{
    "yelouafi": "thanks!\n. Thanks!\n. Thanks again! Glad you like it :)\n. > What do you think? Am I making sense here? Have I missed something that makes this infeasible, not useful, or hard?\nIf I understand it's about 2 things\n- first being able to trace each effect yielded by the Saga\n- second is being able to build some kind of control-flow model from the above list\nThe first thing seems easy to implement. However we can't do that by wrapping effect creators (take, put, ...) because they are just pure functions so they are not aware of the context that created them (in test or in real code). Instead it can be added in the proc function (the one that drives the generator). \nWe can for example make the middleware accepts an effectMonitor callback, the effectMonitor will be called each time an effect is executed like effectMonitor (nameOfSaga, effect) (in replay sessions the Devtools can simply replay with the recorded results). And so you can process the log data in the way you like: log into the console, render in an UI or whatever else.\nThe second thing: I need to more understand the desired output: this control flow graph\n\nwe could potentially build a graph of saga control flow and trace action history through the sagas that generated it.\n\nBy graph of saga control flow do you mean a call hierarchy of Sagas -> child Sagas/functions ? so we can for example log something like (* to distinguish generators from normal functions)\n*watchFetch\n   action FETCH_POSTS\n   *fetchPosts\n         action REQUEST_POSTS\n         call (fetchPosts)\n         action RECEIVE_POSTS\nAt first glance this seems doable, for example we can add a field which is the current call path. So now we can call the effectMonitor(currentCalPath, effect)\nso for the sample above it would give something like\n// flat list of effects\n[\n  saga: '*watchFetch', args: [], path ''\n  action: FETCH_POSTS, path:  ['*watchFetch']\n  call: *fetchPosts, args: [], path: ['*watchFetch']\n  action REQUEST_POSTS, path: ['*watchFetch/*fetchPosts']\n  ...\n]\nAnd the log handler can transform this list into the desired control flow \nThis is kind of a quick thinking. We need also to represent other kind of effects in the control flow model : paraellel effects, race, fork, join\nSo to recap\n- The Saga driver can provides all data that it processes to a logger callback\n- The main question is how to map all the kind of effects into that control flow graph\n\nEDIT: sorry fixed the last list\n. let's see if I understood you correctly. I'll call the Sagas/effects tasks in the following\n\nWhen started, each task is giving an ID, and optionally the parent's ID of an already started task\nEach time a task is started I notify the monitor with something like monitor.taskcreated(id, parentId, taskDesc) and now we have a hierarchy of tasks\nEach time a task yields an effect I call the monitor.effectTriggered(taskId, effectId, effectDesc) so now the monitor can locate in which place in the call tree the effect was issued\nAnd for tasks that return results (usually promised functions) when the result is resolved I call monitor.effectResolved/Rejected(taskId, effectId, result)\nI saw the cerebral video and a couple of others. It seems the fact that the control flow being described declaratively helps a lot for tracing each operation. and with the state atom and cursor like operations every single mutation can be traced. In Redux the finest you can get is at the action level (which can leads to multiple mutations). More flexibility but less control.\n. @gaearon I pushed a new branch for experimenting. This is not so big, but can serve as a starting point to refine the model\nRight now, the middleware can dispatch low level actions (defined here).  usage example here\nThis forms a kind of a DB with 2 tables: tasks and effects, with parent/child relation from tasks to effects, and a hierarchical  parent/child relation on the tasks table itself. so we can construct different 'views' or 'queries' from this. Actually  I can think of 2 different views\n- a view per Saga: we can watch saga progression (receiving actions, firing effects, nested sagas)\n- a view 'per action': means upon each UI-dispatched action, picks all sagas watching for that action and show their reactions below the triggered action; this is quite semblable to how Cerebral debugger work. But seems more challenging to implement (but not impossible)\n. Reworked the monitoring branch. \nFirst, Sagas events are now dispatched as normal Redux actions, so you can handle them by a normal middleware and/or reducer.\nSecond there are only 3 actions:  EFFECT_TRIGGERED, EFFECT_RESOLVED, EFFECT_REJECTED. Every effect is identified by 3 props: its Id, its parent ID (forked/called sagas, child effects in a yield race or a yield [...effects]) and optionally a label (to support  yield race({label1: effect1, ... }))\nThere is an example of a saga monitor that watches all monitoring actions and update an internal tree. You can play with all examples (except real-world), by running the example and dispatching a {type: 'LOG_EFFECT'} action to the store whenever you want to print the flow log into the console (the store is exposed as a global variable to allow playing with it).\nfor example\n```\nnpm run counter\n// execute some actions\n// in the console type this \nstore.dispatch({type: 'LOG_EFFECT'})\n```\nBelow a sample snabpshot \n\nAnother snapshot from the shopping-cart example\n\n. Happy you liked it! It took some tweaks but chrome console api is really awesome\n. @davej Yes but unit tests are needed before making a separate release\n. @pke (sorry for the late answer) Those are either sagas called directly without the declarative form yield saga() instead of yield call(saga) or either using yield takeEvery(...) instead of yield* takeEvery(...) (the later could be fixed thou)\n. @DjebbZ Right now it looks like there is only 1 channel defined which is the Redux Store'actions (in && out). \nWhen I defined the fork/join tasks. I considered the idea of using other channels in order to allow concurrent tasks inter-communication. But I think this would make it hard to reason about the actual control flow of the program. I prefer the structured programming approach (routine/subroutine) which makes the control flow more explicit and easy to track.\nEventually, we'd have to provide some synchronization mechanism between forked tasks. I'm still thinking about it, But I'm more willing  to a more restrictive approach like some pipe operation to connect one Task's output to another Task's Input. \n. As @slorber said, async/await makes testing difficult. see Declarative effects section\n. > However, the caching system in the \"real world\" example would probably be harder to write without getState: https://github.com/yelouafi/redux-saga/blob/master/examples/real-world/sagas/index.js\n\nI would like to see how you could handle that without getState :)\n\nYes, that's because the loadUser is forked and not called. \nA possible solution is to declare loadUser inside watchLoadUserPage so it can access its local state (same principle can be applied to loadStarred)\n``` javascript\nfunction* watchLoadUserPage() {\n  let userCache = {}\n  while(true) {\n    const {login, requiredFields = []} = yield take(actions.LOAD_USER_PAGE)\n    yield fork(loadUser, login, requiredFields)\n  }\n// load user unless it is cached\n  function* loadUser(login, requiredFields) {\n    const user = userCache[login]\n    if (!user || requiredFields.some(key => !user.hasOwnProperty(key))) {\n      userCache[login] = yield call(fetchUser, login) // update the cache\n    }\n  }\n}\n```\n. Thanks!\n. @satispunk I've uploaded a fix to the generator test. This isn't yet released on npm, could you try with the latest source on this repo and confirm the issue has gone ?\n. I understand, I released a patch version '0.3.2'. I m pretty sure it would fix the problem, but wanted a confirmation. You can try with it and confirm me if it's Ok.\n. Great! And thanks!\n. Thans!\n. @bgerm I released a new patch version on npm with the fix suggested by @gaearon. Could you try and confirm if it's ok now ?\n. Great! I'll close the issue. Thanks!\n. > Is there, instead, some way we could watch for the completion of a set of sagas?\nIf I understand, this is only related to 'startup sagas'. i.e. sagas that do some startup tasks (like initial data fetching) then termintates\nActually, the saga runner returns a promise, it's used internally by the middleware. But it's certainly possible to expose those promises to the outside.\nA possible way is to return an array of promises attached as a prop to the middleware function\n``` javascript\nimport { createStore, applyMiddleware } from 'redux'\nimport runSaga from 'redux-saga'\nimport sagas from '../sagas' // [startupSaga1, saga1, ...]\nconst sagaMiddleware = runSaga(...sagas)\nconst [startupPromise1, ...] = sagaMiddleware.promises\nconst createStoreWithSaga = applyMiddleware(\n  sagaMiddleware\n)(createStore)\n```\n. What do you mean by not invoked. All sagas are ran at startup. Do you mean sagas that run only on server ?\n. I understand (I think). You don't have to wait for all of them, but just pick the ones you want.\nFor example, say you have a root startup Saga that will fire all the bootstrap tasks\n``` javascript\nfunction *startupSaga() {\n// will terminate after all the calls resolve\n  yield [\n    call(fetchUsers),\n    call(fetchOrders),\n    ...\n ]\n}\nfunction* clientOnlySaga() { ... }\nexport default [startupSaga, clientOnlySaga, ...]\n```\nyou can pick only the first one and wait for it\n``` javascript\nimport sagas from '..'\nconst sagaMiddleware = runSaga(sagas) \nconst [startupSaga, ...otherSagas] = sagaMiddleware.promises\nstartupSaga.then(render)\n```\n. @slorber \n\nOnce the app starts on the frontend, the saga will start and now that frontend saga is still waiting for a ONBOARDING_STARTED event. You see what I mean?\n\nyes. And it seems inherent to the Saga approach.\n@dts \n\nI don't think that half-executed sagas and server-side rendering are going to play nicely\n\nUnfortunately, that's true. While reducers can be started at any point in time (given a state and an action), Sagas need to start from the beginning.\nTaking the onboarding example; care must be taken as @dts pointed to account on events that may have already occurred on server side\njavascript\nfunction* onboarding(getState) {\n  while ( true ) {\n    if( !getState().isOnBoarding )\n      take(ONBOARDING_STARTED)\n    take(TODO_CREATED)\n    put(SHOW_TODO_CREATION_CONGRATULATION)\n    take(ONBOARDING_ENDED)\n  }\n}\nBut I'm pretty sure you see the issues with this approach. We can't start the onboarding saga from some arbitrary point (for example from the take(TODO_CREATED) point). We'd have to specify from what point we would take the lead.\nanother possible solution is somewhat related to #22. If we record the event log on the server. We can replay the Saga on the client: replay means we will advance the saga with the past event log and the recorded responses from the saga on the server\n. > yes I was thinking of something similar, but while you replay you'll probably want to stub the side-effects. It becomes quite complicated\nMaybe not. on this post @youknowriad mentioned the term pure generators to denote the fact that sagas dont execute the effects themeselves. This gave me some ideas\n- a pure function is a function that - given the same inputs - will always produce the same outputs\n- a pure iterator is an iterator that - given the same sequence of inputs - will always produce the same sequence of outputs.\n~~I m aware the 2nd definition isn't quite exact, because reexecuting effects yielded by the iterator can lead to different results. But~~ we can assign an ID to each newly started saga - as @gaearon mentioned in https://github.com/yelouafi/redux-saga/issues/5#issuecomment-166494953 - the ID will be an ordinal - i.e. 5 means the 5th started saga. \nSame thing for yielded effects, assign an ordinal num. to each yielded effect.\nIf we know that sagas/effects are always triggered in the same order\n- on the run phase, we can record all called/forked sagas and yielded effects as well as the results of running each effect.\n- on the replay phase, an iterator player will iterate on each iterator getting yielded effects/sagas. for each triggered effect it will locate the previously recorded response by the pair sagaNum/effectNum and resume the iterator with it\nI know this sounds a bit theoritical right now. But if the 'effects are always triggered in the same order' assumption can hold for most cases, I think the above solution is doable\n. > Is there any problem with this approach?\nNot AFAIK, but the only cases I saw with universal apps involved doing an initial render on the server given some route and sending the initial state + UI to the client.\nBut this also means it'd be hard or complicated to do hot relaoding/time travel on Sagas\n@slorber I m bit curious on how an event like ONBOARDING_STARTED would fire on the server.\n. After all the comments above. I think the preferred way is to provide an external method runSaga. So we don't have to provide 2 different store configs for the client and the server\njavascript\nrunSaga(saga, store).then(...)\nthe store argument will allow the saga to still dispatch actions to the store on the server (and possibly take actions from it)\nDo you think this method is better than returning the end promise directly from the middleware function https://github.com/yelouafi/redux-saga/issues/13#issuecomment-166953222\n. Added runSaga support to the master branch. With a slight modification; the function returns a task instead of the promise (so we could cancel the task when cancellation support will be enabled)\n``` javascript\nconst task = runSaga( someSaga(store.getState), store )\ntask.done.then( renderAppToString )\n```\nThe same method can also be used on the client (to handle use cases issued in #23) Here is an example of running the saga from outside in the async example (It feels the 2 bootstrap methods -runSaga and middleware- are somewhat redundant)\nThis is not released yet on npm. I'm waiting for any feedback before making a release\n. @dts it will only resolve with the main one. If you want to wait on some or all forked sagas, you have to use join to wait their termination\n. @ashaffer\n\nA better approach, I think, is to create some function of state that decides when to complete the rendering process on the server. E.g. isReady(state) is true when no relevant sagas are in progress. \n\nThis is what @slorber  suggested (https://github.com/yelouafi/redux-saga/issues/13#issuecomment-168042166). \nBut with runSaga I think @gaearon solution (https://github.com/yelouafi/redux-saga/issues/13#issuecomment-168189380) will work for most cases without having to maintain 2 saga middleware configs (client and server). I don't really like the monkey patching solution used to make this work. But as mentioned in #23 runSaga maybe necessary for apps using code splitting (i.e. we don't know all the sagas to run at the start time). \nIf somoene has a better idea I'll take it, but for now runSaga seems to solve both issues.\n. @tappleby your solution makes more sens. It has also the benefit of patching the store only once (i.e. with multiple calls to runSaga). My only concern is with using store enhancers themselves. If someone would use a store config like this\njavascript\nconst finalCreateStore = compose(\n  applyMiddleware(...middleware),\n  reduxSagaStoreEnhancer(...startupSagas),\n  reduxRouter(),\n  devtools.instrument()\n);\nthat's perhaps too much enhancers.  I dont remember exactly where, but I learned that using multiple store enhancers may present some issues with action dispatching, because each store enhancer has its own dispatch method, but I m not sure if this applies to the present use case.\n. I'll close this as the current version added the standalone runSaga function. Feel free to comment. I can reopen the issue if needed\n. join can be called only with one task. In your code yield [...] returns an array of tasks so you've to write something like\n``` javascript\nfunction* rootSaga() {\n  // yield array of forks -> array of tasks\n  const taskList = yield [\n    fork(subtask1, ...args),\n    fork(subtask2, ...args),\n    ...\n  ]\n// yield array of joins -> will return after all tasks terminate\n  yield taskList.map(join)\n}\n```\n. @pavelkornev \n\nI mean, we can register all sagas on the server like we do on the client, then emit actions to run them, but when to render?\n\nyou can run your server sagas from outside using middleware.run\nmiddleware.run(saga) will return a Task object. You can use task.done which is a Promise that resolves when the Saga ends, or rejects when the Saga throws an error\n``` javascript\nimport serverSagas from './serverSagas'\nimport sagaMiddleware from './configureStore'\nconst tasks = serverSagas.map(saga => sagaMiddleware.run(saga))\ntasksEndPromises = tasks.map(t => t.done)\nPromise.all(tasksEndPromises).then(render)\n```\n. @pavelkornev That would be great! thanks\n. see #255. \n. @pavelkornev \n\nIt's not that obvious how to fix it. I would ask @gaearon as an author of these dev tools for an advise.\n\nFYI, this solved it for me. The solution is to wrap the server-rendered react markup in an additional div\nhttp://stackoverflow.com/questions/33521047/warning-react-attempted-to-reuse-markup-in-a-container-but-the-checksum-was-inv?answertab=active#tab-top\n. > The following is my opinionated approach\nFirst, I dont recommend calling service directly within sagas, it'd be better to use declarative calls. It makes possible testing all the operational logic inside the generator as explained in the declarative effects section\nSo I'll first refactor localStorage calls into some isolated service\n``` javascript\n// Side effects Services\nfunction getAuthToken() {\n  return JSON.parse(localStorage.getItem('authToken'))\n}\nfunction setAuthToken(token) {\n  localStorage.setItem('authToken', JSON.stringify(token))\n}\nfunction removeAuthToken() {\n  localStorage.removeItem('authToken')\n}\n```\nAnother remark is regarding action watching flow. It'd be easier if you exploit the Structured programming benefits offered by generators. I'll illustrate with a simple example, suppose our flow is just this simple sequence\nSIGN_IN -> AUTHORIZE -> SIGN_OUT\nInstead of doing something like\n``` javascript\nwhile(true) {\n  const action = take([SIGN_IN, SIGN_OUT])\nif(action.type === SIGN_IN)\n     const token = yield call(authorize)\n     yield call(setAuthToken) // save to local storage\n     yield put(authSuccess, token)\n  else\n     yield call(removeAuthToken)\n     yield put(signout)\n  }\n}\n```\nYou can exploit the fact that SIGN_IN and SIGN_OUT fire always in sequence and never concurrently and offload the flow control burden (where are we in the program right now ?) to the underlying generator runtime  (I simplify to illustrate the concept, I ll introduce concurrency next)\n``` javascript\nfunction* authFlowSaga() {\n  while(true) {\n    // first expect a SIGN_IN\n    const {credentials} = yield take(SIGN_IN)\n    const token = yield call(authorize, credentials)\n// followed by a SIGN_OUT\nyield take(SIGN_OUT)\nyield call(signout)\n\n}\n}\n// reusable subroutines. Avoid duplicating code inside the main Saga\nfunction* authorize(credentialsOrToken) {\n  // call the remote authorization service\n  const token = yield call(authService, credentialsOrToken)\n  yield call(setAuthToken, token) // save to local storage\n  yield put(authSuccess, token) // notify the store\n  return token\n}\nfunction* signout(error) {\n  yield call(removeAuthToken) // remove the token from localStorage\n  yield put( actions.signout(error)  ) // notify th store\n}\n```\nBefore introducing concurrency, let's first introduce the refresh cycles, when the token expires w'll send again a request to the server to get a new token. so our sequence will become now\nSIGN_IN -> AUTHORIZE -> REFRESH* -> SIGN_OUT\nREFRESH* means many refreshes i.e. a loop in the generator\nWe're still forgetting concurrency to keep things simple and progress step by step\n``` javascript\nfunction* authFlowSaga() {\n  while(true) {\n    const {credentials} = yield take(SIGN_IN)\n    let token = yield call(authorize, credentials)\n// refresh authorization tokens on expiration\nwhile(true) {\n  yield wait(token.expires_in)\n  token = call(authorize, token)\n}\n\nyield take(SIGN_OUT)\nyield call(signout)\n\n}\n}\n```\nBut we've an issue there, the refresh loop executes forever, because there is no breaking condition. If the user signed out between 2 refreshes we've to break the loop. So the breaking condition is the SIGN_OUT action. Also the SIGN_OUT action is concurrent to the next expiration delay, So we have to introduce a race between the 2 events\n``` javascript\nfunction* authFlowSaga() {\n  while(true) {\n    const {credentials} = yield take(SIGN_IN)\n    let token = yield call(authorize, credentials)\nlet userSignedOut\nwhile( !userSignedOut ) {\n  const {expired} = yield race({\n    expired : wait(token.expires_in),\n    signout : take(SIGN_OUT)\n  })\n\n  // token expired first\n  if(expired)\n    token = yield call(authorize, token)\n  // user signed out before token expiration\n  else {\n    userSignedOut = true // breaks the loop and wait for SIGN_IN again\n    yield call(signout)\n  }\n}\n\n}\n}\n```\nBut there are 2 othe issues, first the authorize saga may fail if the remote server responded with an error (e.g. invalid credentials, network error ...). And second, there is another concurrency issue, what if the user signed out in the middle of a refresh request/response cycle ? We'd have to cancel the ongoing authorization operation.\nSo first, we've to refactor our authorize saga\n``` javascript\nfunction* authorize(credentialsOrToken) {\n  const {response} = yield race({\n    response: call(authService, credentialsOrToken), \n    signout : take(SIGN_OUT)\n  })\n// server responded (with Success) before user signed out\n  if(response && response.token) {\n    yield call(setAuthToken, response.token) // save to local storage\n    yield put(authSuccess, response.token)\n    return response.token\n  } \n  // user signed out before server response OR server responded first but with error\n  else {\n    yield call(signout, response ? response.error : 'User signed out')\n    return null\n  }\n}\n```\nNow if a remote authorization fails, we signout the user and return null as token. So we've also to refactor our main Saga to take into account the failure (null return value)\n``` javascript\nfunction* authFlowSaga() {\n  while(true) {\n    const {credentials} = yield take(SIGN_IN)\n    let token = yield call(authorize, credentials)\n    // authorization failed, wait the next signing\n    if(!token) \n        continue\nlet userSignedOut\nwhile( !userSignedOut ) {\n  const {expired} = yield race({\n    expired : wait(token.expires_in),\n    signout : take(SIGN_OUT)\n  })\n\n  // token expired first\n  if(expired) {\n    token = yield call(authorize, token)\n    // authorization failed, either by the server or the user signout\n    if(!token) {\n      userSignedOut = true // breaks the loop\n      yield call(signout)\n    }\n  } \n  // user signed out before token expiration\n  else {\n    userSignedOut = true // breaks the loop\n    yield call(signout)\n  }\n}\n\n}\n}\n```\nNow, we can think of the left requirement. What if there is a token already in local storage ? We'll simply skip the take(SIGN_IN) step and refresh immerdiately\n``` javascript\nfunction* authFlowSaga() {\nlet token = yield call(getAuthToken) // retreive from local storage\n  token.expires_in = 0\nwhile(true) {\n    if(!token) {\n      let {credentials} = yield take(SIGN_IN)\n      token = yield call(authorize, credentials)\n    }\n// ... rest pf code unchanged\n}\n```\nSo IMO we should follow as much as we can the following\n- isolate side effects functions (api calls, dom storage, ...) into separate services. This includes JSON.parse or stringify, or also wrapping api call results into {result} or {errors}\n- implement your flow step by step, starting by the simplest assumptions, then progressively introduce more requirements (concurrency, failure). The code will emerge naturally from this iterative process.\n- follow the Structured Programming approach. An if test makes only sens if we're waiting for concurrent effects (using race) or conditional results (success or error)\n- Your code flow should reflect closely the corresponding flow of events. If you know 2 events will fire in sequence (e.g. SIGN_IN then SIGN_OUT) then write 2 consecutive takes (take(SIGN_IN) then take(SIGN_OUT)). Use race only if there are concurrent events.\nAs I said, the main benefit of using Generators is that it allows to leverage the power of Structured Programming and routine/subroutine approach. do you think that humans could write such complex programs using only goto jumps ?\n. @aikoven you may take a looke at task-cancel branch its incomplete (use a generic error) but it seems to work (Need more tests though).\n. > The obvious (though admittedly horrible) alternative is a more \"opt-in\" system where you check against some state variable whether or not the current thread has been canceled (this.isCanceled() or whatever). Are there any other thoughts on the mechanics for this cancellation?\nAFAIK The behavior of this inside a generator is unspecified. It may point to the global object (window).\n. I think this is more related to React/React-redux than redux-saga itself.\nRelated to 'physical rendering' (patching the real DOM) I think there is no worry here because React will batch (or debounce) multiple renders in the next animation frame.\nNow for the 'logical render' (calling the render method of components) I can't say. It depends on how React-redux is implemented. Maybe @gaearon can tell us more about this.\n. > React won't batch renders by default but you can tell it to\nDidn't know that. I thought that animation frame debouncing was automatic\n. So, if we dispatch all actions inside the same (micro)-task queue, this will be fine.\n. micro tasks (like used by promise.then) are executed withing the same event loop. Meaning even if the overall code triggered by the event handler dispatches multiples actions, We'll stay in the same event loop cycle, If React doesn't touch the DOM during this interval, no browser render will occur.\nI mentioned them because redux-saga dispatches actions from Sagas using microtasks (using promises). If you look at the real-example bootstrap code you'll see I m delaying the render until the next animation frame. Otherwise, the Render will occur synchronously, and the Sagas may miss some startup events (especially the Router related events) because take effect will run only on a future microtask. \nusing requestAnimationFrame ensures Sagas are ready to take actions before the UI starts to fire anything. requestAnimationFrame will always be scheduled in a new macro-task, i.e. after all scheduled microtasks terminate \n. > I guess for put/take you will follow FSA conventions so if one follow these conventions he would still be able to plug the proc to its own system.\nCould you elaborate on this ? I saw the FSA repo as well as how it's used by redux-promise/redux-rx middlewares. But I m not sure if I understood correctly how this can be exploited in redux-saga. \n. @slorber What you said makes sens. It's just that being a Redux middleware actually. The project has more visibility (I'm really thankfull to @gaearon for all the RTs and mentioning the project in various place). This means it has more chance to be used in real world scenarios. And also benefits from more contributions.\n. @youknowriad a project a with similar idea https://github.com/weo-edu/yio\n. @joshrtay looked rapidely at this and I m really impressed! The concept of mapping/reducing a generator is both simple and powerful. And I like how you leverage composition in your code. \n. One difference though is that you still fire the flow on each action. While Redux saga treats incoming actions themselves as part of the flow.\n. @youknowriad seems interesting. Will take a deeper look later. Is the match func necesary ? You can return the boolean directly from resolve to indicate a successful match\n. @joshrtay not sure to undrestand what the code do. But redux-saga has to take care of some extra things like cancellation propagation,  which is a little bif too awkward to express by the map/reduce pattern (or at least i have to think about it). \nAlso I like the idea of control flow units expressed as middlewares\n. @youknowriad FYI rewrote the redux-saga core without promises. It was necessary to get rid of all mentioned issues and have a predictable order of things, the code is the no-promise branch. Trickiest part was to propagate cancellations (sort of control flow inversion), but finally works, and all tests cases pass. \n. Not sut but maybe I'll make a separate repo to expriment with other things (csp channels, maybe actors. if i've got the time of course). \n. > But if called subroutine is in progress when parent routine is cancelled, then there is no way to actually cancel subroutine.\nThanks for drawing my attention on this. I was too focused on forked tasks.\nThere are some more issues i'd like to discuss\n1- taking into account that a task can be blocked on multiple calls. for example\njavascript\nfunction* task() {\n  const [r1, r2] = yield [call(subtask1), call(subtask2)]\n}\nwe need to cancel both subtasks if task is cancelled while waiting for the 2 subtasks to complete.\n2- making task cancellation declarative. so instead of task.cancel() we write yield cancel(task). I think it makes more sens since fork and join are already declaratives\n3- Do you think we should automatically cancel called subtasks that have lost in a race. for example\njavascript\nfunction* task() {\n  ...\n   const {timeout} = yield race({\n      timeout: call(delay, 1000),\n      subtask: call(subtask)\n    });\n}\nif timeout wins the race, should we automatically cancel the call(subtask) ?\n. @aikoven great work! thanks :+1: .\nMy only doubt is on the automatic race cancellation. we should cancel the cancellable/competing effects. I looked quickly, but it seems like you're cancelling subroutines of the Saga that is running the actual effects.\n. @aikoven \nSorry. It seems like your code is correct after all. If the Saga that is running the actual race advances; all pending subroutines should be cancelled as we're no longer blocked on them.\n. > You are right, my code will go wrong if there was another called subroutine outside of race, e.g.:\nOops! merged too soon!\n. I reverted the merge. Not sure however if this will reactivate the PR\n. > Generators seems to allow an user-friendly syntax but also seems to introduce some kind of implicit state and I don't really see how to deal with that.\nIMO it's not only about Generators. Although I agree that the flexibility offered by Generators makes it a bit harder to achieve. I think it's more related to the complex nature of long-running flows, I mean flows which span across multiple actions.\nEven if we implement a saga as a state machine which reacts to a sequence of actions like we can do actually with redux-thunk (or even in a more restrictive way like in Cerebral). It doesn't mean we can time travel - correctly - that code. Time travel is driven by the event-log/actions (at least in its actual conception). Give me an action, the previous state. I'll give you an output and the next state. But imagine a long-running authorization flow \nSIGN_IN -> authorization -> SIGN_OUT\nIn theory, you can time travel the code managing the above flow - and probably it`s easier with a state machine like approach -. But imagine you change requirements of the above flow into something like\nSIGN_IN -> authorization -> (refresh with timeout of 5 mins) -> SIGN_OUT\nYou change your code and hot reload it, how to replay actions with the new state machine code ? the whole flow has changed, it means the state machine will probably produce a new sequence of actions: the recorded event log is no longer valid, so it wont make sens to reply it. \n. Time travelling Sagas, IMO, is not the real challenge. If we record the states at the different breakpoints (i.e. yields) of a saga. We can travel to any point in the past and see the app/state at that point. We can even time travel different Sagas independently, as if there is a local time for each saga (vs the global time defined in the current devtools)\nwhat's really challenging is hot reloading saga code. And this is a conceptual issue, because modifying an existing saga code can lead to an action path totally different from the recorded one. Hot reloading Sagas can change the past. At the point of time a hot reloaded Saga dispatches an action different from the one dispatched in the old saga code, the remaining actions in the log no longer make sens, because we can now have a future totally different from the recorded one.\nA possible way to hot reload control flow, IMO, is to replay the control flow from the beginning. We have to exclude any 'saga triggered action' from the log and take 'the user triggered actions' as a single source of truth: something similar to what @slorber called 'command sourcing' (https://github.com/yelouafi/redux-saga/issues/8#issuecomment-167101351). Then we have to replay the Saga from the beginning by re-dispatching the recorded user actions to the store. So we'll effectively recompute a new action log. A side issue of this approach is that replaying the Saga will re-triggers all api calls inside the Saga (or possibly will trigger new api calls with the modified saga code). But at least we don't have to repeat the UI actions manually to test the new Saga code. \nThose UI triggered actions seems more like Cerebral signals. A user triggered action can lead to different cascaded actions (like REQUEST -> SUCCESS) fired by the Saga. So instead of a flat view of the action log (like the actual devtools view), we'd have a structured view : user actions/program actions\nthis approach would also enable devtools to work with any other async middleware, as long the devtools can \n1- make a distinction between user actions/program actions\n2- link program actions to their parent user actions\n. @gaearon \n\njust pausing existing sagas and restarting hot reloaded ones would cover most cases where you\u2019d care about hot reloading them\n\nthe issue is most of the time you have only one root saga that is visible to the external world; the rest of Sagas are started 'internally' using fork/call. W'll have to determine where the modified Saga is actually in the execution tree (there maybe many instances)? and more importantly we need to determine the impact of hot reloading this Saga on other running Sagas. The most predictable way I can think of is to replay the top level Saga withe the event log (see below)\n@hoschi(thanks for sharing this)\nSo in your solution you restart all Sagas. In the case of simple watchers (watch-and-fork) it's sufficient. But note in the case of a more complex Saga (say an authorization saga in the middle of a login/logout) restarting the Saga will put it at the beginning of the flow. \nThere is also the issue of the already running tasks, normally if you have only forked sagas (non spawned) it should be sufficient because cancelling the root Saga will cancel all forked tasks on the execution tree. But in the case of non attached forks (via spawn Effects) it won't work.\nThe solution I had in mind is to replay the Sagas with the past event log: But then we have to distinguish between 2 classes of actions\n1. External Actions (User, Websockets, ...): I'll call those Events\n2. Internal Actions (dispatched by the app in reaction to Events) I'll call them just Actions\nSo if we hot-reload the Saga code we replay the Sagas only with past Events, which may trigger a different internal Action log (e.g. Saga changed from dispatching ACTION_1 to dispatching ACTION_2 in reaction to an event).\nThere is still the issue of the api calls: we can memoize api calls to avoid hitting the server, but in the case the changed Saga code trigger Api calls with different arguments then in this case w're forced to make a real API call (or throw a message to the user/developer)\n. While I understand the code splitting requirement. I tend to not agree with starting sagas from inside containers elements. Perhaps, it'd be better to start the dynamic sagas in the same place we update the store. For example, if we load some dynamic module with new reducers and sagas I can imagine\njavascript\nfunction updateAppWithNewModule(module) {\n  updateStoreWithNewReducer( module.reducer )\n  runSaga(module.saga)\n}\nFYI, I've already pushed changes in the master branch which include runSaga support (along with monitoring support). \n. > though I have been curious if proc could be used locally within a component to manage complex flows\ntechnically yes. actually proc has a signature like (iterator, subscribe, dispatch) -> Promise. So you can hookup take and put to any external input/output (aka csp channels). But I wouldn't recommend using an internal function, as the signature may change in the future.\nThis is another item on my todo list. Initially, I imagined runSaga(iterator, {subscribe, dispatch}) which would work with Redux Stores out of the box. But the store doesn't actually provide the triggered action to its subscribers, and I read in a related Redux issue that this is intentional (https://github.com/rackt/redux/issues/1057).\nAnother solution I m considering is keeping the generic runSaga(iterator, {subscribe, dispatch}) and exposing the utility function storeChannel so we'll end up with something like\njavascript\nrunSaga( iterator, storeChannel(store) )\nWith the benefit of being able to connect the Saga to any external channel\n. > Is there a common interface that other libraries seem to be using for channel like functionality? closest thing I can think of is Rx.Subject\nNode duplex streams seems to mimics channel's take/put, but uses 2 independent channels reads/writes. It doesn't also use promises for communication\n. FYI. the new v0.4.0 supports runSaga\n. Thanks!\n. Sorry, But I'll have to raise some issues again\n- for parallel effects [call(saga1), call(saga2), effect]. If effect is rejected the whole [...] effect will be rejected. The saga will progress (through a try/catch or by throwing to its parent) with the rejected effect alone, se we have also to cancel the other calls inside the array \n- In race({c1: someEffect, c2: join(task)}). if c1 wins c2 should also be cancelled IMO. But the actual code will skip it because the promise result (task._done) doesn't define a _cancel method\n- It's not only related to subroutines, for example if we have\njavascript\nyield race({\n  c1: call(saga1),\n  c2: [\n    call(saga2),\n    call(saga3)\n  ] \n})\nIf c1 wins the race, we should cancel the 2 calls inside c2. But since the promise returned by the parallel effect (Pormise.all(...)) doesn't have a _cancel method it will be skipped and the inner calls will continue to execute. \nIMO, we're takling the problem from the wrong angle, i.e. we're too focused on the cancellation of sagas. we should think in a more generic way: the cancellation of effects themeselves. Effects are composables. We can exploit this to make cancellation also composables;\nLet's start with a simple assumption: all effects are cancellables (e.g. their promise results define a _cancel method). We have to specify 3 things\n1- Semantics of cancellation for each effect type\n2- Semantics of automatic cancellation\n3- Semantics of manual cancellation\nSemantics of cancellation for each effect type\n\ncancelling raw promises, as well as results of normal function calls (call and cps) is noop (until promises support cancellation, we can simply set promise._cancel = () = {} ) \ncancelling the result of a put effect is noop\ncancelling the result of a take effect can be achieved by simply setting the deferredInput to null (we could also support multiple concurrent/parallel takes by allowing an array of deferred inputs).\ncancelling the result of a fork effect is noop\ncancelling the result of a join effect is trivial since the end promise of a forked task should already have a _cancel method, idem for raw iterators (we could set this directly in the body of proc)\ncancelling a parallel effect [...] means cancelling all sub-effects on the array\ncancelling a race effect means cancelling all the competing sub-effects\ncancelling a saga call result means:  1- cancelling the current effect result where the saga is blocked (could be anything, we don't care), and 2- throwing a SagaCancellationException \ncancelling the result of cancel effect is noop (we cannot undo the effect of a cancellation)\n\nSemantics of automatic cancellation\nAutomatic cancellation can be triggered in tho following cases\n- in a race effect, cancel all sub-effects except the winner\n- in a parallel effect, if a sub-effect is rejected, cancel all other sub-effects\nSemantics of manual cancellation\n\na manual cancellation can only be triggered via yield cancel(...)\nyield cancel can only be called on tasks created via fork\n\nUnless I miss something, I think the above approach will allow us to tackle the problem in a generic way. It's composable so we can relay on recursion to handle all the edge cases\nWhat do you think ?\n. > We can also make automatic cancellation of parallel / race effects simpler: just cancel the whole parallel / race effect after it completes. Race winner subroutine will already have _isRunning = false so _cancel becomes noop and we won't have to filter losers from winner.\nYes, that makes things simpler. This adds another rule to the semantics above\n- cancelling an already resolved/rejected effect is noop\nPerhaps _isRunning should be defined in a generic way\n``` javascript\nrunEffect(effect) {\n  const promise = (...)\n  const done = () => promise._isRunning = false\npromise.then(done, done)\n  promise._isRunning = true\n  return promise\n}\ncancelEffectResult(promise) {\n  if(promise._isRunning)\n     promise._cancel()\n}\n```\nin Promise.all/Promise.race blocks, child promises complete always before the parent promise, and their then blocks are also ran before completing the parent; so the order is Ok (done will be executed before completing the parent all/race promise)\n. I think we should not prevent propagation. All cancellables Sagas should catch cancellation exceptions to do any cleanup. If the canceled Saga omit this; then the parent could handle the exception (for example, if one cleanup is relevant to mulitple child called sagas, the parent saga can handle the cancelltion exception).\nOtherwise, we should IMO propagate the exception as JavaScript does with normal errors\n. > If we start two subroutines without handlers in parallel, then if first one fails then the second will be cancelled. Which exception should be pulled to parent?\nI'd say the synchronous flow of things suggests to throw the cancellation exception, because it was raised while proc is trying to handle the resolution of the parallel effects. for example looks at this simplified code of proc\n``` javascript\nproc(iterator) {\nconst endPromise = ...\n endPromise._cancel = cancel\ncancel() {\n    next(CancellationException(), true)\n  }\nnext(arg, isErr) {\n    try {\n       const result = isErr ? iterator.throw(arg) : iterator.next(arg)\n       runEffect(result.value).then(next, err => next(err, true))\n   } catch(err) {\n      reject(endPromise)\n   }\n  }\nrunParallelEffects(effects) {\n    const promises = effects.map(runEffect)\n    const result = Promise.all(promises)\n    const done = isErr => val => {\n      promises.forEach(p => p._cancel())\n      return isErr ? Promise.reject(val) : val\n    }\n    return result.then(done(), done(true))\n  }\n}\n```\nthe code result.then(done, done) will run before resuming the parent promise with the failed result. If result fails with some subeffect, the code will run the _cancel method on promises consecutively, which will trigger iterator.throw on consecutive subroutines (via next(CanellationException, isErr)), if a subroutine in the list omitted to catch the exception caused by iterator.throw then the exception will propagate to the parent (which is running the actual runParallelEffects) and will throw that Cancellation exception inside it. the uncaught exception will then propagate up to next.\nNow what if a developer already defined a try/catch block inside a main routine\njavascript\nfunction* main() {\n   try {\n     yield put(requestStart())\n     const results = yield [call(subroutine), someEffect]\n     yield put(requestSuccess(results))\n   } catch(err) {\n     yield put(requestFailure(err))\n   }\n}\nif someEffect failed, then we will cancel call(subroutine); if subroutine omitted to define cleanup code then we should propagate the exception to warn the developer and abort subroutine as well as main (the same as normal JS errors abort all code up to the top of the call chain).\nThe issue is that catch(err) is catch-all block and will prevent the Cancellation exception from propagating up; In languages like Java we don't have this kind of problem because we can define multiple catches per Exception type, but this is not possible in JS.\nSo IMO, until JS supports this feature the solution is for the developer to put a guard in his code\n``` javascript\n// reausable guard\nfunction rethrowCancellation(err) {\n  if(err instance of CancellationException)\n    throw err\n}\nfunction* main() {\n   try {\n     yield put(requestStart())\n     const results = yield [call(subroutine), someEffect]\n     yield put(requestSuccess(results))\n   } catch(err) {\n     rethrowCancellation(err)\n     yield put(requestFailure(err))\n   }\n}\n```\nThis kind of explicit solution adds a little burden to the developer, but IMO makes also the code intention more obvious\n\nSuppose that main routine is blocked on yield call(child). Then cancelling main effectively cancels call effect which in turn throws exception inside child routine. But if child routine caught SagaCancellationException and did not rethrow it, then it won't be thrown in main routine.\n\nBut child don't need to rethrow cancellation, If I'm not mistaken, cancelling main involves 2 operations as defined by our semantical model\n1- first cancel the current effect we're blocked in\n2- throw a CancellationException inside main iterator\nif child catch its cancellation, then good. (2) will throw a Cancellation inside main. If not, also good, the exception will propagate to main; if main defines the rethrowCancellation(err) guard then it'll propagate and warn the developer (Did I miss something ?)\n\nAs for parallel/race effects: when they finish, all losers' resolution is ignored, so any cancellation exceptions should be ignored as well.\n\nHmm.. I feel a bit uncomfortable with this silent failing. A missed cancellation catch will likely point to some bug in the program (developer omitted to define cancellation logic). Warning only on the console won't prevent the parent and its parents on the call chain from continuing, while the conventional JS mechanism is to abort all the routines in the call chain. Since w're trying to mimic the normal JS synchronous control flow, shouldn't we do the same with the propagation mechanism and propagate the first encountered  exception?\n\nThe remaining case is join. I think it should work the same as call: cancelling joined subroutine, then propagating to main routine.\n\nI agree, join should follow the call semantics\n. > First of all, the only way to cancel effect is to cancel routine that is currently blocked on it.\nIMO, it'd be clearer if you view cancellation at the effect level, not the subroutine level. a subroutine is cancelled by 1- cancelling its current effect, 2- throwing a CancellationException inside it. As for (1) it doesn't care what the current effect is: could be a race, all, another subroutine or a simple promise (noop); all it has to do is invoke _cancel on that effect. Composition will look more natural this way, and recursion will take care of all edge cases for us.\n. in thinking about it, perhaps a @@redux-saga/Cancellable symbol is better than a _cancel property. So w'd know that a result is cancelable if it defines that symbol\n. > I propose the following:\n\nIf we have unhandled CancellationException then we stop parent routine immediately with exception; not via iterator.throw(), but by throwing it inside of next()\nAny other exception propagates as usual\nThis way we won't burden developer to write extra boilerplate for rethrowing. And in my opinion it would be easier to reason about execution flow if it was only subroutine's business to handle its own cancellation.\n\nSounds reasonable. \n\nIn regular Promise.race any loser promise rejection would be unhandled and I guess there is no way to warn about it other than just logging to console.\n\nSounds also reasonable, we definitely throw away all losers: they are no longer part of our control flow\n\nAnd in my opinion it would be easier if CancellationException is local \u2014 i.e. if we caught it, then it means that current routine was cancelled from outside, not that some child routine was cancelled.\n\nAgree, it makes more sens.\n. > About cancelling race losers:\n\nWhat if loser had some async cleanup code? Should we wait for it to complete before returning control to parent routine?\n\nconsidering your solution, the response comes naturally. Any race losers are no longer part of our main control flow, any cleanup code they perform becomes independent. Like if they were detached from our main flow.\n. Great! I'll push this into the master branch asap. Hope to make a release tonight.\nThanks again for the great work :+1: \n. Merged. Since the master branch was ahead of the current task-cancel branch I resorted to manual merging.\nI did some minor modifications: SagaCancellationException is constructed with 3 props: type (manual, race auto, parallel auto) which is a defined constant (to work with monitoring), saga which is the current saga being cancelled, and finally origin which is the root saga where the cancel was triggered from.\nFor reporting, I resorted to a simple console.error which will print the above infos\n\nAs for the Saga monitor, manual cancellations are displayed as normal errors,\n\nautomatic cancellation errors are not displayed on loser effects\n\n. FYI. released a new version 0.4.0 with included cancellation support (and other features). \nHere are the docs for task cancellation. Do you have any remarks ?\n. Seems a valid issue to me. yield call( backend.fetch.bind(backend) ) can not be tested easily, because the call backend.fetch.bind(backend) will return a different result each time it's called.\nAdding context (this) support to the call effect is a bit awkward because the call(fn, ...args) is variadic (I dont feel also the form call(null, fn, ...args) for non-class functions)\nI think we should provide another effect creator to handle this case like method(API, fetch, ...args)\n. @tappleby I agree. Your solution looks better\n. FYI. the new v0.4.0 supports the apply effect.\n. > The best thing I can think of is trying to mock the call function to just throw an error\nYou don't have to mock, yield call(...) doesn't execute anything, to test the generator you provide it with dummy responses. To simulate a promise rejection, call throw on the iterator\n``` javascript\nconst cart = {}\nconst getState = () => ({cart})\nconst iterator = checkout(getState)\nassert.deepEqual(iterator.next().value, take(types.CHECKOUT_REQUEST))\nassert.deepEqual(iterator.next(actions.checkoutRequest()).value, call(api.buyProducts, cart) )\n// simulate a promise rejection\nassert.deepEqual(iterator.throw('error').value, put(actions.checkoutFailure('error')))\n```\n. sorry, didnt mean to close it\n. In your 2nd solution, this code\njavascript\nlet [place] = yield [call(api.places.get, id), tx];\nIf call(api.places.get, id) resolves first, it'll have to wait also for tx to complete (which always rejects in your code)\nThe task cancellation would handle this case in a more concise way, until #26 is merged, I'd also use the builtin exception system, but would opt instead for a more declarative way\n``` javascript\n// a higher order function\nfunction buildTx(cancelEffect) {\n  // returns a reusable guarded call subroutine\n  // will throw if cancelEffect completes before call(fn, ...args)\n  return function* guardedCall(fn, ...args) {\n    const {result} = yield race({\n      result: call(fn, ...args),\n      cancelEffect\n    })\nif(result)\n   return result\nthrow new TransactionCancelledError()\n\n}\n}\nfunction* createAudienceSaga (getState) {\n  let action\n  const nextCreateAudience = take(CREATE_AUDIENCE)\n/eslint no-cond-assign:0 /\n  while (action = yield nextCreateAudience ) {\n    yield fork(\n        buildAudience, \n        nextCreateAudience,\n        action.payload);\n  }\n}\n// Create a new audience\nfunction* buildAudienceFromPlaceId(cancelEffect, params) {\n  const tx = buildTx(cancelEffect)\n  try {\n    let place = yield call(tx, api.places.get, id);\n    yield put(showPlace(place));\nconst audienceId = yield\n  call(tx, createAudienceWithDefinition, {\n    definition: params.definition,\n    geography: [makePlaceGeography(place)],\n    product_id: params.product\n  });\n\nconst audience = yield call(tx, api.audience.get, audienceId);\n\nyield put(showAudience(audience));\n\n} catch (e) {\n    if (e instanceof TransactionCancelledError) {\n      console.info(\"Transaction cancelled\", id, product);\n      return;\n    } else {\n      throw e;\n    }\n  }\n}\n```\n. I see, you can also define a higher order effect creator\n``` javascript\nexport function* guard(tx, ...args) {...}\nconst guardedCall = (guard, tx) => call(guard, tx, api.places.get, id);\n// Create a new audience from a place and product id\nexport function* buildAudienceFromPlaceId(tx, id, product) {\n  const callWithTx= guardedCall(guard, tx)\n  try {\n    // Step 1: retrieve the place that the user wants to build the audience in\n    let place = yield callWithTx(api.places.get, id);\n    // ...\n```\n. > I had also considered (but have not tested) the following because it uses private values that might break\nI wouldn't recommend this. As internal representation may change (actually already changed in the current master branch). \n. > Yeah. Again, it means peeling the function instance out of the iterator.next().value\nMaybe I missed something, but is there any issue with the following\ncode\n``` javascript\nexport function* guard(tx, ...args) {...}\nexport const guardedCall = (guard, tx) => call(guard, tx, api.places.get, id);\n// Create a new audience from a place and product id\nexport function* buildAudienceFromPlaceId(tx, id, product) {\n  const callWithTx= guardedCall(guard, tx)\n  try {\n    // Step 1: retrieve the place that the user wants to build the audience in\n    let place = yield callWithTx(api.places.get, id);\n    // ...\n```\ntest\n``` javascript\nimport { guard, guardedCall } from 'wherever';\nlet tx = new Promise(() => {}),\n     callWithTx = guardedCall(guard, tx),\n     iterator = buildAudienceFromPlaceId(tx);\nassert.deepEqual(\n    iterator.next().value,\n    callWithTx(api.places.get, placeId));\n```\n. > The result of a higher-order function is always unique:\nyes, but in our current case we're not comparing the resulting functions but the final value\n``` javascript\nfunction add(a) { return function(b) { return a + b; } }\nassert(add(5)(3) === add(5)(3)); \nassert.deepEqual(\n  guardedCall(guard, tx)(api.places.get, placeId),\n  guardedCall(guard, tx)(api.places.get, placeId)\n)\n``\n. It's not explicit in the docs, but all effect creators likecallare pure functions. for example a call returns an object {fn, args}, so as long you're providing the same inputs, which is the case above for all the 4 arguments, you can expect the same output (in the deepEqual sens)\n. the latest version includes a [runSaga`](https://github.com/yelouafi/redux-saga#dynamically-starting-sagas-with-runsaga) function to start a saga outside of Redux. You can also connects the Saga to a custom input/output.\nOne idea is to use this function to connect a Saga to a React component, I mean for things that uses uniquely the local component state. For example provide a ReactComponentIO which routes component events as input to Sagas (to resolve take effects) and connects the output of the Saga to component's setState (to resolve put effects) \n``` javascript\nfunction* myComponentSaga(comp) {\n  while(true) {\n     yield take('CLICK')\n     // yield some stuff\n     yield put({clicked: true}) // same as setState({clicked: true})\n  }\n}\nclass MyComponent extends React.Component {\ncomponentDidMount() {\n     this.sagaIO = ReactComponentIO(this)\n     runSaga(mySaga(this), this.sagaIO) )\n  }\nrender() {\n     return (\n         ...\n         <button onClick={this.sagaIO.fire({type: 'CLICK'})}\n     )\n  }\n}\n```\nThis is all quick and dirty, but can be refined further\n. I'll close this for the moment. Please feel free to add any comment. I can reopen it if necessary.\n. Thanks!\n. concurrent takes within race are not allowed until now; but should be supported as soon as #26 get merged. \nFor now you can take multiple actions like this\njavascript\n   const action = yield take([DASHBOARD_LOAD_REQUEST, LOGOUT])\n   if(action.type === DASHBOARD_LOAD_REQUEST)\n     ....\n   else\n     ...\n. > Would you say there is anything fundamentally wrong with wrapping the takes in functions as demonstrated above?\nNo. It just adds a level of indirection. \n. Which in some cases could be useful of course\n. FYI, the new version 0.4.0 supports concurrent or parallel takes\nthe code below is now valid\njavascript\nconst { explicitLogout, dashboardChange } = yield race({                                                                                                                                                                                                                                          \n  dashboardChange: take(DASHBOARD_LOAD_REQUEST),                                                                                                                                                                                                                            \n  explicitLogout: take(LOGOUT),                                                                                                                                                                                                                                            \n})\n. I was just thinking about adding this! I like the jsbin idea, one can play with the library without heavy installs. Thanks! \nLooking forward for you blog post.\n. Already pushed. BTW the link is https://npmcdn.com/redux-saga@0.4.0/dist/redux-saga.js\nThanks again :)\n. Can't you dispatch a single action for the whole file list\n``` javascript\nhandleLocalFileUpload(files) {\n    this.props.createAssetFromLocal(files);\n}\nexport const watchCreateAssetFromLocal = function *(getState) {\n  while (true) {\n    const { files } = yield take(actions.CREATE_ASSET_FROM_LOCAL_REQUEST);\n    yield files.map(file => fork(createAssetFromLocal, file, getState) );\nconsole.log('done');\n\n}\n};\n```\n. > Yeah, that was also the workaround we did in this case\nIMO; it's more than a workaround; whenever I dispatch multiple actions synchronously; then it feels (still IMO) like a code smell. If I have all the user/server/... input at a given moment, I should dispatch the whole input as one batch to the store.\n\nBut there could be problems somewhere else, when there is no implicit delay introduced by the user\n\nIf I'm not mistaken, there will be always a delay between 2 user actions. Each user command (click, input, event ajax responses) are scheduled on the next tick of the event loop. i.e. the current event loop tick will always terminate all the pending tasks before handling the next user input.\n\nSo do redux-saga's watchers implicitly require a very short delay between actions? Just so that we don't run into an issue later.\n\nredux-saga uses promise chaining with promise.then to drive its progression. Promises chained callbacks are executed asynchronously; but they are always executed in the same event loop queue. It means event if a user event happens in-between, it wont be missed\nSo the rules are (should probably figure in the docs)\n- do not dispatch multiple actions synchronously, dispatch one action with all the input\n- use fork to avoid blocking.\n. > my saga dispatches CREATE_ASSET_REQUEST_SUCCESS and I have a watcher that listens for this action (for whatever reason ;) ). Then I couldn't be sure that there is a delay between two actions. \nWhat you're describing here is 2 sagas communicating via the store. So the 2nd saga must be waiting for the action at the moment the 1st dispatches it. \n\nThen I couldn't be sure that there is a delay between two actions.  Not sure, if this could even be a valid use case and if it isn't covered by your last paragraph anyway\n\nOf course you could :). (I mean if you're the author of the 1st saga). But anyway, CREATE_ASSET_REQUEST_SUCCESS is normally dispatched after some external event (ajax respoonse, websocket message), so yes it's also covered by my above comment.\nThe only case I suspect is when the saga fire consecutively 2 actions; and another Saga is waiting also consecutively for those 2 actions. But in this case, I dont see why simply not send one action with all the required payload\n. > two callbacks resolve at the same time\nThe 2 callbacks will always be scheduled in different task queues. \n. FYI. Release 0.6.0 supports synchronous actions. there were more use cases (actions fired simultaneously from different components or middlewares)\n. Yeah. It'd be safer. \n. Thanks\n. I didn't work with redux-router before; but it's likely because the action can't reach the middleware.\nCan you show me you store setup ? I suspect some issue related of using multiple store enhancers\n. @cherta Thanks for your example. There is also an example of integrating react-router with sagas in the real-world example. It only use history api (one drawback though: it doesn't play nice with devtools)\nI tend to agree with @slorber. It feels like react-router way is somewhat short-circuiting the data flow in Redux applications.\n. You can't yield from a  callback. Only from generators. A possible solution is\njavascript\nyield result.map(item => fork(api.endpoint, item))\n. There is a cps effect that works with node style callbacks (err, res). But for now only works with non method functions (or strongly bound functions) [I'll have to fix that]\njavascript\nconst result = yield cps(func)\nyield put(myAction(result))\nAnother solution is to promisify your method and use it with call instead of cps\njavascript\nfunction promisifiedFn(...args) {\n  return new Promise( (resolve, reject) => {\n    obj.method(...args,  (err, res) => err ? reject(err) : resolve(res)\n  }\n}\n. addEventListener calls its callback with the event as a first parameter. cps's callback is called with the event as a first argument by addEventListener, since cps expects an error first argument. it treats the event as an error.\nI'd opt for your first solution but would remove the event listener after the promise is resolved\njavascript\nconst waitForEvent = (elm, eventType) => {\n  return new Promise(resolve => {\n    const cb = e => {\n      resolve(e)\n      elm.removeEventListener(eventType, cb)\n    }\n    elm.addEventListener(eventType, cb)\n  })\n}\n. Isn't a return statement missed in your loginUser function ? \n. thanks!\n. thanks\n. @aikoven Can't you pass the required data (entities & locale setting) in the action payload ? Then the only dependency you'll have to the 2 selectors will be in the component firing the action.\n. @aikoven Sorry for the late response. I was hopping for some more comments from other people\nI thinks the issue you raised is valid. I also remember this was also raised by some Redux users. I agree the idea of a master reducer feels like a code smell. Although i\"m not sure it belongs to the Saga to this kind of things. The point is that Sagas handle effects, and effects are about yielding something at some specific moment. Processing response is normally done inside api services which have to return a final value to the Saga. \nBut in the same time I can't think as you said of another place where to put this. So the question question I'm asking (myself principally) is: is it right to implement this by default inside Sagas ?  Or maybe the Saga acts in this situation like a bridge between the store and api services. i.e. gets the required info from the store and pass it to api services as arguments.\nMy other concern is regarding the implementation Can we implement this without having a dependency to a Redux concept (getState) inside the internal proc method ? (which right now is independent). Keeping proc independant from Redux allows it to be used in other situations ( like connecting runSaga to external IO ).\nAnother concern is related to effect logging, if we wrap the Saga inside a decorator, do we loose the name of the generator function ? Because if so, the effect monitoring wont be able to print a readable trace of the Sagas (I'm not well versed into decorators yet)\n. @aikoven Sorry for not replying to this. I was following your discussion with @slorber and trying to abstract out something more generic for redux-saga\nI think Decorators would be great as a mean for general configuration of Sagas (e.g. indicate that a saga depends on some actions so the middleware can buffer those actions). However it seems function Decorators wont be supported anysoon (currently at stage 0 and only for function expressions).\nMy feel is that connecting Sagas for what you want seems to be part of a much general concern of dependency injection.\nFor the state, there was a time I considered adding some effect yield getState/setState in order allow testing the Saga state as well but didn't explore further this way.\n\nIt also made me refactor my reducers to split them into smaller ones that manage smallest possible state slice. Which is great even if I didn't use redux-saga, as it makes it much easier to reason about update logic and also to test it.\nAnd when some update logic requires data from other parts of the state, I treat it as a side-effect instead of introducing reducer that manages larger slice.\n\nDid you see this proposal in Redux repo\nhttps://github.com/rackt/redux/issues/1315\nIt proposes a solution to this issue based on Generators as well\njavascript\nfunction* c(state = 0, action) {\n  const aState = yield a\n  const bState = yield b\n  return state + Math.abs(aState - bState)\n}\n\nI'm thinking about publishing this as a separate repo.\n\nI guess this would make more sens actually. We can see later if we can factor out something to integrate into redux-saga\n. @slorber \n\nmostly because as far as I remember, the c generator has to be on the same level as a and b reducers.\n\nDidn't saw that. Is this a technical constraint ? (I can't really see how this is a requirement for the above solution to work) \n. @slorber \n\nmostly because as far as I remember, the c generator has to be on the same level as a and b reducers.\n\nDidn't saw that. Is this a technical constraint ? (I can't really see how this is a requirement for the above solution to work) \n. @aikoven What do you think of this proposition\n@gaearon first proposed to provide a yield getState() effect so we do not pass the getState param around.\n@slorber proposed a more general yield select(selector) Effect.\n\nEdit: added link to issue commoent\n. @aikoven What do you think of this proposition\n\n@gaearon first proposed to provide a yield getState() effect so we do not pass the getState param around.\n@slorber proposed a more general yield select(selector) Effect.\n\nEdit: added link to issue commoent\n. FYI released in 0.9.0\n. FYI released in 0.9.0\n. thanks!\n. thanks!\n. @mjrussell Thanks for raising this issue.\n\nIf I understand the main problem is: how to resume the generator with a dummy result of the fork. Put in other words how to mock the result of a fork task. right ?\n. @mjrussell Thanks for raising this issue.\nIf I understand the main problem is: how to resume the generator with a dummy result of the fork. Put in other words how to mock the result of a fork task. right ?\n. > am also curious as to why this passes on 0.4.1 and not on 0.5.0, was there a breaking change in how call works?\nI think the issue starts from here\nhttps://github.com/yelouafi/redux-saga/pull/45/files#diff-fe2186b9207791d7c78cdf4eb20515feR83\nIn 0.4.1, you can call fork directly on an iterator (yield fork( saga() )). In 0.5.0 it was removed, and fork must be called as call and cps (sorry, forgot to mention this in the releases notes). so it should be (syncSaga without ())\njavascript\n const task = runSaga(cancellableSaga(syncSaga), storeIO(store));\nSo this call wont fail\nhttps://github.com/yelouafi/redux-saga/pull/45/files#diff-fe2186b9207791d7c78cdf4eb20515feR42\nThis is to provide an uniform support to all those function for providing context (this). Also it's much simpler to test equality on fork(saga, a1, a2).\n\nIn general would you tell people to avoid using the runSaga as a testing method and stay to the behavior driven? Otherwise it does seem like we are testing redux-saga as much as our own code.\n\nIn unit testing yes, IMO, it's more reliable and predictable. \n. > am also curious as to why this passes on 0.4.1 and not on 0.5.0, was there a breaking change in how call works?\nI think the issue starts from here\nhttps://github.com/yelouafi/redux-saga/pull/45/files#diff-fe2186b9207791d7c78cdf4eb20515feR83\nIn 0.4.1, you can call fork directly on an iterator (yield fork( saga() )). In 0.5.0 it was removed, and fork must be called as call and cps (sorry, forgot to mention this in the releases notes). so it should be (syncSaga without ())\njavascript\n const task = runSaga(cancellableSaga(syncSaga), storeIO(store));\nSo this call wont fail\nhttps://github.com/yelouafi/redux-saga/pull/45/files#diff-fe2186b9207791d7c78cdf4eb20515feR42\nThis is to provide an uniform support to all those function for providing context (this). Also it's much simpler to test equality on fork(saga, a1, a2).\n\nIn general would you tell people to avoid using the runSaga as a testing method and stay to the behavior driven? Otherwise it does seem like we are testing redux-saga as much as our own code.\n\nIn unit testing yes, IMO, it's more reliable and predictable. \n. FYI. 0.6.0 added an utility functin createMockTask to mock fork results. see release notes for usage example\n. FYI. 0.6.0 added an utility functin createMockTask to mock fork results. see release notes for usage example\n. > I can close this then unless it would be worth cleaning it up with the examples and new way for mocking forks\nI think it'd be util to include. But maybe we should change the title tasks to something more informative (kind of saga-test-sample)\n. > I can close this then unless it would be worth cleaning it up with the examples and new way for mocking forks\nI think it'd be util to include. But maybe we should change the title tasks to something more informative (kind of saga-test-sample)\n. No worry :)\n. No worry :)\n. > How do I use a yielded value inside a generator to continue on with tests?\nby calling next(mockResult).\n``` javascript\n it('should wait for the next DO_SOMETHING', function() {\n   sut.next().value.should.eql(io.take(actions.DO_SOMETHING))\n })\nit('should dispatch a fetch request', function() {\n  // inject mock result into next\n  const mockThing = { thing: { id: 1 } }\n  sut.next(mockThing).value.should.eql(io.fork(creators.fetchSomething)) \n  ....\n}\n```\nIf you want to simulate an error, call throw(mockResult) instead\nAlthough you don't use it in the above example. We should provide a way to mock the result of forked tasks (e.g. fetch = in your example )\n. > How do I use a yielded value inside a generator to continue on with tests?\nby calling next(mockResult).\n``` javascript\n it('should wait for the next DO_SOMETHING', function() {\n   sut.next().value.should.eql(io.take(actions.DO_SOMETHING))\n })\nit('should dispatch a fetch request', function() {\n  // inject mock result into next\n  const mockThing = { thing: { id: 1 } }\n  sut.next(mockThing).value.should.eql(io.fork(creators.fetchSomething)) \n  ....\n}\n```\nIf you want to simulate an error, call throw(mockResult) instead\nAlthough you don't use it in the above example. We should provide a way to mock the result of forked tasks (e.g. fetch = in your example )\n. @josebalius This is related to #47. We need to provide an utility function to mock fork results\n. @josebalius This is related to #47. We need to provide an utility function to mock fork results\n. v0.6.0 includes a createMockTask function, see releases notes for usage example.\n. v0.6.0 includes a createMockTask function, see releases notes for usage example.\n. This is related to #45 and #46. We need to provide a way to mock fork results (i.e. create mock tasks), since the developer can't create them himself.\nI'm thinking of something like a createMockTask method; then your test should be something like this\n``` javascript\nimport { createMockTask } from 'redux-saga/lib/testUtils'\ntest('getData', assert => {\nconst it = getData()\nassert.deepEqual( it.next().value, take(types.GET_DATA) )\nconst mockData = {data: 'xyz'}\n  const mockAction = {type: types.GET_DATA, data: mockData }\n// resume the generator with mockAction\n  // since task is null, we expect it to skip yield cancel(task)\n  assert.deepEqual( it.next(mockAction).value, fork(callApi, mockData ) )\n// mock fork result\n  const mockTask = createMockTask()\n// resume the generator with mock task\n  assert.deepEqual( it.next(mockTask).value, take(types.GET_DATA) )\n// simulate a task ending\n  mockTask.setRunning(true)\n  console.log(mockTask.isRunning())\n  // now expect a cancel\n  assert.deepEqual( it.next(mockAction).value, cancel(mockTask) )\nassert.end()\n})\n```\n\nEDIT: sorry fixed test code\n. This is related to #45 and #46. We need to provide a way to mock fork results (i.e. create mock tasks), since the developer can't create them himself.\n\nI'm thinking of something like a createMockTask method; then your test should be something like this\n``` javascript\nimport { createMockTask } from 'redux-saga/lib/testUtils'\ntest('getData', assert => {\nconst it = getData()\nassert.deepEqual( it.next().value, take(types.GET_DATA) )\nconst mockData = {data: 'xyz'}\n  const mockAction = {type: types.GET_DATA, data: mockData }\n// resume the generator with mockAction\n  // since task is null, we expect it to skip yield cancel(task)\n  assert.deepEqual( it.next(mockAction).value, fork(callApi, mockData ) )\n// mock fork result\n  const mockTask = createMockTask()\n// resume the generator with mock task\n  assert.deepEqual( it.next(mockTask).value, take(types.GET_DATA) )\n// simulate a task ending\n  mockTask.setRunning(true)\n  console.log(mockTask.isRunning())\n  // now expect a cancel\n  assert.deepEqual( it.next(mockAction).value, cancel(mockTask) )\nassert.end()\n})\n```\n\nEDIT: sorry fixed test code\n. @josebalius call is just a pure function that receives some params and return a plain object. It doesnt have to detect anything. What happens is that when the redux-saga middleware run the generator, it asks it to get the next effect. The generator returns for example a call object. The middleware then run the call (e.g. by making an xhr request ) and resume the generator when the result of the execution arrives.\n\nIn tests, you do the same thing, you ask the generator for the next effect. except that you dont run the call. you just resume the generator by some mock result\n``` javascript\nfunction* saga() {\n  const res = yield call(myFunc)\n  yield put(action(res))\n}\nconst it = saga()\nassert.deepEqual( it.next().value, call(myFunc) )\nconst mockResultOfMyFuncCall = {}\nassert.deepEqual( \n  // here you provide a dummy result to the generator into the next method\n  it.next(mockResultOfMyFuncCall ).value,\n  // and expect it putting an action with that result\n  put( action(mockResultOfMyFuncCall) ) \n)\n```\nThe issue with fork is that you can't give the generator an arbitrary mock value. Because fork results are expected to have some special properties. So there is no way actually for a library user to mock them. Thus we need to provide a function to create mock fork results\n. @josebalius call is just a pure function that receives some params and return a plain object. It doesnt have to detect anything. What happens is that when the redux-saga middleware run the generator, it asks it to get the next effect. The generator returns for example a call object. The middleware then run the call (e.g. by making an xhr request ) and resume the generator when the result of the execution arrives.\nIn tests, you do the same thing, you ask the generator for the next effect. except that you dont run the call. you just resume the generator by some mock result\n``` javascript\nfunction* saga() {\n  const res = yield call(myFunc)\n  yield put(action(res))\n}\nconst it = saga()\nassert.deepEqual( it.next().value, call(myFunc) )\nconst mockResultOfMyFuncCall = {}\nassert.deepEqual( \n  // here you provide a dummy result to the generator into the next method\n  it.next(mockResultOfMyFuncCall ).value,\n  // and expect it putting an action with that result\n  put( action(mockResultOfMyFuncCall) ) \n)\n```\nThe issue with fork is that you can't give the generator an arbitrary mock value. Because fork results are expected to have some special properties. So there is no way actually for a library user to mock them. Thus we need to provide a function to create mock fork results\n. @n9ti  v0.6.0 introduces createMockTask. see releases notes for usage example\n. @n9ti  v0.6.0 introduces createMockTask. see releases notes for usage example\n. That's annoying. I didnt like the monkey patching solution used in runSaga from the start. Things would be much easier if the redux store provided the dispatched action directly to its subscribers.\nOne possible solution is redux-saga providing explicit channels for inter-saga communication. \n. That's annoying. I didnt like the monkey patching solution used in runSaga from the start. Things would be much easier if the redux store provided the dispatched action directly to its subscribers.\nOne possible solution is redux-saga providing explicit channels for inter-saga communication. \n. Yes I think it would work; Although the developer has to export the middleware which feel a bit unnatural (just a feeling :) ).\nI think also using a store enhancer with a lifted reducer like in devtools would also work, since the reducer can intercept all actions. Basically it's a problem of getting a store action from the outside, it seems I was doing it the wrong way.\n. Yes I think it would work; Although the developer has to export the middleware which feel a bit unnatural (just a feeling :) ).\nI think also using a store enhancer with a lifted reducer like in devtools would also work, since the reducer can intercept all actions. Basically it's a problem of getting a store action from the outside, it seems I was doing it the wrong way.\n. FYI version 0.7.0 provides a new method to start dynamic Sagas\n. FYI version 0.7.0 provides a new method to start dynamic Sagas\n. @aft-luke I think the undefined issue is that you dont return a value from doFetch (return (yield req = ...))\nRegarding cancellation, redux-saga cancels only the effects it creates itself (called sagas, take effects). raw promise cancellation is a no-op since this is not yet supported by the standard. \n. @aft-luke I think the undefined issue is that you dont return a value from doFetch (return (yield req = ...))\nRegarding cancellation, redux-saga cancels only the effects it creates itself (called sagas, take effects). raw promise cancellation is a no-op since this is not yet supported by the standard. \n. I think the problem is inside the fnB. If you put delay between the 3 puts (like yield call(delay, 0)). I think it'd work\nThe issue come from the fact that Sagas runner uses promise chaining to drive the generator progression, So every effect, even non blocking ones like fork, are processed asynchronously inside promise.then chains. \nYou can find issue there related issue #34.\nI feel a bit uncomfortable with using the store as a communication channel between sagas. If possible, it's always preferable to factor the common code into a callable saga and call it from inside the 2 communicating sagas. It makes control-flow more reliable and easier to understand \n. I think the problem is inside the fnB. If you put delay between the 3 puts (like yield call(delay, 0)). I think it'd work\nThe issue come from the fact that Sagas runner uses promise chaining to drive the generator progression, So every effect, even non blocking ones like fork, are processed asynchronously inside promise.then chains. \nYou can find issue there related issue #34.\nI feel a bit uncomfortable with using the store as a communication channel between sagas. If possible, it's always preferable to factor the common code into a callable saga and call it from inside the 2 communicating sagas. It makes control-flow more reliable and easier to understand \n. As redux-saga actually relies on promise chaining. It cant't handle consecutive synchronous actions. So you'd have to dispatch the 2 api calls in one batch, and take the whole in sagas (Also may be better for performance to send one api than 2).\n. As redux-saga actually relies on promise chaining. It cant't handle consecutive synchronous actions. So you'd have to dispatch the 2 api calls in one batch, and take the whole in sagas (Also may be better for performance to send one api than 2).\n. > For the same reason, it doesn't make sense to change the API (which I don't own) to handle these combined requests.\nI see. Indeed this is not the right solution\n\nCan you please give me a better idea what are \"synchronous\" actions and what would be \"asynchronous\" in that case? \n\nwhen you're inside a component for example and you do something like\njavascript\ndispatch(action1)\ndispatch(action2)\nYou are dispatching 2 consecutive actions synchronously. And even if they are fired from 2 different component they are still fired synchronously (Just called from different place).\nSince redux-saga uses promises chaining, when a saga receives the 1st action; it does something like\njavascript\nresolveTakeEffect(action1)\n   .then( goAndFetchNextEffect )\nThe problem is that the then callback will not execute right away, instead the underlying promise runtime will schedule the goAndFetchNextTakeEffect in a microtak queue.  It simply means, the then will wait for the current flow (for exampe the current event handler, or componentDidMount or whatever fired the action) to terminate and then execute goAndFetchNextTakeEffect. Meantime your code  continues and executes dispatch(action2). But at this time, the Saga hasn't yet fetched the next effect (e.g. take or fork) so it is not ready yet to take the action.\nThe problem wont occur when you dispatch actions in reaction to external events (like xhr/event callbacks) because those callbacks wont execute until all promise then callbacks execute first. So even if 2 event come at a very fast rate, JS runtime will still schedule their callbacks after all promise callbacks.\nInitially I thought the above issue wont occur because of how event loop works as described above. But the issue was reported many times; so we need a consistent solution to handle this kind of weird side effect\nUntil then; You can the workaround from\nhttps://github.com/tomkis1/redux-side-effect-example/blob/master/src/components/Application.jsx#L21-L31\nie. Schedulin the 2 dispatch in 2 macrotasks. This way, the 2nd dispatch will always execute after the Saga is ready to take it.\nYou don't have to use the brute setTimeout. You can use the https://github.com/YuzuJS/setImmediate for a more efficient way\njavascript\ncomponentDidMount() {\n    setImmediate(() =>\n      this.props.dispatch(myAction);\n  }\n\nFor now, it looks like I have to drop sagas here in favor of the custom middleware.\n\nThe project is still young and evolving (2 months). So you can't expect it to handle every possible use case yet. It can only evolve and mature by gathering feedback from developers and then handling reported issues through reusable and consistent solutions.\n. > For the same reason, it doesn't make sense to change the API (which I don't own) to handle these combined requests.\nI see. Indeed this is not the right solution\n\nCan you please give me a better idea what are \"synchronous\" actions and what would be \"asynchronous\" in that case? \n\nwhen you're inside a component for example and you do something like\njavascript\ndispatch(action1)\ndispatch(action2)\nYou are dispatching 2 consecutive actions synchronously. And even if they are fired from 2 different component they are still fired synchronously (Just called from different place).\nSince redux-saga uses promises chaining, when a saga receives the 1st action; it does something like\njavascript\nresolveTakeEffect(action1)\n   .then( goAndFetchNextEffect )\nThe problem is that the then callback will not execute right away, instead the underlying promise runtime will schedule the goAndFetchNextTakeEffect in a microtak queue.  It simply means, the then will wait for the current flow (for exampe the current event handler, or componentDidMount or whatever fired the action) to terminate and then execute goAndFetchNextTakeEffect. Meantime your code  continues and executes dispatch(action2). But at this time, the Saga hasn't yet fetched the next effect (e.g. take or fork) so it is not ready yet to take the action.\nThe problem wont occur when you dispatch actions in reaction to external events (like xhr/event callbacks) because those callbacks wont execute until all promise then callbacks execute first. So even if 2 event come at a very fast rate, JS runtime will still schedule their callbacks after all promise callbacks.\nInitially I thought the above issue wont occur because of how event loop works as described above. But the issue was reported many times; so we need a consistent solution to handle this kind of weird side effect\nUntil then; You can the workaround from\nhttps://github.com/tomkis1/redux-side-effect-example/blob/master/src/components/Application.jsx#L21-L31\nie. Schedulin the 2 dispatch in 2 macrotasks. This way, the 2nd dispatch will always execute after the Saga is ready to take it.\nYou don't have to use the brute setTimeout. You can use the https://github.com/YuzuJS/setImmediate for a more efficient way\njavascript\ncomponentDidMount() {\n    setImmediate(() =>\n      this.props.dispatch(myAction);\n  }\n\nFor now, it looks like I have to drop sagas here in favor of the custom middleware.\n\nThe project is still young and evolving (2 months). So you can't expect it to handle every possible use case yet. It can only evolve and mature by gathering feedback from developers and then handling reported issues through reusable and consistent solutions.\n. @emirotin \n\nSorry if I sound irritated here. It wasn't meant to criticize the project by any means. I really value how you listen to your users and look open to adapting the library behavior to real use-cases \n\nNo worry :). i'm also thankful to all people who are trying this lib in their apps although it's still on its early stages.\n\nI think the actual problem here is the mental dissonance. Sagas are middleware and other middlewares are guaranteed to be called for every action dispatched. When one reads the saga code it looks like it will be the case as well, with just the code being suspended between the events. So one (me :)) imagines the unhandled actions queued until the saga unshifts them and executes.\n\nAgree 100%. The pull approach suggests that the saga is actually iterating over an event queue. so the user expects to not miss any event. \nAnd I'm conscious that library users shouldn't concern themselves with underlying implementation details (promises, microtasks, ...) in order to use the library, but only with its communicated semantics. Because it'll add another mental overhead while the library has already a steep learning curve (generators, event handlng paradigm shift, processes ...)\nWhen implementing the take effect. There were 2 choices for its semantics\n1- Either queue all incoming actions for the Saga. So it wont miss any action; even if it's blocked on an api call when the action arrives\n2- discard the incoming action if the Saga isn't waiting for it\nThe 1st behavior is more close to how CSP channels work. While the 2nd looks more close to the Actor model.\nBoth approaches has pros and cons. Depending on the use case, the developer will sometimes want the incoming actions to be queued (buffered) while in other use cases it's not necessary to buffer the actions.\nFrom a conceptual view, event buffering is more close to how iterators works: when i'm iterating over some iterable, i don't expect to miss some value. But the iterator can't be shared between multiple consumers, each consumer has to create its own iterator from a given iterable (array, generator, event queue). \nSo in a order to share the store channel between many Sagas, w'll have to create an event iterator (or event queue/bufffer) for each Saga. However, buffering all actions can lead to more or less serious memory issues: A generic action queue can't determine in advance which action to keep or discard (i.e. will be taken later by the saga); so it'l have to buffer all incoming actions even if those actions will never be taken by a Saga. \nSo this is how somewhat I ended up with the actual behavior.\nI was of course thinking in adding dedicated channel support which could support the iterator semantics (buffering). Could be something like\n``` javascript\nfunction* saga() {\n  // buffered channel, wont miss any API_CALL action\n  const apiChannel = yield channel('API_CALL')\nwhile(true) {\n    const apiAction = yield take(apiChannel)\n    ....\n  }\n}\n```\nOr could be something generic created outside of sagas, and called with a simple call. This has the advantage of being usable also with other event sources (Observables, websocket messages, even raw DOM events)\n``` javascript\nconst apiCallChannel= createChannel(fromStoreActions(store, 'API_CALL'))\nfunction* saga() {\n while(true) {\n    const apiAction = yield call(apiCallChannel.nextEvent)\n    ....\n  }\n}\n```\nSo I'd have to comeup with clear semantics and API; (and also find the time :) to do it ).\n\nThis will create a normal middleware that picks every CALL_API action and forks the callApi method. Such kind of notation will also make the actual sagas code shorter as I always find myself writing\n\nyeah. that also crossed my mind, but w'd also have to define some way to coordinate those forked daemons. Otherwise, the solution won't have a real advantage above normal callback based solutions (like thunks) when managing complex flow for all forked daemons. We could provide some saga coordinator to the daemon function; But then we shift away from the simple synchronous-like mental model of generators to a more complex async/push/callback model.\n. @emirotin \n\nSorry if I sound irritated here. It wasn't meant to criticize the project by any means. I really value how you listen to your users and look open to adapting the library behavior to real use-cases \n\nNo worry :). i'm also thankful to all people who are trying this lib in their apps although it's still on its early stages.\n\nI think the actual problem here is the mental dissonance. Sagas are middleware and other middlewares are guaranteed to be called for every action dispatched. When one reads the saga code it looks like it will be the case as well, with just the code being suspended between the events. So one (me :)) imagines the unhandled actions queued until the saga unshifts them and executes.\n\nAgree 100%. The pull approach suggests that the saga is actually iterating over an event queue. so the user expects to not miss any event. \nAnd I'm conscious that library users shouldn't concern themselves with underlying implementation details (promises, microtasks, ...) in order to use the library, but only with its communicated semantics. Because it'll add another mental overhead while the library has already a steep learning curve (generators, event handlng paradigm shift, processes ...)\nWhen implementing the take effect. There were 2 choices for its semantics\n1- Either queue all incoming actions for the Saga. So it wont miss any action; even if it's blocked on an api call when the action arrives\n2- discard the incoming action if the Saga isn't waiting for it\nThe 1st behavior is more close to how CSP channels work. While the 2nd looks more close to the Actor model.\nBoth approaches has pros and cons. Depending on the use case, the developer will sometimes want the incoming actions to be queued (buffered) while in other use cases it's not necessary to buffer the actions.\nFrom a conceptual view, event buffering is more close to how iterators works: when i'm iterating over some iterable, i don't expect to miss some value. But the iterator can't be shared between multiple consumers, each consumer has to create its own iterator from a given iterable (array, generator, event queue). \nSo in a order to share the store channel between many Sagas, w'll have to create an event iterator (or event queue/bufffer) for each Saga. However, buffering all actions can lead to more or less serious memory issues: A generic action queue can't determine in advance which action to keep or discard (i.e. will be taken later by the saga); so it'l have to buffer all incoming actions even if those actions will never be taken by a Saga. \nSo this is how somewhat I ended up with the actual behavior.\nI was of course thinking in adding dedicated channel support which could support the iterator semantics (buffering). Could be something like\n``` javascript\nfunction* saga() {\n  // buffered channel, wont miss any API_CALL action\n  const apiChannel = yield channel('API_CALL')\nwhile(true) {\n    const apiAction = yield take(apiChannel)\n    ....\n  }\n}\n```\nOr could be something generic created outside of sagas, and called with a simple call. This has the advantage of being usable also with other event sources (Observables, websocket messages, even raw DOM events)\n``` javascript\nconst apiCallChannel= createChannel(fromStoreActions(store, 'API_CALL'))\nfunction* saga() {\n while(true) {\n    const apiAction = yield call(apiCallChannel.nextEvent)\n    ....\n  }\n}\n```\nSo I'd have to comeup with clear semantics and API; (and also find the time :) to do it ).\n\nThis will create a normal middleware that picks every CALL_API action and forks the callApi method. Such kind of notation will also make the actual sagas code shorter as I always find myself writing\n\nyeah. that also crossed my mind, but w'd also have to define some way to coordinate those forked daemons. Otherwise, the solution won't have a real advantage above normal callback based solutions (like thunks) when managing complex flow for all forked daemons. We could provide some saga coordinator to the daemon function; But then we shift away from the simple synchronous-like mental model of generators to a more complex async/push/callback model.\n. Actually I think we may need both solutions. \nThe daemon approach could serve many uses cases where all we're doing is replicating the same behavior inside a while(true). it also doesn't have the flaw of missing actions\n``` javascript\nfunction* rootSaga() {\n// avoids state-less/logic-less while(true)\n  yield on('SOME_ACTION', handlerSaga)\n  ...\n}\n```\nThe channel approach would serve for non trivial complex flow and also solves the problem of missing actions\nand even daemon sagas instances can coordinate using a dedicated channel\n. Actually I think we may need both solutions. \nThe daemon approach could serve many uses cases where all we're doing is replicating the same behavior inside a while(true). it also doesn't have the flaw of missing actions\n``` javascript\nfunction* rootSaga() {\n// avoids state-less/logic-less while(true)\n  yield on('SOME_ACTION', handlerSaga)\n  ...\n}\n```\nThe channel approach would serve for non trivial complex flow and also solves the problem of missing actions\nand even daemon sagas instances can coordinate using a dedicated channel\n. After examining all issues. It become clear that reliance on promise isn't going to play nice with synchronous actions. Channels may solve issues for saga inter-communications and are certainly useful. but there are other issues which can't be solved like Sagas taking some time to start (cc @tgriesser like use yield [fork(a), fork(b)] works but  yield fork(a); fork(b) not).\nI think as long as the core relies on promises, there will be always some issue reported kind of this thing started before this thing. This is inavoidable because of the nature of promise, we ont have control of order of things (which sounds a bit ironic for a lib whose purpose is to allow people to manage order of things). \nSo to tackle that problem I made a more radical choice, rewrite the redux-saga core without relying on promise to drive the generators but only callbacks (this is only an internal impl. detail and doesnt affect the external API). The advantage its that now w've total control of order of things, and effects like fork are truly non blocking, even call effects which return non promise results are non blocking. \nIt a was bit (well more than a bit) trickier to achieve (cancellation propagation, had to reinvent race/parallel ...) But finally it works,  and now all tests cases pass, even with sync actions. And no more requestAnimationFrame are necessary now.\nThe code is the no-promise branch. I'll merge it with the master after adding some more edge-case tests. \n. After examining all issues. It become clear that reliance on promise isn't going to play nice with synchronous actions. Channels may solve issues for saga inter-communications and are certainly useful. but there are other issues which can't be solved like Sagas taking some time to start (cc @tgriesser like use yield [fork(a), fork(b)] works but  yield fork(a); fork(b) not).\nI think as long as the core relies on promises, there will be always some issue reported kind of this thing started before this thing. This is inavoidable because of the nature of promise, we ont have control of order of things (which sounds a bit ironic for a lib whose purpose is to allow people to manage order of things). \nSo to tackle that problem I made a more radical choice, rewrite the redux-saga core without relying on promise to drive the generators but only callbacks (this is only an internal impl. detail and doesnt affect the external API). The advantage its that now w've total control of order of things, and effects like fork are truly non blocking, even call effects which return non promise results are non blocking. \nIt a was bit (well more than a bit) trickier to achieve (cancellation propagation, had to reinvent race/parallel ...) But finally it works,  and now all tests cases pass, even with sync actions. And no more requestAnimationFrame are necessary now.\nThe code is the no-promise branch. I'll merge it with the master after adding some more edge-case tests. \n. @fhelwanger v0.6.0 is already out with the new changes. You can try it and see.\n. @fhelwanger v0.6.0 is already out with the new changes. You can try it and see.\n. @tgriesser with the new promise-less version; on helper can be created like this\n``` javascript\nfunction* on(actionType, workerSaga) {\n  while(true) {\n    const nextAction = yield take(actionType)\n    yield fork(workerSaga)\n  }\n}\n// start incrementAsync on each INCREMENT_ASYNC\non(INCREMENT_ASYNC, incrementAsync)\n```\nOther concurrency patterns can also be created (as discussed here https://github.com/yelouafi/redux-saga/issues/68#issuecomment-178086859)\nSo I'm not sure if an addition to the core is needed. Thinking of creating a separate repo like redux-saga-contrib where we can gather multiple helpers for different concurrencey patterns\n. @tgriesser with the new promise-less version; on helper can be created like this\n``` javascript\nfunction* on(actionType, workerSaga) {\n  while(true) {\n    const nextAction = yield take(actionType)\n    yield fork(workerSaga)\n  }\n}\n// start incrementAsync on each INCREMENT_ASYNC\non(INCREMENT_ASYNC, incrementAsync)\n```\nOther concurrency patterns can also be created (as discussed here https://github.com/yelouafi/redux-saga/issues/68#issuecomment-178086859)\nSo I'm not sure if an addition to the core is needed. Thinking of creating a separate repo like redux-saga-contrib where we can gather multiple helpers for different concurrencey patterns\n. @emirotin I think this maybe related to this SO question. The main point is\n\nTo integrate external push sources, we'll need to transpose the Event Source from the push model into the pull model; i.e. we'll have to build an event iterator from which we can pull the future events from the event source\n\nIt joins somewhat your solution, but factor out the concept into a separate function. So the saga can be easily tested. You can find a jsbin live demo here https://jsbin.com/wumuri/edit?js,console\n``` javascript\n// Event iterator for socket events\nfunction socketEventIterator(event) {\n  let deferred\n  socket.subscribe(event, payload => {\n    if(deferred) {\n      deferred.resolve(payload)\n      deferred = null \n    }\n  }\nreturn {\n    nextEvent() {\n      if(!deferred) {\n        deferred = {}\n        deferred.promise = \n          new Promise(resolve => deferred.resolve = resolve)\n      }\n      return deferred.promise\n    }\n  }\n}\nfunction* listenToSocket(event, actionType) {\n  const { nextEvent } = yield call(socketEventIterator, event)\n  while (true) {\n    const payload = yield call(nextEvent)\n    yield put({ type: actionType, payload })\n  }\n}\nfunction* subscribeSocket(getState) {\n  while (true) {\n    const nextAction = yield take(SUBSCRIBE_SOCKET)\n    const subscribeConfig = nextAction.payload\n    const { event, actionType } = subscribeConfig\n    yield fork(listenToSocket, event, actionType)\n  }\n}\n```\n. @emirotin I think this maybe related to this SO question. The main point is\n\nTo integrate external push sources, we'll need to transpose the Event Source from the push model into the pull model; i.e. we'll have to build an event iterator from which we can pull the future events from the event source\n\nIt joins somewhat your solution, but factor out the concept into a separate function. So the saga can be easily tested. You can find a jsbin live demo here https://jsbin.com/wumuri/edit?js,console\n``` javascript\n// Event iterator for socket events\nfunction socketEventIterator(event) {\n  let deferred\n  socket.subscribe(event, payload => {\n    if(deferred) {\n      deferred.resolve(payload)\n      deferred = null \n    }\n  }\nreturn {\n    nextEvent() {\n      if(!deferred) {\n        deferred = {}\n        deferred.promise = \n          new Promise(resolve => deferred.resolve = resolve)\n      }\n      return deferred.promise\n    }\n  }\n}\nfunction* listenToSocket(event, actionType) {\n  const { nextEvent } = yield call(socketEventIterator, event)\n  while (true) {\n    const payload = yield call(nextEvent)\n    yield put({ type: actionType, payload })\n  }\n}\nfunction* subscribeSocket(getState) {\n  while (true) {\n    const nextAction = yield take(SUBSCRIBE_SOCKET)\n    const subscribeConfig = nextAction.payload\n    const { event, actionType } = subscribeConfig\n    yield fork(listenToSocket, event, actionType)\n  }\n}\n```\n. @aft-luke Yes the above method doesn't queue in-between events. The method on the SO does queue the events\n. @aft-luke Yes the above method doesn't queue in-between events. The method on the SO does queue the events\n. Thanks!\n. Thanks!\n. Not sure I understand the issue. Saga cancellation exceptions are only thrown when yielding a cancel effect. But I dont see any cancel effect in the code above\n. > but it might be too ambitious to console.warn in each branch that doesn't explicitly handle that exception\nthe warning is printed just to remind the developer in case he forgot to handle the cancellation. Which can lead to some mysterious bugs (inconsistent state)\n. I'm thinking of making this an opt-in behavior. Provide some config argument, so the developer can choose to disable the console warnings\n. > perhaps just the NODE_ENV=\"production\" convention. I have used that with something like envify in the past and it works well.\nAgree; I think it's a better idea\n. @aft-luke yes. Included with the new 0.6.0\n. Symbols are mainly used to ensure reliable uniqueness of constants. If this is an issue, I can replace them with simple namespaced strings.\nI'm a bit surprised, i thought babel would polyfill Symbols by itself\n. You include import babel-polyfill at the top of your entry point file. Like in the examples\nhttps://github.com/yelouafi/redux-saga/blob/master/examples/counter/src/main.js#L2\n. @tappleby yes I guess so.\n@skellock  I think I'll remove the Symbol mentions anyway. As they're not that important in the code\n. @ryyppy The last releases implements something like your solution \nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/utils.js#L23.\n. This is a weird side effect of using promises. I'm currently thinking of a consistent solution to this and other related issues (#50 && #34). Until it's fixed you can try this workaround used in the real world example\nhttps://github.com/yelouafi/redux-saga/blob/master/examples/real-world/index.js#L15-L23\n``` javascript\nconst store = configureStore()\nrequestAnimationFrame(() =>\n  render(\n    ,\n    document.getElementById('root')\n  )\n)\n```\n. @lvgunst Does the 2 containers load in the same time ?\n. Should be resolved by 0.6.0\n. did the new version solve the issue ?\n. thanks!\n. and thanks!\n. Sagas can express control flow that's hard to implement by simple middleware (complex login process, game rules). Where the logic spans accross multiple actions (Like login then refresh authorization each min until logout)\nIt's all normal to ask :)\n. Unless I miss something. You dont have to put the loser keys with null. It should just work with just the winner key 'update' key alone.\n. Actually the result of race is an object that only includes the winner key. That's why i said nulled keys are unnecessary\n. Sagas that milmics the thunk callbacks are generally wrapped inside a while(true). the examples dir re-implement some of the original redux/thunk examples so I don't think there is a lack on this side. although I agree there is a lack on the docs side: step by step tutorials; showcase of complex flow implementations; handling common concurrency concerns...)\n@trevorsenior \n\nIf it would be a welcome addition, I wouldn't mind working on a PR to use gitbook for documentation\n\nDidn't work with gitbook before; but from the site docs, it seems like publishing gitbooks isn't done in the Github repo but instead on the gitbook site https://github.com/GitbookIO/gitbook#publish-your-book.\nOf course any contribution is welcome\n. @danscan yeap; API docs is terribly lacking; hope to do it soon.\n. opened #70 to centralize feedback\n. also will close this; feel free to add your suggestions to #70 \n. @danscan there is a new section for API docs\nhttp://yelouafi.github.io/redux-saga/docs/api/index.html\nWill be adding more content later\n. Yes. The middleware should not redispatch monitor events to sagas\n. Should be fixed by 0.6.0\n. maybe related to #30\n. when do you call your create function ? not after the component has been mounted ?\n. can you try with the new version 0.6 ?\n. FYI https://github.com/yelouafi/redux-saga/releases/tag/v0.7.0\n. > Is the API abandoning the ability to provide a different IO implementation?\nNo. runSaga is still here. Only storeIO was deprecated because of its issues\n. Extending Error object is a bit more than extending it. Also we wanted a way to let the developer distinguish cancellstion errors from normal errors using simply instanceof.\nI think there is a way to extend the native error object. I remember I saw it. \n. Extending Error object is a bit more than extending it. Also we wanted a way to let the developer distinguish cancellstion errors from normal errors using simply instanceof.\nI think there is a way to extend the native error object. I remember I saw it. \n. Thanks @tgriesser @romseguy. I'll take a look\n. Thanks @tgriesser @romseguy. I'll take a look\n. FYI. fixed in v0.6.0; I simply settled with a solution presented by MDN site. (e6-error solution work on browser but tests fail to pass in Node)\nHere are the test case\n. FYI. fixed in v0.6.0; I simply settled with a solution presented by MDN site. (e6-error solution work on browser but tests fail to pass in Node)\nHere are the test case\n. > Is this against what sagas are about? I've just interpreted them as middleware with much more advanced capabilities. \nAgainst no I dont think. But sagas can do more than that. See \nhttp://stackoverflow.com/questions/34930735/pros-cons-of-using-redux-saga-with-es6-generators-vs-redux-thunk-with-es7-async\n\nIs there any equivalent to next from middleware in sagas? If you noticed I do a put in my apiCall, but it has an undesired behavior as it also sends that action to the reducers. I want to be able to do a put that only my sagas can receive basically.\n\nAs long as the action types arent of any meaning to the reducer. It will ignore them. But you can if you want create a filter middleware that intercept all saga actions and put it after the redux-saga middleware in the middleware chain\n. > Is this against what sagas are about? I've just interpreted them as middleware with much more advanced capabilities. \nAgainst no I dont think. But sagas can do more than that. See \nhttp://stackoverflow.com/questions/34930735/pros-cons-of-using-redux-saga-with-es6-generators-vs-redux-thunk-with-es7-async\n\nIs there any equivalent to next from middleware in sagas? If you noticed I do a put in my apiCall, but it has an undesired behavior as it also sends that action to the reducers. I want to be able to do a put that only my sagas can receive basically.\n\nAs long as the action types arent of any meaning to the reducer. It will ignore them. But you can if you want create a filter middleware that intercept all saga actions and put it after the redux-saga middleware in the middleware chain\n. thanks\n. thanks\n. > But I get my first assertions twice too\nThere is no way to return a generator back in time;  but you can factor out the part that test the 2 first assertions; then simply make the assertion noop on subsequent iterations\n``` javascript\nconst cart = {}\nconst getState = () ={ cart }\nfunction testTakeAndCall(gen, deepEqual) {\n   deepEqual(gen.next().value, \n   take(types.CHECKOUT_REQUEST),\n  )\ndeepEqual(\n    gen.next().value, \n    call(api.buyProducts, cart)\n  )\n}\ntest('checkout Saga test', function (t) {\nconst noop = () => {}\n  const gen = checkout(getState)\n// 1st iteration: perform the assertions\n  testTakeAndCall(gen, assert.deepEqual)\nconst response = {}\n  t.deepEqual(\n    gen.next({response}).value, \n   put( actions.checkoutSuccess(cart) )\n  )\n// 2nd iteration: do not perform the assertions\n  testTakeAndCall(gen, noop)\nconst error = {}\n   t.deepEqual(\n    gen.next({error}).value, \n   put( actions.checkoutFailure(error) )\n  )\nt.end()\n})\n```\n. > But I get my first assertions twice too\nThere is no way to return a generator back in time;  but you can factor out the part that test the 2 first assertions; then simply make the assertion noop on subsequent iterations\n``` javascript\nconst cart = {}\nconst getState = () ={ cart }\nfunction testTakeAndCall(gen, deepEqual) {\n   deepEqual(gen.next().value, \n   take(types.CHECKOUT_REQUEST),\n  )\ndeepEqual(\n    gen.next().value, \n    call(api.buyProducts, cart)\n  )\n}\ntest('checkout Saga test', function (t) {\nconst noop = () => {}\n  const gen = checkout(getState)\n// 1st iteration: perform the assertions\n  testTakeAndCall(gen, assert.deepEqual)\nconst response = {}\n  t.deepEqual(\n    gen.next({response}).value, \n   put( actions.checkoutSuccess(cart) )\n  )\n// 2nd iteration: do not perform the assertions\n  testTakeAndCall(gen, noop)\nconst error = {}\n   t.deepEqual(\n    gen.next({error}).value, \n   put( actions.checkoutFailure(error) )\n  )\nt.end()\n})\n```\n. I dont think it's a big deal unless it has a noticeable impact on testing time. In my own experience this is negligible compared to the latency of other tests (ui, integration)\nBut your separate function could be useful as it can be made reusable\n. I dont think it's a big deal unless it has a noticeable impact on testing time. In my own experience this is negligible compared to the latency of other tests (ui, integration)\nBut your separate function could be useful as it can be made reusable\n. > but it misses any extra actions fired in that 1 second delay.\nYes you're right (perhaps not the best example to start with). \nTo express parallelism, we use fork, for example\n``` javascript\nimport { take, put, fork } from 'redux-saga'\n// worker saga\nfunction* incrementAsync() {\n  yield delay(1000)\n  yield put( increment() )\n}\n// watcher saga\nfunction* watchIncrementAsync() {\n  while(true) {\n    const nextAction = yield take(INCREMENT_ASYNC)\n    yield fork(incrementAsync)\n  }\n}\n```\nThe watcher saga can also be made reusable as illustrated in your createSaga example\n``` javascript\nimport { take, put, fork } from 'redux-saga'\nfunction* watch(actionType, workerSaga) {\n  while(true) {\n    const nextAction = yield take(actionType)\n    yield fork(workerSaga)\n  }\n}\n// start incrementAsync on each INCREMENT_ASYNC\nwatch(INCREMENT_ASYNC, incrementAsync)\n```\nwhich mimics somewhat the callback behavior\nWe can also express concurrency between parallel tasks, if for example we want each new incoming INCREMENT_ASYNC action to cancel any ongoing async increment and keep only the latest one (like flatmapLatest in Observables)\n``` javascript\nfunction* incrementAsync() { ... }\n// watcher saga\nfunction* watchIncrementAsync() {\n  let task\n  while(true) {\n    const nextAction = yield take(INCREMENT_ASYNC)\n    // cancel task if pending\n    if(task)\n      yield cancel(task)\ntask = yield fork(incrementAsync)\n\n}\n}\n```\nNote this behavior can also be made reusbale\n``` javascript\nfunction* incrementAsync() { ... }\n// watcher saga\nfunction* watchLatest(actionType, workerSaga) {\n  let task\n  while(true) {\n    const nextAction = yield take(actionType)\n    // cancel task if pending\n    if(task)\n      yield cancel(task)\ntask = yield fork(workerSaga)\n\n}\n}\nwatchLatest(INCREMENT_ASYNC, incrementAsync)\n```\n\nYou don't know in advance when or if a saga will attempt to take a given action type, so you are forced to buffer all actions indefinitely.\n\nOne of the main reason I avoided buffering is because of the related memory issues as you mentioned, this was already discussed (see this comment). \nEvent buffering, via channels, has the benefit of being more predictable. Especially for case involving inter-saga communication. The time or the order (ie who started first) of which inter-communicating sagas has started or dispatched doesn't matter (for example see this pin pong example from the js-csp site)\n\nbut I don't think you should be putting state inside your sagas. Keep your state in the store (updated via reducers).\n\nActually, there 2 different opinions about this. \n@slorber (who introduced me to the Saga concept). thinks it's not right for Sagas to be coupled with state shape and only depend on the event log (Redux actions). see #8\n\nEDIT: fixed example code\n. > but it misses any extra actions fired in that 1 second delay.\n\nYes you're right (perhaps not the best example to start with). \nTo express parallelism, we use fork, for example\n``` javascript\nimport { take, put, fork } from 'redux-saga'\n// worker saga\nfunction* incrementAsync() {\n  yield delay(1000)\n  yield put( increment() )\n}\n// watcher saga\nfunction* watchIncrementAsync() {\n  while(true) {\n    const nextAction = yield take(INCREMENT_ASYNC)\n    yield fork(incrementAsync)\n  }\n}\n```\nThe watcher saga can also be made reusable as illustrated in your createSaga example\n``` javascript\nimport { take, put, fork } from 'redux-saga'\nfunction* watch(actionType, workerSaga) {\n  while(true) {\n    const nextAction = yield take(actionType)\n    yield fork(workerSaga)\n  }\n}\n// start incrementAsync on each INCREMENT_ASYNC\nwatch(INCREMENT_ASYNC, incrementAsync)\n```\nwhich mimics somewhat the callback behavior\nWe can also express concurrency between parallel tasks, if for example we want each new incoming INCREMENT_ASYNC action to cancel any ongoing async increment and keep only the latest one (like flatmapLatest in Observables)\n``` javascript\nfunction* incrementAsync() { ... }\n// watcher saga\nfunction* watchIncrementAsync() {\n  let task\n  while(true) {\n    const nextAction = yield take(INCREMENT_ASYNC)\n    // cancel task if pending\n    if(task)\n      yield cancel(task)\ntask = yield fork(incrementAsync)\n\n}\n}\n```\nNote this behavior can also be made reusbale\n``` javascript\nfunction* incrementAsync() { ... }\n// watcher saga\nfunction* watchLatest(actionType, workerSaga) {\n  let task\n  while(true) {\n    const nextAction = yield take(actionType)\n    // cancel task if pending\n    if(task)\n      yield cancel(task)\ntask = yield fork(workerSaga)\n\n}\n}\nwatchLatest(INCREMENT_ASYNC, incrementAsync)\n```\n\nYou don't know in advance when or if a saga will attempt to take a given action type, so you are forced to buffer all actions indefinitely.\n\nOne of the main reason I avoided buffering is because of the related memory issues as you mentioned, this was already discussed (see this comment). \nEvent buffering, via channels, has the benefit of being more predictable. Especially for case involving inter-saga communication. The time or the order (ie who started first) of which inter-communicating sagas has started or dispatched doesn't matter (for example see this pin pong example from the js-csp site)\n\nbut I don't think you should be putting state inside your sagas. Keep your state in the store (updated via reducers).\n\nActually, there 2 different opinions about this. \n@slorber (who introduced me to the Saga concept). thinks it's not right for Sagas to be coupled with state shape and only depend on the event log (Redux actions). see #8\n\nEDIT: fixed example code\n. As a side note, for the above examples to work; fork has to be truly non blocking, ie has to resume immediately/synchronously. Otherwise it may miss other actions dispatched synchronously from components/Redux middlewares. with the promise-based version of the lib, fork doesn't resolve until the next microtask which make it loose events happened in-between. \n\nI tried first to fix this by keeping the actions for some time for the current event queue (using setImmediate / requestAnimationFrame as a timeout to discard the action later) But some other issues persisted; for example when a saga does yield fork(otherSaga). otherSaga takes some time to start (in the next microtask) which makes it miss its startup actions (buffering wont work because the saga hasn't started yet and we can't give it any action [each saga has its own action buffer and shared action buffer is not possible because we must then keep all actions all the time for future sagas]); \nThe solution seemed to be the parent saga passing the current action queue to all its forked/called child sagas but it doesn't work; The solution began to look more and more hacky/complicated so I decided to stop right here. and took the other more radical way: using callbacks mainly because they don't have the latency problem of microtasks. And because it make it possible for the library to express true non-blocking semantics (ie non-blocking means the saga resumes immediately)\n. As a side note, for the above examples to work; fork has to be truly non blocking, ie has to resume immediately/synchronously. Otherwise it may miss other actions dispatched synchronously from components/Redux middlewares. with the promise-based version of the lib, fork doesn't resolve until the next microtask which make it loose events happened in-between. \nI tried first to fix this by keeping the actions for some time for the current event queue (using setImmediate / requestAnimationFrame as a timeout to discard the action later) But some other issues persisted; for example when a saga does yield fork(otherSaga). otherSaga takes some time to start (in the next microtask) which makes it miss its startup actions (buffering wont work because the saga hasn't started yet and we can't give it any action [each saga has its own action buffer and shared action buffer is not possible because we must then keep all actions all the time for future sagas]); \nThe solution seemed to be the parent saga passing the current action queue to all its forked/called child sagas but it doesn't work; The solution began to look more and more hacky/complicated so I decided to stop right here. and took the other more radical way: using callbacks mainly because they don't have the latency problem of microtasks. And because it make it possible for the library to express true non-blocking semantics (ie non-blocking means the saga resumes immediately)\n. > At the very least, your examples should all religiously enforce this separation, or you will just leave users with these subtle race conditions.\nThere are still some cases which can not be trivially described by the watcher/worker pattern; in some complex flows: a worker may itself forks other worker at some moments. The point is that the model gives enough flexiblity to implement from simple to complex flows; some time we may need a behavior different than watch, watchLatest (eg. put the results of requests according to their dispatch order)\nBut Perhaps you're right; maybe the lib should provide helper functions for the more common use cases (like watch/wachLatest) and use them in the repo examples. This could act as a guard against a bunch of future issues;\n\nAs for promises, you could have any non-blocking calls (e.g. take, fork and cancel) return plain values, and delay etc. can return promises.\n\nWhen I said I shifted away from promises, I didn't mean the library doesn't support yielding promises. I was talking about the internal implementation;\nredux-saga is not like libs like co; take, call, fork and all other effects actually all returns plain object; even if you do yield call(delay, 1000); call(delay) doesn't call the delay function. It just creates a plain object description like {type: 'call', func: delay, args: [1000]} and the execution/interpretation is performed by the middleware. It makes possible testing the generator easily without executing any real service call, simply iterate over the generator and examines the yielded values.\nthe core function that drives the generator internally takes all yielded effects (take, call ...); execute them then wraps all results automatically in promises; using promise simplifies the generator plumbing because it exposes an unified interface, and also parallelism and race could be implemented directly on top of Promise.all/Promise.race. The problem is that using promise chaining to drive the generator causes the issues I mentioned; So I just got rid of the promise wrapping and used callback notification internally: when results of effects are simple values I notify the generator to resume immediately and when the result is a promise I notify when the promise resolve/reject.\n. > At the very least, your examples should all religiously enforce this separation, or you will just leave users with these subtle race conditions.\nThere are still some cases which can not be trivially described by the watcher/worker pattern; in some complex flows: a worker may itself forks other worker at some moments. The point is that the model gives enough flexiblity to implement from simple to complex flows; some time we may need a behavior different than watch, watchLatest (eg. put the results of requests according to their dispatch order)\nBut Perhaps you're right; maybe the lib should provide helper functions for the more common use cases (like watch/wachLatest) and use them in the repo examples. This could act as a guard against a bunch of future issues;\n\nAs for promises, you could have any non-blocking calls (e.g. take, fork and cancel) return plain values, and delay etc. can return promises.\n\nWhen I said I shifted away from promises, I didn't mean the library doesn't support yielding promises. I was talking about the internal implementation;\nredux-saga is not like libs like co; take, call, fork and all other effects actually all returns plain object; even if you do yield call(delay, 1000); call(delay) doesn't call the delay function. It just creates a plain object description like {type: 'call', func: delay, args: [1000]} and the execution/interpretation is performed by the middleware. It makes possible testing the generator easily without executing any real service call, simply iterate over the generator and examines the yielded values.\nthe core function that drives the generator internally takes all yielded effects (take, call ...); execute them then wraps all results automatically in promises; using promise simplifies the generator plumbing because it exposes an unified interface, and also parallelism and race could be implemented directly on top of Promise.all/Promise.race. The problem is that using promise chaining to drive the generator causes the issues I mentioned; So I just got rid of the promise wrapping and used callback notification internally: when results of effects are simple values I notify the generator to resume immediately and when the result is a promise I notify when the promise resolve/reject.\n. > or you will just leave users with these subtle race conditions.\nIf I understand. Your point is that the lib actually provides a double-edged sword \n. > or you will just leave users with these subtle race conditions.\nIf I understand. Your point is that the lib actually provides a double-edged sword \n. @ForbesLindesay I was thinking of creating a redux-saga-contrib repo which provides higher level abstractions (like watch). I'm writing a step by step tutorial and I find it a little hard to write correct examples without introducing too much concepts at once (fork, call, blocking/non blocking)\nThinking if we've such a higher level lib, then we can make the project more accessible. And newcomers can use safe abstractions provided by default. Advanced users can still use the low level functions to implement non trivial flows (and of course Advanced users should know when to make blocking and non blocking calls)\nAbout race conditions, it's true that using call carelessely exposes users to race conditions. But simple callbacks have also their own kind of race conditions: If a new Redux user for example uses redux-thunk  just as it is to handle AJAX requests, there are also subtle race conditions here (out of order responses although this is less serious than missing actions). \nWhile I agree that we should provide safe abstractions to be used by new users. IMO the main goal shouldn't be to hide race conditions. Instead we need the developers to be aware of them when they're specifying an async control flow. The developer has always to ask\n- Do I need a simple merge like the one provided by callbacks ?\n- Do I need to ignore concurrent actions (e.g. infinite scroll) ?\n- Do I need to take only the latest action ?\n- Do I need to queue concurrent actions ?\n. @ForbesLindesay I was thinking of creating a redux-saga-contrib repo which provides higher level abstractions (like watch). I'm writing a step by step tutorial and I find it a little hard to write correct examples without introducing too much concepts at once (fork, call, blocking/non blocking)\nThinking if we've such a higher level lib, then we can make the project more accessible. And newcomers can use safe abstractions provided by default. Advanced users can still use the low level functions to implement non trivial flows (and of course Advanced users should know when to make blocking and non blocking calls)\nAbout race conditions, it's true that using call carelessely exposes users to race conditions. But simple callbacks have also their own kind of race conditions: If a new Redux user for example uses redux-thunk  just as it is to handle AJAX requests, there are also subtle race conditions here (out of order responses although this is less serious than missing actions). \nWhile I agree that we should provide safe abstractions to be used by new users. IMO the main goal shouldn't be to hide race conditions. Instead we need the developers to be aware of them when they're specifying an async control flow. The developer has always to ask\n- Do I need a simple merge like the one provided by callbacks ?\n- Do I need to ignore concurrent actions (e.g. infinite scroll) ?\n- Do I need to take only the latest action ?\n- Do I need to queue concurrent actions ?\n. @ForbesLindesay the new release 0.8.0 introduced the helper functions takeEvery and takeLatest which offers a safer way for new users. The helpers are introduced early in the docs (README, beginner tutorial and basics section)\ntake is not introduced until the advanced section And Immediately followed by a section on Non blocking calls. This section illustrates the pitfalls of using take with call, and shows the right way to do non blocking calls when using take to implement complex flows.\nI also started refactoring the examples in the repo to use the helpers. \nDo you think this would be sufficient to prevent the mentioned race issues ? New users are exposed only to the helper functions. And advanced users are warned about the use of take with blocking calls.\nAlso you may find here an interesting case of how 'missing' the actions allows implementing some useful patterns like throttling and debouncing.\n. @ForbesLindesay the new release 0.8.0 introduced the helper functions takeEvery and takeLatest which offers a safer way for new users. The helpers are introduced early in the docs (README, beginner tutorial and basics section)\ntake is not introduced until the advanced section And Immediately followed by a section on Non blocking calls. This section illustrates the pitfalls of using take with call, and shows the right way to do non blocking calls when using take to implement complex flows.\nI also started refactoring the examples in the repo to use the helpers. \nDo you think this would be sufficient to prevent the mentioned race issues ? New users are exposed only to the helper functions. And advanced users are warned about the use of take with blocking calls.\nAlso you may find here an interesting case of how 'missing' the actions allows implementing some useful patterns like throttling and debouncing.\n. Sorry here is the link to the comment\nhttps://github.com/yelouafi/redux-saga/issues/105#issuecomment-184754941\n. Sorry here is the link to the comment\nhttps://github.com/yelouafi/redux-saga/issues/105#issuecomment-184754941\n. @slorber Yes I think also Sagas should be introduced.\n@cef62 I agree. will be a good start. Thanks for working on this\n@cherta Thanks. Integration with the router would make a good example.\n. @slorber Yes I think also Sagas should be introduced.\n@cef62 I agree. will be a good start. Thanks for working on this\n@cherta Thanks. Integration with the router would make a good example.\n. > Do you think a transition guide from redux-thunk would be useful?\nYes perhaps the tutorial should adopt this approach. to make learning as smooth as possible\n. > Do you think a transition guide from redux-thunk would be useful?\nYes perhaps the tutorial should adopt this approach. to make learning as smooth as possible\n. FYI, thanks to @cef62 actual docs were migrated to GitBook. docs are now on this link\nhttp://yelouafi.github.io/redux-saga/\nAny suggestions for the TOC are welcome\nAlso added a section for API reference\nhttp://yelouafi.github.io/redux-saga/docs/api/index.html\nStill need some improvements but better than nothing \n. FYI, thanks to @cef62 actual docs were migrated to GitBook. docs are now on this link\nhttp://yelouafi.github.io/redux-saga/\nAny suggestions for the TOC are welcome\nAlso added a section for API reference\nhttp://yelouafi.github.io/redux-saga/docs/api/index.html\nStill need some improvements but better than nothing \n. @gaearon thanks! Hope to add more content next week \n. @gaearon thanks! Hope to add more content next week \n. @gaearon done. thanks\n. @gaearon done. thanks\n. @staltz Thanks for you feedback. I agree that the Intro should adopt more familiar terms like Asynchronous actions, workflow, background tasks ...\nFor the Saga term, it's true that Sagas as used in the backend seem different from the frontend (long running business transactions, failure management ...) and may put people in confusion. But dropping it completely seems a bit radical. Even in the backend people appear to use Sagas in different contexts (I think the same thing goes for FRP if we take into consideration how the concept has evolved since the original conal elliott's paper).\nIt seems to me that the steep learning curve has more to do with the amount of new things a new user has to digest (Generators, async Generators, event pulling, declarative Effects, concurrency management ...). And I think the focus should be on explaining those concepts and putting them in context (tutorials, common cases examples)\n. @staltz Thanks for you feedback. I agree that the Intro should adopt more familiar terms like Asynchronous actions, workflow, background tasks ...\nFor the Saga term, it's true that Sagas as used in the backend seem different from the frontend (long running business transactions, failure management ...) and may put people in confusion. But dropping it completely seems a bit radical. Even in the backend people appear to use Sagas in different contexts (I think the same thing goes for FRP if we take into consideration how the concept has evolved since the original conal elliott's paper).\nIt seems to me that the steep learning curve has more to do with the amount of new things a new user has to digest (Generators, async Generators, event pulling, declarative Effects, concurrency management ...). And I think the focus should be on explaining those concepts and putting them in context (tutorials, common cases examples)\n. @slorber \n\nthe original async counter example does not really speak to me\n\ntotally agree; and it's broken en plus.\n. @slorber \n\nthe original async counter example does not really speak to me\n\ntotally agree; and it's broken en plus.\n. > The library can\u2019t really be explained in a good way if one refuses to acknowledge that these types of things exist and make specific sense in the context of the library (and correspond to types). However, once we determine those terms, we need to be careful to only mention these types in the documentation, and not anything else.\nThat what I think. The goal is not hide 'difficult concepts' from the developer, Instead we should introduce them in a way that's both progressive and accessible.\nThe main difficulty I'm encountering now (to write a tutorial) is how to introduce things one by one, even a simple Counter example needs multiple concepts at once (Declarative Effects, the event pull concept, forking if we need to provide a correct example)\n. > The library can\u2019t really be explained in a good way if one refuses to acknowledge that these types of things exist and make specific sense in the context of the library (and correspond to types). However, once we determine those terms, we need to be careful to only mention these types in the documentation, and not anything else.\nThat what I think. The goal is not hide 'difficult concepts' from the developer, Instead we should introduce them in a way that's both progressive and accessible.\nThe main difficulty I'm encountering now (to write a tutorial) is how to introduce things one by one, even a simple Counter example needs multiple concepts at once (Declarative Effects, the event pull concept, forking if we need to provide a correct example)\n. Suggestions for a new Introductions ? \nShould at least keep the terms mentioned by @gaearon (Saga, Effect, Background tasks). \nNeed to explain what Sagas are about in familiar terms. For now I'm thinking of\n- Simplify Async control flow\n- Easy testing\n- Decouple Components from Reducers\n. Suggestions for a new Introductions ? \nShould at least keep the terms mentioned by @gaearon (Saga, Effect, Background tasks). \nNeed to explain what Sagas are about in familiar terms. For now I'm thinking of\n- Simplify Async control flow\n- Easy testing\n- Decouple Components from Reducers\n. @gaearon I'm aware of this, I discussed this with @ForbesLindesay in #68. That's what I meant by\n\neven a simple Counter example needs multiple concepts at once (Declarative Effects, the event pull concept, forking if we need to provide a correct example)\n\nI think he's right about the examples being misleading even If they're short snippets. I'm currently writing an introductory tutorial and managing concurrency is planned here by pointing out the issue with blocking calls.\nI think concurrency should be introduced early, and for the examples which makes blocking calls (like in call docs) put a warning about it.\nAnother complementary solution is by providing higher level abstractions that are safe to use for common cases (watch, watchLatest and maybe more see https://github.com/yelouafi/redux-saga/issues/68#issuecomment-178086859). I'm thinking of adding a redux-saga-contrib repo which provides those helpers and use them in the examples and repo demos when possible.\nEnforcing the non blocking calls in the core library is complicated. as @slorber commented in #68, the library provides low level functions for concurrency which make it possible to implement complicated flows which are not trivial to write using simple watch or watchLatest\nMy point is that we should not hide race concerns from developers; instead make the library users aware of them in the best way. thinking about race conditions is inavoidable even in the most obvious cases. A simple example is concurrent requests using redux-thunk: the default behavior is not 100% safe because it doesn't handle out of order responses (ie application state could be updated with outdated response).\n. @gaearon I'm aware of this, I discussed this with @ForbesLindesay in #68. That's what I meant by\n\neven a simple Counter example needs multiple concepts at once (Declarative Effects, the event pull concept, forking if we need to provide a correct example)\n\nI think he's right about the examples being misleading even If they're short snippets. I'm currently writing an introductory tutorial and managing concurrency is planned here by pointing out the issue with blocking calls.\nI think concurrency should be introduced early, and for the examples which makes blocking calls (like in call docs) put a warning about it.\nAnother complementary solution is by providing higher level abstractions that are safe to use for common cases (watch, watchLatest and maybe more see https://github.com/yelouafi/redux-saga/issues/68#issuecomment-178086859). I'm thinking of adding a redux-saga-contrib repo which provides those helpers and use them in the examples and repo demos when possible.\nEnforcing the non blocking calls in the core library is complicated. as @slorber commented in #68, the library provides low level functions for concurrency which make it possible to implement complicated flows which are not trivial to write using simple watch or watchLatest\nMy point is that we should not hide race concerns from developers; instead make the library users aware of them in the best way. thinking about race conditions is inavoidable even in the most obvious cases. A simple example is concurrent requests using redux-thunk: the default behavior is not 100% safe because it doesn't handle out of order responses (ie application state could be updated with outdated response).\n. > maybe watch/watchLatest should be in core and be one of the first example.\nIn thinking about it, perhaps this is the most suitable solution.\n. > maybe watch/watchLatest should be in core and be one of the first example.\nIn thinking about it, perhaps this is the most suitable solution.\n. > Figure out which utilities are needed in 95% of apps and include them in the core.\nFor now it seems the most common needs are watch (which provides thunk like behavior) and watchLatest(which handles out of order responses by taking only the last response).\nProbably another utility is one that outputs the responses in the same order of the requests\nRx and Bacon.js can also serve as a good reference (the flatMap and family functions)\n. > Figure out which utilities are needed in 95% of apps and include them in the core.\nFor now it seems the most common needs are watch (which provides thunk like behavior) and watchLatest(which handles out of order responses by taking only the last response).\nProbably another utility is one that outputs the responses in the same order of the requests\nRx and Bacon.js can also serve as a good reference (the flatMap and family functions)\n. > and be one of the first example.\nDo you think the introductory tutorial should only use the Higher level API ?\n. > and be one of the first example.\nDo you think the introductory tutorial should only use the Higher level API ?\n. > You mean it only takes the response of the last query I guess?\nYes\n\nI think watch examples should be on the front page. That\u2019s what people come for. We can introduce generators later.\n\nBut still, the developer needs to implement the watch logic using Generators\n. > You mean it only takes the response of the last query I guess?\nYes\n\nI think watch examples should be on the front page. That\u2019s what people come for. We can introduce generators later.\n\nBut still, the developer needs to implement the watch logic using Generators\n. Do you think watch and  watchLatest should return something ?\nThe denotation seems like a dynamic array of tasks. Should it be something with getTasks() method (in case of watchLatest it's only one task: the latest)  ?\n. Do you think watch and  watchLatest should return something ?\nThe denotation seems like a dynamic array of tasks. Should it be something with getTasks() method (in case of watchLatest it's only one task: the latest)  ?\n. An idea is to make the middleware accept also watch Effects besides Saga\n``` javascript\n// Allow concurrent fetches of user \nexport const watchUserRequests = watch(\"USER_FETCH_REQUESTED\",fetchUser);\n// Do not allow concurrent fetches of user\n// If \"USER_FETCH_REQUESTED\" gets dispatched \n// while a fetch is already pending, that pending fetch is cancelled \n// and only the latest one will be run\nexport const watchUserRequests = yield watchLatest(\"USER_FETCH_REQUESTED\",fetchUser);\n// in another module\nimport { watchUserRequests, someSaga } from './sagas'\nconst sagaMiddleware = createSagaMiddleware(watchUserRequests, someSaga)\n```\n. An idea is to make the middleware accept also watch Effects besides Saga\n``` javascript\n// Allow concurrent fetches of user \nexport const watchUserRequests = watch(\"USER_FETCH_REQUESTED\",fetchUser);\n// Do not allow concurrent fetches of user\n// If \"USER_FETCH_REQUESTED\" gets dispatched \n// while a fetch is already pending, that pending fetch is cancelled \n// and only the latest one will be run\nexport const watchUserRequests = yield watchLatest(\"USER_FETCH_REQUESTED\",fetchUser);\n// in another module\nimport { watchUserRequests, someSaga } from './sagas'\nconst sagaMiddleware = createSagaMiddleware(watchUserRequests, someSaga)\n```\n. Question about the naming, what would be more suitable\njavascript\nwatch(REQUEST, fetch)\nwatchLatest(REQUEST, fetch)\nvs\njavascript\non(REQUEST, fetch)\nonLatest(REQUEST, fetch)\n. > It would also be great if there was an easy way to tell between effects (take, put) and saga helpers.\nMy initial idea was to make them higher order functions which return Sagas. But it has a minor side effect, the returned sagas will be anonymous Generator functions so it may make debugging and monitoring less obvious.\n\nFinally, I\u2019m not completely for anything that hides that top-level sagas are generators because this will make people assume watch is the only way to create them. \n\nYou're right. Finally I don't feel that solution either\n. > yield* takeEvery('USER_FETCH_REQUESTED', fetchUser);\nGenerator delegation solves the issue with anonymous functions. And as you said we don't need to implement a watch effect.\nthis also would make the implementation much easier\n\nyield getState();\n\nthis solve the issue partly (In the real-world demo for example, the root Saga passes different selectors to sub-sagas). But I guess still better than passing getState around\nI think @slorber could have some objections here :)\nFor the last example, the root Saga won't terminate until all called Sagas terminate. It could be desirable but wanted just to mention that saga will also terminate if an Error bubbles from one of the child sagas\n. BTW maybe a naive question; how can I make this possible\njavascript\nimport ... from 'redux-saga/effects'\nUntil now I can only achieve this\njavascript\nimport ... from 'redux-saga/lib/effects'\n. Totally forgot about module.exports. thanks!\n. > Would it be nice to have some kind of block diagram? Just to show where you could use saga's in Redux.\nThat would be nice.\nBTW nice article @ngerritsen. Thanks\n. @markerikson You may find useful this series on Generators written by Kyle Simpson\n. FYI released 0.8.0 \nhttps://github.com/yelouafi/redux-saga/releases/tag/v0.8.0\nThe release include the takeEvery and takeLatest helpers.\nThere are some additions on the docs\n- Added a beginner Tutorial. No shiny demos, This is a simple tutorial for beginners I tried make the basic concepts for new users as accessible as I can.\n- Rearranged the TOC. the Basics section doesnt include the take Effect. Event pulling is introduced in the Advanced Section and then immediately followed by a section on non blocking calls/Concurrency to illustrate concurrency issues.\nThe main reason behind this is that I think take shouldn't be used by new users until they become aware of concurrency issues. I'll also refactor the repo examples to use the helper functions\n. Forgot to mention the changes in the readme\n. @nickzarate Maybe it's a little early for best practices as we need to get feedback from people using it in real world apps. But I agree we'll have to add some 'advices' in the recipes section.\nActually i'm thinking of a few But there maybe there are better opinions\nTestability\n- Use declarative call form yield call(fn,...) instead of yield fn(...) \n- Use named functions in take(fn) instead of inlined take(action => ...).\n- Avoid using call(fn.bind(...)) as bind returns a different reference on each call  \nWork Organisation\n- Separation watcher/worker\n- Favor high level API takeEvery/takeLatest\n- Use take only when necessary (non trivial flow) and preferably to build other Higher level APIs\nThere maybe others related to how to use Store state, connect to external event emitters ...\n. Closing this. It was mainly to track the migration of docs from single README to gitbook. Sure there are still things to be added but I think this is an ongoing process that can't be tracked in ad-hoc issue. it's better to create specific issues for each use case using the docs label\n. thanks! I missed this one :)\n. FYI released a patch version 0.6.1 with this fix.\n. thanks\n. @prashaantt Normally Sagas aren't fired from within UI components; but are started with your application; If an UI component need to communicate something to a Saga you can do it by dispatching the action from the component and taking it in the Saga\nFor example\n``` javascript\n// component file\nclass MyComponent extends React.Component {\ncomponentDidMount() {\n     dispatch( myAction() )\n  }\n}\n// In your Saga\nfunction *mySaga() {\n   while(true) {\n      const action = yield take(MY_ACTION)\n      // do something with action\n   }\n}\n```\n. > will I have to boot my app with all those forked while loops waiting for those future actions without needing to worry about any performance issues?\nThe while loop doesn't run synchronously; for example when you do something like\n``` javascript\nfunction* watchApiRequest() {\n   while(true) {\n      const action = yield take(API_REQUEST)\n      yield fork(doSomeWork, action)\n   }\n}\nfunction* doSomeWork(action) {\n  const response = yield call(someApi, action.payload)\n  yield put(actions.response(response)\n}\n```\nIn watchApiRequest, the while(true) will block on yield take(API_REQUEST) until it receives an action of type API_REQUEST. When a matching action occurs, it'll fork doSomeWork then will block again until another action happens.\nAs for doSomeWork it terminates as soon as it performs the yield put(...). So there are no memory issues, because the infinite-ish while loop progresses only as matching actions are taken; and the forked worker tasks terminates as soon as they finish their business\n\nWhat I'm still figuring out to do properly is to decide on how to structure multiple sagas in a complex app \n\nA simple pattern is to divide the flow between watcher sagas and a worker sagas. In the above example, the watcher Saga watchApiRequest watch for specific actions then forks worker tasks doSomeWork. Also see https://github.com/yelouafi/redux-saga/issues/68#issuecomment-178086859\n. @bradynapier thanks for sharing this.\nYou may find a related SO question here\nBasically, whenever we want to interface with a push source (DOM events, websocket messages); we build an event iterator (somewhat like channels in CSP or coroutines) then we can iterate over it inside the Saga\nhere is a slightly version of your example\n- We buffer incoming actions when the Saga is not waiting for them\n- We define a [CANCEL] method on the returned promises, so redux-saga will automatically call this\n  method if the promise looses in a race\n\nNote: Didn't test the code\n\n``` javascript\nimport { CANCEL } from 'redux-saga'\n// define a cancellable promise\n// will be called by redux-saga to cancel this promise\n// upon loosing on race\nfunction cancellablePromise(p, doCancel) {\n  p[CANCEL] = doCancel\n  return p\n}\nfunction firebaseIterator(ref) {\n  const messageQueue = []\n  const resolveQueue = []\nconst listenerID = ref.on('value', snapshot => {\n    const msg = snapshot.val()\n    // anyone waiting for a message ?\n    if (resolveQueue.length) {\n      const nextResolve = resolveQueue.shift()\n      nextResolve(msg)\n    } else {\n      // no one is waiting ? queue the event\n      messageQueue.push(msg)\n    }\n  })\nfunction close() {\n    ref.off(listenerID)\n  }\nreturn {\n    getNext() {\n      // do we have queued messages ?\n      if(messageQueue.length) {\n        return cancellablePromise( \n           Promise.resolve(messageQueue.shift()) \n        )\n      } else {\n         return cancellablePromise(\n            new Promise(resolve => resolveQueue.push(resolve))\n        )\n     }\n    }\n  }\n}\nfunction* onFirebaseData(accountRef, path, getState) {\n  const localRef = accountRef.child(path)\n  const { getNext } = yield call(firebaseIterator, localRef)\nvar cancel, data\n  while (!cancel) {\n    // if getNext loose, redux-saga will try to cancel it \n    // by looking for a CANCEL method on its promise result\n    ({data, cancel} = yield race({\n      data: call(getNext),\n      cancel: take(action => action.type === CANCEL_LISTENER && action.path === path)\n    })\nif (data) {\n  console.log('Received Data from Firebase Path!', path)\n  console.log(data)\n}\n\n}\n  console.log('Cancelling Firebase Listener at Path: ', path)\n}\n```\n. thanks!\n. > Would this be the official usage? \nActually yes. But there are some issues with the actual method runSaga (see #48). Sagas started by runSaga can't see actions from sagas started by the middleware\n\nIt looks like a middleware approach was discussed in #13 (comment) that would have solved this\n\nNot a middleware but a store enhancer. There are some potential issues with this approach (see https://github.com/yelouafi/redux-saga/issues/13#issuecomment-169179962)\nIt seems the solution proposed by @gaearon (https://github.com/yelouafi/redux-saga/issues/48#issuecomment-176231891) is the simplest one; a run method will be attached to the middleware itself.\n\nWould this be the official usage? What about \"stopping/removing/disconnecting\" the sagas? Will this work with server side rendering?\nWhat about \"stopping/removing/disconnecting\" the sagas?\n\nDidn't think about this. But If we provide a way to dynamically attach sagas to the middleware, it makes sens to be able to detach them. I think we can do this by providing exposing a cancel method\n\nWill this work with server side rendering?\n\nI don't see any issue with that\n. > So basically as it stands now its not possible\nfor now you can use runSaga but only if your dynamic Sagas don't take actions from middleware-Sagas. Otherwise yes, it's not possible\n\nbut an \"official\" api (run method within the middleware) is being considered?\n\nYes exactly. I think I'll go with that. should be probably this week-end if things go well\n. > Usually in Redux we try to return a function for this, e.g. const unsubscribe = store.subscribe(...). Not saying it always makes sense but worth considering as an API choice.\nActually runSaga returns a task descriptor which contains some useful fields, like a done promise, an isRunning() method. My idea was adding some cancel(reason) method to the descriptor\n. FYI new 0.7.0 version is out with the new method of running dynamic sagas\n. Closing this, feel free to add your comments. I can reopen it if needed.\n. Great thanks for this @cef62 \n\nhe current file subdivision is hypothetical, if you'd like it as starting point I think you can merge the PR, otherwise let me know what change to make the PR acceptable.\n\nl prefer to take it as a starting point. It's good to have something concrete.\n\nIf you like this setup we can start working on real contents. \nI think maybe we should draft a more official TOC. Then we can subdivide the work on different chapters.\n\nAgree, I think the one in your actual setup makes a good starting point; thinking of adding the sections mentioned in #70; merged with the actual setup; it'll give something like\n- Introduction\n- Step by step tutorial\n- Basics\n- Advanced\n- Unit testing\n- Recipes (e.g. authorization, infinite scroll, integration with router, ...)\n- Common Concurrency Patterns (also see https://github.com/yelouafi/redux-saga/issues/50#issuecomment-179376628)\n- Troubleshooting\n- Links to external resources\n- Glossary\n- API reference\n- Contribute\nWhat do you think ?\n. Ok done: http://yelouafi.github.io/redux-saga/\nthere was an issue with docs:publish. I get the following error (seems to occur after cd _book && git init)\nInitialized empty Git repository in C:/My data/Yassine/projects/redux-saga/_book/.git/\nerror: pathspec 'book'' did not match any file(s) known to git.\nI managed to publish by running all the steps in docs:publish manually\n. Actual behavior propagates cancellation only to the current effect; i.e. where the Saga is blocked. For subtasks, it means the cancellation propagates only to called ones but not forked ones (since the saga is not blocked on them).\nDo you think cancellation should be automatically propagated to forked tasks also ? \nIt's true that until now I also only encountered cases when the cancellation should be propagated. But aren't there cases where the propagation is not desirable ?\nOr should we perhaps provide the 2 options (like an additional method spawn which automatically propagate the cancellation) ?\n. > also there's a case where the parent terminates before the forks. Should the forks be cancelled?\nIMO, That depends on the use case. For now the forking model as I see it is\n- forked children remain attached to their parent -> the lifetime of children is scoped by the parent's lifetime; So if the parent terminates (either normally or by error, including cancellation errors), children should also terminate (possibly adding another kind of exception for this case)\n- forked children are detached -> then children become totally independent of their parent; and not affected by the parent's outcome.\nEither we should overload fork (or provide a forkDetached function) to support detached forking (I also think the attached option should be the default as in Node). \nOr we can adopt the same interface in Node and provide a task.unref() (or task.detach()) method . Personally I prefer the first option.\n\nThis would make the path of least resistance to be that the cancelation of a parent saga could be used to \"turn off\" event streams that you have running in its forks, sort of an \"unsubscribeAll\" for forked child sagas.\n\nI dont think it's a good idea. A disconnected Saga seems to be useless. And more importantly with the sync looking flow of Generators; the only way to interrupt that flow is by the Exception mechanism. Unless we provide something like unix signals or old DOS interruption mechanism.\n. @slorber In this example you fork tasks then immediately join them\njavascript\nfunction* handleStamplesPaginationAndFiltering(model) {\n  const subtasks = [];\n  try {\n    subtasks.push(yield fork(stamplePaginateSaga,model))\n    subtasks.push(yield fork(stampleFilterUpdatesWatcher,model))\n    yield subtasks.map(join)\n  }\n  catch(e) {\n    if ( e instanceof SagaCancellationException ) {\n      yield subtasks.map(cancel);\n    }\n  }\n}\nwhy not simply use\njavascript\nfunction* handleStamplesPaginationAndFiltering(model) {\n  yield [\n    call(stamplePaginateSaga,model),\n    call(stampleFilterUpdatesWatcher,model)\n  ]\n}\nif handleStamplesPaginationAndFiltering is cancelled from a parent Saga, then the cancellation would propagate automatically to the current effect which is the parallel yield [...]. Parallel effect cancellation means cancellation of all sub-effects\n. I'm thinking of integrating this into the next release. \nThe mental model is that a parent + forked children represent a whole unit: a tree with multiple execution paths.\nHere is what I propose\n1. Cancellation of parent automatically triggers cancellation of all currently active forked tasks (we cancel the whole execution tree)\n2. A parent terminates when : \n   1. its own body terminates and\n   2. forked (and attached) tasks terminate (the whole execution tree must terminate)\n3. Provide an additional setting to fork detached children (the default for children is to be attached). The cases for this IMO should be pretty rare so rather than create another effect, W'll just provide this as a config option on the fork itself, something like : yield fork({fn, detached: true}, ...args) or yield fork(fn, ...args).detached\n(1) would handle common client side scenarios: when an UI page is unloaded we'd typically like to cancel all the tasks related to that page\n(2) would handle server side scenario: when we do render on the server, w'd like to wait for all triggered tasks to terminate before sending the HTML to the client (see #149)\n(3) would provide an alternative for other cases\n. @slorber I haven't looked in detail into the Actor Model. I'll have to check it to find more about.\n. FYI 0.10.0 fixes this\n. Thanks!\n. You dont have to catch cancel errors in someTaker. Errors wont bubble uo. \nThe main point of warnings is to remind the developer. And they are logged only in dev mode\n. First, sorry for the late response.\nI assume the someData param is missed in your first snippet\nThe issue is that calling checkFn(5) multiple times will lead to different results because checkFn will return a different function object on each invocation.\nWhat for example if we memoize the result of checkFn so it'd return the same function object for the same argument. \n``` javascript\n// for example using lodash memoize \nconst checkFn = _.memoize(\n  (dataToCheck) => ({ type, payload }) => \n    type === MY_CONST && payload && payload.data === dataToCheck\n)\nassert.equal( checkFn(5), checkFn(5) )\n``\n. As @slorber  said, theawaitcan be replaced byyield` because the middleware automatically resolves yielded Promises. \nI'd recommand using call to invoke Promised functions as it can make testing your Sagas easier. For more infos see Declarative Effects section\n. @aikoven It seems the apply function is missed\n. Thanks @aikoven.\n. Starting from 0.6 monitor actions fires only on dev mode. Do you have process.env. NODE_ENV set to 'development' ?\n. > I can open a PR if you like.\nOf course. Thanks!\n. Does the :: operator return the same reference on multiple invocations?\njavascript\n::obj.func === ::obj.func\nOtherwise w'd have some issue when testing sagas\n. @gaearon Agree. \n@bradennapier  It seems ::obj.func is just a syntactic sugar for obj.func.bind(obj) (from babel REPL). So it can't be tested by simple equality. You can't simply test you Saga using\n``` javascript\nfunction *mySaga() {\n  yield call(::obj.func)\n}\nconst gen = mySaga()\n// this will fail, because ::obj.func will return a different func object from the\n// one produced inside the Saga\nassert.deepEqual(gen.next().value, call(::obj.func))\n```\n. thanks\n. Yeah. Experienced that too :)\n. thanks. didn't know about it\n. > Perhaps you could remove it from there to prevent this confusion.\nYes. I think you're right\n. > I'll submit a new PR if you like it.\nOf course. Thanks!\n. thanks.\n. Ok. thanks again\n. thanks\n. The content in docs should mirror the website content. Unless i forgot to push something\nDid you see a difference between docs and website ?\n. No worry :) thanks\n. Sure it helps. Thanks for all the efforts. \n. Thanks for the fix\n\nFrom your npm scripts I believe you're the only one pushing to the gb-pages branch. Still, let me know if you'd like a PR for that as well.\n\nSorry, but didn't understood this. Can you explain ?\n. It's fine I already pushed to it (I do that each time I merge doc contributions). \n. Wow! How many thanks should I say :)\n. Micro thanks :)\n. Nano thanks :)\n. And thanks again :)\n. seems there is a typo to fix here Moar\n. Wait until you hear me singing :)\n. Thanks a lot @DjebbZ.\n. Yes. This needs to be updated since  0.7.0 deprecate connecting dynamic Sagas to the store using storeIO (https://github.com/yelouafi/redux-saga/releases).\nIn the API I left the runSaga empty. Since its main purpose now is to connect Sagas to external IO (other than the Store). I need to also update usage examples. \n. Ok a partial fix; moved runSaga new docs to\nhttp://yelouafi.github.io/redux-saga/docs/api/index.html#runsagagenerator-subscribe-dispatch-monitor\nand for this linke\nhttp://yelouafi.github.io/redux-saga/docs/advanced/UsingRunSaga.html\nPut a temporary fix. Need to put some concrete example here like connecting a Saga directly to a React component, or websocket data source ...\n. Can't come up yet with a useful example for runSaga. will tarck this in #60. I added a simple (although dumb) explanation. any comment or suggestions for use cases are welcome\n. I will fix that. thanks\n. Hmm.. I don't think is easy to express those patterns using a pull API like redux-saga (or async/await). With a push API it'll be more easy to do that. This is where libraries like Rx really shine.\nOTOH, we can make a Generator play nicely with push concepts. So a suitable way to do the composition IMO is not on the 2nd argument of watch (the Generator) but on the 1st argument (the Action to watch).\nFor example\n``` javascript\n// unchanged input\nwatchLatest(\"USER_FETCH_REQUESTED\" ,fetchUser);\n// map : transform the input\nwatchLatest(map(\"USER_FETCH_REQUESTED\", fn) ,fetchUser);\n// filter the input\nwatchLatest(filter(\"USER_FETCH_REQUESTED\", predicate) ,fetchUser);\n// throttle the input\nwatchLatest(throttle(\"USER_FETCH_REQUESTED\", millis) ,fetchUser);\n```\nThis also could be used by take effects to make the take pattern more powerful\n. @AriaFallah \n\nIt ended up being a long response. I hope It's not completely non-sens :)\n\nI tend to view the difference from a pull vs push perspective. Fundamentally it relates to how you deliver the result of a function call\npush vs pull\npull\nThe return value of the function is delivered via assignement.\njavascript\nconst result = func(...args)\nAbove We are pulling the result from func. This is the normal way we'are all used to.\npush\nThe return value of the function is delivered in the argument position (via callback). \njavascript\nfunc(...args, arg => ...)\nThe result is pushed into the callback passed as an additional parameter to the function.\niteration vs Observation\nAnother perspective is iteration vs observation, which extends the concept of pull/push from single values to collections (or more generally from scalar to compound values).\nIteration\nHappens when you are pulling values from a collection in sequence\n``` javascript\n// iterable: something that can returns an iterator\nconst iterator = iterable[Symbol.iterator]\n// iterator: has a next() method and returns a { value, done } result\nlet result = iterator.next()\nwhile(!result.done) {\n  //... do something with result.value\n  result = iterator.next()\n}\n```\nThe iterator acts as a producer of data and the while loop acts as a consumer of data. With iteration the consumer is always in control: you decide when to pull the next value\nObservation\nThe typical example is with Rx like observables\njavascript\n// observable: has a forEach(onNext, onEnd) method\n// Not quite the Rx signature, just simplifying for illustration\nobservable.forEach(\n/* onNext */ val => // ... do something with val\n/* onEnd */  ()  => // ... do something when ended\n)\nSame as above, the observable acts as a producer of data and the provided callbacks act as a consumer of data. But here the control is inversed, It's the producer who decide when to push the next value.\nWhen to use each one\nThe pull/iteration approach is more suitable when dealing with control flow. It maybe related to how human brain work, people find it easier to reason about a program written in the pull style.\nIt maybe also related to our legacy. Most of the accumulated  Programming Knowledge (AFAIK) was in the pull side: starting from algorithms, control structures (if, while, for), routine/subroutine... So most of our learning & experience is also done on the pull side.\nBut one thing is sure, we're always trying to transpose problems into the pull side (async/await, Generators)\nAnother advantage has to do with composability. If your function returns a value, it automatically makes it composable with other functions\n``` javascript\n// only possible if f and g both return something\nresult = f(g())\n// same as; \nx = g()\ny = f(x)\n```\nWith a pure push style (like in Node API) this is not possible, because callback style functions return undefined: and you can't do anything useful with undefined. You can learn more about in an old post I wrote From Callback to Future -> Functor -> Monad (do not feel intimidated by the terms in the title, the article is plain familiar English :) )\nOTOH The issue with a pure pull approach is when we deal with future values. I mean, when we call a function that may take some noticeable time before it can delivers its result (a common case is when you make a call to a remote server)\n``` javascript\n// server data may take a long time to return\nresult = getServerData()\n// doSomething with result\n```\nThe problem is how to deal, from the execution POV, with the getServerData() call ? Should we block the program until the function return ? clearly, this is not a good idea, because the program have certainly other things to do while waiting for the server result.\nTypically, those other things may involve responding to User interactions if We're in a UI program, or responding to network requests if we're in a server environment.\nFor a long time, the traditional way to deal with this issue was by using Threads, which are like separate programs running in parallel and typically managed by the Operating system. For example in a language like Java with a thread based API, if you do\n``` javascript\n// will suspend the current thread until the server returns\nresult = getServerData()\ndoSomething(result)\n```\nThis is a pull style approach, the runtime manages transparently the suspend/resume mechanics, so the developer can focus on writing code using a familiar synchronous style. As you see, pull style was there long before async/await but ...\nThe issue with the above approach is thread usage. Thread have a non negligible cost in terms of memory/performance. So to make it short, here come push based solutions like Node with its callback model. \n``` javascript\ngetServerData( result=> doSomething(result) )\n// continue and handle other things\n```\nSo, no threads, no suspension, just one thread to rule them all.getServerData will tell the runtime: I'm going to continue my business. When a result come, call this callback, it will know what to do.\n\nEdit: And anyway, JavaScript is single thread; So we can't implement a thread based solution on it even if we'd like to do it\n\nThe main advantage of this approach is performance, since there is no memory/performance overhead of threads usage.\nBut this push approach isn't only suitable for technical reasons. It may become necessary when we deal with events. here, it's more a conceptual constraint: we want to do some work when some event happens. The decisive moment here is when the event happens, so it makes plain sens that the event producer takes control in this case: ie a push approach is more suitable.\nAre Promises/Observable a push concept ?\nNot exactly, the Promise/Observable concepts advantage is to wrap the callback push concept in an abstraction (e.g. a Promise is like a magical box holding the eventual content of a Future result). Then you can use this abstraction and pass it around to your program as a first class value (i.e. use either as argument or return value).\nSo now with promises we have the same Java/thread based code, except one thing: instead of returning a plain value we return a Promise\n``` javascript\n// result is a promise\nresult = getServerData()\nresult.then(value => doSomething(value) )\n```\nNote also the whole result.then(value => doSomething(value) ) will result in another Promise if you return some value from doSomething. So you can also continue in a sequential/pseudo-synchronous style\nObservable, extends the Promise abstraction further to deal also with event observation\n``` javascript\n// result is an Observable\nresult = domElement.on('click')\nresult.forEach(eventData => doSomething(eventData) )\n```\nSo There is a pull because now the we can get something from the functions. And this is very important: if a function returns something, it means the function can be composed with other functions; If a function returns undefined it means you hit a wall. With composition you never hit a wall.\nBut there is still a push because result.then/results.forEach deliver their results in the argument position. So it's more an interleaving of push/pull (And it's always like that in other solutions, just matter of what the library exposes and what it hides from you)\nSo for the Promise case, come async/await\n``` javascript\nasync function myfunc() {\n  // result is a plain value\n  result = await getServerData()\ndoSomething(result)\n}\n```\nWe get the same synchronous style as in the Thread based solutions but without the costs incurred by thread usage.\nNow the next step is to extend the above sync model to Observable. Here enter Generators\nGenerators as iterators and observers\nIf Generators are capable of replicating the async/await model. it's because they encapsulate both the iterator and the observer pattern\nGenerators as iterators\nThe mostly-known usage of Generators\n``` javascript\n// produces an infinite sequence of 0, 1, 2 ...\nfunction* naturalNumbers() {\n let k = 0\n while(true) {\n   yield k\n   k++\n }\n}\nconst iterator = naturalNumbers()\niterator.next().value // => 0\niterator.next().value // => 1\niterator.next().value // => 2\n```\nGenerators as observers\nThis is a less known side of Generators\n``` javascript\nfunction* logEvents() {\n  // wait for a value that will get passed as argument to next\n  while(true) {\n    const event = yield;\n    console.log(event)\n  }\n}\nconst observer = logEvents()\nobserver.next() // forward one step since w're not interested on yielded values\ndocument.addEventListener('click', observer.next.bind(observer))\n```\nThe Generator doesn't produce any value, it just sits and waits for something to get passed to it. The Generator driver here is in control: it can advance the Generator by providing it an input.\nBut note the Generator doesn't produce observables, it just produce observers; there are some possible ways to achieve this: You can read more about one proposed solution here (https://github.com/jhusain/asyncgenerator)\nWhat about redux-saga\nTBH, I can't even pretend there was a conceptual phase where the model was specified before implementation. I started it as a Proof of Concept following a discussion where @slorber introduced me to the concept of Saga (in the case of React/Redux it acts like a mediator between Components and Reducers). \nTo describe the model a posteriori. I could say it's a more imperative model than FP (like Observables/Promises). Each Saga can be connected to an input/output  and can fork/join/cancel one or multiple tasks.\nAnother difference is that it's a kind of Sand boxed model: everything happens inside the Generator by yielding effects. \nIf you'd like to compare it to Observables, you may see it as a super Observer which can handle/coordinate input from different Observables.\n\nEdit\n\nAlso We can also say that redux-saga introduces a pull model of events. where in observables you'd write \njavascript\neventObservable = someSource.on('click')\neventObservable.forEach( event => doSomething(event) )\nWith redux-saga it translates to\njavascript\n// assuming saga is connected to someSource\nfunction* saga() {\n  while(true) {\n     const event = take('click')\n     doSomething(event)\n  }\n}\n. > It's true that once you're inside the generator it seems like you've pulled the event synchronously, but haven't you in reality, behind the scenes, pushed the event to the generator by using an event listener?\nYes. That's what happens always behind the scenes. And we can push this further and say the OS is pushing events behind the scenes. If we go down further, we'll say the hardware is pushing interrupts behind the scenes.\nThe point is what matters is not what happens behind the scenes (as long as it doesn't impact performance & quality), but what's exposed to the final developer. What the developer is capable of by using our API.\n\nThus, sagas are very helpful when you want to finely manipulate individual actions, but streams would be better if you're trying to map functions to actions.\n\nNot quite the exact words but I'd say in a sens yes. Sagas are very helpful when used to implement control flow (manipulate individual actions). Streams can better describe an event source and operations that transform that source, not only map but other functions as well (filter, throttle, debounce, flatmap ...)\nSagas can be thought somewhat as complementary to Streams, as stream processors (which is the equivalent of observers)\n. > maybe also a monad? \nYes a Stream (in the reactive sens) is also a Monad, because it can emit other nested Streams. Here is another self promoted article about Streams. It's an experiment I did some time ago to build a reactive stream as a linked list of Promises.\n. Thanks for the fix :)\n. @AriaFallah \n\nI don't see a huge problem except that perhaps it looks a little unnatural.\n\nMaybe a matter of style. But I prefer this one\n``` javascript\nfunction* authorize(credentials) {\n   const token = yield call(api.authorize, credentials)\n   yield put( login.success(token) )\n}\nfunction* authAndRefreshTokenOnExpiry(name, password) {\n  let token = yield call(authorize, {name, password})\n  while(true) {\n    yield call(delay, token.expires_in)\n    token = yield call(authorize, {token})\n  }\n}\nfunction* watchAuth() {\n  while(true) {\n    const {name, password} = yield take(LOGIN.REQUEST)    \n    try {\n      yield race([\n        take(LOGOUT),\n        call(authAndRefreshTokenOnExpiry, name, password)\n      ])\n    }\n   // centarlize error handling\n   catch(error) {\n      yield put( login.error(error) )\n   }    \n  }\n}\n```\nflatmap is the equivalent of bind for Monads. Monads typically describe sequential operations In pure FP languages like Haskell, they are useful because the language has no notion of 'statement', and then no notion of 'sequence of statements', and then no notion of explicit order. The only order that exists in a pure FP languages is the order implied by the evaluation of a function and its dependencies\nIn an Imperative language like javascript (where there is a notion of statement), I can express order by simply putting statements one after another. \nBut Monads are more abstract and General. While JavaScript sequential statements can only describe synchronous operations meaningfully. Monads can express any kind of order even asynchronous operations (that's why Monads are also called programmable semi colons).\nGenerators solve the Order issue for asynchronous operations using the same imperative paradigm. Their point is : If I want to express Order, I'll simply put my statements one after another. You can do  the same thing with async/await but you'll have to solve the testability and cancellability issue. \nThat's been said, If your async control flow is as simple as merging things as they come (flatmap), or putting them in the same order as the source (concatmap) or picking only the result of the latest source (flatmapLatest). and provided you know enough about the meaning of each operation, then you probably don't need Generators (should you solve the testability issue, and perhaps the cancellability issue also [Not sure But I think RxJs already have this builtin]).\nBut for non trivial control flow like the authorization process above, I'd prefer to have a code which can map as closely as possible to the mental model.\n. @lennerd For expressing transformation on the event source. Perhaps it's better to do that from the source before the action reaches the Saga. For example to debounce the a scroll action, you can do that in the component that fires the action\n``` javascript\nclass MyComp extends React.Component {\nfunction handleScoll(e) {\n   this.props.dispatch({type: 'SCOLLED', ...})\n } \nrender() {\n     \n   }\n}\n```\nActually, redux-saga doesn't provide yet an abstraction to express transformations on event sources. Adding something like csp channels could allow expressing and also composing those transformations.\n. > Sure, I could fire two actions in the component where one action get debounced, but I find it more convenient to do this kind of complex async stuff in the saga. What do you think?\nI think you're right. A good argument in favor of doing this in a Saga is to keep the Component as 'dumb' as possible.\nJust a few remarks about your code.\n- even if updateMap sleeps for some time, watchAddressUpdate will continue to take UPDATE_ADDRESS events and continually fork new updateMap tasks. So IMO the sleep should be inside watchAddressUpdate\n``` javascript\nfunction* watchAddressUpdate() {\n  ...\n  while (true) {\n    ...\n    task = yield fork(updateMap, node);\n// sleep for 'ms' millis before taking the next action\nyield call(delay, ms)\n\n}\n}\n```\n- 'sleeping' doesn't debounce events, it throttles them. To debounce user input, you'll need to take the action only if the user stopped typing for some period (the debouncing period). While in throttling you'll take the action each 'x' millis even if the user hasn't stopped typing.\n-  I think you don't need this code. starting from 0.6.0 Cancellation exceptions do not propagate to parent\njavascript\nif (error instanceof SagaCancellationException)\n      return;\n. > Maybe I misunderstand your point,\nOops! Seems i'm the one who misunderstood. \nSo if I understand your code\n- If we put the delay inside watchAddressUpdate we are throttling the whole updateMap process by 'x' ms\n- But if we put the delay inside updateMap and precisely before the geocode call, then we're updating the state (node) immediately but debouncing the geocode update, because if we get another user input, the updateMap will be cancelled, the geocode won't take place in this task and postponed to the next forked task. And this process is repeated until the user stops typing for a period  ~~equal or~~ superior to the specified delay.\nUnless I'm mistaken (I hope not), I think this is a great example of how to achieve throttle or debounce by simply changing the place where we call the delay:\n- To throttle -> put the delay inside the 'watcher'\n- To debounce -> put the delay inside the 'worker'\n. > Both scenarios would make good examples for the receipt section of the documentation. What do you think?\nYes! definetly\n. > I think we should support a high level API to handle throttle/debounce with leading/trailing options like underscore.\nI prefer to have those functions out of the core for now. Because of #107, helper functions are implemented as state machines instead of Generators, using SM to implement more advanced features will lead to more complex code. And I prefer to have those features written using Generators instead\nI've put the throttle/debounce examples in the recipes section (the throtlle example has some issues see #166). \n. @slorber i added another example of throttling in the recipes which handles trailing actions.\nThe code could also be improved to make the behavior customizable (enable/disable leading & trailing actions)\n. If you're using v0.10.0. channels could provide something similar with less complicated code\n``` javascript\nfunction* callee(chan) {\n  while(true) {\n    const ac = yield take(chan)\n    yield something\n    // sleep for 500 ms; new messages on chan will drop old ones\n    yield call(delay, 500)\n  }\n}\nfunction* caller() {\n // channel with sliding buffer for at most 1 msg.\n  const chan = channel( buffers.sliding(1) )\nyield fork(callee, chan)\n  while(true) {\n    const action = yield take('ACTION')\n    yield put(chan, action) \n  }\n}\n```\n\nEDIT: added yield fork to caller\n. thanks!\n. One solution is to implement those functions without generators, i.e. implement the iterator manually. It could be done with the above functions but maybe more complicated if we are going to add other helpers with more complicated logic.\n\nThis concern was the reason I was thinking about puting the helpers on a separate repo.\n. Ok until someone has a better solution, I'll go with manual implementation \nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/sagaHelpers.js\nLooking at the above, One can understand how Generators simplify things\nI also added more tests (cancel watchers) in order to test the manual implementations\nhttps://github.com/yelouafi/redux-saga/blob/master/test/sagaHelpers/takeEvery.js\nhttps://github.com/yelouafi/redux-saga/blob/master/test/sagaHelpers/takeLatest.js\n. FYI released 0.8.0\nhttps://github.com/yelouafi/redux-saga/releases/tag/v0.8.0\n. Arguments are passed here. \nUsing the dynamic running API. Can't the following solve your issue ?\nconfigureStore.js\n``` javascript\nimport createSagaMiddleware from 'redux-saga'\n// export middleware\nexport const sagaMiddleware = createSagaMiddleware()\nexport default function createStore() {\n   return createStore(reducer, applyMiddleware(sagaMiddleware ))\n}\n```\nmain.js\n`` javascript\nimport createStore, {  sagaMiddleware } from./configureStore`\nimport rootSaga from '...'\nconst store = createStore()\nsagaMiddleware.run(rootSaga, store.dispatch))\n```\n. That's really curious. I made a change in my yesterday commit because the test failed. Initially i thought it was a manipulation error so I dropped the last result and the test passed. \nTurns out I was running the tests with node v0.10.40. Now That I switched to 5.0.0 I get the same results as yours. Not sure why the 2 versions give 2 different results, I'm using a magnitude of 50millis so I don't think it's related to timeout precision.\nThat's why I never trust tests with setTimeout.\n. Ok here are some results; seems Node v0.10.40 accumulates timeout diffs more than I expected\n\n. To be able to predict test results we have to drop timeouts and work only with promises that resolve in a predefined order\n. @cherta @mjrussell FYI https://gitter.im/yelouafi/redux-saga\n. @cherta in your example. If the request completes for example with a sessionExpired error, what's the meaning of dispatching dataLoaded(result.data) ? (I mean if there is an error, there is no loaded data and if there is loaded data there is no error ?).\n. What about making the error codes handling a normal function, a function which returns an action ?\n``` javascript\nfunction responseAction(response) {\n  const code = response.code\nif(code === 419) { //419: When the session has expired\n    return sessionExpired() \n  }\n  ...\n  ...\n  return dataLoaded(reponse.data)\n}\nexport function* dataRequested() {\n  let action = null\n  while(action = yield take('DATA_REQUESTED')) {\n    const result = yield call(fetchData)\n    yield put(responseAction(result))\n  }\n}\n``\n. Arigatou :)\n. thanks!\n. thanks!\n. When you expect a result from ayield` like here\njavascript\nconst { users, expenses, categories } = yield call(fetchAll);\nThen in your test you need to pass the whole response to the next call to next\njavascript\nit('should yield action RECEIVE_USERS', function () {\n    const expected = put(UsersActions.receiveUsers(users)); \n    /* here, you need to pass the expected result */\n    const result = loadAppGenerator.next({users, expenses, categories}).value;\n    expect(result).to.deep.equal(expected);\n  });\nIn the following calls to next you don't need to pass any argument to next since in the Generator you're not assigning the results of puts to any value\n. Yes. Anytime you use the 'return value' of yield (e.g via assignament val = yield something, in an expression like if(yield soemthing)), you have to pass the mocked result to the next next call\n. Thanks.\nI'll have to update the repo example to match the tutorial\n. thanks\n. thank you\n. No there are no reason, that was as an implementation mistake. The correct is what's in the API and examples.\nThanks for pointing on this. already released a patch for this (and of course added tests cases for args passing)\n. thanks\n. thanks\n. thanks\n. thanks again\n. @wizardzloy Dispatching Sagas from Components will scope the Saga by the triggering action. Sometimes Sagas need a much higher level view for control flow for example\njavascript\nfunction* saga() {\n  while(true) {\n     yield take(LOGIN)\n     ...authorize logic\n     yield take(LOGOUT)\n  }\n}\nUsing the dispatch on each action method, you'll have to write 2 Sagas for each action and then coordinate the 2 using some stored state in the Store. \nThe daemon method also decouples the Component from the Saga, your Action Creators are just pure functions which return plain Objects (and maybe you don't need them anymore). The Component just communicates  what happens.\n. I'd like to add the point of take is transform the push style of events into a pull style. This way event handling can be embedded inside a synchronous like algrorithm inside Sagas. Somewhat similar to when you use var char = readLine() in apps that read from the standard input.\n. > They are important, but I really worry about the fact that all my business logic is detached from the views that call for it.\nCan you elaborate on this ? At a first glance it seems like a good thing to have this kind of decoupling. But I'd like to hear you opinion\n\nOr maybe the daemons approach is the only one that library wants to enforce\n\nFrom API POV I'm not a fan of enforcing things. I don't like to dictate to people how they write their apps.\nMy question is, what are the pros/cons of introducing the support of dispatching Sagas ? \nWould love to hear what other people think; (cc @slorber, @aikoven, @gaearon)\nOne benefit I'm  seeing actually is that it would make transitioning from redux-thunk easier: Generators in this case will offer a more testable alternative to async functions.\nOTOH I'm wondering if this would make people miss the point of Sagas, because the dispatch approach is easier and would likely be used widely (But As I said that's an opinion and I don't like to dictate it on people)\n. @wizardzloy I think you can achieve what you want with the actual API using the dynamic running feature\nconfigureStore.js\n``` javascript\nimport createSagaMiddleware from 'redux-saga'\nimport { createStore, applyMiddleware } from 'redux'\nimport reducer from '...'\nconst sagaMiddleware = createSagaMiddleware()\nexport const runSaga = sagaMiddleware.run\nexport default configureStore() {\n  return createStore(\n    reducer,\n    applyMiddleware(/../, sagaMiddleware)\n  )\n}\n```\nactions.js\n``` javascript\nimport { runSaga } from './configureStore'\nexport function fetchSomething(url) {\n  runSaga(function*() {\n     const response = yield call(api.fetch, url)\n     yiedl put(success(response))\n  })\n}\n```\nMaybe you can even create a middleware for that\n. > But most of the time on the front end you use short lived sagas that are spawned, executed and killed within couple of seconds. \nI don't think it's that simple. The 'easy' benefit of the dispatch approach tend to hide some subtle issues from the developer.\nIf we take what seems to be the most common use case which is ajax requests. Dispatching async things (thunks, generators, promises) seems to be the easiest approach but it hides subtle concurrency issues (out of order responses, which can be handled by the daemon approach). New users will likely be unaware of those issues.\nUI applications are inherently concurrents, and even what seems to be an isolated action is likely to be a part of a much larger flow. The daemon/pull approach makes those requirements more visibles : When you start forking tasks you are more exposed to the issue of coordinating those tasks.\nThere are some benefits of the dispatch approach, but if this is going to be implemented. I prefer it to be a separate middleware. \njavascript\nconst createSagaDispatcher = sagaMiddleware => store => next => action => {\n   if(is.generator(action)) {\n     return sagaMiddleware.run(action()).done\n   }\n   return next(action)\n}\nUsage\n``` javascript\nimport { createStore, applyMiddleware } from 'redux'\nimport createSagaMiddleware from 'redux-saga'\nimport createSagaDispatcher from 'redux-saga-dispatcher'\nimport reducer from './reducer'\nimport daemonSagas from './saga'\nconst sagaMiddleware = createSagaMiddleware(...daemonSagas)\nconst sagaDispatcher  = createSagaDispatcher(sagaMiddleware)\nconst store = createStore(\n  reducer,\n  applyMiddleware( sagaDispatcher , sagaMiddleware)\n)\n```\nIf you want to make this a separate package, I don't mind linking it from the redux-saga docs.\n. I'll close this. As I don't plan to add dispatching to the core. Let me know If someone would like to contribute a separate middleware for this.\n. @Grmiade \nyield* allows only for sequential compositions; see http://yelouafi.github.io/redux-saga/docs/advanced/SequencingSagas.html\nIf you want to yield muliple tasks in parallel (note yield and not yield*)\njavascript\nexport default function* root() {\n  yield [\n     takeLatest(Actions.LOGIN, login),\n     takeLatest(Actions.LOGOUT, logout)\n  ]\n}\nIt works because takeLatest and takeEvery return Iterators, and redux-saga can also handle yielding iterators directly. But this has a minor side effect on monitoring Sagas (the Saga monitor will print anonymous on the places you call yield); \nIf you've worked before with languages like C/C++ you can view the difference between direct call (yield iterator) and delegation (yield* iterator) like the difference between calling a function and a marco in your code.\nUsing yield takeLatest is like calling a function, the middleware will run the Iterator and resumes the parent Saga when the iterator terminates (in the above case the parent Saga will resume when all the child iterators in the array terminates)\nUsing delegation (yield*) the Iterator will be spread into the parent Saga: It's like if you replaced the body of the parent Saga by the instructions of the invoked iterator. So in you code example\njavascript\nexport default function* root() {\n  yield* takeLatest(Actions.LOGIN, login);\n  yield* takeLatest(Actions.LOGOUT, logout);\n}\nThe body of root will run the first takeLatest until it terminates, then only will run the second. \n. @slorber from the order of execution POV there is no diff. But when testing root it makes a difference\nFor example, if we have\njavascript\nfunction* child() {\n  yield 1\n  yield 2\n}\nUsing yield* child() will delagate all next calls to child\n``` javascript\nexport default function root() {\n  yield child()\n  yield* child()\n}\n// testing\niter = root()\niter.next().value // => 1\niter.next().value // => 2\niter.next().value // => 1\niter.next().value // => 2\n```\nUsing yield only evaluate and returns the expression\n``` javascript\nexport default function* root() {\n  yield child()\n  yield child()\n}\n// testing\niter = root()\niter.next().value // => result of child() => an iterator\niter.next().value // => result of child() => an iterator\n```\nwhen you yield an iterator directly like in yield takeLatest(...), the middleware autoamtically resolves the yielded iterator (like it does with Promises): it runs it and waits for it to terminate and possibly return a value. But testing raw iterators could be difficult (like testing raw promises)\nWhen you use the delegation form yield* takeLatest() all the yields in the child are 'copied' into the parent Saga;\n. yes kind of a hardcore/brutal flatmap\n. thanks\n. thanks\n. Seems some typos has been already fixed by previous PRs.\n. thanks again\n. thanks\n. Thanks for all the effort! \n. It's likely because you passed the result of a generator function instead of the function itself\n``` javascript\nfunction*saga() { ... }\n// wrong\nmid = sagaMiddleware(saga())\n//correct\nmid = sagaMiddleware(saga)\n``\n. You cant pass the result oftakeEvery` to the middleware. You have to wrap it in a generator\njavascript\nexport default function* rootSaga() {\n  yield [\n     takeEvery(...),\n     takeEvery(...)\n  ]\n}\n. You can do\njavascript\nyield urls.map( url => call(parallelFetch, ...) )\n. thanks\n. thanks\n. thanks\n. thanks\n. @slorber From the 1st link I think the author gives a different meaning to actors than the one commonly known in the Actor model.\n@jokeyrhyme \nActors in the Actor model communicates by sending messages to each other while in the above link the author talks about reacting to state changes. In the mentioned article, actors are functions invoked on each state change, can dispatch actions and forms a kind of a pipeline where each actor can see the results of actions dispatched by previous actors on the chain.\nI can see 2 principal concerns from my rapid lecture\n1. ability to dispatch actions in reactions to other actions\n2. amelioration of performance rendering by not rendering on each state change\nThe 2nd concern seems more technical than conceptual and IMO can be handled by different means (like using redux-batched-actions).\nThe 1st concern joins somewhat the Saga purpose, as Sagas can also translate user events into business events that maybe handled by other Sagas. And those Sagas can in turn generate other events to be used by other Sagas.\nI don't see why the author chose to deliberately ignore actions and just examines state changes in order to infer the next action or effect. It means the developer will likely store more control state in the store in order to give re-actors enough information to decide what to do. \n. thanks\n. Thanks. this code in webpack.config\nhttps://github.com/yelouafi/redux-saga/blob/master/examples/real-world/webpack.config.js#L31-L52\npulled the dep. from the repo source. So didn't notice it in my local tests\n. The error is raised because the middleware runs rootSaga(getState) and checking that the result is an Iterator. \nThe fact that it works in Chrome debugger makes me suspect something to do with Generator/Iterator support (present in the Chrome emulator but not on the dev. device). But this is just a speculation as I never developed react native apps.\nMaybe someone with experience in react native apps could help.\n. The iterator test checks for a Symbol.iterator method on the result. But this should also raise an error kind of Symbol is not defined.\nAnyway closing this as it seems more an issue with the underlying platform. Feel free to comment, I can reopen it if necessary\n. thanks\n. see https://github.com/yelouafi/redux-saga/issues/13#issuecomment-182883680\nClosging this; I reopened #13 to track this\n. Should I still merge this\n. Ok then\n.  the middleware first hit the reducers then after dispatches to sagas. Since reducers are always synchronous the answer is yes sagas always take actions after the reducers.\nThe order of what happens after is entirely defined by how you implement your flow. In the example above the master of course takes the action first and then forked task\n. Should certainely be mentioned in the docs\n. FYI added a note on the API docs\nhttps://redux-saga.github.io/redux-saga/docs/api/index.html#selectselector-args\n. how do we actually handle universal rendering using redux-thunk and react-router ?  I tried to look at the redux universal demo project but didn't find a react-router example (which uses match). It only uses a generic handler which always fires the same api call. What I expected is an of example of a componentWillMount -> dispatch data-load tasks -> wait completion -> render process.\n@pavelkornev looked at your universal example. In waitAll you fork multiple tasks then immediately join them. You can achieve this directly with parallel calls.\njavascript\nexport default (sagas) => function* () {\n  yield sagas.map(([saga, ...params]) => call(saga, ...params))\n}\n. I found this one\nhttps://github.com/erikras/react-redux-universal-hot-example/blob/master/src/containers/App/App.js\nIt uses a kind of async Connect that collect load-time promises on the server from mounted components. It provides a loadOnServer helper which apparently waits for all collected promises before resolving.\nSince it uses redux-thunk. Async-Connected components can simply dispatch thunks and pass the returned promises to asyncConnect.\nIt seems that@pavelkornev solution is similar. Components define load-time tasks which get collected on the match method. But seems this is not quite the Saga way of doing things\nThe watcher model used actually doesnt play nice with the server processing model. \nThe while(true) loop isnt the real issue. We can break it with some server specific event. Or we can place it in a conditional isServer test.\nThe issue is that the middleware starts all sagas while in the server we need only to start the sagas that handles the matching route's actions. middleware.done will wait for all started sagas but since only current route's actions will fire from mounted components, sagas waiting for actions on unmounted components will stay blocked on their take effect. So the middleware.done will never resolve\n. @quicksnap I think the takeDefer solution a bit complicated. I prefer also to not modify the core unless it's necessary.\nThat been said. It seems the 2 solutions are centered around the same issue (@pavelkornev correct me if I'm mistaken) which is tracking the resolution of the first take effect. Either to turn it into a promise in the 1st solution or to filter out and kill sagas who haven't resolved their take effect in the current event loop.\nIf the above is correct there is an alternative option which doesn't involve changing the core and also more flexible which is saga monitoring Api. \nAll sagas fire actually events on each effect creation/resolution.\n@quicksnap We can create a server saga monitor which will track take effects fired within the current event loop and their resolution.  Since a saga monitor is a middleware it can transform the first takes into promisea\n@pavelkornev We can also create a saga monitor which directly tracks all tasks forked by watchers in the current event loop. So we dont need to filter out and cancel. In the saga monitor we can simply collect all forked tasks and wait for all of them.\n. Another angle of view is: on the server we want to run some tasks before rendering but we do not know those tasks because they are encapsulated within watchers.\n@pavelkornev solution solves this but couples the components with sagas.\nSo a possible solution is:\n- Use component statics to define only load-time actions\n- write a custom saga driver: it will iterate on all watchers and get their first take effects.\n- filters to only keep watchers whose take pattern matches the load-time actions\n- resume each watcher with its matching action\n- get the next fork effect which gives us infos about the task to run\n- run all collected tasks and wait for them\nThis has the advantage of coupling components only with actions. And we do not have to call renderToString twice. But as @pavelkornev mentioned it works only if your Router mount points matches your Connect mount points\n. Note that the driver expect the watchers to yield in a specific order; also can extend to support other action patterns (array, functions)\n``` javascript\nimport { take, fork } from 'redux-saga/effects'\nimport{ asEffect } from 'redux-saga/utils'\nfunction* commonTask() { }\nfunction* watchCommonTask() {\n  while(true) {\n    const action = yield take('COMMON_TASK')\n    yield fork(commonTask, action.data)\n  }\n}\nfunction* loadUser(action) {}\nfunction* watchLoadUser() {\n  while(true) {\n    const action = yield take('LOAD_USER')\n    yield fork(loadUser, action.user)\n  }\n}\nfunction* loadRepo(action) {}\nfunction* watchLoadRepo() {\n  while(true) {\n    const action = yield take('LOAD_REPO')\n    yield fork(loadRepo, action.repo)\n  }\n}\nfunction watcherDriver(watcher, filterActions) {\nconst gen = watcher()\nlet { value: effect } = gen.next()\n  const pattern = asEffect.take(effect)\n  if(pattern !== undefined) {\n    for (var i = 0; i < filterActions.length; i++) {\n      const action = filterActions[i]\n      if(pattern === action.type) {\n        let { value: effect } = gen.next(action)\n        const taskDef = asEffect.fork(effect)\n        if(taskDef !== undefined) {\n          return {\n            action,\n            saga: taskDef.fn,\n            args: taskDef.args\n          }\n        }\n      }\n    }\n  }\n}\nfunction getLoadTasks(watchers, filterActions) {\n  return watchers.map(watcher => watcherDriver(watcher, filterActions))\n                 .filter(taskDef => taskDef !== undefined)\n}\nconsole.log(getLoadTasks(\n  [watchLoadUser, watchLoadRepo, watchCommonTask],\n  [{type: 'LOAD_REPO', user: 'user-1'}, {type: 'COMMON_TASK', data: 'data-1'}]\n))\n``\n. @quicksnap @pavelkornev have something ?\n. @quicksnap @pavelkornev I've a proposed solution here. In https://github.com/yelouafi/redux-saga/issues/78#issuecomment-203886961 I propose that a parent is terminated only when all attached forked tasks terminate. If we combine this with a specialEND` action that I intend to introduce. We can have soemthing like this\n``` javascript\nfunction* watcher() {\n  let action\n  while((action = take('ACTION') !== END) {\n    yield fork(worker, action.payload)\n  }\n}\nfunction* rootSaga() {\n  yield [\n    fork(watcher),\n    fork(anotherWatcher)\n  ]\n}\n// on the server rendering code, inside match\nconst sagaRunner = createSagaMiddleware() // no saga is passed here\nconst store = createStore(reducer, applyMiddleware(sagaRunner))\nconst rootTask = sagaRunner.run(rootSaga)\nrenderToString(RootComponent)\n// will break the while loop on watchers\nstore.dispatch(END)\n// rootTask will resolve only when all tasks in the program are terminated\nrootTask.done.then(/ render and send state + html to the client /)\n```\nEND is a special action, it notifies all takers that no more actions will be dispatched. And since a saga won't terminate until all forked tasks terminate, we can use the done promise of the root saga  to determine when all forked tasks are completed. Similarly the root saga will abort on the first error encountered by a forked task so we can use this to send an error to the client.\nW'll be rendering twice of course on the server, but The main advantage here is that the same saga code would run on the server and client\n. see #255\n. thanks\n. thanks\n. > Also I would have expected that my code would catch the exception but it was not true in both cases\nYes; seems we need to put this in a try/catch block\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L269\n. could you create a small test case ?\n. I think the expected output should be\n['start parent', 'startChild', 'failure child', 'success parent'].\nSince the child catches the error, it won't bubble up to the parent unless the child rethrow it\n. Also I think your test fails because you do call instead of io.call\n. maybe those links can help\nhttp://stackoverflow.com/questions/34859932/can-i-use-redux-sagas-es6-generators-as-onmessage-listener-for-websockets-or-ev/34866840?noredirect=1#comment57501919_34866840\nhttp://stackoverflow.com/questions/35277682/how-to-tie-emitted-events-events-into-redux-saga\n. First, I'm glad you opened this issue\nIn the csp branch you'll find I'm already experiencing with this\nCode\nhttps://github.com/yelouafi/redux-saga/blob/csp/src/internal/channel.js\nTest\nhttps://github.com/yelouafi/redux-saga/blob/csp/test/channels/channel.js\nredux-saga is not quite csp. the take model is more close to eventEmitter (or hot observables in Rx) because it doesn't buffer events (principally for technical reasons) And the puts are not blocking (putter sagas do not wait for taker sagas to take an action)\nMy goal is not to add a feature for itself. Until now I tried to adopt a pragmatic approach, I only add features needed by the users (cancellation, select). Actually what I think the lib lacks is some way to connect to external event sources (websockets, obervables ...) I'm more willing for an event iterator concept : An iterator that connects to the event source and buffer events in order for sagas to take them. It means Sagas will not miss those events even if they were blocked while those events happened: i.e. they will be processed in order. It's like a half of csp channels (just the take side of a channel). \nCSP channels adds support for synchronous puts: A saga can 'put'  a message for another/others saga(s), and the put will block until one Saga takes that message, The model can handle inter-process communication and synchronisation using the famous rendez-vous mechanism, but I'm not sure if this use case is really needed by redux/saga users, plus it's not easy to grok by people (especially with buffered channels: dropping, sliding ...). I don't want to provide some complicated feature that no one or only few persons will use.\nI'm also exploring some similar ideas like the linda programming model. Which is similar to csp but uses fewer semantics (a global channel called the tuple space). You can find some of my experiments here\nhttps://github.com/yelouafi/linda/blob/master/examples/gen/hello.js\nI don't plan to add this model to redux-saga. Just trying to find some inspiration\n. see API proposal #254\n. Can you disable the Saga monitoring ? You can do this by running the application in production mode (set process.env.NODE_ENV to production)\n. Most of the react-native issues reported so far are related to absent Symbol support. \nsee https://github.com/yelouafi/redux-saga/issues/144#issuecomment-187452310\n. FYI released v0.9.2 patch which addresses Symbol issue in react-native apps. May fix your issue\n. Can you show me your saga code and store setup\n. I don't see any issue with your Saga code above. Since there is an EFFECT_RESOLVED for the routingSaga function, it means the function has been executed. You can verify here\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L288\nThe forked function (routingSaga) will be called before resolving the fork effect. But if the function above is called, it should print an inside RoutingSaga message which never happens (are you sure you're pointing to the right routingSaga function ?)\nOtherwise you can trace what your Sagas actually is doing by using the sagaMonitor middleware. the source is here\nhttps://github.com/yelouafi/redux-saga/blob/master/examples/sagaMonitor/index.js\nHere is an example of how to use it\nhttps://github.com/yelouafi/redux-saga/blob/master/examples/async/src/store/configureStore.js\nAfter starting the application, type $$LogSagas() in the console. Then show me a snapshot of the console output\n. It seems the fork effect is not interpreted but returned as is. I think the middleware skips to this condition \nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L223\nSo my guess is that all asEffect.xxxx(effect) fails. \nCan you say more about your dev environement: are you using babel (which version 5 or 6) with webpack ? are you using react-native ? \n. Can you try with babel 6. I've seen a similar issue with babel 5+react-native due to some incomplete Symbol support. I suspect the same issue perhaps with the electron VM and the old babel polyfill\n. I released a new version 0.9.2 which removes Symbol dependency from the lib. You may want to try, if your issue is due to buggy Symbol support as I suspect, this should fix the issue.\n. thanks\n. @joshwcomeau put effects are dispatched on the next microtask (Promise.then) but 60-90ms is too high for the Promise.then latency even with a polyfilled version.\nI think there is time lost in dispatching Saga monitor events (monitor events are only dispatched in the development mode) : Each time a Saga yield an effect, a monitoring event is dispatched and will go throw the entire store.dispatch pipeline (unless intercepted by the Saga monitor). So you may try to disable dev. mode to see the impact.\nI did some quick experiments on the counter demo (sceenshots below), the 1st in dev mode (monitoring enabled) and the 2nd with monitoring disabled. You can see the diff between the 2 effects\nWith monitoring enabled\n\nWith monitoring disabled\n\nAs for the Effect-triggred/resolved order; i think the first Effect resolved action belongs to a former effect, you can verify by logging the whole Effect action (like above) so you can see the actual effectIds in the sequence\n. javascript\nwhile(true) {\n  yield take(ACTION)\n  yield fork(worker)\n}\nwhen ACTION is dispatched there will be an EFFECT_RESOLVED for the take effect, then a pair EFFECT_TRIGGERED/RESOLVED for the fork effect. Each event will be dispatched in a microstask and will also trigger a full Store.dispatch cycle. If there is no Saga monitor to intercept events, then the actions will also be invoked on the entire reducer tree\nI think it's the accumulated effect of both monitor events dispatching and the overhead of microtasks\n. Maybe. I'll have to check that\n. the middleware support for passing multiple sagas is a just a convenience. If you need to control top Sagas (like cancelling them) you should use a single root Saga. You can't do this with the createSagaMiddleware(..topSagas) because you can't get a reference to the forked tasks.\n. Yes you're right in the above case it should be something like\njavascript\nfunction* loginFlow() {\n  while(true) {\n    const {user, password} = yield take('LOGIN_REQUEST')\n    // fork return a Task object\n    const task = yield fork(authorize, user, password)\n    yield take(['LOGOUT', 'LOGIN_ERROR'])\n    yield cancel(task)\n    yield call(Api.clearItem('token'))\n  }\n}\n\nAlso, could the sample also be written using while(takeLatest('LOGIN_REQUEST'))?\n\ntakeLatest will only take LOGIN_REQUEST and not LOGOUT events. You can yield a race between the authorize call and the LOGOUT action also. But anyway, the purpose of the example was to implement the feature using only fork and cancel\n. FYI updated the docs\nhttp://yelouafi.github.io/redux-saga/docs/advanced/NonBlockingCalls.html\n. You can't put takeEvery in a while loop. You have to use it with a yield* or yield statement\n. fixed. thanks!\n. thanks; I'll have also to fix cps, an the most subtle one which is fork\n. FYI pushed the fix. In the case of fork, I fail the forked task \nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L318-L322\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L125-L127\n. FYI https://github.com/yelouafi/redux-saga/releases/tag/v0.9.3\n. You're right the implementation was simplistic\nTo capture trailing actions. We could use something like (Not tested)\n``` javascript\nunction* watchThrotlled(actionType, worker, wait) {\n  let lastAction\n  let lastTime = Date.now()\n  let countdwon = 0 // handle leading action\nwhile(true) {\n    const winner = yield race({\n      action: take(actionType),\n      timeout: countdwon ? call(delay, countdwon) : null\n    })\n    const now = Date.now()\n    countdwon -= (now - lastTime)\n    lastTime = now\nif(winner.action) {\n  lastAction = action\n}\nif(lastAction && countdwon <= 0) {\n  yield fork(worker, lastAction)\n  lastAction = null\n  countdwon = wait\n}\n\n}\n}\n```\n. FYI added the warning and also the trailing version to the docs\nhttps://redux-saga.github.io/redux-saga/docs/recipes/index.html\n. The put effect dispatches actions asynchronously on the next microtask (using Promise.then). In your example the 2 Component actions will be handled by the reducers before the 2 Saga actions. \nThe Sagas dispatches its actions asynchronously because synchronous dispatches have some unpredictable side effects (among them nested dispatches, you can also consult some test cases here)\n. @pke I think you can implement the log utility without involving the core. put, take, ... are simple pure functions which return plain objects so you can just wrap them in whatever you want\n``` javascript\nfunction log(effect, message) {\n  console.log(message)\n  return effect\n}\nfunction* saga() {\n  // will log then return the result of take\n  yield log(take(WAIT_FOR_ACTION), \"Waiting for action\")\n}\n``\n. @slorber it's$$LogSagas()now\n. Thanks\n. Thank you\n.combineReducers` has for purpose to combine multiple reducers into different state slices. Sagas do not store state into the Redux Store so I think the analogy do not make much sens.\nFrom your example it seems the purpose of combineSagas is to take out some (not so much IMO) boilerplate of forking mulitple tasks at startup. You can just write a helper function for that\n``` javascript\nfunction startSagas(...sagas) {\n  return function* rootSaga() {\n    yield sagas.map(saga => fork(saga))\n  }\n}\n// usage\nexport default rootSaga = startSagas(saga1, saga2, ...)\n```\n. @yjcxy12 see #160\n. Here are some possible ways to handle push event sources\npass dispatch parameter to your saga\nThe simplest way, see #108\nThe downside is that dispatch must be passed around to child sagas\nUse Channels\nYou can read more at this SO question\nhttp://stackoverflow.com/questions/35277682/how-to-tie-emitted-events-events-into-redux-saga/35287785#35287785\nAlthough it seems a lot of boilerplate. The channel abstraction can be used to connect to multiple sources (Observables, websockets ...). For example\n``` javascript\nfunction createRxChannel(observable) {\n  const channel = createChannel()\n  observable.subscribe(\n    channel.put,\n    channel.put, // error\n    () => channel.put(null) // ends the channel\n  )\n  return channel\n}\nfunction* saga() {\n  while (true) {\n    const { id, source } = yield take(EXECUTE_CELL);\n    const childMessages = new IOPubSubject(id).share();\nconst channel = createRxChannel(\n  childMessages\n    .ofMessageType(['execute_input'])\n    .first()\n})\n\nlet message\nwhile (message = (yield call(channel.take))) {\n  // ...\n}\n\n}\n}\n```\nI'm also investigating on adding channel support directly into the core see #155\n. You may also want to look at this solution https://github.com/yelouafi/redux-saga/issues/108#issuecomment-191687909\n. The middleware should log all caught errors into the console (except for Cancel errors where a warning is printed only while in dev mode). In your case the middleware should print a message like this (assuming a LOGOUT_SUCCESS action id dispatched)\npersistAccount: uncaught ReferenceError: action is not defined(\u2026)\nBut I couldn't reproduce your issue: I tried a and I get the error printed on the console\n. @mxdubois \n\nDoes the basic concept make sense?\n\nYes it does. There are various concurrency patterns, and this one of them (takeEvery, takeLatest, takeFirst/takeAndQueue, takeWithConcurrencyLimit...). As an analogy you can look at the flatmap*** methods on Rx Obervables (flatmap, flatmapLatest, flatmapFirst ...)\n\nWould you want to add something like this to the collection of helpers (whether they're in core or moved out of core)?\n\nI prefer to have this out of the core for now. Saga helpers are actually implemented as state machines (see #107 for the reason). Implementing advanced concurrency solutions using state machines will add more complexity to the code. I prefer to have implementations written using Generators instead.\nUsing Generators we can implement more sophisticated concurrency patterns. A suitable place for this is in the Common Concurrency Patterns section of the docs. Later we can gather all the helper functions into a separate package (like redux-saga-concurrency) along with the tests.\n. > My impression is that each call to yield fork(...) returns a new task\n\nobject.\n\nYes, fork returns a Task Object\n\nI haven't looked at whether or not that task object has any references to the other task objects or any bearing over whether or not those tasks are cleaned up as they complete.\n\na task will be normally cleaned up as soon as : \n1. it's completed (either success or error)\n2. No external references (in the user code) are kept to it\n. I don't know much about cucumber. But in redux-saga you don't have to execute the real wait function in the tests. You can use the call effect instead of calling the function directly\n``` javascript\nfunction* saga() {\n  yield call(wait, 10, 'minutes')\n}\n// test\nconst gen = saga()\nassert.deepEqual( gen.next().value, call(wait, 10, 'minutes') )\n```\nsee https://redux-saga.github.io/redux-saga/docs/basics/DeclarativeEffects.html\n. As I said I don't know much about cuncomber so can't really help on this.\n. @pke it's mostly for convenience see #160\n@eMerzh as @pke said forked and startup Sagas are started with the same mechanism function under the hood so I don't think there is a perf. difference between the 2 methods. As mentioned in #160 the only difference is that using fork you get a reference to a Task object so you can interact with is (cancel it, inspect if it's running etc ...)\n. it depends on the use case; but if the requirements for all APIs are the same (e.g. dispatch success/error actions on each api response, handle logout errors ...)  I'd start with one parametrized saga. This way if the requirements are going to change (which is likely to happen at the beginning) I'll only have to change in one place.\nIf you have for example an api call that's called in many places then you may define a saga that just delegates the generic request saga\n``` javascript\nfunction* apiSaga(fn, args, successAction, errorAction) {\n  try {\n    const { response } = yield call(fn, ...args)\n    yield put(successAction(response)\n  } catch({ error }) {\n    yield put(errorAction(error)\n  }\n}\n// this one is used on many places\nfunction fetchUser(userId) {\n  yield apiSaga(api.fetchUser, [userId], actions.userFetchSuccess, actions.userFetchError)\n}\n```\nBut beware of premature factoring, do it if you're only confident that all your api calls (or most of them) are handled the same way.\n. > and i have to add the watchUserSaga + fetchUser for each of my endpoints?\nYes but you can also setup multiple watchers on the same place\njavascript\nfunction *watchMany() {\n  yield [\n    takeEvery(\"USER_FETCH_REQUESTED\", fetchUser),\n    takeEvery(\"ANOTHER_ACTION\", anotherSaga),\n    ...\n  ]\n}\n. @pke You'll have to use the low level API for that\n``` javascript\nfunction *takeEvery(watchAction, cancelAction, worker) {\n  const taskArray = []\n  while(true) {\n    const action = yield take([watchAction, cancelAction])\n    if(action.type === cancelAction)\n      yield tasks.map(t => cancel(t))\nelse {\n  const task = yield fork(worker, action)\n  taskArray.push(task)\n  task.done(() => remove(taskArray, task))\n}\n\n}\n}\nfunction *watchMany() {\n  yield [\n    takeEvery(\"USER_FETCH_REQUESTED\", \"LOGOUT\", fetchUser),\n    takeEvery(\"ANOTHER_ACTION\", \"LOGOUT\", anotherSaga),\n    ...\n  ]\n}\n```\n. Sure It would and the code will also be more declarative, you won't even need to create a custom helper. OTOH you'll have to create a task-watcher for each forked worker (not a big deal on most cases)\n``` javascript\nfunction* cancellableWorker(worker, cancelAction, workerAction) {\n  yield race([\n    call(worker, workerAction),\n    take(cancelAction)\n  ])\n}\nfunction watchMany() {\n  yield [\n    takeEvery(\"ACTION\", cancellableWorker, fetchUser, \"LOGOUT\")\n    ...\n  ]\n}\n. js\nyield stamples.map(stample => {\n    / return */ call(watcherGenerator,stample);\n});\n``\n. Maybe adding a warning when an undefined value is yielded. more general and can also cover the above case\n. @pke thanks, this would be useful. I'm not sure the place where to put the file: maybe aneslint-config-saga.jsfile on the root directory\n. @pke is this still relevant ?\n. I'll keep it open since it's still actionable. Thanks\n. I'm closing this b/c it's too old. Sorry I didn't check the repo (I'm not really familiar with how to write eslint rules, was planning to learn on it but couldn't find the time). If you like you can submit a PR to add a link on the [addons section](http://yelouafi.github.io/redux-saga/docs/ExternalResources.html). I think it makes more sense to keep the repo under your username.\n. Perhaps therunSaga` helper would help\nhttps://redux-saga.github.io/redux-saga/docs/api/index.html#runsagaiterator-subscribe-dispatch-getstate-monitor\nHere is an example on how to connect to an already created store\nhttps://github.com/redux-saga/redux-saga/blob/master/src/internal/runSaga.js#L16-L38\nBut the downside is that you'll only be able to take and put from outside; actions dispatched from inside (by middlewares) won't be seen by sagas. But actions dispatched from outside (components, or manually using store.dispatch) will work with take/put.\n\nOr maybe saga could (optionally) be split into two middlewares? one for take, one for put?\n\nI think this issue is inherent to how Redux's enhancer composition works. Maybe @gaearon have some advice here.\n. This was an error in the implementattion \nv 0.9.4 fixes the result signature\nThe impl. is here (the only important bit is to define the [TASK]: true property)\nhttps://github.com/yelouafi/redux-saga/blob/v0.9.4/src/internal/testUtils.js\nNote there is no id of name as they are not specified by the App. as for done and cancel they are not implemented with the mock as they do not serve on the declarative effects testing (yield cancel and yield join) But if you need them (for a more classic mock testing) you can just attach your mock implementations to the fake task object\n. I think the proposition makes sense. I've been thinking on adding a non destructive race effect. Maybe we need also the same thing for parallel effect (no automatic cancellation)\n. With v0.10.0 you can replace task.done with join(task). If timeout wins only the join (i.e. the waiting) will be cancelled not the task itself\n. thanks\n. thanks\n. If you mock your API (ajax calls) to return some fake promises then doing setTimeout(..,0) will be sufficient; timer callback will always be scheduled after all promises resolution\n. redux-saga just attaches a promise.then(onResolve, onReject) when handling promise responses. If it puts a TOKEN_REFRESH_SUCCESS it's likely because it gets a promise resolved with undefined.\nYou may to try attach a handler to `parseResponse(...)\njavascript\nfunction* callAPI(route : string, config : Object, emptyResponseExpected : boolean = false) {\n    return fetch(route, config).then(response => {\n        return parseResponse(response, emptyResponseExpected)\n                    .then(logResolve, logReject)\n    });\n}\nto check what outcome you get (resolve or reject)\n. it's not clear from your first question if you need to\n1. memoize xhr call results for queries to the same resource all the time\n2. prevent requests for the same resource to run concurrently i.e. you don't want to memoize results for all queries but just for those running concurrently at a given time\n\nIsn't this a bit against the credo of Redux? I.e. keeping and modifying state outside of the Store.\n\nThere is a distinction between 'view state' and 'control state'. The first is meant to be presented (directly or indirectly) to the application user. The second is meant to drive the program's logic of operations and not meant to be presented to the user.\nThe question of course is whether we should keep the control state inside the Redux Store or not. Well as usual there are different opinions and pros and cons\nIf you keep the control state inside the Store then you'll achieve that famous credo 'keep all state inside the Store', your entire control flow can be time-traveled (in theory, I've yet to see that in practice, because time-traveling control flow present some conceptual challenges i.e. keeping the control state in the Store doesn't give you control-flow time-traveling for free).\nBut now, you'll have to drive all your control flow from inside the reducers, this means you'll have to keep all 'program control variables' in the store to keep track where you're actually on the flow; this is not an issu with simple fire-and-forget ajax requests; but as soon as you get to more serious cases (handling concurrent requeusts, long-running flows like login-logout etc...) the reducer code will become more complicated.\nredux-loop implements a similar concept, the reducer function has a signature (state, action) => (newState, ...Effects) : you return your desired side effects (e.g. ajax call) right from the reducers thus you'll keep all your control state inside the store\nredux-saga OTOH implements the 2nd approach, implements the control flow outside of the reducers: thus if you opt for Sagas you already adhere to keeping your control state outside the store. Suppose you have this Saga\n``` javascript\nfunction* congratulateAfter3TodosCreation() {\n  yield take('CREATE_TODO')\n  yield take('CREATE_TODO')\n  yield take('CREATE_TODO')\nyield put({type: 'SHOW_CONGRATULATION'})\n}\n```\nI know we could've done it with a for but I wanted to point to something more subtle, suppose we took 2 CREATE_TODO actions and now the Saga is waiting for the 3rd one. The fact the Saga is now at the 3rd take statement can be viewed as a control state itself, and this control state is implicit (ie implied by the execution sequence that leads to that statement). My point is that using redux-saga you'll forcibly externalize your control state. In fact, that's the purpose of Sagas.\nSo does that mean you must never use the redux Store to drive the Saga operations ? Well there are pros and cons for this too (as usual). Using the store's state means the Saga will be coupled with state shape (this can be alleviated with yield select) but OTOH there are some situations where the view state itself is inveitably needed by the Saga. \nFor example, think of a real shopping cart application : the Cart state inside the Store is constructed across multiples views (checkout different products from different pages) but when checking out the cart, we'll need to submit our Cart to the server: The Saga responsible for this operation will have to access the store to get the Cart (otherwise it'll have to reuse the Cart reducers itself to keep track of a local copy of the Cart state). So this is a case where we can allow a Saga to access the Store's state (others may disagree with this) because the pros/cons balance IMO is in favor of accessing the existing state rather than duplicating the Store/reducer work. \n\nIt seems to me that the only way to achieve what I want is to maintain a hash of queries that my getFromServer method checks.\n\nYes. Where to keep this hash is related to the previous question. I would keep it inside the Saga unless we need to display it into the view\n. > I was hoping to use a simple PUT call to tell the store that the request is being fetched, but that didn't work out too well due to PUT not being synchronous.\nI don't see why this is a problem actually. Microtasks are always finer-grained than user events: it means even if you get 2 consecutive click events they will be processed in this order : first click -> put -> second click. Unless of course you have a code that dispatches 2 successive actions synchronously in the code like\njavascript\ndispatch({type: 'FETCH', query: 'resource1'})\ndispatch({type: 'FETCH', query: 'resource1'})\nIt's pretty rare but it can be the case actually if 2 Components mounted at the same time dispatches 2 requests to the same resource.\nIn this case you may want to store the query state inside the watcher itself (if you need to keep it in the Redux store you may also uses ana additional put)\n``` javascript\nfunction* watchFetch() {\n  const queryState = {}\n  while(true) {\n    const { query } = yield take('FETCH')  \n    const prevTask = queryState[query]\n    if( !prevTask || !prevTask.isRunning() ) {\n      queryState[query] = yield fork(getFromServer, query)\n    }  \n  }\n}\nfunction * getFromServer(query) {\n   // if needed for the view : yield put(queryIsExecuting(...))\n   yield doXhttpRequest(query)\n   ... handle responses etc\n}\n```\n. thanks\n. > I think the problem is on 'LOGIN.ERROR' watchAuth cancel the still running task authorize which receives a SagaCancellationException but can no more catch it\ncancel doesn't throw on an already terminated task. \nI tried to reproduce the error but I can't see the logged error (see this bin).\n. > I think the problem is on unterminated task which is already in catch and it results in a uncaught error in promise.\nOk, I understand now. In this code \njavascript\nfunction* authorize(credentials) {\n ...\n  catch(error) {\n    if (!isCancelError(error)) {\n      yield put({type: 'LOGIN_ERROR', error })\n    }\n  }\n}\nWhen the yield put(...) dispatches the LOGIN_ERROR action, watchAuth takes the action and throws a cancellation exception inside  authorize while authorize is still waiting for the put to return (because everything is done synchronously in this sequence). Since there is no surrounding try/catch this results in the promise rejection error.\nThe error wont affect watchAuth because forked tasks are isolated but the error can be confusing to the user.\nIn this case we can fix it by \njavascript\nfunction* watchAuth() {\n  while(true) {\n    var { name, password } = yield take('LOGIN_REQUEST')\n    const authTask = yield fork(authorize, {name, password})\n    const action = yield take(['LOGOUT', 'LOGIN_ERROR'])\n    if(action.type === 'LOGOUT')\n      yield cancel(authTask)\n  }\n}\n. Fixed the docs. \n. adding a delay util function could make sens. But adding a new effect here is irrelevant here since this is just an alias for a call effect. I prefer to keep the core small and focused\n. @axelson Fyi added a delay fn to redux-saga/utils in the current master branch\n. Sorry forgot to mention: its exported from the root redux-saga\n. Thanks this would be very useful also in my unit tests\n. > It could be improved even more by tracking the whole saga chain so we know how we ended up there\nyeah, I think it could be achieved by passing the call hierarchy as param to proc\n. thanks\n. I suspect this has to do with incomplete yield* support on Node 5. see https://kangax.github.io/compat-table/es6/#test-generators\n. > I'm having the same issue running the latest Electron (0.37.2), though I also get this error:\n\n(0 , _reduxSaga.takeEvery)(...)[Symbol.iterator] is not a function\n\nyeah; it seems a valid point. takeEvery implements iterators manually and yield* would be expecting a Symbol.iterator method. the method was removed since 0.9.2.\nI'm also curious electron is throwing this kind of error, since electron (besides react native) was one of the platforms having issues with Symbols prior to 0.9.2\n. > I can also confirm that downgrading to 0.9.1 fixes this issue. @yelouafi: What's do you suggest? Stick with 0.9.1 for the moment?\nYou can also just use the yield takeEvery form.  The only difference is when using the saga Monitor (you'll get an additional unkown node under the watcher) which is not a big deal IMO (and will probably be improved on the next release)\nI can't re-add the Symbol support for now, as it'll cause a lot more trouble. Probably I should add a conditional check in the saga helpers\njavascript\nfunction makeIterable() {\n  const iterable = { next: ..., throw: ... }\n  if(typeof Symbol !== undefined and Symbol.iterator) {\n    iterable[Symbol.iterator] = () => iterable\n  }\n}\n@MichalBures I was referring to this issue #157\n. Oops! forgot to mention this in release notes. Thanks for the remainder\n. @baabgai First let's understand why you're missing the action.\nFirst thing to know is that the put effect is dispatched asynchronously in a microtask (you'll see why shortly); i.e. something like this\njavascript\nfunction runPutEffect(action) {\n  Promise.resolve().then(() => dispatch(action))\n}\nwhat that means in your code is that yield put(loadUserData(...)) is not executed right away but shceduled in a microtask. so the current flow will first terminate (e.g. the code dispatching the action to the Saga) then the dispatch will be executed. \nThere are various reasons for this but in this case your example doesn't work precisely because of synchronous dispatching. Here is why\nSuppose that redux-saga executes the put effects syncronously (i.e right away)\njavascript\nfunction runPutEffect(action) {\n  dispatch(action)\n}\nWhat will happen in your example above is the following sequence\n- Some code (e.g. inside an UI component) dispatches SHOW_PROFILE\n- The Saga takes the action and yields the put(loadUserData(...)) effect\n- (We suppose) the Saga dispatches the loadUserData(...) action synchronously\n- The action goes through the Store's middleware pipeline and intercepted by your middleware\n- The middleware will dispatch({ type: pending, meta: action.meta }). and this is the issue: because we're still in the middle of the first dispatch.\nIn other terms we've this call sequence\nUIComponent:dispatch(SHOW_PROFILE)\n-----------> Saga:take(SHOW_PROFILE)\n-----------> Saga:put(loadUserData)\n--------------------->Store:dispatch(loadUserData)\n------------------------------->middleware:dispatch({ type: pending, meta: action.meta })\n------------------------------->middleware:fires the ajax request\n------------------------------->middleware:return\n--------------------->Store:return\n----------->Saga:take(USERDATA_PENDING)\nso the issue here is precisely because the sequence is synchronous, when the Saga is calling put; It'll have to wait for the dispatch call to return (Just as you wait for a val = func()). But since the middleware action is dispatched inside the first dispatch, the Saga will not take the nested action because it's still waiting for the outer dispatch call to return.\nand this is exactly what's happening in your example above: even if the Saga dispatches the action asynchronously, the whole sequence above will happen inside the same microtask (the dispatch and the nested dispatch).\nSo the solution is to dispatch the middleware action after the the saga action and not inside of it. And to do this you have also to dispatch your action asynchronously\njavascript\nconst [ pending, success, failure ] = action.types\nPromise.resolve(). then( () => dispatch({ type: pending, meta: action.meta }) )\n\nI got the impression that the use-case of synchronous actions was already resolved in v0.6+.\n\n0.6 solved the case for synchronously taking actions: i.e. the take effects will be resolved in the same task as when the action was dispatched (e.g. from a Component event handler). But the case for sync/async dispatches is more complicated (conceptually and not technically) because of the nested dispatch issue above.\nI opted for the async dispatch because it provides a more predictable behavior for most of use cases. For example a common use case is for Sagas to dispatch actions at the start of the application\n``` javascript\nfunction* startupSaga() {\n  yield put( loadStartupData() )\n}\n//...\ncreateStore(reducer, applyMiddleware( createSagaMiddleware(startupSaga, ...) ))\n```\nThe Saga dispatches an action right at the start. If we dispatch the action synchronously, it won't work because the code above will execute inside the applyMiddleware(...) call, i.e. before even the createStore returns. \nYou can also find more examples in those test cases\n\nIs this case still a limitation of the library \n\nTBH I can't answer this. I agree it has to do with the event model of Sagas (take/put). But I think it's also due to how Redux dispatching works. \nWill this issue be gone if Redux flattened itself the dispatches (for example by ordering them in microtasks) ? I don't know. But I'd like to hear what @gaearon is thinking of this\n. > If this issue can't be considered a bug, maybe your explanations would fit somewhere in the docs (troubleshooting section?) to prevent people from running into that issue.\nYes I think so\n. FYI added a mention on the troubleshooting page(The put effect is also a blocking call section)\nhttps://redux-saga.github.io/redux-saga/docs/Troubleshooting.html\n. thanks!\n. thanks!\n. it may be related to #159. The midleware fires multiple monitoring events in dev. mode which may cause perf. issue. try in production mode\n. redux-saga doesn't have any dependency on fsevents@1.0.8 this may be related to another module depending on filesystem events likely webpack or browserify\n. yes it have been fixed in https://github.com/yelouafi/redux-saga/releases/tag/v0.9.3\n\nyield* call(doThrow);\n\nYou can't delegate (yield*) to any value. Only to iteratros see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*\n. thanks. Haven't worked with rollup before, if this small addition would make it work then great :)\n. I think yes. I'll be making a release tonight\n. forgot to mention 0.9.5 is out https://github.com/yelouafi/redux-saga/releases/tag/v0.9.5\n. thank\n. join will throw if not provided with a Task object. During execution the middleware creates those objects internally . During tests you can use the createMockTask helper function to mock fork results\nA simple example\n``` javascript\nimport {  fork, join } from 'redux-saga/effects'\nimport { createMockTask } from 'redux-saga/utils'\nfunction* someGen() { ... }\nfunction* gen() {\n  const task = yield fork(someGen)\n  yield join(task)\n}\ndescribe('gen', () => {\n  it('runs correctly', () => {\n    let next = gen.next()\n    expect(next.value).toEqual(fork(someGen))\nlet fakeTask = createMockTask ()\nnext = gen.next(fakeTask)  // pass the fake task to the generator\nexpect(next.value).toEqual(join(fakeTask))\n\n})\n})\n```\n. For now parallel takes are not allowed. You may try this instead\n``` javascript\nfunction* resolve(action, acSuccess, acError) {\n  yield put(action)\n  return (yield take([acSuccess, acError])\n}\nconst actionResults = yield [\n  call(resolve, action1(), 'action1_SUCCESS', 'action1_ERROR'),\n  call(resolve, action2(), 'action2_SUCCESS', 'action2_ERROR')\n]\n```\n. FYI the actual code on the master branch can handle parallel takes. Probably to be released this week-end\n. It took more time but the last v0.10.0 handles parallel takes\n. thanks again!\n. thanks!\n. Yes, it should :) thanks!\n. ### 1- Sequential execution\n``` javascript\nyield taskOne();\nyield taskTwo();\nyield taskThree();\n// or using the declarative form\nyield call(taskOne);\nyield call(taskTwo);\nyield call(taskThree);\n```\nWill run the 3 sagas sequentially: first run taskOne and wait until it terminates then only resume and run taskTwo and also wait for its completion, and same with taskThree. yield taskOne() and yield call(taskOne) behaves the same way, in both cases the saga will block until the called task terminates; but the call form is easier to test (see Declarative Effects)\n2- Parallel execution (blocking)\n``` javascript\nresults = yield [\n    taskOne(),\n    taskTwo(),\n    taskThree(),\n];\n// or\nresults = yield [\n    call(taskOne),\n    call(taskTwo),\n    call(taskThree),\n];\n```\nWill run all tasks in parallel and wait for all of them to complete before resuming; After all tasks complete (successfully) results will contain the return values of all called tasks\n3- Parallel execution (Non blocking)\n``` javascript\nresults = yield [\n    fork(taskOne),\n    fork(taskTwo),\n    fork(taskThree),\n];\n// same as\nconst results = []\nresults.push( yield fork(taskOne) )\nresults.push( yield fork(taskTwo) )\nresults.push( yield fork(taskThree) )\n```\nWill run all tasks in parallel But do not wait for them to complete. Instead the Saga will resume immediately. results will contain now an array of Task objects. You can then use join or cancel on those tasks\n. > However the function always throws an error, and I think it is because redux-saga is expecting an es6 promise. Is there any way to use jQuery compatible promises with call?\ncall should work with any object having a then method. In your code you should however pass just the Promise-like object not the then method itself\njavascript\nobject = yield call(query.first())\n. You can pass this by using  apply\njavascript\nyield apply(query, query.first)\nIf you want to yield a promise directly you must do\njavascript\nyield query.first()\nBut the 2nd form is harder to test\n. > UPD: It seems we always should have try-catch in the watchers\nCan you explain ? The cancellation errors are not propagated to parent sagas;  so even if you don't wrap a saga in a try/catch the cancellation of the sub-saga wont propagate to the parent saga\nI think the error is thrown because the middleware fails the done promise of doSomeStuff And the browser runtime detects the failed/unhandled promise\n. Thanks for all  :)\n. You can also simply create a saga to encapsulate the full logic\n``` javascript\nfunction* wrapSaga(saga, ...args) {\n   yield put(setLoading(true))\n   try {  \n    return yield call(saga, ...args)\n   } finally {\n      yield put(setLoading(false))\n   }\n}\n// used with fork\nyield fork(wrapSaga, myAsyncTask, somearg)\n```\n. I suspect this has to do with Redux middleware/enhance issue. When there are multiple store enhancers, each enhancer gets its own dispatch pipeline, so an enhancer may not see actions from another enhancer (see for example #48 and https://github.com/yelouafi/redux-saga/issues/13#issuecomment-169179962)\n. @ctrlplusb \n\nIn terms of issues with synchronous execution of startup sagas my technique is to fire an action (e.g. \"APP_INIT\") directly after my redux store has been configured\n\nYes that would work. The question is of course is should we keep the actual startup API and document the above workaround in the troubleshooting section?\nAlso the actual API can't return tasks for middleware-started sagas\n@slorber \n\nI guess the idea is that the sagas should be able to become \"stable\" before receiving any new dispatch from outside the sagas right? \n\nYes in some sense. Actually I considered the global lock for all the effects, but afterthought it wasn't necessary; the only way a saga can affect another saga is by dispatching actions that the other saga will take. So i think that serializing put effects should be sufficient.\n\nHowever a nice default setting is cool, but I think it would be nice to give options in the put effect so that developers can decide themselves if they need sync/async/default for their puts\n\nYes I think it's a good idea.\n. see 0.10.0\n. @vojtatranta the while loop is just used to orchestrate the generator flow (the return statements inside the switch break the while loop). It doesn't mean the generator will run forever and consume your entire CPU time. otherwise everybody would have noticed , don't you think? :)\n. thanks\n. > Am I missing something here?\nNo, It's me who missed here :)\n. thanks\n. Actually they are already exported from redux-saga/utils (see this example).\nAlse note the actions are only fired on dev. mode not in production.\n. You can also use the sagaMonitor from the examples; it'll intercept the actions for you, plus you can have some nice logs about the saga activity. see the repo examples for usage\n. Those are monitoring actions. They are only fired in development mode. You wont see them if you start your app in production mode\n. Thanks! I'll add a link to this in the docs\n. Sorry for being (too much) late. I added a link ti the README\nhttps://github.com/yelouafi/redux-saga#documentation\n. @aksonov Without seeing a gist or a simplified example, we can't really say why it doesn't work\n. > I can't seem to figure out why the redux/saga app is not waiting until post-success to re-render itself\nIt's hard to answer without providing more details. The time the app will re-render itself depends on how you wire the store to your component and isn't related to Sagas. If you're using react-redux then a component will re-render every time the connected state slice changes\n. Can you give a little example? In my local tests I can see the same error thrown inside the Saga logged into the console. \n. The issue seems from here. String interpolation doesn't work for symbols\n. fixed by https://github.com/yelouafi/redux-saga/commit/c9c63d95a95846162a3f51739d2b9dee41bd695a\n. @bvalosek What error do you get?\n. thanks!\n. @ronanwize I don't have an exact answer to this. a Saga 'running in the background' is just an object instance with a few method and its local/closure state. IMO what affects the performance is not how many Sagas do you have in an application but how many Sagas fires concurrently in response to a single action.\nAnd If you have a large number of Sagas you could  try to refactor the common code into common sagas (for example request/response with the same logic)\n. @evgenyt1 did you find some warkaround?\n. @evgenyt1 Thanks for you feedback. I think this kind of interaction is better handled by a more conventional listener approach. At least I can't think of a simple method using Sagas\n. @axelson For forked sagas you can use the done property to catch errors\n``` javascript\nfunction* wrap(saga, ...args) {\n  const task = yield fork(saga, ...args)\n  task.done.catch(reportTheError) // handle the error\n  return task\n} \n// wrap the fork effect\nconst wrapFork = (saga, ...args) => call(wrap, saga, ...args)\n// then use it instead of fork\nfunction* mySaga() {\n  while(true) {\n    const action = take(ACTION)\n    yield wrapFork(doSomething, action)\n  }\n}\n```\nyou can do the same thing with called sagas by putting the call in a try/catch then rethrow the error.\n. thanks\n. @npbee Thanks for pointing to this. it was an inattention from my part\n. Actually redux-saga logs all rejections inside a Saga. In the code you're forking a call to fetchApi (which is automatically wrapped in a generator), so when fetchApi fails with a rejection, the middleware automatically logs the error.\nMaybe we should change this because sometimes the developers want to bubble up the error intentionally. So we can keep the error logging only for forked tasks (because there is actually no way to catch errors from forks). So this will would work only for called and joined tasks (although it's be hard to determine this in the above example since you're not joining the original task but only a copy of its done promise)\n. > Since the loser in the race would be cancelled automatically so that code I copied from #183 is kinda a workaround to get the loser's eventual result (I might misunderstand something here).\nI understand. since I plan to add a non destructive race version, I think this wont be an issue.\nSo IMO the solution would be to log only uncaught exceptions from top level tasks which in our case corresponds to forked (and non joined later) tasks\n. > In my case I just wanna throw the errors out, letting it bubble up, then I can handle the errors in their own scope.\nJust to be precise. This affects only the logging behavior (which may be confusing of course). The errors are still bubbled up\n. I agree on this. Already posted a fix on the master branch. The errors are now logged only for forked tasks, and if a task was joined then errors will no longer be logged until they propagate to a top level task.\nI'll also add the non destructive race effect for the next release\n. v0.10.0 has a new fork model. Errors now bubble up the fork/call chain and are logged only at the top level task. Since the new version no longer depends in promises to handle task ending I suggest you use join(task) whenever you want to wait for a task. In a race only the join will be cancelled\n. The error will actually bubble to parent. But there is no  way for the parent to catch errors from forked tasks: the parent has its own flow in its body. And the parent may have already terminated its body. The only way I think you can handle errors on a forked task is by catching it in the fork itself\nOf course nothing of the above is set in stone:)\nAre there use cases which implies catching errors from forks?\n. Oops! Sorry THERE is actually one way to catch errors from forks: say p1 call(p2) then p2 fork(child)  if child aborts you can't catch the error from p2 (b/c it's parallel to the main p2 body). But you can catch it from p1\n. I think you can get the same effect and a simpler code with try/finally\njavascript\nexport function * callWithLoadingEffect (fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('callWithLoadingEffect only accept function as its argument')\n  }\n  try {\n    const task = yield fork(fn)\n    let {timeout, result} = yield race({\n      timeout: call(delay, 20),\n      result: join(task)\n    })\n    if (timeout) {\n      yield put(loadingShow())\n      result = yield join(task)\n    }\n    return result\n  } finally {\n    yield put(loadingHide())\n  }\n}\nIMO, you shouldn't use any try/catch with a join effect. The main purpose of a join is to wait for a task to terminate. The task should handle all its errors and let only bubble unexpected ones (see below)\nI'd rather separate errors in 2 classes\n- Business errors are expected errors and should be handled inside the forked task itself.\n- Bugs are unexpected errors and will simply bubble up the fork chain up to the root. All sagas in the current execution tree will be cancelled and the error will bubble up. I can't see how a program can recover from a bug. The only options I think of is to show some message to the user that the app has encountered an unexpected error, send some report then close the app to avoid any inconsistent state.\nAt least the best way to work with the redux-saga fork model is to handle business errors from inside the forked tasks themselves an let bubble only bugs which can be caught at some higher level. \nIn fact I can even go farther and recommend to not use try/catch for business error handling because javascript IMO lacks the necessary constructs for typed catch blocks. consider this code\njavascript\nfunction* myCallabletask() {\n  try {\n    yield call(Api.gett) // note typo\n    yield put(RequestSuccess)\n  } catch(err) {\n    yield put(RequestError) // will put on any kind of error including Runtime errors/bugs\n  }\n}\nbecause the catch block catches all errors: both business Errors (server error, timeout ...) and bugs (Api.gett is not function). The code reacts the same on both types; I don't think this the desired behavior. Typically we want to put an Error action only on server errors and let bubble any bug. In typed languages like Java you can achieve this with typed catch blocks  likecatch (ServerError err) But JS lacks this feature.\nThe best way to think of the fork model is as dynamic parallel effect. A saga has a main flow (its own body => the main task) and can fork parallel flows dynamically. Like in parallel effects, cancelling the saga will cancel all the parallel tasks (main task + forked tasks). The saga will terminate after all parallel tasks terminate, and an error from one of the tasks will abort the whole parallel effects. \nIt may sound restrictive but this has the advantage of having a much simpler model to reason about. You know precisely how do Return values, Errors and Cancellations propagate, ... The other option is the very flexible Promise model but also its well known issues (esp. Error propagation => unhandled rejections, error swallowed, not to mention the difficulty to define a simple and consistent model for Cancellations)\n. @timeu\n\nAs far as I understand the proposal, it tries to generalize the solution of the stackoverflow answer ?\n\nIt's more about formalizing the concept. Generalization applies to take since now take(action) can be simply seen as taking from a (very special) channel: the redux store channel.\n\nFor Websockets I think some kind of buffering would be really handy. Would it be possible to implement a buffered channel manually/by the user with your eventChannel proposal ?\n\nIs it necessary to have buffering? If you have a saga which take events then forks tasks in a non-blocking way, then you won't miss any event. \nAre there any use cases which can't be solved with the take-and-fork pattern?\n. @timeu good remark. \nThe order is not the same in the 2 approach. In the queued channel version actions are dispatched in sequence while in the 2nd actions from forked tasks are interleaved.\nI guess it makes sense to add the  queueing variant (including for store action)\n. @quicksnap The second render won't trigger any async actions; because i'll occur after dispatching END which causes the Sagas to terminate. So the cost will be only of building the Component tree + markup generation\n. I also think that END is more a computational context than a value that should be dealt with manually. But I'm thinking of potential use cases where we may need to catch the END in order to do something like starting a task.\nFor example, let's say I'm taking from a given channel and I'd like to start a task when that channel is closed (e.g. the underlying event source has terminated)\njavascript\nfunction* saga() {\n  const chan = yield call(eventChannel, eventSource)\n  let event = yield take(chan)\n  while(event !== END) {\n    // do some stuff\n    event = yield take(chan)\n  }\n  // eventSource ended, start another event source\n  const chan2 =  yield call(eventChannel, eventSource2)\n  // loop over chan2...\n}\nAs an FP analogy, it's like instead of having a return type of ACTION (with automatic handling) we have now a type of Maybe(ACTION) so we need to handle both the case when there is a Just(ACTION) (we have an action) and the case of NOTHING (channel was closed). i.e. we need some way to map over END\n. @axelson \n\nIf END is usually not expected, would it make more sense for take() to raise an exception if END is received?\n\nThat would be a practical solution. OTOH this also means more  surcharging for the catch block, as we already have to perform an isCancel now to discern normal errors from cancellations, we'll also have to perform an isEnd. \n\nOtherwise wouldn't we have to specifically check for END every time we do a take()?\n\nYes. that's on drawback of manual END handling, since we now have a return type of Action | END\n. @axelson I think the issue you raised makes plain sense. END will be likely used in the server to end the sagas most if the time. So enforcing a check on every take is indeed awkward.\nIt's just it seems weird to use the exception system to raise an exception that wont propagate if not handled. \nI m thinking of this\n- takeing an END would invoke return (if available) on the generator which will cause the saga to terminate (possibly after executing an eventual finally block). This would be the default behavior\n- provide  an additional take.maybe or takem which will explicitly return the END action. This would be handy when taking from observables.\n. FYI 0.10.0 is out  ended up with the double method of above: cf. release notes \n. You can pass the mock result to the next call of generator.next\n``` javascript\nfunction* saga() {\n  const state = yield select(mySelector)\n  if(!state.dataLoaded)\n    yield call(fetchData)\n}\nconst gen = saga()\nassert.deepEqual(gen.next().value, select(mySelector))\nassert.deepEqual(gen.next({dataLoaded: false}).value, call(fetchData))\n``\n. thanks\n. thanks\n. I'm not sure if@@INIT` is a public API in Redux (cc @gaearon). for example inside reducers you rely only on the state param to be undefined. \nIs it necessary to wait for the specific @@INIT. You can for example start the saga after the store creation\n``` javascript\nimport createSagaMiddleware from 'redux-saga'\n// other imports\nconst sagaMiddleware =  createSagaMiddleware()\nconst store = createStore(reducer, applyMiddleware(sagaMiddleware ))\nsagaMiddleware.run(mySaga)\n``\n. Also see #5\n. @pke the catch-alltry/catch` blocks traps all errors including Cancellation errors\nTry adding a test in the catch blocks\njavascript\ncatch(e) {\n  if(isCancel(e)) return\n  console.log(e)\n}\n. @pke Ok I missed your first example. Inside race, you shouldn't yield effects just specify them\njavascript\nyield race({\n      watchers: /*yield*/ [\n        call(refreshUser, access_token),\n        call(refreshActivities, access_token),\n        call(refreshPendingTransactions, access_token)\n      ],\n      logout: /*yield*/ take(actions.LOGOUT_SUCCESS)\n    })\n. @pke You're getting the exception because the saga catch errors only around the call effect. But if the cancellation happens while the saga is blocked in take then the thrown Error is uncaught.\nAnyway the 0.10.0 version no longer throw on Cancellation so you shouldn't get this warnings; Also cancellations are now logged used console.info on dev mode\n. @pke as for the eslint rule, TBH I havent created ESlint rules before. I'll try this and report back. Thanks for this\n. BTW the last comment IMO should be posted on #179\n. closing this. ESlint rules is tracked in #179\n. Sorry I did some changes on the package.json file before I saw this. could you make another PR?\nAlso I think script commandes for examples need to be prefixed with cross-env BABEL_ENV=commonjs\n. Ok, thanks\n. @dsblv Is this still relevant?\n. The master branch contains many more changes. Since the fork model was totally reimplemented, it'll be possible to propagate errors from forked tasks just as we do with normal functions. So no error should be swallowed, uncaught errors will propagate up to the top parent. I've also improved a bit error reporting to log the entire saga stack.\n\nIt's almost finished, I'll try to release this ASAP\n. See v0.10.0\n. Thanks @russellholmes. I replayed to your mail. Just for the sake of visibility I'll reproduce my answer here\n\nI'm actually making some notable changes on the source code (channels, SSR, new fork model...). To be released soon.\nSome ideas are: upgrading/improving existing examples, making more examples, contributing to the docs (e.g. recipes section/tutorials).\nyou can take a look to the tests folder in the master branch. It contains specs for the upcoming version. The project would benefit from making more tests for more edge cases.\n. @aikoven Generators have a return() method which can do that; this is already implemented in the zero branch.\n. As a side note, using this approach I'm able to handle task Cancellations and Channel ending (see #255) using the same abstraction.\n. see 0.10.0\n. @elliottsj \nTo simulate cancellation call gen.return(). If the saga asks for the cancel status with a yield cancelled() resume it with true\n\n``` javascript\n//assuming this saga \nfunction* saga() {\n  try {\n    const resp = yield call(someApi)\n    yield put(action(resp))\n  } finally {\n    if(yield cancelled()) {\n       // handle logic specific to cancellation. For example\n       yield \n    }\n  }\n}\n// test\nconst gen = saga()\nexpect(gen.next().value).toEqual(call(someApi))\n// simulates cancellation\n// gen asking for cancel status\nexpect(gen.return().value).toEqual( cancelled() ) \n// answer yes, we've been cancelled\nexpect(gen.next(true).value).toEqual()\n``\n. @3LOK can't your saga just wait for the *_LOGIN_SUCCESS actions. Since sagas execute after reducers your saga should see the calculated token\n. You can usetake` with a function predicate instead of a constant\n`` javascript\nfunction isLoginAction(action) {\n  return action.type.endsWith('LOGIN_SUCCESS')\n  /**\n   or to avoid relying on strings, you can set anisLoginSuccess` \n   field on the action then return\n   return action.isLoginSuccess\n  **/\n}\nfunction* saga() {\n  yield take(isLoginAction)\n}\n```\n. Another way is to hold a reference to the task doing the login; and share it with the other Sagas needing to wait for a login for ex. by making it a param\njavascript\nfunction* saga(loginTask) {\n  /*\n      if loginTask has already completed this will resolve immediately\n      otherwise it'll wait for the loginTask to start or complete (if it's already in progress)\n  */\n  yield join(loginTask)\n  let accessToken = yield select(state => state.login.access);\n}\n. Hmm... This remind me of Wait conditions in Java: Wait until a condition on the store is met (regardless of the different possible action pathes causing the state change) \n. A more Saga-conventional approach is to create a Saga acting as a decoupling point: it will listen to all *_LOGIN_SUCCESS actions and dispatch a TOKEN_DISPONIBLE action\n. thanks!\n. yeap I missed that, thanks!\n. @secobarbital  I'm merging this as is and will do the change locally (sorry but I'm working on a patch today. Thanks for the contribution!)\n. thanks again!\n. @pke i wouldn't recommend importing the middleware in the same sagas module. It's better to export a root Saga (cf @slorber answer above) from the module then run it from elsewhere (eg. main file as in the examples).\n\nI managed to re-arrange my applyMiddleware call and add a call to sagaMiddleware.run after the store creation, but what should the root saga function return?\n\nsagaMiddleware.run returns a Task object. see API docs https://redux-saga.github.io/redux-saga/docs/api/index.html#middlewarerunsaga-args\n. Example of config\n./saga.js\njavascript\n// Using `fork`?\nfunction* rootSaga () {\n    yield [\n        fork(saga1), // saga1 can also yield [ fork(actionOne), fork(actionTwo) ]\n        fork(saga2),\n    ];\n}\n./main.js\n``` javascript\nimport { createStore, applyMiddleware } from 'redux'\nimport createSagaMiddleware from 'redux-saga'\nimport rootReducer from './reducers'\nimport rootSaga from './sagas'\nconst sagaMiddleware = createSagaMiddleware()\nconst store = createStore(\n  reducer,\n  applyMiddleware(sagaMiddleware)\n)\nsagaMiddleware.run(rootSaga)\n``\n.runis normal javascipt method that can be used to create and start a task from outside the Sagas. And should be typically used in the same place where you create the store.forkis an _Effect_ that can be only used withyield` from inside Sagas. \nYou shouldn't use run from inside Sagas just yield fork. And you can't use fork outside of Sagas.\n. the noticeable change between 0.9.5 and 0.10.0 is that put effects are no longer scheduled in a Promise.then but are executed right away. Since it works with a delayit could be caused by the order takeEvery and put are issued. \nYou may try to put some console.log  inside the sagas (the one that put and the other that takes) to check whether the take is issued before or after the put\n. That's a curious case: takeEvery is forking a task, and the task is dispatching an action back to its forker. I'll be curious to know what's the use case here.\nAs for the issue:\n- takeEvery internally calls fork(takeTest) and wait for the fork to return\n- Since takeTest contains only non blocking calls it'll run fully synchronously inside the stack frame of fork(takeTest) including the put. \n- It means the put is executed while takeEvery is still waiting for fork(takeTest) to return. takeEvery hasn't yet resumed to execute its take.\nA possible solution is to enqueue the execution of forks like in #235 but i'll have to make sure this doesn't break the other tests. Until that you can get the same behavior of 0.9.5 by delaying the put, but instead of delay(0) I'd recommend a simple Promise.resolve() which is more performent.\n. @MichalBures Thanks for sharing this. I think there is an error on the Fix of 0.10.1. I'll check\n@joonhyublee \nI dont think what we've here is a 'basic case'. Let me explain. \nAfter switching redux-saga to a promise-less version, execution of non-blocking effects (Effects which execute and resume the Saga synchronously in the same stack frame just like a synchronous function call) no longer caused the Saga to sleep. Instead Saga resume asap as the function call returns and thus cause it not to miss events dispatched sync. For example if you do\njavascript\ndispatch(action) // Saga take this and execute it, then returns\ndispatch(action) // after return 2nd dispatch executed then Saga take it again\nAs you see, a Saga doing only non-blocking calls will execute its effect fully inside the stack frame of the 1st dispatch, when the 1st dispatch returns, the Saga is already ready to take the 2nd. So as long as your flow of actions is unidirectional Saga can't miss an event (not talking of 0.10.1 b/c as I said there is an issue with the fix to fork)\nThere is one 'edge case', Suppose you have this fork/call chain\nparent take(action) -> parent fork(child) -> ... -> child(n) put(action)\nSo here we have a cycle on the action flow. Even with that the parent Saga should have no problem with taking the action from one of its child. Except on an 'edge case' (of the former 'edge case'):\nIf all the call/fork chain is executing only non-bloking Effects, then the whole fork/call chain will execute as a single function call in the same stack frame. We'll have something like this\nparent............................child.............\ntake(action)............................................\n.............................................................. action is dispatched from outside\nfork(child).............................................. fork Effect executed: begin of fn call\n..............................put(action)............... child dispatch: fork han't yet returned\n.............................................................. put returns\n.............................................................. fork returns\ntake(action)........................................... Saga resumes\nSo the parent execute a normal function call and waiting for it to return. Except in the case of bounded recursion, I dont think (sync) cycles are basic cases on any kind of context I'm aware of.\nThe only way to fix the above is by making the nested put async. In other words by scheduling the nested put for execution later. And by later I mean until the function call to fork(child) terminate and the parent executes its next take effect (assuming the parent doing only non-blocking) (And from this POV, I don't consider Promise.resolve solution a hacky solution)\nPrior to 0.10.0. the scheduling was done using Promise.then. which delayed all the puts to the next microtasks. But there was an issue with this solution: Promise.then was delaying the execution 'too much' (to the next microtask). It means the Saga doing put (here child) can miss any consecutive action dispatched on the current task. \nThis is why I implemented the solution in #235. My impl. delayed the nested puts only the time other Sagas are ready to take it. But the impl. of 0.10.0 handled only the cases of puts within puts not puts within forks. 0.10.1 attempts to fix this (but as I said the impl. of fix of 0.10.1 is incorrect, I'll have 'to  fix the fix')\nFundamentally the re-entrant lock solution in #235 is somewhat similar to the actionChannel. But instead of queuing the actions we're queuing the functions dispatching those actions. \n. @MichalBures The new release 0.10.2 'fixes the fix' of 0.10.1. I added your example to the test suite (see https://github.com/yelouafi/redux-saga/blob/master/test/proc/takeSync.js#L470-527).\nCould you try with the new release and see if it works?\n. cool!\n. can you post a test case for this?\nFYI heres is the test case for the previous fix:\nhttps://github.com/yelouafi/redux-saga/blob/master/test/proc/takeSync.js#L470-L527\n. @axelson Sorry for the delay. Haven't been able to look at this. Could you open a new issue with your last comment?\n. thanks\n. If you're using ES6 on the server you may try to import the polyfill on the server as well. also running on the server requires node --require babel-register server.js in package.json https://github.com/yelouafi/redux-saga/blob/master/examples/real-world/package.json#L6\n. I'm not sure if this needs to be added to the core. you can create a little helper saga for this\n. ``` javascript\nfunction* callObs(obs) {\n   return ( yield obs.take(1).toPromise() )\n}\nfunction* saga() {\n   ...\n   const wells = yield call(businessesService.getAllWells());\n}\n```\n. @davesnx Here is the correct code\n``` javascript\nconst sagaMiddleware = createSagaMiddleware()\nconst storeFactory = compose(\n  applyMiddleware(\n    sagaMiddleware / (sagas) remove this /\n  )\n)(createStore)\nconst store = storeFactory(reducers)\n// sagaMiddleware.run must be called AFTER the store creation\nsagaMiddleware.run(sagas)\n```\n. it's already there\nhttps://github.com/yelouafi/redux-saga/releases/tag/v0.10.0\nhttps://github.com/yelouafi/redux-saga#mainjs\n. it's a side effect of the usage of node style callbacks internally\njavascript\ncb(err, res) {\n  if(err) // it's an error\n  else // it's a success\n}\nsince the error is undefined it's interpreted as a success call by the callback\n. @luisherranz Issue was fixed in 0.10.1\n. thanks!\n. @danpantry the correct form is yield. The saga can't take the dispatched action because it's still blocked on the call(wait, 1000) when you dispatch the action. So when it resumes from the delay it remains blocked on the take.\nHere is the correct code\njavascript\nfunction* fetchCompanySaga() {\n  const action = yield take('FETCH_COMPANY')\n  // put the delay after the take\n  yield call(wait, 1000)\n  yield put({\n    type: 'FETCH_COMPANY_SUCCESS',\n    payload: {\n      id: action.id,\n      name: 'Foo'\n    }\n  })\n}\n. as for yield* it's used to delegate to other Iterables object (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*). AFAIK, It shouldn't work with non iterables (like the result of call above). It seems the regenerator runtime (used by babel to transpile Generator code) resumes the Generator when you yield* to a non iterable instead of throwing an error \n. what version are you using? the v0.10.0 has some improvements on error reporting\nhttps://cloud.githubusercontent.com/assets/5453835/14753131/30f3dd10-08cb-11e6-869e-6519cd463ff7.png\nAs for getting the exact location of the error (i.e. console.log) this is not possible to inside a library and requires external tooling like a babel plugin\n. clicking on the arrow of the first trace will give you the raw JS trace \n. From the trace it appears the error is raised in the open saga; while it's trying to execute some Effect. Can't really see the link with React component, unless you're trying to render from within the Saga.\n. Ah didn't say your last message; I'll check\n. In the fiddle, the error is thrown while the Saga is executing a put Effect. Seems the dispatching is causing react-redux's Connect to re-render the React Component. the Error is thrown from the Saga (because it was thrown in the same stack frame of yield put), However Can't understand why all React specific calls where removed from the stack trace\n. I think the issue comes from the log('error', ...) call. In the browser the call translates to console.error which prints the error stack at the moment of the console.error call rather than the stack at the moment when the error happened. \nIn redux-saga there is a difference between the 2 moments: When an error happens the middleware bubbles the error up the call/fork chain so it can be caught by parent sagas. The propagation stops at the top level parent (root saga or a spawned saga) and at this moment the error is printed on the console.\n. > which is fine for me. Is that a good fix for this?\nI think so\n. @yarcub \nIf what you need is crash reporting, you can attach an error handler to the root saga\nsagaMiddleware.run(rootSaga).catch(...)\n. @yarcub should be\njs\nsagaMiddleware.run(...).done.catch(...)\nb/c run returns a Task object not a promise\n. I think it's var createSagaMiddleware = require(\"redux-saga\").default\n. Thanks so much for this!\nI'll update the gitbook site asap\n. This is indeed related to the way #277 was fixed. Prior  to 0.10.1 forks run its body before the parent resume causing #277. In 0.10.1 the fork is enqueued until the parent resumes first. In your example the parent resumes and takes the next action before even the fork starts. I guess because actions are dispatched synchronously. So it's because is 'too fast' and not 'not fast enough' (unless I'm mistaken)\nSo we have to choose which way to go. Because it seems we can't handle #277 and this at the same time.\nCould you tell more about the use case here: why  do you need to debounce actions fired synchronously? Typically debouncing is applied to UI events which always are handled in different event loops?\n. Sorry. Just forget about the previous comment\n. @joonhyublee can you try with the new 0.10.2? I don't have enough info about your issue but as I said in #277 there was an issue with the impl of the fix in 0.10.1\n. thanks!\n. Sorry I dont know much about redial but the saga code seems corect. Although it can be simplified to\njavascript\nsagaMiddleware.run(fetch).done.then(\n  () => console.log(...),\n  ...\n)\n. the error is raised because rootSaga is not (apparently) a Generator function. \n. Are you logging the actions from reducers or some middleware like redux-loggger?\n. if it doesn't reach the devtools it's likely because it isn't dispatched at all. Unless some middleware intercept it.\n. sorry for the delay. Can you post a runnable Gist or a test case? it's hard to tell from the snippet above\n. I don't see a particular issue with it. It depends on the work to be done after taking the action. It could be even good to have multiple watcher for the same actions if they need to perform different tasks\n. Makes sense. I was wondering if uglify does this by default\n. @gaearon Thanks for the clarification. I'll add this in the next patch\n@slorber\nAgree but I think in cases like the one in the tweet above it's not necessary. Because the errors are related to the app startup itself. It's very unlikely that the app will be shipped in production with that type of errors. \n. thanks\n. You're right. It's missed\n. I noticed a put with 2 args put(setSessionOptions(responses[1].body), false). The signature of put is either put(action) or put(channel, msg). When you call it with 2 args it expects the 1st to be a channel\n. Actually the puts are executed simply calling dispatch. The action gets back to the saga middleware via the normal middleware pipeline which  then emits the action to all sagas\nSo if I understand you want the putted action to be ignored by the saga middleware and not emitted to sagas? \n. Yeah that would be possible by setting some special property (e.g. SKIP_SAGAS) on the action which the middleware can check. But not sure if the Api should be to expose a new Effect or simply expose the special property. Mainly because the first solution require mutating the dispatched action by the middleware\n. As @ojkelly said you don't need both fetchComponentData and the two-phase render on the server.\n1. If you know precisely your data dependencies for components on the server, then you don't need to run the sagas on the server. Just fire your loading routine and when you get the data update the Store's state and send the whole (rendered markup + initial state) to the client\n2. If you want to use universal Sagas, and assuming you're using componentWillMount to dispatch data loading actions (componentDidMount will not work on the server) then you need to follow this steps:\n   - Run the root saga of your app\n   - RenderToString will trigger componentWillMount and thus will dispatch the load actions for Sagas. You need to close the store immediately after\n   - root Saga will fork the necessary tasks and wait for them to finish. After all tasks finish (or after the 1st error). The done promise of the root saga will resolve/reject. At this point the Store's state is already updated by Sagas and you can do your 2nd render that will be sent to the client\n@ojkelly a small correction, the 2nd render is the one into done callback\n. Use map to yield a parallel effect. If you want to yield effect in sequence (wait for 1st effect to terminate before yielding the 2nd) use a normal for loop\njavascript\nfunction* mySaga() {\n  yield all([1,2,3].map(x => call(foo, bar)));\n}\n. thanks\n. It means that a take(...) call inside root saga was provided with an undefined argument (e.g. because a misspelled constant)\n. I don't recommend using actionChannel inside race calls as it buffers all incoming actions so it may not work consistently with other effects: If you start a race and there is already an action in the channel's internal buffer the race will be resolved with it\n. @codering didn't have in mind to support IE8. This would lead to unnecessary complications in the code\n. > Also probably there's a better place for delay function than root module, maybe src/utils.js?\nI was hesitant on this\n- It makes more sense to put the function on the utils module as you said\n- OTOH thought this would involve more imports for the user\n``` js\nimport { takeEvery } from 'redux-saga'\nimport { takr, put,  ... } from 'redux-saga/effects'\nimport { delay } from 'redux-saga/utils'\n```\nWhat do you think?\n. > Last options I see are to put it in internal/sagaHelpers or to introduce new module.\nI dont think it's a natural place. this module implements helpers Generators (manually) which is not the cas of delay\nWe can let the implementation in src/internal/utils and export the function from the root module src/index. We can move the CANCEL constant itself from src/internal/proc to src/internal/util to avoid cross reference issues\n. thanks! I'll make a 0.10.4 asap\n. This is not in the source files but the babel compiled files (inside lib folder). all CR+LF endings (yeap! I work in Windows locally) are converted to LF. Except in multiline comments where you still find CR+LF. I don't think this is an issue as long as it's in the compiled files and only inside comments. In the source You'll still find all lines ends with just LF (CR+LF are automtically converted to LF in git commits)\n. TBH didn't work before with .editorconfig. I'll take a look, thanks.\n. Thanks for the catch. I'll fix this in the next patch\n. FYI fixed in 0.10.3\n. Great! thanks for this one!\n. You can treat takeEvery/takeLatest either as a single call; in this case you can use it with yield call(takeEvery, ACTION, saga) or (yield fork(takeEevry,..) and the test could be just as a normal call (or fork) Effect test.\nIf you want to test the internals of the Generator (when you use yield*) you can find the implementation here https://redux-saga.github.io/redux-saga/docs/advanced/Concurrency.html\n. fixed by #321 \n. thanks for the cleanup\n\nfor single-line conditionals, blocks were used around 50/50, so I wasn't sure which you preferred\n\nI thinks blocks are fine. \nMaybe we should put some rules in the eslint config\n. thanks\n. thanks\n. Usually we create a standalone function for the selector This makes it easier to test for equality\n``` js\nexport function cardDisplayedSelector = ({ displayList }) => displayList.has(card.id)\nexport function* dispatchNewCard({ payload }) {\n  const card = mapResponse(payload);\n  const cardDisplayed = yield select(cardDisplayedSelector );\n  ...\n```\n``` js\ntest('newCard saga test', t => {\n  const generator = dispatchNewCard(actions.newCard(card));\nconst selectAction = generator.next().value;\n  const fakeStore = {\n    displayList: {\n      has() {\n        return this.id === card.id;\n      }\n    }\n  };\nt.equal(\n    selectAction,\n    select(cardDisplayedSelector),\n    'should yield a redux-saga/effects select action'\n  );\nt.end();\n});\n```\n. thanks\n. thanks for the catch!\n. Sorry for the delay. I was already thinking of something like this long ago. IMO it's better to keep things simple so we can get precise semantics: The way I think of it is exactly like function composition but with Generators (or functions returning promises).\nBut I think this can be implemented directly on user land: so chain would be like a higher order saga which takes a list of input sagas and then return a Saga with the above sequencing behavior. You can then either call the result Saga in a blocking way or fork it.\n. closing this. Feel free to open another PR when you have something. \n. thanks\n. From the above I can identify 2 issues:\n1. multiple calls to renderToString \n2. determine when the server flow have terminated so we can send the HTML to the client\nFor 2. we can watch for specific events (like ACTION_LOAD_USER_DATA_SUCCESS and ACTION_DASHBOARD_DATA_SUCCESS) and dispatch END once we get all the required events.\nFor 2. multiple calls to renderToString may have noticeable performance issues. In the server, until the flow terminates, we're not interested in the generated markup but only on triggering the component's lifecycle events (esp. componentWillMount) so rendering in intermediate calls is wasteful. We need to perform the render only when the flow terminates and we want to send the result to the client. \nOn possibility is to use a custom react renderer (here is an example) for the intermediate renders which turns render calls into no-op. And use renderToString only when the server flow terminates. I'm not sure however if we should rely on this feature as it's not officially documented.\nanother less complicated approach is to simply check for some condition and return null from component's render method on intermediate calls (Maybe use a HOC for this)\nThe dependency on components/actions to trigger data fetches comes from the usage of react-router. IMO What we're aiming to (usually) is to load data when a route is activated, but since in react-router we get this information via component lifecycle we trigger data fetches from here. \n. thanks\n. thanks\n. > I'm guessing this is caused by a delay in the response to yield put on the previous line.\nIn this line put(searchResultsActions.loadSearchResults(action)) are you issuing an action to a middleware who'll execute the API call? (because now put will wait for the response from the dispatch call)\n. I think we should provide both options: sync (wait for the promise response) and async (do not wait). The question is which should be the default option?\n\nShould I be using something other than put now?\n\nYou can try this workaround (until the async option gets supported)\njs\nyield fork(() => put(searchResultsActions.loadSearchResults(action)))\n. > From my point of view it would be nice to have put and putSync options as I think having 'put' waiting is not a behavior I would expect.\nI agree. Most of the time we do not expect responses from put effects.\n. https://github.com/yelouafi/redux-saga/releases/tag/v0.10.5\n. cf releases notes\nhttps://github.com/yelouafi/redux-saga/releases\n. thanks\n. Can't really say without more details. Can you provide a runnable Gist?\n. can you make sure the actions.CANCEL_SLOW_ACTION fires before the others? Or more perferably could you make some runnable gist to reproduce the issue?\nBTW the example can be simply rewritten\n``` js\nfunction* watchActions() {\n    while (true) {\n        yield put({type: actions.NO_ACTION});\n        yield take(actions.SLOW_ACTION);\n    yield race({\n      task: call(slowAction),\n      cancel: take(actions.CANCEL_SLOW_ACTION)\n    })\n}\n\n}\n``\n. That was a subtle one! you need to put thecall(delay, 3 * 1000)inside thetry` block\njs\nfunction* slowAction() {\n  try {\n    yield call(delay, 3 * 1000);\n    if (Math.random() > 0.45) {\n      yield put({type: 'SLOW_ACTION_COMPLETED'});\n    } else {\n      yield put({type: 'SLOW_ACTION_FAILED'});\n    }\n  } finally {\n    if (yield cancelled()) {\n      console.log('cancelled!')\n      yield put({type: 'SLOW_ACTION_CANCELED'});\n    }\n  }\n}\n. thanks\n. thanks\n. I think what @hoschi  is asking is a 'generic' way to handle errors inside tasks. Catching the error on the root saga will abort all the currently executing tasks on the execution tree. The same observation holds for the above snippet in proc.js, when you reach that point it's too late because all the tasks in the way have already been canceled.\nredux-saga follows the same synchronous style for handling errors, so in order to handle some errors in a generic way you'll have to implement a generic saga for handling those errors and then call it inside your catch blocks. A better way IMO, is to not use try/catch to handle application errors and use explicit return values instead. JavaScript hasn't good support for try/catch as it doesn't provide Typed catch blocks. so your catch block can swallow also application bugs (e.g. undefined var)\n. thanks\n. thanks\n. No, just laziness :)\n\nWould you accept a PR to add tests?\n\nI'd love to\n. thanks\n. Could this solve your issue?\njs\nfunction* saga() {\n  for(var i = 1; i <= 5; i++) {\n    try {\n      yield call(orderApi)\n      return Success\n    } catch(err) {\n      // do not call delay if the last attempt fails\n      if(i < 5) {\n        yield call(delay, 2000) // retry after 2s\n      }\n    }\n  }\n  // attempts failed after 5x2secs\n  return Error\n}\n\nIf you feel this warrants an extra page under \"Advanced Concepts\" I'd be happy to write it and contribute it back.\n\nI think it's a good case to add to the Recipes section\nhttps://redux-saga.github.io/redux-saga/docs/recipes/index.html\n. Could this solve your issue?\njs\nfunction* saga() {\n  for(var i = 1; i <= 5; i++) {\n    try {\n      yield call(orderApi)\n      return Success\n    } catch(err) {\n      // do not call delay if the last attempt fails\n      if(i < 5) {\n        yield call(delay, 2000) // retry after 2s\n      }\n    }\n  }\n  // attempts failed after 5x2secs\n  return Error\n}\n\nIf you feel this warrants an extra page under \"Advanced Concepts\" I'd be happy to write it and contribute it back.\n\nI think it's a good case to add to the Recipes section\nhttps://redux-saga.github.io/redux-saga/docs/recipes/index.html\n. You'll have to throw the error instead of returing it\njs\nfunction* checkOrderSaga() {\n  for(let i = 1; i <= 5; i++) {\n    try {\n      const order = yield call(orderApi);\n      return order;\n    } catch(err) {\n      if(i < 5) {\n        yield call(delay, 2000);\n      }\n    }\n  }\n  // attempts failed after 5x2secs\n  throw new Error('Order not fulfilled. Giving up.');\n}\n\nEDIT the code return Error was just for illustration\n. You'll have to throw the error instead of returing it\n\njs\nfunction* checkOrderSaga() {\n  for(let i = 1; i <= 5; i++) {\n    try {\n      const order = yield call(orderApi);\n      return order;\n    } catch(err) {\n      if(i < 5) {\n        yield call(delay, 2000);\n      }\n    }\n  }\n  // attempts failed after 5x2secs\n  throw new Error('Order not fulfilled. Giving up.');\n}\n\nEDIT the code return Error was just for illustration\n. yes; throwing instead of returning is because you catch in the containing saga, so you're expecting the subsaga to throw errors instead of returning them\n. yes; throwing instead of returning is because you catch in the containing saga, so you're expecting the subsaga to throw errors instead of returning them\n. The rest seems Ok. So I'll merge this.\n\nThanks for the PR! \n. The rest seems Ok. So I'll merge this.\nThanks for the PR! \n. sorry I couldn't help. Didnt work with Redux form.\n. sorry I couldn't help. Didnt work with Redux form.\n. The 1st render is meant to activate componentWillMount methods which then dispatch actions for loading initial data. Actions are then handled inside sagas which will eventually update the Redux state on the server. The 2nd render (inside the then callback is the one that sends the HTML along with the cumulated state so for\n\nI think it will make performance slower if the react app become huge.\n\nAs @oreqizer mentioned the bottleneck of an app is generally on networked calls (e.g. loading data from a remote API server or a DB) where the latency is -typically- far more superior to in-process function calls. But if you find that the impact of the 2 renders is significative on your app performance then you may try another solution which dosent involve universal Sagas (like attaching load actions as static props to your components, then inspecting those props inside the router's match function) .\nI highlighted 'if you find' because the conclusion should be based on a real measurement of perf. costs  not just assumptions. \n. The 1st render is meant to activate componentWillMount methods which then dispatch actions for loading initial data. Actions are then handled inside sagas which will eventually update the Redux state on the server. The 2nd render (inside the then callback is the one that sends the HTML along with the cumulated state so for\n\nI think it will make performance slower if the react app become huge.\n\nAs @oreqizer mentioned the bottleneck of an app is generally on networked calls (e.g. loading data from a remote API server or a DB) where the latency is -typically- far more superior to in-process function calls. But if you find that the impact of the 2 renders is significative on your app performance then you may try another solution which dosent involve universal Sagas (like attaching load actions as static props to your components, then inspecting those props inside the router's match function) .\nI highlighted 'if you find' because the conclusion should be based on a real measurement of perf. costs  not just assumptions. \n. thanks\n. thanks\n. I think so. You can make new commits then just submit a new PR\n. I think so. You can make new commits then just submit a new PR\n. thanks\n. thanks\n. see https://redux-saga.github.io/redux-saga/docs/advanced/UsingRunSaga.html for manually starting Sagas\nIt's not recommended to do such calls inside a Reducer. If your component architecture supports some lifecycle events  you can hook the runSaga call inside some  'component loaded' lifecycle method\n. see https://redux-saga.github.io/redux-saga/docs/advanced/UsingRunSaga.html for manually starting Sagas\nIt's not recommended to do such calls inside a Reducer. If your component architecture supports some lifecycle events  you can hook the runSaga call inside some  'component loaded' lifecycle method\n. thanks\n. thanks\n. Thnking of making a config option passed to the middleware factory function to customize this\n. Thnking of making a config option passed to the middleware factory function to customize this\n. thanks\n. thanks\n. thanks\n. thanks\n. thanks\n. thanks\n. thanks\n. thanks\n. It depends on the use case, I dont think having many watchers will impact the perf. on most cases (unless it's a perf. critical app ).But you need to profile the app and measure the impact\n. It depends on the use case, I dont think having many watchers will impact the perf. on most cases (unless it's a perf. critical app ).But you need to profile the app and measure the impact\n. @kuy Appreciate your help (and other contributions). Thanks!\n. @kuy Appreciate your help (and other contributions). Thanks!\n. thanks\n. thanks\n. fixed by #422\n. fixed by #422\n. Agree. emitter or channelEmitter seems more appropriate\n. Agree. emitter or channelEmitter seems more appropriate\n. It's ok. Thanks\n. It's ok. Thanks\n. As @kuy mentioned it depends on the sepecific use case. If you want to achieve a general purpose communication mechanism you make take a look at the Channel API.\n. As @kuy mentioned it depends on the sepecific use case. If you want to achieve a general purpose communication mechanism you make take a look at the Channel API.\n. I think it's not a big deal here to mutate the object. Thanks\n. I think it's not a big deal here to mutate the object. Thanks\n. > Is this behavior expected (when the wrapped saga immediately throws an error)?\nYes.And with the new fork model of 0.10 uncaught errors bubbling from forked saga will abort the parent chain. So a forked task should always handle its errors.\n\nShould I just be using spawn instead of fork? It seems like I should default to using spawn unless I need the \"child saga\" to take down the parent in the case of an error. Does that sound right?\n\nspawn is used for detached children, a spawned task lives as a separate process, meaning cancelling a parent task wont automatically cancel the spawned task.\nUsing spawn just for this use case seems a little overkill; if what you need is to send crash reports you may look at #343\n. > Is this behavior expected (when the wrapped saga immediately throws an error)?\nYes.And with the new fork model of 0.10 uncaught errors bubbling from forked saga will abort the parent chain. So a forked task should always handle its errors.\n\nShould I just be using spawn instead of fork? It seems like I should default to using spawn unless I need the \"child saga\" to take down the parent in the case of an error. Does that sound right?\n\nspawn is used for detached children, a spawned task lives as a separate process, meaning cancelling a parent task wont automatically cancel the spawned task.\nUsing spawn just for this use case seems a little overkill; if what you need is to send crash reports you may look at #343\n. Your gist seems to work correctly in jsbin. what Node version are you using?\n. Your gist seems to work correctly in jsbin. what Node version are you using?\n. the issue is that generator.return() is not supported until Node v6; see https://kangax.github.io/compat-table/es6/#node6. the generator.return() method is used by the middleware to jump to the finally block\nRight now, the middleware simply terminates the saga if there is no return method on the generator. Which means the yields in the finally block as well as chan.close (which cancels the interval) are never executed\nperhaps I should throw an error if there is no return method instead of simply terminating the saga \n. the issue is that generator.return() is not supported until Node v6; see https://kangax.github.io/compat-table/es6/#node6. the generator.return() method is used by the middleware to jump to the finally block\nRight now, the middleware simply terminates the saga if there is no return method on the generator. Which means the yields in the finally block as well as chan.close (which cancels the interval) are never executed\nperhaps I should throw an error if there is no return method instead of simply terminating the saga \n. This will be a lot complicated; cancellation propagation logic is handled in multiple parts in the code. You should use a polyfill like babel-polyfill\n. This will be a lot complicated; cancellation propagation logic is handled in multiple parts in the code. You should use a polyfill like babel-polyfill\n. Yeah I agree. The issue is that sometimes people report issues and it's not clear immediately if it's a bug or a mistake in the reported example.\nPerhaps we should require some template for issue reporting\n. Yeah I agree. The issue is that sometimes people report issues and it's not clear immediately if it's a bug or a mistake in the reported example.\nPerhaps we should require some template for issue reporting\n. the issue is that in JS  catch will catch all errors. For ex. in your example above the catch will trap both errors from the api call as well as any bug raised inside the stack frame of put.\nSo you may either test errors inside the catch to filter out 'business errors' from program bugs. Or better do not use try/catch to handle your business errors and instead use explicit return values (e.g. the return value of call(ensureAuth) can be an object with response/error props)\n. the issue is that in JS  catch will catch all errors. For ex. in your example above the catch will trap both errors from the api call as well as any bug raised inside the stack frame of put.\nSo you may either test errors inside the catch to filter out 'business errors' from program bugs. Or better do not use try/catch to handle your business errors and instead use explicit return values (e.g. the return value of call(ensureAuth) can be an object with response/error props)\n. If I understand correctly the issue addressed by the snippet above is the deep stack traces by logging the error in a fresh stack (timeout).\nIf that so, I don't think this has to be implemented in the core. Esp. because this would confuse users about when the errors happened (e.g. think an error with a small stack trace)\n. @mistre833  please note that usage questions should be posted on SO\n. > Is there any way to cleanly handle this using the current API\nyou can create your own buffer and pass it to eventChannel\n. Hmm... Not sure about this. Seems more like an implementation concern for a special kind of buffers (buffers which clear on some action/event)\n. thanks\n. thanks\n. thanks\n. You can catch uncaught exceptions from your root Saga\njs\nconst rootTask = sagaMiddleware.run(rootSaga)\nrootTask.done.catch(...)\n. But note that the method above works more as a crash reporting mechanism. i.e. when the error reaches that level, all sagas in the way are already cancelled.\n. yes. all errors that are raised inside sagas are trapped\n. thanks. sounds good for me\n. @sibelius please note that questions should be posted on SO. this is to keep the issues repo. focused on bugs & proposals.\n. see https://redux-saga.github.io/redux-saga/docs/basics/UsingSagaHelpers.html. At the bottom there is an example on how to start mulitple watchers\n. @Moeriki yes. As you said it's by design to keep things consistent with Redux actions.\n. thanks. \n\nI thought it would be nice to have them in the section as well, as it looks like a nice ecosystem is starting to grow around redux-saga\n\nyeah. That's nice to see. I hope there will be more add-ons like this\n. thanks for working on this. \n. Not sure what exactly the kind of behavior you are looking for : does resuming the execution execute all suspended effects or just should ignore them? Also to do hot relaod with time-travel you need to replay all the Sagas from the beginning. I don't see how just suspending the Effects would permit us to do time travel.\n. A possible way is to 'embed' the saga middleware itself in another middleware that will manage the pause/resume mechanism. This would also be a generic solution as you can apply it to any other middleware\nA snippet (untested)\n``` js\nfunction pauseResumeMiddleware(middlewre) {\n  let paused = false\n  return store => next => \n    let delegate = middleware(store)(next)\nreturn action => {\n  if(action.type === 'PAUSE')\n     paused = true\n  else if(action.type === 'RESUME')\n     paused = false\n\n  if(paused)\n    return next(action) // skip if paused\n  else\n    return delegate(action)\n}\n\n};\n}\n```\n. This will be more complicated b/c there maybe sagas in the middle of a blocking effect (API call, channel's take, a put waiting in a promise, a join); and also effects can be nested inside composite race/parallel effects.\n. see in #410 \n. In the old fork model (pre 0.10) task termination was signaled via promises. so in the example above, the authorize task ending will be signaled in the next tick while the LOGIN_ERROR action will be processed synchronously.\nThe 0.10.x releases fixes this by signaling termination synchronously (and also cancelations are no longer propagated via exceptions see https://github.com/yelouafi/redux-saga/releases). I strongly recommend using the lasted release which have better handling for edge cases and a more consistent fork model.\nMeanwhile in your example above you can cancel the authorize task only on LOGOUT actions\njs\nfunction* loginFlow() {\n  ...\n  while (true) {\n     ...\n     const { type } = yield take([actions.LOGOUT, actions.LOGIN_ERROR])\n     if (type === actions.LOGOUT) {\n       yield cancel(authorizeTask)\n       yield take(actions.LOGOUT_SUCCESS)\n     }\n  }\n}\n. You can't yield a Saga directly. You'll have to wrap it inside call or fork\n``` diff\nexport default function* rootSagas() {\n  const allSagas = [\n    ...accountSagas,\n    ...cities.sagas,\n    apiRequest,\n    ...retailerSagas,\n    ...garagesSagas,\n    ...onboardingSagas,\n    ...telemetrySagas,\n  ]\nyield allSagas.map(call)\n}\n``\n. @sergej-s The problem is in thesubscribe` function\njs\nsubscribe(callback) {\n  return setInterval(() => (callback({type: 'TEST'})), 1000);\n}\nthe function should return an unsubscribe function, in your case you're just returning the interval's id. The middleware was trying to call unsubscribe (a non function) which results in an error. The error of course was not signaled. This is an issue of redux-saga which must be fixed.\nNote that simply returning a clearInterval in your example wont work either because the subscribe function must be multicast: it's shared between multiple Sagas, each Saga subscribes when started and unsubscribe when finished. So if you just return clearInterval, the first terminated Saga will call unsubscribe causing the interval to be stopped for all other Sagas\nHere is a simplified example that works\n``` js\nfunction createEmitter() {\n  const listeners = []\nreturn {\n    subscribe(l) {\n      listeners.push(l)\n      return () => {\n        const idx = listeners.indexOf(l)\n        if(idx >= 0)\n          listeners.splice(idx, 1)\n      }\n    },\nemit(action) {\n  listeners.forEach(l => l(action))\n}\n\n}\n}\n//... inchanged\nconst {subscribe, emit} = createEmitter ()\nsetInterval(() => emit({type: 'TEST'}), 1000);\nrs.runSaga(\n  rootSaga(),\n  {\n    subscribe,\n    dispatch(action) {\n      console.log(action);\n    },\n    getState() {}\n  }\n);\n```\n. yes. you just pass noop functions for unused params\n``` js\nconst noop = () => {}\nfunction runSagaEx(generator) {\n  return runSaga(generator, {\n    subscribe: () => noop,\n    dispatch: noop,\n    getState: noop,\n  })\n}\nrunSagaEx(rootSaga())\n```\nI should perhaps add support for this into the lib\n. Sounds good. Thanks\n. Although docs are not updated yet, put.sync is a public API https://github.com/yelouafi/redux-saga/releases/tag/v0.10.5.\n. thanks\n. thanks. \nMaybe we should replace the entire example and keep only the version with takeLatest\n. > Do I have to coordinate put/take some custom event?\nYes, once a task has been cancelled. The only way to communicate with it is through take/put. In your case I'd recommend to setup  an action channel to avoid race conditions\n``` js\nfunction* subTask() {\n  try {\n    run something for a while;\n  } finally {\n    if (yield cancelled()) { \n      ... \n      yield put({type: 'CANCEL_DONE',...})\n    }\n  }\n}\nfunction* mainTask() {\n  const cancelDoneChan = yield actionChannel('CANCEL_DONE')\n  while (true) {\n    s = yield fork(subTask);\n    run something;\n    if (somethingWrong) {\n      yield cancel(s); // <== early stop\n    }\n    yield take(cancelDoneChan);\n  }\n}\n``\n. yes. can pass a channel to forked tasks as a param\n. yes; because event channels are implemented using continuation callbacks, the receiver's code is executed inside the stack frame ofemitter`. This means any non-blocking effects in the receiver will be executed before returning\n. You can simply yield to a Promise.resolve() which is more performant \n``` js\nfunction nextTick() {\n  return Promise.resolve()\n}\nfunction* saga() {\n  yield call(nexTick)\n}\n```\n. This could be an interesting feature, and if it can solve the time travel problem, it'd be great, but the PR only implements a part of it. For example, how do we resume once sagas are suspended? and more importantly we need an example of how this pause/resume is used to implement time travel debugging.\nThere is also an issue with 'ignoring' the effect above. Say for example we have a Saga like this\njs\nfunction *saga() {\n  yield take(ACTION)\n  const resp = yield call(api)\n  yield put(SUCCESS)\n}\nSuppose we suspend the saga while trying to execute the call effect. If we simply ignore the effect, then resuming it later will execute the put effect with an undefined action.\n. thanks\n. > I'm still not sure about the name of this helper\nYeah. the name suggests that the saga doesn't ignore actions and queue them one after another.\n. Sorry for the long delay.\nIf I'm not mistakn the corresponding generator code is\njs\nfunction* takeSequence(pattern, worker, ...args) {\n  while(true) {\n    const action = yield take(pattern)\n    const task = yield fork(worker, ...args, action)\n    yield join(task)\n  }\n}\nBut then fork followed by a join is equivalent to a simple call\njs\nfunction* takeSequence(pattern, worker, ...args) {\n  while(true) {\n    const action = yield take(pattern)\n    yield call(worker, ...args, action)\n  }\n}\nI'm willing to add this helper as well, but I dont like much the takeSequence name. the helper name should suggest that the helper skip actions while blocked on the current task. or at the very least should not suggest that he is taking all actions in sequence\n. The issue is not caused by takeEvery missing PING actions; you can check it by simply inserting a console.log statement at the beginning of ackWorker. You'll see that the 2 workers are forked which means that takeEvery caught the 2 PING actions.\nThe issue is caused by the scheduling algorithm of redux-saga. Internally the middleware tries to 'reorder' the Effects so to make it look like the forked tasks are ran in parallel, fundamentally because JavaScript is single threaded, and redux-saga resolves effects synchronously (b/c doing it with Promise scheduling causes a lot more problems than it solves, a well known issue in older versions of the lib)\nfor example when executing a fork Effect, the library setup a 'lock' so any put Effect executed within the stack frame of a fork will be delayed until the fork completes and the next effect executed (this is explained in https://github.com/yelouafi/redux-saga/issues/277#issuecomment-216083937). For example\n``` js\nfunction* watcher() {\n  while(true) {\n    yield take('PING')\n    yield fork(worker)\n  }\n}\nfunction* worker() {\n  // ... non blocking stuff\n  yield put('PING')\n}\n```\nThe worker's put is executed inside the the stack frame of watcher's fork, so the put is delayed until the watcher resumes and executes the take Effect. then the lock is released, the put is then executed and can be taken by watcher. This is precisely what prevents takeEvery from missing actions from its forks.\nI'll have to review the scheduling code in order to account for the case above. This is not a simple problem. You'll see there are already a bunch of test cases solved by the actual solution and any fix must not break the previous test cases.\nAs for the proposed solution, it'll solve the above issue for sure but can break existing behavior; For example\n``` js\nfunction* watcher() {\n  yield takeEvery('PING', worker)\n  yield put({type: 'PONG'})\n}\nfunction* worker() {\n  yield take('PONG')\n}\n```\nIf we delay the worker by a Promise.resolve, then it will miss the PONG action dispatched immediately after the fork.\nI'd stay away from promise based solutions as their async behavior can create subtle race effects in the cases like above. If you want to have a predictable behavior which can handle all edge cases use actionChannel instead.\n. I considered this idea when starting the lib. But as @MattKunze didn't think of use cases for it.\nIMO it may be also more confusing. The semantics of a few effects (call, put, ...) if well understood make the code immediately understandable; With custom effects however, this may create another level of inderiction b/c the reader has to also understand the semantics of the custom operator (which may denote a call to a function)\n. > I guess in this scenario, followLink is a more specialised form of call.\nExact. You can create an effect creator which builds the specialized call effect.\nFor example\n``` js\n// Saga to handle the effect logic\nfunction* followLinkSaga(url) {\n   yield call(fetch, url)\n   //... retry logic\n}\n// Effect creator\nfunction followLink(url) {\n  return call(followLinkSaga, url)\n}\n// Use it like other effects\nfunction* saga() {\n   const {url} = yield take(ACTION)\n   yield followLink(url)\n}\n```\n. thanks\n. thanks\n. @lukaszszymanski Please use SO for usage questions\n. It maybe suitable as part of a framework or a boilerplate based on the ducks pattern. But I dont think this should be part of the core lib.\n. @pke eventChannels are now part of redux-saga API\nhttps://redux-saga.github.io/redux-saga/docs/advanced/Channels.html\nIn your example, it'd be something like\n``` js\nfunction getDeviceTokenChannel() {\n  if (window.PushNotification) {\n    return eventChannel((emit) => {\n      let push = window.PushNotification.init({...})\n      push.on(\"notification\", emit)\n      push.on(\"error\", e => emit({error: e})\n      // return cleanup logic (called when chan.close() is invoked)\n      return () => {}\n    })\n } else {\n    throw new Error(\"No push notification available\"))\n }\n}\nfunction* saga() {\n  const pushChan = yield call(getDeviceTokenChannel)\n  while(true) {\n    const msg = yield take(pushChan)\n    if(!msg.error) {\n      yield put(actions.refreshPendingTransactions())\n    }\n  }\n}\n```\n\nEDIT : return dispose function from eventChannel factory\n. you can return a promise of the channel from getDeviceTokenChannel\n. eventChannel returns a channel (cf API docs). A call(getDeviceTokenChannel) is a simple call to a function which returns either a value (of type channel) or a promise that will resolve to that value (promise of a channel). After that you can use the returned channel with take effects like shown above\n\njs\nfunction getDeviceTokenChannel() {\n  return new Promise((resolve, reject) => {\n    if (window.PushNotification) {\n      push.on('registration', (data) => resolve(eventChannel(...))\n    }) else {\n       reject(\"No push notification available\"))\n    }\n  })\n}\n. You don't actually call eventChannel (and I mean the real one from redux-saga)\n``` es6\nimport { eventChannel } from 'redux-saga'\nconst createChannel = (target, eventName) => eventChannel/here/(emitter => {\n  ...\n})\n```\nAlso taking from an array mixing channels and action types in not (yet!) supported. You should use race for this\nes6\nfunction* refreshUser(access_token) {\n  const visibilityChangeChannel = yield call(createChannel, document, \"visibilitychange\")\n  try {\n    while (true) {\n      yield call(apiUserRefresh, access_token)\n     /* here */\n      yield race([take([REFRESH_USER), take(visiblityChangeChannel)])\n   ...\n  }\n}\n. thanks\n. Thanks and sorry for the delay.\n. You can pass getState explicitly as argument in sagaMiddleware.run\njs\nfunction* rootSaga(getState) {\n  ...\n}\nconst store = createStore(...)\nsagaMiddleware.run(rootSaga, store.getState)\n. Sorry for the late replay.\nAs you said, overriding select effect is not supported. But I think passing a selector to the child saga would do the same thing\n``` js\nfunction* megaItemEditorSaga() {\n  yield fork(childSaga, itemSelector)\n}\nfunction* itemEditorSaga(itemSelector) {\n  yield select(itemSelector)\n}\n. `put` Effect simply executes `store.dispatch` behind the scene so I suspect the issue is elsewhere.\n. have you been able to locate the issue?\n. js\nimport createSagaMiddleware, { END } from 'redux-saga'\nimport { createStore, applyMiddleware } from 'redux'\nimport rootSaga from '...'\nimport rootReducer from '...'\nconst sagaMiddleware = createSagaMiddleware()\nconst store = createStore(\n  rootReducer, \n  applyMiddleware(sagaMiddleware)\n)\nsagaMiddleware.run(rootSaga).done.then(() => { \n  / put tests here /\n})\n//... dispatch test actions\n// then signal that no action will be dispatched further\n// this will stop all action watchers and wait for any pending requests to finish\n// after that the 'done' prop above will be resolved \n// (or rejected if an uncaught error is detected)\nstore.dispatch(END)\n```\n. You can also run the worker Saga directly\n``` javascript\ndescribe('redux saga', () => {\n  it('increments async by 1', async () => {\n    const store = configureStore({counter: 1})\nawait sagaMiddleware.run(incrementAsyncSaga(1)).done\nconst counter = selectCounter(store.getState())\nexpect(counter).toBe(2)\n\nawait sagaMiddleware.run(incrementAsyncSaga(1)).done\nconst counter = selectCounter(store.getState())\nexpect(counter).toBe(3)\n\n})\n})\n``\n. Can you post a test case or a runnable gist? I tried the above snippet but couldn't reproduce the issue\n. Sorry not yet. I'll take a look asap\n. I think we can get around this by implementingreturnin iterators returned by saga helpers. Already pushed a fix  with this solution. I did the tests locally on the @smashercosmo fork and the error is gone (although there are still an error related toimport` statements but that's related to missing node presets)\n. FYI https://github.com/yelouafi/redux-saga/releases/tag/v0.11.1\n. > My question is how would I wrap AMD require or ensure.require in the proper saga effect like call or fork?\nYou can promisify the 'require' function then use it with call or fork\n``` js\nfunction requireP(url) {\n  return new Promise(resolve => {\n    require(\"provisioned.json\", resolve)\n  })\n}\nfunction* saga() {\n  ...\n  const data = requireP(\"provisioned.json\")\n}\n```\n. thanks\n. thanks\n. thanks\n. @mxstbr I find your introduction better\nI'm not particularly proud of the current Section on Sagas; Either we should put content related to how Sagas work in the context of frontend/React apps, giving example with redux-saga; or at the very least we should put the links in the resources section. The point is that people are not required to go through the academic papers or backend specific content to start using the library.\n. closing this. see #437\n. sorry for the delay. I added some notes. \n. Looks great! thanks.\nSorry but one last remark, actually there is no mention that this a Redux middleware. Perhaps we should mention that\n- The library is a redux middleware (although it can be used outside of Redux)\n-  [Optionally define what is Redux] a library which makes managing application state consistent and predictable\n- redux without middleware can not perform side effects but only transform state inside reducers\n. > I don't think we should add this to the introductory text, I think assuming that people know redux is a fair assumption for a library called redux-saga that mentions it's a redux middleware\nRight.\nI'll update the docs repo right away. Thanks again!\n. Thanks for working on this. There is one concern though: when taking out elements from the buffer (using take or shifting in the Sliding Buffer case) the code just updates the indexes which can cause memory leaks since the underlying array is still holding a reference to the removed data. So I think we need to free the reference to the data in the array cells (by setting it to null or undefined) \n\nI'm not sure what to put as the default limit (it can't be Infinity, obviously) as I am not very familiar with what this buffer is used for. Feel free to change it.\n\nI think we can just put a low limit as default (eg 10 like the max num of listeners in Nodejs). The lib user can still put a higher number if required (Another option could be: when there is no limit argument=default to Inifnity, allocate a bigger array and copy old data here. But I don't like much this approach since it can hide memory leaks from the lib user)\n\nIt passes your provided tests, but I'm not sure how much performance increase this will provide. Up to you whether to merge it in or not, but would like your feedback regardless.\n\nI'll try to run some perfs tests locally. But I expect it to be more performant b/c we're working with a fixed array in memory and most VMs has optimizations for this cases (continuous blob on OS memory). In the actual impl. arr.shift (maybe even arr.push) calls will likely be causing deoptimizations on VMs\n\nThe length variable within the ringBuffer simplifies checking if the buffer is empty or not (no edge case where pushIndex == popIndex but the buffer could be full or empty).\n\nthe length could be calculated from Math.abs(pushIndex - popIndex) % limit but it's not obvious to me which approach is more performant: calculating on demand or updating the length var each time (though I don't think this has significant impact)\n. > Regarding the potential memory leaks in the shifting case, arr[pushIndex] = it replaces the reference to the removed data\nYes. You're right.\n. I'll look at this more closely, I think it's due to an incorrect handling in the lib of the sync forks. For example in Scenario 1, it's clearly a bug, since the fork shouldn't return the error but has to throw it (Actually in this place of the code we need to put cb(err, true) to indicate that this is an error).\nBut first le me indicate what the expected behavior should be in both sync and async cases (I'm planning to add this in the docs in a 'redux-saga fork model' section).\nWhen using a call a generator should be able to catch errors from the called function/generator\njs\ntry {\n  yield call(funcorGen, ...)\n} catch(err) { ... }\nUncaught errors should bubble up the call chain (ie to calls from parents) just like in normal JavaScript code.\nfork effects has different semantics. Observe this code for ex.\njs\nfunction* parent() {\n  try {\n    yield fork(funcorGen, ...)\n  } catch(err) { ... } // Invalid, you can't expect to catch errors from forked tasks\n}\nThe reason you can't catch errors from forks is that the parent is not blocked and waiting for the fork but continues its execution as soon as the fork is performed; when a fork throws some error the parent Generator could have moved past the try catch block\njs\nfunction* parent() {\n  try {\n    yield fork(funcOrGen, ...)\n  } catch(err) { ... } \n  // when `funcOrGen` task throws, the Generator could be already here\n  yield fork(anotherFuncOrGen) \n}\nSo the rule of thumb is you can't catch errors from forks, but they still bubble up. So how do Error propagation from forked tasks work?\n\nNote for all readers: If you dont want to dig deeper into this, you can just remember the rule above and skip all of this.\n\nIn the pre 0.10 versions all errors from forked tasks were swallowed. Just like in raw Promises and async functions now. The 0.10 release introduced a new concept of attached fork see release notes : a parent can fork one or multiple tasks, say for example we have a saga which at some time forked 2 tasks, so now we have 3 tasks evolving in parallel\n- The 'main task' is the parent who forked the other tasks\n- The 2 forked tasks\nYou can view those tasks as 3 parallel tasks belonging to the same execution context or execution tree. Each one of the 3 tasks can catch its own errors, but can' t catch errors from its siblings. When an uncaught error is raised inside one of the 3 tasks, the whole execution tree is aborted: the errored task is of course aborted, and the sibling tasks, if they are still running, are cancelled (including all their respective subtasks, effectively killing all the nested execution trees).  \nAfter an execution tree is aborted, the error bubbles up to the parent of the main task. If this parent was calling the main task using call (or join) then it should be able to catch that error, but if it was using fork the same mechanism happens: the whole execution tree corresponding to that parent (its own task and all forked tasks) is cancelled and the error is raised again up to the root.\nTo summarize:\n- A Generator, along with all its forked tasks, form an execution tree (forked tasks can also have their own nested execution trees). The generator forking the other tasks is called the main task, the main task can catch errors only from generators/functions invoked using a blocking call (call or join).\n- The execution tree terminates when the main task's body terminates as well as all forked tasks (all nested execution trees should terminate)\n- Cancelling the main task will cancel the whole execution tree\n- Any uncaught error from a task (main tasks or one of the forks) in the execution tree causes the whole execution tree to abort. The error bubbles up to the parent of the main task (and the same rules applies to this parent).\nSo in relation to the above scenarios, it seems (I have still to look more closely) that this is caused by an inconsistent handing of the synchronous forks (ie which terminates synchronously). in the actual code the sync errors from forks are reported to the main task, but they should behave like the async forks and cause the whole execution tree to abort. And since the fork aborts synchronously, we can't expect the fork call to return a task but immediately aborts the whole execution tree including the main task.\nOTOH, detached forks , created using the spawn Effect behave like the pre 0.10 forks; errors raised from spawned tasks are lost unless you handle them explicitly (catching in the done promise of the task, of joining a spawned task). This is pretty much the behavior of the raw promises and async functions: the behavior of error propagations depend on whether and when you attached the error handler to a promise chain (before or after the error was raised).\nThe structured model of attached forks, may sound more restrictive and less flexible, but It's this structure and the rules above which makes things like Server Side Rendering possible with the same Saga code running both on the client and the server.\n. > can P handle the error and stop the cancellation from bubbling?\nYes but only if P is using a blocking call (call, join or a composite form of them like [] or race). If P is invoking T using fork the same mechanism happens: P is aborted.\nto get a better intuition, you can think of a saga + its forks as a dynamic parallel effect. In a static parallel effect\njs\nfunction* saga() {\n  try {\n     yield [call(s1), call(s2)]\n   } catch (err) { ... }\n}\nthe parallel effect [call(s1), call(s2)] will terminate only after all effects inside terminate. And will abort as soon as one effect inside the array raises an uncaught error. And note s1 for example can not catch errors from its sibling s2. But saga can catch errors from the array because yield [call(s1), call(s2)] is a blocking call.\nNow with forks\n``` js\nfunction* childSaga() {\n  while(true) {\n    yield take(ACTION)\n    yield fork(s)\n   } \n}\nfunction* saga() {\n  try {\n    yield call(childSaga)\n  } catch(err) { ... } // ok, can catch errors b/c it's using a blocking call\n}\n```\nYou can think of call(childSaga) as [call(s1), call(s2)]. But now instead of a fixed list, we have a dynamic list of tasks (because we dont know in advance how many tasks w're going to call, it depends on the number of dispatched actions):\njs\nyield [main, call(s1), call(s2), ...]\nThe 1st one is the main task childSaga itself which runs the while(true) loop and forks other tasks dynamically, and the rest are the tasks forked by main. The list may grow dynamically as new tasks are forked (or shrink as existent tasks are terminated). And same as the static parallel effect:\n- any error from one of those tasks will cause the whole 'dynamic array' to abort.\n- the whole 'dynamic array' will terminate after all child tasks terminate (ie main and all the forked tasks)\n. I'm not sure to understand\n- If you want to wait for a task immediately after forking it you can simply use call. \n- If you want to wait for a specific task t you can use yield join(t)\n- If you want to handle errors from all forks in a saga and prevent that Saga from being aborted (I suspect this is what you want). You can either handle the errors inside the forked tasks themselves, or if you want to keep it a separate concern, you can wrap all forks in a generic handler\n``` js\nfunction* wrapFork(saga, args = []) {\n  try {\n    return yield call(saga)\n  } catch(err) { \n     ...\n   }\n}\nfunction* parent() {\n  while(true) {\n    yield take(action)\n    yield fork(wrapFork, saga)\n  }\n}\n```\nBut if you wanted my 'very opinionated way' for handling errors, you shouldn't rely on try/catch to handle errors in all JavaScript and use explicit return values for 'expected (business)' errors. Then let the 'unexpected errors' (bugs) bubble up and abort the program (catch them at the top saga to send a crash report)\n. sorry for the delay. The above should not work. since you can't catch errors from forked tasks.\nBTW, instead of yield task.done, it's better to use yield join(task).\nFYI, I've already implemented the fixes and also added initial docs for the fork behavior. To be uploaded shortly with a new release\n. thanks\n. if you want to yield multiple calls in parallel, use the snippet of @sergej-s; to put the results in parallel you can yield an array of put effects\njs\nyield R.map(item => put({type: '...', payalod: item}), data)\n. I think we need a more concrete example. Like subscribing to a websocket, browser history event.\n. @michael-iglesias where do you start watchForFetchYears\n. thanks\n. Yes you're right. Thanks\n. thanks\n. thanks! great work\n. thanks\n. thanks\n. the yield iterator is a blocking call. It means we'll have to wait for the iterator to terminate before resuming the caller. In your PR we'll be calling the continuation cb twice: 1st with task and later with the return value of the iterator\n. Actually you can have the desired behavior using fork\njs\nyield fork(takeEvery, action, saga, ...args)\n\nstill dont you think that such helper as takeEvery should return its task to the caller? it has no return value, so its stoping caller indefinitely\n\nSo you're proposing to make yielding to helpers non blocking and return a task descriptor by default to the caller. That sounds reasonable to me. The only concern is that could break the existing behavior (blocking); not sure how this will affect existing code (OTOH since blocking on saga helpers will block the parent saga forever (b/c saga helpers never return) I don't see how changing the behavior could negatively affect an existing flow)\n\nAint sure how I would implement it yet, but might give it a try if you green light it + maybe give some tips about desired implementation details.\n\nwe can test if the iterator was created by  a Saga helper; \nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L328\nSo we'll need to put some flag on the iterators returned by the following method (which can be tested in the above code)\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/utils.js#L92-L98\nIf the iterator was created by a saga helper we call runForkEffect (instead of resolveIterator)\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L430\nBut for this we need to make  runForkEffect support forking iterators directly (instead of functions returning iterators).\n. sorry for the delay. And thanks\n. thanks\n. Yeah; that's a subtle case, thanks \n. > I don't know if the side effect being synchronous is related\nI think this is related to #441.\n. > I don't know if the side effect being synchronous is related\nI think this is related to #441.\n. FYI new 0.11.1 release fixes the errors issue. \nCan you try with the new release ? I'm mostly sure this is a similar issue\n. FYI new 0.11.1 release fixes the errors issue. \nCan you try with the new release ? I'm mostly sure this is a similar issue\n. thanks\n. thanks\n. In fact asEffect is already exported from the redux-saga/utils. \n\nbut I guess it's not really a good idea to use this outside redux-saga source code. Or is it?\n\nThere is a good case for it: implementing a Saga monitor (provided as option to the sagaMiddleware.run function). You can see how it's used in the sagaMonitor example \n. In fact asEffect is already exported from the redux-saga/utils. \n\nbut I guess it's not really a good idea to use this outside redux-saga source code. Or is it?\n\nThere is a good case for it: implementing a Saga monitor (provided as option to the sagaMiddleware.run function). You can see how it's used in the sagaMonitor example \n. Thanks\n. Thanks\n. Not sure to understand the exact issue, but the actual signature of the call effect above is not call([context, fn], args) but call([context, fn], ...args) (see API). Maybe this is the cause of the issue you have\nso in the code above you can replace apply with\njs\nconst token = yield call(\n  [\n    cognitoUser,\n    cognitoUser.authenticateUser\n  ],\n  /*[ no brackets */\n    authenticationDetails,\n    { onSuccess(){}, onFailure(){} }\n  /*] no brackets*/\n);\n\nEDIT: fixed the code snippet\n. Not sure to understand the exact issue, but the actual signature of the call effect above is not call([context, fn], args) but call([context, fn], ...args) (see API). Maybe this is the cause of the issue you have\n\nso in the code above you can replace apply with\njs\nconst token = yield call(\n  [\n    cognitoUser,\n    cognitoUser.authenticateUser\n  ],\n  /*[ no brackets */\n    authenticationDetails,\n    { onSuccess(){}, onFailure(){} }\n  /*] no brackets*/\n);\n\nEDIT: fixed the code snippet\n. > I agree there is still something missing in doc\n\nyeah; I think we need an article about architecture (can be an entire section also after the advanced section)\n@tomkis1 \nI'm using Side Effect with the pure FP meaning. Long lived transactions is just one aspect that arises from the nature of Side Effects.\n. > I agree there is still something missing in doc\nyeah; I think we need an article about architecture (can be an entire section also after the advanced section)\n@tomkis1 \nI'm using Side Effect with the pure FP meaning. Long lived transactions is just one aspect that arises from the nature of Side Effects.\n. Thanks\n. Thanks\n. Why do you need to put the entire Error object in the action?  Could be just\njs\nyield put(actions.login.failure(error.message))\nAlso I think the native Error object is not easily serializable and you need to put serializable thing into actions\n. Why do you need to put the entire Error object in the action?  Could be just\njs\nyield put(actions.login.failure(error.message))\nAlso I think the native Error object is not easily serializable and you need to put serializable thing into actions\n. you can try having a function which create the error then use call in the saga to create the error\n``` js\nfunction error(msg) {\n  return new Error(msg)\n}\nexport function *createLogin (API) {\n    // ...\n    if (!ID) {\n      throw (yield call(error, 'Please provide an ID'))\n    }\n    // ...\n}\n// test\nit('should raise an error if there is no application ID', function () {\n  const generator = module.createLogin(API)\n// ...\n  assert.deepEqual(\n    generator.next().value,\n    select(getID)\n  )\nassert.deepEqual(\n    generator.next().value,\n    call(error, 'Please provide an ID')\n  )\n// create a real Error and get the reference to it\n  const idError = error('Please provide an ID')\n  // pass it to the generator\n  let next = generator.next(idError)\n  assert.deepEqual(\n    next.value, \n    put(actions.loginEntrypoint.failure(idError ))\n  )\n}\n``\n. you can try having a function which create the error then usecall` in the saga to create the error\n``` js\nfunction error(msg) {\n  return new Error(msg)\n}\nexport function *createLogin (API) {\n    // ...\n    if (!ID) {\n      throw (yield call(error, 'Please provide an ID'))\n    }\n    // ...\n}\n// test\nit('should raise an error if there is no application ID', function () {\n  const generator = module.createLogin(API)\n// ...\n  assert.deepEqual(\n    generator.next().value,\n    select(getID)\n  )\nassert.deepEqual(\n    generator.next().value,\n    call(error, 'Please provide an ID')\n  )\n// create a real Error and get the reference to it\n  const idError = error('Please provide an ID')\n  // pass it to the generator\n  let next = generator.next(idError)\n  assert.deepEqual(\n    next.value, \n    put(actions.loginEntrypoint.failure(idError ))\n  )\n}\n```\n. > I guess one could do that, but our actions conform to flux-standard-action which specifies that Error objects should be passed in the payload.\nI think this conflicts with the requirement that actions should be plain and serializable objects. For an app user to send the action log to replay on the developer machine (eg to reproduce a bug) the actions have to be serializables. Unless I'm mistaken the native Error object can't be serialized (at least not automatically). \n. > I guess one could do that, but our actions conform to flux-standard-action which specifies that Error objects should be passed in the payload.\nI think this conflicts with the requirement that actions should be plain and serializable objects. For an app user to send the action log to replay on the developer machine (eg to reproduce a bug) the actions have to be serializables. Unless I'm mistaken the native Error object can't be serialized (at least not automatically). \n. Actually there is a [kind of] support for errors in take effects: if a take is resolved with an Error it will throw in the generator. For example\n``` js\nconst myChannel = function () {\n  return eventChannel(function (emitter) {\n     const s = someSource()\n        .on('thing', emitter)\n        .on('error', () => emitter(new Error(...) ) / put an Error instance / \n        .on('done', () => emitter(END))\n     return () => s.cancel()\n  }\n}\nfunction* saga() {\n  const chan = yield call(myChannel)\n  while(true) {\n    try {\n      const thing = yield take(chan)\n    } catch(err) {\n      // emitting an Error will throw here\n    }\n  }\n}\n```\nNote that emitting an error will not abort the channel by default, if you want to end the channel after an error you'll have to close it explicitly (for example in the catch block of the Saga)\n. Actually there is a [kind of] support for errors in take effects: if a take is resolved with an Error it will throw in the generator. For example\n``` js\nconst myChannel = function () {\n  return eventChannel(function (emitter) {\n     const s = someSource()\n        .on('thing', emitter)\n        .on('error', () => emitter(new Error(...) ) / put an Error instance / \n        .on('done', () => emitter(END))\n     return () => s.cancel()\n  }\n}\nfunction* saga() {\n  const chan = yield call(myChannel)\n  while(true) {\n    try {\n      const thing = yield take(chan)\n    } catch(err) {\n      // emitting an Error will throw here\n    }\n  }\n}\n```\nNote that emitting an error will not abort the channel by default, if you want to end the channel after an error you'll have to close it explicitly (for example in the catch block of the Saga)\n. > Is this documented somewhere?\nNo but it should be of course\n. > Is this documented somewhere?\nNo but it should be of course\n. done https://redux-saga.github.io/redux-saga/docs/api/index.html#takepattern\n. done https://redux-saga.github.io/redux-saga/docs/api/index.html#takepattern\n. thanks\n. thanks\n. thanks\n. thanks\n. Seems good to me. TBH didn't think of using action channels with sliding buffers for throttling. I'll update the throttling recipe on the docs with your implementation.\nAnd thanks for all your contributions!\n. Seems good to me. TBH didn't think of using action channels with sliding buffers for throttling. I'll update the throttling recipe on the docs with your implementation.\nAnd thanks for all your contributions!\n. Oh sorry I was not quite explicit! I meant we could pass to the next steps you mentioned (tests and docs). I dont mind adding helpers for common cases to the core.\n. Oh sorry I was not quite explicit! I meant we could pass to the next steps you mentioned (tests and docs). I dont mind adding helpers for common cases to the core.\n. For the recipes I just meant your solution is cleaner than the actual one & that I should update it.\n. For the recipes I just meant your solution is cleaner than the actual one & that I should update it.\n. > Can make it as part of this PR - updating recipe. But when I'm done with docs and tests - is it even needed in the recipes? I mean underlaying implementation? It can just be explained alongside with the helper I think.\nHmm sounds right\n\nAlso I have similar helper written as generator for trailingThrottle. Dont know though if it deserves geting a standalone helper\nAlso I have similar helper written as generator for trailingThrottle. Dont know though if it deserves geting a standalone helper \n\nI think so; you can open a PR for it\nthe code seems ok; I've left some notes on docs.\nI'm having some trouble to understand what the test does.  Maybe I missed something but each worker waits for a def in the array. but since most of defs are not resolved then the worker will never put results into the ~~expected~~ actual array. My point is this won't permit us to observe throttling since even if the workers are not throttled they will not make it to the actual.push(...) instructions. (and sorry If I missed something, was a quick review)\n. > In fact there are only 5 defs created (all geting resovled eventually) and 35 actions dispatched. So not every action is geting their corresponding watcher started (cause of throttling)\nYou're right,I didn't notice the Math.floor(payload / 10).\n. > In fact there are only 5 defs created (all geting resovled eventually) and 35 actions dispatched. So not every action is geting their corresponding watcher started (cause of throttling)\nYou're right,I didn't notice the Math.floor(payload / 10).\n. thanks\n. thanks\n. Sorry for the delay. Looks like a special case of debouncing but it's a good demo for optimistic updates (using a delay).\n\nExcellent library btw, I was shocked at how easy it was to implement the ability to undo a task.\n\nThanks!\n. Sorry for the delay. Looks like a special case of debouncing but it's a good demo for optimistic updates (using a delay).\n\nExcellent library btw, I was shocked at how easy it was to implement the ability to undo a task.\n\nThanks!\n. thanks\n. thanks\n. thanks!\n. thanks!\n. thanks\n. thanks\n. Missed that; thanks @aikoven for the catch\n. Missed that; thanks @aikoven for the catch\n. sorry for the delay. channels are official API (and meant to stay). using them for inter saga communication is all normal and even recommended\n. sorry for the delay. channels are official API (and meant to stay). using them for inter saga communication is all normal and even recommended\n. thanks!\n. thanks!\n. done http://redux-saga.github.io/redux-saga/docs/api/index.html#createmocktask\n. done http://redux-saga.github.io/redux-saga/docs/api/index.html#createmocktask\n. thanks\n. thanks\n. thanks\n. thanks\n. thanks for the PR. a flush Effect can effectively be a very useful future which allows more operations on channels (debouncing, buffering with time...)\nBut I'm having some trouble to understand the proposed implementation (left some notes). Also there is a need for more complete semantics\n- is this a blocking Effect ? I guess no, we want to get only the buffered messages if any, otherwise we should resume with ... an empty array (right?)\n- if we try to flush a closed channel, the result should be the same as taking (resume with END which will end the Saga) ?\nFor the implementation I think it should be done at the channel level (having a channel.flush method perhaps backed by a similar method in the buffer)\n. thanks for the PR. a flush Effect can effectively be a very useful future which allows more operations on channels (debouncing, buffering with time...)\nBut I'm having some trouble to understand the proposed implementation (left some notes). Also there is a need for more complete semantics\n- is this a blocking Effect ? I guess no, we want to get only the buffered messages if any, otherwise we should resume with ... an empty array (right?)\n- if we try to flush a closed channel, the result should be the same as taking (resume with END which will end the Saga) ?\nFor the implementation I think it should be done at the channel level (having a channel.flush method perhaps backed by a similar method in the buffer)\n. for the semantics question, I have a decision table which describes exhaustively the semantics of each action of the channel (sort of transition function for a state machine). If we add the flush action to the table we can define the complete semantics for it (what the action should do on each channel's state)\n\n. for the semantics question, I have a decision table which describes exhaustively the semantics of each action of the channel (sort of transition function for a state machine). If we add the flush action to the table we can define the complete semantics for it (what the action should do on each channel's state)\n\n. > Isnt it wrong? I mean shouldnt close channel always resume END then and not only if it is closed and empty? Especially that closing the channel aint clearing buffer?\nNo because the channel has still some items to deliver. Future takers will get buffered items until the channel is empty. Only then we can resolve with END since no more items can be added to the channel. For the flush effect of course we will deliver all buffered items not just one.\nFor cancelation it's not a problem. Since the effect is synchronous (non blocking) it can't be cancelled\n. > Isnt it wrong? I mean shouldnt close channel always resume END then and not only if it is closed and empty? Especially that closing the channel aint clearing buffer?\nNo because the channel has still some items to deliver. Future takers will get buffered items until the channel is empty. Only then we can resolve with END since no more items can be added to the channel. For the flush effect of course we will deliver all buffered items not just one.\nFor cancelation it's not a problem. Since the effect is synchronous (non blocking) it can't be cancelled\n. This seems ok to me.\n\nAlso thought that flush could take matcher argument, but aint sure how to proceed with that, cause most likely it will need to implemented in the buffer itself, but for now it stays agnostic of what's inside it (which is nice). In the same time I've found a bug (#507) which to be solved would require similar implementation I think - matcher argument in buffer.take\n\nActually I'm not sure if we should consider it a bug, I'll put some comment on the issue.\n. And of course thanks for the great work!\n. > I've been thinking about how redux-saga has a lot in common with the IO monad from purely functional languages\nYeah, I think it's due to the way JS Generators work: yield looks a lot like do notation in Haskell. But I'm not sure the IO monad models the effect as data concept (can be unit tested?). IO Seems like an opaque data type (although I don't know how IO is tested in Haskell).\nas @slorber commented, redux-saga looks like a hybrid approach: individual Effects have some similarities with Free (model this thing as a Data structure which can be interpreted). OTOH control flow inside Generators looks like the imperative sequencing on IO monads.\n\nOne restriction would be that the do-notation would only allow one to yield IO-monad's whereas redux-saga gives the user a lot of flexibility about what to yield.\n\nAnother thing is related to concurrency, In redux-saga you can fork tasks in parallel, join and cancel them. Monads by nature are sequential. I think Haskell has a forkIO function but not sure how much control it gives over concurrency. \n\nI've played a little with the idea of implementing an IO-monad in JavaScript and using it with Fantasy Do like do-notation. Do you think such a thing is viable? \n\nGenerators have one limitation though: they can't be started from an arbitrary point, this can cause weird problems when the monad calls the chain function multiple times (eg: Array monad), especially when chained blocks have visible side effects. Do Fantasy has a special multi mode to handle this.\n\nI can see that there has previously (#16) been talk about decoupling redux-saga from redux. What is your thoughts about that now? I think a general purpose declarative effects library for JS could be interesting albeit probably not to an audience as wide as the Redux userbase.\n\nyeah. and another concern is about maintaining 2 repos (one for the core lib and another for just the middleware). Likely most of redux-saga issues will be related to the core Generator driver so either We'll have to ask redux-saga users to post issues on the core lib repo; or we'll have to duplicate them in the core repo. Each solution can be very confusing for either part (user or maintainer).\n. > I've been thinking about how redux-saga has a lot in common with the IO monad from purely functional languages\nYeah, I think it's due to the way JS Generators work: yield looks a lot like do notation in Haskell. But I'm not sure the IO monad models the effect as data concept (can be unit tested?). IO Seems like an opaque data type (although I don't know how IO is tested in Haskell).\nas @slorber commented, redux-saga looks like a hybrid approach: individual Effects have some similarities with Free (model this thing as a Data structure which can be interpreted). OTOH control flow inside Generators looks like the imperative sequencing on IO monads.\n\nOne restriction would be that the do-notation would only allow one to yield IO-monad's whereas redux-saga gives the user a lot of flexibility about what to yield.\n\nAnother thing is related to concurrency, In redux-saga you can fork tasks in parallel, join and cancel them. Monads by nature are sequential. I think Haskell has a forkIO function but not sure how much control it gives over concurrency. \n\nI've played a little with the idea of implementing an IO-monad in JavaScript and using it with Fantasy Do like do-notation. Do you think such a thing is viable? \n\nGenerators have one limitation though: they can't be started from an arbitrary point, this can cause weird problems when the monad calls the chain function multiple times (eg: Array monad), especially when chained blocks have visible side effects. Do Fantasy has a special multi mode to handle this.\n\nI can see that there has previously (#16) been talk about decoupling redux-saga from redux. What is your thoughts about that now? I think a general purpose declarative effects library for JS could be interesting albeit probably not to an audience as wide as the Redux userbase.\n\nyeah. and another concern is about maintaining 2 repos (one for the core lib and another for just the middleware). Likely most of redux-saga issues will be related to the core Generator driver so either We'll have to ask redux-saga users to post issues on the core lib repo; or we'll have to duplicate them in the core repo. Each solution can be very confusing for either part (user or maintainer).\n. @mxstbr looks interesting! I'll have to look at this\n. @mxstbr looks interesting! I'll have to look at this\n. thanks for the catch!\n. thanks for the catch!\n. I'm not sure this should be considered a bug. \nthe matcher argument is not exposed as a public API. but used internally for the special case of resolving store actions yield take(ACTION). Store actions are handled internally using an eventChannel with no buffering. So when matcher is provided to the channel we'll always have an empty buffer\n. the new version v0.12.0 includes now a new type buffer.expanding() (https://github.com/yelouafi/redux-saga/releases/tag/v0.12.0) which behaves like the old fixed.\n. the new version v0.12.0 includes now a new type buffer.expanding() (https://github.com/yelouafi/redux-saga/releases/tag/v0.12.0) which behaves like the old fixed.\n. thanks!\n. thanks!\n. thanks\n. thanks\n. thanks both!\n. thanks both!\n. @3LOK How do you handle call effects? are call effects executing the real functions?\n. @3LOK How do you handle call effects? are call effects executing the real functions?\n. @3LOK Isn't the test above also coupled (in a different manner) to the implementation. I don't mean it's a bad thing. But that in the Saga example the ordering is still important except for the last 2 put effects.\nIf we change the Saga impl. and yield an array instead of the 2 last consecutive effects where the ordering doesn't matter.\n``` js\nfunction* onDelete(clients, action) {\n// ...\nyield ([\n  put(ListActions.actions.update({data:list}));\n  put(SessionActions.actions.screenList());\n])\n\n}\n```\nwouldn't the corresponding unit test be no so much different from the mock based version?\n. @3LOK Isn't the test above also coupled (in a different manner) to the implementation. I don't mean it's a bad thing. But that in the Saga example the ordering is still important except for the last 2 put effects.\nIf we change the Saga impl. and yield an array instead of the 2 last consecutive effects where the ordering doesn't matter.\n``` js\nfunction* onDelete(clients, action) {\n// ...\nyield ([\n  put(ListActions.actions.update({data:list}));\n  put(SessionActions.actions.screenList());\n])\n\n}\n```\nwouldn't the corresponding unit test be no so much different from the mock based version?\n. thanks!\n. thanks!\n. The issue with try/catch in JavaScript is there is no way to have error specific catch like in Java or C#\njs\ntry {\n ...\n} catch (MySpecificError err) {\n  will catch only MySpecificError errors\n  other errors (like React or runtime JS errors) should bubble up\n}\nbecause of this, I believe that in Javascript (and not just in Redux-saga) expected errors (business errors like in ajax fetches) shouldn't be communicated using try/catch but using explicit return values\njs\nfunction* fetchProducts() {\n    const {response, error}= yield call(Api.fetch, '/products')\n    if(response)\n       yield put({ type: 'PRODUCTS_RECEIVED', products: response })\n    else\n      yield put({ type: 'PRODUCTS_REQUEST_FAILED', error })\n}\nThis will let all other unexpected errors (bugs) bubble up to the root and can be caught for crash reports\n. The issue with try/catch in JavaScript is there is no way to have error specific catch like in Java or C#\njs\ntry {\n ...\n} catch (MySpecificError err) {\n  will catch only MySpecificError errors\n  other errors (like React or runtime JS errors) should bubble up\n}\nbecause of this, I believe that in Javascript (and not just in Redux-saga) expected errors (business errors like in ajax fetches) shouldn't be communicated using try/catch but using explicit return values\njs\nfunction* fetchProducts() {\n    const {response, error}= yield call(Api.fetch, '/products')\n    if(response)\n       yield put({ type: 'PRODUCTS_RECEIVED', products: response })\n    else\n      yield put({ type: 'PRODUCTS_REQUEST_FAILED', error })\n}\nThis will let all other unexpected errors (bugs) bubble up to the root and can be caught for crash reports\n. thanks\n. thanks\n. > I think it's confusing to refer in the docs to historical ideas that happen to share the same name, \"sagas,\" but aren't that similar..\nI agree, but I think also that having an historical background (+ the mention that redux-saga's Sagas have a different meaning) could help avoiding confusion.\n\nHappy to PR this if you're amenable.\n\nSure, you're welcome.\n. Will delete the actual Saga section since it adds nothing but confusion and more fatigue. If anyone have an article on using Sagas in the context of react/redux apps, It'd be better.\n. Will delete the actual Saga section since it adds nothing but confusion and more fatigue. If anyone have an article on using Sagas in the context of react/redux apps, It'd be better.\n. thanks for the fix!\n. this Infinity name looks scary :). I think a name like dynamic or expanding is more appropriate\nBut I think there is an issue with the implementation, expanding the limit of the ring buffer will create a hole on the ring between actual limit and the new limit; while what you want is to create more room between the pop index and the push index.\nI think a more simple implementation is to create a new array, and copy all the items (between the pop and push indexes) into it\n. thanks\n. thanks\n. looks fine to me. Esp. tests are exhaustives. Thanks!\n. looks fine to me. Esp. tests are exhaustives. Thanks!\n. thanks\n. thanks\n. thanks\n. thanks for all!\n. thanks for all!\n. thanks\n. thanks\n. Do we need a dediczted effect here? I think this could be simply implemented in userland\n. Do we need a dediczted effect here? I think this could be simply implemented in userland\n. I prefer to keep the list of effects as minimal as possible on the core. Perhaps we should have this in a separate repo. \n. I prefer to keep the list of effects as minimal as possible on the core. Perhaps we should have this in a separate repo. \n. @slorber I don't recommend using the done promise inside Sagas as it can lead to subtle race conditions. \nYou may need to use the join effect which catches the task termination synchronously. \njs\nyield forkedTasks.map(join);\nWhen I was implementing the new fork model, join was trivially implemented on top of .done but this caused me a lot of problems as the promise didn't notify the termination until the next microtask (I susped you were experiencing the same type of issue). That's why I implemented join on top of simple continuations (callbacks).\nThe main reason I left the done promise  in the lib is to be used by external functions (outside of Sagas).\n\nSo, when using forked tasks, is there a way for the parent to catch a child error? And eventually decide weither or not to kill the whole tasks tree?\n\nThe short answer is no. But I think your case makes perfect sense. The main reason for a parent being unable to catch errors from child tasks it that both evolve in parallel. But if at a moment a parent joined a child task, I think it makes sense at this point to let the parent catch the child error (since it's now blocked/synchronized with its child). \nso I think what we should do in this case is that when a parent joins a forked task, we should remove the child from the parent's fork queue. (But this leaves use with some questions especially regarding cancellation, if a join is cancelled shoudl we re-add the child to the fork queue).\n\nI don't know, how comes your last code snippet is capable of catching the error?\n\nI dont think it'll work; the error form the forked task should abort the parent as well\n. @slorber I don't recommend using the done promise inside Sagas as it can lead to subtle race conditions. \nYou may need to use the join effect which catches the task termination synchronously. \njs\nyield forkedTasks.map(join);\nWhen I was implementing the new fork model, join was trivially implemented on top of .done but this caused me a lot of problems as the promise didn't notify the termination until the next microtask (I susped you were experiencing the same type of issue). That's why I implemented join on top of simple continuations (callbacks).\nThe main reason I left the done promise  in the lib is to be used by external functions (outside of Sagas).\n\nSo, when using forked tasks, is there a way for the parent to catch a child error? And eventually decide weither or not to kill the whole tasks tree?\n\nThe short answer is no. But I think your case makes perfect sense. The main reason for a parent being unable to catch errors from child tasks it that both evolve in parallel. But if at a moment a parent joined a child task, I think it makes sense at this point to let the parent catch the child error (since it's now blocked/synchronized with its child). \nso I think what we should do in this case is that when a parent joins a forked task, we should remove the child from the parent's fork queue. (But this leaves use with some questions especially regarding cancellation, if a join is cancelled shoudl we re-add the child to the fork queue).\n\nI don't know, how comes your last code snippet is capable of catching the error?\n\nI dont think it'll work; the error form the forked task should abort the parent as well\n. You can wrap your forks with the desired Error handler\n``` js\n// Wrap forks with an Error handler\nfunction* wrap(fn, args) {\n  try {\n    yield call(fn, ...args)\n  }\n  catch (e) {\n    yield put(displayError());\n    throw e;\n  }\n}\n// a custom Effect creator for it\nconst forkWithErrHandler = (fn, ...args) => fork(wrap, fn, args)\nfunction* saga() {\n  //const forkedTasks = [...];\n// To fork a new task instead of yield fork(fn, ...args) use the wrapper\n  yield forkWithErrHandler(fn, ...args)\n// yield forkedTasks.map(join);\n  // You don't have to wait for forked tasks, saga will terminate when all forked tasks terminate\n}\n```\n. You can wrap your forks with the desired Error handler\n``` js\n// Wrap forks with an Error handler\nfunction* wrap(fn, args) {\n  try {\n    yield call(fn, ...args)\n  }\n  catch (e) {\n    yield put(displayError());\n    throw e;\n  }\n}\n// a custom Effect creator for it\nconst forkWithErrHandler = (fn, ...args) => fork(wrap, fn, args)\nfunction* saga() {\n  //const forkedTasks = [...];\n// To fork a new task instead of yield fork(fn, ...args) use the wrapper\n  yield forkWithErrHandler(fn, ...args)\n// yield forkedTasks.map(join);\n  // You don't have to wait for forked tasks, saga will terminate when all forked tasks terminate\n}\n```\n. closing this. I think more finer-grained error control is needed. will use #570 for tracking this. closing this. I think more finer-grained error control is needed. will use #570 for tracking this. Could you try with the new release? I think the issue is resolved\n. closing this. will reopen if the issue isn't resolved yet. closing this. will reopen if the issue isn't resolved yet. > It seems the race effect guarantees a single winner, even if more than one channel has a message. The messages from the losers are dropped.\nEffectively race by design will cancel all losers. Could you explain what's the expected behavior here? If you can setup a runnable gist/jsbin... that would be helpful.\n. > It seems the race effect guarantees a single winner, even if more than one channel has a message. The messages from the losers are dropped.\nEffectively race by design will cancel all losers. Could you explain what's the expected behavior here? If you can setup a runnable gist/jsbin... that would be helpful.\n. @3LOK I don't really have a strong opinion against bypassing reducers. Perhaps many Redux users will find this shocking, but I've seen this quite often in FRP examples (RxJS, Bacon) where we produce a stream of update functions which get merged and applied to some central state (Maybe because in those systems there is no explicit concept of action).\nBut I think this is beyond the scope of redux-saga as a middleware. Even If we want we can't actually because there is no way for a middleware to change state in the store; In fact, the only way to change state in Redux is through dispatching actions to reducers. But then you can implement this by yourself by dispatching a specific action 'CHANGE_STATE' which will be handled by a generic reducer\n``` js\nfunction genericReducer(state, action) {\n  return action.updateFn(state)\n}\n// make an Effect creator\nconst changeState = updateFn => put({ type: 'UPDATE_STATE', updateFn })\nfunction* saga() {\n  yield changeState(state => ...)\n}\n```\nBut I think the issues raised by @slorber remains pertinent.  Sagas are fundamentally Event driven; and the advantage of dispatching actions is that an action can be handled by other Sagas.\nIt may be not obvious because as @slorber mentioned, in your application you [may] have so many bounded contexts (logic that is local to a specific component). \nThe main benefit of Redux (and Flux solutions in general) is to externalize some global piece of logic: I mean some piece of state used by multiple UI components and also can be updated as a  side effect of many local updates (The Facebook Chat example is a good illustration). So if in your applications you dont have much of this global logic the Redux architecture (actions/reducers) may seem an unnecessary overhead to use for all local state updates.\n. @3LOK I don't really have a strong opinion against bypassing reducers. Perhaps many Redux users will find this shocking, but I've seen this quite often in FRP examples (RxJS, Bacon) where we produce a stream of update functions which get merged and applied to some central state (Maybe because in those systems there is no explicit concept of action).\nBut I think this is beyond the scope of redux-saga as a middleware. Even If we want we can't actually because there is no way for a middleware to change state in the store; In fact, the only way to change state in Redux is through dispatching actions to reducers. But then you can implement this by yourself by dispatching a specific action 'CHANGE_STATE' which will be handled by a generic reducer\n``` js\nfunction genericReducer(state, action) {\n  return action.updateFn(state)\n}\n// make an Effect creator\nconst changeState = updateFn => put({ type: 'UPDATE_STATE', updateFn })\nfunction* saga() {\n  yield changeState(state => ...)\n}\n```\nBut I think the issues raised by @slorber remains pertinent.  Sagas are fundamentally Event driven; and the advantage of dispatching actions is that an action can be handled by other Sagas.\nIt may be not obvious because as @slorber mentioned, in your application you [may] have so many bounded contexts (logic that is local to a specific component). \nThe main benefit of Redux (and Flux solutions in general) is to externalize some global piece of logic: I mean some piece of state used by multiple UI components and also can be updated as a  side effect of many local updates (The Facebook Chat example is a good illustration). So if in your applications you dont have much of this global logic the Redux architecture (actions/reducers) may seem an unnecessary overhead to use for all local state updates.\n. > Events for other sagas/plugins - I agree - I'll be honest that this point is making me reconsider my solution. Let me think about this :) I might design a special structure of events that you can explicitly define how they need to change the state.\nYou may want to take a look at this article\nUsing React (-Native) with Redux and Redux-Saga. A new proposal?\nIf you abstract away firing actions whose specific purpose is to update the state, and replace them by updating the state directly (by dispatching instead functions which will update the state) you may find the purpose similar to you proposal.\n. > Events for other sagas/plugins - I agree - I'll be honest that this point is making me reconsider my solution. Let me think about this :) I might design a special structure of events that you can explicitly define how they need to change the state.\nYou may want to take a look at this article\nUsing React (-Native) with Redux and Redux-Saga. A new proposal?\nIf you abstract away firing actions whose specific purpose is to update the state, and replace them by updating the state directly (by dispatching instead functions which will update the state) you may find the purpose similar to you proposal.\n. Yeah it makes sense if the effect is non blocking.\nOTOH, what could be the alternative path for an app (other than crashing)? \n. @michaelgilley should we consider this fixed by #567?\n. @michaelgilley should we consider this fixed by #567?\n. thanks\n. thanks\n. thanks\n. thanks\n. Planned for this weekend (hopefully)\n. Planned for this weekend (hopefully)\n. done!\nhttps://github.com/yelouafi/redux-saga/releases/tag/v0.12.0\n. done!\nhttps://github.com/yelouafi/redux-saga/releases/tag/v0.12.0\n. closing as the question seems to be resolved on SO. Personally I would just use a plain component or an HOC otherwise. . closing as the question seems to be resolved on SO. Personally I would just use a plain component or an HOC otherwise. . As @Andarist noted, this seems out of the scope of the library. Could you motivate why this shouldn't be allowed? \n. As @Andarist noted, this seems out of the scope of the library. Could you motivate why this shouldn't be allowed? \n. thanks!\n. thanks!\n. It makes sense as the put effect is non blocking. A couple of remarks.\nWe could make the handling more consistent. Right now the put effect can be either blocking (using put.sync(...)) or non blocking (the default, using put(...)). So what I propose is\n- If the put is non-blocking (sync == false) then we do not bubble the error, just log it as in the PR.\n- If the put is blocking (sync == true) then keep the actual behavior.\nFor logging, I noticed that logging error.stack gives better error logging in console.chrome. Relying on console.error (invoked by log('error', ...)) doesn't show where the error exactly occured (in this example inside the checkoutStatus reducer of the shopping cart example)\n\nlogging error.stack explicitly shows the orignial stack of the error\n\n. > This behavior should be documented\nWould you like to add docs as part of this PR ?\n\nput.sync should be added to the documentation\n\nYeah! forgot it \ud83d\ude05\n\nLogging is inconsistent and at times unhelpful (as you pointed out here). I vote we make error reporting more robust.\n\nYou're right. Do you have any other suggestions to improve error reporting ? (you can open a separate issue for this)\n. > This behavior should be documented\nWould you like to add docs as part of this PR ?\n\nput.sync should be added to the documentation\n\nYeah! forgot it \ud83d\ude05\n\nLogging is inconsistent and at times unhelpful (as you pointed out here). I vote we make error reporting more robust.\n\nYou're right. Do you have any other suggestions to improve error reporting ? (you can open a separate issue for this)\n. Looks fine. Thanks!\n. Looks fine. Thanks!\n. closing this as it seems more related to react-router. closing this as it seems more related to react-router. > It's easy for example to send an event:\n\nOnly to the parent (ie the forker saga)\nOnly to the childs (ie the forked sagas) (or a subset)\nBy \"replying\" to an incoming event (ie you don't have to know who emitted the event to reply to it)\n\nYou can get a somewhat similar thing using channels. Like in CSP, processes do not interact directly via direct references but through channels. A parent can create a channel and pass it to the child, sending a message only to that child will be done by putting the message on that channel. You can also share a channel between multiple children (cf channels section, Using channels to communicate between Sagas shows how to implement load balancing between different tasks using a shared channel).\nPerhaps this makes redux-saga an hybrid between actors (do not block on sending messages) and csp (uses channels to communicate), but I dont know if channels have being used before with actors\n\nbut there's also another aspect that Redux-saga does not have that actually would be really helpful: fault tolerance and supervision strategy.\n\nCan't we handle that with just some higher order Saga. For example, a simple retry saga can be implemented like\n``` js\nfunction* retrySaga(saga, args, maxTimes) {\n  for(let i = 0; i < maxTimes; i++) {\n    try {\n      yield call(saga, ...args)\n      return\n    } catch(err) {\n      continue\n    }\n  }\n}\nconst retry = (saga, args, maxTimes) => fork(retrySaga, [saga, args, maxTimes])\nfunction* saga() {\n   yield retry(takeEvery, ['ACTION'], 5)\n   ...\n}\n```\n. > It's easy for example to send an event:\n\nOnly to the parent (ie the forker saga)\nOnly to the childs (ie the forked sagas) (or a subset)\nBy \"replying\" to an incoming event (ie you don't have to know who emitted the event to reply to it)\n\nYou can get a somewhat similar thing using channels. Like in CSP, processes do not interact directly via direct references but through channels. A parent can create a channel and pass it to the child, sending a message only to that child will be done by putting the message on that channel. You can also share a channel between multiple children (cf channels section, Using channels to communicate between Sagas shows how to implement load balancing between different tasks using a shared channel).\nPerhaps this makes redux-saga an hybrid between actors (do not block on sending messages) and csp (uses channels to communicate), but I dont know if channels have being used before with actors\n\nbut there's also another aspect that Redux-saga does not have that actually would be really helpful: fault tolerance and supervision strategy.\n\nCan't we handle that with just some higher order Saga. For example, a simple retry saga can be implemented like\n``` js\nfunction* retrySaga(saga, args, maxTimes) {\n  for(let i = 0; i < maxTimes; i++) {\n    try {\n      yield call(saga, ...args)\n      return\n    } catch(err) {\n      continue\n    }\n  }\n}\nconst retry = (saga, args, maxTimes) => fork(retrySaga, [saga, args, maxTimes])\nfunction* saga() {\n   yield retry(takeEvery, ['ACTION'], 5)\n   ...\n}\n```\n. Do you think we should add some configurable helper for this? Or as an option to existing helpers?\n. Do you think we should add some configurable helper for this? Or as an option to existing helpers?\n. > not sure what you mean by configurable helper :) \nDidn't have something precise in mind, could be\njs\nyield forkWithErrHandler(fn, args, handler)\nyield forkRetry()\nyield forkIgnore()\n...\n\nwon't it be the same problem as with takeEvery/takeLatest and require a complex implementation to avoid using generators?\n\nDont think so; they are basically state machines. Most of the work is alerady done by the fsmIterator function. So it'd be just specifying state transitions (eg see the throttle helper)\n. > not sure what you mean by configurable helper :) \nDidn't have something precise in mind, could be\njs\nyield forkWithErrHandler(fn, args, handler)\nyield forkRetry()\nyield forkIgnore()\n...\n\nwon't it be the same problem as with takeEvery/takeLatest and require a complex implementation to avoid using generators?\n\nDont think so; they are basically state machines. Most of the work is alerady done by the fsmIterator function. So it'd be just specifying state transitions (eg see the throttle helper)\n. > And now because of this - '@@redux-saga/HELPER': true its gonna be interpreted by the redux-saga in the special way:\n\n: is.helper(effect) ? runForkEffect(wrapHelper(effect), effectId, currCb)\nSo effectively in real saga the task descriptor is going to be injected into the saga, and not an iterator.\n\nI'm thinking if we may use a declarative form for the helpers as well. This way we can test them the same way we test other effects.\ncould be something like\n``` js\n// helper\nfunction* takeEveryHelper (pattern, worker) { ... }\n//effect creator: exposed to the user\nconst takeEvery = (pattern, worker) => fork(takeEveryHelper, pattern, worker)\n```\n. > And now because of this - '@@redux-saga/HELPER': true its gonna be interpreted by the redux-saga in the special way:\n\n: is.helper(effect) ? runForkEffect(wrapHelper(effect), effectId, currCb)\nSo effectively in real saga the task descriptor is going to be injected into the saga, and not an iterator.\n\nI'm thinking if we may use a declarative form for the helpers as well. This way we can test them the same way we test other effects.\ncould be something like\n``` js\n// helper\nfunction* takeEveryHelper (pattern, worker) { ... }\n//effect creator: exposed to the user\nconst takeEvery = (pattern, worker) => fork(takeEveryHelper, pattern, worker)\n```\n. @michaelgilley yes. I dont see any reason to keep the iterator approach. \n. @michaelgilley yes. I dont see any reason to keep the iterator approach. \n. thanks!\n. thanks!\n. cf #586. if implemented, could possibly make testing this possible without mocks\n. I meant that we could get control over precise resolution order of the delay calls (by using promises we resolve in a specific order) and forks (to inspect that the helper throttle forked tasks). I had perviously this kind of randomness (see #109) due to repeated accumulation of timeouts\n. Thanks for the fix. Seems ok to me.\nZalgo keeps resurging :)\n. >That being said I dont yet what to think about those interceptors. First of all - would be nice to find use case for them outside of testings, cause I generally dont like adding the code just for testings purposes,\n@Andarist I think a more general perspective of the proposal could be someting similar to Aspect Oriented Programming in the sense it can allow isolating cross cutting concerns (logging, persistence ...). Although didn't think in detail how this could be benefited from in the context of a React/Redux application. Also Error handling itself could be seen as a cross cutting concern. thanks\n. Besides making testing helpers more trivial. This seems to make the code simpler (getting rid of helper related functions). I think this also would reduces confusion around helpers vs effects, yield* vs yield...\nBut as this will be a breaking change (yield* will no longer work) I think we should let the old exports from the helpers module with a deprecation warning for at least one minor version before removing it.\n. looks fine to me. also generator.next().value instead of generator.next()\n. done\n. Didn't have time to look at this but the scheduler (asap) needs to be fixed (cf #413). Actually i use the asap helper to delay running put effects until the saga executing puts become 'stable' (ie ready to take, also cf #235 for some bg). But I think the issue is that the flush method actually doesn't handle nested queues correctly.\n. I vote for documenting the behavior. We could introduce a guard in the take implementation but I think this would the implementation of channels unnecessary complicated.\n. I had so bad experiences with async in redux-saga that I dropped Promises completely from the internals and did everything synchronously (even ending with a more complex impl.). TL/DR; promise scheduling of  then callbacks cause multiple and subtle race conditions. This is not the fault of promises themselves, it's just by mixing  async scheduling (promises) with sync (callbacks) we open the door to a whole class of subtle and weird bugs.\nspeaking of the case of channels. suppose for example we make take for channels perform async (via promises)\njs\nfunction* saga() {\n   yield take(channel)\n   yield take('ACTION')\n}\nIf someone else (a component, or another Saga) puts in the channel, and this caused another one synchronously putting a Redux action. The saga won't be able to take the second action because the first take will execute in a promise microtask (ie after the Redux action was dispatched) so it'll miss the action in between. The same reasoning can be applied to put(channel) being made async. \nBTW this was one of the big issues of the early versions of redux-saga (cf https://github.com/yelouafi/redux-saga/releases/tag/v0.6.0)\n. should we make the logging opt-in?. > Should I close PR #602 ?\nYes the test is already included in this PR (thanks to it the #598 case was greatly simplified)\n. I marked this as a bug. I'll try to 'fix' the scheduler to make it handle this case (maybe possible). Otherwise we have to document this case and possible workarounds. but I prefer to delay the 2nd solution until we make sure this can't be fixed in the scheduler.. >Solution 1: wrapped fork and spawn\nHandling errors with done.catch wont prevent errors from bubbling. done.catch is meant only to be used outside of Sagas (eg monitors, root sagas). But in your case since put is already swallowing the error, no error is reported to the promise\nTo prevent aborted forks from killing the entire tree use call\njs\nfunction* forkSafely(saga, ...args) {\n   try {\n     yield call(saga, ...args);\n  } catch (err) {\n    console.log('Exception caught inside forkSafely', e);\n  }\n}\nBut that wont also work with the current (weird) put behavior, because the error is swallowed (but will work with put.sync)\n\nput is async (non-blocking), and it always returns ASAP without exceptions.\n\nActually not quite true. put will report the result of the dispatch (here). The difference with put.sync is that the latter will wait if the result is a promise.\n\nif put is non-blocking, it should return a task\nexceptions fired by put should be able to be caught\n\nI agree, the error reporting behavior of (non sync) puts  doesn't look quite right when I look at it right now (In fact very weird). It seems all correct for me to bubble the error also for normal puts (ie non sync) since we have this info before resuming the Saga. \n\nwhat's caught locally (both sync and async way), if there's no re-throw:\n  should be treated as handled\n should not bubble up to the root\n\nI think that's the actual behavior (besides the weird put 'bug'). Except for fork && spawn, because I think the functions should still return a task to the caller (even aborted task)\n\nif a custom global handler is specified, no default logging should be done\n\nHmm... not sure about this. onError was introduced as a kind of post-mortem handler. That being said, I'm open to hear opinions about the desired behavior of a global error handler; for example should the global handler prevents fork errors from bubbling && killing the parent tree?\n. @Andarist Yeah! but that was the other me :). \nMore seriously, in #567 the idea was that 'put is non blocking so we shouldn't bubble errors'. But then, as @banderror noted we should return a task in this case, otherwise there is no way to catch errors from it. But again if we return a task, then errors will fail the entire tree just as fork/spawn do actually.\nI think we shouldn't treat put as a non blocking effect (ie I think I was wrong on #567). In the actual code, put will wait (even sync) for the return value from dispatch, in fact seems like put.sync is a misleading name, because all the difference vs put alone is that the former resolve promise responses. maybe put.resolve could be a better name. I think it's needed because of this line in package.json which requires babel-register from the npm command line\njs\n\"scripts\": {\n   ...\n   \"real-world\": \"npm --prefix examples/real-world install examples/real-world && cross-env BABEL_ENV=cjs node --require babel-register examples/real-world/server.js\",\n   ...\n  },\nIt permits running the real-world example directly from the main repo (auto install deps && not having to cd examples/real-world && npm start). \nInitially I thought it was fine to provide users with scripts in the main package.json to directly start examples from the main repo folder. But I think now this is not a so good idea, we pollute the scripts section of the main package with too many demo related scripts (npm run counter, npm test counter, ...).\nWe can accept this PR as a fix for the current solution. But I think we should migrate all examples to have their own package/build config using eg. create-react-app like it's done actually in the redux repo.\n. @granmoe a drawback of using spawn is that it doesnt propgate cancellation down. not a prob. for top watchers but can be for watchers located in mid-hierarchy.\nas I said to @Andarist spawn is the opposite extreme  to fork. The issue is essentially related to 2 params: error bubbling and cancellation propagation. Actually there is no api for more fine tunning of the 2 behaviors and thus possibly the core issue is here: need for a gradual top down tunning of fork errors starting with a global onError and more specific/per case config (we could also add config options to takeXXXX helpers).\nfor the auto retry behavior I assume we are referring here to watchers only. Because we can also fork non watchers and I dont think it makes sense to always restart a worker saga. in the latter case I guess this is what @aikoven meant when he said the restarting is a internal concern to the worker saga (possibly combined with a ui dialog)\nAlso the setTimeout in the example could potentially have some race condition issues. It's unlikely that an async request could return before the timeout but not impossible if I'm not mistaken (cached response, sevice worker).\nregarding sync/async distinction I tend also to make the distinction but with diff. terms expected/unexpected (or business errors/bugs). for the 2nd type I agree that it doesnt make sense to catch them b/c the program is already in an unexpected state. but I'm not sure what other alternative could be used in place of simply halting all the things (possibly after executing some post mortem onError handler) because the program could be in an inconsistent state.. as @HansDP commented, you can export the sagaMiddleware.run function. There is also the runSaga which offers more control on running and connecting sagas dynamically.. looks better to me. Thanks. thank :). thanks. of course :) thanks.. I saw that the submitted code use type annotations. redux-saga is actually written in ES6, typings for other languages (like flow and typescript) are provided spearately. the Typescript defs for are provided in the *.ts files in this repo.. @pbadenski oops! sorry I was reviewing the index.d.ts file without noticing.  Just ignore my previous comment.. I think using runSaga wont be much convenient. it's mainly intended to connect to non redux envs (eg other flux libs, angular). beside you'd have to write another middleware/enhancer to hookup redux actions.\nI'd favour the 2nd option (only provide the emit). maybe we should find a more apprpriate name since the option can have other uses (like filtering out some actions).\n@pbadenski for the motivating use case of batched actions. If I'm not mistaken you have to solve the same issue for every other middleware: logger, devtool ...?. I feel like the contract of emit is broken into 2 pieces: \n1-the custom emit dispatches an array or null/undefined\n2- the builtin emit interprets the array/null or undefined\nI don't feel much putting the constraint on the builtin emit to interpret the passed result. IMO, could be better if the custom emit receives the builtin emit as parameter and decides itself fully on how to interpret the action.\nBesides avoiding the breaking change it could also make the custom emit more flexible, (eg could potentially allow async transformations)\n. dont know, processAction, mapAction looks more appropriate to me. As here we're not really emitting actions but just transforming the stream of actions already dispatched. yeah that's right, but I used map because we're like in the middle of a chain where we forward dispatched actions to sagas. API suggestion: make the option a higher order function, which takes the builtin emitter and returns another emitter. For example\njs\ncreateSagaMiddleware({\n  [whatevername](emitter) {\n    return action => {\n      if(action == null) return // do nothing\n      else if(Array.isArray(action) ...\n      else emitter(action)\n    }\n  }\n}\nIn the middleware code then, the default option will be just the identity function\njs\nconst sagaEmitter = (options.[whatevername] || identity)(emitter)\nThis way we don't impose any superfluous semantics on the builtin emitter (ie interpreting array or null actions). All interpretation can be done on user land by the custom emitter\n. @henrikra for the test to pass you have to pass back some mock action to the generator on the next iteration (the result of the first yield). Otherwise the generator resumes with undefined i.e. gives while(undefined) which breaks the loop and terminates the generator. I'd opt for onError but that's just my personal bias (perhaps bc of my java background). >I was wondering where to put the test - I would lean towards changing its location to test/proc/takeSync.js + exporting storeLike from test/runSaga.js and then DRY both tests (the one which got fixed by scheduler changes), as they are exactly the same, just one using standard store and one storeLike\nProbably better to isolate the test in a separate file: i.e. exports (from the test file) a function which takes a store object with methods necessary to run the test { subscribe, dispatch, runSaga }. The test function could then be imported from both takeSync and runSaga which can run the tests by providing the store object.\n\nalso I was wondering where to put scheduling now, should it be handled in stdChannel's subscribe like now or should maybe it be handled in eventChannel\n\nMy approach to scheduling until now was to handle issue (i.e. edge cases) as they surface. So progressively we gain better understanding of the whole scheduling problem. So I'd let the scheduling in stdchannel for now\n\nI think the latter would only fix rly far fetched scenarios, cause its technically possible to reference store.dispatch inside eventChannel's listener, but that could be said about pretty everything, as there is always a possibility for developer to shoot himself in the foot\n\nI think it's unlikely to happen (although not impossible) because eventChannel is typically used to interface external events like websockets. \nThe scheduling issue appears [only] when there are synchronous effects called inside within the stack frame of others. All external events (browser, websockets) are dispatched in separate event queues (i.e. after the current stack is exhausted). And in edge cases of eventChannel dispatching events synchronously (eg app specific events) I think the scheduling issues can be easily avoided by using Promise.resolve().then(() => emit()) which should give the developer a more predictable order of events.\n\nlooking on runSaga API it was really confusing for me that it behaved pretty much like store, but not exactly. Real store's subscriber function is not receiving any arguments, its just notified about the change, but nothing more. Dont you think it's a slight problem? Maybe the difference should at least be expressed better in the docs?\n\nNot sure to understand what you mean. runSaga's subscribe argument is different from store's subscribe. We need the input argument in order to fullfill take effects, in the middleware we get this from the middleware's action argument.. seems good to me.. Good catch on the cancel issue, didn't thought of it. This seems ok to me. \nOTOH [thinking out loud] this could be also done with actionChannel + custom buffer. . dont have a precise idea, but basically smth like\njs\n// simple scheduler\nfunction delayScheduler(delay) {\n  return put => item => {\n    setTimeout(() => put(item), delay )\n  }\n}\nconst chan = channel(buffer, scheduler)\nAnother option could be to implement an observableChannel which could get events from an Rx like observable. Since Observables are really great to handle time based transformations. see https://github.com/yelouafi/redux-saga/issues/70#issuecomment-182545609. Oops! sorry for this mess.\nActually it's the channel export which should be exposed. let me explain\nThe channel's END is used to resolve takes from closed channels (call to channel.take). In proc, the END is interpreted depending on the maybe flag of take effect (takem creates a take effect with maybe = true). \nby default by receiving END, proc will terminate the generator this is done by resolving the take with a special value CHANNEL_END (cf https://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L412). this value is interpreted by next (cf https://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L247-L250).\nif maybe=true (using takem) then the dev. is willing to trap the END and handles it by himeself, in this case the take will be resolved with the (channel's) END. In the saga devtools we check for it in order to show a custom display (instead of the default {type: CHANNEL_END_TYPE})\nCHANNEL_END is internal to proc (can't remember why it's exported, perhaps for possible usage in tests although I think it's not used there).. >couldnt proc's CHANNEL_END just be imported from the ./channel? Is there need for both?\nNo, because in proc next function couldn't interpret the END as either terminating the generator or resolving the effect. looks much better. @kopax As a temporary workaround You can filter out that error by passing a custom logger to the middleware\n```js\nfunction myLogger(level, message, error = '') {\n // ignore error\n  if(error === 'Generator is already running' ) return\n/eslint-disable no-console/\n  if(typeof window === 'undefined') {\n    console.log(redux-saga ${level}: ${message}\\n${(error && error.stack) || error})\n  } else {\n    consolelevel\n  }\n}\n// in your middleware setup code\nconst sagaMiddleware = createSagaMiddleware({ logger: myLogger })\n```\n@Andarist \nI was able to get the same error executing the following code in Chrome's console \n```js\nvar g\nfunction* gen() { \n  yield 1 \n  console.log(g) // print the status of the generator\n  doSomeCrazyStuff()\n  yield 2\n}\nfunction doSomeCrazyStuff() {\n  g.next()\n}\ng = gen()\ng.next()\ng.next()\n``\nyou'll see the status of the generator isrunning: the code tries to callnextwhile there is already anext` in progress. \nIt could be due to some subtle race conditions (it could be also a V8  bug like this one)\n. @Andarist Perhaps we should decouple stdChannel totally from channel as they seem to be completely different things: \n\none is unbuffered, multicast (dispatch to all subscribers), event pubsub (ie with matchers)\nwhile the other can be buffered, unicast (dispatch to one taker using FIFO rule), and matchers just dont make sense (as we encountered in a previous issue IIRC).\n\nIt seems like continuing the 'OOP' way (treating stdChannel as an extension of channel) is going to impose superfluous complications to the channel interface.. agree; it's more consistent. Seems like the concept dynamic scoping. I think it could be helpful for things like dep. injection.\nThis could be implemented using prototype chaining of JS objects. We can pass an additional arg to proc which is the parent context (context of the caller/forker saga), then we create the actual context using Object.create(parentContext). This way getContext/setContext could be implemented using simple JS object property access (a question is should getContext throw if the var. can't be resolved)\n. I like it! \nthanks @karland . Dont know. Personally I'd prefer to have separate values for the 2 since each one has its own role. Yeah, it's better to avoid confusion. We can also adopt an explicit naming convention for termination values: SAGA_TERMINATION_CANCELLED, SAGA_TERMINATION_CHANNEL_END .... >or maybe SAGA_TERMINATION with reason field? would probably come handy for tracking cancellations\nI'd prefer to separate type info from payload info. Perhaps we could use smth like the Effect siganature\njs\n{ [SAGA_TERMINATION]: CANCEL, reason }\n{ [SAGA_TERMINATION]: CHANNEL_END }\n...\nIn the earlier versions of redux-saga (when cancellations were modeled as special type of Errors) the reason info was stored in the message field on the Error class. After redux-saga switched to Cancellation as a third state, the reason info was discarded (also no one has reclaimed it). [SAGA_TERMINATION] indicates the type of completion, because in proc#next we handle each type differently. >es, but still with mentioned example ({ [SAGA_TERMINATION]: CANCEL, reason }) im not sure if there is a purpose of both value of [SAGA_TERMINATION] field (here CANCEL) + the reason field.\nAh, perhaps I didn't understand properly what you meant by \n\nor maybe SAGA_TERMINATION with reason field? would probably come handy for tracking cancellations\n\nI thought you're talking about having additional infos about the origins of cancellations (manual, automatic in race or parallel). Perhaps a simpler option: place a yield before the call to buffer creation, and resolve the 'yielded' argument with a mock buffer. At runtime the code still works because redux-saga will just return the yielded value back to the generator (same for all non effects/iterator/promise values)\njs\nexport function * processServerActions () {\n  const queuedActions = yield actionChannel(PROCESS_ACTIONS,  yield buffers.expanding()) \n  while (true) {\n    const nextActions = yield take(queuedActions)\n    //...some logic....//\n  }\n}\n```js\nit('all actions are processed', () => {\n  const processServerActionsSaga = processServerActions();\nconst mockedChannel = channel();\n  const mockBuffer = buffers.expanding()\n// will return result of buffer.expanding()\n  processServerActionsSaga.next().value \nexpect(\n    // resolve the yield with the mockBuffer\n    processServerActionsSaga.next(mockBuffer).value\n  ).to.deep.equal(\n    actionChannel(PROCESS_ACTIONS, mockBuffer)\n  );\nexpect(\n    processServerActionsSaga.next(mockedChannel).value\n  ).to.deep.equal(\n    take(mockedChannel)\n  );\n});\n```\n. @Andarist @eloytoro  if we dont interpret combinators then race should be excluded as well?\nAlso I think the signature doesn't allow resolving effects asynchronously, I know this is mainly for testing purpose, but in integration tests it could be useful to test race conditions.\nAnother thing is I think this PR is closely related to #586 (Effect interceptors proposal). And we could perhaps think of a more generic API which allows chaining interpreters. What follows is just a braindump and would like to have your feedback.\nWhat if we make a redux-like middleware api:\njs\nrunSaga(mySaga(), {\n  ...,\n  middleware: (next) => (effect, cb) => {\n    if (isEqual(effect, call(serverRequest)) {\n      return cb('mocked value')\n    }\n    // forward to the next interpreter\n    next(effect);\n  }\n});\nmultiple middlewares could be chained together, and also things like logging, monitoring, custom error handling could [possibly] be implemented as simple middleware.\nThe downside of using a callback is that we can't capture the moment after the effect execution. Perhaps using generators as middleware (koa style) can solve this. > I made some progress doing what youre asking using co and other fancy middleware composition stuff\nI think using a 3rd party lib like co would add much size overhead. Anyway, we can in a first time use the simple callback api in my previous example to get this PR merged (would be sufficient to enable integration testing). We can then have another PR to discuss further a generator based API\n@Andarist If i'm not mistaken, the same argument applies to parallel effects, no?\n. >Maybe we should have parallel([...effects]) too and deprecate yielding arrays?\nHmm.. dont know, seems like a 'significant change' (regarding the number of LOCs likely using the yield [...]  form in real code). >But it would give more explicitness for this effect, which is in my opinion better in most cases. Implicitness causes confusion.\nFair point. Another  argument is an explicit effect could support object keys like race.\njs\n  // or whatever name it gets\n  yield all({\n    prop1: call(...),\n    prop2: take(...)\n  }). I think the issue here is still unresolved. . probably join(...task) is more flexible as it can handle all iterables, not just arrays. OTOH join(Array) is more convenient when you have your tasks stored in a an array. But we could also get both feature by allowing a signature like join(Iterable), like Promise.all for example. >it also seems reasonable to support cancel(...tasks)\nI agree. We could delay subscription until the first take (using a custom channel instead of eventChannel). I think this makes more sense since most of the observables are lazy (cold). And for the case of eager (hot) observables I dont think it makes a difference (unless we introduce buffering, but I dont think we need to support buffering for those channels since observables have more powerful support for that). >also maybe we could implement $$observable on the middleware so put actions can be observed?\nwould be useful. >in the sense with my PR runSagaDynamically is becoming a partially applied runSaga, so it could be made more obvious here and partial utility could be written and used here to prefill runSaga's 2nd parameter - store interface\nWouldn't be better to flip the 1st and 2nd param\njs\nrunSaga({dispatch, getState, subscribe}, saga, arg1, arg2)\nThe argument behind this is that one will likely setup options only once and run sagas more often\n. I dont mind adding this in principle. But, like @aikoven, I suspect there could be a more basic solution behind this. For example if we have some effect catch (or wait if it'd return also cancelled outcomes) that that would act like safeCall but for all effects. Then we could implement settle on top of it as a helper effect.. catch would trap errors and return an explicit object {result, isError}. . Example, suppose this code throws some NetworkError object\njs\ntry {\n  const res = yield call(fetch, data)\n} catch (err) {\n  ...\n}\nUsing catch, instead of throwing in the generator we return an explicit result\njs\n  const {result, isError} = yield katch(call(fetch, data))// or call(fetch, data).catch()\n. >then in fact settle would become something like yield effects.map(catch)\nExact. We could also make the effect trap all completion values not just errors (cancellations, channel ending). In fact, if we use the method version yield effect(...).catch(). We could implement it just by setting a catch: true flag on the effect, then each effect runner would handle the flag by decorating the result appropriately  (like setting isError to true) and resuming the generator normally. >Hm, aint sure though if that would be helpful to people and also what I as a user would expect from it. \nFor blocking effects, there is no need since there no way to cancel manually for example a call effect from outside. So the user is not required to check other values (eg isCancel). For take effects, it'd play the same rule as takem effect (trapping channel ends).\nIn effects like join(task). If the task is cancelled then the join effect will propagate cancellation to the calling saga. With catch, we could avoid that. . >this would require all effects to expose .catch() method. Which ofc could be easily done here, but we'd lose serialization of the effects then\nHow so? if we create Effects based on a custom prototype (or a simple class) I think it'll be ok. >For example simple objects (POJOs \ud83d\ude06) can be transferred through postMessage interface, but ofc function references cant be transferred between such contexts.\nIf I'm not mistaken, serialization doesn't include fields from base prototypes, only own fields. In fact, serialization even excludes own field functions. Like @slorber I dont have experience with code-splitting so mostly astronaute thoughts :)\nOne way to view spawn vs fork is like manual/automatic memory management (or any other 'system' resource). for each manual start, there should be also a corresponding cancel, and that means also the burden of manually propagating cancellation down.\nregarding splitting, If  a task attached to a route/container is started manually (using sagaMiddleware.run), then the task should be cancelled also manually.\nfor example in React, starting in componentWillmount and cancelling in componentWillUnmount would ensure cancellation is propagated automatically through React lifecycle hooks (assuming splitting is based on routes/containers). for the rest (sagas started withing this route, IMO only fork should be used here unless exceptional situation).\nOne thing that perhaps surprise about fork is the error propagation behavior, but this could be simply handled by wrapping the forked task in a HO task which calls the original task in a try/catch block (could even use an effect helper for that)\n. >Hm, it kinda boils down to proper error handling all over the place, the problem is that the language is not enforcing it in anyway and people tend to get a little bit paranoid. And as redux-saga (but also react!) is the interpreter, our code is ran by a 3rd party machinery which all is done often in the same call stack etc, so any uncaught error just destroy our app entirely.\nI agree this is confusing. Perhaps, as a convenience, we should give the global onError handler a chance to intercept the error before deciding to kill the entire tree.. >Isn't it easier to just return?\nAnother difference is that return just terminates the main task (the currently executing generator) but in order for the whole task to finish it has to wait for all its forked child tasks to terminate. see https://redux-saga.github.io/redux-saga/docs/advanced/ForkModel.html\nself cancellation actually terminate the whole task (main tasks + childs) . >wow, didnt know that difference, so many surprises yet to come for me i guess \ud83d\ude04\nIt's totally understandable, the behavior may seem unexpected at first, but it works nicely with server side rendering. Closing the store on the server (by dispatching END action) will cause all watchers to terminate the main task (watcher body), but they will still wait for all forked workers to finish (get fetch results, update the store state) before terminating. \nIn final, we render to the client after all work is done. This way we can have universal sagas, the same saga (and also reducer & React) code can work both on client and server. leaving from work right now. I'll look at this tonight, Promise :). >Also I think it would be better if internal tests didnt rely so much on such an implementation detail. After all proc is not an exposed API. WDYT?\nI think you're right. Looking at the current signature of proc it seems calls to it in all tests could be replaced with runSaga (or middleware.run). extra params (like parentEffectId, cont ..) are not actually needed in tests.\nas for the other points\n\n\nproc signature changes\n\n\nNot sure if I understood the question. But I think now proc will take a multicast channel instead of subscribe. The middleware will ofc build a global one that will get passed around to child proc calls. \nFor runSaga either we keep the api as it is (and then it should also build a multicast channel itself) or we change the API and make it take a channel as argument (or support both options). The advantage of the second is that multiple runSagas can be connected together using the same channel \n\nactionChannel's support for multicasting - extra param?\n\nI can't see how that would be useful. The point of actionChannel is to buffer actions while the saga is being blocked. If we make it multicast it means no buffering and thus it will behave the same as the global Redux channel\n\nblocking channel idea\n\nactually the example you mentioned corresponds to how CSP channels behave (put is blocking until someone takes the message or it's buffered). When I first started adding channels, my intention was to make them CSP compliant. But finally settled on a non blocking model.\nThe main reason was that blocking channels may deadlock. If 2 sagas are using the same channel as a bidirectional medium there could be a situations where the 2 will be trying to put in a full channel, thus waiting for each other to take an item to free the channel. \nAlso we can implement CSP blocking by using 2 channels: 1 to send and the other to acknowledge, and without deadlock risks. see those 2 test cases // EDIT: actually the cases are using 1 channel to simulate blokcing, but since redux-saga scheduler serializes the puts they're delivered one after another to the corresponding saga).\n\nur comment about \"unicast: buffering, no matchers\" - eventChannel still needs matcher I think, OTOH it could be achieved in userland within subscribe callback\n\nThat's right. We can rework channels spec : to support matchers we need to account of the case that we can have buffered channels AND queued takers in the same time.  But I wonder if this is worth it?. I did a quick review (so I may be missing something). from what I understand custom effect runners can only transform from a custom effect to a 'standard' one. But couldn't this be already achieved with a more direct method?\n```js\nconst customEffect = (paylaod) => put({type: 'CUSTOM', payload})\nfunction* saga() {\n  yield customEffect(payload)\n}\n```. didnt work before with Rollup, but heard about its flat bundles. and that's nice size gain.. for an example of use see\nhttps://github.com/redux-saga/redux-saga/blob/master/examples/sagaMonitor/index.js\nhttps://github.com/redux-saga/redux-saga-devtools/blob/master/src/store/createSagaMonitor.js\nEsp. root Sagas can be recognized with the field root: true during the EFFECT_TRIGGERED event.. > I have no idea how task and mainTask work in the proc\nfor example if we have this saga\n```js\nfunction* parent() {\n  yield fork(child1)\n  yield fork(child2)\n  yield call(someApi)\n}\n// inside another saga\nconst parentTask = yield fork(parent)\n```\ntask is basically the descriptor for parentTask. It will terminate after the yield call(someApi) resolves but will also wait for the 2 previously forked tasks to terminate.\nmainTask represents only the sequence of 3 yields in parent's body. It ends as soon as the yield call(someApi) resolves. I used it to track when the body of the generator has terminated. Using a task internally allows forkQueue code to be generic. I just add mainTask here\nhttps://github.com/redux-saga/redux-saga/blob/441b00959d51c2edc9efd4bdf7216d308f56344c/src/internal/proc.js#L61\nIf later attached forks are added then all tasks (mainTask + attached forks) are tracked using the same logic. The article is already mentioned above\n. IMO it's be better to write if(arguments.length > 2). because this would allow catching common typo Errors: i.e. the user provided a matcher argument but provided arg is undefined due to some typo error.\n. I understand, but in the above function there is no default value for the matcher argument. If I do the check only if matcher is not undefined, then it implies that this call form is allowed eventChannel(subscribe, buffer, undefined). I dont think there is a case where a developer will want to pass undefined intentionally (except for setting the arg to the default value, which  is not the case above since match has no default value). If we got an undefined value it's likely  because of some typo error.\n. It's a valid POV but I personally think using undefined is not a good idea for indicating no args as it can overlaps with the so common undefined Errors (maybe also my typed lang. Java/FP background). i agree with your point on the buffer arg;  I considered making it mandatory or requiring a null instead of undefined but didn't like it much from the API viewpoint. So I just settled with the no-buffer solution. Trade-offs as usual :).\n. As a side note initially the buffer argument was checked using arguments.length like match, but since the arg is used internally by the lib (to resolve the yield channel effects) I adopted the default value approach because it makes the internal client code less complicated\n. @aikoven TBH didn't thank of browser compat. But in this simple case I think we could call the 'cross-browser' version of setTimeout (without args...) \n. I think t.ok(generator.next().done, 'must finish') conveys better meaning.\n. Do you think we can borrow something from this http://survivejs.com/blog/redux-saga-interview/#redux-middlewares. Mainly, define what 'Side Effects' are in the context of Redux (async and impure calls).\n. While this is correct. There are also things that are synchronous but not pure (like saving to a browser storage, clearing a timeout ID, ...). If we define Side Effects in the first paragraph, we can simply put here that a Saga is solely responsible for Side Effects, or to reflect the opinions of the library: redux-saga proposes to 'isolate' all sorts of Side Effects (including async calls) inside Sagas.\n. Perhaps worth mentioning that Generators are part of the ES6 standard\n. Note that here we pass cb as last param to proc. It will be called once the iterator is done\n. It's not possible to test this form. Can we extract this into a separate a function like createWebSocketChannel and then call it using a declarative form yield call(createWebSocketChannel)? \n. if the buffer is empty, this callback wont be called until the next item is put into the channel. The saga will remain blocked until then\n. The whole paragraph starting from Each time belongs to takeLatest and should be removed\n. js\nconst autocompleteProposals = yield call(Api.fetchAutocomplete, action.text)\n. length shouldn't be modified because it denotes the number of items in the array not he length of the array\n. I think we should put this inside the below if(!task.cont) { block. Because here it will notify all errors not just uncaught ones; for example\n``` js\nfunction* child() {\n  const {err, res} = yield call(fetch, 'url')\n  if(err)\n   throw new Error(err)\n}\nfunction parent() {\n  try {\n    yield call(child)\n  } catch(err) {\n     // you don't want to report this one\n  }\n}\n``\n. Do we need to create a new Array here?flushalready returns a new array\n. I dont like much the default parameter here. Because it may swallow typo errors. Adding acheck(patternOrChannel, is.notUndef, ...)could provide better error detection.\n. but w've still left thepatternOrChannel = ''`. which will assign a '*' to the argument if it's undefined.\nThe actual code will transpile to \n``` js\nfunction take() {\n  var patternOrChannel = arguments.length <= 0 || arguments[0] === undefined ? '*' : arguments[0];\nif (arguments.length) {\n    check(patternOrChannel, is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined');\n  }\n}\n```\nThe default value will be assigned before our check has a chance to run\n. Imagine this scenario\n``` js\nimport module from '...'\nyield take(module.matchActionn) // typo should be matchAction\n```\nin the above example, module.matchActionn will resolve to undefined and instead of reporting the error will assign the argument a value of *. that's because default parameter will be assigned (since arguments[0] is undefined) before the check for undefined is reached.\n. oops! sorry forget my last comment. I think checking arguments[0] should be ok\n. I think we should check if error instanceof Error because dev. could throw other things (like throw \"some error message\"\n. No that's an internal function, the public one is declared at the bottom sagaMiddleware.run = (saga, ...args) = ...\n. right. I did a global style fix on the file\n. hmm... dont think so. for #598 seems the external dispatch needs to be queued as well (which is not the case actually) but I think it's more related to the asap#isSuspended state. More fundamentally IMO what we need primarily is to come up with some unambiguous semantics for scheduling before tempting any impl.\n. After some thoughtsI think you're right. I might have some solution to asap which could fix both #598 (ie #602 failing test) as well as #413.\nI'm going to merge this and try with the new scheduling idea\n. did some refactorings\n. try/finally wont swallow errors since there is no swallowing catch. It simply ensures that the scheduler is always in a consistent state; every suspend must have a corresponding flush.\n. yes I think it's redundant\n. I think that the END test is not required anymore  b/c proc will anyway terminate the generator if it detects an END (END is returned explicitly only when using takem effects ). see\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L412\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L247-L250\nI added this test when there wasn't yet automatic handling of END in proc but forgot to remove it later.. agree on the null. wouldn't be simpler to pass runSaga as argument to syncDispatchTest? it can then run sagas and tests directly. ah right! missed that. why array effects are excluded from interpretation?. why cant we just pass the parent context?. yeah but you could also view spawn as a simple child task with different behavior regarding cancellation/errors? And also with analogy to lexical scope, it gets its params from its parent task, so could be the same from dynamic scope (context). yeah, I think we should just keep join(...tasks). In case a wrong string is provided, since fn was mutated in the previous line, the message will print smth like argument undefined is not a function. perhaps better to keep the string name for more helpful messages (since it's more likely that an error could happen with string args). the long msg was introduced with breaking changes of 0.10. perhaps we could get rid of it now and just keep the short message. offtopic but could probably use is.func util here and the 1st if for the test. this is a refactoring I wanted to do long time ago.\nBTW why dynamic [type] property and not just type and payload properties ? (would also makes inspection easier in devtools) . the purpose of [IO] was to avoid name clashes as the user could yield any object so needed . I meant 3 props : \njs\n{\n  [IO]: true  //as a signature\n  type: TAKE,\n  payload: ...\n}\nthen it could be consumed like\njs\nif(obj[IO] === true) {\n  switch(obj.type) {\n    case TAKE:\n    ...\n  }\n}\nthe first test could maybe be put behind a little function isEffect(obj). ",
    "quicksnap": "I see that delay is just an example function, but put is part of the API. I'll whip up a PR to adjust the readme\n. #2 \n. Also, I'm really grateful @gaearon tweeted about this library, because it's really well done! Thanks so much. Very exciting.\n. Also, with my idea of takeDefer enabling saga middleware to return promises, we don't even need to wait for sagas to complete. We may simply render once we have received all deferred requests necessary.\n. @yelouafi Interesting! I didn't see the sagaMonitor example before. I will look into it and see if it can achieve what's needed. It sounds promising..\n. @yelouafi I've been testing out Sagas on a side project. To have server rendering work without much pain is important, as I want to make traction on the project in my spare time. Right now I've been inclined to fall back on my more familiar pattern of promise middleware combined with thunks.\nHaving to work in a solution outside of core is a drawback for me, as it increases the complexity of my project, and I am not certain yet that it will yield the benefit of lowering the overall complexity of action orchestration. It feels like it could cause more code or confusion around what's happening in either the server or client environments.\nHonestly, these thoughts are coming from my perspective of not putting in enough time/thought into this problem space. I really appreciate your examples in this thread, and I think they could work to help the problem. However, having an official way of supporting server rendering that doesn't involve separate client/server sagas is crucial to me.\nShould we create a new issue to think about best solutions to this? I really want to use sagas, and if we can work a solution that either gets into core or gracefully solves the problem, I'd be happy to put time into helping!\nThanks for your work so far on all this, it's great!\n. @pavelkornev Thanks for taking it up! I wish I could devote more time to it right now..\n. @yelouafi at first blush, I like this approach. I'll try and provide some more thoughtful feedback soon. \nThanks for putting so much effort into this! If you happen to be going to React Europe, I'll buy you a beer!\n. I love the approach here. I have one concern:\n\nThere is on drawback though: we need to render twice\n\nA general approach in server rendering with co-located data loading is that, when navigating to a specific route, we fire off data fetching. Performing these types of actions twice is far from optimal.\nI'm sure there are ways to address the double-render symptom and check for it in various places, but preventing it altogether seems important to me.\nCould we instead utilize runSaga or something, so to prevent the initial renderToString?\n. ",
    "gaearon": "Some inspiration: https://www.youtube.com/watch?v=Fo86aiBoomE\n. > At first glance this seems doable, for example we can add a field which is the current call path. So now we can call the effectMonitor(currentCalPath, effect)\nBasically I was thinking about giving each saga an ID (internally) and notifying which saga is parent to which saga by embedding \"parent ID\" into every parent-child effect. So this would give us the call tree.\n. https://github.com/yelouafi/redux-saga/issues/5#issuecomment-166503173 describes what I mean pretty well. Implementation wise I'd experiment with creating a store enhancer that would track the relevant DevTools state in a separate reducer, so those calls to monitor are just actions. See this approach in regular Redux DevTools.\n. To be fair we already let you mute certain actions with https://github.com/zalmoxisus/redux-devtools-filter-actions. But I\u2019m open to offering a built-in approach. \n. > It's storing a log of events (actions) that happened from the bootstrap of the application (or from the backend for isomorphism first loading), and generate the state (redux state and sagas state) by \"playing\" those events. \nTangentially this is exactly how Redux DevTools works. It uses Redux to store the event log itself. Inception.\n. Would you like to send a PR? ;-)\n. It's not going to break. Babel 6 broke this on purpose to align with ES6 semantics. It won't change further. \n. This sounds quite complicated and error prone. I'd vote for running different sagas on the server and the client. Is there any problem with this approach?\n. React won't batch renders by default but you can tell it to with ReactDOM.unstable_batchedUpdates\u2014either manually or via https://github.com/tappleby/redux-batched-subscribe. \nIn any case this is out of scope of Redux Saga. \n. It batches updates if you're inside an event handler. So for dispatches caused by a click, for example, it will be fine. But it doesn't do that in other cases such as AJAX callbacks. There are plans to implement this for all cases but there hasn't been a dedicated effort yet. \n. I'm not well versed in micro tasks in JS. I'm fairly certain React explicitly wraps its event handlers with batching but I don't think it works in other cases. Regardless you can always opt into this with the package I linked to and ReactDOM.unstable_batchedUpdates(). \n. I suggest you to use redux-batched-subscribe as I said above. Alternatively you can do this: https://github.com/tshelburne/redux-batched-actions\n. > If hot-reloading of the saga only affects the future I'll be fine with that.\nI agree. Just pausing existing sagas and restarting hot reloaded ones would cover most cases where you\u2019d care about hot reloading them, in my opinion. Sure, it\u2019s not perfect, but it\u2019s better than nothing, isn\u2019t it?\n. Would an alternative API like\njs\nconst sagas = sagaMiddleware(midSaga1, midSaga2)\nconst store = applyMiddleware(sagas)(createStore)(reducer)\nsagas.run(externalSaga);\nhelp fix this? I'm not sure I understand the problem yet, just thinking aloud. In other words I'm proposing to make run instance method of the middleware function itself so it has access to the dispatched actions.\n. > Yes I think it would work; Although the developer has to export the middleware which feel a bit unnatural (just a feeling :) ).\nAgreed, OTOH this pattern is used by other popular middleware like https://github.com/rackt/react-router-redux. So maybe not too evil.\n\nI think also using a store enhancer with a lifted reducer like in devtools would also work, since the reducer can intercept all actions. \n\nLifting reducers is useful if you want to accumulate custom state without letting the app know. In case of sagas it doesn't seem necessary.\n. > If someone is using an IoC container, they now have to jump through some hoops to have access to run ( which was previously exposed directly as runSaga ). I'm not sure how, though, you could split this up into two modules - they seem rather dependent on one another's scope.\nWhat is the big difference between\njs\nimport { runSaga } from 'redux-saga'\nand\njs\nimport sagaMiddleware from '../sagas/middleware'\nsagaMiddleware.runSaga(...)\n?\nIn any case, beginners likely won\u2019t need this, and when you need I think it\u2019s OK to export saga middleware just like you currently export sagas themselves.\n. Note that you'll want to make sure error behavior is exactly the same between prod and dev versions. If anything throws, it should throw in both cases. Logging a warning only in dev is fine though.\n. > Didn't work with gitbook before; but from the site docs, it seems like publishing gitbooks isn't done in the Github repo but instead on the gitbook site https://github.com/GitbookIO/gitbook#publish-your-book.\nThe site is optional, you can totally make it work with Github Pages. You can check out docs:publish in package.json of Redux to get an idea.\n. Amazing work :+1: \n. I think it's already a good idea to put the Gitbook into the \"website\" field at the top of the repo to give it visibility.\n. > Trust me, I have experience explaining Cycle.js in a weird way (\"Honestly reactive framework for Human-Computer Interaction\"), I learned how to keep it dumb (\"Functional reactive JavaScript framework for cleaner code\").\n:+1: \nAlso, Redux used to be \u201cAtomic Flux with hot reloading\u201d. :open_mouth: \nSo glad we changed that.\n. As for the examples, here\u2019s a few that would make sense to me:\n- Closing modal windows on backdrop click -or- request to open another modal window\n- Reauthenticating the user when the token is expired\n- Showing the onboarding tooltips\n- Showing a \u201cdelete item\u201d confirmation dialog and dispatching an action on confirmation\n- Fetching new data in response to the route changes\n. > drop \"dispatching thunks\", drop \"redux-thunk middleware\".\nI think we can drop those when they are no longer dominant way of performing fetches, etc, in Redux. For now we need to make it clear that Redux Saga handles those scenarios and obsoletes Redux Thunk which is pretty much the most popular Redux middleware at this time.\n\nAvoid heavy beginner-unfriendly jargon for the first text they will ever read. Drop \"saga\" (why not rename it to \"Redux coprocesses\"?), drop \"side effect model\"\n\nIs \u201csaga\u201d more intimidating than \u201ccoprocess\u201d? I have barely any exposure to either, and both seem equally vague to me. I like that \u201csagas\u201d haves precedent in the event sourcing. Since I\u2019m new to both terms, \u201csaga\u201d sounds even a bit friendlier to me than \u201ccoprocess\u201d or \u201cdaemon\u201d. It\u2019s easier to write :smile: .\nI think that we need to pick a few terms we consider essential for the library. For example, saga, effect, and task seem like good candidates. The library can\u2019t really be explained in a good way if one refuses to acknowledge that these types of things exist and make specific sense in the context of the library (and correspond to types). However, once we determine those terms, we need to be careful to only mention these types in the documentation, and not anything else.\n. Something that came up in chat with @ForbesLindesay that I believe is important.\nhttps://twitter.com/forbeslindesay/status/697428202894053376\nAre we sure we are explaining concurrent fetches soon enough? Are the early examples misleading because concurrent actions are ignored but people are not used to this model?\n. I think splitting this into two repos is not a very good solution.\nFigure out which utilities are needed in 95% of apps and include them in the core.\n. I think watch examples should be on the front page. That\u2019s what people come for. We can introduce generators later.\n\nI think it would be nice to have a 2 column table with these 2 higher level function and the corresponding implementations details + how to test them, so that people understand well the distinction and how it got implemented\n\nAgreed.\n. It\u2019s important the APIs are googleable and don\u2019t grab very generic names. It would also be great if there was an easy way to tell between effects (take, put) and saga helpers. Finally, I\u2019m not completely for anything that hides that top-level sagas are generators because this will make people assume watch is the only way to create them. That\u2019s the reason we didn\u2019t ship popular createReducer() helper in Redux.\n. Just throwing this out there.\nNot sure if I made mistakes in generator usage.\n``` js\n// Separate effects and generators\nimport { takeEvery, takeLatest } from 'redux-saga'\nimport { call, put, take, getState } from 'redux-saga/effects'\nfunction* logActions() {\n  while (true) {\n    const action = yield take(action);\n    // getState() is an effect so it doesn\u2019t need to be passed down\n    const state = yield getState();\n    console.log('action: ', action);\n    console.log('state after: ', state);\n  }\n}\nfunction* fetchUser(action) {\n   try {\n      const user = yield call(Api.fetchUser,action.payload.userId);\n      yield put({type: \"USER_FETCH_SUCCEEDED\", user: user});\n   } catch (e) {\n      yield put({type: \"USER_FETCH_FAILED\",message: e.message});\n   }\n}\n// takeEvery() returns a generator so we have a nice named function here.\nfunction fetchUsers() {\n  // No need to support a special watch effect: use yield to delegate.\n  yield* takeEvery('USER_FETCH_REQUESTED', fetchUser);\n}\n// Export one root saga rather than an array.\n// We already allow yield [] so it matches how you\u2019d export one root reducer.\n// Since getState() is an effect, we no longer need to thread it through sagas.\nexport default function* saga() {\n  yield [\n    logActions(),\n    fetchUsers()\n  ]\n}\n``\n. You can provide a top-leveleffects.jsin the project root that just saysmodule.exports = require('./lib/effects')`. Just make sure it is included into the NPM package. \n. > I think we can do this by providing exposing a cancel method\nUsually in Redux we try to return a function for this, e.g. const unsubscribe = store.subscribe(...). Not saying it always makes sense but worth considering as an API choice.\n. Ah, okay then!\n. @cef62 Thank you for your work on this, it is greatly appreciated!\n. I advise you not to rely on experimental feature proposals anywhere except personal projects. Certainly not in the documentation or the source, as it confuses users who are not familiar with those proposals, or worse, leads them to believe those are safe to use when in reality they may well be withdrawn later. \n. @DjebbZ Thank you for contributing!\n. OTOH let\u2019s not forget we want the library to be easy to use without having a good command of FP style.\n. Interesting. I don't know what would be the best way to solve this. Are there precedents in other libraries?\n. No, Webpack does not do that. \n. Yeah, I meant that this project already envifies with DefinePlugin so adding a condition is enough to get this eliminated with Uglify. \n. How it usually works: DefinePlugin/envify just replace process.env.NODE_ENV with a string. However it is Uglify that actually removes if ('production' !== 'production') blocks as dead code. \n. The one important thing is to have consistent throwing behavior in dev and prod. Giving a shorter message in prod is fine, but throwing only in dev is problematic because it makes app behaves inconsistently.\n. ",
    "christianalfoni": "Hi guys! Just wanted to add an updated video on the Cerebral Debugger, which takes into account parallell requests, paths etc. Really glad it can inspire and really looking forward to see where this is going :-) https://www.youtube.com/watch?v=QhStJqngBXc\n. ",
    "slorber": "Hello,\nWhen implementing devtools with Sagas, make sure that when you replay events the saga does not kick in and triggers new actions (replaying history should not modify that history and it could be easy to do so with sagas). \n. waouuuh I like the way you display the race :)\n. @jfrolich I'm interested in this too.\nMaybe we could mark some actions as being verbose, and the devtools could have a checkbox to only display those when we really want to? @gaearon ?\n. @DjebbZ I initially suggested to @yelouafi the saga pattern that is already used in backend's eventsourcing architectures. (long discussion here https://github.com/paldepind/functional-frontend-architecture/issues/20)\nAlso some basic implementations I provided on top of Redux:\nhttp://stackoverflow.com/a/33501899/82609\nhttp://stackoverflow.com/a/33829400/82609\nSome doc of the Saga pattern: https://msdn.microsoft.com/en-us/library/jj591569.aspx\nActually Sagas implemented here are more \"process managers\" but they are often called Saga too (this is a bit confusing yes)\nWhat I mean here is that Saga / process manager is a pattern for which there are many possible implementations. In the backend it's not rare to see the Saga being implemented as an Actor with Scala/Akka or Erlang, or many other solutions.\nHere is a Java implementation of the Axon framework just to illustrate. You can see it does not look at all the same as the implementation provided by this repo (also because the domain of a backend app is very different of a frontend app):\n```\npublic class OrderManagementSaga extends AbstractAnnotatedSaga {\nprivate boolean paid = false;\nprivate boolean delivered = false;\nprivate transient CommandGateway commandGateway;\n\n@StartSaga\n@SagaEventHandler(associationProperty = \"orderId\")\npublic void handle(OrderCreatedEvent event) {\n    // client generated identifiers (1)\n    ShippingId shipmentId = createShipmentId();\n    InvoiceId invoiceId = createInvoiceId();\n    // associate the Saga with these values, before sending the commands (2)\n    associateWith(\"shipmentId\", shipmentId);\n    associateWith(\"invoiceId\", invoiceId);\n    // send the commands\n    commandGateway.send(new PrepareShippingCommand(...));\n    commandGateway.send(new CreateInvoiceCommand(...));\n}\n\n@SagaEventHandler(associationProperty = \"shipmentId\")\npublic void handle(ShippingArrivedEvent event) {\n    delivered = true;\n    if (paid) {\n        end(); (3)\n    }\n}\n\n@SagaEventHandler(associationProperty = \"invoiceId\")\npublic void handle(InvoicePaidEvent event) {\n    paid = true;\n    if (delivered) {\n        end(); (4)\n    }\n}\n\n// ...\n\n}\n```\nI don't know so much the specificity of CSP and I may be wrong but the thing is @yelouafi wants to keep the effects being declarative because it makes it much easier to test (no mock required). When you use the CSP operations, it seems to me that the operation is executed right now (right?), while with the @yelouafi implementation the operations are executed in some kind of interpreter proc.js a bit like a free-monad script. \nWe can discuss this in next reactjs paris meetup :)\n. @DjebbZ yes i think the proc to use promises is an implementation detail.\n\nMakes me think : all declarative is nice to read/write but always seems limiting, whereas full imperative/functional is limitless but can lead to spaghettis. Sagas seem to be somewhat in the middle ground. Is it because it's impossible to have both ? Are we using the wrong paradigms ? Is it a limitation of the language ? Should we all move to LISP (half a joke, really) ? Or Dedalus (watch this GREAT talk, you'll understand my point on languages) ?\n\nI think @yelouafi will at some point want to provide extension points for the interpreter so that users will be able to plug their own effects.\nIf you can build your own AST and its interpreter than you are free to do whatever you want, and Redux-saga can provide some nice and useful defaults that make sense in most cases.\n. @christianalfoni i'm not sure but maybe my answer here could also help answer your question:\nhttps://github.com/yelouafi/redux-saga/issues/6\n. @youknowriad \nActually I don't know what is the claim of Redux, but for me Redux has never been the source of truth. The source of truth is the event log. Redux reducers permit to project that event log into a JS object usable by views but still the event log is the source of truth. You can see it because it's the event log used during devtools time travel, and not store state snapshots. If an event is fired but no reducer use it, then you still have the event, even if you don't see any change in your Redux store: the events are your data, not the store.\nDuring time-travel, the Saga should not emit new events because it can't modify the history. This means that if you follow this reco then time-travel will continue to work like before.  For sagas hot reloading, the saga can be update, and recompute its state from the event log with new logic, but should rather fire new events only in the future.\nFor App state vs UI state. As I said, the real source of truth is the event log. It is both your app and UI state. It does not matter how much time you project this event log into different shapes. In the backend we very often do that to construct very business-specific indexes. The event log is in some global Kafka log and multiple computers listen to that event log, every one computing a specific view. Some projects into Cassandra for timelines, some for Oracle for business analysis, some to ElasticSearch for full-text search... You can project the event log to as many places as you want to according to your needs. You can project this event log to 2 or * redux store instances. They don't even have to use the same root reducer. Your current redux store is just ONE possible projection of your app state, but there are an infinite number of other possibilities. \nSee http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/\nYou shape the projection according to your query needs. We are using immutable data in frontend now mostly because it permits to leverage good performances easily with shouldComponentUpdate. However for state that is not passed to any React view (like saga state), using immutable data structures does not benefit from this performance advantage. I'm not saying we should necessarily use mutable data structures but still it's something to consider: it is really worth projecting everything in a Redux store and immutable data structures if they are not even rendered? or should we do like the backend, and choose the best storage system that solves our problem?\nAbout isomorphism / universal: I'm not sure to understand what your concerns are.\n. @timdorr it is not because it's written in the doc in a simple way to make it easy to understand for event-sourcing new-comers that is it an absolute truth :)\nBrowsers and backend systems are not so different: they manage state. The main difference is that the frontend receives the user intent synchronously so it generally handles that intent based on an up-to-date state. I'm pretty sure frontend and backend will be more and more similar in the future, and don't forget than @gaearon has also been influcend by the Turning the database inside out talk which is about backend primarily :)\n\nYour UI is simply a function on state, i.e. React(state) = view. Replaying an event log to compute that view doesn't make any sense. You should let your state container (Redux) handle that computation of final state so that React can render it.\n\nAbsolutely not. It does make a lot of sense and it permits to implement features like time-travel. You know what, backend guys are doing time-travel for decades :) The saga concept itself is from the backend / eventsourcing world.\nInstead of thinking React(state) = view, you should consider React(Redux(eventlog)) = view\nIf Redux is claimed to be the source of truth it is probably to be simpler to understand, but Redux treats itself the event-log as the source of truth. The beauty of this is that you can use this event log for many other usages:\n- You can sync 2 Redux stores that are on 2 different browser (for example imagine someone taking remote control of your local redux app for assistance...)\n- You can project that event log in other systems\n- You can send that event log to the backend and compute bigdata statistics based in UI usage\n- so many possibilities...\n\nAbsolutely! You may have non-visible state that needs to be managed. Take analytics data for instance. You might collect that into your state to occasionally ship back to your server.\n\nPlease tell me any drawback of storing these statistics outside of the Redux tree if they are not displayed in the UI? \nIf you ship the event log to the server directly instead of computing the analytics on the client, you are still able to implement reducers in the backend to compute these analytics (in the language of your choice btw!). You never loose any data and can replay that event log 1 year later, on another browser or a backend if you want to. (Shipping the event log still has a network cost however...)\nIf you have an app in production for 1 year, and you want to introduce a new analytics that count the TodoCreated actions for a given user. If you compute the analytics on the frontend, then you will start with a counter value = 0. If you ship the event log to the backend, and want to introduce that statistic, you have 1 year of historical event-log to compute a counter value: you don't start at 0 but you have your new stat instantatenously!\nRedux is just a system to project an event-log (source of truth) into an easy-to-comsume state (projection of source of truth) for view applications like React. Nothing forces you to use a single projection at a time of your event log.\n. @youknowriad \n\n@slorber May be It is because I have not the necessary backend knowledge you have to consider the event log as the source of truth for frontend application. I think I need to see an implementation of this to have a precise idea about this.\n\nJust look at this and it will click: http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/\n\nRedux suggest the state of the store is this source of truth and It works quite well for any frontend application.\n\nThe source of truth for React is the Redux store.\nYou can put the Redux state into React and it computes the same view.\nThe source of truth for Redux is the event log.\nYou can put the event log into Redux and it will computes the same state.\nThe source of truth for the event log is the dom events happening on a given UI.\nYou can trigger the dom events on the same UI and it will produce the same event log.\n\nThe thing is some source of truth seems to actually be derived from a former source of truth.\nFor a long time on the backend we considered the database (ie MySQL / MongoDB) as the source of truth (most of us still do actually). While even internally these databases are using event-logs as the source of truth for technical reasons like replication: isn't that funny?\n\nYou have to consider the source of truth according to what you will want to record / replay and how the derived source of truth should behave after code change.\nThe history of things you record should be immutable: you should rather not change the past, but you can eventually change your interpretation of the past: this is hot reloading.\nstate sourcing\nIf you consider state as a source of truth, then you can record state and replay them in the same React app. Here's a video i've done some time ago. If you record only state, you don't have the event log and then if you change a reducer the state history will remain the same: you can only hot-reload React views\nevent sourcing\nIf you record events (or actions) of what has happened, then you can replay these events into redux reducers to recompute the whole history of states, and replay this state history into React to show something. If you change a reducer, then you can compute a new history of state: this is how Redux hot reload works. However you can not modify the event log.\ncommand sourcing\nIf you choose to record the commands (ie the user intent) then you can recompute an event log from the intent log, and then a state log from the event log. The intent is generally translated to events in actionCreators and jsx views where we transform low-level dom-events to Redux actions.\nFor example imagine a video game in React. When the user press left arrow, an event \"WentLeft\" is fired. If you hot-reload the JSX or actionCreator so that when left arrow is pressed it actually fires a \"Jump\", and you time-travel with Redux, you will see that in your history you still have \"WentLeft\" because Redux hot reload does not affect the past.\nCommand sourcing would permit to hot-reload the interpretation layer too and would replace the \"WentLeft\" by a\"Jump\" in the event log before computing the state log and before injection states in React. In practice it has not much interest and may be more complicated to do (not sure but maybe ELM is doing this no?)\nSee also\nhttp://stackoverflow.com/questions/9448215/tools-to-support-live-coding-as-in-bret-victors-inventing-on-principle-talk/31388262#31388262\n. ```\nfunction *startupSaga() {\n// will terminate after all the calls resolve\n  yield [\n    call(fetchUsers),\n    call(fetchOrders),\n ]\n  yield put(applicationStarted())\n}\n```\n@dts  If you only render once the application started action gets fired, you know all the pending calls will have resolved. Not sure it's the best solution but is indeed a solution quite easy to setup.\n. @yelouafi I'm concerned by another problem we may have with sagas and server-side rendering.\nWhen the backend renders we take a snapshot of the state and transmit it to the client.\nBut if a saga starts executing on the backend, then we can't transmit its current \"state\" easily to the frontend. I mean we loose at which point the saga was in the backend, and it will restart from the beginning once started on the frontend.\nLet's consider a saga to handle the onboarding of a TodoMVC app.\nOriginally from https://github.com/rackt/redux/issues/1171#issuecomment-167585575\njavascript\nfunction* onboarding() {\n  while ( true ) {\n    take(ONBOARDING_STARTED)\n    take(TODO_CREATED)\n    put(SHOW_TODO_CREATION_CONGRATULATION)\n    take(ONBOARDING_ENDED)\n  }\n}\nIf the ONBOARDING_STARTED gets fired on the backend then the saga on the backend will wait for a TODO_CREATED event.\nOnce the app starts on the frontend, the saga will start and now that frontend saga is still waiting for a  ONBOARDING_STARTED event. You see what I mean?\n. yes I was thinking of something similar, but while you replay you'll probably want to stub the side-effects. It becomes quite complicated... The same problem may appear if you try to hot reload the saga.\nI don't think the problem is inherent to sagas but rather sagas implemented with generators.\n. Actually I've not come up with any better usecase so maybe it's just a non issue. The users of redux saga should just be aware of the drawbacks and that the saga's progress will be lost when transferring from server to client.\nWe don't do server side rendering yet so it's hard for me to find a usecase in my app right now.\nImho a saga running on the server could probably always/easily be entirely replaced by simple action dispatching. As the server must respond to the client quickly generally only \"boostrap events\" are fired at this stage and you can easily deal with these with a short-lived/server-only boostrap saga, or simply not use a saga at all and dispatch the required actions by yourself. \n. @yelouafi take care with requestAnimationFrame\nI've been using it in the past and we got problems with text inputs where the caret jumped. I know Om uses requestAnimationFrame and they used to wrap the default react inputs to avoid this problem. I don't know if it works better by default today.\n. @yelouafi sorry forget to answer. I just meant that your take effect's matcher assumes there's a \"type\" attribute on actions which is the attribute name choosen by FSA. (in AtomReact the action has a \"name\" attribute so I added a \"type\" to conform to FSA)\n. @yelouafi I wonder if it's not worth reopening this issue actually.\nAs @youknowriad said in his recent medium post, redux-saga is a bit like co but it actually does not execute the effects right now.\nCo is a generic library that can be useful on backend and frontend.\nhttps://github.com/tj/co\nI see redux-saga being close but more powerful than co, but with too much coupling with Redux. If co is useful to anyone, why Redux-saga could not be?\nIt really looks like free monad conceptually\nhttp://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html\nI'm not an expert in free monads, but basically it seems to me you have found an elegant way to declare free monad scripts using generators, and provide a default interpreter that solves most usecases.\n. cc @joshrtay :)\nI like the idea of a generic runtime for IO/async flows. It should provide a nice useful default and be customizable. One should be able to integrate it with redux, or other similar frameworks, and also be able to plug custom logic like to yield observables or whatever maybe... \nAlso in a free-monad env we may try to make the interpreter optimize IOs (see also dataloader idea to do so). If the runtime user has the ability to plug in its own AST he then can declare an effect like \"fetchUser(userId)\" instead of the generic effect \"fetch(\"xyz.com/users/$id\"), and the interpreter could then optimize / batch userfetching according to the user's needs.\n. I'm more concerned about state that the sagas have. I mean if you have a long-lived saga and it uses local variables, then when we time-travel it's not easy to update this state accordingly, and worse the saga also has some kind of \"progress state\" (I mean at which execution point the Saga is currently).\nGenerators seems to allow an user-friendly syntax but also seems to introduce some kind of implicit state and I don't really see how to deal with that.\n. Just to wonder, anybody have a real usecase where he would like to alter the past with a redux-saga?\nI think it's quite complicated to manage. If hot-reloading of the saga only affects the future I'll be fine with that.\n. @aft-luke instead of disabling state, the processor that executes them can simply memoize the effects. Instead of reexecuting the effect, it will simply yield its memoized return directly.\nFor example if you have a statement like:\njavascript\nconst {stop, tick} = yield race({\n        stop   : take('STOP'),\n        tick : call(wait, ONE_SECOND);\n})\nDuring real execution, the race could return from one of the 2 effects.\nDuring replay, if the result of the race is memoized, there's no wait/take to call at all and we simply return the value that has already been returned during real execution. It is easy to reconstruct saga state by using the memoized effects, the complicated part is to stop at a given point in time as it means tracking at which event/action we are and not executing effects after this action/effect.\nAlso when time-travelling it's probably not a good idea to emit any effect in the past and go to the future: it could produce weird things. However it makes sense to rollback to a past state and restart real app execution from this point, and sagas should be able to be set in an appropriate state during that rollback.\n. Hey,\nI've always had troubles to understand all the fame around React Router.\nIs there really any advantage of declaring routes into JSX? \"Hey we are already using JSX, let's do everything in JSX it's better than JS/JSON/XML\"\nAlso I don't like at all the idea of letting side-effects trigger state changes: why should the url change even before your app state! If you consider the url bar/browser history as a \"controlled input\" (like a form input) then you should always update your Redux state before even updating that url/history.\nAlso, if you want clean looking urls and complex routing, I don't understand how the content of the url itself can be enough to contain all the routing state.\nWhat I suggest:\n- Never touch the url bar before updating redux state: make it controlled (the url bar content should be in redux store)\n- On app start, fire an event with the initial url\n- On link clicks, fire actions, rather than triggering browser history apis imperatively. Is it really the responsibility of a given component to update your app's url?\n- On routing state pop (back/forward nav), just publish \"routing state popped\" and let a saga decide what to do\nAlso I generally suggest that components only describe what has happened inside them instead of embedding the translation layer (raw dom event -> business intent). See also http://stackoverflow.com/a/34623840/82609\n. @aikoven I think in all cases redux-saga does not have to be dependent on your redux state at all. However I discussed that with @yelouafi and we agree that it however can be more convenient.\nRelated discussion: https://github.com/yelouafi/redux-saga/issues/8\nAlso check this blogpost: http://jaysoo.ca/2016/01/03/managing-processes-in-redux-using-sagas/\nWhere I suggest the author to change the saga from:\n``` javascript\nfunction* runTimer(getState) {\n  // The sagasMiddleware will start running this generator.\n// Wake up when user starts timer.\n  while(yield take('START')) {\n    while(true) {\n      // This side effect is not run yet, so it can be treated\n      // as data, making it easier to test if needed.\n      yield call(wait, ONE_SECOND);\n  // Check if the timer is still running.\n  // If so, then dispatch a TICK.\n  if (getState().status === 'Running') {\n    yield put(actions.tick());\n  // Otherwise, go idle until user starts the timer again.\n  } else {\n    break;\n  }\n}\n\n}\n}\n```\nto\njavascript\nfunction* runTimer() {\n  while(yield take('START')) {\n    while(true) {\n      const {stop, tick} = yield race({\n        stop   : take('STOP'),\n        tick : call(wait, ONE_SECOND);\n      })\n      if ( !stop ) {\n        yield put(actions.tick());\n      } else {\n        break;\n      }\n    }\n  }\n}\nYou can see that finally no getState() is required at all.\nThe problem is that you consider that Redux is the source of truth, instead of considering the event log. There is no need to depend on the Redux store state because that state is already a projection of the event log. Whoever has access to that log is actually capable of rebuilding Redux store. It is the only dependency required, because all data you need is already is that log.\nHowever if you have a reducer to compute some value over time in a Redux store, I understand this seems quite unnatural to  also compute that same value as a local variable inside the saga: \n- It duplicates the data (inside Redux store + inside saga as local variable)\n- It duplicates the code to compute that value (generators are not really written like reducers...)\nIs data duplication really a problem? Sagas come from the backend world, CQRS and EventSourcing. In this world, the saga and reducers you are familiar with are actually often running on different physical machines, and it is not effective at all to query each others: doing getState() or querying selector data into saga involves IO operations and make the saga unefficient. The only thing these physical machines share is the event log, and they don't query each others. It just works in an efficient and a very decoupled way as the only real dependency is the event log. Each physical machine host a microservice and implements a reducer (but actually persisted in a local DB/index) and some selectors (queries over the DB/index). In this world the saga can run alone in a single physical machine, and has no access to any microservice DB / query API. The saga can itself has its own local DB.\nI don't think data duplication is a problem. A reducer is very predictible and given a state + an event it's supposed to always return the same result, so using the same reducer multiple times inside a single app is not a big deal. However unlike the backend world we are running on a single browser so it should be performant enough... But the reducer could be memoized too (like reselect we could create rereduce :p) \nFinal thoughts\n@aikoven I think in your example with entities/settings, there are different solution. One is to consider settingsReducer as a shared/common dependency of your app (because you need these settings in many places) and then you could use settingsReducer  inside entitiesReducer even if it creates duplication. This would permit you to parse the entity in an atomic/sync way while using a saga for this means the entity would be first unparsed and then become parsed.\nAnother solution, using a saga, that seems more appropriate to me is that instead of trying to inject Redux's store state inside the saga, why not letting the saga declare that it actually needs data that is computed by a reducer (ie registering reducer dependencies to a saga). I like the idea that the saga remains free of querying state from the Redux store, and that the saga should be able to compute its state on its own from the event log. However it would be convenient if the saga could reuse code that is already implemented for redux stores to project the event log. I prefer to depend on pure shared reducers than state shape / selectors.\nInstead of:\n``` javascript\n@connectSaga(state => ({stateParam: ...}))\nfunction* connectedSaga(getParams) {\n  const {stateParam, extraParam} = getParams();\n  // ...\n}\nfunction *saga() {\n  yield run(connectedSaga, {extraParam: ...});\n}\n```\nIt could look like\n``` javascript\n@connectSaga({ stateParam: stateParamReducer })\nfunction* connectedSaga(params) {\n  const {stateParam, extraParam} = params;\n  // ...\n}\nfunction *saga() {\n  yield run(connectedSaga, {extraParam: ...});\n}\n```\n\nDepending on state / selectors in actionCreators and sagas feels wrong to me, like the waitFor of initial Flux implementations.\n. @aikoven I'm just trying to think about how backend systems implement saga. I'm not experienced enough in building those kind of components but as far as I know there's not really a concept of \"subroutine\". It looks like your subroutine is a way to factorise code and split a complex saga into smaller bits, bit does it mean that there are multiple sagas instead of a single big one then? Like React we have smart/dumb components. Wouldn't it make sens to only manage state in a \"smart generator\" (ie the saga) and the factorized/reusable subroutines could just receive required state as a parameter?\n\nStill I'm not sure what are real benefits in having slice of state recomputed locally for each saga. In any way we'd have to query the state, even if it is local.\n\nIf you consider the saga runs on a separate computer and can't query other computers, the only solution to get this required state is to compute it locally from the event log. A reducer is not a \"slice of state\" it's just pure code to project an event log into a meaningful state snapshot. That reducer does not necessarily have to work from the very beginning of the event log. \nIt is ok for the saga to query its local state as it manages its own state. In backends sagas can be backed by databases and they can query these databases as long as the saga itself has the responsability to manage that database. I mean that it's the saga that creates and manage its own DB and can query it (because every state can't always fit in memory like we are used to on frontends). That DB is the saga DB only, and is meant to be queried only by the saga and no one else.\nWhat I want to say is that each component (including sagas) that has acces to the event log picks the state it's interested in from it, by using code that can take form of a reducer, or a generator, or whatever fancy stuff you want. If 2 components of the system need to pick the same data from the log, doesn't it make sens to factorise the code to do so? Once they picked it, they manage that state the way they want and store is where they want to in an autonomous way. These components can be implemented in different languages and technologies, using actors, state machines, sagas, generators, whatever... If one component gets totally refactored, or even deleted, the others are not affected at all (unless the event log is affected). A team can take ownership of a component without having to understand how other components are working nor their component query API updates and lifecycle management. This is not the case if you allow components to query each others.\nSo if we agree components should not query each others, the problem is that components can project the log to a state snapshot in different ways (ie reducers / generators). If you want to be able to reuse some of that logic it should share the same technology. It seems to me there would be less friction introducing reducers in sagas code than introducing generators in redux.\nI don't really have an answer to these questions :)\n. > What I meant by \"slice\" is the part of state that is computed by given reducer. So if I have settingsReducer that manages state of shape {locale: ..., /* other data */}, and connect it to Saga, then querying state.locale means relying on the shape of that part.\n\nThis is probably not an issue in this particular case, because locale is computed independently from other settings, so I can introduce localeReducer that only manages locale value.\nAlso I'm starting to think that exposing state shape to Saga is ok in case of local state, because it's already structured for that particular Saga means.\n\nExactly. A reducer is a function that returns something, so obviously if you decide to use that function, you should be aware of the kind of shape it returns. Obviously it's better to use the smallest possible function that gets the job done so if you only need to pick the locale you don't want to pass your saga your redux's root reducer and have your saga broken everytime the path the locale setting is refactored :) \nBe aware that not all code reuse / factorisation is always a good idea:\nhttp://udidahan.com/2009/06/07/the-fallacy-of-reuse/\nhttp://us3.campaign-archive2.com/?u=1090565ccff48ac602d0a84b4&id=92902a19e4&e=7f00539c7d\nI would only connect to sagas very simple reducers that would preferably compute very simple reducers, mayby only returning primitive values or very simple objects.\n. that seems nice to me :)\nWhat happens if you use connectSaga multiple times last one wins right?\n. Also @aikoven take a look at https://github.com/slorber/rereduce\nYou can use memoization to avoid doing twice the same computation in your solution.\nAlso not sure it's a big deal if you have reducers that don't compute on the whole log but a slice of it.\n@yelouafi I don't like so much the solution of @gaearon here, mostly because as far as I remember, the c generator has to be on the same level as a and b reducers. It couples too much on the shape of the state, so introducing a new dependency could mean we have to refactor the state shape, and it could also lead to have to put a lot of reducers on the same level just for dependency injection in a complex app. If you start to shape your state because of technical constraints of a lib I think it's not a good thing at all.\nIf we really are going to follow the \"query the redux store to get state from it\" approach, I'd rather inject selectors to the saga. This makes the saga and the store shape keep being decoupled. The injected selectors could be binded with getState as parameter so that you don't have to pass getState method everywhere\n. On the initial proposal:\n\nJust like with regular combineReducers(), this pattern can be applied recursively, although only reducers \u201con the same level\u201d (inside the same combineReducers() call) would be allowed to yield each other.\n. @skellock generators and symbols are ES6. Are you sure you preprocessed the lib files with Babel?\n. @ForbesLindesay I understand your point but in practice using redux-saga you soon understand that you should take great care of this kind of race problems. \nI think the library is a low-level building block. Maybe it's not yet the most easy to use, but as @yelouafi said you can easily build meaningful abstractions on top of it like watch/watchLatest.\nIf you think some devs will make mistake, then make sure you understand redux-saga yourself and give them useful and easy to understand abstractions to work with, or teach them these subtilities\n\nIf your usage is just to replace redux-thunk to redux-saga for api call, watch/watchLatest interface is enough in most cases, but redux-saga is not just a lib to handle api calls.\nIn my app when we click on an username we load that username profile page fullscreen.\nIf we click very fast on 2 distincts usernames, then I want to ensure that we will always display the last clicked username profile, no matter the time the requests took. watchLatest is more appropriate in that case, while it may not be for async counter. If I wanted to express that with redux-thunk I would probably have to make some kind of cancellable promise in action creators (and I'm not really sure where I would store it? global variable?)\n. agreed.\nAlso explaining why the term \"saga\" was initially choosen will help people understand how it relates to existing backend concepts\n. @yelouafi I was thinking or organising some kind of \"challenge\" like the one of @staltz: https://github.com/staltz/flux-challenge\nThe challenge idea was to plug an onboarding to an existing TodoMVC application. \nThe onboarding should be complex enough to showcase the power of different approaches, and I think it would be a nice tutorial to display redux-saga capabilities.\nJust haven't figured out yet the onboarding spec to implement :)\n. @staltz the name \"saga\" does not come from nowhere, it actually already is used in the backend event-sourcing and domain-driven-design communities (also called \"process manager\"). It is used to orchestrate complex operations (sometimes eventually consistent transactions) across differend decoupled bounded contexts. \nA bounded context has generally no coupling to other bounded contexts and for the backend it is generally a good candidate to be isolated as a microservice. I think the closest thing we have in Redux community, is a \"widget\" or a \"ducks\". \nBesides being used for ajax interactions, the saga is also a mean to couple 2 ducks together in a meaningful way for your business/app, without creating cyclic dependencies between the 2 ducks.\nSo yes it takes some time to grasp and there is jargon to learn. Notice that even for a domain-driven-design newcomer, this jargon is quite hard to follow at first :) \nI agree that it should be made simpler for newcomers. I've read many times in the DDD community that people sum it up this way: \n\nA saga is just a piece of software that receive events and may issue new commands\n\nBut the UI is different from the backend world (no real need for commands, and a lot more work with remote services, ie ajax)\nFor FP users we could also point out that the implementation shares many similarities with the Free monad. Different user background -> different way to sell the lib. For my background \"free monad\" is more meaningful than \"coprocess\"\n\nI agree for a better \"tagline\" and also think that showing on the first page some very common and easy to understand \"recipes\" would be nice  (the original async counter example does not really speak to me)\nHowever I still think that for more advanced usecase this jargon can be useful to dig deeper into this subject. Flux/Redux is really close to event-sourcing, and as time pass we see more and more existing backend patterns being used in the frontend (including this project). Maybe it's time to simply recognize this fact and stop duplicating already existing jargon?\n. @yelouafi maybe watch/watchLatest should be in core and be one of the first example.\nThis will be used extensively by people wanting to replace ajax calls in actionCreators thunks, and most people think redux-saga is essentially to do only that, in a more testable way.\nIdiomatic ajax thunk replacement is watch, but the doc should also point out that watchLatest can be better in certain usecases (ie not the counter example) and explain the differences, maybe by comparing the 2 low-level implementations so that people finally understand the concurrency concerns that @ForbesLindesay pointed out\n. > watchLatest(which handles out of order responses by taking only the last response).\nYou mean it only takes the response of the last query I guess?\n\nDo you think the introductory tutorial should only use the Higher level API ?\n\nprobably not but the reader should probably learn very soon about watch/watchLatest as it cover an usercase everybody has.\nI think it would be nice to have a 2 column table with these 2 higher level function and the corresponding implementations details + how to test them, so that people understand well the distinction and how it got implemented\n. ``` javascript\nfunction* fetchUser(action) {\n   try {\n      const user = yield call(Api.fetchUser,action.payload.userId);\n      yield put({type: \"USER_FETCH_SUCCEEDED\", user: user});\n   } catch (e) {\n      yield put({type: \"USER_FETCH_FAILED\",message: e.message});\n   }\n}\n// Allow concurrent fetches of user \nfunction* mySaga() {\n  yield watch(\"USER_FETCH_REQUESTED\",fetchUser);\n}\n// Do not allow concurrent fetches of user\n// If \"USER_FETCH_REQUESTED\" gets dispatched \n// while a fetch is already pending, that pending fetch is cancelled \n// and only the latest one will be run\nfunction* mySaga() {\n  yield watchLatest(\"USER_FETCH_REQUESTED\",fetchUser);\n}\n```\nThe watch logic can be a simple Ajax request for the first example as it is simple and match a very common usecase too.\nJust with that snippet, users will know how to effectively replace their thunks and have better concurrency control.\n. Not necessarily, this is just pseudo code but maybe.\n. > > yield getState();\n\nthis solve the issue partly (In the real-world demo for example, the root Saga passes different selectors to sub-sagas). But I guess still better than passing getState around\nI think @slorber could have some objections here :)\n\nI don't like the idea to query the store inside a saga but anyway many users will want to do this at some point so if it's made possible and i simply don't use it it's not a big deal. If I were to use it I would prefer something like yield select(selector) which hide the state shape (but both can be provided anyway). I guess the former \"storeIO\" now need a getState method provided too.\nNot sure we are still discussing about doc here :)\n. If the saga middleware did return a storeIO to use against runSaga, wouldn't it solve the problem? there would only be a single emitter then\n. It seems to me a better default in most cases, but an option would be nice too. I'm not a sysadmin but it's worth checking what linux does here\n. @yelouafi also there's a case where the parent terminates before the forks. Should the forks be cancelled?\n. @yelouafi about my last comment, here I don't know how to handle a parent whose role is only to create subprocesses.\nfunction* handleStamplesPaginationAndFiltering(model) {\n  const subtasks = [];\n  try {\n    subtasks.push(yield fork(stamplePaginateSaga,model))\n    subtasks.push(yield fork(stampleFilterUpdatesWatcher,model))\n    yield subtasks.map(join)\n  }\n  catch(e) {\n    if ( e instanceof SagaCancellationException ) {\n      yield subtasks.map(cancel);\n    }\n  }\n}\nI think what I have here is pretty common and should require less boilerplate maybe? don't know just wanted you to be aware of this case\n. oh ok :) will do that then haha\n. I'll be fine with that :)\nBtw don't you think that redux-saga would start to become very close to an actor model?\n- Each actor can receive/emit events from a bus\n- Each actor can span child actors, or create detached actors\n- Killing a parent actor kills the whole branch\n- When a child actor fails, the parent is responsible for recovery strategy\nI feel like we are moving in this kind of direction. Btw actor systems like Akka are often used to build backend saga\n. great thanks :)\n. Not sure what you want to do but it seems what you want is:\n- after a notification gets set, it gets cleared after 300ms\n- if a new notification gets set but the old one is not cleared yet, then the old timer should not mess up with the new notification\nMaybe something like this will work fine:\njavascript\nfunction* hideNotification() {\n  while(true) {\n    const {action, wait} = yield race({\n        action : yield take(SET_NOTIFICATION);\n        wait : call(wait, 300);\n    });\n    if ( !action ) {\n        yield put(NotificationActions.clearNotification()\n    }\n  }\n}\nSee also: http://jaysoo.ca/2016/01/03/managing-processes-in-redux-using-sagas/\n. @aft-luke what you want to achieve seems a bit far-fetched. Instead of trying to abstract over redux-saga you could simply create a reusable React component that you customize in different places.\nAn idiomatic way of using Redux is to keep a serializable event log. In means you are not supposed to dispatch actions with callbacks, generators, functions, promises or observables as payload. \nIt is also my personal opinion (not really followed by the rest of the community atm) that the dispatched actions should always represent something that HAS happened (past tense) and not be used to do remove procedure calls. This is how event-sourcing works in the first place.\nYou can see how I remove, with redux-saga, an idiomatic redux-thunk rpc call here by a simple event dispatch: http://stackoverflow.com/a/34623840/82609\nFlux/Redux is heavily close to event-sourcing, but a lot of confusion comes from the word \"action\" because people now think the \"dispatcher\" is supposed to dispatch both commands (rpc / user intent) and events (descriptors of what happened).\n. @aft-luke \n\nA domain driven design approach would translate any event that is external to the component's domain into an internal representation, at which point the root of the reducer hierarchy becomes an aggregate root. This, unfortunately, means a very large reducer at the top of the hierarchy that must capture and translate every single event used by any component below.\n\nInstead of doing this translation into reducers you should do it inside a saga. This is why I wanted something like redux-saga in the first place.\nI don't think there is something close to an aggregate root in UIs because of the synchronous nature of interactions (while backend receive commands async). There's no need to validate commands because actually in the UI word everything has happened. You can notice this subtility because DOM events are always in the past tense, and the DOM does not send you commands that you can refuse. Even if there is a form error or whatever it's still an event, and the display of the error message has happened ;)\n. @aft-luke we agree on that :)\nyou may be interested by this discussion: https://github.com/jarvisaoieong/redux-architecture/issues/1\n. @savethefails not sure it's related to \"put within a callback\", but here's my opinion.\nIt looks like you want to navigate away from current page, after form save is successful. I guess your push is something like HistoryJS/ReactRouter push. Instead of letting your component do the push, which seems not their responsability, I would rather use a saga for that.\n``` javascript\nfunction * redirectToSuccessPageAfterSuccessfulFormSubmit(){\n  while(true) {\n    const action = yield take(FORM_SUBMITTED)\n// Option1: \nyield call(() => window.location.href = \"/success\");\n\n// Option2: HistoryJS\nyield call(() => history.push(\"/success\"));\n\n// Option3: React-router-redux: \nyield put(push('/foo'))\n\n}\n}\n```\nDoes it make sense?\nAlso, I would say that dispatching payloads with functions in it is a bad practice that makes your event-log unserializable\n. @savethefails \n\nhow many Sagas are too many?\n\nI don't know if there are performance limits but sagas are just listeners so if they don't take it's not more costly than a connected component I guess. It is ok to not keep alive your sagas during the whole app process. For example if you build an onboarding saga, you can spawn it after signup, and cancel/end it at the end of the onboarding. A saga itself can track onboarding_start/cancel/end events to manage that onboarding saga. You likely don't want to congratulate the user everytime he creates a todo, but only during the TodoMVC onboarding.\n\nCan a component dictate the story of a Saga when the specifics of how to respond to async actions can't be known by the Saga itself?\n\nI'm trying to understand your example but it's quite complicated so I'm unsure...\nIt looks to like you have components that can be arbitrarily nested and that you need to validate asynchronously the data that these components need to set somehow. For me it's fine to emit an event with a path to the state you want to update so that the saga can do the call and reuse that path in the reponse. You can even tell the saga which success/fail actions you want after async call, so that you have a very generic and reusable saga. \nHowever I think it's not good to emit actions creators inside your events so that the saga can call them. It reduces your boilerplate but it a bad idea for me. Are these actionCreators simples (I mean no thunks?). For me it would be better to do something like that:\n``` javascript\ndispatch({\n     type: FIRE_OR_RETREAT,\n     current: { lat: this.props.lat, long: this.props.long },\n     successActionTypes: [\"ORDER_SUCCEEDED\"],\n     errorActionTypes: [\"ORDER_FAILED\"]\n});\nfunction* handleFireOrRetreat(){\n  while(true) {\n    const action = yield take(FIRE_OR_RETREAT)\n    put({\n       type: CALL_API,\n       url: \"/api?lat=\"+action.payload.lat+\"&long=\"+action.payload.long,\n       successActionTypes: action.successActionTypes,\n       errorActionTypes: action.errorActionTypes,\n   });\n  }\n}\nfunction* callApi(){\n  while(true) {\n    const action = yield take(CALL_API)\n    const {success, error} = fetch(action.url)\n    if (success) {\n       yield action.successActionTypes.map(type => put({type: type, data: success.data}))\n   }\n   if (error) {\n       yield action.errorActionTypes.map(type => put({type: type, data: error.data}))\n   }\n}\n```\nThis won't work if you have complex actionCreators, but you can probably rework these existing action creators by using sagas as well.\n. @mhoffmanniseki yes you can run redux-saga without redux, as long as you an API so that take/put/select can work\nSee https://gist.github.com/slorber/c095671a14b2eccf8ad665a97a7b8ad1\n. If you just look for a simple workaround this certainly is not the way it's supposed to be done but it still works:\njavascript\nfunction onProgress(progress) {\n  store.dispatch({type: ACTIONS.S_DOWNLOAD_PROGRESS, progress})\n}\nYou won't have the testability/analysis benefits of a yielded effect, but for this kind of usecase it may be fine. I don't think it is possible since that await is not processed by the redux-saga processor but by the browser so it does not generate a cancellable redux-saga task.\nWhat is the usecase of using await inside redux-saga exactly? can't you just use yield ?\n. it's probably useful as a low-level api only. For example for those who wants to build a middleware to allow dispatching sagas, or whose who want a saga to exist only the time a component is mounted (like redux-react-local\nFor me it's more of an architectural low-level API to build on top than something you should use regularly in your app\n. that would be nice :)\n. @AriaFallah the same logic can be expressed with a state machine, a reducer returning effects, a stream or a generator. The only distinction is convenience for me. Expressing sagas logic with RxJs would also be fine\n. @AriaFallah I guess it's the same as asking \"why invent async/await when we have stable promises or callbacks\". I guess it's just some people will find it more easy to read/maintain, but it does not permit to do things we could not do in the past. Wonder what @yelouafi think about that :)\n. I think we should support a high level API to handle throttle/debounce with leading/trailing options like underscore.\n. sure @yelouafi I didn't say it should be in the core anyway :)\n. hmmm, just needing that throttle with trailing action.\nUnfortunatly the code for handling trailing is quite complicated :'(\nI've seen the recipe and your snippet here: https://github.com/yelouafi/redux-saga/issues/166#issuecomment-192671726\nIn my case I don't need to throttle the take, but trottle a generator call :)\n``` javascript\nlet pollingTask;\nlet pollingDebouncing = 500;\n\nwhile ( true ) {\n\n  yield race({\n    delay: call(delay,MaxPollingInterval),\n    event : call(watchForEventsTriggeringPolling)\n  });\n\n  if ( pollingTask ) yield cancel(pollingTask);\n\n  pollingTask = yield fork(function* doPolling() {\n    try {\n      yield delay(pollingDebouncing);\n      yield something; // Call your api here\n    }\n    catch(e) {\n      if ( isCancelError(e) ) { }\n      else throw e;\n    }\n  });\n\n}\n\n```\nI've used debouncing finally because it almost does the same but throttling with trailing would have been better for me but really not that easy to implement :D we'll have to build a toolkit for that \n. hmmm that looks great and much simpler yes :) I'll try to migrate soon\n. great will test that in next release :)\nDon't know so much about the generator problem. \nFor JS bundles you can make 2 different js files.\nFor Browserify/Webpack, can't the lib client handle lib transpiling? I think browserify support this by declaring a transform on the lib but don't know about Webpack\n. Hi,\nIn my app I used to handle this with an XHR interceptor. This way I'm sure I'm not missing any case if someone starts to use some ad-hoc api request in componentDidMount.\nI've built ajax-interceptor for that.\n. > OTOH I'm wondering if this would make people miss the point of Sagas, because the dispatch approach is easier and would likely be used widely (But As I said that's an opinion and I don't like to dictate it on people)\nI totally agree. The idea of sagas for me is to orchestrate operations across decoupled components. Triggering sagas in an imperative way seems weird to me, and is not even close to backend saga concept at all. \nThe problem is that we are mixing kind of 2 different things in this lib. Sagas is a pattern from backend world. This library permits to implement the saga pattern for frontend world, but not only that. So redux-saga should rather choose if it wants to be a more general toolkit for side-effects, permitting to implement the saga pattern, or if it wants to enforce a clean usage of the saga pattern.\nBecause for me, dispatching sagas, or running local sagas on component mount is not the saga pattern anymore and I'm not planning to use such things at all.\n. I'm not sure to understand that analogy sorry.\nThe saga pattern is the coupling point between different decoupled bounded contexts (you can compare a bounded context to a widget). Widgets should not know about each others but just know about themselves. The saga is the piece that says \"when button is clicked inside widget1, then widget2 should toggle\", without widget1 having to know anything about widget2. \nYou don't create a 1-1 mapping between an widget or an action to a saga. The widget should not even be aware of any saga and should be able to work fine without that saga (only the global cooperation of widgets should be affected).\nYes this creates indirection that is overkill in small projects but will make the app scale better on big projects.\nYou may or may not use redux-saga this way, but this is what the saga pattern is initially\n. @yelouafi I'm not sure to understand what would be the difference between\njavascript\nexport default function* root() {\n  yield* takeLatest(Actions.LOGIN, login);\n  yield* takeLatest(Actions.LOGOUT, logout);\n}\nand\njavascript\nexport default function* root() {\n  yield takeLatest(Actions.LOGIN, login);\n  yield takeLatest(Actions.LOGOUT, logout);\n}\nJust learned about this yield* thing, first time I read it I thought it was a typo haha\n. ok so it's like flatMap for generators I guess haha\n. @jokeyrhyme a Saga is a pattern that is often used in EventSourcing/CQRS/DDD. It can be implemented in different ways, including using actors.\nIn some functional languages like Erlang or Scala (which use extensively the actor model) the saga pattern is often implemented on top of actors\nredux-saga is kind of similar to actors except it does not implement a lot of unneeded features like parent/child sender/receiver communication, or retry/recovery patterns. Remember that the actor pattern was initially built with Erlang with failure handling in mind, for reliability of telco networks. Another difference is its focus on testability by using an interpreter for yielded effects, also permitting to get a better idea of what is happening in the long run (which is more complicated to achieve in distributed systems implemented with actors, requiring tools like Zipkin)\n. I'll try to make a PR with a test case tomorrow \n. @yelouafi I can't make an easy to reproduce test case.\nThe following seems to be passing already:\n``` javascript\ntest.only('processor handles synchronous call failures', assert => {\n  assert.plan(1);\nlet actual = []\n  const dispatch = v => actual.push(v)\nfunction* genFn() {\n    try {\n      yield io.put(\"start\")\n      yield call(() => {\n        throw new Error(\"test error\")\n      });\n      yield io.put(\"success\")\n    }\n    catch (e) {\n      yield io.put(\"failure\")\n    }\n  }\nproc(genFn(),undefined,dispatch).done.catch(err => assert.fail(err))\nconst expected = ['start','failure'];\n  setTimeout(() => {\n    assert.deepEqual(actual, expected,\"processor should inject call error into generator\")\n    assert.end()\n  }, DELAY)\n});\n```\nThe problem is that I still get strange unhandled ES6 failures in my logs of my real app. I use Q in my app so these unhandled ES6 failures come from redux-saga and not my own code.\n. Here is what looks like my  real app code:\n``` javascript\nimport { isCancelError } from 'redux-saga'\nimport { take, put, fork, join, call, cancel, delay } from 'redux-saga/effects';\nimport * as events from 'appEvents';\nconst Names = events.Names;\nimport ApiV3 from 'repositories/apiV3';\nimport { Types, withStamples, withLibraries, withFolders, withGroups, isType } from 'models/mainContentModel';\nconst StamplesPerPage = 10;\nexport function* fetchNextStamplePage(apiFilters, from) {\n  try {\n    yield put(events.stamplePageRequested());\n    const page = yield call(ApiV3.getStamples, from, StamplesPerPage, apiFilters);\n    const isLastPage = page.length !== StamplesPerPage;\n    yield put(events.stamplePageLoaded(page,isLastPage));\n    return {page,isLastPage: isLastPage};\n  }\n  catch (e) {\n    if ( isCancelError(e) ) { void(0) }\n    else {\n      console.error(\"Stample pagination error while loading page from=\"+from+\" / filter=\"+JSON.stringify(apiFilters),e);\n      yield put(events.stamplePageError(e.message));\n    }\n  }\n}\nexport function startPagination(apiFilters) {\n  let loadedStamplesCount = 0;\n  let canLoadMore = false;\n  function fetchPage() {\n    const {page,isLastPage} = yield call(fetchNextStamplePage, apiFilters, loadedStamplesCount);\n    if ( page ) {\n      loadedStamplesCount += page.length;\n      canLoadMore = !isLastPage;\n    }\n    if ( canLoadMore ) {\n      yield put(events.moreContentAvailableDetected());\n    }\n    return page;\n  }\ntry {\n    // fetch 1s page\n    yield fetchPage();\n    // and wait for more content requests (on scroll) until last page is reached\n    while ( canLoadMore ) {\n      yield take(Names.MORE_CONTENT_REQUESTED);\n      yield fetchPage();\n    }\n  }\n  catch(e) {\n    if ( isCancelError(e) ) { void(0); }\n    else throw e;\n  }\n}\nfunction getApiFilters(model,filters) {\n  const baseApiFilters = {\n    withFilteringTags: filters.selectedTags\n  };\nswitch(model.type) {\n    case Types.HOME:\n      return baseApiFilters;\n    case Types.FOLDER_CONTENT:\n      // Yes this can be surprising at first, but when tags are selected, we search for stamples\n      // in \"depth\" (underCategoryIds instead of categoryIds filter)\n      if ( filters.selectedTags && filters.selectedTags.length > 0 ) {\n        return {\n          ...baseApiFilters,\n          underCategoryIds: [model.folderId],\n        };\n      }\n      else {\n        return {\n          ...baseApiFilters,\n          categoryIds: [model.folderId]\n        };\n      }\n    case Types.MY_FAVORITES:\n      return {\n        ...baseApiFilters,\n        favorite: true,\n      };\n    case Types.SEARCH_RESULTS:\n      return {\n        ...baseApiFilters,\n        text: model.text\n      };\n    default:\n      throw new Error(\"Unknown filters for main content model of type \" + model.type);\n  }\n}\nexport default function* stamplePaginateSaga(model) {\n  let subtasks = [];\n  let apiFilters = undefined;\n  try {\nyield put(events.stamplePagesCleaned());\napiFilters = getApiFilters(model,{});\nsubtasks.push(yield fork(startPagination, apiFilters));\n\nwhile ( true ) {\n  const {data: {filters}} = yield take(Names.STAMPLE_FILTERS_UPDATED);\n  yield subtasks.map(cancel);\n  subtasks = [];\n\n  yield put(events.stamplePagesCleaned());\n  apiFilters = getApiFilters(model,filters);\n  subtasks.push(yield fork(startPagination, apiFilters));\n}\n\n}\n  catch(e) {\n    if ( isCancelError(e) ) yield subtasks.map(cancel);\n    else throw e;\n  }\n}\n```\nIf I make the ApiV3.getStamples method throw a synchronous error (and not a failed promise), I get these unhandled ES6 promises logs.\nI tried to do:\n``` javascript\nfunction runCallEffect({context, fn, args}, effectId, cb) {\n    let result;\n    try {\n      result = fn.apply(context, args);\n    } catch (e) {\n      result = Promise.reject(e);\n    }\n    return (\n        is.promise(result)  ? resolvePromise(result, cb)\n      : is.iterator(result) ? resolveIterator(result, effectId, fn.name, cb)\n      : cb(null, result)\n    )\n  }\n```\nNow it seems my exception is catched in fetchNextStamplePage but it then fails later with: Unhandled promise rejection TypeError: Cannot read property 'page' of undefined(\u2026). This seems expected to me because my saga does not return anything\n. @yelouafi hmmm I may have found the test case:\n``` javascript\ntest.only('processor handles synchronous call failures', assert => {\n  assert.plan(1);\nlet actual = []\n  const dispatch = v => actual.push(v)\nfunction* genFnChild() {\n    try {\n      yield io.put(\"startChild\")\n      yield call(() => {\n        throw new Error(\"child error\")\n      });\n      yield io.put(\"success child\")\n    }\n    catch (e) {\n      yield io.put(\"failure child\")\n    }\n  }\nfunction* genFnParent() {\n    try {\n      yield io.put(\"start parent\")\n      yield call(genFnChild);\n      yield io.put(\"success parent\")\n    }\n    catch (e) {\n      yield io.put(\"failure parent\")\n    }\n  }\nproc(genFnParent(),undefined,dispatch).done.catch(err => assert.fail(err))\nconst expected = ['start parent','startChild','failure child','failure parent'];\n  setTimeout(() => {\n    assert.deepEqual(actual, expected,\"processor should inject call error into generator\")\n    assert.end()\n  }, DELAY)\n});\n```\n```\n      expected: |-\n        [ 'start parent', 'startChild', 'failure child', 'failure parent' ]\n      actual: |-\n        [ 'start parent', 'failure parent' ]\n```\nNot sure it's the behavior you want but at least this is what I intuitively expected :)\nIf this is a bug, I have no idea yet how it should be fixed but I guess you do ;)\n. ooh yes!\nI've made a PR because yes the try/catch seems to fix the issue and otherwise the test-case does not produce the expected output.\nhttps://github.com/yelouafi/redux-saga/pull/165\nI think it also fix my app problem but not sure yet I'll try to check that when I've more time\n. There are 2 possible cases here:\n- The saga is slow and takes 90ms to dispatch the new action\n- The saga is delayed for something like 90ms for unknown reasons \nThe saga code is called AFTER your store's root reducer is called and has computed the new state.\nI suspect that your reducer is slow, and that the saga is delayed by 90ms because it is the time your reducer takes to handle that event.\nYou should try to log performance around these updates:\njavascript\nreturn state.updateIn([FUTURE, 'nodes'], nodes => {\n        return nodes.map( (node, index) => {\n          return nodeIndex === index\n          ? node.set( 'selected', true )\n          : node.set( 'rejected', true );\n        });\n      });\nI may be wrong but it is likely to me that this part of your app is slower than you think and takes 90ms. \nI use redux-saga and did not notice any performance problem with it.\nIf that's not the case don't hesitate to show the former redux-thunk version (including log statements).\n. Can you log the execution time of each action inside the reducer? Because here we only see the time when the reducer receives the action, but it does not show how much time does this action takes to be handled.\nAlso it would help if you log the time around each dispatch.\nAlso do you use a saga monitor? Can you try without it?\nCan you also try to use actionCreators/thunks without disabling the saga middleware?\n. @joshwcomeau as far as I know redux-saga do dispatch internal events so that we could plug additional devtools based on these (like the saga monitor I mention).\nIt seems that each of these events are 15ms from each others, so there is something weird that takes time because if you don't have a saga monitor nobody else should be interested by these events...\nMaybe try to use redux-ignore so that these events never gets dispatched to your reducer?\n. great!\n@yelouafi how comes this dev mode is so expensive?\n. makes sense but what I see in source code is that the reudcer tree of @joshwcomeau is pretty small and will ignore fastly all these redux-saga events. The overhead of microtasks is unlikely to delay each dispatchs of 15ms.\nMaybe there's an existing middleware that does not handle redux-saga effects in an efficient way. I suggest some middleware is trying to log the effect actions, and in some cases it may not be performant because you put tasks in these effects. I think redux-saga should rather avoid to dispatch unserializable events containing objects with methods, like promises or errors. And it may be the cause of this latency no?\n. I think there's not much difference.\nThe only difference I can see right now is probably related to error/cancellation propagation, but I think it has not been implemented properly yet. Probably that starting sagas as an array instead of forks isolates them better?\n. great :)\n. thanks will update\n. it looks like a great idea to me to be able to attach a log or context to each executed effect.\nThe saga monitor tools could be able to display these messages as well so that it's easier to understand what is happening.\nI don't agree with the proposed implementation, as if the log is not an effect and not processed by the generator it only logs to the console and is unusable with saga devtools.\nIt would somehow be similar to the writer monad for generators.\n. @pke I'm not saying it's not helpful to log like that, it's just that it just logs to the console and we could do better IMO, but this logging thing should probably be implemented inside the processor of redux-saga.\nthere used to be a method window.$$logSagaTrace() but I can't find it back. It may have helped you to find the source of your problem. @yelouafi any idea why this method is not available anymore in latest versions?\n. thanks :)\n. @pke instead of trying to wait less time when wait(10 minutes) is called, why not replace it by wait(1 second) in case your are in cucumber tests env\n. @yelouafi by chance do you know why this does not work?\njavascript\nyield stamples.map(stample => {\n    call(watcherGenerator,stample);\n});\nwhile this works:\njavascript\nyield call(watcherGenerator,stample);\nI don't understand :D \n. :O obviously :)\nby chance is there a way to add a warning for such cases when we are yielding an array those values are not effects/promises? it would probably be helpful to others\nthanks\n. hmmm actually one might want to map and not return effect for all the elements of the array (I almost did try that).\nI certainly can use _.compact to remove undefined values from the array anyway\n. @kfrajtak you have to either compute state inside your saga (so you can't use const because you need to reassign variables overtime), OR reuse existing Redux store state if you have reducers that compute state\nFor example:\njavascript\nexport function* watchLeftRightChanged() {  \n  let right;\n  let left;\n  while (true) {\n    const result = yield take(['LEFT_CHANGED', 'RIGHT_CHANGED'])\n    switch (result.type) {\n      case 'LEFT_CHANGED': left = result.payload; break;\n      case 'RIGHT_CHANGED': right = result.payload; break;\n    }\n    yield put({ type: 'SOURCES_CHANGED', left, right })\n  }\n}\nOR \njavascript\nexport function* watchLeftRightChanged() {  \n  while (true) {\n    const result = yield take(['LEFT_CHANGED', 'RIGHT_CHANGED'])\n    const left = select(state => state.leftState)\n    const right = select(state => state.rightState)\n    yield put({ type: 'SOURCES_CHANGED', left, right })\n  }\n}\nThis pattern is handy for example if you build a search engine and your search engine filters are not close in the DOM: you may want to aggregate multiple small filters in a big composite filter\n. I too had to copy this method in my project. Initially I though it was built-in but figured out it was not later :)\n. @artursgirons I think you can't currently\nWorth checking these related issues where some people  are trying to use multiple times take() inside a race() \nhttps://github.com/yelouafi/redux-saga/issues/21\nhttps://github.com/yelouafi/redux-saga/issues/32\n. Like @ctrlplusb I always start my app with a startup events so I don't have much this kind of problem.\n@yelouafi I had the same problem 2 years ago, when I built a hacky saga system on top of my AtomReact stores\nAs you can see I choose the async path based on setTimeout :) but this was really annoying me because of the pros and cons you mention I didn't really know what to choose :D\nI implemented something that looks a bit similar to your reentrant lock at some point (command queuing. Don't even really remember how it worked but it was quite hacky :)\nI guess the idea is that the sagas should be able to become \"stable\" before receiving any new dispatch from outside the sagas right? If yes i'm fine with that.\nHowever a nice default setting is cool, but I think it would be nice to give options in the put effect so that developers can decide themselves if they need sync/async/default for their puts\n. @joonhyublee this might interest you: http://stackoverflow.com/questions/34782249/can-a-react-redux-app-really-scale-as-well-as-say-backbone-even-with-reselect/34788570\n. @danwad if you call error() like that the generator is not called it's just a regular function call then. \nI think you should rather use:\njavascript\nfunction* saga() {\n  yield* [\n    call(error)\n  ]\n}\n. have you imported call?\nAlso I'm not sure but is yield* [] with an array something that actually works? (I mean with the asterisk)\n. @pke this is a hard problem to solve.\nSagas come from backend world, and during event-sourcing replay, we generally disable the sagas (or at least make them not reprocess already processed events). The thing is we generally replay the full event-log (with different projection, ie reducers, code) and we don't reset to a past point and start going new actions from here (like Redux permits). \nThese problems have already been discussed a bit in existing issues, like https://github.com/yelouafi/redux-saga/issues/22\n. @pke \nTake a look at: https://github.com/yelouafi/redux-saga/issues/78\nThe generator loosing the race should normally already be cancelled automatically as far as I know. \nAlso this comment:\n\nParallel effect cancellation means cancellation of all sub-effects\n\nSo, for me it looks like your watchers should already be cancelled on logout. Are you sure they are still running? Unless you fork them they should already be automatically cancelled no?\n. great catch :)\n. @jshthornton for me it's a valid usecase. I do this kind of stuff extensively to build onboardings where we have to guide the user to a specific workflow that should only be applied just after signup.\n. account.sagas.map(saga => sagaMiddleware.run(saga)) should do the job\nOr maybe\njavascript\nfunction* root() {\n  yield account.sagas.map(saga => call(saga));\n}\n. @babeal I don't understand what you would expect redux-saga to do. What does it mean to call an observable? How can we know the behavior you want? You may want the first item of the stream, or you may want all the items of the stream once the stream ends\n. @gaearon you mean DefinePlugin / Envify? not sure Uglify does such thing\n. Also, for those like me logging all production errors in GetSentry, it's better to not do like React and still have meaningful errors in production, otherwise what we log in GetSentry is useless. A short message or an error code is relevant, but a generic \"redux saga error\" would be bad\nSee also https://github.com/facebook/react/issues/2686\n. @davej \nParallel upload:\njavascript\nyield files.map(file => call(uploadImageApi , file));\nSequential upload:\njavascript\nfor (const i in files) {\n  if (files.hasOwnProperty(i)) {\n    yield call(uploadImageApi, files[i]);\n  }\n}\nConclusion:\nBoth options work fine, but it depends on if you want the files to get uploaded in paralllel or in sequence, according to your own usecase.\n. @davej it depends on if you intend to use the result returned by the upload API.\nIf you use sequential upload you need to put the forked tasks in an array and join them afterwards to be able to get all the results. If you use sequential version above the yield directly returns an array of all the collected upload results (note that if any of the upload fails, it will throw)\n. @DEllement yes it is\nI've just twitted about it because probably others could be interested.\nhttps://twitter.com/sebastienlorber/status/735037978377105408\nhttps://gist.github.com/slorber/c095671a14b2eccf8ad665a97a7b8ad1\n. NP.\nI've backlinked the link in my gist for users interest to use Alt :)\n. @adjohu not sure by try the following: \nyield select(state => dogSelector(state), {params: {dogId}});\n. I don't know.\n\nselect() doesn't seem to work properly with reselect\n\nThis does not really describle the problem. Please show error or returned object\nHonnestly there's something strange in your code, because you seem to try to pass a dogId in params, and in the same time you seem to try to select the dogId from state (by depending on dogIdSelector)\nIt seems to me you can't do both\n. @yelouafi maybe put in the doc that saga middleware should usually be put as last middleware.\nIf you dispatch thunks/promises, or from devtools, you''d generally like the saga to receive raw events / devtool events\n. @DarrylD I yhink my answer here might help you \nhttp://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34623840#34623840\n. @DarrylD thanks :)\nI think we allow to dispatch an action creator because people might want to keep using thunks with redux-saga. I think thunks are not needed anymore with redux-saga, but one might want to migrate progressively to sagas and keep both during the migration.\nIn this example as the selectReddit is not a thunk I don't see much interest, except the ability to have an action builder, on which you can easily add assertions, and eventually a typesystem like typescript or flow. I'd recommend to keep the usage of actionCreators just for that as it can help maintainability.\nWether you are in a saga, or in a componnt, using an actionCreator has these advantages:\n``` javascript\nthis.props.dispatch(selectReddit(nextReddit))\n// or \nyield put(selectReddit(nextReddit))\n```\n. @yelouafi also we often see people using a single root saga starting other sagas with fork, call array or something similar\nI'm not sure it's a good idea to let people use redux-saga this way because a single uncatched error anywhere will make all the sagas cancelled, leading sometimes to the app becoming unusable. We all know it's quite annoying when this happens (see error boundaries in React) so it may be worth advocating for a clever isolation of sagas inside of a single top-level saga\n. @madebyherzblut use spawn instead of fork/call, or run multiple times runSaga method\n. @ms88privat I think it's the same and the only difference is spawn is detached\n. Hi,\nI'm using the same Cordova push plugin :)\nHere it's a bit particular because you want this function to both return a Apns/GCM token, and a stream of future notifications. It's not the responsability of this method to be coupled with redux and dispatch actions.\nInstead of returning just the token in the promise, why not also returning the push object, so that the caller can decide to subscribe to notifications? Alternatively you can probably create a channel and return it as well. The thing is that you probably don't want to return the channel until the registration is successful so you can put the channel inside the promise.\nHonnetly, not sure it's important to return the stream/channel after the token. If the channel is available at the beginning but does not emit anything it's not a big deal imho. Also note that runnng your method multiple times will lead to multiple push plugin initializations. You might want to memoize the returned promise or ensure it only run once in your code.\n. hmmmm no I think in any case you need a channel to handle that properly :)\n. yes look at https://github.com/redux-saga/redux-saga/blob/master/docs/advanced/Channels.md#using-the-eventchannel-factory-to-connect-to-external-events\n. There are some examples available where people tried to subscribe to websocket events from sagas, which is a similar usecase.\nFor example: http://stackoverflow.com/questions/35277682/how-to-tie-emitted-events-events-into-redux-saga\nI have never used such channel yet however, and I'm not sure it's really worth it unless you really have to handle complex coordination.\nHere's what I've done in my app: https://gist.github.com/slorber/88cc95d16647fd73fa071f497fd1c6f9\nIn my app, the push plugin simply triggers dispatches and could be simplied as:\njavascript\npush.on('notification', function(data) {\n        store.dispatch(AppEvents.mobilePushReceived(data));\n});\nI think this is largely enough for most push usecases.\nOnce the push event is dispatched, it's still possible to listen to that event in sagas and handle more complex workflows if needed. Unless you have to handle complexity related to the subscription (unsubscribe/resubscribe/handle subscription disconnections/throttle/debounce/exponential backoff...), I wouldn't manage this inside the saga directly because imho it's not worth it.\n. ``` javascript\nfunction registerForPushes(store) {\n  push.on('notification', function(data) {\n          store.dispatch(AppEvents.mobilePushReceived(data));\n  });\n}\nconst store = createStore(reducer);\nregisterForPushes(store);\n```\n. Why would you not have access to the store? If you create a store, it is somewhere, and you can call a method passing that store as parameter.\n. If your dispatch function returns promise, it's probably because you use some promise middleware.\nIt is possible to wait for promises in redux-saga, have you tried the following?\njavascript\nconst actionAPromise = yield put(actionA);\nconst actionAResult = yield actionAPromise;\nconst actionBPromise = yield put(actionB);\nconst actionBResult = yield actionBPromise;\nI'm not sure if currently the put effect does return the result of the dispatch method however but you can try that.\nAlso, why do you want to mix redux-saga code with promise middleware? If you start to use sagas you would tend to dispatch only synchronous actions and manage effects inside sagas directly.\n. @nhjk by default, neither redux or redux-thunk make dispatch({ type: 'REQUEST_NOTE', id }) returning a promise. So which middleware are you using that make it return a promise? \nCheck for yourself: http://www.webpackbin.com/VJ406K4Ub\n\nUncaught TypeError: store.dispatch(...).then is not a function\n\nAlso if redux-saga does not return promises from dispatches and it makes sense for your usecase, you can ask this feature to be added. It seems reasonable for me that the put effect does return the thing that gets returned by store.dispatch, no matter what it is.\n. So, you are dispatching promises, because fetchNote(id) is likely to return a promise. Thus please try what I have written above and if  this does not work open a feature request\n. Hi @jzaefferer \nYou may find my answer here easier to understand:\nhttp://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34623840#34623840\n. @jzaefferer if you don't involve time to understand underlying concepts it's hard to explain you redux-saga in the first place. It is not the typical library that beginners should start with. Plus the redux-saga project is not mature yet so the documentation can probably be made better over time.\nThis is a thunk, in the context of Redux:\n``` javascript\nconst userId = \"123\"\n// Create a thunk (task usually done inside a Flux actionCreator)\nconst thunk = dispatch => fetch(http://data.com/${userId})\n    .then(res => res.json())\n    .then(\n      data => dispatch({ type: 'USER_PROFILE_LOADED', data }),\n      err => dispatch({ type: 'USER_PROFILE_LOAD_FAILED', err })\n    );\n// You can dispatch a thunk\nreduxStore.dispatch(thunk);\n```\nA thunk is not something complicated, and it's well-explained on the page I gave you. If you already use Redux, you must know what a thunk is. If you don't use redux, redux-saga has probably no utility to you, so maybe start first by learning Redux in the first place.\nIt is just a syntactic sugar that is equivalent to:\njavascript\nconst userId = \"123\"\n// Create a thunk (task usually done inside a Flux actionCreator)\nfetch(`http://data.com/${userId}`)\n    .then(res => res.json())\n    .then(\n      data => reduxStore.dispatch({ type: 'USER_PROFILE_LOADED', data }),\n      err => reduxStore.dispatch({ type: 'USER_PROFILE_LOAD_FAILED', err })\n    );\nIn term of Redux, it just permits to be able to handle asynchronous actions (ie calling an API) on the actionCreators instead of your JSX, to have better code organization.\nPlease take a look at these tutorials: \n- https://egghead.io/courses/getting-started-with-redux\n- https://egghead.io/courses/building-react-applications-with-idiomatic-redux\nThese are the best tutorials to Redux you can find out. It will explain thunks. Don't use redux-saga if you don't understand the limited possibilities of redux-thunk. Don't use Redux if you don't see the limited possibilities of React or Flux. Don't use a library if you don't yet understand the problem it tries to solve.\n. @jzaefferer I'm sorry if I feel rude and make you feel dumb, it's not the point of my comment.\nI understand that you might not understand thunks better after my comment, and don't say you are stupid if you don't. But you certainly will once you have watched the Egghead videos.\nWe all agree most people have hard time to understand sagas in the first place, because the doc is not perfect for beginners, because the saga pattern is new to most frontend developers, because we maybe should have called the pattern \"process manager\", and because redux-saga is using cutting edge technologies as implementation details, like ES6 generators and Redux.\nI'll try to explain in a simple way.\nSaga with Vanilla JS and an event bus\nThe simplest explanation of what a saga is basically: \"a process that receive events, and may emit new events (sync or async), aiming to orchestrate complex workflows inside your application\". \nThis saga will handle the fetching of a user profile data, whenever an username is clicked into your system.\n``` javascript\nconst {emit,subscribe} = SomeEventBusSystem;\nfunction setupUsernameClickedSaga() {\n   subscribe(function(event) {\n      if ( event.name = \"USERNAME_CLICKED\" ) {\n         fetch(http://data.com/${event.userId})\n            .then(res => res.json())\n            .then(\n              data => emit({ type: 'USER_PROFILE_LOADED', data }),\n              err => emit({ type: 'USER_PROFILE_LOAD_FAILED', err })\n             );\n      }\n   });\n}\n```\nAs you can see, the concept is quite simple to understand with VanillaJS. I hope you don't mind if I say it's easy, because it really is. You can use this pattern on top of any JS framework you want as long as you have some kind of event bus from which to listen to and to emit new events.\nVanilla JS Saga benefits\nOnce you know what is a saga is, you can understand why it's useful. In this case it permits to handle asynchronous operations (talking to your API), and it permits to avoid polluting your view component with imperative logic, which permits to decouple the components and make them more reusable (but also more complex).\nNow, you can reuse the view component in another context, and maybe in this context a click on the username does not mean that we should load the user profile but something else, like opening chat window with the user instead). This reuse wouldn't be easy if your view was using imperative logic:\njavascript\n<div onClick={e => fetchUserProfile(user.id)}>{user.name}</div>\nYou would end-up with something that become more and more complicated other time\n``` javascript\nfunction handleClick(user) {\n   if ( context = \"openProfile\" ) fetchUserProfile(user.id);\n   else if ( context = \"openChat\" ) fetchChatData(user.id);\n}\n handleClick(user)}>{user.name}\n```\nWhile using saga, the component remains simple and all the coupling will be handled outside of your component:\njavascript\n<div onClick={e => emit({type: \"USERNAME_CLICKED\",userId: user.id})}>{user.name}</div>\nA saga is not suited for simple apps, because it makes the app more complex by introducing a new level of indirection. But more manageable at large scale, particularly if you want to dispatch the work across multiple teams.\nNothing forces you to go all-in about sagas, you can use them for components that you want to reuse or decouple, or maybe just to handle async API communications.\nMore powerful sagas with Redux-saga\nRedux-saga is an implementation of sagas on top of Redux (it actually is not that much coupled with Redux and can be used on top of other event systems).\nThe complexity of Redux-saga is related to the expression of sagas with generators, which mean you need some understanding of what a generator is in the first place, but the concept behind it remains the same.\nThe usage of generators give us an expressive way to describe complex concurrency patterns that is not easy to handle with VanillaJS, and the declarative effects approach it uses makes it easy to test, compared to my initial Vanilla JS saga implementation which requires complex mocking strategies.\nConclusion\nI hope you understand what a saga is and you see the value of using this pattern.\nIf you don't, you are not an idiot. Maybe it will make sense once you really try to use the pattern on a complex app (Redux or not).\nIf you want to use Redux-saga for real, I still recommend that you understand the prerequisites (Redux and ES6 generators). Having worked with thunks is not a prerequisive but will give you some insights on why sagas are nice\n. you can yield an array of effects\n. Hi,\nI agree there is still something missing in doc, even after the updates of @mxstbr in https://github.com/yelouafi/redux-saga/issues/436\nHowever it's quite hard to explain these concepts without entering technical jargon like bounded contexts, polemics like should it be called saga or process manager or workflow or whatever, not to mention that not everybody has an app complex enough where building a non-monolith architecture is an advantage.\nHow could this presented so that the new lib adopter doesn't feel helpless? Note that he also often has to learn generators, so we'd rather not give him to much work at the very beginning :)\n. A saga (as it is in redux-saga, also called process manager) is just a piece of software that receive events and emit new events.\nYou can achieve this pattern in a lot of different ways, including using a custom middleware.\nIt's just the redux-saga impementation based on generators is really interesting as it gives a good testability, and a good expressivity to handle complex currency patterns.\nHere is a concrete example I gave: http://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/38574266#38574266\nGood luck implementing this thing with redux-thunk, or a custom middleware\n. Hi,\nI've often compared redux-saga to an hybrid between imperative programming and free monad.\nThe flow of redux-saga, often using while looks and sequential operations look like imperative programming, but the effects you can yield that are run against an interpreter look like the free monad. The difference between IO and Free is that with Free being that Free uses data structures and can be tested / transformed / interpreted while IO is more like a thunk that can only be run.\nSee also: http://stackoverflow.com/a/34623840/82609\nAfter that I'm not a FP guru.\nDon't know if this thing has been done in other FP languages for now.\nI tried to ask John de Goes which seems expert in Free and didn't found much: https://twitter.com/sebastienlorber/status/763664957846216704\nFor example in Scala, people use Free monad, but they have to chain sequential calls in a monadic way, and can't use imperative logic. In Scala, async/await is implemented as a language extension and uses macros, and it's the closest we have to this imperative style programming afaik. Not sure to have seen the equivalent of JS generators in any languages so far but would be interested to know if there are some :)\n. In the first version, you don't return the fetch, so the generator call does not return anything, it just blocks for the fetch result and does not return anything to the caller generator. Blocking and waiting for result in fetchVersion does not mean it will be returned. Because in fetchVersion you could have waited for multiple promises and the generator could not know which one of the results to return.\nBtw not sure it's really useful to use a generator here: just returning a promise like you did in 2nd attempt is perfectly fine and simpler if you don't need to use take/put/select inside fetchVersion it's not worthy to use a generator.\n. As far as I know, call can be used with normal / sync functions too. The advantage of using call fr a sync function being probably that the call can easily be tested like all other effects, while invoking the function directly without yielding the call would make this harder.\nNot sure my comment is a good example of this as I'm using arrow functions call(() => doSomething()) so it does actually not really help for testability compared to having simply called doSomething() directly.\nI guess call will work fine and maybe handle sync functions returning promises, normal results, array of promises etc... maybe a function returning a generator too?\n. It's like other tests: do you want to unit-test the details of your code, or do you want to do integration tests of the behavior of the saga and your store, without having to deal implementation details.\nI've always felt doing blackbox testing is a superior idea, as testing implementation details means that changing implementation details will likely break tests.\nFor example, do you want to test your classes that are used to build a REST API, or do you want to test the API directly? Personnally I think it's better to test the API directly, and don't care that much about unit tests, except rare cases where it's worth it because the function to test is likely complex and not going to change (like date/math utilities...)\nI guess the subject is also quite related to new debates we've seen on twitter that say it's not really worth it to test React component outputs because when changing React component it will always break the test. That's probably why Jest's snapshot testing feature is gaining interest of the community\nIf redux-saga gives you good testability for yielded effects, it does not mean you have to test all your code in this fashion. \n. Hmmm,\nI don't know, how comes your last code snippet is capable of catching the error? Maybe the task promise only resolves after the parent has been killed, but if a parent is blocking on an effect the exception is reinjected before the parent being killed?\n. Ok thanks :)\nSo in the end do you recommend any workaround in the meantime of a better solution, or should I continue temporarily to use spawnto achieve this result?\n. hmmm yes that looks like a good alternative! thanks\n. What you want to achieve can easily be done by using a top-level reducer that listens for a CHANGE_STATE event, and replace the old state entirely by the new state. \nI'm not an expert in generator syntax but I'm sure it can be done with some code like:\n``` javascript\nfunction saga() {\n  yield changeState((state) => {...state, x:1, y:2});\n}\nfunction* changeState(update) {\n   const state = yield select();\n   yield put({type: CHANGE_STATE, data: update(state));\n}\nfunction liftReducer(reducer) {\n  return (state, action) => {\n    if ( action.type == \"CHANGE_STATE\" ) {\n      return action.data;\n    }\n    else {\n      return reducer(state,action)\n    }\n  }\n}\nconst finalAppReducer = liftReducer(appReducer);\n```\n. Also it looks to me a terrible idea.\nThe initial philosophy of a saga is to listen to events, manage its own internal state, and eventually emit new events.\nThe saga, in the first place, should generally avoid access to redux state. The select effect has been done because it is actually sometimes convenient and can help reduce boilerplate, but it is absolutly optional and for me it's not at all a best practice to rely on select heavily. The saga should be an autonomous component, that does not query other components of the system. Initially it comes from backend distributed systems. It is to consider that the saga is supposed to run on its own microservice, and should not communicate with other microservices with anything else than the event stream. It is generally advised, in distributed systems, that microservices do not access storage of one each others because it creates a lot of mess.\nThis is less dramatic for Redux, but still the same concerns apply. By relying on redux state inside sagas, and not only actions, you actually couple your saga to the state shape you choose for your React application. A properly designed saga should not assume anything about how your UI state is handled or shaped, but should just do its job and emit new events when needed. Actually, the saga should not even have to know that you are using React, or Redux. If you do things properly decoupled, you could switch to backbone and reuse the exact same unmodified sagas.\nIt is also important to emit new events, because these events can be useful for other sagas, or listened to by other pieces of the system (for example an event-tracking system like Mixpanel/GoogleAnalytics/Splunk/GetSentry...). If you modify state in place, it is much harder, later, to introduce these kind of usages. For example, in my app, I recently displayed an error message to the user for every request failure that is not due to the network, as a technical error. If you don't have the request informations as an event, you will have to pollute all your sagas doing api requests with this concern, while this behavior should more elegantly be plugged to the existing system by using a single-purpose technical error notifier saga. \nThe saga somehow express \"if This, then That\". If you never emit an event for That, but only changes the state directly, nobody in the future will have the ability to plug behavior on the That event, that is never emitted.\nYou will also loose some ability for hot code reloading. By changing the state directly in the saga, it's not possible anymore to reinterpret your action log by running it again against an hot-reloaded updated reducer. Redux-saga in its current form will not help you much and it's quite hard to hot reload generators.\n. Hi,\nI understand your point. As far as I understand your delete button is a lot coupled to your delete confirmation popup, and emitting open/close events, and having to maintain a reducer for the popup feel like a lot of complexity.\nIn distributed systems you could say these 2 components are part of the same microservice (or bounded context) that handles the whole deletion of your item. Then if it's perfectly clear that the 2 components and the saga act inside the same bounded context, I think it's fine if all 3 knows about the state shape. I've done that in the past too. \nYour bounded context of the item deletion is composed of a delete button, a delete popup, and a saga that orchestrate the button with the popup. In my app, I call this a \"widget\" and give to this widget a subspace of my Redux store. Ideally, only this widget can select or connect state from its store subspace. The widget act somehow like a microservice which has its own private/internal database, and it's database is actually mounted inside the Redux store. This way we preserve the decoupled advantages.\n\nHowever, for your specific usecase, it's very rare that we need to listen to confirmation popup open/close events from other parts of your system. For example if you add a tracking system you generally only care about the delete action, and you don't need to track actions like confirmation popup delete cancellation. Generally these operations are actually to consider as implementation details of your widget, and maybe it's not worth it to expose them as widget API.\nWhat I mean is, in my opinion, if you are concerned with boilerplate, it's really much easier to handle the delete confirmation popup and the spinner with React local component state. Yes, you will loose the ability to hot reload the confirmation modal and the spinner, but it really isn't a big deal imho unless it's very important to you.\nIf you want the confirmation popup to be appended to the document body (for z-index reasons), I'd recommend using a portal which is very useful to reduce this kind of boilerplate.\nFor example you could have:\njavascript\nReact.createClass({\n  getInitialState() {\n    return { confirmationPopup: false };\n  },\n  render() {\n    return (\n       <div className=\"delete-item-widget\">\n          <div onClick={() => this.setState({confirmationPopup: true})}>Delete item</div>\n          {this.state.confirmationPopup && (\n              <Portal>\n                 <ConfirmationPopup \n                      onCancel={() => this.setState({confirmationPopup: false})}\n                      onConfirm={() => this.props.onDelete())}\n                 >\n              </Portal>\n          )}\n       </div>\n    );\n  }\n})\nEven if the portal is deeply nested, it gets appended to document body.\nFor \"positionned portals\" you can use react-tether which is extremely convenient and permit to avoid the mess of relative positionning and z-index management.\nFor spinner, you can also use local component state, and make your actions return promises. It can also be helpful if you make the prop functions (onDelete) return the deletion promise, so that deeply nested components can eventually decide to show a spinner.\nDoing all this will generally reduce a lot the boilerplate of your application, and in my experience the tradeoff for using these shortcuts is not a big deal\nNote there are projects like redux-react-local of @threepointone which permits to mount React local component state to Redux store, and use component-level sagas if you need that.\n. yes @tobyl , you can also use a regular javascript loop instead of a foreach for imperative style login, as we stay in the generator execution context.\nforeach does not work, but it would probably be simply to create an util to emulate it.\nNote that if only one promise fail, you won't get a newArray at all\n. hmmm yes I think I'll implement that myself then :) thanks\nHope to have some time to work on a redux-saga-utils project\n. not sure what you mean by configurable helper :) won't it be the same problem as with takeEvery/takeLatest and require a complex implementation to avoid using generators?\n. Hmmm not sure to understand the the fsmIterator nor why it couldn't be applied to takeLatest as well but if you say so why not :)\nIt would probably be better to provide saga wrappers, like your retry example IMO\n. Thanks, I understand better now.\n. I'm simply doing this and it works fine for months. Still catching in while loop looks to me a good idea in order to handle retry in case of failure. Probably quite equivalent to your solution.\njavascript\n    sagas.forEach(saga =>\n      runSaga(saga,reduxSagaIO)\n    );\n. @Andarist to avoid killing all the sagas on any single http call error\nRelated to https://github.com/yelouafi/redux-saga/issues/570\n. That's right @Andarist :) still I believe sagas should be isolated from each others, it's easy to forget catching errors and make your whole app unusable\n. @granmoe uncatched errors are automatically logged as far as I know so it's not really worthy to catch just for logging unless you customize error message\nThere are multiple ways that you can do.\nPersonnally in my app I'm simply doing:\nsagas.forEach(saga =>\n      runSaga(saga,reduxSagaIO)\n    );\nBut this is quite equivalent of spawing multiple childs in a root saga as far as I know\n. @granmoe I have a special setting, because I actually make Redux-saga work on top of a legacy framework I have that is not redux (we'll migrate someday to redux)\n. @vanhtuan0409 instead of emitting a LOAD_REPO event, you can emit LOAD_REPO_REQUESTED\nThen you have a saga, that will decide weither or not to fire a LOAD_REPO\nI think this is what @Andarist proposed as well and it does not seem unnatural to me at all. \nWhat feels unnatural is to dispatch a LOAD_REPO action, and to expect that in some cases it does not lead to any loading at all :)\nMaybe you can take inspiration from this notification system I've build, which use a similar pattern:\nhttp://stackoverflow.com/a/38574266/82609\n. @Andarist for me your solution is fine, I was about to suggest something very similar. Maybe it could be simpler to just return a chan and have an end event signaling that the upload did complete, maybe with a status? Seems to me that there's a little intersection in functionality between using both a stream + a promise, and that just a stream would be enough.\nAnother problem is that for the saga to kick in it generally has to wait for a UPLOAD_STARTED event, and handling that inside a saga means that user is likely to pass unserializable content inside a Redux action, which is not a very good idea in the first place.\nFor such case, I'd rather use a thunk, or a RxJS-based middleware so that it does not require putting File / Dom events directly inside the sagas\n. I agree that in my project it creates some useless logging statements.\nHowever they are still useful when something is going wrong and you want to debug sagas without plugging the monitor :)\n. stample.co \n\n. as long as the feature is not removed I'm not against an api change if you need it. @fzaninotto unfortunatly it's like asking for JS std to recommand a prefered way to iterate over an array, while there are usecases for forEach, for, map, iterator...\nWe can't really recommend a way to start root sagas however we can certainly explain better the effect. I think it's probably worth creating a dedicated documentation page.\nyour examples\n1)\njavascript\n// single entry point to start all Sagas at once\nexport default function* rootSaga() {\n  yield [\n    saga1(),\n    saga2(),\n    saga3(),\n  ]\n}\nHere the 3 sagas will be run in parallel. The root saga will block until the 3 sagas complete. If one of the 3 fail, the error will be propagated to the root saga which will be killed, which will also kill the other 2 saga \n2)\njavascript\nexport default function* root() {\n  yield [\n    fork(saga1),\n    fork(saga2),\n    fork(saga3)\n  ]\n}\nThe only difference I see here is that this time the yield effect will not block because forking is non-blocking, thus the root saga will reach the end but the 3 childs will remain alive. Error behavior is the same as 1)\n3)\n```javascript\nexport default function* root() {\n  yield fork(saga1)\n  yield fork(saga2)\n  yield fork(saga3)\n}\n````\nI don't see any difference in behavior from 2) \n\nbetter examples\nThe problem with forking is that if any of the root saga fails, then the root saga will be killed, and the other sub sagas will also be killed because their parent got killed. In practice this means that your whole app may become unusable (if it relies heavily on sagas) just because of a minor saga error so it's not really good.\n4)\n```javascript\nexport default function* root() {\n  yield spawn(saga1)\n  yield spawn(saga2)\n  yield spawn(saga3)\n}\n````\nThis time, if an error occur in saga1, it will not make root, saga2 and saga3 get killed so only a part of your app stops working in case of error. Somehow this can also be very problematic because the saga1 might be killed due to an error like a failing http request that you didn't catch properly, making the whole feature covered by saga1 unavailable for the app lifetime.\n5)\n@granmoe has suggested the following way to start sagas in: https://github.com/redux-saga/redux-saga/issues/570\n```javascript\nfunction* rootSaga () {\nconst sagas = [\n    saga1,\n    saga2,\n    saga3,\n  ]; \nyield sagas.map(saga =>\n    spawn(function* () {\n      while (true) {\n        try {\n          yield call(saga)\n        } catch (e) {\n          console.log(e)\n        }\n      }\n    })\n  )\n}\n```\nThis time, if any of the 3 sagas had an error, it would be automatically restarted. This may, or not, be the desired behavior according to your app.\n6)\nHere's how I handle sagas in my own app:\n```javascript\nconst makeRestartable = (saga) => {\n  return function () {\n    yield spawn(function () {\n      while (true) {\n        try {\n          yield call(saga);\n          console.error(\"unexpected root saga termination. The root sagas are supposed to be sagas that live during the whole app lifetime!\",saga);\n        } catch (e) {\n          console.error(\"Saga error, the saga will be restarted\",e);\n        }\n        yield delay(1000); // Avoid infinite failures blocking app TODO use backoff retry policy...\n      }\n    })\n  };\n};\nconst rootSagas = [\n  domain1saga,\n  domain2saga,\n  domain3saga,\n].map(makeRestartable);\nexport default function* root() {\n  yield rootSagas.map(saga => call(saga));\n}\n```\nI'm using a saga HOC to add error handling to the root sagas. In my app, all root sagas are never supposed to terminate but should block, and if there are errors they should be automatically restarted.\nRestarting synchronously can, in my experience, lead to infinite loops (if the saga fails everytime you try to restart it) so I added a hacky delay for now to prevent this issue.\nYou mentionned different domains in your app so this pattern seems appropriate to your usecase where each domain should somehow have its own root saga.\n\nIf this is helpful I can write something like that in the doc.\nNote that I didn't mention runSaga. You can easily start root sagas through this tool, and it will behave like spawned sagas\nSee also this SO answer. > you say you can't make redux-saga doc and code consistent, but I don't understand why\nCode and doc can be consistent, and we certainly all want that, but it does not mean that there's a \"best way\" to start root sagas, just that we can explain the different options.\nI'm not either officially from redux-saga team, and everybody can contribute to the doc if something is not clear enough.\n\nyou say in example 1) the root saga blocks, but since most of the underlying watches use takeEvery, which implicitly fork in 0.14 if I'm not mistaken, then it's not blocking.\n\nThe root saga blocks if any subtask blocks. If all subtasks are not blocking then the root saga will terminate as well because there's nothing to wait for.\n\nexample 4 uses spawn, which is not the default way to make non-blocking calls according to the documentation (it's fork). I tried to understand the difference between spawn and fork by reading the related doc, and my brain melted.\n\nForked tasks will be killed when the parent is killed, while spawned tasks will be kept alive (and you will have to cancel them yourself on errors if you don't want them to keep running)\nspawned sagas are a bit like new root sagas that you can start directly from deeper levels.\n\nexamples 5 and 6 add to the confusion: are they better than the others? Should we forget about all the previous examples and use these? I'm really looking for a simple answer.\n\nIMHO they are for root sagas, but it's only my opinion and my usecase. And this only applied for root sagas because generally on deeper level you might want errors to propagate.\nYou might be interested to read as well: https://github.com/redux-saga/redux-saga/issues/570\n\nthinking that users will understand the intricacies of these choices makes redux a bit too elitist IMO. I'm a long time ES6 developer, and I still don't understand what I'm supposed to use in my use case. You'd better choose the best method, and use it all around the doc and say \"that's the only way you should do\", without explaining how it works under the hood. Much better Developer Experience!\n\nRedux-saga is probably not yet mature enough and the doc could certainly be better. We are all figuring this out together but as we are iterating progressively according to usecases we find, it becomes clearer over time.\nIt's true that a lot of information is currently hidden in github comments, and at some point we should probably make the doc better including the most useful comments.\nFeel free to apply some techniques mentionned in comments, and give feedback so we figure out together what to recommend to the users\n. @anthonychung14 try running something like that and you'll see that the main thread stays in Redux-saga forever, freezing your browser tab:\n```javascript\nfunction* alwaysFailingSaga() {\n  throw new Error(\"boom\");\n}\nfunction* rootSaga() {\n      while (true) {\n        try {\n          yield call(alwaysFailingSaga);\n        } catch (e) {\n          console.error(\"Saga error\",e);\n        }\n      }\n    }\n```\nYielding a little delay between restarts make room for the browser to execute other things as well.\nThis is not a production problem, more related to developer experience when you have a big bug in one of your saga you may not like it to freeze your browser. It's very unlikely that you don't notice this bug locally and you ship it to production.. @jedrichards yes redux-saga is an generator runtime interpreter with addons to work nicely with redux, but it's low level and does not really provide any recommendations on how you manage your sagas over time, it's just a toolbox.\nWe've already discussed in the past the creation of an extra repository for useful addons and patterns (including takeLatest/takeEvery/throttle/debounce/error handling/bootstrapping etc) and it's likely someday someone will do that.\n@fzaninotto I don't think spawn is only for advanced usage, it's kinda important for the sagas startup usecases like this one and you might need it in other cases too\nFor me 1) 2) 3) should be avoided for app startup unless you catch carefully errors in each subsaga and do not let them propagate to parent who'll terminate and kill everything. Using spawn or runSaga seems safer to me but it only isolate the failure to a branch of your system and won't handle potential restart that's why I'm using 6 which is more resilient.. @anthonychung14 I don't know what you tried so I can't say. You should be able to add logs to debug why your saga does not restart. In my 6th example there are logs that might help you understand what is happening.\nAbout the 1sec delay, it's just a simple restart strategy. If you want something more advanced I'd recommend looking at what actor systems use as supervision strategy\n\nDelayed restarts with the BackoffSupervisor pattern\nProvided as a built-in pattern the akka.pattern.BackoffSupervisor implements the so-called exponential backoff supervision strategy, starting a child actor again when it fails, each time with a growing time delay between restarts.\nThis pattern is useful when the started actor fails [1] because some external resource is not available, and we need to give it some time to start-up again. One of the prime examples when this is useful is when a PersistentActor fails (by stopping) with a persistence failure - which indicates that the database may be down or overloaded, in such situations it makes most sense to give it a little bit of time to recover before the peristent actor is started.\n. Don't focus on 1sec it's a random value I pick because I didn't have time to implement something better. The only thing to remember here is that if there's no delay between restart attempts, then you might have a saga that continuously tries to restart itself and freeze the current tick. It probably works with 0sec delay too as long as you let some space for other work to happen. . yes @granmoe I want it to try to restart it forever. But I want to give the UI thread some time between restarts to avoid freezing the UI, that's all. There's no best solution, just a solution that works for your usecase. Just try your webpackBin without the delay and you'll immediately understand that it's painful DX to have to kill your chrome tab and reopen it in case of typo. Yes @henninghall yielding arrays is deprecated for quite a while I think. There used to be a deprecating warning but I guess 1.0.0 did really made the breaking change. Hi,\n\nI don't have much feedback to provide here as I don't really need to restart sagas imperatively, in my usecase I just need root sagas to be kept alive for the whole app lifespan.\nOne important thing I noticed in my app is that it can be very annoying if we restart sagas without a backoff policy. It can lead to infinite execution loops that may lock the main thread and the whole browser very badly. In my app I'm currently adding a delay between restarts, as a workaroud to let some space to the thread to execute some code. \nSo I'd just recommend to make sure that new effect does not lead to such problems.\nHere's my current code:\n```javascript\nimport {\n  runSaga,\n  delay,\n} from \"redux-saga\";\nimport {\n  spawn,\n  call,\n} from \"redux-saga/effects\";\nimport mainContentSaga from \"widgets/mainContent/common/sagas/mainContentSaga\";\nimport folderSelectionDefaultTargetUpdaterSaga from \"sagas/folderSelectionDefaultTargetUpdaterSaga\";\nimport stampleWillUpdateSaga from \"sagas/stampleWillUpdateSaga\";\nimport navBarSaga from \"widgets/navBar/navBarSaga\";\nimport toastSaga from \"widgets/toast/toastSaga\";\nimport subscriptionBannerSaga from \"widgets/subscriptionBanner/subscriptionBannerSaga\";\nimport stampleFullScreenSaga from \"widgets/stampleFullScreen/stampleFullScreenSaga\";\n// See https://github.com/redux-saga/redux-saga/issues/570\nconst makeRestartable = (saga) => {\n  return function () {\n    yield spawn(function () {\n      while (true) {\n        try {\n          yield call(saga);\n          console.error(\"unexpected root saga termination. The root sagas are supposed to be sagas that live during the whole app lifetime!\",saga);\n        } catch (e) {\n          console.error(\"Saga error, the saga will be restarted\",e);\n        }\n        yield delay(1000); // Avoid infinite failures blocking app TODO use backoff retry policy...\n      }\n    })\n  };\n};\nconst rootSagas = [\n  mainContentSaga,\n  toastSaga,\n  navBarSaga,\n  subscriptionBannerSaga,\n  stampleFullScreenSaga,\n  folderSelectionDefaultTargetUpdaterSaga,\n  stampleWillUpdateSaga,\n].map(makeRestartable);\n// Adapter to make Redux-saga work on top of legacy atom-react framework\nconst makeIO = (atomReactContext) => ({\n  dispatch: events => atomReactContext.publishEvents(events),\n  subscribe: listener => {\n    const callback = event => {\n      listener({...event, type: event.name})\n    };\n    atomReactContext.addEventListener(callback);\n    return () => atomReactContext.removeEventListener(callback);\n  },\n  getState: () => atomReactContext.getState(),\n});\nexport const startSagas = (atomReactContext) => {\n  const IO = makeIO(atomReactContext);\n  rootSagas.forEach(saga =>\n    runSaga(saga(),IO)\n  );\n};\n```. Hi,\nCurrently in my app I don't do code-splitting so I can't provide real feedback on that.\nOne interesting approach is react-redux-saga (cc @threepointone) which will probably help people who want a saga to live only for a given route (like react-router), so it should work fine with code splitting as long as it's already setup for JSX components.\nHowever I'm not really advocating JSX-based routing, and this approach won't work with redux-tower of @kuy \nIt may be opiniated, but I think root sagas are special. In my app, they generally tend to live from begin to end, or at least from the whole route lifespan. Maybe it could be useful to have a saga HOC that permit to cancel both forked and spawned tasks on failure, and be the default for any task started with runSaga?. Hi,\nFunny as I'm also working on getSentry.\nI think it accept big JSON states yes.\nIt would only be for conveniency because you can easily call store.getState() directly in your error listener, I'm not sure it's worth changing the signature of onError just for this usecase. You can easily figure this out:\n```javascript\nconst log = () => setTimeout(() => console.debug(\"timeout\"),0);\nfunction* root() { \nlog(); \n  yield fork(saga1);\n  console.debug(\"after yield\");\nlog(); \n  yield spawn(saga2)\n  console.debug(\"after yield\");\nlog(); \n  yield put(event);\n  console.debug(\"after yield\");\n}\n```\nDidn't run but IMHO all 3 effects are non blocking and will execute before any \"after effect\" log statement.\nFor put effect doc also mentions a blocking put.resolve(action).\nDon't know the subtilities of all the effects but IMHO non blocking ones do not involve any context-switch.. Aren't you confusing takeEvery and takeLatest?\nAre you sure your initSaga  isn't run multiple times concurrently?\nInstead of takeEverySync why not using take directly?. I never used put.resolve yet so I don't know maybe there's a bug somewhere...\nAre you sure you aren't calling multiple times initSaga?\nSorry but I'm not really sure to understand what you are trying to dispatch with yield put.resolve(INIT1, 1)); there's an extra bracket and put effect does not take 2 arguments. How can you be so sure that this effect is not blocking? Does dispatching it directly through reduxStore.dispatch(action) block? Have you setup some kind of batching redux middleware?. @alanwei0 like the DOM fire events that you may choose to handle or not, you can do the same with Redux. It's not a bad practice to decouple action producing from action handling in more complex apps, and any action can be handled by 0 - * reducer\nMaybe reading this would help: https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/. @alanwei0 it depends on your conventions, but the saga pattern implemented originally in this library comes from event-sourced backend systems where we consider that every state change is triggered by an event and the saga can handle those events as well as the reducers/query view side\nAlso note that Redux is also inspired by such systems in the first place.\nIMHO it has been a wrong theorical decision for the Flux team to create the name \"action\", but it certainly helpex Flux to gain adoption because the event-sourced theory is less idiomatic for newcomers\nSo I'd say you can use the lib the way you want in the end, but have to know that it takes origin from a world where the term \"action\" does not exist, in favor of \"commands\" and \"events\"\nSee also: http://stackoverflow.com/a/34623840/82609. @kelsonic since React itself is not supporting IE8 anymore I'd rather not expect tooling created around React ecosystem to be compatible with older IE browsers.\nhttps://facebook.github.io/react/blog/2016/01/12/discontinuing-ie8-support.html. \nHi, I can't provide much feedback @Andarist I don't have used much channels so far. Actually in my app I have an array with like 10 actions if I could avoid\nmaintaining that list it would be better :p\nLe jeu. 24 janv. 2019 \u00e0 08:11, Mateusz Burzy\u0144ski notifications@github.com\na \u00e9crit :\n\nCould we maybe use conditional types and do some fancy stuff like:\ntype Unpack = T extends Array> ? ActionPattern : T\nNote that actual type names are probably different, I'm not using saga\ntogether with TS and I dont have correct type named remembered by heart.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/1740#issuecomment-457091238,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAtvPrJMuAS1ZheZquD35HVfNXbRGeRdks5vGVy6gaJpZM4aO5Mc\n.\n. Hi @aikoven and thanks for your update\n\nmigrating to 1.0 is not in my priority anymore and don't have much time, so let's consider it's working and if I don't reopen later or someone else, then it's fine ;). ",
    "tomkis": "\nBasically I was thinking about giving each saga an ID (internally) and notifying which saga is parent to which saga by embedding \"parent ID\" into every parent-child effect. So this would give us the call tree.\n\n@gaearon Can you please elaborate on this? Did I understand it correctly, that you would like to have an user interaction defined transaction boundary? Let's say onClick these actions have been dispatched:\n- CLICKED_FOO\n- API_STARTED\n- API_FINISHED\n. @gaearon in that case isn't this slight modification of redux-thunk melted into store enhancer exactly what we need?\n``` javascript\nconst storeEnhancer = storeFactory => (reducer, initialState) => {\n  let correlationId = 0;\n  const store = storeFactory(reducer, initialState);\nconst wrappedDispatch = action => {\n    correlationId++;\nif (typeof action === 'function') {\n  // The idea is to wrap dispatch only for thunks (which defines UI interaction transaction boundary)\n  return action(dispatchable => store.dispatch({...dispatchable, correlationId}), store.getState);\n} else {\n  return store.dispatch({...action, correlationId});\n}\n\n};\nreturn {\n    ...store,\n    dispatch: wrappedDispatch\n  };\n};\n```\nGiven two action creators:\njavascript\nconst simpleActionCreator = () => ({type: 'SIMPLE'});\nand\n``` javascript\nconst thunkActionCreator = (dispatch, getState) => {\n  dispatch({type: 'THUNK_STEP_1'});\n  dispatch({type: 'THUNK_STEP_2'});\nsetTimeout(() => {\n    dispatch({type: 'THUNK_STEP_3'});\n  }, 500);\n};\n```\nwhen called sequentially\njavascript\ndispatch(simpleActionCreator());\ndispatch(thunkActionCreator);\nwill dispatch these actions:\njavascript\n[{type: 'SIMPLE', correlationId: 1},\n{type: 'THUNK_STEP_1', correlationId: 2},\n{type: 'THUNK_STEP_2', correlationId: 2},\n{type: 'THUNK_STEP_3', correlationId: 2}]\n. Because the implementation is exclusive with thunk-middleware it must allow recursive thunk dispatching, therefore slight modification. The implementation does not break any middleware chain and all the middlewares get applied:\n``` javascript\nconst storeEnhancer = storeFactory => (reducer, initialState) => {\n  let correlationId = 0;\n  const store = storeFactory(reducer, initialState);\nconst thunkMiddlewareWithCorrelationId = id => action => {\n    if (typeof action === 'function') {\n      return action(thunkMiddlewareWithCorrelationId(id), store.getState);\n    } else {\n      return store.dispatch({...action, correlationId: id});\n    }\n  };\nconst wrappedDispatch = action => {\n    correlationId++;\nreturn thunkMiddlewareWithCorrelationId(correlationId)(action);\n\n};\nreturn {\n    ...store,\n    dispatch: wrappedDispatch\n  };\n};\n```\nEDIT: Reflecting the tree structure of correlation ids is fairly simple, you can display in devtools the exact async thunk hierarchy.\nAlso the cool thing about this is that it replaces redux-thunk for development, the functionality is no different except it provides some additional action metadata. Therefore we can use this enhancer for development and swap it for redux-thunk in production.\n. @AriaFallah IMO it's just a matter of taste - if you prefer imperative approach then choose generators, streams are more declarative.\nFor some people (I would say majority) generators are easier to understand but Streams are in some situations more powerful. Need debounce? Just debounce the stream... need double clicks just buffer stream... etc.\nAPI of RxJS is definitely really powerful and I am all excited how community utilizes the fact.\nJust a side note between redux-saga and redux-saga-rxjs is no difference, both works the same. Saga pattern in Redux is just a simple map function which maps incoming actions to another actions (potentially asynchronously). And the proof is simple - redux-saga is basically using a form of async generators even though it's not directly using its API.\n\nThis proposal has been withdrawn. For a more updated (and smaller scoped) proposal, see Observable in ES2016 [https://github.com/zenparsing/es-observable]\n\nSee? There's no difference between Observable and Async generator.\n. redux-saga-rxjs does not provide DevTools yet. However, streams can be really nicely visualizable (http://jaredforsyth.com/rxvision/ or rxmarbles.com) - just imagine the devtools we could build on top of it - your complete asynchronous code could be visualized as it goes.\n. My suspicion is that this issue is definitly bug in redux-elm please @eliperelman feel free to file the issue there and let me investigate closer in redux-elm context. We would file the issue here after deeper investigation in redux-elm.\nThis can be closed.\n. Frankly, I am not that much concerned about advanced techniques, this can be covered later and I do not think it should be part of the documentation but rather someone should write really good practically oriented article.\nPerhaps, inverting a way information are presented would be a good start, eg:\n\nredux-saga is a library that aims to make side effects (i.e. asynchronous things like data fetching and impure things like accessing the browser cache) in React/Redux applications easier and better.\n\nshould rather be\n\nredux-saga is a library that aims to make asynchronous things like data fetching and impure things like accessing the browser cache in React/Redux applications easier and better.\n\nand then as the side note would be something like\n\nalthough the main goal is dealing with asynchronous things, it still important to realize that it's possible to handle side effects with redux-saga because....\n\nEDIT: and of course obviously changing the repo description is necessary\n. > I'm using Side Effect with the pure FP meaning. Long lived transactions is just one aspect that arises from the nature of Side Effect\nInteresting, I've been always thinking vice versa, but yeah, in pure FP meaning it indeed makes sense.\n. ",
    "SoftMemes": "This is amazing stuff! I've recently started to look at Redux, didn't like redux-thunk, found redux-saga, started thinking about how to make sagas more explicit, and here we are!\nWhat I would love to see is a way to fully recreate the state of an app, not just the store/view, but also the implicit state of sagas.\nIs the idea here that eventually you could do this by replaying the event stream, and whenever a saga calls a function, automagically turn that into a take on the event representing the effect being resolved?\n. Catching up on everything redux and came across https://github.com/yelouafi/redux-saga/issues/5.\nAssuming there already is a log of all past effects (as per above issue), appropriately interleaved with other events, there shouldn't be any need for explicit memoization in order to \"dry run\" effects. When replaying, could not a call() be turned into a take() on the event that represents the already known result? Likewise, puts would be ignored as they \"have already happened\".\nThis would cause problems when the logic / control flow of the saga changed as per comments made already, but with enough information stored about the effects, this could be made quite clear, i.e. you could flag that \"last time, the saga was waiting for something else at this point\".\n. ",
    "jfrolich": "I currently have an application that has all asynchronous logic in sagas. The problem I ran into is that the saga middleware spits out a huge amount of EFFECT_RESOLVED and EFFECT_TRIGGERED actions. This makes it hard to analyse the application state over time in the regular devtools. Any solution for this (maybe muting a way of muting these actions?).\n. Awesome Dan, I should have checked for a solution before posting. Cheers!\nOne thing it does not solve is for instance if we also have a logger. For my quite simple app with sagas it is spitting out 1k actions. Maybe there is a way to reduce it?\n. Great this helped a lot! I know it's better to pull actions, but this is a good workaround!\n. ",
    "mjrussell": "@jfrolich redux-logger has a predicate in the config object to drop or print the given action:\nhttps://github.com/fcomb/redux-logger#options\n. @cherta many people are moving towards redux-simple-router which uses a middleware approach rather than a store enhancer and will work with React-Rotuer v2. You might give that a shot instead.\nI like this approach as well because you could create a saga that does things like preventing users from going to /object/:objectId when objectId is invalid due to your store's collection of objects. Currently that logic has to get pushed into the connected components which seems like the wrong place for such actions.\n. @cherta they just supported the full location object in the 2.x release which is far better than they had previously. The only thing now thats missing is the router param id auto parsing.\n. Please let me know how it ends up working for you, I'm pretty interested in using sagas with routing (just haven't gotten to it quite yet) so I'd  be very interested to hear how it goes\n. @cherta thanks! This is definitely cool. I was thinking of using saga in a slightly different way (rewriting the url on invalid selections) but its helpful to see your approach here!\n. If you use Redux-simple-router you actually can replay history (except currently for POP operations because its already been popped off).\nI agree React-Router alone can kind of feel that way, however efforts like redux-router and redux-simple-router are trying to be more \"redux-pure\" and have the store drive the url bar\n. FYI the main difficulties in the test start to happen here: https://github.com/yelouafi/redux-saga/pull/45/files#diff-fe2186b9207791d7c78cdf4eb20515feR25\n. Also I havent used tape before so I think the \"integration test\" never ends for some reason, my mocha/chai test has a clean exit\n. @yelouafi Thanks for the reply. Yeah I think the core of the issue is on testing the fork task, and I like your proposed syntax on #47.\nI am also curious as to why this passes on 0.4.1 and not on 0.5.0, was there a breaking change in how call works?\nIn general would you tell people to avoid using the runSaga as a testing method and stay to the behavior driven? Otherwise it does seem like we are testing redux-saga as much as our own code.\n. Here's the output running against master (same for 0.5.0) and the branch\n```\nbehavior spec\n\u2714 Waits for start\n\u2714 Starts the task sync for an item\n\nfully running\nanonymous: uncaught [Error: call/cps/fork first argument must be a function, an array [context, function] or an object {context, fn}]\n\u2716 Error: call/cps/fork first argument must be a function, an array [context, function] or an object {context, fn}\n------------------------------------------------------------------------------------------------------------------\n  operator: fail\n  at: run (/Users/matt/Hacking/redux-saga/node_modules/babel-polyfill/node_modules/core-js/modules/es6.promise.js:104:47)\n\nFailed Tests: There was 1 failure\nfully running\n\n  \u2716 Error: call/cps/fork first argument must be a function, an array [context, function] or an object {context, fn}\n\ntotal:     3\n  passing:   2\n  failing:   1\n  duration:  7.1s\n```\n. > In 0.4.1, you can call fork directly on an iterator (yield fork( saga() )). In 0.5.0 it was removed, and fork must be called as call and cps (sorry, forgot to mention this in the releases notes). so it should be (syncSaga without ())\nAha! Thanks, updated and working now.\n. @yelouafi awesome thanks, I can close this then unless it would be worth cleaning it up with the examples and new way for mocking forks\n. > maybe we should change the title tasks to something more informative (kind of saga-test-sample)\nWill do!\n. Sorry I didn't get around to this sooner, been busy. I think theres a benefit to add some advanced testing examples to the docs/examples and will open a new PR when I find a little more time.\n. @aft-luke I just created a PR (more like a discussion) about possibly similar issues with testing #45 \n. I ran into the same issues, but ended up with a different solution. This is essentially using a link-list approach to queue up the messages:\n``` js\n// Creates a chain of message promises, each promise (when resolved) has a payload and nextPromise \n// to wait for the next message\nfunction socketMessageChain(socket) {\n  let resolveNext;\n  const headPromise = new Promise(resolve => resolveNext = resolve);\nsocket.onmessage = event => {\n    const resolveThis = resolveNext;\n    const nextPromise = new Promise(resolve => resolveNext = resolve);\n    resolveThis({ payload: JSON.parse(event.data), nextPromise });\n  };\nreturn headPromise;\n}\n``\n. It seemed like the unpacking due toconst { stop, update } = yield race({ended up causing a null point. I can double check though\n. Ah yeah my bad, closing this\n. One example of usingtakewithdelay` where (I think) you dont run into this kind of issue\n``` js\nwhile(true) {\n  let interval = 5;\n  yield put({ type: FETCH });\nconst { stop, start } = yield race({\n    delay: call(delay, interval),\n     start: take(Constants.FETCH_START),\n     stop: take(Constants.FETCH_STOP),\n  });\nif (stop) {\n    break;\n   } else if (start) {\n    interval = start.payload;\n   }\n}\n```\nMaybe its that the worker sagas cant yield a take at the \"top level\"?\n. @prashaantt you can listen to any actions inside your sagas using take so why not just dispatch an action from componentWillMount or componentDidMount to kick off your saga? For listening to route changes, I'd look at #37\n. Also check out how the examples work. Counter is pretty simple and shows button clicking leading to work being done inside a saga\n. @patrickheeney I was implementing something similar recently for code splitting with both reducers and sagas. Its working quite well, although the sagaRegistry has to be implemented a bit differently from the reducerRegistry. \nWith reducers, you can easily trigger store.replaceReducer(createReducer(reducers)); on each route change because the reducer is pure function without side effects and the store data is held elsewhere.\nWith the sagas, however, it would be incorrect to both (1) run the all the sagas store in the registry and (2) re-run sagas that have been started for the route. \n(1) is pretty easy to solve by just only sending to the change listener the new saga\n(2) seems a bit more tricky, you could (a) use the name of the function as only fire off new names, or  (b) send a key in the sagaRegistry.register and only emit a new change for a new key.\nIm currently doing (1) and (2b) but I'd be interested to hear how others tackle the problem\n. @pke check out https://github.com/reactjs/redux/issues/37 for more details on code splitting with reducers. Its got a great explanation by Dan Ambramov about the process and workflow.\n. @johanneslumpe AFAIK you cannot hot-reload a saga. Changes to sagas during hot reloading should force an entire app refresh. What I do is pass in a \"key\" of the saga to a registry which calls sagaMiddleware.run. And I only run a saga when I register a saga with a key that is different from any key I've registered before. This is because the registration exists inside the getComponent call in a React Router <Route> which is invoked on every route enter/change. @yelouafi thanks, and no worries on the late response, I know you've been quite busy with the Docs (which are coming along great).\nYeah missed the first curried param, your example is what I was thinking. Seems like using memoize will definitely work, not sure why I didn't think of that :smile: \nI was thinking back to how sagas with call works where you test the fact that you will yield call with certain args rather than the equality of call after evaluating it.\nI can definitely use the memoize for now though\n. :+1: for throwing this in the docs in section called like \"Observables vs Sagas\"\nReally great post!\n. :+1: for a chat location so we don't have to fill up the issue tracker with general questions about writing sagas/best practices. Maybe can request a chat channel in the Reactiflux discord? Seems like this project is getting big enough. \n@gaearon probably knows more about that process.\n. @5h1rU the worker saga gets passed the action after being started with takeEvery. So in your case, change the worker to:\njs\nfunction* userSaga ({ id }) {\n  let response = yield call(callApi, {\n    endpoint: `patients/${id}`,\n    method: 'GET'\n  });\n  if (response.statusCode >= 200 && response.statusCode < 300) {\n    yield put({ type: USER_SUCCESS, response });\n  } else {\n    yield put({ type: USER_ERROR, response });\n  }\n}\n. I think I recently ran into this, and I just want to make sure I understand it completely and the path going forward (next release):\nOriginally I had something like this:\n``` js\nconst { itemA, itemB } = yield race({\n   itemA: take(queueA),\n   itemB: take(queueB),\n});\nif (itemA) {\n  // Do stuff with A\n} else if (itemB) {\n // Do stuff with B\n}\n```\nAfter reading this it seems like what is happening is that there can be a case where both take's resolve (one of the queues sources is from a socket and the other from a store dispatch) and therefore I have both itemA and itemB as non-null. And since I've got an else if, the code skips doing anything with itemB when itemA is non-null. This seems like an easy bugfix on my end, just moving to two if statements.\nSo my question is how would this look following the \"fix\"? Would my original code have been correct?\n. Sorry for not responding sooner, I was focused on #598. Thank you for the responses, I tried to over simplify my example and then ended up having bugs/typos in the example \ud83d\ude1e \nI got confused about the difference between the effect descriptor and the actual channel in my testing at first. I was trying to pass back into the generator the result of actionChannel but I needed a mocked channel instead as @Andarist pointed out. Im going to post a quick example below in case other people run into this.\n``` js\nfunction* channelSaga() {\n  const chanA = yield actionChannel('TYPE_A');\n  const chanB = yield actionChannel('TYPE_B');\nwhile (true) {\n    const { a, b } = yield race({\n      a: chanA,\n      b: chanB,\n    });\nif (a) {\n  yield put(a);\n} else if (b) {\n  yield put(b);\n}\n\n}\n}\ndescribe('Testing channelSaga', () => {\n  it('Can unit test', () => {\n    const generator = channelSaga();\nlet next;\nnext = generator.next();\n\nconst mockChanA = channel();\nconst mockChanB = channel();\n\nexpect(next.value).to.deep.equal(actionChannel('TYPE_A'));\nnext = generator.next(mockChanA);\n\nexpect(next.value).to.deep.equal(actionChannel('TYPE_B'));\nnext = generator.next(mockChanB);\n\nexpect(next.value).to.deep.equal(race({\n  a: mockChanA,\n  b: mockChanB,\n}));\n\nnext = generator.next({ a: { type: 'TYPE_A' } });\nexpect(next.value).to.deep.equal(put({ type: 'TYPE_A' }));\n\nnext = generator.next();\nexpect(next.value).to.deep.equal(race({\n  a: mockChanA,\n  b: mockChanB,\n}));\n\nnext = generator.next({ b: { type: 'TYPE_B' } });\nexpect(next.value).to.deep.equal(put({ type: 'TYPE_B' }));\n\n});\n});\n```\n. Also looking forward to alternative ways of testing, agree that using a mock store or some other approach is probably better long term so your tests aren't so tightly coupled to the implementation details of the saga\n. Sure...its a bit long but here goes:\njs\nexport function* appSocketForwardParser(app, parser, forwardForApp = isForwardForApp(app),\n  parseResponseForApp = isParseResponseForApp(app), parseFrame = parseAppFrame) {\n  // Map from sequenceId to the parser responsible for it\n  let parsersBySequence = {};\n  while (true) {\n    const { parseResponse, forward } = yield race({\n      parseResponse: take(parseResponseForApp),\n      forward: take(forwardForApp),\n    });\n    if (forward) {\n      const payload = parseFrame(forward);\n      let parsedAction;\n      try {\n        // If its a forward, check if there is a sequence and a parser for that sequence\n        if (_.isNumber(payload.sequence)) {\n          const parserForSequence = parsersBySequence[payload.sequence];\n          if (parserForSequence) {\n            parsedAction = parserForSequence(payload);\n            parsersBySequence = _.omit(parsersBySequence, payload.sequence);\n          } else {\n            /* eslint-disable no-console */\n            console.log('Received socket payload with sequence without parser, using default parser', payload);\n            /* eslint-enable */\n            parsedAction = parser(payload);\n          }\n        } else {\n          parsedAction = parser(payload);\n        }\n      } catch (error) {\n        yield put({ type: APP_SOCKET_PARSE_ERROR, error: true, payload: { error, payload } });\n        continue; // eslint-disable-line no-continue\n      }\n      if (parsedAction) {\n        yield put(parsedAction);\n      } else {\n        yield put({ type: APP_SOCKET_UNKNOWN_FRAME, error: true, payload: { payload } });\n      }\n    } else if (parseResponse) {\n      const { payload: { sequence, parser: parserForSequence } } = parseResponse;\n      if (_.isNumber(sequence) && _.isFunction(parserForSequence)) {\n        parsersBySequence = {\n          ...parsersBySequence,\n          [sequence]: parserForSequence,\n        };\n      } else {\n        console.error('Parse response request was invalid', parseResponse); // eslint-disable-line no-console\n      }\n    }\n  }\n}\njs\nexport function* appSocketForwardParserCopy(app, parser, forwardForApp = isForwardForApp(app),\n  parseResponseForApp = isParseResponseForApp(app), parseFrame = parseAppFrame) {\n  // Map from sequenceId to the parser responsible for it\n  let parsersBySequence = {};\n  while (true) {\n    const { parseResponse, forward } = yield race({\n      parseResponse: take(parseResponseForApp),\n      forward: take(forwardForApp),\n    });\n    if (forward) {\n      const payload = parseFrame(forward);\n      let parsedAction;\n      try {\n        // If its a forward, check if there is a sequence and a parser for that sequence\n        if (_.isNumber(payload.sequence)) {\n          const parserForSequence = parsersBySequence[payload.sequence];\n          if (parserForSequence) {\n            parsedAction = parserForSequence(payload);\n            parsersBySequence = _.omit(parsersBySequence, payload.sequence);\n          } else {\n            /* eslint-disable no-console */\n            console.log('Received socket payload with sequence without parser, using default parser', payload);\n            /* eslint-enable */\n            parsedAction = parser(payload);\n          }\n        } else {\n          parsedAction = parser(payload);\n        }\n      } catch (error) {\n        yield put({ type: APP_SOCKET_PARSE_ERROR, error: true, payload: { error, payload } });\n        continue; // eslint-disable-line no-continue\n      }\n      if (parsedAction) {\n         yield put({ ...parsedAction, type: 'FOO' }); // original yield put({ ...parsedAction });\n      } else {\n        yield put({ type: APP_SOCKET_UNKNOWN_FRAME, error: true, payload: { payload } });\n      }\n    } else if (parseResponse) {\n      const { payload: { sequence, parser: parserForSequence } } = parseResponse;\n      if (_.isNumber(sequence) && _.isFunction(parserForSequence)) {\n        parsersBySequence = {\n          ...parsersBySequence,\n          [sequence]: parserForSequence,\n        };\n      } else {\n        console.error('Parse response request was invalid', parseResponse); // eslint-disable-line no-console\n      }\n    }\n  }\n}\nThanks for looking into this!\n. I threw a few console logs in each function inside asap.js. Im not exactly sure 100% what Im looking for though. Could you explain a bit about when suspend and flush should be called? It does appear that during the put call isSuspended is true and there isn't a flush until much later.\n\n. One thing that is possibly interesting, is that in another saga there is a race of a couple different take calls. Its listening for the HARDHAT_OPEN_DATA redux action, and subsequently does the put of the APP_SOCKET_CONNECTED. It seems like the call to flush is occurring only after this finishes.\n. Yeah definitely! I'll message you on gitter and we can set something up\n. \ud83d\udc4d looking forward to the next release\n. Sure thing\n. Updated and rebased\n. \ud83d\udc4f nicely done!\n. ",
    "pke": "Great work so far!\nI wonder how difficult it would be to transform the sagaMonitor to an actual DevTools monitor.\n. Some sagas appear as \"unknown\" in SagaMonitor. Anything I can do about that?\n. Signatur of apply effect seems to have changed to apply(context, method...) \n. I don't quite understand the code split with the reducers. Care to elaborate on that?\n. @yelouafi cool. Parallel effects with the ability to cancel is just what I was looking for in my current logni saga. There are a bunch of watchers that should spawn when a user logs in. But they should only run until the the user logs out.\nBeside that, a non-attached fork should be called spawn, imho.\n. Wow, that was quick! Was about to create a PR myself.\n. What implementation do you suggest, @slorber?\nI have to check out the saga monitor tools still. But this form of simple logging helped me a lot to find flaws in my sagas.\nAlso since \"function*\" are just function we could attach the log info to them also directly:\nfunction log(func, message) {\n  console.log(func.name + \": \" + message)\n  func.log = message\n  return func\n}\nThat way an effects inspector could read out the message. Would that work?\n. Sure I am all for better tooling. In my case the logging is done inside an app, and on the mobile device you cannot really open dev tools. So I log all those things to a file, that the user can (even in prod mode) send us the file and we can see what went on.\nBut a universal hook into the saga processing would be great to have.\n. You can hand in many sagas into the middleware, not only one. So there is no need to combine them like you do, is there?\ncreateSagaMiddleware(firstSaga, secondSaga, thirdSaga) should be the same as \nexport default rootSagas = [\n  firstSaga, secondSaga, thirdSaga\n]\ncreateSagaMiddleware(...rootSagas)\nWhats the yield and fork doing in your code?\n. Hmmm. Maybe I had an outdated version. I try to reproduce and open this here again if the issue remains the same.\n. Thanks, the question for me is who drives all the sagas. In a normal react app, this is done by the middleware. I guess I'd have to create a cucumber-sagas middleware to at least give me all the available sagas. Or not and I can have a cucumber step definition like this:\n```\nWhen(\"I start the app for the first time\") {\n  this.onboardingSaga = onboarding()\n}\nWhen(\"I use the app for 10 minutes\") {\n  if (!this.deepEqual(this.onboardingSaga.next().value, call(wait, 10, \"minutes\")) {\n    throw new Error(\"On boarding did not wait for 10 minutes\")\n  }\n}\n```\n. I have to chim in here and ask why I see so many saga examples that export \nexport default sagas = [\n  yield [\n    fork *saga1,\n    fork *saga2,\n    ...\n  ]\n]\nWhat's the benefit? Shouldn't a simple array of saga func generators be sufficient to hand into the saga middleware?\n. Why not just return the sagas without forking them? I would guess the saga middleware forks each saga in the array anyway \n. @yelouafi Speaking of such factoring, that what I am using atm in my app:\n```\nimport { takeEvery } from \"redux-saga\"\nimport { put, call } from \"redux-saga/effects\"\nimport { requestAsync } from \"./api\"\nimport { REQUEST } from \"./apiActions\"\nfunction *performRequest(request) {\n  try {\n    const { payload, response } = yield call(requestAsync, request.method, request.path, request.data, request.headers)\n    const successAs = request.successAs ? request.successAs : \"payload\"\n    yield put({ type: request.successAction, payload: {\n      [successAs]: payload,\n      response,\n      timestamp: Date.now()\n    }})\n  } catch (error) {\n    yield put({\n      type: request.errorAction,\n      error: true, payload: {\n        error,\n        request,\n        timestamp: Date.now()\n      }\n    })\n  }\n}\nexport function apiRequest() {\n  yield takeEvery(REQUEST, performRequest)\n}\n```\nIt is used by other modules like this:\n```\nfunction *fetchCities() {\n  yield put(apiAction(getCities(), REFRESH_SUCCESS, REFRESH_ERROR, \"cities\"))\n}\nfunction refreshCities() {\n  yield log(fetchCities(), \"Initial city refresh\")\n  yield takeLatest(REFRESH, fetchCities)\n}\nexport default [\n  refreshCities\n]\n```\nIts slightly different than your example, as the city saga does not import the apiSaga directly but creates an REQUEST action. I am not sure if your model or mine is \"better\". What are the pros & cons?\n. @yelouafi and what would be the best way to have them all being canceled on LOGOUT action?\nLike this?\nes6\nfunction* watchManyWhileLoggedIn(access_token) {\n  yield race(\n    take(\"LOGOUT\"),\n    watchMany(access_token)\n  )\n}\nor in a more generic way\n``` es6\nfunction* runUntil(effect, ...sagas) {\n  yield race(effect, ...sagas)\n}\nfunction* runUntilAction(actionName, ...sagas) {\n  yield runUntil(take(actionName), sagas)\n}\nrunUntil(take(\"LOGOUT\"), watchManyWhileLoggedIn(access_token))\nrunUntilAction(\"LOGOUT\", watchManyWhileLoggedIn(access_token))\n``\n. hmmm forking all the worker actions andracethem against thecancelAction` would not work?\n. Sure, every effect could be covered.\n. Its on my agenda to do, yes. You can close for now if you want. I'll open a PR once I am ready.\n. @fhelwanger Sure, that would make it cleaner for sure and easier to integrate with eslint.\n. Wrote the first rule see #261 \n@yelouafi I propose to create a new repo called eslint-plugin-redux-saga and collect all the rules we think would make sense there as issues first and create them step by step. Since you own the redux-saga repo I think it would be best hosted under your username? I could push my initial plugin to my account and you could fork it, or how would you like us to proceed?\n. @tgriesser There you go:\nes6\nruleTester.run(\"yield-effects\", rule, {\n  valid: [\n    {\n      code: \"function* test() { yield take('ACTION') }\",\n      parserOptions: { ecmaVersion: 6 }\n    }, \n    {\n      code: \"function* test() { notAnEffectDoesNotNeedYield() }\",\n      parserOptions: { ecmaVersion: 6 } \n    }    \n  ],\n  invalid: [\n    {\n      code: \"function* test() { take('ACTION') }\",\n      output: \"function* test() { yield take('ACTION') }\",\n      parserOptions: { ecmaVersion: 6 },\n      errors: [{ message: \"take effect must be yielded\" }]\n    }\n  ]\n})\n. I have setup a preliminary work-in-progress repo at https://github.com/pke/eslint-plugin-redux-saga\n. @yelouafi The rules are now published on npm. I have created a PR #452  that updates the addons section\n. I just wonder I never saw it before. Maybe my node ENV was not set correctly to development and saga did not try to log anything.\n. Would that be an effect like take and put or a simple function as described above?\n``` es6\nfunction* wait(ms, result=true) {\n  return call(new Promise(resolve => setTimeout(() => resolve(result), ms)))\n}\nconst { timeout, otherCall } = yield race({\n  timeout: wait(5000),\n  otherCall: call(asyncFunc, ...)\n})\n```\n. Thanks , so I can close this one.\n. They definitely keep on running.\nThats how they look: \n```\nfunction* refreshUser(access_token) {\n  while (true) {\n    try {\n      const user = yield call(api.getUserAsync, access_token)\n      yield put(actions.userRefreshed(user))\n    } catch (error) {\n      // No user refresh error show. We should have a global strategy to count refresh errors\n      // And display a message\n      console.error(error)\n    }\n    yield take(actions.REFRESH_USER)\n  }\n}\nfunction* refreshActivities(access_token) {\n  while (true) {\n    try {\n      const activities = yield call(api.getActivitiesAsync, access_token)\n      console.info(${activities.length} activities fetched)\n      yield put(actions.activitiesUpdated(addInvoices(sortActivities(activities))))\n    } catch (error) {\n      console.error(error)\n    }  \n    yield take(actions.REFRESH_ACTIVITIES)\n  }\n}\nfunction* refreshPendingTransactions(access_token) {\n  while (true) {\n    try {\n      let pending = yield call(api.getPendingParkingTransactionsAsync, access_token)\n      yield put(actions.pendingTransactionsUpdated(pending))\n    } catch (error) {\n      console.error(error)\n    }\n    yield call(delay, 5 * 1000)\n  }\n}\n```\nand this is the log output:\naction @ 10:28:59.412 account/LOGIN_SUCCESS (in 85.45 ms)\n action @ 10:28:59.746 account/USER_REFRESHED (in 33.18 ms)\n action @ 10:28:59.810 account/PENDING_TRANSACTIONS_UPDATED (in 42.53 ms)\n32 activities fetched\n action @ 10:28:59.893 account/ACTIVITIES_UPDATED (in 49.31 ms)\n action @ 10:29:01.476 account/LOGOUT (in 5.16 ms)\n action @ 10:29:01.575 account/LOGOUT_SUCCESS (in 29.94 ms)\nWaiting for account/LOGIN\n action @ 10:29:04.981 account/PENDING_TRANSACTIONS_UPDATED (in 26.04 ms)\n action @ 10:29:10.124 account/PENDING_TRANSACTIONS_UPDATED (in 22.92 ms)\n action @ 10:29:15.270 account/PENDING_TRANSACTIONS_UPDATED (in 24.25 ms)\n action @ 10:29:20.419 account/PENDING_TRANSACTIONS_UPDATED (in 31.04 ms)\n action @ 10:29:25.589 account/PENDING_TRANSACTIONS_UPDATED (in 22.77 ms)\n action @ 10:29:30.733 account/PENDING_TRANSACTIONS_UPDATED (in 24.92 ms)\n action @ 10:29:35.890 account/PENDING_TRANSACTIONS_UPDATED (in 40.45 ms)\n action @ 10:29:41.080 account/PENDING_TRANSACTIONS_UPDATED (in 25.78 ms)\n action @ 10:29:46.237 account/PENDING_TRANSACTIONS_UPDATED (in 27.08 ms)\n action @ 10:29:51.421 account/PENDING_TRANSACTIONS_UPDATED (in 79.83 ms)\nwas we can see, no errors are logged, so no cancellation exception is raised.\n. @yelouafi  I have put in debugger statements in the catch block, they are not triggered. Also all catch blocks have console.error() logging so I should see something in the console\n. :+1: great! Another setting for the hopefully soon coming eslint-redux-saga :)\nI'm still getting:\nrefreshUser: uncaught SagaCancellationException {name: \"SagaCancellationException\", message: \"SagaCancellationException; type: RACE_AUTO_CANCEL, saga: refreshUser, origin: authorizedFlow\", type: \"RACE_AUTO_CANCEL\", saga: \"refreshUser\", origin: \"authorizedFlow\"\u2026}message: \"SagaCancellationException; type: RACE_AUTO_CANCEL, saga: refreshUser, origin: authorizedFlow\"name: \"SagaCancellationException\"origin: \"authorizedFlow\"saga: \"refreshUser\"stack: \"Error\u21b5    at new SagaCancellationException (eval at <anonymous> (http://localhost:3000/bundle.js:98:29), <anonymous>:27:16)\u21b5    at Function.task.done.(anonymous function) [as cancel] (eval at <anonymous> (http://localhost:3000/bundle.js:98:29), <anonymous>:102:17)\u21b5    at Function.cb.cancel (eval at <anonymous> (http://localhost:3000/bundle.js:98:29), <anonymous>:197:16)\u21b5    at eval (eval at <anonymous> (http://localhost:3000/bundle.js:98:29), <anonymous>:434:23)\u21b5    at Array.forEach (native)\u21b5    at Function.cb.cancel (eval at <anonymous> (http://localhost:3000/bundle.js:98:29), <anonymous>:433:18)\u21b5    at Function.cb.cancel (eval at <anonymous> (http://localhost:3000/bundle.js:98:29), <anonymous>:197:16)\u21b5    at eval (eval at <anonymous> (http://localhost:3000/bundle.js:98:29), <anonymous>:483:32)\u21b5    at Array.forEach (native)\u21b5    at Function.cb.cancel (eval at <anonymous> (http://localhost:3000/bundle.js:98:29), <anonymous>:482:14)\"type: \"RACE_AUTO_CANCEL\"__proto__: Error\nrefreshActivities: uncaught SagaCancellationException {name: \"SagaCancellationException\", message: \"SagaCancellationException; type: RACE_AUTO_CANCEL, saga: refreshActivities, origin: authorizedFlow\", type: \"RACE_AUTO_CANCEL\", saga: \"refreshActivities\", origin: \"authorizedFlow\"\u2026}\nauthorizedFlow: Logged out\nWaiting for account/LOGIN\nalthough my code looks like this:\n```\nfunction* refreshUser(access_token) {\n  while (true) {\n    try {\n      const user = yield call(api.getUserAsync, access_token)\n      yield put(actions.userRefreshed(user))\n    } catch (error) {\n      if (isCancelError(error)) {\n        return\n      }\n      // No user refresh error show. We should have a global strategy to count refresh errors\n      // And display a message\n      console.error(error)\n    }\n    yield take(actions.REFRESH_USER)\n  }\n}\nfunction* refreshActivities(access_token) {\n  while (true) {\n    try {\n      const activities = yield call(api.getActivitiesAsync, access_token)\n      console.info(${activities.length} activities fetched)\n      yield put(actions.activitiesUpdated(addInvoices(sortActivities(activities))))\n    } catch (error) {\n      if (isCancelError(error)) {\n        return\n      }\n      console.error(error)\n    }\n    yield take(actions.REFRESH_ACTIVITIES)\n  }\n}\n``\n. Created aneslint` rule for that:\nes6\nruleTester.run(\"no-yield-in-race\", rule, {\n  valid: [\n    {\n      code: \"function* test() { yield race({ posts: call(fetchApis) }) }\",\n      parserOptions: { ecmaVersion: 6 }\n    }, \n    {\n      code: \"function* test() { yield race({ watchers: [call(watcher1), call(watcher2)] }) }\",\n      parserOptions: { ecmaVersion: 6 } \n    }    \n  ],\n  invalid: [\n    {\n      code: \"function* test() { yield race({ posts: yield call(fetchApis) }) }\",\n      output: \"function* test() { yield race({ posts: call(fetchApis) }) }\",\n      parserOptions: { ecmaVersion: 6 },\n      errors: [{ message: \"yield not allowed inside race: posts\" }]\n    },\n    {\n      code: \"function* test() { yield race({ watchers: yield [call(watcher1), call(watcher2)] }) }\",\n      errors: [{ message: \"yield not allowed inside race: watchers\" }],\n      output: \"function* test() { yield race({ watchers: [call(watcher1), call(watcher2)] }) }\",\n      parserOptions: { ecmaVersion: 6 } \n    }\n  ]\n})\nFor good measure I threw in auto-fixes for that rule ;)\nDoes this look correct to you guys?\n. @yelouafi I upgrade to 0.10.5 now and made the required adjustments. Though my sagas do not start anymore.\n``` diff\n-import createSagaMiddleware from \"redux-saga\"\n-\n import { sagas as accountSagas } from \"../account\"\n import cities from \"../cities\"\n import { sagas as retailerSagas } from \"../retailers\"\n import { sagas as garagesSagas } from \"../garages\"\n import { apiRequest } from \"../api/apiSagas\"\n import onboardingSagas from \"../onboarding/onboardingSagas\"\n import { sagas as telemetrySagas } from \"../telemetry\"\n-export default createSagaMiddleware(\n-  ...accountSagas,\n-  ...cities.sagas,\n-  apiRequest,\n-  ...retailerSagas,\n-  ...garagesSagas,\n-  ...onboardingSagas,\n-  ...telemetrySagas\n-)\n+export default function* rootSagas() {\n+  return yield [\n+    ...accountSagas,\n+    ...cities.sagas,\n+    apiRequest,\n+    ...retailerSagas,\n+    ...garagesSagas,\n+    ...onboardingSagas,\n+    ...telemetrySagas,\n+  ]\n+}\n```\nAnd my store creation:\n``` diff\n@@ -1,11 +1,12 @@\n+import createSagaMiddleware from \"redux-saga\"\n //import sagaMonitor from \"./sagaMonitor\"\n-import sagas from \"./sagas\"\n+import rootSaga from \"./sagas\"\nconst DEV = process.env.NODE_ENV === \"development\"\n const isDebugging = DEV && !!window.navigator.userAgent\nvar devFeatures = ((obj) => obj)\n@@ -22,17 +23,19 @@ const logger = createLogger({\n   actionTransformer: ({ payload, ...action }) => ({ ...action, ...payload }),\n   collapsed: true,\n   duration: true,\n })\n+const sagaMiddleWare = createSagaMiddleware()\n const composedStore = compose(\n-  applyMiddleware(thunk, sagas, logger),\n+  applyMiddleware(thunk, sagaMiddleWare, logger),\n   devFeatures\n )(createStore)\nexport default function configureStore(initialState, onComplete) {\n   const store = composedStore(reducer, initialState)\n+  sagaMiddleWare.run(rootSaga)\n// When using WebPack, module.hot.accept should be used. In LiveReactload,\n   // same result can be achieved by using \"module.onReload\" hook.\n   if (module.hot) {\n     // Enable Webpack hot module replacement for reducers\n```\nAny hint what else needs to be changed?\n. If returning the push object, can we call put effects in the event handler we attach to it?\n. And a channel is a redux-saga concept?\n. Ok I found that. Which channel to use? Do you have a small example for my usecase, since you also use the push plugin maybe you have something ready?\n. Where do you get the store from within the push.onNotification?\n. aha! Well in my code I have no access to the store where I create the store. Hmm. I'd like to keep this all in the account saga that I have. There is no way the saga function has access to the store @yelouafi? and could give the event handler the store?\n. nah, my modules are much more separated. The store is created far far away from the sagas :) Anyway, I implemented a proper PushNotificationSource like in this SO posting http://stackoverflow.com/questions/34859932/can-i-use-redux-sagas-es6-generators-as-onmessage-listener-for-websockets-or-ev/34866840#34866840\n``` es6\nfunction createPushSource(push, id) {\n  let deferred\npush.on(\"notification\", data => {\n    console.info(\"notification: \" + JSON.stringify(data))\n    if (deferred) {\n      deferred.resolve(data)\n      deferred = null\n    }\n  })\n  return {\n    id,\n    next() {\n      if (!deferred) {\n        deferred = {}\n        deferred.promise = new Promise(resolve => deferred.resolve = resolve)\n      }\n      return deferred.promise\n    },\n  }\n}\nfunction* watchPushNotification(source) {\n  let notification = yield call(source.next)\n  while (notification) {\n    yield put(actions.refreshPendingTransactions)\n    notification = yield call(source.next)\n  }\n}\nfunction initPushSupportAsync() {\n  return new Promise((s,e) => {\n    if (window.PushNotification) {\n      let push = window.PushNotification.init({\n        android: {\n          senderID: GCM_SENDER_ID,\n          icon: \"ic_notification\",\n          iconColor: PRIMARY_COLOR,\n        },\n        ios: {\n          alert: true,\n          badge: false,\n          sound: false,\n        },\n        windows: {\n        },\n      })\n      push.on(\"registration\", (data) => {\n        console.info(\"PUSH registration: \" + JSON.stringify(data))\n        s(createPushSource(push, data.registrationId))\n      })\n      push.on(\"error\", e)\n    } else {\n      e(new Error(\"No push notification available\"))\n    }\n  })\n}\n```\nMaybe such (event) source could be even more generalized and added to redux-saga\n. @yelouafi thanks. The window.PushNotification.init has a success handler that is called with the push ID that I need to send to the server. So I'd have to somehow return from getDeviceTokenChannel only after the success callback has been called (like in my original code).  How would I incorporate this functionality?\n. I'm afraid I cannot follow what you mean? Isn't eventChannel already returning a promise?\n. as a follow up, I want to use channels to yield document visibilitychange events.\n``` es6\nconst eventChannel = (target, eventName) => emitter => {\n  const listener = event => emitter(event)\n  target.addEventListener(eventName, listener, false)\n  return () => {\n    target.removeEventListener(eventName, listener)\n  }\n}\nfunction* refreshUser(access_token) {\n  const visibilityChangeChannel = yield call(eventChannel, document, \"visibilitychange\")\n  try {\n    while (true) {\n      yield call(apiUserRefresh, access_token)\n      yield take([REFRESH_USER, visiblityChangeChannel])\n    }\n  } finally {\n    if (yield cancelled()) {\n      visibilityChangeChannel.close()\n    }\n  }\n}\n```\nBut the visibility event does not seem to be emitted.\n. @yelouafi Can eventChannel also throw exceptions instead of emitting a error object?. @yelouafi One more thing to this concept you outlined here: https://github.com/yelouafi/redux-saga/issues/421#issuecomment-230475206\nHow would I close this channel (and terminate its saga that is using it) when the the user logs out?. I tried this code now but it fails at yield take(channel) with\nError: take(patternOrChannel): argument [object Object] is not valid channel or a valid pattern\n```es6\nfunction* watchPushNotification(channel) {\n  while (true) {\n    const notification = yield take(channel)\n    if (!notification.error) {\n      yield put(actions.refreshPendingTransactions())\n      yield put(actions.refreshInvoices())\n    }\n  }\n}\nconst getDeviceTokenAsync = () => (\n  new Promise((s,e) => {\n    if (window.PushNotification && Product.googleSenderId) {\n      const push = window.PushNotification.init({\n        android: {\n          senderID: Product.googleSenderId,\n          icon: \"ic_notification\",\n          iconColor: PRIMARY_COLOR,\n        },\n        ios: {\n          alert: true,\n          badge: false,\n          sound: false,\n        },\n        windows: {\n        },\n      })\n      push.on(\"registration\", data => {\n        DEV && console.info(\"PUSH registration: \" + JSON.stringify(data))\n        const channel = eventChannel(emit => {\n          push.on(\"notification\", emit)\n          push.on(\"error\", error => emit({ error }))\n          return () => {\n            //push.unregister()\n          }\n        })\n        debugger\n        s({ channel, id: data.id })\n      })\n    } else {\n      e(new Error(\"No push notification available\"))\n    }\n  })\n)\nfunction* authorize(credentials) {\n  try {\n    const { email, password } = credentials\n    const deviceInfo = getDeviceInfo()\n    try {\n      const { id, channel } = yield call(getDeviceTokenAsync)\n      deviceInfo.device_token = id\n      yield fork(watchPushNotification, channel)\n    } catch (error) {\n      // Silently ignore if no push service is avail\n    }\n    let { access_token, user } = yield call(api.loginAsync, email, password, deviceInfo)\n    if (!user) {\n      user = yield call(api.getUserAsync, access_token)\n    }\n    yield put(actions.loginSuccess(access_token, user))\n  } catch (error) {\n    console.error(error)\n    yield put(actions.loginError(error))\n  }\n}\n``\n. @Andarist didn't solve it yet but had other things to do. @stoyandamov thats more like a hack :). Yes I also guess the error was somewhere else.\n. Thanks, I will try that. I guess it could also be combined with webpack codesplitting to create a splitpoint insiderequireP`?\n. @salzhrani Ouch. You are correct: #454 \n. ",
    "davej": "@yelouafi Would you be interested in releasing https://github.com/yelouafi/redux-saga/blob/master/examples/sagaMonitor/index.js as a separate module on npm?\n. @GantMan reactotron doesn't support sagas yet though, does it?\n. @MichalBures FYI: I'm also in Electron.\n. I can also confirm that downgrading to 0.9.1 fixes this issue. @yelouafi: What's do you suggest? Stick with 0.9.1 for the moment?\n. Just tried this on redux-saga@0.9.4 and it seems to work ok now with just yield call(doThrow). This must have been fixed in newer versions.\n. I'm confused by this:\njs\nfiles.map(file => yield call(uploadImageApi , file))\nAFAIK you can't yield from inside a callback?\n. @dixitc That doesn't look like valid JS?\nI ended up needing to use a for loop instead:\njs\nfor (const i in files) {\n  if (files.hasOwnProperty(i)) {\n    yield call(uploadImageApi, files[i]);\n  }\n}\n. @slorber Yup, thanks for that, that's the conclusion I came to also. Might be best to use fork in the parallel upload example because call makes the semantics confusing.\n. Actually I'm probably wrong, I'm guessing that the parallel upload example waits for all the uploads to complete before moving to the next operation.\n. ",
    "GantMan": "Have you all seen https://github.com/skellock/reactotron ?\n. I know the guy working on it, and he's planning on making it extendable to support a variety of items.  We use Sagas all the time (BECAUSE IT'S AWESOME) so it's on the roadmap.\nAs of now, just redux, but you can Reactotron.log in your sagas if you're desperate.   I just found this UI way more useful than chrome, at this time.   I figure the more demand the faster we'll deliver.\n. ",
    "sibelius": "@sompylasar thanks, do you know how can I get the store or the dispatch function on chrome debug in React Native?\n. @yelouafi thanks, you are right, there was a typo in my code,\n. @kuy what happens if I want to add two of these messengers components ? Their actions will conflict with each other right?\n. ok, I will post on SO\n. I've found this package that solves this problem: https://github.com/threepointone/react-redux-saga\n. @warrendeleon u can try this one: https://github.com/threepointone/react-redux-saga\n. ",
    "sompylasar": "@sibeliusseraphini sorry, I don't work with React Native, but I think Reactotron should help you with that \u2013 store and the dispatch function come from Redux itself, not Redux-Saga, so not related to the sagaMonitor.\n. @sibeliusseraphini oh, and there is that: https://github.com/zalmoxisus/remote-redux-devtools\n. > The 2nd render is performed after dispatching END so the Sagas will not take any further action from the store \nThe sagas will not, but there may be other components that may connect directly to Redux and receive the actions. I think I'll have to monkey-patch the dispatch function to prevent that after the store \"close\" (I renamed that to \"endSaga\" because this is what it did by dispatching the END action, but if it will prevent further dispatches, it would become \"close\" again).\n. You can use .editorconfig and LF line-endings on Windows, too. This has become a de-facto standard these days... I know this won't influence the functionality, so you may close as won't fix if you like.\n. @yelouafi Thanks!\n. @yelouafi Thanks!\n\nFor 2. we can watch for specific events (like ACTION_LOAD_USER_DATA_SUCCESS and ACTION_DASHBOARD_DATA_SUCCESS) and dispatch END once we get all the required events.\n\nWe cannot, because there is no component in the architecture that would know them all. The components are decoupled, and the server-side rendering code is generic.\n\nOn possibility is to use a custom react renderer (here is an example) for the intermediate renders which turns render calls into no-op. And use renderToString only when the server flow terminates. I'm not sure however if we should rely on this feature as it's not officially documented.\n\nYes, thank you, that'd be a good improvement, I'll see if I can do this (later, currently meeting deadlines).\n\nanother less complicated approach is to simply check for some condition and return null from component's render method on intermediate calls (Maybe use a HOC for this)\n\nThis would require each component to know that it is a part of that arcitecture, so would require each developer to not forget to put that check in each render. This solution is not scaleable.\n\nThe dependency on components/actions to trigger data fetches comes from the usage of react-router. IMO What we're aiming to (usually) is to load data when a route is activated, but since in react-router we get this information via component lifecycle we trigger data fetches from here.\n\nActually, Relay follows the same principle. Components demand the data they require to be properly rendered.\n. Sagas are endless by default, so you have to find a moment to terminate them by dispatching the END action after all that can happen on the server-side is done.\nPlease see my gist that implements the server-side rendering loop that ensures that all the asynchronous effects have finished: https://gist.github.com/sompylasar/5e7157e451f4b7268def9ae1ce01edd4\nPlease ask any questions, I'll explain what's going on there.\n. For the server-side rendering it brings saga effects tracking outside of the redux-saga engine, which is otherwise hidden under the hood of redux-saga (there really is complexity in the saga engine but it's hidden from novices like you).\nAs I wrote before, knowing when all async effects are done and the sagas are just waiting (hanging) is necessary for the server-side rendering, exactly to resolve your hanging issue.\nI wish saga monitor was in a separate repo so you just npm install it and don't see what's under the hood, but I cannot afford to maintain it myself yet, and @yelouafi maintains it as just an example for logging, not for other effects tracking uses.\n. This: saga dispatch END ( store.dispatch(END) )\nShould go after this: start sagas ( store.runSaga(rootSaga) )\nWhich code stands for the saga dispatch END log message, and what's the surrounding code?\nIs there any public link to the whole code you're trying to debug?\n. Looks like \"My output\" is now out of sync with the updated code (the \"saga run\" and \"saga dispatch END\" are missing, and I don't see any code that could print \"req /d/R\").\n[1] ==> \u2705  React Redux Example is running, talking to API server on 8988.\n[1] ==> \ud83d\udcbb  Open http://localhost:3000 in a browser to view the app.\n[1] req /d/R\n[1] hydrate ON SERVER !!!!\n[1] start sagas\n[1] watchRequestDirectory1\nLogging this:\nconsole.log('saga run');\n  store.runSaga = sagaMiddleware.run;\nis useless and misleading because when you add a runSaga function to the store object, you don't actually run a saga; you run it when you call it like this:\nstore.runSaga(rootSaga)\nThe same goes for:\nconsole.log('saga dispatch END');\n  store.close = () => store.dispatch(END);\n\u2013 you don't dispatch the END action here, you just create a function that does, and add that function to the store object.\nBut the main issue here is that you don't actually render anything on the server between calling runSaga and hanging on the saga promise, so the componentWillMount will never get called, so the LOAD_DIRECTORY_PAGE will never get dispatched, etc.\nThat's why I implemented the server-side render loop that renders to string until all the components have mounted, all the actions have fired, and all the effects triggered by these actions (sync or async) have resolved.\n. > Ok I understand the store.close = () => store.dispatch(END); but why this is not setup by the library itself? the library is modifying the store anyway because it added the runSaga function.\nBecause you might want to name that function anyway you like (for example, I named them runSaga and endSaga instead of runSaga and close \u2014 this made more sense to me). The library provides you with implementations of these functions, and you are free to put them anywhere you like, and not necessarily on the store object. You may export them separately, like return { store, dispatchSagaEnd } or import END and dispatch it without an extra wrapping function.\n\nMy end goal is to use your sagaMonitor code to have a solid universal rendering. I just would like to take baby step to try to learn saga along the way.\n\nSure, then start with learning saga without the server-side rendering first. Grasp the concepts, try implementing the same features you were used to implement with thunks or fetchComponentData, in sagas.\n. I have looked. Nothing new to me.\nYou can\u2019t cross a chasm in two small jumps. (c)\nI have to repeat myself:\n\nBut the main issue here is that you don't actually render anything on the server between calling runSaga and hanging on the saga promise, so the componentWillMount will never get called, so the LOAD_DIRECTORY_PAGE will never get dispatched, etc.\n. It has these two lines after runSaga: https://github.com/yelouafi/redux-saga/blob/0dc376107d24537028bd1c66e4fce81c223f2c23/examples/real-world/server.js#L72-L73\n\nLet's expand the code if you can't follow it inline:\n```\n      const sagaTask = store.runSaga(rootSaga);\n      const sagaTaskPromise = sagaTask.done;\n      sagaTaskPromise.then(() => {\n        console.log('sagas complete');\n    // HERE'S THE SECOND RENDER which triggers componentWillMount again, \n    // but the actions dispatched from there are ignored because the saga has terminated\n    const resReactContent = renderToString(rootComp);\n\n    const currentStateJsonString = JSON.stringify(store.getState());\n    const resFullHtml = layout(resReactContent, currentStateJsonString);\n    res.status(200);\n    res.send(resFullHtml);\n  }).catch((e) => {\n    console.log(e.message);\n    res.status(500);\n    res.send(e.message);\n  });\n\n  // HERE'S THE FIRST RENDER which triggers componentWillMount\n  renderToString(rootComp)\n\n  // HERE'S THE END ACTION DISPATCH after the first render\n  // This terminates all the sagas and resolves the sagaTaskPromise.\n  store.close()\n\n```\nAs you see above, there are TWO renders because this is suitable for most cases.\nBut for my case, two was not enough because I had deeply nested layout that loaded sequentially. That's why I generalized the TWO-render code into the N-render code (which I extracted into the gist).\n. The third argument support isn't cross-browser ( http://stackoverflow.com/a/12657665 ), and would require a polyfill (though core-js that comes with babel seems to polyfill it https://github.com/zloirock/core-js/blob/e482646353b489e200a5ecccca6af5c01f0b4ef2/modules/web.timers.js ).\n. ",
    "Splact": "I've just tried @yelouafi sagaMonitor example, it's really nice! however when I try to log my sagas I see a couple of unnamed parallel tasks. I think it's caused by my rootSaga (composed saga) and some of its children (composed as the parent one). There is a way to \"label\" composed sagas (yield [\u00a0... ])?\n. @emragins you can use the sagaMonitor defined in the redux-saga examples and pass it to createSagaMiddleware through the options object.\nconst sagaMiddleware = createSagaMiddleware({ sagaMonitor: yourSagaMonitor });\nNow that the monitor is setup, you can call the logSaga from inside your code or easily the $$LogSagas from the console in your browser.\n@yelouafi maybe just two lines more in docs will help ;)\n. Sorry @DiMoNTD for that, was just a typo mistake. (Fixed for next readers...)\n. How do you avoid try catch on a race context? a SagaCancellationException could be thrown.\n. ",
    "mkazlauskas": "@pke @sompylasar I was getting \"unknowns\" as well. I traced it to \"actionChannel\", which isn't handled in getEffectLog. Consider adding else if (data = asEffect.actionChannel(effect.effect)) \n. ",
    "reem": "Seems to me the hardest part about having dev tools for sagas is exposing the current state of the saga, rather than just the history of effects and what it is currently waiting on. For instance, observing my authentication saga I want to know what it thinks is the current user, not only that it is waiting on race(logout, refresh auth), but this is very difficult since the current user is just stored in a local variable.\n. I was thinking more about this problem and it occurred to me that there is already a very similar mechanism to reloading: cancellation. The simplest thing would be to just cancel any reloaded saga and run it again, but as discussed above this has the downside of reseting state.\nWe can look to the bare usage of HMR for a solution to this problem - any module with state that needs to be transferred to the newly loaded module can do so using dispose. We can introduce a similar mechanism for sagas:\n```\nfunction* reloadableSaga(hot) {\n  let someState = hot.someState || defaultValue;\nwhile (true) {\n    try {\n      someState = yield call(doSomethingWith, someState);\n    } finally {\n      if (yield reloaded()) { // potentially reloaded can be rolled in with cancelled\n         yield reloadWith({ someState });\n      }\n    }\n  }\n}\n```\nwhere the data passed to reloadWith is passed to the new version of reloadableSaga.\nUnfortunately unlike react components sagas don't already nicely isolate their state, so users would have to do it semi-manually, but by implementing reloading support in many saga combinators (takeEvery, takeLatest, etc.) a lot of simple sagas will gain reloading support automatically.\nEDIT: I think with additional libraries that feature saga helpers like takeEvery and takeLatest which make writing declarative sagas easier we could cover even more sagas automatically.\nFor instance an always combinator could look like this:\nfunction* always(effect) {\n  while (true) {\n    try {\n      yield effect;\n    } finally {\n       if (yield reloaded()) { // this takes care of reloading the always saga itself, not the parent\n         yield reloadWith(effect);\n       }\n    }\n  }\n}\nEDIT2: Thinking about it more, we can take care of the parent saga reloading by having the reloaded effect return us our new arguments from the parent, and the saga can then choose to override some of those with reloadWith or even just continue on with the new state.\n. Another case where run would be useful: \nLet's say we have some function like this:\nexport function* doBackground(saga, config) {\n   const handle = yield fork(backgroundTask(saga, config));\n   return handle;\n}\nright now there is no convenient way for me to \"call\" this saga and get its result. If I call it to get the return value it never terminates because the fork never terminates, if I yield* it then I lose the return value.\nI can manually create and iterate over the generator to collect the return value, but this is a pretty bad solution to the problem.\nEDIT: Upon further research I discovered that yield* does give you the return value, so this case is just the same as the other one where you want run so you can do the equivalent of return yield* something as a pure effect.\n. Any thoughts here? Really all this issue is asking for is the run effect. Does anyone have thoughts on how difficult this would be to implement? I would be happy to tackle it myself if someone gave me some pointers on where to start and what parts of the code are most relevant.\n. run does the same thing as call except that if the saga it runs forks, the forks are attached to the saga that yielded the run effect, not the sub-saga.\nExample:\n```\nfunction forkingSaga() {\n     yield fork(function* () { while (true) { ... });\n}\nfunction calling() {\n      yield call(forkingSaga);\n      // never get here\n}\nfunction running() {\n     yield run(forkingSaga); // \"equivalent\" to yield *forkingSaga(); except pure\n     // we do get here\n}\n```\nIt looks like it might not be so easy given that runCallEffect just calls resolveIterator which is just proc, which appears to be the main \"loop\". I'd have to change proc to be able to \"inherit\" the forking context and call that from runRunEffect.\n. calling will never be resumed because a call effect only ends when all the sagas forks end.\n. It looks like it is covered here https://redux-saga.github.io/redux-saga/docs/advanced/ForkModel.html.\n. So originally I phrased this all in Monad language because I thought it would be helpful to have some context to refer to, but it seems to have caused more confusion than clarity.\nThis issue is mostly a feature request for run/call.nonblocking/whatever that implements the same behavior as yield * and runs the given saga transparently (without it adding any additional effects). run is a necessary counterpart to fork and call. Without it you can't write any sagas that fork without joining, which is a helpful thing to do.\nThe \"Monad wizardry\" is mostly just recognizing that using yield in the way we are here is almost the same as Haskell's do notation which is used for desugaring Monads. Sagas (call/fork/join/take) are just another Monad (or they would be if we had run :P).. A Monad is just a type that fulfills a few criteria, mainly that there exists a set of functions pure and bind which operate on the type and whose implementation fulfills some monad laws, in particular:\n  - bind(pure(x), f) == f(x)\n  - bind(instance, pure) == instance\n  - bind(instance, compose(f, g)) == bind(bind(instance, g), f)\nIf you refer back to my original post you will see my attempts at providing implementations of bind and pure above. pure is easy but bind requires run so it doesn't introduce additional effects (which is necessary to fulfill for all three laws).\nFor more info (in haskell though): https://en.wikipedia.org/wiki/Monad_(functional_programming)#Monad_laws. I recently migrated a redux-thunk-driven codebase to redux-saga, so I can relate to your issues. My primary recommendation is that you move as much logic over as possible to sagas as soon as possible. Remember, a saga is just a function, so you can always move over your redux-thunk code wholesale to sagas in what is basically an automatic transformation into a watcher saga + just calling your thunk.\nYou can then begin refactoring the sagas and thunks themselves to be more idiomatic (using call instead of just running side effects, etc.), but you won't have a problem where half of your logic can't talk to the other half.. ",
    "emragins": "Could somebody please post a full-ish example of how to use the monitor?  Or link to the documentation?  It looks amazing but my best attempt at using it was unsuccessful.\n. ",
    "DTupalov": "Hello.\nI've seen that @yelouafi wrote an wonderful tool for logging Effects, and gave examples, but I have questions to that comment:\nhttps://github.com/yelouafi/redux-saga/issues/5#issuecomment-168416397\nThere was attached pretty log like this:\n\nI've connect sagaMonitor to my project and saw not so pretty log like above\n\nSo I've clone redux-saga-examples and run it, and... in console no logs at all.\nI'm doing something wrong?\nUPD. Yes, I thought that log in real time all my Effects, but it's not! Need to enter $$LogSagas() in your console and the tree will be displaing! \nI've tried it before, but I've typed $$logSagas() instead of $$LogSagas(), because copy past that function from the comment above https://github.com/yelouafi/redux-saga/issues/5#issuecomment-249382968  from @Splact \n. @Andarist thank you for the answer! It's cool example.\nIn addictional, there is one more example, that I've found useful\nhttps://github.com/kuy/redux-saga-examples/tree/master/wizard\n. ",
    "benhughes": "@sibelius react native seems to run in a web worker when debugging in chrome https://corbt.com/posts/2015/12/19/debugging-with-global-variables-in-react-native.html you can access the global scope as mentioned in the article so all you have to do is the following somewhere in your code:\n// If react native\n  if (typeof window.document === 'undefined' && navigator.product === 'ReactNative') {\n    this.$$LogSagas = logSaga;\n  }\n. How about this?\n. Done, not a massive fan of nesting ternary expressions,, but seems to work OK.\n. Done, if any issues are raised from this please feel free to assign the issues to me. Thanks :)\n. ",
    "stunaz": "is this abandoned?  is another solution for this?. ",
    "Andarist": "I think tools like Reactotron has some saga monitoring. There is also https://github.com/redux-saga/redux-saga-devtools , its graphical and working - but it needs polishing and more work, so its rather far from being finished and unfortunately noone is working on it at the moment. If you'd like to help, please reach out to me - project is quite straightforward and contributing to it shouldnt be too hard.. put effect is not exactly synchronous, you can look on how its handled here - https://github.com/yelouafi/redux-saga/blob/e18dfa2592b493d91b82ef68d026e311827a34ba/src/internal/proc.js#L382\n. @ducin i guess you can write simple sagas as async functions, they are just functions returning promises with some sugar syntax on top of it, BUT that won't let you yield any effects in those \"async\" sagas, which is the true power of redux-saga\n\nAll places, where we actually yield async stuff would make sense, but call is synchronous - would that be a problem\n\ncall is by no means synchronous, it can call synchronous functions, but it can also call asynchronous ones. What matters is that this is a \"blocking\" effect - called function (sync/async/generator) must finish and only then \"calling\" saga will get resumed.\n\nAnd the only reason for call is clean testing (which is , as a side effect, disabling async await)?\n\nTrue reason for having effects is that they are lazy - which opens new techniques. It's the runtime that executes those effects, so in theory we can modify yielded effect, inspect it etc to have it executed in certain way. As a bonus of being lazy they do not get executed automatically in tests.. > BTW is there any docs page discussing A/A vs redux-saga?\nNo, various comments might be found across issues, but they are not consolidated into 1.\n\nIs the reason for async await-based sagas incapable of performing effects the fact, that what is yielded with redux-saga is a POFO object (representing the effect), whereas with A/A it's a promise, natively?\n\nasync/await is all or nothing (can result in a single value only), it returns a promise and resolves intermediary promises with builtin mechanism. Generators do not progress on their own - they need to be called (.next()) to progress, whats more - arbitrary values can be injected (.next(value)), we can call .next right away (for sync effects) in the same call stack or can call it later (async effects) - and some effects might even be a mix of sync/async, like take(channel), if there are pending messages in the channel we resolve immediately, if there are not we wait until something pops up in the channel. Generators are producers which can result in many (even infinite) results.  Also because whole control is in hands of redux-saga we can implement things like cancellation, which is not possible with async/await. \nGenerators might seem like an overkill, they are certainly less familiar to most of JS developers - but they are uniquely powerful. You can implement async/await on top of a simple generator-based runner, but you cant do the opposite - it's impossible to implement yielding generator on top of async/await.. Yes, otherwise ur loop will skip take sign in. @jimbol \nNo, its doesnt serve the same purpose. You might know yield all() already as yield [...arrayOfEffects]. We've added this all as we prefer keeping things explicit (all effect) rather than implicit (yielding arrays).\nall is by no means tied to puts. You can use with any other effect - useful with 2 parallel calls, or forks etc.\nKeep in mind that due to synchronous nature of redux-saga and single-threaded javascript if you all([put(ACTION1), put(ACTION2), put(ACTION3)]) they will get dispatched to ur store one by one, probably from the left to right, but I wouldnt count on that order as it might break in the future (it shouldnt, but u know how it is... if we change internals somehow, ordering of this might be affected). This is considered to be a parallel effect and to execute effects in it all at once and such mental model u should apply when working with this.. just before the fetch, function loginUser creates a Promise (by using fetch) but it doesnt return it to the caller\n. It might be some scheduling problem (we have a simple internal scheduler), cant say more without a slimmed down repro case though. Please also test this only against v1-beta as it has improved scheduling over 0.x. Its 'difficult' because the callback needs to be run in generator/saga context.\nAint sure how would you like to use yours onDownloadFileProgress, please post an example usage and ill explain how you should approach it.. Oh, yeah - its kinda cumbersome with generators in javascript, nothing really which could be simplified in the library itself.\nI think the most idiomatic way to do this in saga is to use eventChannel. Its exactly for such uses cases - connecting external event sources (other than redux / redux-saga) through the channel to the redux-saga context.\nMore can be read in the docs - but basically you need to wrap your source (RNFS.downloadFile in your case) with eventChannel. And from there you can use emit argument to put things on the created channel. And from there you can easily just take and put actions. https://decembersoft.com/posts/file-upload-progress-with-redux-saga/. I've written a little helper in such manner \n```javascript\nexport function* throttle(ms, pattern, task, ...args) {\n    const throttleChannel = yield actionChannel(pattern, buffers.sliding(1))\nfor (;;) {\n    const action = yield take(throttleChannel)\n    yield fork(task, ...args, action)\n    yield call(delay, ms)\n}\n\n}\n```\nMaybe it will be useful for somebody :) got also trailingThrottle so leading call is not included, unfortunately i couldnt think of any solution without checking if buffer is empty.\n```javascript\nfunction* delayFirstCall(ms, buffer, task, ...args) {\n    yield call(delay, ms)\nif (!buffer.isEmpty()) {\n    return\n}\n\nyield call(task, ...args)\n\n}\nexport function* trailingThrottle(ms, pattern, task, ...args) {\n    const buffer = buffers.sliding(1)\n    const throttleChannel = yield actionChannel(pattern, buffer)\nfor (;;) {\n    const firstActionInSequence = yield take(throttleChannel)\n    yield fork(delayFirstCall, ms, buffer, task, ...args, firstActionInSequence)\n\n    for (;;) {\n        yield call(delay, ms)\n\n        if (buffer.isEmpty()) {\n            break\n        }\n\n        const action = yield take(throttleChannel)\n        yield call(task, ...args, action)\n    }\n}\n\n}\n```\nEDIT:// came up with the better solution once flush effect got into the redux-saga's core\n```javascript\nexport function trailingThrottle(ms, pattern, worker, ...args) {\n        const task = yield fork(function () {\n        const throttleChannel = yield actionChannel(pattern, buffers.sliding(1))\n    for (;;) {\n        const leadingAction = yield take(throttleChannel)\n        yield call(delay, ms)\n        const [ action ] = yield flush(throttleChannel)\n        yield fork(worker, ...args, action || leadingAction)\n    }\n})\nreturn task\n\n}\n. @kumar155 Please share ur problem on something like codesandbox.io so we can help you better.. Could have also be written like thisjs\nyield all(Object.keys(sagasByPatterns).map(pattern => takeLatest(pattern, sagasByPatterns[pattern])))\nor by extracting it to a helperjs\nconst takeMultipleLatestSaga = (sagasByPatterns, ...args) => all(Object.keys(sagasByPatterns)\n  .map(pattern => takeLatest(pattern, sagasByPatterns[pattern], ...args)))\n```. ah, yeah, sorry i thought that ur use case was a little bit different, sorry for the confusion, was reading in a hurry\nif you want different patterns causing different sagas, but each action still canceling any (latest) task, then ur helper is just fine :)\ntakeLatest is using regular take under the hood, so every pattern is allowed, if somebody needs to start the same saga for multiple action types (+ cancellation logic ofc) - yield takeLatest([ACTION_1, ACTION_2], saga). @eric-burel please share ur sample repository with issue reproduced. The issue mentioned in this thread no longer exists (or at least the underlaying reason might be different) because redux-saga is no longer dispatching any debug events - instead it allows you to pass in sagaMonitor object if you want debug this way, but it is an opt-in and doesnt do anything if not passed explicitly.. Its just fine, the only downside (but rly a minor) is slightly more memory used up. I'll explain this only for completeness ;)\nEach saga - what u pass to the sagaMiddleware.run/runSaga and every generator passed into the call, apply, fork, spawn, all, race effects is internally becoming a Task. So if u add another layer of the generators in between they all get instances internally etc.\nAnd as every effect is just an object you can actually export them instead of the generators.\nSo slightly more performant would be to:\n```js\n// foo.js\nexport const fooSagas = [\n  takeEvery(\"FOO_A\", fooASaga),\n  takeEvery(\"FOO_B\", fooBSaga),\n]\n// bar.js\nexport const barSagas = [\n  takeEvery(\"BAR_A\", barASaga),\n  takeEvery(\"BAR_B\", barBSaga),\n];\n// index.js\nimport { fooSagas } from './foo';\nimport { barSagas } from './bar';\nexport default function* rootSaga() {\n  yield all([\n    ...fooSagas,\n    ...barSagas\n  ])\n}\n```\nBut you know how it is... dont optimize prematurely ! :). all is an effect therefore it should be exported by redux-saga/effects. @SmirnovW it depends what fooSagas and booSagas are, if they are the same thing in both examples then your second example probably is not working at all. First snippet should work, but yielding arrays directly is deprecated at the moment and the array should be wrapped in all effect.\n. In that case its just a matter of passing effects and non-effects (promises and iterators) to the redux-saga. While it is capable of handling those, the preferred way is to wrap them in effects (thus delaying their execution). @dfee as mentioned - it depends on what fooSagas are, all accept any effects (+ promises/awaitables and iterators), if fooSagas is a factory which returns an effect then yes - it has to be called. @oanylund \nI think thats the issue for redux-form rather than the redux-saga, so it should be issued on their repository.\n. So basically what you trying to achieve is a deepFlatMap for arrays of arrays of generators and run each of them within saga?. So in general I would advise you to use smth like flatMapDeep:\nyield flatMapDeep(bundledSagas, fork)\nI think this is exactly what you need, if not please specify your requirements stricter and I'll try to adjust my advice accordingly :). @alfonsodev the downside is that you create iterators here, they will have different identities with each run, so its harder to test. You are also yielding an array, which is deprecated now - you should wrap that array in all effect.\nIdiomatic way of using redux-saga is to yield effects (description object) only, although yielding promises and iterators is allowed.\nIt is also super easy to adjust your code to use effects:\njs\nexport default function* rootSaga() {\n  yield all(map(key => fork(combinedSagas[key]), Object.keys(combinedSagas)))\n}\nor event shorter\njs\nexport default function* rootSaga() {\n  yield all(map(fork, combinedSagas))\n}. @andredp \nThis is only sometimes suggested as precaution measure. But I would rather advise to use a wrapper around ur 'unsafe' calls (i.e. network requests), like here - with a generic solution of restarts its quite easy to lose control about how ur program behaves. More granular approach let u be more specific and handle each case differently - according to the circumstances of the failed call. @Julio-Assis starting from redux-saga@1 the delay is coming from redux-saga/effects. @sospedra \nWould you like to provide a PR with this simple change? Would be much appreciated. @mohamed-ismat its breaking the standard control flow and bypass the saga execution, you can wrap your Notification in a channel\njs\nconst chan = eventChannel(emit => {\n  const notif = new Notification(\"title\")\n  notif.onclick = e => emit(someAction())\n  return () => {}\n})\nconst ac = yield take(chan)\nchan.close()\nyield put(ac). you can import it like that\nimport { END } from 'redux-saga'\nalthough it should probably be better documented\n. There is no need to check for END manually - all ur sagas which are paused on a take effect will get resolved with END and terminate immediately. IF YOU HAVE a special needs for handling this manually you can use take.maybe which will resume ur sagas with END so you could handle it by urself.. U could lift ur fetch triggers out of the components, start the saga first and render only once data is ready (rootTask.done.then(() => {...). \nIs any other side effect library providing u better approach for this problem than doubled render?. You would also have to share how do u plan to integrate redux-saga into ur project. \nYou could similarly expose relevant sagas on the components, gather them like you have gathered promises, then run them and render once in rootTask.done.then(() => {... (dont forget to add and use store.close ofc). Dont rly think so, server side story is not well documented. \nSagas can be resumed (is they are paused at a listener 'step' - take effect) when some action occurs. But they need to be ran first to meet the listener.\nIf you associate saga with a component, and that saga start fetching immediately you could do pretty much what I have described.\nI imagine it could look roughly like this:\napp/components/App.jsx\n```jsx\nimport React from 'react';\nimport { connect } from 'react-redux';\n// getStuff returns a function that returns a promise, just like redux-thunk\nimport { getStuffSaga } from 'app/sagas';\nexport class App extends React.PureComponent {\n    static fetchData() {\n        return getStuffSaga;\n    }\ncomponentDidMount() {\n    // get sagaMiddleware from the context or smth\n    sagaMiddleware.run(getStuffSaga)\n}\n\nrender() {\n    // ...\n}\n\n}\n```\nserver/index.js\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport { match, RouterContext } from 'react-router';\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware, { END } from 'redux-saga';\n// reducer is not relevant here\nimport reducer from 'app/reducers';\nimport routes from 'app/routes';\nconst app = express();\napp.get('*', (req, res, next) => {\n    const sagaMiddleware = createSagaMiddleware()\n    const store = createStore(reducer, , applyMiddleware(sagaMiddleware));\nmatch({ location: req.url, routes }, (err, redirect, props) => {\n    // handle err, redirect or no props\n\n    const render = () => {\n        res.send(renderToString(\n            <Provider store={store}>\n                <RouterContext {...props} />\n            </Provider>\n        ));\n    };\n\n    // this is the important part: since react router exposes which components it will render\n    // I am able to go through them and find the ones that have a data dependency\n    const sagas = props.components\n        .filter(component => !!component.fetchData)\n        .map(component => sagaMiddleware.run(component.fetchData, props).done);\n\n    if (!sagas.length) {\n        return render();\n    }\n\n    store.dispatch(END)\n\n    Promise.all(sagas)\n        .then(render)\n        .catch(next);\n});\n\n});\napp.listen(3000);\n``.ENDshould release all of ur sagas paused ontake(end them), if saga is paused on some other effect it should still complete it and once it reachestakeit should end as well and then urdone.thencallback should fire. Your sagas shouldnt be paused ontakeEvery- its a non-blocking effect (since v0.12 I think). So yoursaga2can be paused aftertakeEvery` already forks. \nIf you want better control over the END you can use take.maybe and handle it however you want - so you will be able to execute put after END gets dispatched.\nHowever in general it should be possible to restructure your logic in such a way that this is not needed.\n\nIf so my more general question is, is there a way to set it up such that I can\u00a0put\u00a0an event from one saga and listen for that event from another saga after\u00a0END? This seems like a common scenario to enable a saga to listen for something like a\u00a0success\u00a0event that is dispatched by a different saga, right?\n\nIt certainly is, however not always on the server side.. No, its not possible - not through stdChannel (its internal channel which passes through each dispatched / put action) which gets closed on END. U can try other communication patterns to achieve ur goal - using call or msg passing through channel.. Probably ur mySelector has other references in both cases. Could u check it?. Yeah, i think most people store their selectors in the reducer file or in a dedicated file but close to the reducer. It depends on your babel config, so hard to tell without looking at it.. U probably need to dispatch special END action (exported by redux-saga) if u want to make SSR  . just do the simplest thing\n```javascript\nfunction* safeSomeSaga(item) {\n    const task = yield fork(someSaga, item);\nconst { error } = yield race({\n    success: take(SUCCESS),\n    error: take(FAILURE),\n})\n\nif(error) {\n    yield cancel(task)\n}\n\n}\nfunction* example {\n    yield items.map(item => call(safeSomeSaga, item))\n}\n```\nive corrected your example a little bit\n1. you need to use fork instead of call to achieve a non-blocking effect which will return a task descriptor\n2. and ive used a race instead of a take with array pattern, it feels more natural for me and gives more meaning for that part of the code. or better without such duplication\n```javascript\nfunction* example {\n    for (let item of items) {\n        const task = yield fork(someSaga, item);\n    const { error } = yield race({\n        success: take(SUCCESS),\n        error: take(FAILURE),\n    })\n\n    if(error) {\n        yield cancel(task)\n        break\n    }           \n}\n\n}\nive assumed here that 1 error breaks the loop - so all remaining, not started yet tasks are discarded, if this is not your requirement, just delete the line. @liesislukas\nIsnt that info included in the error msg? It states that argument is undefined. @ChadEubanks its probably issue with ur code, maybe u import some action type which doesnt exist (thus being undefined)? It should be easy to debug, just setup a breakpoint in `take` function. @drewandrew new release of redux-saga@1-beta is coming and it will have much nicer error messages (and even nicer ones with a babel plugin). Actually preferred way is to yield takeEvery. Are u on the latest version of redux-saga? How do u import takeEvery?. You have mentioned that this is working for ujs\nconst { takeEvery } = require('redux-saga/effects');\n// ...\nyield fork(takeEvery, 'hello', helloWorld);\n```\nand it shouldnt I think.\nCorrect working way is to yield takeEvery('hello', helloWorld);. Could u share a reproduced code on something like https://codesandbox.io ? takeEvery effect is already wrapped in a fork for you under the hood.\nSo according to what u have written it becomes something like yield fork(fork(takeEveryHelper, 'hello', helloWorld)) and this certainly shouldnt work. \nThere is a possibility though that you import takeEvery from the redux-saga and not redux-saga/effects, but that way is deprecated for quite some time.. @hwangar \nThank you for the the raising this up. You have unveiled a really subtle bug, need to figure out how to fix it properly now :).\nAs to ur origina issue though - preferred way is to:\njs\nyield takeEvery(\"task\", task);\n// ...\nassert.deepEqual(watchTask().next().value, takeEvery(\"task\", task));. call(takeEvery, ...) is old recommendation, please just use takeEvery(...) from the redux-saga/effects 'subpackage'. A little, but if you take a moment, you'll notice that its in fact totally independent of the dispatchNewCard saga. In fact many people collocate their selectors with reducers, put it in another file and you can treat it as separate module.. Thanks to the great work by @Alxandr, flow-typed has now updated redux-saga typings. Closing the issue now, if there are any problems with new typings, please report them here by creating a new issue or fix them in flow-typed repository.\nIf you have any suggestions on what is the best way to incorporate typings directly into redux-saga repository - please let me know. From what I understand the biggest problem is that typings are targeting specified range of flow versions and having them directly in the repository kinda locks them down to that range and might cause problems for people using versions from outside the range.. Could you elaborate on your problem, hopefully with example code? Its not\nobvious from this issue\nOn Thu, 15 Dec 2016 at 01:56, bakatrouble notifications@github.com wrote:\n\nIs store.runSaga().done\nhttps://github.com/yelouafi/redux-saga/tree/master/docs/api#runsagaiterator-options\ncorrect solution for this problem?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/379#issuecomment-267204657,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkhDI325zyZ4B7iERH0GYEX3Gx26pks5rIJA2gaJpZM4Iw9GI\n.\n. I would say that more natural way of doing this is to store a flag in your\nstate and update it on promise's success, then connect would do its thing -\nselect this state from the store and render appropriately.\n\nrunSaga is not the best for this use case, at least not with the snippet\nyou have proposed, cause it would never resolve I think as you use there an\ninfinite helper - takeEvery. Which stays alive until cancellation or error\nOn Thu, 15 Dec 2016 at 07:19, bakatrouble notifications@github.com wrote:\n\nI could provide example later, but I'll try to explain it now shortly\nI was trying to wire redux-saga together with redux-connect in order to\ndelay router redraw until asynchronous data is fetched, so I needed to get\nan action promise. I ended up using Task.done promise, getting the Task\nvia store.runSaga(). Is it appropriate way to do it or there are better\nones?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/379#issuecomment-267248714,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkr5evn2GZ4tKlV5zFj8xEj308in0ks5rINwJgaJpZM4Iw9GI\n.\n. @sam-jay \nI aint sure if you have noticed but the API for it is available for some time already (I know it wasnt when you have posted your issue). There is an effect now called flush and you can use it like this - yield flush(channel). Probably one of your dispatched actions throw, one of loginSuccess, loginFailure.\n\nIt may be in you reducer, I see there is a replaceAtIndex function in your call stack. Maybe it doesnt receive correct arguments? Try to wrap your actions in:\njavascript\ntry {\n  // ... regular action code\n} catch (e) {\n  debugger\n}\nand your should find the mistake within minutes.\nHope you catch it!. @simlmx \nCould you describe your exact problem more thouroghly? I would like to get rid of the pain points of our API, but do so I need to understand all concerns. Your feedback will be really much appreciated.. Sure, there is always room for improvement. I'll start another issue, so people can point out the pain points in the lib regarding this.. @AlastairTaft \n\nIs there any reason why errors are being caught internally instead of just failing and throwing?\n\nThis should no longer be the case with latest beta release.. im curious, how would you use that to achieve throttle? I mean, as far as I can see it it is not a standard throttle with delay parameter, just more like:\nwhile (true) {\n    const action = yield take(pattern)\n    // do smth\n}\nam I right? its just waiting for the previous run to finish before accepting new action, so its kinda takeFirstInSequence ?\n. well, my thought up name takeFirstInSequance was not ideal ofc, but your explanation is exactly what I was thinking about\nwell, in my opinion that would not be throttling, just delaying, truly throttled tasks would be independent of each other, in your solution they are completely dependant on the completion of previous one\nsome time ago I've implemented a helper in my project for throttle and I think its more accurate\n```\nexport function* throttle(ms, pattern, task, ...args) {\n  const throttleChannel = yield actionChannel(pattern, buffers.sliding(1))\nfor (;;) {\n    const action = yield take(throttleChannel)\n    yield call(task, ...args, action)\n    yield call(delay, ms)\n  }\n}\n```\nthinking now if it is possible to implement it as general helper with fsmIterator\nEDIT:// well actually I can see now that my solution aint perfect either, probably should fork instead of call(task)\n. @kamleshchandnani \njust use this in ur split bundle\njs\nsagaMiddleware.run(function *watcher() {\n  yield all([\n    takeEvery(FETCH, fetchAuthSaga),\n    takeEvery(LOGOUT, logoutSaga),\n    takeEvery(LOGIN, loginSaga),\n  ]);\n})\nor depending on how much involved in this sagasManager you are you may need to tweak it a little bit. i.e. like this:\n```js\nimport { all, flush, fork, take } from 'redux-saga/effects';\nimport { channel } from 'redux-saga';\nclass SagasManager {\n  constructor() {\n    this.sagasWithArguments = channel();\n  }\naddSagaToRoot(...sagaWithArguments) {\n    this.sagasWithArguments.put([...sagaWithArguments]);\n  }\ngetRootSaga() {\n    const sagasChannel = this.sagasWithArguments;\nreturn function *rootSaga() {\n  const initialSagas = yield flush(sagasChannel);\n  yield all(initialSagas.map((initialSagaWithArguments) => fork(...initialSagaWithArguments)));\n\n  while (true) {\n    const dynamicSaga = yield take(sagasChannel)\n    yield fork(...dynamicSaga)\n  }\n};\n\n}\n}\nexport default new SagasManager;\n. Then the second option is (tweaked manager) is what you need. Inspect with a debugger this line `const initialSagas = yield flush(sagasChannel);` - somehow `sagasChannel` is referencing `loginSaga` (or some similar one), when it should be a channel's instance. Should be easily fixable - I've written this tweaked code in a rush and ofc didnt test it properly.. I've DMed u on twitter :). hey, did you solve your issue? looking on the code you shouldnt receive this error `Error: take(patternOrChannel): argument [object Object] is not valid channel or a valid pattern`. Yeah, @stoyandamov's solution is definitely a hack and can be avoided pretty much always.. Contribution would be greatly appreciated!.js\nsagaMiddleware.run(rootSaga).toPromise().then(() => { \n  / put tests here /\n})\n``. You would have to need to post more code, so I can help you. There is not much to get out of the snippets you have posted. \n. @ArtBITyield actions.map(put)might not work, because put will be called with both action and index arguments.puts signature isfunction put(channel, action) { ... }` so it would create wrong effect (or just throw when validating.\nAlso you should wrap this with all effect which is preferred way of starting parallel effects. \nSo the final code should look like this:\njs\nyield all(actions.map(ac => put(ac))). I've forked @Baisang branch and changed this example into socket.io one, hope its good - https://github.com/yelouafi/redux-saga/pull/464\n. I think that you might be forking some task which initialize takeLatest each time you fork it, but you would have to post more code concerning your issue I think as it is unclear from those lines you have posted how big picture looks like\n. ```\nfunction fetchHotel(action) { \n    // business logic stuff\n}\nexport function homeSaga() {\n  yield* takeLatest(SUBMIT_HOTEL_ID_FOR_SEARCH, fetchHotel);\n}\nexport default [\n  homeSaga,\n];\n```\nis that whole saga code? you are not even using in this one LOCATION_CHANGE which is connected to your problem as you said, I dont need buisness logic posted to help you, but I need to know exact saga code, what is root saga? how hotelSaga and homeSaga are tied with each other?\n. is hotelSaga your rootSaga or is it triggered from some of your other sagas?\n. well, this is probably cause of the specifics of injectSagas - however this work \nprobably it just runs sagas.default  (in this case) each time getComponent is ran and I imagine that its called on every route change for path: '/hotel/:hotelId'\nSo overall its not a bug or anything, it just works like that. New hotelSaga generator is instantiated on each route and therefore this takeLatest is instiantiated the same number of times so its callback is correctly invoked several times after few re-routes.\nYour solution for dealing with that problem is not that bad, you probably could just leave intermediate generator out so instead of:\nconst hotelWatcher = yield fork(fetchHotelWatcher);\nuse const hotelWatcher = yield fork(takeLatest, SUBMIT_FILTER, fetchHotel);\nor you can wrap injectSaga for that file in smth like lodash' once\nor maybe there is an option to cancel this saga from your routes, but I dont know about that\n. @justinhp could u specify ur issue? It seems all is explained in this issue. ok, I understand this, good to know\nstill dont you think that such helper as takeEvery should return its task to the caller? it has no return value, so its stoping caller indefinitely\nOfc this should be done in some other way than i've proposed here\n. Probably here, those special helpers just dont need to specify its cb so it can by ignored in proc when iterator returns. \nAs I can see from a quick look into the code - those helpers dont even specify their callbacks. So such case with no callback could probably return task to the caller? And if callback is specified then it would be handled by proc?\nThis would require just an if resolveIterator and both scenarios would be handled just fine I think - no double calling cb.\nOr I have thought about wrapping takeEvery such it would not be a blocking call and therefore could yield task to the caller. Just would have to wrap it so it use forking mechanism which would for a iterator-based worker in the background. It would preserve blocking nature of yielding iterator but in the same time make helpers (at least those 2 present ones) non-blocking.\nAint sure how I would implement it yet, but might give it a try if you green light it + maybe give some tips about desired implementation details.\n. Yeah, I knew that i can indeed use a fork for a desired effect, it just kinda surprised me that it is not a default behaviour.\nGonna try to wrap my head around your tips later and will take a shot at implementing this.\n. @yelouafi \nOk, I've managed to implement this, wasn't that hard after all ;) Would love to see your code review on that, also I didnt write tests (yet). Please take a loot at this PR, if everything is ok I'll write tests and rebase to master, so it can be merged if you decide to proceed with this.\nPre-existing tests are passing, so things should be fine.\nPS. I had problem with cross-env BABEL_ENV=es babel src --out-dir es script, but didnt change anything regarding that. Probably some wrong node/npm version here and things got crazy a little bit.\n. Tweaked existing tests to accommodate new behaviour. Aint sure if any additional tests are needed, personally dont think so.\n. @yelouafi \nI've rebased the branch now, so it can be merged without conflicts. When you have some spare time I would appreciate you looking at that. Cheers!\n. But is asEffect a good solution here? Its purpose is unwrapping metadata from effect so it can be run by a proper handler. The fact it will return smth other than undefined only if effect is certain type would be rather sort of indirect logic.\n. My solution might not be the best, but I dont know how to do it better for now. If anyone knows, please share! :)\nSo far I'm dealing with such scenario by:\n1. setting up custom channel - const customChannel = channel()\n2. in a callback using customChannel.put(action)\n3. in your regular saga generator, kinda watcher on customChannel:\nwhile (true) {\n    const action = yield take(customChannel)\n    yield put(action)\n}\n. @adrispo it's actually a good way of integrating with Promise/callback based APIs. @baldwmic would u like to provide some help in fixing this? hadnt time to take care of this yet and probably wont have in the near future. i think its all defined in book.json, you can check how redux fixed this issue - by adding there a custom css which fixes this, but i think this could have been done with prism upgrade or something, but that would have to be investigated - i didnt play with gitbook much. In fact there is a way I think, please take a look here - https://github.com/yelouafi/redux-saga/blob/master/test/sagaHelpers/takeLatest.js\nIt is a really similar example. If you really want to check this debouncing thing.\nHowever you dont even need to check:\n1. use delay helper from redux-saga (import { delay } from 'redux-saga')\n2. use it exactly the same - yield call(delay, 250)\n3. just test if call effect is created with correct arguments. Effects are description to saga what should be done by it. You actually do not need to check if it happened, just if saga was ordered to do something\nAlso in my opinion you do not need to use yield call(getCompanies). I guess you are exporting getCompanies, so it can be tested. For me its exporting just for testing purposes which is not ideal (in my opinion). You can yield* getCompanies() so in your test (after const it = getCompaniesWatcher()) calls to it.next will be delegated in to your underlaying iterator which is the one created by getCompanies, so it can stay hidden from the outside world and still works exactly the same. However that is my personal preference.\n. So should I close this PR? I mean do you plan to keep such helpers out of the core (as you have mentioned adding it just to the recipes)? Did you maybe consider this mono-repo thing so maybe more helpers could be included and imported by ppl just on demand?\n. Can make it as part of this PR - updating recipe. But when I'm done with docs and tests - is it even needed in the recipes? I mean underlaying implementation? It can just be explained alongside with the helper I think.\nAlso I have similar helper written as generator for trailingThrottle. Dont know though if it deserves geting a standalone helper (which I can implement using fsmIterator) or do you think its good only for a recipe? (dont know how common such use case is)\n```\nfunction* delayFirstCall(ms, buffer, task, ...args) {\n    yield call(delay, ms)\nif (!buffer.isEmpty()) {\n    return\n}\n\nyield call(task, ...args)\n\n}\nexport function* trailingThrottle(ms, pattern, task, ...args) {\n    const buffer = buffers.sliding(1)\n    const throttleChannel = yield actionChannel(pattern, buffer)\nfor (;;) {\n    const firstActionInSequence = yield take(throttleChannel)\n    yield fork(delayFirstCall, ms, buffer, task, ...args, firstActionInSequence)\n\n    for (;;) {\n        yield call(delay, ms)\n\n        if (buffer.isEmpty()) {\n            break\n        }\n\n        const action = yield take(throttleChannel)\n        yield call(task, ...args, action)\n    }\n}\n\n}\n```\n. I've updated the PR with test and docs \ud83c\udf89, please take a look. :)\n. Had same problem while developing a branch. So you are not alone. Looked into the issue for a brief moment and I've seen that:\n// npm ^3\n    commonJsPlugin = require('babel-plugin-transform-es2015-modules-commonjs');\nwas sucessful and later in \nes2015WebpackPluginList = es2015PluginList.filter(function (es2015Plugin) {\n    return es2015Plugin !== commonJsPlugin;\n});\nNothing was filtered out of the list and it was supposed to. It may be some issue with incorrect package versions? I see that babel-preset-es2015-webpack is requiring via npm3 commonJsPlugin = require('babel-plugin-transform-es2015-modules-commonjs'); from a flat structure and in es2015PluginList is included require(\"babel-plugin-transform-es2015-modules-commonjs\"), { loose: loose }] which probably has some other identity cause of a flag passed in.\nHowever I think that is a problem babel-preset-es2015 itself.. \n. Probably there isnt, cause it is a problem with a package its depending on (babel-preset-es2015). I've found why this had happened. Culprit is here - https://github.com/babel/babel/commit/c6354a2132c18caca18792a544105cc1e932987a#diff-a854a9360f2dd5153da7e0f8ed87c965 . [].concat flattens arrays, so concatening an array to an array is like adding elements from the second one to the first one. And they have changed it so the second flat wasnt flattened at all and the list became [a,b,c, [d]] instead of [a,b,c,d]. Therefore filtering in another package babel-preset-es2015-webpack just broke. Im gonna make a pull request to fix it in few minutes.\n. Oh, I see there was already pull request with the fix there - (https://github.com/gajus/babel-preset-es2015-webpack/pull/13) but  its pending on approval.\n. @elitan it seems that babel-preset-es2015-webpack got deprecated and a simple change with updated babel-preset-es2015 seems to work perfectly. Just made PR here within redux-saga.\n. Saga is another way of dealing with async and side effects than thunk-like middleware. So it is not exactly an other way of writing middlewares but another way of dealing with things you could do within middleware.\nSaga is more robust and can give you way better structured code than the middleware approach for those scenarios.\n. I would say its normal usage. Shouldnt cause you any problems I think, but ofc I cant be sure as im not @yelouafi ;) \nHowever Im doing similar things with my channels. \nAlso I dont see how communicating between stores would be different than communicating between sagas 'owned' by one store and the later is mentioned in the docs as one of main purposes of channels.\n. @henrikra \nI've just noticed that its not documented in the API reference section. Would you be willing also to provide some short description with a link to the section you have created in #681 ?\nWould be greatly appreciated! . just a note - you can import any util from redux-saga/utils. How does your rootSaga look like?\n. @pke \nThat is probably cause race accepts dictionaries and this dictionary 'keys' are racing. So its a race between watchers (as a whole) and logout and not between 4 independent watchers and logout. For watchers to complete in first example its not sufficient that just 1 logoutFlow finished, all effects in the array need to be completed for watchers being treated as completed and therefore finishing the race\nI see how you have fixed it and why it works. This race effect is kinda only waiting for the logout completion and then its able to cancel all non completed (other) effects from this race.\nThat being said I dont think race is the best solution for your problem, cause there is really no racing here. I would model this flow as smth like that:\n``` js\nfunction* authorizedFlow() {\n  let payload\n  while (({ payload } = yield take([actions.LOGIN_SUCCESS, actions.START_SIGNUP_SUCCESS]))) {\n    const { access_token } = payload\n    const watchers = yield fork(runWatchers, access_token)\n    take([actions.LOGOUT_SUCCESS, actions.LOGOUT_ERROR]) // waiting for any to happen\n    yield cancel(watchers)\nconsole.info(\"authorizedFlow: Logged out\")\n\n}\n}\nfunction* runWatchers(access_token) {\n  // wrapped in an array so they can be parallelized\n  yield [\n    call(logoutFlow, access_token),\n    call(refreshUser, access_token),\n    call(refreshInvoices, access_token),\n    call(refreshPendingTransactions, access_token)\n  ]\n}\nfunction* logoutFlow(access_token) {\n  while (yield take(actions.LOGOUT)) {\n    try {\n      yield call(api.logoutAsync, access_token)\n      yield put(actions.logoutSuccess())\n    } catch (error) {\n      yield put(actions.logoutError(error))\n    }\n  }\n}\n``\n. Yes, you are right. Sent a PR with a fix.\n. 1. It should be non-blocking.\n2. Yeah, I was not sure what should be done if closed channel is tried to be flushed. Didnt yet understand how cancelation works and what behaviours must be accounted into such implementation for it to work. We can ofc resume withENDalthough when Im looking attakeimplementation - its resuming withEND` on:\nif(closed && buffer.isEmpty()) {\n      cb(END)\nIsnt it wrong? I mean shouldnt close channel always resume END then and not only if it is closed and empty? Especially that closing the channel aint clearing buffer?\n. state                           |   action\n--------------------------------|--------------\nclosed  |   takers  |   buffer  |   flush\n--------------------------------|---------------\nT       |   empty   |   empty   |   it(END)\nT       |   empty   |   part    |   it(buf.flush())\nT       |   empty   |   full    |   it(buf.flush())\n--------------------------------|---------------\nT       |   filled  |   empty   |   not possible, cause takers should be resolved?\nT       |   filled  |   part    |   \nT       |   filled  |   full    |   \n--------------------------------|---------------\nF       |   empty   |   empty   |   it([])\nF       |   empty   |   part    |   it(buf.flush())\nF       |   empty   |   full    |   it(buf.flush())\n--------------------------------|---------------\nF       |   filled  |   empty   |   not possible, cause takers should be resolved?\nF       |   filled  |   part    |   \nF       |   filled  |   full    |   \n--------------------------------|---------------\nIint sure about the cases when takers are filled, cause I dont know how exactly scheduling things work here yet. But the rest of it is pretty straight forward I guess\n. @yelouafi \nI've updated my PR with corrected version of the flush effect.\nAlso thought that flush could take matcher argument, but aint sure how to proceed with that, cause most likely it will need to implemented in the buffer itself, but for now it stays agnostic of what's inside it (which is nice). In the same time I've found a bug (https://github.com/yelouafi/redux-saga/issues/507) which to be solved would require similar implementation I think - matcher argument in buffer.take\n. Crucial here is how and when do you run watchSubmit? Most likely you run it on every route change, so with each change you fire up thistakeEvery.\n. Could you please post more code? How do you get your actions in saga, where is this call and what is authorize?\nTry to compare to this:\n```\nfunction* saga() {\n    while (true) {\n        const { payload } = yield take('ACTION') //payload here should be your Immutable.Map\n        yield call(authorize, { data: payload, isRegistering: false })\n        //...\n    }\n}\nfunction* authorize({ data, isRegistering }) {\n    console.log(data)\n}\n```\n. https://github.com/yelouafi/redux-saga/issues/503#issuecomment-241844258\nin that comment you have a such line - const { data } = yield take(LOGIN_REQUEST);\nand that was the wrong reference from what I see, you LOGIN_REQUEST action has shape of { type, payload }, so you have extracted undefined from it.\n. @aikoven this Promise will resolve just once, if he wants to get multiple values over time from the firebase callback it is not a suitable solution unfortunately\nwhat i came up with in my project is that - https://github.com/yelouafi/redux-saga/issues/475#issuecomment-239129811\n. It really is about how do u want to structure your code. Problem with Promises as I've mentioned is that they provide a SINGLE value and that's all.\nYou can ofc wrap this one in a Promise and just listen to that promise with an infinite while loop fashion, but you would have to remember to clear up the subscription in the callback, like this:\njs\nfunction connect() {\n  return new Promise(resolve => {\n    const database = firebase.database();\n    const connectionRef = database.ref('.info/connected');\n    connectionRef.on('value', val => {\n      connectionRef.off('value', resolve)\n      resolve(val)\n    });\n  });\n}\nBy wrapping the thing not in a Promise but in a channel you allow the underlying source (firebase here) to emit MULTIPLE values over time to the channel and you will be able to take from that channel and act appropriately on the received items.. Its basically the same situation. You need to wrap your data source in the eventChannel, emit items from it and just take those items from the saga. Something like this:\n```js\nfunction queryAppid({ payload },{ put, call }){\n     return new eventChannel(emit => {\n      wx.ready(function(){\n        wx.getLocation({\n          type: 'wgs84', \n          success: function (res) {\n            let latitude = res.latitude; \n            let longitude = res.longitude; \n            let speed = res.speed; \n            let accuracy = res.accuracy; \n       //when get latitude and  longitude  then getLocation.\n\n        var myGeo = new BMap.Geocoder();\n        myGeo.getLocation(new BMap.Point(longitude, latitude), function(result){\n          if (result){\n            emit(result)\n          }\n        });\n      }\n    });\n\n    return () => {\n      // return some unscubscribe function here\n    }\n })\n\n}\nfunction* someSaga() {\n  const payload = ...\n  const chan = queryAppid({ payload })\n  while (true) {\n    const result = yield take(chan)\n    yield put({ type: 'someAction' , payload: { location: result.address} })\n  }\n}\n```. well, sagas are not for intercepting actions, just to handle side effects of them, if you want to act on action before it hits reducer you need to dispatch action which will not be handled by reducers (unknown to them), handle it in the saga and dispatch other action upon completion so it can be handled by reducers\nfunction* saga() {\n    while (true) {\n        const action = yield take('BEFORE_REDUCERS')\n        // handle action \n        // ...\n        yield put({\n            ...action,\n            type: 'HIT_REDUCERS'\n        })\n    }\n}\n. Well, if state could influence the way that the side effect is processed (e.g condition based on select) then you dont really have a problem, cause your take effect will execute after store's update. \nFollow 'splitting actions into 2' pattern only if you need that before logic.\n. Hey, I was just correcting your example when you have solved it by yourself ;)\nYou could do it also like this:\n``\nfunction* fetchVersion(id) {\n    const token = yield select(getUsetToken)\n    const url =${settings.apiServer}/version/${id}const options = {\n        method: 'get',\n        headers: {\n            Authorization:Bearer ${token}`,\n            Accept:         'application/json',\n            'Content-Type': 'application/json',\n        }\n    }\nconst fetchRes = yield fetch(url, options)\n    .then(checkHttpStatus)\n    .then(parseJSON)\n    .catch(err => ({err}))\n    .then(res => ({res}))\n\nreturn fetchRes\n\n}\nexport function* loadVersionFlow() {\n    while (true) {\n        const { data } = yield take(ITEM_VERSION_REQUEST)\n        const id = parseInt(data)\n        const { err, res } = yield call(fetchVersion, id)\n        console.log(err, res)\n    }\n}\n```\nor even better - instead of const fetchRes = yield fetch(url, options) you could wrap this whole fetch into a function and just use const fetchRes = yield call(fetchFn, url, options)\nGonna write some explanation in few minutes\n. What's wrong with passing custom buffer? you can use the one implemented in redux-saga and customize your buffer limit as you wish just by passing a second argument to the actionChannel, like so:\n```\nimport { buffers } from 'redux-saga'\nimport { actionChannel } from 'redux-saga/effects'\n//...\nyield actionChannel(EXAMPLE_ACTION, buffers.fixed(YOUR_LIMIT))\n```\nHowever that's an interesting issue raised - what should I do if I want to have an infinite buffer?\n. I guess you are mutating the features with push. With const features = yield select(selectFeatures); you are grabbing the reference to some nested object in your state and then you are mutating its content so it gets updated in state too, so when you grab it again on the second run of startSomething you are geting mutated result and you will probably just push to it again so those MORE will just pile up in your state.\nI would suggest to const [...features] = yield select(selectFeatures)\n. Could you maybe try to post more code? Especially this selector - selectFeatures? Have you tried this const [...features] = yield select(selectFeatures)? (I know you are using Immutable so its probably not a case, but still ;)) Also - what is done by enableFeatures action?\nIt shouldnt matter that this features reference is outside in the closure in transpiled code, cause every call effect will call startSomething and thus create new references in 2 separate instances of this generator.\n. Well, @yelouafi himself has proposed wrapping simple function into call effect here - https://github.com/redux-saga/redux-saga/pull/464#discussion_r73314259 for testability purposes and its part of the examples in the docs, so I would say its recommended all the way.\nAnd also runCallEffect supports it directly - https://github.com/redux-saga/redux-saga/blob/e18dfa2592b493d91b82ef68d026e311827a34ba/src/internal/proc.js#L417 . Everything returned from calling else than iterator and promise will get just passed back into your saga.\nProbably could be explained a little bit better in the docs though.\n. I kinda feel the same. In my tests I wouldnt like to focus on underlaying implementation, just like in the 'normal' code. For that reason I'm not even testing my sagas right now. Dont want to have my tests broken if I rearrange 2 lines which dont even change the overall behaviour\n. this one return step.value && step.value.SELECT; is reaching for rather private API, which should be avoided\nand also i dont get why here return step.value.select.selector(); // call promise you are mentioning promises. I dont get why then the API is:\n.match('select', detectSelector, callSelector)\nI mean - what's the purpose of puting select string there? if it is not detected automatically under the head for the user is it smth more than a label? Is it used somethow?. I have just tried your exact code and everything is like expected - got 400 error from the API response and only CONTACTS_REQUEST_FAILED got dispatched.\n. Could you maybe make a jsfiddle with minimal test case?\n. Could you share this, even not working, fiddle here?\n. you just create an effect in your test and check its deep equality against yielded one\nnext = gen.next()\nexpect(next.value).toEqual(put(itemDeleteSuccess()))\n. Well, it probably depends on what do you want to test rly. You could play with this https://github.com/yelouafi/redux-saga/blob/b29b4315e729e45f71feb06f69c5afd7eee0e73e/src/utils.js#L2 to grab effect's payload and test what you want about it. Cause effects are just plain object, similarly to actions.\n. You make an Api call from this listUsers but you are not yielding nor\nreturning its response. Its just wrapped in try/catch block and nothomg else\nOn Sun, 4 Sep 2016 at 09:05, gavin-gmlab notifications@github.com wrote:\n\nUpdate: I think there is some problem handling the particular request or\nthe response that I am passing in. I tried with another API just modifying\nrequest params and the api call and it works\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/526#issuecomment-244587752,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkneFw6Itla89W041ErTThpTN5s25ks5qmm3WgaJpZM4J0U-o\n.\n. Could you post here code of your saga?\nOn Sun, 4 Sep 2016 at 13:58, Suraj Savita notifications@github.com wrote:\nHey Guys,\nFirst of all thanks for this great side-effects library \\m/.\nSecondly I got one small issue with the implementation described in the\ndoc.\nI have used async example to implement one todo app and the issue is\nactions are being dispatched twice once directly without going through\nsagaMiddleware and another one through sagaMiddleware.\nSo each and every Action which I am listening for using take side-effect\nis being dispatched to reducer directly as well as via saga.\nTried to go through stack trace as well but it just give me all this info.\nI can't figure out what's the issue in here.\nLet me know if this via some configuration switch or something else.\nCheers,\nSuraj\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/527, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMknu24vW0i6vALq9Vn2TaO9Gnv14gks5qmrJYgaJpZM4J0hN2\n.\n. That's cause sagas are not for intercepting actions, but for acting whenever 1 happens. So you are both listening for EDIT_TODO and dispatching EDIT_TODO in response for that. For it to work properly, you need to distinguish those 2.\n\nFor better understanding look into the source code here - https://github.com/yelouafi/redux-saga/blob/7b30115cc75ed121e3308fa8d5b274b5346120b0/src/internal/middleware.js#L50\nAs you can see the action is hitting reducers first and then emitted to the redux-saga\n. You can dispatch action from the saga and run code in reducers at the same\naction. Just do not listen for action A in the saga (with take) and then\ndispatch action A, cause it will end up running ur reducers twice\nOn Sun, 4 Sep 2016 at 17:59, Suraj Savita notifications@github.com wrote:\n\n[image: image]\nhttps://cloud.githubusercontent.com/assets/5236276/18232085/0de978cc-72e6-11e6-83e2-f4f542c68558.png\nTo me middleware seems more of a decorators wrapping the actual code like\nan onion layers so that you can run code before and after actual action\nbeing performed by reducers.\nI have seen few examples too in redux-saga like async example which uses\nSELECT_REDDIT action in reducer as well as in sagas but runs only once on\ndropdown selection change.\nIt looks like I am missing some major point in here.\nRef: https://www.codementor.io/reactjs/tutorial/intro-to-react-redux-pros\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/527#issuecomment-244611454,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMks5mrxmplPUbHC6SeqzA00aT8ioOks5qmur5gaJpZM4J0hN2\n.\n. Changed the scary name to expanding ;)\n\nAlso changed implementation along your suggestion, so new array is created upon expanding.\nEDIT://\nthought also about such solution after a while:\ncase ON_OVERFLOW_EXPAND:\n  arr.splice(0, 0, ...arr.splice(popIndex, arr.length - popIndex))\n  popIndex = 0\n  pushIndex = arr.length\n  arr.length = limit = 2 * limit\n  push(it)\nwhich is cleaner imho, but mutating the original arr\n. Adjusted things as you have suggested\n. Hey, sorry I've somehow missed your issue. Did you overcome the troubles somehow?\nCould be the problem of statupTasks not resolving be connected to the problem mentioned here?. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. @mheiber \nIt is not rly a good solution as between yield select(selectedRedditSelector) and yield take(actions.EXTERNAL_UPDATE) may happen multiple other actions which will change the state. \n@axelson \n\nAlternatively since the EXTERNAL_UPDATE is being dispatched from within a reducer, I may use a channel to send out the EXTERNAL_UPDATES before the actual action is sent out, but this seems like a hacky solution.\n\nFirst of all - this is not possible, you cannot use dispatch from reducers.\nYour last proposal is ofc possible (with splitting EXTERNAL_UPDATE and DO_EXTERNAL_UPDATE), but for this case I think its kinda too much of the boilerplate.\nPersonally I would go with smth like\nlet prevState\nyield fork(function* () {\n  yield take(EXTERNAL_UPDATE)\n  // ... do smth with prevState\n})\nwhile (true) {\n  yield take((action) => action.type !== EXTERNAL_UPDATE)\n  const prevState = yield select(state => state)\n}\n. Well, you will just keep reference to this huge list of entities, so i\nwouldnt rly be too much concern about it\nOn Mon, 12 Sep 2016 at 22:40, Jason Axelson notifications@github.com\nwrote:\n\n@Andarist https://github.com/Andarist You are correct that you cannot\ndispatch within a reducer, that was a typo, I am dispatching within a saga.\nYour suggested solution works but the data in question is a list of\nentities that's potentially 500+ long and the EXTERNAL_UPDATE only\naffects one of them so I'd rather not cache all of them.\nI ended up going with creating a new event channel but I still think it\nwould be nice to have something built into redux-saga to help with this\ncase. Maybe a custom/new effect. It could operate like a hybrid of take\nand select\nfunction takeWithPreviousState(pattern, previousStateSelector)\nIt would return when pattern is matched but in addition to returning\naction it would return the result of the previousStateSelector run\nagainst the state immediately before the action matching pattern was\nprocessed by the reducers.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/538#issuecomment-246484981,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkkSyd3iztE18i8bPjJMJ01rahGy4ks5qpbixgaJpZM4J5l4h\n.\n. I would recommend similar thing like I've proposed in other question thread - https://github.com/yelouafi/redux-saga/issues/532#issuecomment-245337343\n\nfunction* serial() {\n    // map your data to effects (which are just plain objects)\n    const effects = ['hoge', 'huga', ...].map( (item) => call(xxxfunc, item) );\n    // yield those created effect-objects to the saga, so it can run them all in parallel\n    yield effects\n}\n. Oh sorry. Ive misunderstood your intention. I guess then just regular loop\nwill do fine. Just iterate through your array with for loop. Would be nice though to have some kind of new effect or helper for such use case.\nOn Tue, 13 Sep 2016 at 04:57, kuma yuta notifications@github.com wrote:\n\nThank you!\nThe point is, does this mean I can not to be serial?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/540#issuecomment-246559177,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkmkeIFKb6INBgvpmMY1lUiOr6ksfks5qphEPgaJpZM4J6kl7\n.\n. Thought about it only as a helper as its ofc trivial to implement it. Got kinda requested here - #540. Feel free to close if you think it is an overkill\n. yield forkedTasks.map(task => task.done) - probably array handling should be implemented for join effect, gonna give it a try in a minute\n\nAs of this 'error interception' - I think this might be the difference between fork and spawn themselves. With spawn your task is detached and it is acting as top level task. \nI've debugged the issue a little bit.\n1. Your both scenarios are reaching this point - https://github.com/yelouafi/redux-saga/blob/339ea9a8753d0a60dd006f2d8b2b26e88d75505e/src/internal/proc.js#L254 but with spawn those yielded promises are getting rejected and therefore error is thrown into the saga\n2. Both your scenarios reache also this https://github.com/yelouafi/redux-saga/blob/339ea9a8753d0a60dd006f2d8b2b26e88d75505e/src/internal/proc.js#L84 but with fork tasks.length === 1 and with spawn it is 0. So with fork effect is geting settled during this cancelation process and when promises from 1. are geting rejected it is already settled so it wont run this https://github.com/yelouafi/redux-saga/blob/339ea9a8753d0a60dd006f2d8b2b26e88d75505e/src/internal/proc.js#L273 but spawn was not settled yet so it will run through the check and receive this error\n3. .return() is used there so you could add finally block to your first snippet and perform some logic there\nBut anyway I dont know if what you are trying to accomplish is feasible, both scenarios will end up with stdChannel closed so you wont be able to take anything anymore etc.\nI think this is the problem with your joining method based on quite internal promises, because such snippet seems to work (parent being able to catch child error)\n```\nfunction saga() {\n    try {\n        const task2 = yield fork(function () {\n            yield call(delay, 1000)\n            throw new Error('test')\n        })\n    yield take('TEST')\n} catch (e) {\n    throw e;\n}\n\n}\n```\nEDIT:// having problem with implementing runJoinEffect([...tasks]) cleanly for now. Maybe i'll think about it some time later.\n. I've recently have noticed the same thing and thought about it as a bug too, look here - https://github.com/yelouafi/redux-saga/issues/507\nAnd later have implemented this - https://github.com/yelouafi/redux-saga/pull/539 , so take(chan, pattern) may not be used at all as it produces various unexpected effects.\nImplementing support for taking from channels with pattern would be a little bit strange, cause it would have to be implemented at buffer level and it stays agnostic of the pattern so far. They are just FIFO queues.\n. Well, you could implement your own channel and buffer with the API of those provided in the lib and just tweak yours to your custom needs, but it depends if my PR will get merged in. If it get merged in you would also have to implement your take(chan, pattern) effect.\nI realise though it is hacking around the lib pretty much.\nYou could maybe split actions between various channels, so you could have more control about what you are taking without need of a pattern.\nAnd ofc as it is I guess quite common possible use case, you could wait for @yelouafi response :)\n. As take(chan, pattern) API was hidden completely in 0.12 to avoid such confusions, I'll close the issue right now.\nIn general I think that your proposal makes sense, but present buffer FIFO-like implementation is not suitable for the purpose.\n. I think the second option is more natural - race should have just one winner. I've tried to reproduce your issue with channels dropping messages, but no luck so far.\n. R u able to post a fiddle with reproduced bug?\nOn Wed, 12 Oct 2016 at 17:42, athibaud notifications@github.com wrote:\n\nran into this too.\nthe second option seems more natural to me. race should only have one\nwinner, agreed.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/546#issuecomment-253246774,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkhskhQF6eaUDpDaRepanDQzRv-mPks5qzPxbgaJpZM4J9DLJ\n.\n. @avaragado @athibaud \nDo you think it could be connected to the issue fixed by https://github.com/yelouafi/redux-saga/pull/583 ?\n\nIn general It could have been hard to reproduce cause just after race being resolved bug might have not been surfaced yet, just after the next tick. That is because injected value by the saga as the outcome of race is geting handled synchronously and therefore until another yield lines are geting executed as go (obviously ;) ).\nIn the same time if you were racing possibly synchronous effects (takes from channels) their synchronous callbacks were queued one after another in a loop, synchronous ofc too. So in the end sequence of events were like:\n1. running race effect\n2. trying to resolve 1st take\n3. resolved -> took action from the channel -> immediately/synchronously resolve the race with it\n4. trying to resolve 2nd take\n5. resolved -> took action from the channel -> race already resolved, but msg got already dropped\n. Fix already merged in, soon be available in next release\nOn Tue, 18 Oct 2016 at 17:42, athibaud notifications@github.com wrote:\n\n@Andarist https://github.com/Andarist this seems like exactly what was\nhappening. (also, one of the channels was 'fed' by an external/async\neventChannel so it makes it slightly more likely that the double message\nscenario could happen).\nunfortunately i have switched my implementation since running into that\nbug so i cannot confirm :(\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/546#issuecomment-254549016,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkkwH1rMjbdCP6ZJwgs-EAdwaB6NCks5q1OkBgaJpZM4J9DLJ\n.\n. If I understand you correctly your code is fine, however for now you might lose some buffered items WHEN in the exact moment of yield race you have waiting items in both queues. In the same moment they wont be both returned to the saga, only the first one will be, and the second one will get dropped in the bakcground silently without you even knowing that.\n\nFix is already on the master, I'll try to have it published asap as 0.12.1.\n. It took some time, but the fix finally has landed in the newest version! v0.12.1 has been published.\n. Thanks for posting, should be useful for somebody searching for the answers in the future!. That's probably cause you are running somehow watchSubmitLike twice. Could you post a snippet with the moment you are starting your root saga and this one?\n. Still dont know how are you running this - getAsyncInjectors. Break yourself on this line - sagas.map(store.runSaga); and it will be reached probably at least 2 times with the mentioned watchSubmitLike saga. Check why is that and you will probbaly know how to fix this.\n. @yummyelin thats the way to go. How are 1 and 2 connected? Where and how 2nd generator (myDocumentsLoad) is ran?\n. Ok. This might be in fact a little bit confusing - the ordering of things here. I would say the easiest and the most 'clean' way of handling this is using channel. You can do smth like that:\n```\nexport function* loadMultipleDataSources() {\n    const chan = yield actionChannel([\n        document_actions.MY_DOCUMENTS_LOAD_CACHED,\n        document_actions.MY_DOCUMENTS_LOAD_SUCCEEDED,\n    ]);\n    // load data source A\n    yield put(document_actions.myDocumentsLoad());\n    yield take(chan);\n// load data source B, this must happend after 'MY_DOCUMENTS' are in the redux store\n// load data source C...\n\n```\nIt will buffer those actions internally in the created channel, so you wont miss them.\n. It acts like a listener for the action types you have passed in while creating it and also it has a buffer iternally, so if you really want to dispose it I would suggest just closing it - chan.close()\n. Some possible approach was posted here - https://github.com/yelouafi/redux-saga/issues/660#issuecomment-263612752\nHowever your use case could be a different one, the only way to change your state which you have wanted to check in your select effect is dispatching an action, so the simplest way of detecting changes is just this\njavascript\nwhile () {\n  yield take(ACTION_TRIGGERING_CALENDAR_ENTRIES_CHANGE)\n  const entry = yield select((state) => state.calendar.entries[0]);\n  //... do smth\n}\nPlease remember that even time1 and time2 shouldnt be equal, so your change detection was kinda broken in the first place\njavascript\nconst time1 = moment()\nconst time2 = moment()\ntime1.isSame(time2) // false\nIf you still have further questions, please reopen the issue, Ill try to help to my best. great news, gonna update soon in my project \ud83d\udc4d \n. Every effect is handled by runEffect function - https://github.com/redux-saga/redux-saga/blob/238b394f73bd7c58a330052cba27bd01602306ac/src/internal/proc.js#L307 . Just look what is returned. You would need to implement runRunEffect in similar way that other 'runners' are implemented.\nAlso you would have need to implement run effect creator here - https://github.com/redux-saga/redux-saga/blob/238b394f73bd7c58a330052cba27bd01602306ac/src/internal/io.js#L75 which effectively just wraps your yielded effect in an object so it can be interpreted later by runEffect in proc.js.\nAlthough I dont quite grasp this - \"run, which is like call except that it runs the given saga in the context of the current saga.\". Could you write a full example of usage of this run effect? What is exactly returned in case of run and in case of call?\n. Ok, I guess I see the difference with to which saga forks are attached, however I have no idea whats the purpose, beside monad wizardry ;) not saying that its worthless, just dont see a personal attraction to it right now.\nfunction calling() {\n      yield call(forkingSaga);\n      // never get here\n}\nStill aint sure though what did u mean with 'never get here', forkingSaga will terminate after yielding fork effect and calling will get resumed.\n. Cant find that behavior nor in the docs nor in the source code, im on\nmobile though.\nSuch behavior seems to me at least weird. Did u check if it rly behaves\nlike that? Do u think it should?\n. Thanks for pointing that out, had no idea this works like that, fortunately never had urge to call forking task :)\nIn that case your run effect is indeed a little bit more complicated, but not impossible I guess.\n. Reopening this as I would like to spend some more thought on it and explore the idea, which truth to be told is not so easy for me to grasp as thinking about monads is really a brainburner when one is not accustomed to it.\nHowever your example of:\njavascript\nexport function* doBackground(saga, config) {\n   const handle = yield fork(backgroundTask(saga, config));\n   return handle;\n}\nSeems like a legitimate use case. One should be able to call it somehow in non-blocking manner and get the handle in the caller saga. It is possible now by forking instead of calling + join on the resulting task, but it will be joined only after doBackground finishes here so only after backgroundTask finishes, so effectively - pointless.\nMaybe some call.nonblocking / call.spread (better naming should be used of course :) ) could be introduced. Would that somehow solve your issue? Or only a part of it? Wild idea - maybe call should behave like call.nonblocking and call.block should be introduced to behave like the call now?\n@yelouafi what were your thoughts about this? you probably get a lot more about this as you are more familiar with functional concepts\nYour requested run which would act like yield* would be possible to achieve, just wondering if there is other use case for that than a monad wizardry.. So, I would like to implement this one way or another, but aint sure when yet. Still I won't merge it in until @yelouafi comes back and have time to comment on the matter.\nDont take me wrong - 'monad wizardry' isnt something bad in mi eyes and I think that it was certainly helpful from your side to include this reasoning etc. Its just me who is not too familiar with these concepts (yet :P)\n\nSagas (call/fork/join/take) are just another Monad (or they would be if we had run :P).\n\nwhy they would be then and are not now?. @ericelliott Yeah, I know about the spec and ofc would like to follow it if possible, but for now there are more pressing issues in the library than this and also this is a little over my head at the moment. Would need to study a little bit more about monads to understand it and implement properly.. but why should such thing be constrained at this level? more appropriate place for such a constraint would be an eslint rule\n. I really aint sure what is yoru exact problem. Could you be more elaborate?\nWhat is your expected behaviour?\n. fsm stands for finite state machine. \nfsmIterator just wraps passed in map of states and has ability to interpret them later so that resulting next function on the created iterator behaves just like the generator-created one. You could say that generator syntax is a sugar allowing you to do the same thing, just in the more pleasant way.\nAs for state machines - look on the example graph https://upload.wikimedia.org/wikipedia/commons/thumb/9/9e/Turnstile_state_machine_colored.svg/330px-Turnstile_state_machine_colored.svg.png . Nodes represent states of the machines (traditionally denoted as qs) and arrows denote possible transitions between state and next state (correlated with some input ofc, so branching is possible).\nLets look on the simplest example - https://github.com/yelouafi/redux-saga/blob/8a76a1c7eeb97de58072b2e3ab721a59675d0365/src/internal/sagaHelpers.js#L45-L55\nAccording to the function fsmIterator(fsm, q0, name = 'iterator') signature fsm is map of states which I will describe in the moment. q0 is a starting state and name is just for convenience.\nMap of states is an object with state transitions methods which needs to return tuples of [nextState, yieldedValue, stateUpdater]. So going back to the takeEvery example - q1 is the starting point of the state machine and it says:\nq1() { return ['q2', yTake, setAction] } which we could translate to - when transitioned to state q1 yield yTake (just a { done, value: take(pattern) } here), which can be interprated by the saga accordingly, cause take is an effect known to the 'puller', and when resumed call setAction with resuming value (taken action) and transition to state q2.\nHandling q2 is pretty much the same - \"when transitioned to this tuple[0] state yield tuple[1] and when resumed call tuple[2] on resuming/injected value\".\nAnd this kinda weird yTake and setAction are there only for keeping things in the scope, available for using by each state.\n. could we maybe list various proposals for such strategies? they could be implemented and exposed as functions which simply wraps fork effect. However in that case we would have to handle all scenarios internally, so they would have to be constrained to minimum. Upon which somebody could built his own complex strategies.\nBasic one would be detach and spawn could be implemented using it like this\n```javascript\nconst spawn = (...args) => detach(fork(...args))\n// in saga\nyield detach(fork(someWorker)) // same as yield spawn(someWorker)\n```\nSo that would become just a simple function composition and such functions could be mixed and matched.\nIf thats something we would like to pursue we would have to find a name for a detach's sibling. Detach states about error propagation (upwards) - what about cancel propagation (downwards)?\nWDYT?. @ajwhite Really interesting stuff. Need a calm moment to read it again and comment, but I'll be back here with my thoughts for sure!. @ajwhite I think your ideas are really neat and possibly useful for others. Do you plan to share this with others as library?. redux-saga has recently migrated to the organization account and therefore some public urls have changed, the correct one should be https://redux-saga.github.io/redux-saga/docs/introduction/index.html from now on\nis there somewhere in the docs linked old version of the URL? or have just tried to enter it manually?. Fixed, thanks for noticing!. Could you possibly make a fiddle with the reproduced issue? Would be really helpful for fixing this sooner than later :)\n. Fixed the issue, probably will merge soon, although I would like to have @yelouafi look at the PR beforehand\n. Thanks for pointing out, will try to unify this soon\n. I've standardized error logs a little bit in latest release. Gonna close this issue - but if you feel there is any more room to improvement (beside implementing babel plugin for better stack traces like mentioned here) please create a new issue so we can discuss this further.. I've just noticed that myself, do you maybe use some console.logs for debugging purposes? I've somehow found that with them in my code it was failing but the moment I've deleted them it started to work again.\n. Do you have any ideas how this could be improved? Depending on the timing is indeed not ideal, but as throttle is about the time I had no idea how to test it in other manner.\n. Personally I dont think even dozen dependencies for development purposes is too much, as long as they make your life easier :) Gonna look into both links soon, thanks for sharing.\n. Thanks for the PR, I'll hopefully have some time in the weekend to look into it.\n. Thanks for noticing and fixing right away!\n. I really like the attempt to give another possibility of testings as I think, just like @axelson, that the way of iterating through the iterator is just too tied to the implementation.\nThat being said I dont yet what to think about those interceptors. First of all - would be nice to find use case for them outside of testings, cause I generally dont like adding the code just for testings purposes, ofc completely different thing is writing the code in a way it can be tested more easily and/or exposing some external helpers/APIs which can help in testing, but are not included in the core lib.\nWhen I think about it now, the solution I would be pleased with would include:\n1. running the saga, alone or in context of the store, aint sure which yet\n2. collecting effects in some organised manner, so they can be tested later with deep equality checks\n3. custom resolution when needed, which is included in your interceptors example\n4. some way of 'spying' on forked tasks, could be done by running saga in the context of store and actually running forked workers which cannot be done now with iterating approach\nThe thing I dont know how to solve for now are the endless loops inside the generators. It would be the best if we could have knowledge about them and just group yields from such a loop as some kind of endlessTask without need of knowing how many yields are inside and all the branching in it. Such endlessTask logic would become more easily tested then.\nWe could introduce a new effect - repeat, so the endlessTask content is already grouped in the userland for us and we can just expose ability to run it in the tests on demand with various branching logic. WDYT? It would be roughly equivalent of:\n``` javascript\nfunction repeat(worker, ...args) {\n    const task = yield fork(function* () {\n        while (true) {\n            yield call(worker, ...args)\n        }\n    })\nreturn task\n\n}\n``\n. What do you plan to do with endless loops like while (true)?. You can keep an eye on the [v1 progress](https://github.com/redux-saga/redux-saga/milestone/1). You can also notice that Im being active lately and committing to themaster` few times a week. \nThat said there is still some work (not really any hard work, but it is still time-consuming) left to be done. I plan to give my attention to this particular issue soon, it doesn't mean that I will release v1 as soon as it's done, I can publish some alpha version though if you want. You can checkout latest commits, there was no really ground breaking changes, and there wont be, so I would say that using what's on the master (its tested after all) shouldn't really cause any real problems. I wouldn't hesitate upgrading in my own projects, just have no time for this atm as pushing v1 forward is just more important. Let me know if you are interested in becoming the first alpha tester ;). Cool, I'll let you know asap when that feature is ready then. I will also start to sum up recent changes so you won't get blindsided.. > Version 4 of the library redux-elm already solves it in a nice way for components, action creators and reducers, but we still need to inject these custom bound effects into our original sagas.\n@eliseumds isn't it only a problem of syncing appropriately (preferably automatically) your sagas to instances? I guess enhanceComponent from redux-elm is doing this for components, you could probably have additional wrapper or have this one parametrized with saga - and just proxy or something yielded effects to inject instance-based parameter to ur take/put/select.\nIm not familiar with redux-elm though so I don't quite know if that's completely feasible. It seems it still needs quite a lot of boilerplate in the List~ view to generate selectors etc manually.. This feature (in slightly different form - as effectMiddlewares) got implemented by @eloytoro (thanks again!) and it got merged in. Gonna do a beta v1 release in following hour. @frankandrobot I'd appreciate testing and any feedback you can give on this.\nHow it might be used can be checked here. That really depends how do you start this saga, what do you do on route changes?\n. No problem, I'm glad you have figured it out :)\n. Thanks for fixes! Highly appreciated. \ud83c\udf89 \n. call is a blocking effect so you can just skip this whole firstTask flag.\nIn ur fork just put take and call in a while (true) loop. Effect will be\nthe same and what u r looking for\nfunction* takeFirst(pattern, saga, ...args) {\n  const task = yield fork(function* () {\n    while(true) {\n      const action = yield take(pattern);\n      yield call(saga, ...args.concat(action));\n    }\n  });\n  return task;\n}\n. I would rather base this one on https://github.com/yelouafi/redux-saga/blob/master/test/sagaHelpers/takeLatest.js , rather than on takeEvery. You can dispatch your action, multiple times (so only first will get handled), then resolve promise in the called worker so it gets unblocked. Push to the actual some time on the way and just check in the end that it contains only one action\n. actually takeFirst should be defined as:\njs\nexport const takeFirst = fork(function* (pattern, saga, ...args) {\n  while(true) {\n    const action = yield take(pattern);\n    yield call(saga, ...args.concat(action));\n  }\n})\nthat way it could be yielded like this (without the *):\njs\nyield takeFirst(...)\nand it would mirror how takeEvery etc are implemented in the core.. There is other issue about this - https://github.com/redux-saga/redux-saga/issues/1315 and outside contributor has offered his help in providing this.. please correct it to:\n```js\nimport { fork, call, take } from 'redux-saga/effects'\nexport default (pattern, saga, ...args) => fork(function* () {\n    while(true) {\n        const action = yield take(pattern)\n        yield call(saga, ...args.concat(action))\n    }\n})\n``\nalthough Ive looked on this only for a brief moment, so I hope it will work for you. Maybe - it needs internal implementation. I'd also appreciate better name for it though astakeFirstis imho not the best one.. I liketakeLeading\ud83d\udc4d @tomoyukim r u still working on this?. Please don't be demanding about OSS (even with added smile) - it can truly discourage people from helping. Pressure is never good and we all are just volunteers here.. @thorlukasz it's released, just under beta tag and not the latest, you have to install it withnpm install --save redux-saga@beta. >  it's released, just under beta tag and not the latest, you have to install it with npm install --save redux-saga@beta. It will, we hope to release final v1 this month (or next one). . Your snippets are roughly equivalent -fork` is only adding an extra layer of a task internally.\nI think what you might have meant is the difference between those:\n```js\nfunction takeFirstA(pattern, saga, ...args) {\n  yield fork(function() {\n    while (true) {\n      const action = yield take(pattern);\n      yield call(saga, ...args.concat(action));\n    }\n  });\n}\nfunction takeFirstB(pattern, saga, ...args) {\n  return fork(function*() {\n    while (true) {\n      const action = yield take(pattern);\n      yield call(saga, ...args.concat(action));\n    }\n  });\n}\n```\ntakeFirstB is a factory for an effect (so idiomatic way of running new tasks in saga), whereas takeFirstA is a generator, so to run it in idiomatic way (through effects) you should actually do yield fork(takeFirstA, \"INCREMENT_ASYNC\", incrementAsync).\n. @aikoven could you take a look on it?\n. First of all your getSessionApi doesnt return a Promise. You should add explicit return or omit surrounding curly brackets to leverage the implicit one. Please check again after you fix this.\n. No problem, happy you got it working :)\nOn Wed, 19 Oct 2016 at 09:07, Alleo Indong notifications@github.com wrote:\n\nClosed #592 https://github.com/yelouafi/redux-saga/issues/592.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/592#event-828605192, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkpncGOFs3-lKMRtvVNBxPFygu62kks5q1cHEgaJpZM4KZYHK\n.\n. @benhughes \n\nCool, could be merged, but would prefer if you squash those 4 commits into one, to keep the history cleaner. Additionally you can rebase too. Thanks in advance!\n. Thanks!\n. Thanks!\n. Yeah, that's probably the good idea with depraction working, gonna figure it out how to handle it.\n. @yelouafi \nUpdated the code, please take a look, if everything is fine Im gonna fix the tests and prepare docs and merge to the master and possibly draft a new release.. This\nconst generator = mySaga();\nconst testChanA = actionChannel('TYPE_A');\nexpect(generator.next()).to.deep.equal(chanA);\nshould be\nconst generator = mySaga();\nconst testChanA = actionChannel('TYPE_A');\nexpect(generator.next()).to.deep.equal(testChanA);\nEffects are just plain object and actionChannel effect does not hold any function references so it should be fine to check deep equality against it. Effects become executed only after real redux-saga interprets them.\nPersonally I think this way of testing the saga (iterating through the generator) is far away from perfect anyway, there is a begining of the effort to make testing more robust, so it can be tested more in store-like environment and so you wouldnt have to worry about inserting a new non-behaviour-changing yield in between to break your tests. Just look on some other threads about testing in the issues. There are even 2 community written libraries which aim at easing that.\nAbout take(channel) - you probably could mock channel in your test. You can even import  { channel } from 'redux-saga' and have the interface implemented already. So this\nexpect(generator.next(testChanA)).to.deep.equal(take(testChanA)); // Also fails, see error below\nwould become smth like\nconst mockedChannel = channel()\nexpect(generator.next(mockedChannel)).to.deep.equal(take(mockedChannel));\n. Could you probably post code both of appSocketForwardParser and appSocketForwardParserCopy. I see there are some races involved and to better understand the flow it would be really helpful.\n. Are you able to debug a little bit the saga internals? Crucial would be to check if and possibly why during your - yield put(parsedAction) there is a lock preventing from the effect being executed immediately. From what I see in the source code, the only reasoning I might come to is that - its locked for some reason and lock is lifted too late, so in the meantime websocket's onmessage callback is emiting the action you would expected race is already waiting for.\nhttps://github.com/yelouafi/redux-saga/blob/dfefd046d70615c662971b10438c0881fe84503f/src/internal/asap.js#L5 - it would be the starting point for debugging. I would propose checking these:\n1. if it is locked indeed\n2. when the lock is taken down (what line is doing a flush and why)\n3. when the lock was set up in the first place, before coming to the point of yield put(parsedAction)\n. Hm, there is quite some things going on here and debugging it through this issue thread might be a rl long process ;) Could we maybe schedule some teamviewer session or smth to handle it? \n. Got fixed in https://github.com/yelouafi/redux-saga/issues/622\n. It might be a good idea to also reflect that in src/internal/buffers.js. Would you like to change it there as well?\n. Thanks!\n. Thanks for noticing.\n@yelouafi \nI guess gitbook needs to be published, cause its fixed already on the master.\n. Non-blocking - take(pattern) doesnt rly make sense, as take is acting as a listener for a pattern so it needs to be set up first and can listen only for actions AFTER being set up. Non-blocking kinda means that action would be available for a taking in the exact moment of take (listener) being set up. And those 2 cant happen in the same moment.\nNon-blocking - take(channel) does make a little bit more sense, as channel can buffer things inside it, so it is possible that there is something already in the channel and in that case it will be returned to the saga synchronously so such scenario is made in non-blocking fashion. There is also a scenario where in the moment of take there is nothing in the buffer it will block until something pop ups in the buffer to be taken. To sum it up - non-blocking maybeTake (not the best name ;) ) would make sense only for channel usage, cause there are different scenarios right now when you take(channel).\nFor a non-blocking take(channel) someone could maybe try to utilize smth like:\nconst actions = yield flush(channel)\nif (actions) {\n    // ...\n}\nBut lets go back to your case I aint sure whats the exact flow you are trying to achieve, but probably you should check out the race effect.\nfunction* callApi(login, params) {\n    const { jsonResult } = yield call(login, params)\n    yield put({ type: 'LOGIN_SUCCESS', data: jsonResult })\n}\nfunction* _loginFlow() {\n    while (true) {\n        const { payload } = yield take(\"LOGIN\")\n        yield fork(callApi, api.login, payload.params)\n        const { jumpTo, loginSuccess } = yield race({\n            jumpTo: take(\"JUMPTO_LOGIN\"),\n            loginSuccess: take(\"LOGIN_SUCCESS\")\n        });\n        if (jumpTo) {\n            // jump back\n            continue\n        }\n        const { data: jsonResult } = loginSuccess.data\n        // the origin success staff\n   }\n}\n. Yeah, didnt even think about it. Its probably in this case even a better solution than racing 2 takes\n. related I think - https://github.com/yelouafi/redux-saga/issues/604\n. Closing ss it got included in https://github.com/yelouafi/redux-saga/pull/622 \n. The case is kinda tricky, I'll try to explain what's happening and why. put is kinda 'synchronously' blocking. \nWhat I mean by that that its not just a simple wrapper around dispatch. Its effect runner (the function executing put effect) is wrapping a function making a dispatch in asap queue. asap can handle 2 scenarios: \n1. If queue is suspended its pushing a task (dispatching one) to the end of the queue and the queue will get executed when flushed\n2. If queue is not suspended its suspending it immediately, adding to the queue AND flush. So the queued task is the first to happen (action dispatched etc). But if this dispatched action now triggers some takes during being emitted to the redux-saga and other puts come into play because of that they will meet the 1st scenario, cause this 1st put has suspended the queue, but as they get pushed to the queue they will be executed by the same flushing loop. isSuspending lock is lifted on the end of the flush, when all queued tasks finish.\nThat being said, once a task is executed it will resume effectively dispatch and resume your saga.\nHowever you are meeting the other asap fatigue. takeLatest is consisted of such logical steps:\n1. yield take(pattern) - 'take(some-action)' here\n2. when action is taken it checks if there is already a previous task, if it is - yield cancel(prevTask)\n3. prevTask = yield fork(worker), go back to the 1st step\nWhile looking at the fork effect runner we could see such thing\nasap.suspend()\nconst task = proc(taskIterator, subscribe, dispatch, getState, options, effectId, fn.name, (detached ? null : noop))\n// ...\nasap.flush()\nEffectively that's what happening in your case:\n1. running fork, cause of your takeLatest\n2. therefore suspending the asap\n3. running your worker, geting to yield put({ type: 'trigger-async-calls' })\n4. executing this put, trying to asap dispatching, but as its suspended, its geting to the queue instead of dispatching right away\n5. geting to the asap.flush(), executing the queued dispatch({ type: 'trigger-async-calls' })\n6. the action is emitted back to the saga by the middleware where there is already a listener waiting for it (take('trigger-async-calls'))\n7. resuming that generator and meeting yield put({ type: 'trigger-saga-a' }), trying to asap it, but we are in the middle of the flush (step 5), so its queued up\n8. finishing dispatching trigger-async-calls (step 5) so resuming your worker and hence api.thirdCall happens\n9. flush geting next item from the queue - and therefore dispatching your trigger-saga-a now\n. Well, truth to be told - i dont even even know if its 100% correct and if\nit holds up in the future. Scheduling is a really complex situation and it\nneeds to be addressed accordingly\nOn Fri, 28 Oct 2016 at 16:58, Matt Granmoe notifications@github.com wrote:\n\nWow! Thank you for the detailed explanation :-) \ud83d\udc4d \ud83d\udc4d \ud83d\udc4d\nI decided to just yield put a success action at the end of sagaA and yield\ntake it right after the put in mainSaga. I'm going to have to read your\nreply a few times to fully understand it.\nThanks again :-)\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/604#issuecomment-256943612,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkgECGQkEcmeLd_9hj09BV6TbaHGnks5q4g2JgaJpZM4KjAUR\n.\n. Out of curiosity - do you have an use case when this is creating a problem?\n\nIt is caused by synchronous takes here. Saga is returning immediately to the generator value taken from the channel and as you are using an endless loop to pull those values out your call stack is pilling up. The only thing I'm surprised here is that RangeError is thrown, kinda misleading.\n@yelouafi what do you think, should we disallow sync takes somehow ?\n. Well, the problem is how this is handled by the saga internally - you have buffered many items in the channel before running the endless loop, which is fine in most cases, but your take is handled synchronously and its going back to the endless loop immediately within the same call stack.\nPersonally I would just trick it for now with your timeout solution like so\njavascript\nwhile (true) {\n  const data = yield take(channel);\n  yield call(log, data);\n  yield call(delay, 0);\n}\nDepending on the take being sync is not a good idea anyway, so forcing it to be handled async is the only way to go here and probably the only solution that could be hidden in the redux-saga internals anyway.\nIf you need it handled synchronously I would recommend flushing the channel, calculating what you need and proceed with that.\n. Sure thing. We'll do smth about it. Aint sure what yet though\n. what about just making it async? looks a little bit hacky in the code, but i dont think it being sync solves anything for anyone and the behaviour shouldnt be taken for granted anywhere. Also it might be confusing to newcomers that in majority of cases its async but sometimes it is not\n. Just yield flush(channel)\n. Well, you can always pass a buffer manually, so you have reference to it and you can check its isEmpty method\n``` javascript\nimport { buffers } from 'redux-saga'\nimport { actionChannel } from 'redux-saga/effects'\nfunction* saga() {\n  const buffer = buffers.fixed() // or some other buffer type\n  const chan = yield actionChannel('ACTION_TYPE', buffer)\nif (buffer.isEmpty()) {\n     //...\n  }\n}\n``\n. Ive tried running the example and didnt encounter such problem, I've checked/projects/redux-saga/examples/real-world/node_modules/redux-logger/lib/defaults.jsand has justlogger: console,instead oflogger: undefined && undefined.console || window && window.console,` which appeared in the log you have pasted in.\nCould you try reinstalling node_modules?\n. Gonna close it as its included in the PR that will get merged soon.. One thing I dont understand - why did you change forks to spawns?\n. @slorber \nbut that is already handled by try/catch over yield call(fetchPosts, reddit) \n. Commented on the code. Aditionally when you change it, it would be nice if you rebase to master + squash those commits.\n. Thanks\n. redux-saga only listens for actions (and can dispatch too ofc). It has no power to control if the taken action hits reducers or not. If you need to separate those you need to split the action into 2. It would look smth like this:\njavascript\n// load repo unless it is cached\nfunction* loadRepo(fullName, requiredFields) {\n  const repo = yield select(getRepo, fullName)\n  if (!repo || requiredFields.some(key => !repo.hasOwnProperty(key)))\n    yield put({ type: 'FETCH_REPO' }) // just listen for FETCH_REPO in your reducers, so it only shows the spinner while truly downloading data from the server\n    yield call(fetchRepo, fullName)\n}\n// Fetches data for a Repo: repo data + repo stargazers\nfunction* watchLoadRepo {\n  while(true) {\n    const {fullName, requiredFields = []} = yield take(actions.LOAD_REPO) // do not listen on LOAD_REPO in reducers\n    yield fork(loadRepo, fullName, requiredFields)\n  }\n}\n. Well, as I said - saga acts as a listener for dispatched actions and it wont prevent them from happening. What I've mentioned is a proposed solution, you could do bunch of other stuff to deal with it, but it depends on how you want to handle it, what you feel is the best for your project etc. There is no ultimate solution here, but I guess splitting action into 2 is the most straghtforward and recommended one (but ofc not enforced), you could maybe just name them differently - instead of yield put({ type: 'FETCH_REPO' }) for example yield put({ type: 'SHOW_SPINNER' })\n. Check out related issue - https://github.com/yelouafi/redux-saga/issues/307#issuecomment-217197011 . Ofc do not hesitate to ask additional questions.\n. Well, such thing could be achieved with eventChannel as you have mentioned and it would look smth like that\n``` javascript\nconst identity = (a) => a\nconst createAsync = () => {\n    let emit\n    const chan = eventChannel(emitter => {\n        emit = emitter\n        return () => {}\n    })\n    const promise = new Promise((resolve, reject) => {\n        setTimeout(() => emit(50), 100)\n        setTimeout(() => emit(80), 200)\n        setTimeout(() => {\n            resolve('result')\n            emit(END)\n        }, 500)\n    })\nreturn [ promise, chan ]\n\n}\nfunction* watchOnProgress(chan) {\n    while (true) {\n        const data = yield take(chan)\n        yield put({ type: 'PROGRESS', payload: data })\n    }\n}\nfunction* uploadSource(action) {\n    const [ promise, chan ] = createAsync()\n    yield fork(watchOnProgress, chan)\n    const result = yield call(identity(promise))\n    yield put({ type: 'SUCCESS', payload: result })\n}\n```\nI realise that its not the cleanest solution with the exposing of emit outside of the callback so promise can utilize it, but its what I've come up with for now. \n. It's console.info, so you can easily filter it out, also its dev only\n. Sorry that it took so long to act on this in any way.\nWhat I would propose for now is - console.log only non-cancel cancellations (what a mumbo jumbo). What I mean is that we can distinguish why the cancelation has happened - is it user induced via cancel effect (no logging should take place) or is it cancel caused by cancel propagation when something throws (logging should take place in dev mode).\n@aikoven \nI like your displayName idea, will try to explore this. Would be also useful for overriding display name for helper effects like takeEvery as its implemented as mere fork(takeEveryHelper), would be cool to omit fork part out of this.. > for this, we could also group these messages to more clearly indicate where the error originated and to which cancellations it lead.\nMore trickier, but may be doable, gonna try this when I have time!\n\nActually I have a lot of higher order sagas / custom effects, both could benefit from this.\n\nCould you share some of your ideas for higher order sagas / custom effects? Just names, not necessarily the code. I think it would be cool to expose the idea more to the audience by making a section of the docs about those 2.\nAs to higher order sagas I didnt do much of them in my app but like 1 or 2 became really handy, especially trailingThrottle and takeEveryBetween. Didnt have chance (or need) to write custom effects though other than some specified higher order functions returning regular take, like takeResponse (from websocket connection).\n\nsetFunctionName\n\nIs there any particular reason you are using defineProperty here instead of just assigning?. Yeah, ive kinda have ended yesterday with the same conclusion - there is not really that much gain of custom effects as they tend to be achievable with higher order sagas in most cases. \nThere are those rare occasions when its hard to implement things with higher order sagas alone. For example your context feature. Although the easier version without dynamic scoping could be also easy implemented with a module keeping your context in a closure.\nAlso its not possible for now to have a forking worker (started due to call effect) which would return its result immediately when ending itself.\nAlthough those custom effects are rather rarily needed it would still be cool to have a way of extending the core and built-ins.\nIm now also wondering if moving helpers to the effects was a good idea (cc @yelouafi). It might be a good idea to move them out of there (again... :/) and create a separate module called 'helpers' (higher-order sagas is really a long name). Plus obviously spend more time in the docs about the idea of higher order sagas, so people understand the concept and dont be confused about separation of those and effects.\nNice ideas with your examples! Is listenState implemented using take('*')?. That's certainlt something that should be done. Ive added help wanted label. Maybe somebody would like tackle this? I can help with explaining the source code, but hadnt time to sit down and fix this yet (and probably wont in the nearest future).. https://github.com/redux-saga/redux-saga/commit/f4b52b04eb6bb9094ab07661c98178b55b401a85\nGonna fo a release in a moment.. Truth to be told I dont quite grasp whats the exact problem, it would be much better if you paste some code with explanatory whats wrong on each of the step and what did you expect to happen.\n. I think you have the same question as in\nhttps://github.com/yelouafi/redux-saga/issues/589\nOn Sat, 5 Nov 2016 at 04:21, Stephen Collins notifications@github.com\nwrote:\n\nQuick question: Is it possible to ignore actions?\nI have a saga for a request in my application that can take about 10\nseconds, and it is possible to fire the action for this saga more than\nonce. I need to only respond to the first request and ignore the rest. How\ndo I create a saga (or watcher, really) that will only execute when that\naction is not currently being run?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/616, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkg5I9CyXGMtMOe0KRb74heQBeGfRks5q6_YfgaJpZM4KqJo7\n.\n. You've already filed an issue in their repository - https://github.com/cdnjs/cdnjs/issues/9501 . It got High Priority and an assignee already, so hopefully it will be added there soon. I think it should be handled there from now on, so gonna close the issue here.\n. That is not a correct pattern, that is because put causes dispatch but the generator is resolved only once the dispatch is finished, so it doesnt meet take again yet. Only subsequent initialAction could be taken by this take. \n\nThink of take as one-time subscriber to the action type. Once its resolved it's no longer listening to the action till the time generator meets it again so the subscriber can be set up once again.\n. Well i dont know whats the scenario u would like to handle. If you describe\nwhat u can do i might look on it and possibly help a little\nOn Mon, 7 Nov 2016 at 15:25, Nicolas Medina Sanchez \nnotifications@github.com wrote:\n\n@Andarist https://github.com/Andarist Thanks for the answer, I was\nsuspecting something like this.\nThe way I managed to get it working now is to create a second function\ncalled wacther that will permit this loop. Here is what I got so far:\nfunction * example () {\n  while (true) {\n    yield take('start')\n    const someAction = yield call(apiClient.someClientAction, parameter)\n    yield put({ type: initialAction' })\n  }\n}\nfunction * watcher () {\n    while(true){\n    const actions = yield take('initialAction')\n    yield put({type: 'start'})\n  }\n}\nThis is working, but I do not know if it is the most elegant way to solve\nthe issue.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/618#issuecomment-258848686,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkvfx32A27TdsQwMKtWDsCnOywW_cks5q7zTygaJpZM4KrLxu\n.\n. You could use actionChannel(pattern) + take(channel) instead of simple take to make it work. It has a built-in buffering in it. So it would look smth like this:\n\n``` javascript\nfunction* processServerActions () {\n    const chan = yield actionChannel('start')\n    while(true) {\n        const nextActions = yield take(chan)\n        for (let action of nextActions.payload) {\n            switch(action.actionType) {\n                case REQUEST_ACTIONS:\n                    const nextAcitons = yield call(apiClient.requestActions)\n                    yiel put({actionType: 'start', payload: nextActions})\n                    break;\n            case PLAY_ACTION:\n                yield put({ type: PLAY_AUDIO, payload: action.url })\n                break;\n\n            case MESSAGE_ACTION:\n                yield put({ type: ADD_MESSAGE, payload: action.payload })\n                break;\n\n            case CLEAR_MESSAGES_ACTION:\n                yield put({ type: CLEAR_MESSAGES })\n                break;\n        }\n    }\n}\n\n}\n```\nWith that method, you wont miss any start action.\n. @aikoven Would you be willing to provide a PR for this?. Gonna close it, as its already included in the PR that will get merged soo.. For now it is not possible as throttle is implemented internally with actionChannel(pattern, buffers.sliding(1)). That was however something I was thinking about - ability to accept custom channels. \nUnfortunately implementation for now would be a little bit clunky, I'll might re-implement ir some time in the near future, but for now I would recommend you to use a custom throttle helper, here we go:\n``` javascript\nexport function throttle(delayLength, subscribe, worker, ...args) {\n    const chan = eventChannel(subscribe, buffers.sliding(1))\nfor (;;) {\n    const item = yield take(chan)\n    yield fork(worker, ...args, item)\n    yield call(delay, delayLength)\n}\n\n}\n```\nwith that your code could look like:\n``` javascript\nexport const onEvent = (source, eventName) => emitter => {\n  source.addEventListener(eventName, emitter);\nreturn () => {\n    source.removeEventListener(eventName, emitter);\n  };\n};\nfunction* saga() {\n  const userEventSubscribe = yield call(onEvent, document, 'click');  \nyield throttle(1000, userEventSubscribe, function* () {\n    ...\n  }) \n}\n```\n. And ofc there is always much simpler solution in your case - just throtte\nthe emitter and use throttled one in your addEventListener. Then just take\nfrom the channel without any saga throttling. You can grab throttle from\nlodash, some other utility lib or write ur own ofc\nOn Tue, 8 Nov 2016 at 15:15, Dimitri Rosenberg notifications@github.com\nwrote:\n\nIs it possible to throttle eventChannel?\nexport const onEvent = (source, eventName) => eventChannel(emitter => {\n  source.addEventListener(eventName, emitter);\nreturn () => {\n    document.removeEventListener(eventName, emitter);\n  };\n});\nfunction* saga() {\n  const userEvent = yield call(onEvent, document, 'click');\nyield throttle(1000, userEvent, function* () {\n    ...\n  })\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/620, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkum-wEGBmpEDpKoskLV4wKVfnazsks5q8IM_gaJpZM4Ksd3R\n.\n. Hm, I dont rly see the problem with it being 'less' generic as built-in throttle is not generic either. You wont be able to achieve debouncing with it, you wont also be able to achieve trailingThrottle nor leadingThrottle as all those things needs other logic than throttle itself.\n\nSo throttling the emitter is nothing different from it rly in my opinion.\nAlso. I've started questioning throttling the channel. What would you expect to happen? Let's assume you have a channel which already have 10 items buffered in it, you apply throttle to it, so 1 item is taken and next item will be taken after delayLength ms? Or 1 item is taken and all other items are flushed, so basically only the newest ones are always available for taking?\nIt could also cause weird behaviours/subtle bugs if somebody have tried to throttle the channel and also take, flush or whatever else alongside in the saga, as the created channel reference would live outside of the throttle (you would pass it in to throttle helper after all) and could be tampered with. \nI think for now Im gonna prepare a PR with the ability to pass a subscriber function to the throttle instead of a pattern, just like in the example I've shown you above as it is more safe.\n. It is not possible for throttle helper to know if passed in function is a subscriber or just a predicate testing actions. Gonna close the issue in favor of implementing it in userland like here - https://github.com/yelouafi/redux-saga/issues/620#issuecomment-259161095 .. Cool, thanks fot the PR, gonna merge right away!\n. Wow this is more than cool! \ud83c\udf89 Superb important for the lib and handled gracefully! Just dont forget to erase those commented out // console.logs ;) Should I close PR https://github.com/yelouafi/redux-saga/pull/602 ?\ncc @mjrussell \n. No much to do here more if all tests are passing, merge it asap! (pun intended ;) )\n. Yep, thanks for noticing and sending PR! call alone is creating a wrapper around what should be called, its just a plain object (which we call effect) which can be treated specially by a redux-saga\n. redux-saga is not written in TS nor using flow. Typings are added by community and included in the lib as courtesy for ppl liking to use such tools.\nWould you be willing to add throttle typing? Its documented in the docs + function signature in the original source code is pretty straightforward.\n. I got it working, but gonna publish it later, cause made it kinda in a clumsy way, will try to do it better. For now you could paste in this webpack config - https://jsfiddle.net/nggwhr5g/\n. There is no official 'good practice' for this use case, but it is really easy to implement such a thing. Persisting could be made as follows (the easiest scenario)\n``` javascript\nconst identity = a => a\nconst save = state => window.localStorage.setItem('persisted-state', JSON.stringify(state))\nfunction* persistState() {\n  const state = yield select(identity)\n  yield call(save, state)\n}\n// ...\nyield takeEvery('*', persistState)\n```\nBut all of that rly depends on your use case, just play around with the snippet, accomodate it to your needs and think of rehydrating strategy. \n. It is possible, in fact this is what Im doing in my project.\nI just thought you want for whatever reason (i.e. not liking to include next library) to use sagas to achieve the same result\n. Oh, sorry, I totally forgot posting here\nAnyway - my usage of both redux-saga and redux-persist is pretty much the same as yours, had no trouble integrating them.\n```javascript\n// index.js\nimport { persistStore } from 'redux-persist'\nconst store = configureStore() // in which I apply middlewares and expose sagaMiddleware.run on store object\nstore.runSaga(rootSaga)\npersistStore(store)\n// and later in my reducer I have\nimport { REHYDRATE } from 'redux-persist/constants'\nexport default (state, action) => {\n        switch (action.type) {\n        case REHYDRATE:\n            // update the state with rehydrated data from the storage\n            return state\n        }\n}\n```\ngonna close it for now, if you have questions, just reopen and ask. Thanks!\n. Yes, actionChannel is the correct way to solve the problem or takeEvery (depending on a use case). puts are scheduled with internal scheduler so nested tasks etc are handled correctly. \nThe problem lies here that when 1st put is being handled take reacts to it, meets put which is queued internally, not resolved immediately so take could be met again, so in the moment of 2nd put (from the map) the worker (saga) you wanted to w8 for the dispatched action didnt come to its take again.\n. Oops, closed for a moment by accident.\nThat scenario with a for loop is indeed scarier. Although solving this issue and probably some similar ones in the future would require a robust, non-obvious scheduler implementation instead of the present, elegant one. Just wondering if its worth the trouble. \nJavascript is a single threaded language and anyone coding in it must realise its limitations in such situations. Just explaining the behaviour in the docs could maybe be enough?\n. I think this got fixed by the semaphore scheduler quite long time ago (previous December?). If the issue persists please ping me and I will reopen.. > > if put is non-blocking, it should return a task\n\n\nexceptions fired by put should be able to be caught\n\nI agree, the error reporting behavior of (non sync) puts  doesn't look quite right when I look at it right now (In fact very weird). It seems all correct for me to bubble the error also for normal puts (ie non sync) since we have this info before resuming the Saga. \n\nWasnt that exact behaviour of preventing error from bubbling up to the saga introduced here - https://github.com/yelouafi/redux-saga/pull/567 for mentioned there reasons?. Returning task from put would be a HUGE breaking change I think. Also as you have mentioned it wouldnt help with handling both scenarios well - bubbling error and keeping the tree intact.\nI agree that put.resolve would be a better name, I can draft a PR soon with deprecation warning on put.sync.. For now I would say yes. It for sure needs to be established before reaching 1.0, which I would like to reach eventually in a 'near' future. But for now it seems reasonable to stick to put.resolve here. \nError boundaries are a quite a topic, regarding the fact that even React itself is struggling with it and potentially Fiber might be the answer. I need to dig into what they do there and whats the reasoning behind the thing they do. It could have been helpful for us here.\nI think it might be more important for sagas to keep their tree intact in such a case that put throws under the hood.\nHowever it potentially might lead to the inconsistent state. Do you have any example in mind when it matters? And when failing would be really a better option for us to make by default?. Well, most people think about it like that. I wont throw stones at you for naming it dispatch \ud83d\ude06 \nHowever it wont be always synchronous - no matter if you use put or put.resolve. redux-saga must schedule things under the hood (not too much, but still...) to accomodate 'parallel tasks' environment.\n\nBreaking changes be damned.\n\nNot afraid of breaking changes! Always thought they are good for the project, keeping things non-breaking forcefully might be really constraining the project to move forward in many cases. That doesnt ofc mean that major API changes should happen easily and often.\n\nWith put.resolve the inner stack trace shows you exactly who caused it. With put, you have to wait until next tick and you go hunting for answers.\n\nNot sure what do you mean by that, I think logged errors are pretty much the same in both cases. Also the timing is exactly the same, the difference is that put will swallow the error (just log it) and put.resolve will throw into your saga (with a possibility to crash your app if you do not have proper try/catch)\n. >  I asked you in Gitter about why put was changed to non-blocking, and then you said it was always non-blocking, so I am confused on how it works honestly.\nMy comment was about its general behaviour, not the error handling itself. I strongly believe that put was always resolved (giving back running context to your generator) once it finally managed to dispatch your action. By finally I mean that it could not be immediate due to internal scheduling, but for sure within the same synchronous call stack.\nYou are right though that silent error swallowing was added, because at the moment it felt weird that error in your reducer or component can crash your saga. However after this got into the library the questions were raised about this behaviour and we are not 100% sure which behaviour is desired and which one should we keep. We will for sure settle our minds on it before geting v1 to you, which im pushing forward the best I can due to limited time I can spend on the code now.\nIn addition - there are not really that many blocking effects in the library, most are non-blocking.\nMore about this can be found here:\n- https://redux-saga.github.io/redux-saga/docs/Glossary.html\n- https://redux-saga.github.io/redux-saga/docs/api/index.html#blocking--nonblocking\n\n2.) Why is put non-blocking? It dispatches an action to the reducer, which is synchronous, so why doesn't it wait until the reducer has finished it's task before moving on?\n\nIt waits, it just swallows the error for now, which put.resolve does not do. I dont if I can explain it better than the code itself, let me show you:\n``javascript\n  function runPutEffect({channel, action, resolve}, cb) {\n    /**\n      Schedule the put in case another saga is holding a lock.\n      The put will be executed atomically. ie nested puts will execute after\n      this put has terminated.\n    **/\n    asap(() => {\n      let result\n      try {\n        result = (channel ? channel.put : dispatch)(action)\n      } catch(error) {\n        // If we have a channel orput.resolvewas used then bubble up the error.\n        if (channel || resolve) return cb(error, true)\n        log('error',uncaught at ${name}`, error.stack || error.message || error)\n      }\n  if(resolve && is.promise(result)) {\n    resolvePromise(result, cb)\n  } else {\n    return cb(result)\n  }\n})\n// Put effects are non cancellables\n\n}\n``\nThe only non-obvious thing here might becb- its just a function which propagates the result properly through the code, so it can be injected back to your generator.cb(result)- means this is a proper result and it will get injected byit.next(result)latercb(error, true)- second param being true means this is an error, so it will later inject it later withit.throw(error)`\nIf you have any further questions, please ask, I'll try to explain things to the best of my capabilities :). I've decided to restore old behaviour - we shouldn't swallow errors by default. Gonna do it in upcoming v1 release. I'm really sorry that u had to wait for so long for this, but I guess I had to mature to this decision.. They always bubble in v1-beta. The behaviour described in the docs is referring to v0.16. Sounds good to me\n. Well, it depends. Personally I try to avoid accessing the store's state (as mentioned in the docs) unless I dont replicate reducers logic of parsing actions and updating the saga's state - in such case its simply not worth it.\nBut for your use case something similiar to this could be used to avoid select\n``` javascript\nimport * as API from './api'\nconst fetchSomething = function * (token, action) {\n  const { endpoint, body } = action\n  const payload = yield call(API.makeRequest, endpoint, body, token)\n  yield put(fetchSomethingSucceed(payload))\n}\nexport default function * () {\n  const { token } = yield take(SET_TOKEN)\n  yield take(FETCH_SOMETHING, fetchSomething, token)\n}\n```\nI assume you have some action which sets the token in the store already.\n. Just from top of my head, smth like this should work (although there might be a better way)\n``` javascript\nimport * as API from './api'\nconst fetchSomething = function * (token, action) {\n  const { endpoint, body } = action\n  const payload = yield call(API.makeRequest, endpoint, body, token)\n  yield put(fetchSomethingSucceed(payload))\n}\nexport default function * () {\n  let token\nyield fork(function* () {\n   token = (yield take(SET_TOKEN)).token\n  })\n  while (true) {\n    const action = yield take(FETCH_SOMETHING)\n    yield fork(fetchSomething, token, action)\n  }\n}\n``\n. @BenLorantfy I've proposed to useselectand only provided this more contrived example to illustrate that possibility. I would just go withselectfor this..put.synchas different logic for:\n1. error handling, whencatched it willthrowon your saga\n2. result handling - ifdispatchreturns aPromiseit will block until thisPromise` is resolved\n. Try yield [take(FETCH_FOO), take(FETCH_BAR)]\nOn Fri, 18 Nov 2016 at 19:16, Rub\u00e9n Sospedra notifications@github.com\nwrote:\n\nImagine we want to call two async endpoints from out API and we want to\nthem to finish in order to put an action.\nSo, I tried something (and quite a lot more of options) like this:\nconst fetchMultiple = function * () {\n  yield put(fetchFoo())\n  yield put(fetchBar())\n// the following code is wrong\n  // yield take is not iterable but if we assign it to a single var\n  // it'll take only the first to be triggered\n  const [foo, bar] = yield take([\n    FETCH_FOO,\n    FETCH_BAR\n  ])\nyield put(fetchMultipleSuccess(foo, bar))\n}\nBut the yield take([]) works by OR operator instead of AND which would be\nthe needed here.\nIs there any solution for this? Am I approaching the issue in a wrong way?\nMany thanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/643, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkjR-Sw9T4nbHrQj71VvOazjrZlptks5q_etogaJpZM4K2xeE\n.\n. Could you post a webpackbin with your code? It should certainly work if you yield an array of effects. Im using this pattern in my project without any issues.\n. Ok, so there were some issues with your code. All effects (what you import from redux-saga/effects) - take, put, fork etc are effect creators, basically just functions which return objects with certain structure. And those objects can be later interpreted by the redux-saga in order to execute them. So such thing like this wont work\n\njavascript\nconst asyncFn = setTimeout((type, sec) => {\n  put({ type, sec })\n}, sec * 1000)\nit simply creates put effect/object but it cannot pass it to the saga which could interpet it and dispatch the action as the outcome. The only way to pass effects to the saga is by yielding them (those effects/objects) from the generator which is controlled by the redux-saga\nHere you go with the corrected code - http://www.webpackbin.com/E1SqxwKZz\n. I really like @aikoven approach. It makes sense to have steer things like this.\nUnhandled exceptions is not a problem of saga itself, but more of a general coding problem.\n@granmoe If your solution works for you, it should be fine for you to use it I think. or do you have some issues with it?\nAlso see a commentary here - https://github.com/yelouafi/redux-saga/issues/632#issuecomment-262352406 about onError. Maybe that feature could be utilised for more general use cases as some kind of global-saga try/catch? WDYT? How would you see it working in various scenarious? Differences between fork/spawn?\n. > The reason I want to wrap the root saga itself is because 99% of the time, I don't want any of my sagas to die permanently if an unhandled exception occurs. This is the one important difference between mine and @aikoven 's approach.\nWell, with @aikoven 's solution the main outcome is pretty much the same - those sagas wont die permanently. Or didnt I grasp something?\n\n@Andarist No, I don't have any problems with my current solution. Yes, a global try/catch (with the option to restart sagas after non-sync errors) would be perfect.\n\nCould you post example API with explanation what providing onError and what its absence would cause?\n\nI know it's easy to accomplish with about 20 lines of code (like @aikoven and I have above, for example), but many co-workers have voiced concern about this chunk of code because it feels like too low-level of an abstraction, like something redux-saga should handle for you. Sure, this amounts to just hiding that little chunk of code in the library, but at least then we can have one standard way of doing it that everyone (and apparently a lot of people have need for this) can use.\n\nWell, I feel that although many people would like it to see in redux-saga it would break other's assumptions (even if they are minority) and we should then provide a way of reaching present behaviour. So there is no win in this.\nHowever various strategies for error handling could be included in the docs as examples with explanations for everybody to see and chose between them. With the most basic one being using spawn in the rootSaga and fork in every spawned one.\n@aikoven \nWould you agree on using your code in the docs or maybe even making one of them a built-in helper? I could provide implementation of this using fsmIterator internally (in the way other helpers like takeEvery etc are implemented). > @Andarist \n\n\nWould you agree on using your code in the docs or maybe even making one of them a built-in helper?\n\nAbsolutely! @granmoe's sync error detection should be included as well. I think we should fail loudly in that case.\n\nThere are only 2 things I worry with this trick.\n1. its a trick :P could be non-obvious in the source after a while, however I guess its the best way of detecting this\n2. it can happen not only on a startup, and I feel like it should be applied on each sync step of the generator, which is rather a complex thing to do (not overly complex, but still)\nAlso the whole error handling thing got me to thinking yesterday. I was searching for an interesting topic for my company's blog to write and post on and finally it seemed that it might be it ;) Wouldnt like to use your code (both of you! @aikoven @granmoe) for such purpose without your blessing (would ofc include props for both of you). And later I could convert it to the docs section (as blog post and docs should have a little bit different form).\nAlso the blog post is nice as it might raise awareness among people if we propagate it through twitter etc, lets be honest - everybody looks to the docs (beside API reference) just once, at the beginning while learning.. Sorry for the lack of response here. Please do not close this PR as I think it is a valuable piece of discussion which is worth to be kept and I'll try to get to summarizing it and adding it to the docs in some form eventually.\nPersonally after many thoughts on the topic I dont want to recommend your pattern (restarting) for everyone - that doesnt mean its not a valid approach if somebody needs it. Need to rethink what exactly the recommended approach is in my opinion - but it's probably something more like tests + isolated sagas (through spawn? maybe there is a need for some better isolation solutions, aint sure yet) and just letting sagas to fail + ofc logging the errors to the analytics, so the bugs can be fixed.\nI believe React 16 is moving into the right direction with error handling - https://facebook.github.io/react/blog/2017/07/26/error-handling-in-react-16.html . Let me cite just few things:\n- \"In the past, JavaScript errors inside components used to corrupt React\u2019s internal state and cause it to emit cryptic errors on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.\"\n- \"This change has an important implication. As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.\"\n- \"We debated this decision, but in our experience it is worse to leave corrupted UI in place than to completely remove it.\"\nI think it closely relates to the sagas problem. While React 16 introduces \"error boundaries\" I think its not so easy to apply this concept to the saga due to differences in the formed tree structure (component tree is different than a saga tree) - it behaves in different way. However it might be worthwhile to think about it some more and maybe introduce something similar - no ideas in this field on my side at the moment though.\n. Exactly! Unfortunately I do not have any silver bullet for those kinds of problem. I also believe that more fine-grained control should be preferred when it comes to auto-restarting your processes - explicitness over implicitness.\nFortunately saga is really flexible and allows you to implement your own abstractions over the system or create abstraction-library to share with others. Best the redux-saga core can do is offer (like it does) the addons section for you to share your doings with the community.. NOTE If somebody want to propose API and behaviour spec for something like error boundaries in React - I would gladly read it and work out any rough edges. It is not my priority at the moment though, I sincerely invite anyone who would like to collaborate on the project.. > I think these are good ingredients to a larger abstraction.\nProbably, but it seems really cool to me already \u2764\ufe0f . Fine by me - there is also a gitter channel \ud83d\ude04 In general I would like to have 1 place to hang out, thought it might be reactiflux, but their push notifications cant handle this big server :s so ive kinda stayed on gitter and unfortunately im overlooking discord's one. You are right that this recipe is not ideal and your snippet fixes its issues.\nWould you maybe like to make pull request out of it? . You are right that this recipe is not ideal and your snippet fixes its issues.\nWould you maybe like to make pull request out of it? . Those saga helpers are indeed iterators, so yield* will work and in fact it was the only way to use them some time ago, but they got decorated with internal flag, so when used as such yield takeLatest their iterators are wrapped under the hood with fork and in effect return task descriptor.\nSo the difference is that:\njavascript\nfunction* watchLastFetchUser() {\n  // this is non blocking call\n  const task = yield takeLatest('USER_REQUESTED', fetchUser)\n  // this may be done afterwads\n  yield call(someFunc)\n  // ...\n  // and you can even cancel it later!\n  yield cancel(task)\n}\nand \njavascript\nfunction* mySaga() { \n  // this is a blocking call\n  yield* takeLatest(\"USER_FETCH_REQUESTED\", fetchUser);\n  // this will never be reached\n  yield call(someFunc)\n}\nAdditionally using them with yield* will get deprecated in the future and after some time completely removed as it is really confusing to newcomers - https://github.com/yelouafi/redux-saga/pull/596 . Those saga helpers are indeed iterators, so yield* will work and in fact it was the only way to use them some time ago, but they got decorated with internal flag, so when used as such yield takeLatest their iterators are wrapped under the hood with fork and in effect return task descriptor.\nSo the difference is that:\njavascript\nfunction* watchLastFetchUser() {\n  // this is non blocking call\n  const task = yield takeLatest('USER_REQUESTED', fetchUser)\n  // this may be done afterwads\n  yield call(someFunc)\n  // ...\n  // and you can even cancel it later!\n  yield cancel(task)\n}\nand \njavascript\nfunction* mySaga() { \n  // this is a blocking call\n  yield* takeLatest(\"USER_FETCH_REQUESTED\", fetchUser);\n  // this will never be reached\n  yield call(someFunc)\n}\nAdditionally using them with yield* will get deprecated in the future and after some time completely removed as it is really confusing to newcomers - https://github.com/yelouafi/redux-saga/pull/596 . Also, I've corrected the docs to use yield takeLatest form. Also, I've corrected the docs to use yield takeLatest form. It looks rly great, I just aint sure if introducing spawn here is necessary. It convolutes the example a little bit. Anyway - fork vs spawn struggle is geting bigger and bigger in the community. Gonna speak about it with @yelouafi \nI've put 2 really minor comments, if you decide to correct them, please do an ammend commit (or squash them) + rebase with the current master - it will help keeping the history clean.. It looks rly great, I just aint sure if introducing spawn here is necessary. It convolutes the example a little bit. Anyway - fork vs spawn struggle is geting bigger and bigger in the community. Gonna speak about it with @yelouafi \nI've put 2 really minor comments, if you decide to correct them, please do an ammend commit (or squash them) + rebase with the current master - it will help keeping the history clean.. Only a single commit should be wanting to get merged.\nYou should:\ngit rebase -i HEAD~3\nyou will see 3 commits - use p d s on them in that order, so 1st will get picked, 2nd dropped, 3rd squashed\nyou will get asked about new commit message - just keep single Update Undo recipe\nI aint sure if you did it right, so you might skip next steps if you have already done them:\ngit remote add upstream https://github.com/yelouafi/redux-saga.git\ngit fetch upstream\nAnd finally\ngit rebase upstream/master\ngit force --push. Only a single commit should be wanting to get merged.\nYou should:\ngit rebase -i HEAD~3\nyou will see 3 commits - use p d s on them in that order, so 1st will get picked, 2nd dropped, 3rd squashed\nyou will get asked about new commit message - just keep single Update Undo recipe\nI aint sure if you did it right, so you might skip next steps if you have already done them:\ngit remote add upstream https://github.com/yelouafi/redux-saga.git\ngit fetch upstream\nAnd finally\ngit rebase upstream/master\ngit force --push. Thanks, real good example, leveraging take(predicate) which is rly neat and underpromoted in the docs \ud83c\udf89 . Thanks, real good example, leveraging take(predicate) which is rly neat and underpromoted in the docs \ud83c\udf89 . > A more general question is, how do I access the promise I yielded?\nIf you yield a promise, you are passing concern of creating it and its resolution to the redux-saga. Whats your use case? Why do you want to access it?\nAs of fetch cancellation - it is not possible and not because of the redux-saga. fetch API is based on promised and those are not cancellable by design (at least not yet, there are ongoing discussions about making cancellation spec). > A more general question is, how do I access the promise I yielded?\nIf you yield a promise, you are passing concern of creating it and its resolution to the redux-saga. Whats your use case? Why do you want to access it?\nAs of fetch cancellation - it is not possible and not because of the redux-saga. fetch API is based on promised and those are not cancellable by design (at least not yet, there are ongoing discussions about making cancellation spec). And how would you reject a promise? It has only then and catch methods. \nNo promise can be rejected from the outside. If you want this ability fetch API is not suitable for your use case. I've heard lately that this lib https://github.com/mzabriskie/axios is geting much praise from the community and it supports cancelation.\nKeep in mind that even if you cannot cancel a request it doesnt mean that you will get some duplicate data back into your app. takeLatest in your scenario will use automatically only the newest response and all previous ones will be disarded for you.. And how would you reject a promise? It has only then and catch methods. \nNo promise can be rejected from the outside. If you want this ability fetch API is not suitable for your use case. I've heard lately that this lib https://github.com/mzabriskie/axios is geting much praise from the community and it supports cancelation.\nKeep in mind that even if you cannot cancel a request it doesnt mean that you will get some duplicate data back into your app. takeLatest in your scenario will use automatically only the newest response and all previous ones will be disarded for you.. or even better - you could write your custom fetchAPI, which would look something like this\n```javascript\nimport axios, { CancelToken } from 'axios'\nimport { CANCEL } from 'redux-saga'\nexport default function fetchAPI(url) {\n  const source = CancelToken.source()\n  const request = axios.get(url, { cancelToken: source.token })\n  request[CANCEL] = () => source.cancel()\n  return request\n}\n```\n...and have process of cancelation builtin into your helper, instead of handling this manually in your sagas.. or even better - you could write your custom fetchAPI, which would look something like this\n```javascript\nimport axios, { CancelToken } from 'axios'\nimport { CANCEL } from 'redux-saga'\nexport default function fetchAPI(url) {\n  const source = CancelToken.source()\n  const request = axios.get(url, { cancelToken: source.token })\n  request[CANCEL] = () => source.cancel()\n  return request\n}\n```\n...and have process of cancelation builtin into your helper, instead of handling this manually in your sagas.. Didnt test it, I knew there is a possibility to attach CANCEL callback to the promise so saga can handle it, so I just looked into axios docs and wrote this snippet based on them. \nThere might be some issues with it, I never have used axios and you probably would need to make this fetchAPI more configurable as its capable now only for making GET requests as a demonstration but overall I think this should work without need of changing it too much.. Didnt test it, I knew there is a possibility to attach CANCEL callback to the promise so saga can handle it, so I just looked into axios docs and wrote this snippet based on them. \nThere might be some issues with it, I never have used axios and you probably would need to make this fetchAPI more configurable as its capable now only for making GET requests as a demonstration but overall I think this should work without need of changing it too much.. @vivekdwivedi \nYou have confused 2 things. cancel effect returns an object description for the redux-saga which is later interpreted by the saga and it cancels the task contained in that created effect object.\nWhat you attach to the request is not an effect, its just a special symbol which can be recognized by redux-saga later on to perform cancellation.\nWhen you yield cancel effect to the redux-saga it calls task.cancel() and the cancellation process begins - it propagates this signal downwards through each child task, their childs etc. When a task gets cancelled it simply checks on what effect it is currently paused and tries to call its cancellation function. By attaching previously a CANCEL symbol to your promise you had attached a cancellation function to it, so the redux-saga gets to know what to call when its needed - otherwise there is no automatic way for it to know HOW it should be cancelled.\nFor some other effects like i.e. fork redux-saga knows exactly how it should be cancelled so it attaches the cancel method to it automatically.. @vivekdwivedi \nYou have confused 2 things. cancel effect returns an object description for the redux-saga which is later interpreted by the saga and it cancels the task contained in that created effect object.\nWhat you attach to the request is not an effect, its just a special symbol which can be recognized by redux-saga later on to perform cancellation.\nWhen you yield cancel effect to the redux-saga it calls task.cancel() and the cancellation process begins - it propagates this signal downwards through each child task, their childs etc. When a task gets cancelled it simply checks on what effect it is currently paused and tries to call its cancellation function. By attaching previously a CANCEL symbol to your promise you had attached a cancellation function to it, so the redux-saga gets to know what to call when its needed - otherwise there is no automatic way for it to know HOW it should be cancelled.\nFor some other effects like i.e. fork redux-saga knows exactly how it should be cancelled so it attaches the cancel method to it automatically.. Well, promises are unfortunately not cancellable, can't do much about it. You can always wrap your promise chain in a function that would have custom [CANCEL] raising internal flag for your wrapper that could \"cancel\" the chain or something.. Well, promises are unfortunately not cancellable, can't do much about it. You can always wrap your promise chain in a function that would have custom [CANCEL] raising internal flag for your wrapper that could \"cancel\" the chain or something.. ```javascript\nyield put({ type: DATA_POST_SUCCEEDED }); // handled by the reducer\nyield put({ type: SOME_REQUEST }); // handled by a Saga worker\nconst { error } = yield race({\n  success: take(SOME_SUCCEEDED),\n  error: take(SOME_FAILED),\n})\nif (error) {\n  return\n}\nyield put({ type: ANOTHER_REQUEST }); // handled by a Saga worker\n.javascript\nyield put({ type: DATA_POST_SUCCEEDED }); // handled by the reducer\nyield put({ type: SOME_REQUEST }); // handled by a Saga worker\nconst { error } = yield race({\n  success: take(SOME_SUCCEEDED),\n  error: take(SOME_FAILED),\n})\nif (error) {\n  return\n}\nyield put({ type: ANOTHER_REQUEST }); // handled by a Saga worker\n```. We'll do smth about this, we just need to figure out what\nsee https://github.com/yelouafi/redux-saga/issues/632. We'll do smth about this, we just need to figure out what\nsee https://github.com/yelouafi/redux-saga/issues/632. Could you post your saga?. Could you post your saga?. Thanks!. Thanks!. Thanks! :). Thanks! :). Relying on state is something rather discouraged in sagas and select is rather an escape hatch, easing a life of a developer, so it is not needed to maintain the saga state in the same way reducers already do it. \nIf you make a properly memoized selector it shouldnt be much of a cost in making a higher order saga which wouldnt rely on certain actions (which could be forgotten from being added, as you have mentioned) but on the state itself\njavascript\nfunction* takeEveryDiff(selector, worker) {\n  return fork(function* () {\n    let prevVal\n    while (true) {\n      yield take('*')\n      const val = yield select(selector)\n      if (prevVal === val) {\n        continue\n      }\n      prevVal = val\n      yield fork(worker, val)\n    }\n  })\n}. Relying on state is something rather discouraged in sagas and select is rather an escape hatch, easing a life of a developer, so it is not needed to maintain the saga state in the same way reducers already do it. \nIf you make a properly memoized selector it shouldnt be much of a cost in making a higher order saga which wouldnt rely on certain actions (which could be forgotten from being added, as you have mentioned) but on the state itself\njavascript\nfunction* takeEveryDiff(selector, worker) {\n  return fork(function* () {\n    let prevVal\n    while (true) {\n      yield take('*')\n      const val = yield select(selector)\n      if (prevVal === val) {\n        continue\n      }\n      prevVal = val\n      yield fork(worker, val)\n    }\n  })\n}. it really depends on what you are trying to achieve, but conventionally I think its easiest to set up some loading state flag and just render conditionally null if it is loading\nand ofc you can lift loading state from your saga by dispatching an action from your saga (yield put(action)) and process the action in reducers. it really depends on what you are trying to achieve, but conventionally I think its easiest to set up some loading state flag and just render conditionally null if it is loading\nand ofc you can lift loading state from your saga by dispatching an action from your saga (yield put(action)) and process the action in reducers. Going to close this, if you have any further questions - please just ask :)\n. Going to close this, if you have any further questions - please just ask :)\n. could you post your full setup (minimal ofc) in something like webpackbin.com ? it would help to debug your problem\nwhat I see in your example that will not work for sure is this fragment\njavascript\n        if (userResponse) {\n            console.log('time out dismissed')\n            setSessionTimeOut(arguments)\n        }\n1. setSessionTimeOut is a generator so calling that will return an iterator, but wont run it at all, so its roughly equivalent of\njavascript\n        if (userResponse) {\n            console.log('time out dismissed')\n            { next: () => {} }\n        }\nas you can see nothing is being done with this object so it will be just garbage collected\nif you want to run your generator again in context of the saga you need to yield call(setSessionTimeOut, ...args)\n\n\nin general native generators do not like recursion too much, aint sure about transpiled ones, so I wouldnt recommend calling it like that - you can read more about it here https://medium.com/javascript-scene/7-surprising-things-i-learned-writing-a-fibonacci-generator-4886a5c87710\n\n\nas you are probably using transpilation tools like babel arguments might not be what you think, I wouldnt rely on this old construct in es6 world at all. could you post your full setup (minimal ofc) in something like webpackbin.com ? it would help to debug your problem\n\n\nwhat I see in your example that will not work for sure is this fragment\njavascript\n        if (userResponse) {\n            console.log('time out dismissed')\n            setSessionTimeOut(arguments)\n        }\n1. setSessionTimeOut is a generator so calling that will return an iterator, but wont run it at all, so its roughly equivalent of\njavascript\n        if (userResponse) {\n            console.log('time out dismissed')\n            { next: () => {} }\n        }\nas you can see nothing is being done with this object so it will be just garbage collected\nif you want to run your generator again in context of the saga you need to yield call(setSessionTimeOut, ...args)\n\n\nin general native generators do not like recursion too much, aint sure about transpiled ones, so I wouldnt recommend calling it like that - you can read more about it here https://medium.com/javascript-scene/7-surprising-things-i-learned-writing-a-fibonacci-generator-4886a5c87710\n\n\nas you are probably using transpilation tools like babel arguments might not be what you think, I wouldnt rely on this old construct in es6 world at all. With server side rendering you need to dispatch actions (lets call them - fetch commands) so they can be catched in your sagas. Make the saga tree block on every call etc and dispatch special action END which is exposed by the library. It will cause your sagas which are being blocked takes to resolve and your root task will be able to resolve in that way\njavascript\nconst task = sagaMiddleware.run(rootSaga)\ntask.then(() => ...)\nand then in your callback upon task completion send the server side rendered stuff back to your client.\n\n\nThere are several issues spread up on issues with examples, you can browser around and dig them up. Its certainly something that could be explained better in the docs though.\nGoing to close this, if you have any further questions - please just ask :). With server side rendering you need to dispatch actions (lets call them - fetch commands) so they can be catched in your sagas. Make the saga tree block on every call etc and dispatch special action END which is exposed by the library. It will cause your sagas which are being blocked takes to resolve and your root task will be able to resolve in that way\njavascript\nconst task = sagaMiddleware.run(rootSaga)\ntask.then(() => ...)\nand then in your callback upon task completion send the server side rendered stuff back to your client.\nThere are several issues spread up on issues with examples, you can browser around and dig them up. Its certainly something that could be explained better in the docs though.\nGoing to close this, if you have any further questions - please just ask :). TS typings (same goes for flow) are completely community-driven and not directly implemented by redux-saga author. The library is written in plain javascript.\nWould you be willing to correct them and send a PR? Help would be much appreciated.\ncc @aikoven . TS typings (same goes for flow) are completely community-driven and not directly implemented by redux-saga author. The library is written in plain javascript.\nWould you be willing to correct them and send a PR? Help would be much appreciated.\ncc @aikoven . Would you be willing to create an API section with this cheatsheet?. Would you be willing to create an API section with this cheatsheet?. As generators do not like recursion you could also change the code like this, leveraging flush effect\n```javascript\nfunction * processServerActions () {\n    const queuedActions = yield actionChannel(PROCESS_ACTIONS) \nwhile (true) {\n    const nextActions = yield take(queuedActions)\n\n    const { logout, processedActions } = yield race({\n        logout: take(LOGOUT),\n        processedActions: call(translateActions, nextActions),\n    });\n\n    if (logout) {\n        yield flush(queuedActions)\n    }\n}\n\n}\n. As generators do not like recursion you could also change the code like this, leveraging `flush` effectjavascript\nfunction * processServerActions () {\n    const queuedActions = yield actionChannel(PROCESS_ACTIONS) \nwhile (true) {\n    const nextActions = yield take(queuedActions)\n\n    const { logout, processedActions } = yield race({\n        logout: take(LOGOUT),\n        processedActions: call(translateActions, nextActions),\n    });\n\n    if (logout) {\n        yield flush(queuedActions)\n    }\n}\n\n}\n```. Hey, did u solve your issue?\nOn Tue, 13 Dec 2016 at 02:09, anthonychung14 notifications@github.com\nwrote:\n\nClosed #668 https://github.com/yelouafi/redux-saga/issues/668.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/668#event-891308740, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkugsF5lTBkLxlVpiPq8ZOWP7hrh7ks5rHfBfgaJpZM4LDeib\n.\n. Hey, did u solve your issue?\nOn Tue, 13 Dec 2016 at 02:09, anthonychung14 notifications@github.com\nwrote:\nClosed #668 https://github.com/yelouafi/redux-saga/issues/668.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/668#event-891308740, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkugsF5lTBkLxlVpiPq8ZOWP7hrh7ks5rHfBfgaJpZM4LDeib\n.\n. I've created a simple debounce helper for you (might introduce it to redux-saga natively at some point). \n```javascript\nfunction debounce(ms, pattern, worker, ...args) {\n    const task = yield fork(function () {\n        while (true) {\n            let ac = yield take(pattern)\n\n        while (true) {\n            const { action, debounced } = yield race({\n                action: take(pattern),\n                debounced: call(delay, ms),\n            })\n\n            if (debounced) {\n                yield fork(worker, ...args, ac)\n                break\n            }\n\n            ac = action\n        }       \n    }\n})\nreturn task\n\n}\nfunction* watchChangeAction() {\n    yield debounce(300, actionTypes.CHANGE, updateDataInServer)\n}\nfunction* updateDataInServer(action) {\n    try {\n       //retrieve key from the store\n        const key = yield select(selectors.getKey);\n        const newSettings = yield select(selectors.getSettingsItems);\n    const response = yield call(serverSettings.update, newSettings, key);\n    const responseKey = serverSelectors.getKey(response);\n   // dispatch action with responseKey, which is stored for later user\n    yield put(actions.saved(responseKey));\n\n}\n\n//...\n }\n```\nDidnt test it yet, as I dont have much time now, but it should work or be quite simple to fix. \nPlease remember though that if you send 2 requests they dont necesserily come back to you in the same order, so that should be handled also.. I've created a simple debounce helper for you (might introduce it to redux-saga natively at some point). \n```javascript\nfunction debounce(ms, pattern, worker, ...args) {\n    const task = yield fork(function () {\n        while (true) {\n            let ac = yield take(pattern)\n        while (true) {\n            const { action, debounced } = yield race({\n                action: take(pattern),\n                debounced: call(delay, ms),\n            })\n\n            if (debounced) {\n                yield fork(worker, ...args, ac)\n                break\n            }\n\n            ac = action\n        }       \n    }\n})\nreturn task\n\n}\nfunction* watchChangeAction() {\n    yield debounce(300, actionTypes.CHANGE, updateDataInServer)\n}\nfunction* updateDataInServer(action) {\n    try {\n       //retrieve key from the store\n        const key = yield select(selectors.getKey);\n        const newSettings = yield select(selectors.getSettingsItems);\n    const response = yield call(serverSettings.update, newSettings, key);\n    const responseKey = serverSelectors.getKey(response);\n   // dispatch action with responseKey, which is stored for later user\n    yield put(actions.saved(responseKey));\n\n}\n\n//...\n }\n```\nDidnt test it yet, as I dont have much time now, but it should work or be quite simple to fix. \nPlease remember though that if you send 2 requests they dont necesserily come back to you in the same order, so that should be handled also.. As for w8ing with making new requests maybe changing fork to call would\nsuffice? If not i would probably make request channel which would buffer\ndebounced requests and take + call within the loop from this channel. As for w8ing with making new requests maybe changing fork to call would\nsuffice? If not i would probably make request channel which would buffer\ndebounced requests and take + call within the loop from this channel. It would look smth like this\n```javascript\nfunction debounce(ms, pattern, worker, ...args) {\n    const task = yield fork(function () {\n        while (true) {\n            let ac = yield take(pattern)\n        while (true) {\n            const { action, debounced } = yield race({\n                action: take(pattern),\n                debounced: call(delay, ms),\n            })\n\n            if (debounced) {\n                yield fork(worker, ...args, ac)\n                break\n            }\n\n            ac = action\n        }       \n    }\n})\nreturn task\n\n}\nfunction* watchChangeAction() {\n    const requestChannel = channel()\n    yield debounce(300, actionTypes.CHANGE, queueRequest, requestChannel)\nwhile (true) {\n    const action = yield take(requestChannel)\n    yield call(updateDataInServer, action)\n}\n\n}\nfunction* queueRequest(chan, action) {\n    yield put(chan, action)\n}\nfunction* updateDataInServer(action) {\n    try {\n       //retrieve key from the store\n        const key = yield select(selectors.getKey);\n        const newSettings = yield select(selectors.getSettingsItems);\n    const response = yield call(serverSettings.update, newSettings, key);\n    const responseKey = serverSelectors.getKey(response);\n   // dispatch action with responseKey, which is stored for later user\n    yield put(actions.saved(responseKey));\n\n}\n\n//...\n }\n. It would look smth like thisjavascript\nfunction debounce(ms, pattern, worker, ...args) {\n    const task = yield fork(function () {\n        while (true) {\n            let ac = yield take(pattern)\n        while (true) {\n            const { action, debounced } = yield race({\n                action: take(pattern),\n                debounced: call(delay, ms),\n            })\n\n            if (debounced) {\n                yield fork(worker, ...args, ac)\n                break\n            }\n\n            ac = action\n        }       \n    }\n})\nreturn task\n\n}\nfunction* watchChangeAction() {\n    const requestChannel = channel()\n    yield debounce(300, actionTypes.CHANGE, queueRequest, requestChannel)\nwhile (true) {\n    const action = yield take(requestChannel)\n    yield call(updateDataInServer, action)\n}\n\n}\nfunction* queueRequest(chan, action) {\n    yield put(chan, action)\n}\nfunction* updateDataInServer(action) {\n    try {\n       //retrieve key from the store\n        const key = yield select(selectors.getKey);\n        const newSettings = yield select(selectors.getSettingsItems);\n    const response = yield call(serverSettings.update, newSettings, key);\n    const responseKey = serverSelectors.getKey(response);\n   // dispatch action with responseKey, which is stored for later user\n    yield put(actions.saved(responseKey));\n\n}\n\n//...\n }\n```. As for forking within call - it is expected, althought quite confusing even to me. Maybe @yelouafi could elaborate on reasoning behind this?\nYour snippet is probably good although quite convoluted at first grasp. This is what I would have used:\n```javascript\nfunction debounce(ms, pattern, worker, ...args) {\n    const task = yield fork(function () {\n        while (true) {\n            let ac = yield take(pattern)\n        while (true) {\n            const { action, debounced } = yield race({\n                action: take(pattern),\n                debounced: call(delay, ms),\n            })\n\n            if (debounced) {\n                yield fork(worker, ...args, ac)\n                break\n            }\n\n            ac = action\n        }       \n    }\n})\nreturn task\n\n}\n//usage example:\nfunction watchChangeAction() {\n    const requestChannel = channel()\n    yield debounce(300, actionTypes.CHANGE, function (action) {\n        yield put(requestChannel, action)\n    })\n    while (true) {\n        const action = yield take(requestChannel)\n        yield call(handleRequest, action)\n    }\n}\n``\nWay of debouncing - mine or yours is only a personal preference, just use whatever fits you. I just think having 2 separate channels is obsolate in your scenario, as it seems that the only place where buffering is needed is arequestChannel`. As for forking within call - it is expected, althought quite confusing even to me. Maybe @yelouafi could elaborate on reasoning behind this?\nYour snippet is probably good although quite convoluted at first grasp. This is what I would have used:\n```javascript\nfunction debounce(ms, pattern, worker, ...args) {\n    const task = yield fork(function () {\n        while (true) {\n            let ac = yield take(pattern)\n        while (true) {\n            const { action, debounced } = yield race({\n                action: take(pattern),\n                debounced: call(delay, ms),\n            })\n\n            if (debounced) {\n                yield fork(worker, ...args, ac)\n                break\n            }\n\n            ac = action\n        }       \n    }\n})\nreturn task\n\n}\n//usage example:\nfunction watchChangeAction() {\n    const requestChannel = channel()\n    yield debounce(300, actionTypes.CHANGE, function (action) {\n        yield put(requestChannel, action)\n    })\n    while (true) {\n        const action = yield take(requestChannel)\n        yield call(handleRequest, action)\n    }\n}\n``\nWay of debouncing - mine or yours is only a personal preference, just use whatever fits you. I just think having 2 separate channels is obsolate in your scenario, as it seems that the only place where buffering is needed is arequestChannel`. It sounds reasonable, please create a PR and we'll continue from there.. Gonna close already in favor of PR discussions.. Im not sure if I understand completely what you are trying to achieve. \nFrom what I understand you you want to buffer DISPLAY actions, display 1 snackbar and when user clicks HIDE cancel the forked task, then proceed with next DISPLAY, right?\nIf that's the case I would recommend trying it this way:\n```javascript\nwhile (TRUE) {\n    const action = yield take(channel)\n    const task = yield fork(displayWithCancellation, action)\nyield race({\n    forceHide: take({ type, force } => type === HIDE && force),\n    taskEnd: join(task)\n})\n\nyield cancel(task)\n\n}\n```\nYour loop was totally non blocking after taking from the channel, so basically each item put in the channel was consumed immediately. You had to make some blocking call after taking so it prevents from taking again.\nAlso do not use takeEvery within a loop, as with each run it will create a new subscriber for the action. takeEvery is just a helper easing creation of such construct\njavascript\nfunction* takeEvery(pattern, worker, ...args) {\n    const task = yield fork(function* () {\n        while (true) {\n            const ac = yield take(pattern)\n            yield fork(worker, ...args, ac)\n        }\n    })\n    return task\n}\nAnd looking at that you should see the problem with using takeEvery in the loop.\n. Could u post what you have commented out?\nOn Tue, 6 Dec 2016 at 02:55, Jake Kaufman notifications@github.com wrote:\n\nI'm working on a react-native app that uses sagas to do some async actions\nin the background (including some expensive API calls). I have been running\ninto some issues with the responsiveness of my UI to touch events (the\nonPress calls of TouchableOpacity in particular, they tend to execute in\nbatches after some background tasks have completed). I found that if I\ncommented out the code where I make the most expensive API call, then the\nUI is responsive immediately, but that confused me because the task should\nbe running asynchronously.\nMy root saga follows the following pattern:\nyield [ spawn(saga1), spawn(saga2), ... ]\nI'm wondering if there's any known reason why this type of performance\nproblem might occur.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/672, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkr9YmmYxSZmXg00Y0VYAYu1FchSKks5rFMClgaJpZM4LE71e\n.\n. Could you provide docs update in your PR? Would be much appreciated.. I just thought that this approach - https://gist.github.com/slorber/c095671a14b2eccf8ad665a97a7b8ad1 could be leveraged to achieve your goal, although it would need much more boilerplate to connect the pieces.\n\nAlso I just thought that as runSaga's store-like options dispatch/getState/subscribe are disconnected from the standard middleware emitting from them via subscribe could cause every scheduling problem which was fixed by 'asap' scheduler in the standard middleware recently. That should be addressed I think, WDYT @yelouafi ?\nalso much simpler way of adding the requested functionality than having to provide whole emitter could be ability to 'hijack' emit with the option, smth like this\njavascript\n  function sagaMiddleware({getState, dispatch}) {\n    runSagaDynamically = runSaga\n    const sagaEmitter = emitter()\n    if (options.emit) {\n      const realEmit = sagaEmitter.emit\n      sagaEmitter.emit = (action) => options.emit(realEmit, action)\n    }\nand then ofc passed in options.emit could handle the action however it wants to and still emit easily\n@pbadenski WDYT?. W8. He'll probably have valuable input :)\nOn Fri, 9 Dec 2016 at 15:46, Pawel Badenski notifications@github.com\nwrote:\n\nI like narrowing it down to only providing \"emit\" option instead of\nreplacing the whole \"emitter\". The other solution did seem a bit clunky.\nShould I wait for @yelouafi https://github.com/yelouafi's response or\njust go ahead and change it?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/pull/673#issuecomment-266030299,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkn-symRr7K0QGYRnj81afKPtfDcQks5rGWm5gaJpZM4LFbPk\n.\n. @pbadenski \nwill you have time in following days to work on the PR? I would like to release a new redux-saga version soon and include this PR in it if possible :). do you have some better naming for this option than emit or customEmit? I guess customEmit is not the worst name in the world, but always hated custom, original etc. But we would be emitting them by hand (with passed in original emit) to the saga internals after processing the original emitted item.\n. Process is better as map normally indicate that there will be some\noutcome of the operation - and its up to the user, he can prevent from emit\n. Yeah, sure, I would see it as loose vatiation based on the snippet Ive posted above - https://github.com/yelouafi/redux-saga/pull/673#issuecomment-265712490 . With other naming and possibly other internal implementation, but the API idea should stay similar. Ofc if you see it differently, please raise your concerns!. You had configured store in some wrong way, I've tweaked your configuration and its working now\n```javascript\nimport { createStore, applyMiddleware, compose } from 'redux'\nimport createSagaMiddleware, { END } from 'redux-saga'\nimport rootReducer from '../reducers'\n\nexport default function configureStore(preloadedState) {\n  const sagaMiddleware = createSagaMiddleware();\n  const composeCreateStore = () => compose(\n    applyMiddleware(sagaMiddleware),\n    window.REDUX_DEVTOOLS_EXTENSION ? window.REDUX_DEVTOOLS_EXTENSION() : fn => fn,\n  )(createStore)\n  const finalCreateStore = composeCreateStore()\n  const store = finalCreateStore(rootReducer, preloadedState)\nstore.runSaga = sagaMiddleware.run;\n  store.close = () => store.dispatch(END);\nreturn store;\n}\n```\nadditionally you are desctructuring wrongly your takers with this configuration\nyield take(({action}) => action && action.type === ADD_TODO);\nshould become\nyield take((action) => action && action.type === ADD_TODO);\nor even more concise for this simple use case\nyield take(ADD_TODO);\nI hope it helps. Did it help for you? I would like to close the issue, but aint sure if your problem got resolved.. Just like @restrry said, wrapping your callbacks with eventChannel is a way to go. Gonna close the issue for now, if you have more questions, please reopen and ask.. If I understood you correctly here is a little bit simplified solution (without distinction between errors)\n```javascript\nfunction* tryToSync() {\n  const connectionType = yield select(getConnectionType)\nif (connectionType !== 'WIFI') {\n    return\n  }\nconst ordersToSync = yield select(getOrdersToSync)\n  try {\n    for (const order of ordersToSync) {\n      for (const item of order.itemsPicked) {\n        yield call(API.updatePickQuantityAction, item.PickedQuantity, item.PickingListDetailId)\n      }\n      yield call(API.confirmPickAction, order.pickingListId)\n      yield put(REMOVE_CONFIRMED_PICK_ACTION)\n    }\n  } catch (err) {\n    yield put(SYNCING_ERROR)\n  }\n}\nfunction* saga() {\n  while (true) {\n    // here you have basically your syncing flag/state as call is blocking \n    // and it wont accept any TRY_TO_SYNC till tryToSync is done\n    yield take(TRY_TO_SYNC)\n    yield call(tryToSync)\n  }\n}\n``. But alsocontinue` wouldnt  make a difference here, it would be a last statement in the outer loop.\nI've noticed also you dont pass any argument to the yield fork(removeSyncedOrder);, so dispatched action may be meaningless - not removing synced order.\n. javascript\nexport default function* rootSaga() {\n      yield [\n        watchBackgroundSync(),  // Called once when the app is started\n        fork(watchBgSync),\n      ];\n    }\nyou could inline here takeEvery(BACKGROUND_SYNC_START, backgroundSync); instead of watchBackgroundSync() as it is literally all it does and saga will handle it correctly\ntake(SIGNOUT_USER) // Should cancel the sync?race will cancel automatically the loser tasks\nAlso while race([...effects]) will work I would be cautious with using this syntax as the public supported API is an object with named keys like this:\njavascript\nyield race({\n  poll: call(pollData),\n  signout: take(SIGNOUT_USER) // Should cancel the sync?\n});\nconst state = yield select();\nI would consider it a strong anti-pattern. Your saga becomes strongly coupled with shape of your state. It's advised to use so-called selectors (collocated in your reducer files), like this:\njavascript\nexport const getSyncQueue = (state) => state.pickingList.syncQueue\nand use it in your saga like so\njavascript\nconst syncQueue = yield select(getSyncQueue)\nYour watchBgSync looks kinda weird, but I do not know your requirements. However from what I see your whole snippet is doing the following:\n1. on every trigger action in watchBgSync its starting a race between call(pollData) and take(SIGNOUT_USER)\n2. pollData waits 10 seconds and then dispatch an action consumed by takeEvery AND releasing the race so watchBgSync is accepting the triggers again!\n3. your backgroundSync is forking a task for each item in the syncQueue so they all run in parallel (if your syncQueue grow, it might spawn tens or hundreds of the requests at the same time!)\n4. first success or failure of any request will start pollData again! and there should be no point of that as requests might still be pending, they even can success eventually and you are just making them pointlessly again.\nI think it should be better done as something similar to this:\n```javascript\n    // Handle background sync saga\n    function* backgroundSync() {\n      const state = yield select();\n  if (state.connectivity.connectionType !== 'WIFI') {\n    yield put({\n      type: NOT_CONNECTED\n    });\n    console.log('Not connected');\n  } else if (state.pickingList.syncQueue.length === 0) {\n    yield put({\n      type: SYNC_QUEUE_EMPTY\n    });\n    console.log('Sync queue empty');\n  } else {\n    for (const order of state.pickingList.syncQueue) {\n      if (order.syncType === 'PICK_QTY') {\n        // Update pick qty\n        yield fork(\n          updatePickQtyAsync,\n          order.pickedItem.PickingListDetailId,\n          order.pickedItem.PickedQuantity,\n          state.auth.token\n        );\n      } else if (order.syncType === 'CONFIRM_PICK') {\n        //Confirm pick\n        yield fork(confirmPickAsync, order.Id, state.auth.token);\n      }\n    }\n  }\n}\n\n\n// Update picking list qty saga\nfunction* updatePickQtyAsync(PickingListDetailId, PickedQuantity, token) {\n  try {\n    const config = {\n      method: 'post',\n      url: 'http://XYZ',\n      params: {\n        pickingDetailId: PickingListDetailId,\n        quantity: PickedQuantity\n      },\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    };\n    const response = yield call(axios, config);\n    console.log(`Success in update pick qty: ${response}`);\n\n    // Remove order once synced\n    yield put({\n      type: REMOVE_SYNCED_ORDER\n    });\n    // Restart sync queue\n    yield put({\n      type: SYNC_PICKED_ORDERS_SUCCESS\n    });\n  } catch (error) {\n    // Restart sync queue\n    // Log the error type somewhere where it can be acted on if need be\n    yield put({\n      type: SYNC_PICKED_ORDERS_FAIL\n    });\n    console.log(`Error in update pick qty ${error}`);\n  }\n}\n\n\n// Confirm pick saga\nfunction* confirmPickAsync(Id, token) {\n  try {\n    const config = {\n      method: 'post',\n      url: 'http://XYZ',\n      params: {\n        pickingListId: Id\n      },\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    };\n    const response = yield call(axios, config);\n    console.log(`Success in confirm pick: ${response}`);\n    // Remove order once synced\n    yield put({\n      type: REMOVE_SYNCED_ORDER\n    });\n    // Restart sync queue\n    yield put({\n      type: SYNC_CONFIRM_PICK_SUCCESS\n    });\n  } catch (error) {\n    // Restart sync queue\n    // Log the error type somewhere where it can be acted on if need be\n    yield put({\n      type: SYNC_CONFIRM_PICK_FAIL\n    });\n    console.log(`Error in confirm pick ${JSON.stringify(error.response)}`);\n  }\n}\n\n//////////////////////////////////////////\n   Poll bg sync\n   //////////////////////////////////////////\n// Fetch data every XX seconds\nfunction* pollData() {\n  try {\n    yield call(delay, 10000);\n    yield call(backgroundSync); // call should resolve when all forked tasks inside it ends\n    yield put({\n      type: SYNC_ENDED\n    });\n  } catch (error) {\n    console.log(error);\n  }\n}\n\n//////////////////////////////////////////\n   Root saga\n   //////////////////////////////////////////    \nexport default function* rootSaga() {\n  while (true) {\n    yield take([\n      // I know a single action could trigger the restart but this gives me\n      // Opportunity to see what causes it.\n      SYNC_ENDED,\n      SYNC_QUEUE_EMPTY,\n      NOT_CONNECTED\n    ]);\n    yield race([\n      call(pollData),\n      take(SIGNOUT_USER) // Should cancel the sync?\n    ]);\n  }\n}\n\n```\nBut even with modified snippet Im not sure why those actions should trigger the whole thing. It seems that your requirement is just to try to sync each 10 seconds. If thats the case then it could be simplified.. I dont get quite what do you mean by restarting the process, whats the purpose of that? to which point of the list you have posted should it restart? to \"starts the background sync.\" or to the \"User authenticates and moves to the home screen.\". \nFormer would mean that it should cancel the running syncing task and start it again.\nLatter would mean that it should wait for user signing in again to start syncing.\nHowever none of them makes sense to me. The former seems the one you want, but why should you restart running sync after after each failure/success?. If you look at my latest posted snippet - https://github.com/yelouafi/redux-saga/issues/676#issuecomment-266461046 .\nYou can see that I'm using there fork effect to start a a task which will make the actual request and fork is a non-blocking effect spawning a task in parallel. So it will run through whole loop of for (const order of state.pickingList.syncQueue) { and start state.pickingList.syncQueue.length independent tasks!\nDownside of that is that if your syncQueue is big you will start multiple requests at the same time. You can use a call instead of this fork, which in result would make those requests one by one. After updatePickQtyAsync (or confirmPickAsync) ends it would resume the generator and continue with the beforementioned loop, stoping at next call again and repeats the process. \nNo restart required.. You need to rethink your flow a little bit because:\njavascript\nyield race([\n  call(pollData),\n  take(SIGNOUT_USER_SUCCESS)\n]);\nthis is resolved AFTER call finishes and you dispatch BACKGROUND_SYNC_END at the end of it (so BEFORE call finishes)\nWhen this race is resolved the saga will stop at the take and it will w8 for any of this BACKGROUND_SYNC_END, SYNC_QUEUE_EMPTY, NOT_CONNECTED to happen and trigger it to wake app and run race again . Well, if it works it might be enough but it seems weird that takeEvery(BACKGROUND_SYNC_START) causes immediately BACKGROUND_SYNC_END. Maybe you should adjust their names as their are confusing? From what I see it might work, but is kinda dependant on the ordering of those puts and effect resolution, and when something is added some time later can break that ordering just a little it might break the whole thing loudly.\nIt could be simplified to just this:\n```javascript\n// Fetch data every XX seconds\nfunction* pollData() {\n  while (true) {\n    try {\n      yield call(backgroundSync);\n      yield call(delay, 5000);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n}\n// bgSync\nexport default function* pollBgSync() {\n  const pollingTask = yield fork(pollData)\n  yield take(SIGNOUT_USER_SUCCESS)\n  yield cancel(pollingTask)\n}\n// ... in some other file\nexport default function* loginSaga() {\n  yield takeLatest(LOGIN_USER_SUCCESS, pollBgSync)\n}\n```. Could you give examples of your symbol usage?\nAbout mentioned inconsistency - is it rly one? Its a well documented API\nand im not sure what could be done to improve the situation.\nAlso - keep an eye on takeEvery/takeLatest changes in PRs. They are going\nto be effects as well, and the traditional import will be deprecated soon\nas an attempt to soften a confusion between effects and helpers.\nOn Wed, 7 Dec 2016 at 17:43, Zacqary Adam Xeper notifications@github.com\nwrote:\n\nI've been ramping up some new developers on Redux-Saga, and one of the key\nunderstandings is that sagas that watch for actions generally require an\ninfinite loop:\nwhile(true) {\n   const action = yield take(SOME_ACTION);\n}\nBut then I started seeing in code review things like this:\nwhile(true) {\n   yield takeLatest(SOME_ACTION, actionHandler);\n}\nNow, obviously this could have been avoided if:\n\nI had encouraged people to learn takeEvery more; I've gotten out of\n   the habit of using it since we use Symbols for our action types and\n   takeEvery didn't support that (has that bug been fixed?)\nMy devs had read the docs for takeLatest more carefully and realized\n   it already implements the while(true) for you\n\nStill, though, I think this inconsistency is a pain point. I wonder if\nthere's a better solution.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/677, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMko_kP2i2g8gv1omqnsXrdDCZ8RvOks5rFuIdgaJpZM4LG0QZ\n.\n. Hm. I see your point. However those names are really descriptive about what\nthey do and thats huge pro here. Naming them after fork would for sure\nintroduce much bigger mess\nOn Wed, 7 Dec 2016 at 18:49, Zacqary Adam Xeper notifications@github.com\nwrote:\nInstead of const ACTION_TYPE = \"ACTION_TYPE\" our convention is to do const\nACTION_TYPE = Symbol(\"LocalNamespace ACTION_TYPE\"). Turns out this was\nfixed in #246 https://github.com/yelouafi/redux-saga/issues/246, so\ntakeEvery should be safe for us to use now and I need to get back in that\nhabit.\nChanging takeEvery/takeLatest to effects would be a great help. But\nfurthermore, I guess the reason I see confusion is because they're called\ntake[Something] but their behavior is actually much closer to fork than\nto take.\nI do recognize that the way the docs are structured is to introduce\ntakeEvery first and then consider take to be an advanced concept, so\nagain, maybe it's my fault for teaching people Saga in the opposite\ndirection. Although I do think it's valuable to understand what's actually\ngoing on under the hood in a saga \u2014 seeing an infinite loop of takes is a\nvery good way to communicate the concept of why Saga uses generators.\nIn fact, to me that's the power of Saga over something with a huge library\nlike RxJS \u2014 the fact that you can express complex patterns with these\nsimple building blocks. I agree, I'm not sure off the top of my head how to\ndo it better, but I would like it if the higher-level helpers were more in\nharmony with the lower-level building blocks that they're named after.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/677#issuecomment-265519048,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkn8a8ypplZt6CZFzDKjdWqMdrD0aks5rFvGVgaJpZM4LG0QZ\n.\n. It all depends on how you want to test and how much you would like to have tests coupled to the implementation. There is not (and probably wont be) official way of testing your complex sagas as it really comes down to your personal preference about testing in general.. @erikvold it seems so, many threads about testing approaches are spread on the issues unfortunately\n\nduplicate of #518. I think you might have some error in your code as generator.next().done shouldnt be true as you are running endless loops in both of your snippets. Could you post a working example of undesired behaviour?. No, I wouldnt say this will make testing easier, it may accidently be less error-prone, but I think it is a good thing to understand what those line of codes do and how generators work if you are using them, so making such a rule of \"put take always into the loop's body\" would deprive many people of that basic understanding.. javascript\nit('waits for FETCH_POSTS', () => {\n  const expectedTake = take(actionTypes.FETCH_POSTS);\n  const expectedCall = call(fetchPosts);\n  expect(generator.next().value).to.deep.equal(expectedTake);\n  expect(generator.next({ type: actionTypes.FETCH_POSTS }).value).to.deep.equal(expectedCall);\n});. Passing predicate is already possible and your first proposal with passing\nobject can be easily achieved with it, so I think there is no point in\nextending the API with that\n. Thanks!. I would say that onerror is more in javascript manner than onError.\nObviously we need to set 1 naming convention and follow it strictly through\nthe source code and docs.\nIf we decide to do a change in the source code we should keep both naming\nconventions available to use for this particular case, but the old one\nshould give a deprecation warning.\n@yelaoufi should decide here which one should prevail\nOn Sat, 10 Dec 2016 at 17:30, Yuki Kodama notifications@github.com wrote:\n\nHi, I'm writing flow-typed's definition for redux-saga 0.13.x. While\nworking on it, I found miss-spelling issues in options of\ncreateSagaMiddleware function.\nSource Code\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/middleware.js#L43:\nonerror\nRelease Note https://github.com/yelouafi/redux-saga/releases/tag/v0.12.0:\nonError\nAPI docs\nhttp://yelouafi.github.io/redux-saga/docs/api/index.html#createsagamiddlewareoptions:\nonError\nThe author wrote onerror in original PR\nhttps://github.com/yelouafi/redux-saga/pull/533. But it doesn't follow\nJavaScript manner. May I send a PR to change from onerror to onError? I\nworried about this change causes breaking API and bump a major version.\nPlease let me hear your thought on this.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/682, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkikTRbrGA-adLVZO4zsvuwHdm_cdks5rGtOHgaJpZM4LJsRm\n.\n. onError is fine with me 2, using camelCase in most of the situations too\n\nWould you like to provide PR introducing onError into the source code and deprecating onerror? If not I can do it some time later. Could u post a code snippet?. well, redux-saga and rly most of the code runs big chunks of code synchronously, so for it to keep working it needs to swallow the error on one level or another - or pass it to the user ofc like here so he can report it somehow\nWe cannot let it to throw just like that as everything would go south.. Well, stack issue is something entirely different - this one can probably be fixed on our side. I dont have time to tackle this though now, would you like to dive into the code a little bit and check why that's happening?\nAlso the whole swallow put errors by default is a little bit questionable and I'd like to revisit it and rethink if its actually a good idea.. Thanks!. @kuy \n\nTo use takeEvery, you need to split a saga.\n\nWhat do you mean by splitting?\n\nThis code will work well only if fetchPosts function returns quickly and FETCH_POSTS actions are not dispatched frequently. If nextFETCH_POSTS action is dispatched before calling of fetchPosts returns, it will lost (drop) FETCH_POSTS action.\n\nWell, sometimes that is exactly what you are trying to achieve, so it really all depends on requirements. Sometimes deliberately calling call to block a while (true) loop until call is resolved is what is needed by the app.\n@schuchowsky \n\nSo, my doubt is that I don't understand the need of having that while(true) loop, if we have takeEvery function. Am I going to miss something using my approach?\n\nWell, those examples in the docs are for presentation purposes. takeEvery is not always sufficient as its just a helper creating for you something similar to this:\njavascript\nfunction* watchFetch() {\n  while (true) {\n    const action = yield take(FETCH_POSTS)\n    yield fork(fetchPosts, action)\n  }\n}\nBut having ability to use take manually in while loops allow you to model more complex scenarios, this one is so trivial that it makes sense to have a shortcut form - takeEvery. Thanks!. Thanks!. > >looking on runSaga API it was really confusing for me that it behaved pretty much like store, but not exactly. Real store's subscriber function is not receiving any arguments, its just notified about the change, but nothing more. Dont you think it's a slight problem? Maybe the difference should at least be expressed better in the docs?\n\nNot sure to understand what you mean. runSaga's subscribe argument is different from store's subscribe. We need the input argument in order to fullfill take effects, in the middleware we get this from the middleware's action argument.\n\nYes, I know thats the input argument is needed somewhere, just wondering if maybe it could be done in some other place, so the store like API remains the same as the real store. Didnt spent much time on that thought though, just it caused me a little confusion at first as dispatch and getState are 100% the same and suddenly subscribe is not so I had to stop and think how it works, how its implemented and why it is implemented this way.. @yelouafi \nI've pushed the fresh version of this branch and it should be ready to merge, however would like you to take a look before it.. Well, as of actionChannel + custom buffer solution - that was my first thought (maybe not totally custom buffer, but utilising existing ones), but the problem is that you take the first item immediately and in the sequence of 1 debounce call you need to behave differently than when waiting for the leading call (or I might didnt come up with the better solution... yet ;) )\ntried to work around this snippet which I use in my app, but unfortunately changing its logic to debounce is not straight-forward, as i dont know how to escape the need of second inner loop (like in the first post) and that defies the whole point of smart using the channel\n```javascript\nexport function* trailingThrottle(ms, pattern, worker, ...args) {\n    const throttleChannel = yield actionChannel(pattern, buffers.sliding(1))\nfor (;;) {\n    const leadingAction = yield take(throttleChannel)\n    yield call(delay, ms)\n    const [ action ] = yield flush(throttleChannel)\n    yield fork(worker, ...args, action || leadingAction)\n}\n\n}\n``. smth liketake.preservecould be added orbuffers.preservingand maybe those could be leveraged to make a nicer implementation fordebounce` and at the same time be a general purpose API for everybody to use, what do you think?. That's probably a bug, PR is on the way. Fix should be published in a following week, but till this time I would advice to use a forked repo (from the tag you are using right now) with the fix included. Sorry for the problem.\nI would appreciate also if you can let us know if this fix helps you.. Unfortunately, I'm not familiar how Rollup bundling works and what should jsnext method do. Could you try to explain those a little?\nWould you compare our distribution system with some other libs which are bundled with webpack and do not cause you any problems? Then we could start from this comparison and workout the solution.. from what I see we have appropriate entry in our package.json, just in other order, but that shouldnt be a problem\n\"main\": \"lib/index.js\",\n  \"jsnext:main\": \"es/index.js\",\nIll wait for the comparison, as it might be really helpful in tackling this.. could you create a test repo for me so I could play a little bit with the settings? would appreciate for instructions how to reproduce too. cool, thanks for those, gonna play around with it some time later!. Ok, I think I know why this happens, but aint sure how it should be solved.\n\nredux-saga/effects is interpreted as node_module, so its traversing the directory tree and searches for that using this\nhttps://github.com/substack/node-resolve/blob/7f0ce871b6d2b5cb2082b04cd72ddd4055cb7a05/lib/async.js#L172\nits checking always if the found thing is a dir or file and act accordingly\nit finds this https://github.com/yelouafi/redux-saga/blob/250e722419f9fcaade729c51aaf5d97a3de2b16a/effects.js and loads accordingly which in your case unfortunately points at the wrong file (from the lib) folder\n\nIn case of redux-saga itself it finds a correct directory and rollup later concatanates path with jsnext:main option. But its not working with effects.js for quite obvious reasons.\nIll try to reach out to rollup users so it can be handled in a better way.\n@yelouafi \nI've always wondered about dir structure in the repo, could you elaborate a little bit more on it? Ive always assumed that webpack when importing redux-saga/effects is reaching for ./lib/effects.js but it might seem (didnt check it though) that its reaching for ./effects.js and this only acts as a 'proxy' to the beforementioned file. Its kinda non obvious at first and Im wondering if maybe it could be somehow organised better as this 'proxy' seems a little bit hacky. Hm, so the solution would be to access a jsnext setting somehow and require this conditionally. Kinda clunky and aint sure if possible yet. Gonna search for possibilities later.\n@zech \nFor the time being I would use effects like this, until the issue is resolved better.\n```javascript\nimport { delay, effects } from 'redux-saga'\nconst { call } = effects\nfunction* saga() {\n  yield call(delay, 1000)\n}\n```. its more tied to the internal directory structure (which rather wont change ;) but still)\nHowever as both are working, feel free to use whichever is more convenient for you.. It depends - v0.14.0 fixed wrong CHANNEL_END export\nBut the issue of importing redux-saga/effects within rollup is still not resolved. The best I've come with is this, where possibly in the future we could switch the default to es6 modules once rollup/webpack2 adoption increase and make the reverse fallback to the cjs module format for webpack1 users.\nWDYT? cc @zech @nktssh @yelouafi . @zech \nYe, you are right, I got confused a little bit and changed the initial fix, gonna straighten thing up, just need to establish what should be in fact be exported as there are like 2 or 3 similar things, some internal. Sorry for the confustion.\nPlease read this explanation about 2 entry points problem, if you are interested.. The solution of splitting the lib into separate modules and have them required by each other if neccessary - monorepo style - seems the most viable. \n@zech how would it mix up es6 and es5 code during the build? what do you mean?. > Besides, as I can see from v0.14.0 release notes, a lot of people are confused about two imports\nThat confusion was only about things like take and takeEvery being exported from other modules. Not that 2 modules are confusing in general.\n\nDo redux-saga really need this effects separate import?\n\nPersonally I think this distinction helps people understand the idea behind effects (plain objects with appropriate structure, just like redux actions are - plain objects with type property)\n@zech \n\nYou mean PR for documentation? Can you tell me where you want me to put it? Troubleshooting? But bear with me because I've not done that very often.\n\nYeah, Troubleshooting seems like a good place for this one.\n@issue\nstill needs to think about the issue and decide what to do, w8ing also for @yelouafi's comment on the matter\nEDIT:// from what I see lodash provides special, additiona build so in case you want es build you install separate package lodash-es\n. The fix is pending in the PRs here - https://github.com/redux-saga/redux-saga/pull/724 . How much of the problem does it cause now? Does the fix require using a forked repo? If so Im gonna push the simpler fix faster and release updated library asap.\nSorry for the delay and all, Ive kinda messed up things here. \ncc @ok111net . Ok, I'll release a faster patch version asap and let you know.\n. @zech @ok111net - please check out the new release and let me know. I would like to keep this opened as a reminder that something should be done in the library itself. Possibly we should release 2 builds, but thats the subject for the future for now, as there are more pressings matters at the moment.\nAbout your package - couldnt you spread them? Would it break tree shaking? I havent done it yet, so aint familiar with the rules involved ;). hey guys, would this one solve the issue for you?. thanks to @Ephys I'll release a patch version today which should fix this problem entirely and fixes/hacks like:\n- aliasing\n- @nktssh 's redux-saga-effects package\n- importing effects from redux-saga\n- etc\nshould become obsolete :tada:. couldnt proc's CHANNEL_END just be imported from the ./channel? Is there need for both? . Ok, gonna look more into that, but merging for now as the original issue is resolved.\nAlso still aint sure about this:\n\nhttps://github.com/yelouafi/redux-saga/blob/283cc6c168e5773854e44dce66cda70bb1a1d0a9/src/internal/proc.js#L9 - I'm wondering about theese lines - Whats the purpose of this being an object with toString method?. Thanks! That's a great input easing a newcomers life. Ive put a tiny comment, would you like to address it before merging?. Thanks! looks good :). Hm, I guess it is more strict now. Thanks for a PR!. put.sync got renamed to put.resolve (not released yet, but already on the master)\nShould the helpers, select, actionChannel be included here?\n\nYeah, I think its useful to keep all effects here (helpers are gonna be effects as well with the new release), all of them being non-blocking.\nput(channel, action) is never blocking I think (only scheduler by asap internally), although the above comment (\"sometimes, see API reference\") should be for take(channel)\nAlso I would like for @yelouafi to take a look on it, before merging. both of select and actionChannel are non-blocking as they simply run a functions, but are wrapped as effects so its easy for the saga to distinguish them and run appropriately, so as long as they are effects they should be included in the cheat sheet.\nabout the messed up branch - you could probably just reset till your good commits, just keep a copy so you dont lose your changes by accident ;). Although the diff is good, I wouldnt like to merge this 'broken' branch as it would bloat history too much with unneccessary duplicated commits.\nDo not close the PR though, I'll try later to play with your branch and its history and maybe we could recover it. . sh\n$ git reset --mixed HEAD~3\n$ git stash\n$ git reset --hard HEAD~1\n$ git stash pop\n$ git commit -am 'YOUR NEW MESSAGE'\n$ git push --force. Thanks for your work!. hm, im not 100% sure if I understand your requirements, but from what I do it seems that\n1. performTask2 should be performed for each doAsync2\n2. performTask1 should be performed for latest doAsync1 but scoped per some component id which is included in the doAsync1 action\nSo for those requirements I've written a simple general use-case helper and rewritten your snippet using that\n```javascript\nfunction* takeLatestPerProps(propsOrSelector, pattern, worker, ...args) {\n    const channelsMap = {}\nwhile (true) {\n    const action = take(pattern)\n    const propsValue = typeof propsOrSelector === 'function' ? propsOrSelector(action) : action[propsOrSelector]\n    if (!channelsMap[propsValue]) {\n        channelsMap[propsValue] = channel()\n        yield takeLatest(channelsMap[propsValue], worker, ...args)\n    }\n    yield put(channelsMap[propsValue], action)\n}\n\n}\nfunction* performTask1() {\n    // already scoped per 'id'\n    const { result } = yield call(api, args)\n    // do something with results (not relevant)\n}\nfunction* performTask2() {\n    const { result } = yield call(api, args)\n    // do something with results (not relevant)\n}\nfunction* watchAsyncTasks() {\n    yield takeEvery('doAsync2', performTask2)\n    yield takeLatestPerProps('id', 'doAsync1', performTask1)\n}\n```\nNOTE: also the form you have used in your snippet - const { result } = yield takeLatest('doAsync2') wont work as takeLatest returns a task descriptor (so it could be canceled at a later time). Your understanding is correct - just creating new channels for not yet created ones per props (+ spawning takeLatest with the created channel passed in) and takeLatestPerProps serves as proxy for passing actions to appropriate channel and then takeLatest can do its thing.\npropsValue is the unique identifier to be used for creating and storing channels in the map. Ive included obtaining it simply by accessing property of the action or by running a selector on the action with that line\nconst propsValue = typeof propsOrSelector === 'function' ? propsOrSelector(action) : action[propsOrSelector]\nwhich can come handy in some situations. Its pretty similar to the concept of take(pattern) which you can use by simply passing a string in like so take(ACTION_TYPE) or take(ac => ac.type === ACTION_TYPE). No. You dont need to do it. takeLatest will take any items in those channels and handle only the latest one with a worker generator. So those channels should have at most (for a brief moment) 1 item buffered in them, which are gonna be immediately taken from them, so there is no need for clearing them - they will clear themselves automatically (thanks to takeLatest). Thanks!. Actually we are in the process of migrating those helpers to the effects and you caught us unguarded ;) Within a week I think the new redux-saga version should be released with that changes. Probably docs were adjusted prematurely, sorry for the confusion.. @sublimeye sorry for this mess, I forgot that the main README.md is accessible just like that on the repo site, other docs were more safe to update even before releasing the new version and the docs site needs to be published manually and I've planned to do it after the release\nThat being said I'll definitely release the newest version before the weekend. Im not exactly sure what you mean by the bridge here, but this API https://redux-saga.github.io/redux-saga/docs/api/index.html#runsagaiterator-options helps connecting the saga to the non-redux projects.\nIn that way you could pass success/error from the getArticle's callbacks to the saga.\nOr you could just dispatch your getArticle and play around with this snippet\n```javascript\nfunction getArticle(id) {\n  const apiCall = fetch(...); // your promise\n  // you cant test your created promise origin, so checking in saga just for smth like takeEvery(ac => typeof ac.then === 'function') wont suffice as you probably like to handle different promises in different ways, so you need to have a 'type' here os some other field, but with type you can use a shortcut syntax for takeEvery('REQUEST_ARTICLE' )\n  apiCall.type = 'REQUEST_ARTICLE' \n  return apiCall\n}\n// ...\nfunction* requestArticle (promise) {\n  try {\n    const response = yield promise; // you can yield promises just like that\n    const data = yield call(response.json);\n    yield put('ARTICLE_REQUEST_SUCCESS', data);\n  } catch (err) {\n    yield put('ARTICLE_REQUEST_FAILED');\n  }\n}\nfunction saga () {\n  yield fork(takeEvery, 'REQUEST_ARTICLE', requestArticle);\n}\n. How do you leverage `redux-saga` in combination with this other middleware?. I might not know something about requirements, but I dont see why this logic couldnt be embedded in the saga, instead of in `redux-wait-for-action`, which would automatically solve your concern about promise order.javascript\n// saga code\nfunction requestArticleSaga(view, { id }) {\n  yield call([view, view.renderLoadingSpinner]);\ntry {\n    const response = yield call(fetch, https://api.example.com/${id});\n// aint sure if this method needs the appropriate this binding but it would be safer to use\n// 1. const data = yield call([response, response.json]);\n// or 2. const data = yield apply(response, response.json);\n\nconst data = yield call([response, response.json]);\nyield put({ type: 'ARTICLE_REQUEST_SUCCESS', id, data });\nconst articleState = yield select(state => state[id]);\nyield call([view, view.renderArticleView], articleState);\n\n} catch (error) {\n    yield put({ type: 'ARTICLE_REQUEST_FAILED', id, error });\n    const articleError = yield select(state => state[id].error);\n    yield call([view, view.showErrorPage], articleError);\n  }\n}\nfunction* root(view) {\n  // with v0.14 if you import takeEvery from the redux-saga/effects\n  // you can shorten this\nyield takeEvery('REQUEST_ARTICLE', requestArticleSaga, view)\n// also if you put the logic into the saga it could be better \n  // (if this meets your requirements) to use takeLatest instead of takeEvery\n}\nsagaMiddleware.run(root, view);\n// reducer\nswitch (action.type) {\n  case 'REQUEST_ARTICLE':\n    return { ...state, [action.id]: { loading: true } };\n  case 'ARTICLE_REQUEST_SUCCESS':\n    return { ...state, [action.id]: action.data };\n  case 'ARTICLE_REQUEST_FAILED':\n    return { ...state, [action.id]: { error: action.error } };\n}\n// action creators\nfunction requestArticle(id) {\n  return {\n    type: 'REQUEST_ARTICLE',\n    id,\n  };\n}\n// legacy code\nconst id = parseInt(params.id);\nstore.dispatch(requestArticle(id))\n```\nThis way the whole logic is contained in one async flow inside the saga and you get rid of the overhead tracking this between files and concepts.\nWhen you migrate your views to be redux-connected you will just get rid of those pesky view calls inside the saga, as your views will rerender themselves automatically based on the store's state.. In that case the approach with redux-wait-for-action seems really constrained and your objections towards the promise resolution order is just too big of a concern to ignore it.\nI would suggest to make your own solution with a custom middleware like this:\n```javascript\nexport const DEFERRED = Symbol('DEFERRED');\nconst createExposedPromise = () => {\n  const deferred = {}\nconst promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve\n    deferred.reject = reject\n  })\nreturn [ promise, deferred ]\n}\nexport default store => next => action => {\n  if (!action[DEFERRED]) {\n    return next(action);\n  }\nconst [ promise, deferred ] = createExposedPromise()\n  next({ ...action, [DEFERRED]: deferred })\n  return promise\n};\nand then use it in the similar way like you have proposedjavascript\n// saga code\nfunction* requestArticleSaga({ id, [DEFERRED]: deferred }) {\n  try {\n    const response = yield call(fetch, https://api.example.com/${id});\nconst data = yield call([response, response.json]);\nyield put({ type: 'ARTICLE_REQUEST_SUCCESS', id, data });\nconst articleState = yield select(state => state[id]);\ndeferred.resolve(articleState)\n\n} catch (error) {\n    yield put({ type: 'ARTICLE_REQUEST_FAILED', id, error });\n    const articleError = yield select(state => state[id].error);\n    deferred.reject(articleError)\n  }\n}\nfunction* root() {\n  yield takeEvery('REQUEST_ARTICLE', requestArticleSaga)\n}\nsagaMiddleware.run(root);\n// reducer\nswitch (action.type) {\n  case 'REQUEST_ARTICLE':\n    return { ...state, [action.id]: { loading: true } };\n  case 'ARTICLE_REQUEST_SUCCESS':\n    return { ...state, [action.id]: action.data };\n  case 'ARTICLE_REQUEST_FAILED':\n    return { ...state, [action.id]: { error: action.error } };\n}\n// action creators\nfunction requestArticle(id) {\n  return {\n    type: 'REQUEST_ARTICLE',\n    id,\n    [DEFERRED]: true,\n  };\n}\n// legacy code\nview.renderLoadingSpinner()\nconst id = parseInt(params.id);\nstore.dispatch(requestArticle(id))\n  .then(articleState => view.renderArticleView(articleState))\n  .catch(articleError => view.showErrorPage(articleError))\n```\nMuch simpler and it wont suffer from the ordering issue. > Or maybe this all boils down to needing to pass an explicit promise reference, so that the correct promise is resolved...\nexactly that, there needs to be some kind of connection between the requestArticleSaga instance (spawned by takeEvery) and the trigger-action's promise. With the ability to make custom effects it maybe could be somehow tied behind the scenes, but there is no possibility to make them right now.\nThats why I've proposed attaching the deferred as metadata on the action object, so it can be easily referenced. If you would like to make it more effect-like you can wrap those resolve/reject calls with call effect, but thats best what can be done for now I guess. \nIn general when I think about it right now such custom effects could be quite easily created if only certain internal building blocks would be exposed for people wanting to build more personalized runners. For now it will stay as open question if the internals could fulfill such premise, aint sure if they are modularized enough for now. The excellent example of hardcore modularization - exposing both high-level and low-level APIs were recently done in react-redux (v5 !). I think this migration from v4 to v5 in that package might be an excellent study case for such endavours.. Going to close this, if you have any further questions - please just ask :). It should be somewhere, although as mentioned - it is not recommended. It's better to use call wrappers.. Its prematurely updated. Within a week there should be a new version of\nredux-saga published and the preferred way to import those will be from\neffects, although the old way will still be supported for the time being.\nSorry for the mess, ive updated the entire project too soon, as docs needs\nto be published separately from just pushing the changes to the master\nbranch. Forgot though that main Readme.md is still available right away on\nthe main page of the repository\nOn Thu, 15 Dec 2016 at 06:01, novaline notifications@github.com wrote:\n\n@neurosnap https://github.com/neurosnap I enter the breakpoint find\nthis. Thanks! The example of README.md is wrong?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/698#issuecomment-267239463,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMksCxONLlpMccIBamzvHXsv2rkcRYks5rIMmlgaJpZM4LNpfy\n.\n. Docs are up to date already as new version got already released. Do you experience any errors? What version of redux-saga are you on?. both import { takeLatest } from 'redux-saga/effects'; and import { takeLatest } from 'redux-saga'; are working since v0.14 but the latter (the one you are using at the moment) is deprecated. Should work, check if you have redux-saga installed and your overall configuration. That's standard way of importing and using this, never had a problem.. Could you post a webpack bin with your problem? And also what version of the redux-saga are you using? \n\nFrom what I seen on the screen the call effect was yielded to the saga as runCallEffect is visible in the stack. Is your login generator run by a call effect?. Would you be willing to provide a PR for it?. You can also read a little bit more here - https://github.com/yelouafi/redux-saga/issues/651#issuecomment-262375964\nAlso remember that even if your race wont be able to 'cancel' your regular fetch, so the response will return to your browser, it doesnt mean that redux-saga will handle it - its response will be ignored.. Could you reproduce it on something like webpackbin? Would be really helpful to play around with full working example.\nOr you could public your repo and prepare it for testing.. It seems that it is caught here for you - https://github.com/yelouafi/redux-saga/blob/fb4c69e7a9fe7e588a878b898ce6f342a1e9428a/src/internal/proc.js#L343-L347 . Thats probably why it has not impact on your code, beside the nasty warning.\nIt seems though that it might be related to some bug on our side, replicated example would help a lot.. @kopax \nYe, it would still be cool to see a gist of saga example, as @yelouafi's code probably shows what I would expect to happen. Within saga environment that shouldnt happen.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. cc @aikoven. You can connect other data sources via - https://redux-saga.github.io/redux-saga/docs/api/index.html#runsagaiterator-options . It would be technically possible to use in node, but without requirements, I cannot recommend any specific.\nAlso look at this project - https://github.com/koajs/koa. Imho takeBetween is kinda misleading name for this one, smth like runBetween or forkBetween would be much more appropriate.\nAlso instead of task.cancel() the more idiomatic way to do this is yield cancel(task)\nI aint sure if this one should be added to the core, but overally is quite cool. I would love to see some redux-saga-utils package with more of such helpers. Without tree-shaking it might not be worth to add it for everybody.. Ive marked this as utils, so it can be easily found in the future. Gonna close for now as such utils package needs to be rethought and organised. Not much time for that now. Its certainly something I would like to have done in some form after we release v1.\nIll keep tabs on various ideas which could have been added to such a package. If you have some free time (or anybody else for that matter) it would be super helpful if you browse our issues and gather a list of things that people have proposed or maybe even gave examples of in the comments. Separate issue could be crated for this.\nGoing to close this for now. If you have any further insight - Im all ears :)\n. Thanks for the issue, especially for the webpackbin! Its really helpful.\nI think I already know whats the problem:\n1. every task has its own stdChannel's instance\n2. in the moment of dispatching END there might be a situation - in fact its highly possible - that some task is blocked on something other than take\n3. such task's stdChannel will close (cause of END), but END doesnt terminate your tasks - it only terminate those blocked on take\n4. so when your blocking effect finally resolves and run next on the saga, it might meet a fork effect\n5. it will spawn a new task ofc, with the new stdChannel's instance, which has no idea that END was dispatched before, therefore it wont close automatically and will block on take as usual\n6. and ofc as there is a task running your .done.then wont be run\n@yelouafi \nthought about reworking stdChannel to be a singleton, so once it gets closed all future take effect would resolve with END, but from what I see it would require also channel.put rework, so it could support resolving many takers for 1 input, any cons?. @awaw00 \nI've wanted to let you know that I'm working on the stdChannel so it can become a singleton, and im pretty much done, but have 1 case to work out, before its ready. Hopefully it wont take me forever ;) It also will help on some perf issues when one have really many tasks in his app, since every task is not geting subscribed to the individual instance of stdChannel internally, even when it doesnt care (it wont use take), which can lead to too many subscribers being called on each dispatched action. You might be right, although Ive started implementing this and added smth like putAll to the interface, which could be possibly made later as an effect too. It might be useful for people to multicast to the channel, so each pending subscriber gets the notification. \nThey do not seem too coupled and that this unification between them impose complications (yet at least). Ofc they for sure need to share the common interface. Implementation could be split, but aint sure how much of a gain would that give us, and for sure some duplication (which is not always the worst thing in the world). \nAnyway - established semantics/API would be great. If we split the implementation then multicast primitive could be exported for external usage too and stdChannel just being made on top of it + put wouldnt need its twin method putAll, but just the behaviour would differ - depending on the channel type - multicast vs unicast. Although it wouldnt allow different behaviours on 1 channel type - the behaviour would be set in stone when somebody choses the channel type.\nIn general - pick a side, I'll just get along on this one as you have a better gut on those things :). Im working on releasing v1. Part of that is rewritten internal stdChannel, so it becomes a multicast. It solves this bug and some others. I've written failing test for the bug described in this issue and merged it into the mentioned stdChannel PR to confirm that. Therefore I'm closing this issue now, you can watch progress on v1 here. I don't have much time to work on this, so however slow the progress is it is steady at the moment, so I hope you won't have to wait too long for the release.. Thanks for the PR, actually README got prematurely updated - both imports will be available with the new release, which gonna happen in following week. \nSorry for this mess!. Hey,\nthanks for the PR - its probably the good idea to include in this tutorial even more of the code involved in real working example - not the value props only. It in fact only shows the relevant parts of the code, but there is no indication that there should be more in the final code.\nCould you adapt your PR to include all of the Counter and render code with indication what was added on each step?. Checkout this comment. Effect creator is a function returning a description-object, look at this.\nAlso the created effects are later interpreted here.\nSo for allowing custom effects we would need to expose hooks to those internals and document how to work with it, might make sense for other use cases, but for yours it seems like an overkill.\nIm wondering - isnt just importing an external module containing a reference to your connection viable option? \nAlso - the title of the issue implied for me that this could be used.. > But it won't look nice in the monitor and there's no way for it to access saga runtime stuff.\nOut of curiosity - what saga runtime stuff you would like to have access to?\n\n\nAlso - the title of the issue implied for me that this could be used.\n\nI want to still be able to put to Redux along with accessing non-redux store. I think it's possible to build some smart dispatch and getState options that would somehow route actions and state to the correct store. Seems fragile though.\n\nBut would abstract your connections and you wouldnt need to care about it in your sagas. Well, I guess allowing custom effects wouldnt be even that much of a problem, only if they are self contained and do not need access to the proc's closure. Although I dont see much of the use case for that beside looking more nice in the monitor and allowing ofc access to some external objects without needing to pass them around as args (so basically a context)\nWDYT @yelouafi ? . does React's context allows removal?. Please read the new release notes - https://github.com/yelouafi/redux-saga/releases/tag/v0.14.0\nHowever in the moment of the PR it was indeed broken and confusing, so thanks for being vigilant!. Thanks for the fix!. Could you specify the redux-saga version you are using? Also the code\nsnippet of the moment dispatching those actions wold be helpful\nOn Mon, 26 Dec 2016 at 19:05, anthonychung14 notifications@github.com\nwrote:\n\n50 https://github.com/redux-saga/redux-saga/issues/50 seems to address\nmy issue, namely this quote\nThe problem is that the then callback will not execute right away, instead\nthe underlying promise runtime will schedule the goAndFetchNextTakeEffect\nin a microtask queue. It simply means, the then will wait for the current\nflow (for example the current event handler, or componentDidMount or\nwhatever fired the action) to terminate and then execute\ngoAndFetchNextTakeEffect. Meantime your code continues and executes\ndispatch(action2). But at this time, the Saga hasn't yet fetched the next\neffect (e.g. take or fork) so it is not ready yet to take the action.\nHowever, since this issue was closed, I'm not sure what the resolution was\nif there was a fix implemented to allow this use-case\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/718#issuecomment-269231645,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkpL_mesL98QUoAWOvQIqF_8hxP1hks5rMAHlgaJpZM4LV3S4\n.\n. I've created a webpackbin with your snippets in it and it seems that both actions are logged to the bin's console. \n\nCould you reproduce the issue there? Your original code is way more complex than this simple demo and without the reproduced issue its really difficult to help. You can just edit the code and git Save - it will generate the new URL with your changes included.. ```javascript\nexport default function* componentContentSaga(action) {\n    const buffer = buffers.expanding()\n    const actionChan = yield actionChannel('UPDATE_COMPONENT_CONTENT', buffer)\n    const resChan = channel(buffers.expanding())\nwhile (true) {\n    const { payload } = yield take(actionChan)\n\n    try {\n        const res = yield call(someAPI, payload)\n        yield put(resChan, res)\n\n        if (!buffer.isEmpty()) {\n            continue\n        }\n\n        const results = yield flush(resChan)\n        yield put({ \n            type: 'COMPLETE_TRANSACTIONS',\n            payload: results.reduce(reducingFunction, {})\n        });\n    } catch (err) {\n        yield put({ type: 'PUT_FAILED', payload: err, error: true });\n        // also there should probably be something done about\n        // resChan, actionChan and failed call\n        // but hard to tell what without knowing the requirements\n    }\n}\n\n}\n```\naint sure if this meets your needs, but should be easily tweakable. The reposity was just today transferred to the organization's account so from now on the correct URL path for all docs is https://redux-saga.github.io/redux-saga/docs/\nI've corrected just now all links I've had found and gonna ping @yelouafi to publish the docs asap. \nThanks for noticing and reporting the issue!. Hey,\nall typings (both TS and flow) are community-driven and not written by core maintainers, so there is a high possibility for a mismatch between just released version of the library and the respective typings files.\nI will be happy to merge your PR with updated typings, which (like you said) should be copied from from index.d.ts to effects.d.ts , just please remember that original helpers were generators and effects are just plain objects. The accepted types should stay the same but the returned type for the effects should be different - in this case the same thing what fork would return. For reference see this. Thanks for noticing! Gonna merge right away.. oh, ye - sure :) always wanted to get this done eventually. @karland gr8 work! Would prefer to keep it open for a while, maybe you'll face some competition :P but anyway I like it and if nothing new pops up, I would like to make this official with your permission ofc :)\ncc @yelouafi . maybe the proc's one should be called CHANNEL_END_TERMINATION then?. or maybe SAGA_TERMINATION with reason field? would probably come handy for tracking cancellations\nI was trying to grasp how cancellation cause of uncaught error and cause of the cancel effects work and propagate through tasks to track the chain so it (canceled tasks) can be printed here and also omitted when cancellation happened intentionally (by a cancel effect)\nBut what I thought would take only little of time, happened to be not so easy and hadnt yet time to go back to this idea and debug further. . wouldnt in this case { [SAGA_TERMINATION]: CANCEL, reason } reason be kinda already included there? I mean the CANCEL value, it would indicate the already a reason - explicit cancel from the user. yes, but still with mentioned example ({ [SAGA_TERMINATION]: CANCEL, reason }) im not sure if there is a purpose of both value of [SAGA_TERMINATION] field (here CANCEL) + the reason field.\nArent they the same in the end? \nWith the proposed SAGA_TERMINATION I would now implement this as similarly to the runEffect. So something like:\njavascript\nlet terminationType\nif (terminationType = asTermination(arg)) {\n    // delegation to each method, for various termination types:\n    // err ?\n    // TASK_CANCEL, maybe 2 types here - explicit (user-induced) and implicit (saga-induced)\n    // CHANNEL_END\n    return\n}\n// rest of the `.next()` logic\n. > > or maybe SAGA_TERMINATION with reason field? would probably come handy for tracking cancellations\n\nI thought you're talking about having additional infos about the origins of cancellations (manual, automatic in race or parallel)\n\nYeah, that was an idea once, forgot a little about it :P sorry for the confusion. Ive missed that in my understanding now. Anyway - I'll probably just try to implement this what we were talking about and such cases will just show up during the implementation I guess - whats needed and whats not.. Hm, its in fact a little flawed just in this particular case - actionChannel with custom buffer as buffer is an object containing function references and each buffer is a completely new instance with its own functions as those functions uses closure variables. Therefore deep equality check wont work.\nIt could be reworked internally so each buffer could hold the same function references, but aint sure if its worth it. cc @yelouafi . It would require buffer object to hold to its state variables instead of reaching to the closure and that could be done in 2 ways:\n1. in breaking manner - each method push, take, flush, isEmpty, put would have to accept additional parameter - buffer and mutate its state\n2. in non-breaking manner - those methods could mutate buffer's state if called with it as this, however whole redux-saga codebase is this-less and it would be nice to keep it that way\nFor now you could use:\njavascript\nexpect(\n  asEffect.actionChannel(processServerActionsSaga.next().value)\n).toBeDefined()\nor some similar utility + the spy on buffers.expanding to check if it has been called.. While this approach looks nice and all I think its an overkill to yield the buffer just so it can be returned back to the saga so from the tests we can mock it. But whatever works for you.. cc @aikoven . I guess its because each of them will get evaluated by runEffect anyway\n. Hm, it depends when Im looking at it :D but yeah, argument can be easily applied to the parallel effect too. However it slightly differs as all effects must resolve in case of the parallel one, so it doesnt matter in most cases that the thing was yielded parallely, only that it was yielded. With race situation is different as we do not want to resolve whole map of effects immediately.\nMaybe we should have parallel([...effects]) too and deprecate yielding arrays?\nWould be more explicit what it does and educating about it would be easier and also would be easier to feed such a middleware as from this PR with this.. For sure yielding arrays wouldnt be removed at once, just deprecated at first. But it would give more explicitness for this effect, which is in my opinion better in most cases. Implicitness causes confusion. \n. hm, all is a good name! nice relation to the well-known Promise API, although I got used to parallel already \ud83d\ude22 \nwe made quite an offtopic here about this one, but what about the PR as the whole? Should something be done here or should we merge in?. cb is a resolver, I guess in your implementation the effect needs to be interpreted by the whole chain and final next is the cb itself.\nProposed API was to pass next(effect, cb) to the next item in the chain (cb missing in original comment because of the mistake I guess). In that manner you could bypass leftovers in the chain if u know you can return value already right into the saga's interpreter.. @eloytoro the problem was that in your test by delaying the forkB effect it didnt get a chance to set up a listener for ACTION-3 (with take('ACTION-3')) and it just missed it and couldn't proceed further because the action was dispatched too early\nI've merged your branch here #1246 , need to review it and gonna just do some minor tweaks, so it can land on master soon. Sorry that it took so long time to take this further.. Well, functions cannot be tested against equality in other way than by reference, so deep equality check wont do you any good.\nYou would have to test it differently, maybe expose this function from the module so it can be imported in your tests? or just check if this is a call effect (so just check its type and check if it contains a function (not the function) in its stored arguments?. This was done quite some time ago :). @thezanke @nktssh the feature got released, you can check it out here. Hehe, sorry for the delay :) Gonna merge after the weekend. However if I dont, please just ping me and I will do it.. merged & released\ncc @yelouafi - code review would still be much appreciated. > > > Context property could be anything, not just plain object, so we can't safely copy it.\n\n\nofc it would be checked beforehand if it is a plain object to see if we should make a shallow copy\n\nIs this really a library responsibility? We don't shallow copy selected state and actions returned from take.\n\nGood point, however I feel like context has a higher probability of misusing the feature. With state it is not that much of a problem as there is quite strong mindset that updating the state happens via action + mutating the state breaks connect, so people in general already know that they shouldnt do this.. Hm, interesting. Its really a scary situation and compelling one at the same time to drop shallow copying. Wondering only which usage would be more often and therefore which approach would give us less footguns in the end.\nIn theory we could make 2 versions of this effect getContext and getContext.impure\nIn general im in favor of immutability and this-less programming, aint saying though that everyone should. This feature would be experimental anyway and rather an escape hatch which should noy be used in trivial cases anyway, so... i dont know which is better now as a default. You could queue those actions manually and redispatch them into saga. The workaround is really not that hard to write, it's only hard to include a builtin solution for this because your use cases might differ and require some extra setup. In the other thread I've tried to explain (maybe poorly) that the same comment applies somewhat to the part of your question. \nHelpers and your sagas are not completely different things (only that helpers are a built-in). You want to call both of them with fork effect (and helpers are wrapped by it internally for you, so you dont have to worry about it and do it manually). So only if you are wondering about difference between:\njavascript\nyield fork(saga1)\nyield fork(saga2)\nvs\njavascript\nyield [\n  fork(saga1),\n  fork(saga2)\n]\nthe same comment as above applies. Those are basically the same thing and you can chose whichever you want. \nThe interesting part is what will happen if you yield array of other things. Each of them will get run in parallel and the whole yield will be resolved only once EACH of the things in the array ends. And as you can also yield array of forks (cause... why not?) this makes it only a special case of the parallel effect (which will resolve synchronously as forks are non-blocking).. Hm, I think this is what it would take for allowing both APIs. WDYT?. it also seems reasonable to support cancel(...tasks). > remove deprecated APIs\nI think they should be kept while deprecated and dropped accordingly when the features are removed from the core\n\nHelpers (takeEvery, takeLatest, throttle) now accept up to 6 arguments. ...rest arguments removed for the sake of correctly checking last action argument. cps effect creator accepts up to 4 arguments.\n\nwont it be limiting? aint possible making those of completely variadic length?\n. @aikoven whats the status of the PR? do you know what things does it include? should I cross check against what might be missing and what potentially could be updated? or are you on master's toes? ;)\nwould like to proceed with this PR as im preparing a new release (no rush though!), if I can help in any way, just let me know. Thanks for updating the PR! Im trying to push v0.15 forward and I think I wont release anything in between. Some things ere not yet merged in, but I think their typings could be provided in this PR, so we do not have to come back to the matter latter:\n\nrunSaga refactor - basically just 1. args reordering (store interface geting in there first) 2. it accepting a generator instead of an iterator instance 3. variadic args at the end to be passed into the generator internally. That means that sagaMiddleware.run becomes just partially applied runSaga - dont know if that helps you to dedup something\nself cancellation - cancel(task) and cancel() becomes valid, but not cancel(undefined)!\nall effect - just an explicit alternative for yield [...effects]\ncontext features from #735 - so getContext, setContext effects and things like sagaMiddleware.setContext and { options: { context } } passed in upon creation - although maybe i would hold with that until the PR is more stabilized. There are some unanswered comments in the added code, maybe you could look into them?. Yeah, I would like to include all of them in v0.15 (and maybe something more, but for other things I'll keep u updated). Merged in, preparing a release. Stay tuned. ;). Hm, delaying the subscription is certainly a neat idea, only cancelation, unsubscription etc will be a little bit more trickier, shouldnt be a problem though. Gonna attemp to implement this.\n\nIn most cases such event channels gonna be created and immediately followed by a take, so it in fact doesnt really matter, as take will have its opportunity to set up, therefore subscribe and nothing will be missed as nothing can happen in the same stack.\nAs to buffering - we have those primitives already so it is reasonable to allow passing them in I think.\nFor a brief moment I thought it would be neat to propagate the item to every registered taker, but after a thought it would only cause confusion and also initial take (the one causing subscription) would be problematic.\n\nalso maybe we could implement $$observable on the middleware so put actions can be observed?\n\nWDYT about this idea?. Thanks for the PR!. There is already pending PR with typings. Could you confront how does your PR relate to the other one? Are they overlapping?\ncc @aikoven . For this use case I think you kinda overcomplicated things, IF YOU DO NOT need ability to start those requests independently from FIRST_THEN_SECOND action (by dispatching 'chunk' actions like START_FIRST), you simply could do it like this:\n```javascript\nfunction *firstThenSecond(action) {\n  const payload = yield call(firstAsync, action)\n  yield call(secondAsync, payload)\n}\nexport function someSaga() {\n  yield takeLatest(FIRST_THEN_SECOND, firstThenSecond);\n}\nI think you could misunderstood `put.resolve` it has no way to control your sagas completion. It quite simply uses `dispatch` under the hood. The whole `resolve` part means that if your `dispatch` returns a promise (for example from your custom middleware) it will wait for that promise to resolve and only then resume your saga.\n. It is completely possible, just do this:javascript\nfunction firstThenSecond(payload) {\n  yield put(startFirst(payload));\n  const payload = yield take(FINISH_FIRST)\n  yield call(secondAsync, payload);\n}\norjavascript\nfunction* firstAsync(payload){\n  try {\n    const response = yield call(API.post, payload);\n    yield put(finishFirst(response));\n    return response\n  } catch (error) {}\n}\nfunction *firstThenSecond(action) {\n  const firstTask = yield fork(firstAsync, action)\n  const payload = yield join(firstTask)\n  yield call(secondAsync, payload);\n}\n``. Yeah, sureforkedTaskmust block until a result is retrieved AND return it, so it can be returned by a saga asjoin(forkedTask)` result. \ntakeLatest is returning a task descriptor immediately. However I wouldnt ever use nesting takeLatest within takeLatest call itself. It might work, as parent takeLatest would cancel inner takeLatest on each trigger but probably if you need such construct it can be organized better in the code than using nested takeLatests. Aint sure what you mean, as its sometimes hard to discuss without seeing the code ;)\nIf you want to use takeLatest semantics though (not nested ones, just single takeLatest) its still applicable easily in the posted example code.\n```javascript\nfunction* firstAsync(payload){\n  try {\n    const response = yield call(API.post, payload);\n    // you could have here even more complex async logic\n    // just it had to be made ina blocking manner\n    // so the mentioned requirements are met\n    yield put(finishFirst(response));\n    return response\n  } catch (error) {}\n}\nfunction* secondAsync(payload){\n  try {\n    const response = yield call(API.post, payload);\n    yield put(finishSecond(response));\n  } catch (error) {}\n}\nfunction *firstThenSecond(action) {\n  const firstTask = yield fork(firstAsync, action)\n  const payload = yield join(firstTask)\n  yield call(secondAsync, payload);\n}\nexport function* someSaga() {\n  yield takeLatest(FIRST_THEN_SECOND, firstThenSecond);\n}\n``. if we land [this](https://github.com/redux-saga/redux-saga/pull/755#issuecomment-271850362) (comment aboutsagaMiddleware.runbeing just partially appliedrunSaga`) we could potentially drop duplicated tests for both APIs as those become quite the same, WDYT?. @sergej-s \nfor now you wont need to change anything, but you will get a deprecation warning when using old form of this old API\nchanges required to get rid of them:\nold API\nrunSaga(saga(arg1, arg2), {dispatch, getState, subscribe})\nnew API\nrunSaga(saga, {dispatch, getState, subscribe}, arg1, arg2)\n@yelouafi \nin the sense with my PR runSagaDynamically is becoming a partially applied runSaga, so it could be made more obvious here and partial utility could be written and used here to prefill runSaga's 2nd parameter - store interface. No intention to remove it at all, if its useful for non-redux projects (and i know it is ;) ) it shouldnt be limited to those only!. Could be done, would ease currying this for sure. I'll update this later (and merge!) with flipping args in runSaga, so that both arguments orderings are supported for a time being (old one being deprecated ofc).\nThe whole thing would also allow us to get rid of the sagaMiddleware.run / runSaga doubled tests. Probably we could drop nearly all runSaga tests, as it will be only a generalization of sagaMiddleware.run, so everything should work the same way for both of the APIs.. I've updated the PR, didnt test it properly yet though. Was wondering if maybe a test on a living project would be possible, if anyone has time for it? cc @slorber . Frow what I see you are injecting {selectedItems: [1], item:1, id:1} as const selectedItems and its an object, not an array. \nYou might have wanted to write let { selectedItems } = yield select(myselector), but then you wont be able to reference those id and item in your yield call(asynFunc, id, item).\nYou must restructure your looping and this injected/selected structure.. Im closing the issue for now, if you have any questions regarding the issuse (or any other) just answer here Im gonna receive email notification and reply. Cheers!. yeah, using race is pretty reasonable here, im only wondering whats the point of this integration here? is success utilized somewhere else?. so its basically a parallelEffect (yielding array of effects) but each effect is wrapped in a pair of { result, isError }?\nThat should be quite easily implemented on the user side. It sounds for me as too specific for being added to the lib just like that, especially when settle does not tell you much about its behaviour until you read about it.\nAlthough I think its a great ground for a discussion about:\n- custom effects - would be really cool if we support those, any ideas for the API?\n- error handling, cancellation - what do you feel is lacking and what could be done better? should behaviours be more configurable somehow?. Like @pcgilday said the proposed settle works for array of any effects. Could be achieved probably with something like this:\njavascript\nfunction* settle(effects) {\n  return effects.map(effect => function* () {\n    try {\n        return { result: yield effect }\n    } catch (err) {\n        return { err }\n    }\n  })\n}\nDidnt test it though, so keep that in mind.\nYour promise analogy is quite compelling. However still I would like to put it on hold, so we have time to take a stand on it.. I would like to have @yelouafi's opinion on this before proceeding, cant settle (:P) my mind on this firmly.. cant rly see how the proposed effect of catch or wait would work, something like this doesnt make sense to me \njavascript\nyield catch(errHandler)\nyield call(someAPIcall)\nand cannot see how would you like to structure code in other way with catch effect. in the decorator/higher-order-effect fashion? yield catch(call(someAPI))? \nthen in fact settle would become something like yield effects.map(catch). Hm, aint sure though if that would be helpful to people and also what I as a user would expect from it. Cause then we would burden users with the need to handle all 'completion'/errors types. \nOn one hand it might be useful in some rare situations, but in the most common scenarios catching errors is all what there is needed. \nWe could introduce something like catch for just error traping and catch.all for traping all completion values.. hah! we are brainstorming too fast and our posts are becoming overlapping ;) liking it! you need to come here more often :P\n\nIn fact, if we use the method version yield effect(...).catch(). We could implement it just by setting a catch: true flag on the effect, then each effect runner would handle the flag by decorating the result appropriately (like setting isError to true) and resuming the generator normally\n\nthis would require all effects to expose .catch() method. Which ofc could be easily done here, but we'd lose serialization of the effects then. I would argue that catch(effect) is the better option here, working internally just the same - setting flag on the effect. > For blocking effects, there is no need since there no way to cancel manually for example a call effect from outside. So the user is not required to check other values (eg isCancel). For take effects, it'd play the same rule as takem effect (trapping channel ends).\nimagine also yield catch(race({ someAction: take(SOME_ACTION), someTask: join(someTask) })) - with that each value needs to be checked as various things can happen and effects types can be really mixed\n\n\nthis would require all effects to expose .catch() method. Which ofc could be easily done here, but we'd lose serialization of the effects then\n\nHow so? if we create Effects based on a custom prototype (or a simple class) I think it'll be ok\n\nFor example simple objects (POJOs \ud83d\ude06) can be transferred through postMessage interface, but ofc function references cant be transferred between such contexts.\nAlso there is no .catch() on the parallel effect now (it being an array), although this argument might get outdated due to our other discussion about all/parallel effect. Oh yeah, my thought was only about when .catch being a method the effect wouldnt be able to serialize 'fully'. With cancel being a decorator no assumption gets broken and you can still cancel between contexts etc (not that I would recommend using saga interpreter leaving in a worker, but would certainly open more possibilities in such way). Also if possibly other decorators could be implemented in the future, its always easier to compose numerous functions imho, than chain all of them on the effect itself.\nThe problem with chosing catch as function name is that it is a reserved word and cannot be used as such \ud83d\ude04 but thats just the naming problem.\nYou have also proposed a wait decorator, was it just other name for catch or did you have something else in mind for this one?. Not much of a difference between those 2. You can yield iterators, and you can even yield promises. But the more standarized approach is to yield those 2 wrapped with call or fork (depending on the needs).\nAlthough if you yield fork(generator) you will get back a task descriptor which is way more easier to cancel with yield cancel(taskDescriptor) than plain iterator. Similar APIs might be introduced in the future which will be way easier to apply to the wrapper effect than on the bare metal structures like iterators. Thinking for example about proposing and implementing restart\n@scheduling\ndo you face some scheduling problem or are you just worried that they may be some there in rare cases?. Also this comment is related - https://github.com/redux-saga/redux-saga/issues/737#issuecomment-269924725\nKeep on mind that helper effects - takeLatest, takeEvery, throttle\njavascript\nimport { takeEvery } from 'redux-saga/effects'\n//...\nyield takeEvery(ACTION_A, worker)\nare completely the same thing as\njavascript\nimport { takeEvery } from 'redux-saga'\nimport { fork } from 'redux-saga/effects'\n//...\nyield fork(takeEvery, ACTION_A, worker)\nalthough the latter is deprecated at the moment.\nIm saying this only to point out that takeEvery etc in this case returns a task descriptor, cause its wrapped by a fork internally automatically for you, so what I've written there applies directly to your question  (2nd vs 3rd option)\nAs to yielding iterators directly - although possible (in the same way it is possible to directly yield a promise) it is rather advised to yield them wrapped by a call or fork (depending on the needs). It obviously creates some overhead as more stuff needs to be handled internally, but the cost is minimal and it allow you to easily injecting 'resolved' values of the effects in your tests and bunch of other things.. This thread got a little bit stale and also last comments were a littlbe bit off-topic, so I'm closing it. If you need to discuss this further, please just reply back here.. Are you using it in the node? That's really interesting. What are the use cases? Are you building express-like framework on top of this?\nIm not sure if I like it, seems like mix of various concerns. Whats the motivation for those 'local' redux stores?   \nAt least at first glance it looks to me that it is abstracting too much, feels kinda framework-y and that means the user needs to learn bunch of new semantics and conventions before he can use it, while implementing the same functionality with channels and standard redux-saga  APIs is not that complex of a task.\nEspecially this part from your example looks like a lot of convention magic\njavascript\n  // yield* this.dispatch('removeProducts') dispatches\n  //  { type: 'REMOVE_PRODUCTS' }\n  // yield* this.dispatch('productDetails', productSKU, product) dispatches\n  //  { type: 'PRODUCT_DETAILS', productSKU: productSKU, data: product }\n  static actions = {\n    removeProducts: null,\n    productDetails: [ 'productSKU', 'data' ],\n  };\nI've learned over the years and especially while working on redux-saga that the function is nearly always the best tool for the job, especially that it is easily customized and extensible if done right - even if that means slightly more code to write. This part of the designed API I might say that Im not a fan of.\nBut overally it is a really cool stuff that redux-saga became a building block for such customized solution for you. Please dont take my comments as too harsh as they were not ment to be.\nThis also reminds me that custom effects would be really cool. Aint sure however how to implement those yet in the best way. Do you feel like those could be helpful to you?\nI'll also try to look into your source code to see how things works.\nEDIT:// this might come handy for you once it lands - https://github.com/redux-saga/redux-saga/pull/735. That I was something I was going after with:\n\nshould we track sync errors and expose that information to the user?\n\nThen it would allow user to decide if he wants to restart and when.. After a thought I've decided this idea is not worth implementing in the code.\nI think @ajwhite presents some really cool API for similar problems here.\nThis retry could still get implemented, but I'd rather like to find a good API for custom effects and have it implemented in user land (as some addon or something) on top the custom effects. However there is no development at the moment considering this feature, I invite all the community to start a discussion about this, proposing the API and even implementing this feature.. I really like your idea of higher order saga with different behaviour that today that could be used by default as root sagas or even somewhere down the task tree if somebody wishes to. It also would allow preserving the current behaviour if somebody wants it.\nNot sure about API though, but I guess something neat could be figured out.. > In my large redux application we simply pool all of our disparate sagas together into the runSaga. Is there a way currently to pool together multiple root sagas?\nCould you post a shortened snippet of your code? I aint sure what exactly do you mean.. I dont think that would play well for us. Its rather easy for me to imagine a case where the saga needs to keep its state. Think for example about websocket connection. This one is a saga id like to keep alive no matter what - global for my app. But there are also route-specific trees. Hm, it kinda boils down to proper error handling all over the place, the problem is that the language is not enforcing it in anyway and people tend to get a little bit paranoid. And as redux-saga (but also react!) is the interpreter, our code is ran by a 3rd party machinery which all is done often in the same call stack etc, so any uncaught error just destroy our app entirely.\nWould be probably cool if we could create some guidelines about using fork, spawn in context of code-splitting, but also without it. The community (and me too) get often really confused about this.\nIm also wondering if there is legitimate use case for a spawn inside a route based saga, and probably there is for non-watchers, when somebody would like to persist the task even if the route changes, but then it cannot be a watcher as those probably are unwanted and there is no easy to kill it outside of the saga, which I think is kinda dangerous, but maybe unavoidable.\nHowever i feel like we should provide a way to do this. After all spawned tasks are root tasks, just like those originated from sagaMiddleware.run, but the references for those are hidden.. But even with that presence of fork/spawn will still confuse ppl :P \nThinking about cancelling spawn tasks - I think it is possible in finally blocks within if (yield cancelled()) right? Although I've always found this effect to be not elegant.. Gonna close the issue as this is a duplicate of this. Please read my comment in the other thread.\nIf you have any further questions about this, please put them in there.\n. Well, you need to figure out the best way to do it in your application. I aint sure about your requirements, but its possible to have a loaded flag which you would pass to your child component and based on that it will dispatch (or not) a FETCH_BOOK_REQUEST. Therefore you wont find you in this endless loop situation.. Would adding error.message to the log (as suggested bt @simlmx) would help a little?. I've standardized error logs a little bit in latest release. Gonna close this issue - but if you feel there is any more room to improvement (beside implementing babel plugin for better stack traces like mentioned here) please create a new issue so we can discuss this further.. You can use the custom channel approach, but I think the flush method could be still useful for some cases in the future when you know that the remembered token needs to be discarded as its outdated or whatever.\nAs to having this channel kinda globally - well if this is shared state you will always have to pass it around somehow, so I dont think its avoidable, you only can chose the approach to do so - export it, pass it downwards with each generator or maybe possibly use the context feature if it makes to the core.\nAs to your peek generator. Passing pattern is not supported when take-ing from channel. Its only possible when you take from the dispatched actions. So passing a type there wont have any effect, you can only make smth like peek(channel).\nYou could also try to implement some higher order saga like withToken, which would look smth like:\n```javascript\nfunction* takeEveryWithToken(pattern, worker, ...args) {\n    let token\nyield fork(function* () {\n    while (true) {\n        ({ token } = yield take('TOKEN_RECEIVED'))\n    }\n})\n\nreturn yield fork(function* () {\n    while (true) {\n        const ac = yield take(pattern)\n        yield fork(worker, ...args, token, ac)\n    } \n})\n\n}\n```\nAlthough it might be better to share a single channel inside this closure there, so you set up only 1 listener for pattern instead of 1 per each task started with takeEveryWithToken.\ncc @yelouafi \nthis shows that because channels and buffers are implemented using closures (which i really am fan of!) they are no possibilities for any type of extensions really. Every custom channel/buffer needs to be rebuild from scratch unfortunately. Any ideas what could be made about this? Is it worth to make something about this?. Going to close this, if you have any further questions - please just ask :)\n. Wasnt the deprecation warning telling that you should use yield and not\nyield* from now on? Cant check the source code right now, but this should\nbe the answer for your problem\nOn Mon, 16 Jan 2017 at 18:12, Jose Miguel Navarro notifications@github.com\nwrote:\n\nI have a project with a previous version where i access takeLatest from\n'redux-sga', but after update the package, i get a warning that it has been\ndeprecated. And when i import takeLatest from 'redux-saga/effects' the\nfunction is not working, it is not launching the effect qhen the action is\ndispatched\nexport function loadUser() {\n  const endpoint = '/users/current';\n  console.log(endpoint)\n  const response = yield call(Api.request, endpoint, 'GET');\n  if (!response.errors) {\n    yield put(loadUserSuccess(response));\n  } else {\n    yield put(loadUserFail(response.message));\n    yield call(logout);\n  }\n}\n...\nexport function loadUserWatcher() {\n  yield* takeLatest(LOAD_USER, loadUser);\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/769, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkmsMbn6jftF-hBqLSqMfLwARTPvPks5rS6TogaJpZM4Lkyvn\n.\n. @wanbinkimoon what error are you facing?. I suspect u are injecting async sagas on the routes and u do not cancel old watchers on route exit, so when u come back u end up with multiple active watchers. @wanbinkimoon could u share a reproduced issue on smth like codesandbox or share ur repository? I would love to help u with this. Hard to tell without full example - could you try to reproduce on codesandbox?. This part got me intrigued now:\nThe takeLatest function is triggering as many requests as I mount the component\n\nCould u elaborate on this? Do you split ur sagas and inject them async? If yes then u might have forgot to cancel corresponding watchCustody when ur component unmounts.. Unfortunately I dont know how to help you guys here as Im not using typings myself. \nThats however true that you can yield literally anything, but that special types (promises, iterators, effects etc) will get interpreted in a special way by the redux-saga. So in general yielding promises/iterators directly could be seen as anti-pattern in most cases, but its still possible and if it works for anyone - for me its fine. There are cases (especially with promises) where wrapping them in call sounds for me like a serious overhead for a simple task. But ofc its arguable and in most cases I would still recommend wrapping them in a call.\nBut thats a classic example I think why I cant convince myself for using types. In the dynamic world of JS they just seems often to be... crippling (speaking about myself!). There seems to be always that edge case they do not support gracefully, even when nothing bad is happening. Especially heard that they do not go well with currying.\nAs to this PR - I've always count on you @aikoven in regards of TS typings. So... what should be done here? :D. Closing this in favor of the other PR, thanks you @dxiao for this PR and starting a discussion!. Is it even possible to send big states to sentry?. @al-zah still its probably preferable to you to use also onError handler in the redux-saga as not all exceptions can be caught by this sentry middleware.. Well, as flow and TS typings are completely community driven in the project, I wouldnt like to include this as recommended way of doing things, as the sole purpose of this are the typings.\nUnfortunately Im not a good flower so Im not capable of fully helping you here, but I hope the flow community will step up and give some insight on this in the comments. \nFrom what I understand you try to leverage the type inference here, right? Is it possible to connect each effect's result to the yielded effect itself (which is just an object)? Could you give more examples? select seems like one of the easier ones. \nWondering if the support for this type of thing couldnt be added to the flow itself as generators are comming somewhat more mainstream.. Sorry, didnt yet time to read thoroughly your response, but I've ended somehow in this thread and Im wondering if that helps you anyhow (it might not ofc).\nAlso this thread seems to be connected with your issue, but no responses there yet.. I wouldnt like to include some special constructs into the library just for sake's of typings. Is your issue still unresolved? Should I leave this issue opened? Please let me know.. Ok, going to close issue for now. If you have any further questions, please just ask :). Thanks for this! Gonna merge right away. ;). hey, ive seen that you have pushed a new commit with description of - Merge branch 'master' into master\ndid you try to update the branch against redux-saga's master? if so, please reset your branch by 1 HEAD, rebase it on the origin's master (instead of merging it in) and push with force. Be cautious while doing this though as you might damage your branch if you make a mistake during the process.\nStill I cant guarantee that this one is going to get included in redux-saga, but Im considering it.. > My current understanding is that call only returns an instruction to redux-saga which will be called internally\nYour understanding is correct \ud83d\udc4d \n\nso how does it pass the throw to the worker saga?\n\nYour generators are returning iterators (objects with next, throw, return methods). redux-saga is calling next on those to retrieve instructions (as you have described it) and it handles those instructions for you, so if that throws somehow - for example in the catch method of the promise you have yielded (or created by running a call effect) - it simply inject that error back to your iterator by calling it.throw(err). That can be seen here. No problem. Glad it helped :). Thanks for the PR, but im wondering in what scenario this is needed?. How is it bundling modules internally? webpack? rollup? browserify? smth other?. Not exactly. Bundling with webpack or rollup replaces those with configured env vars. Please try to find out if Aurelia CLI could do the same or what other approach do they use to branch env dependent code.\nIf they wont provide any alternative I can merge your PR happily\nOut of curiosity - why did u chose redux-saga for ur project?. But is there some other standard approach for differentiating dev and prod builds then? would be nice if we can support this out of the box, instead of need for each user to configure it on his own. @forest any updates on the issue?. Could you give reference to this piece of code? Where is it used?\nIf we must go defensive, we'll do. Im only now wondering how aurelia users differentiate envs. :D. Differentiating between envs is not only made for node vs browser, but also for differentiating your dev and production builds - both targeting browser.\nAnyway - I'll look later into the PR and we gonna go full defensive, it wont hurt the project after all and it'' help you. Basically all effects are handled synchronously until async thing happens so there is no much context switching there. That means that only things like promises, take (as it set up the one time listener for action), put.resolve (but that similar to promises and only works that way if your middlewares return a promise) will block and be handled async.. @vjancik \nDo you feel that should be expressed better in the docs? would you be willing to provide a small docs PR with it?. Going to close this, if you have any further questions - please just ask :). what middlewares do you have installed into your store? which one is returning a promise?. So when you dispatch this - yield put.resolve({type: 'INIT'}); it is geting handled by redux-thunk somehow, right? And returning a promise which will resolve when some INIT data get finally to the store?\nWould be great if you create a short webpackbin example of the behaviour. Looking at the source code and everything looks fine from what I see, but with the bin we could be sure and the possible bug could be fixed (in redux-saga or in your code, Im happy to help in both situations :)). No, you dont have to handle this with thunk, but the put.resolve got into the library for better integrations with things like thunks. Why do you use put.resolve then instead of regular put? however that shouldnt affect the behaviour from what I understand.\nIf you dont do anything async in your middleware chain then your reducers should be run first and code point after the put should be in the moment of already updated state, so updated values could be retrieved via select\nWhat about the webpackbin - would you be willing to prepare one?. Its rly easy. You click somewhere on the top in the menu and type in the popup dialog what packages you would like have it to install. After a few secs they are gonna be ready for ur usage. Click Configure instead of Boilerplates and there you will have input to type under Add NPM package. First of all - put.resolve is used with no benefit - put would be exactly the same here.\nAbout your other problem - it is connected to internal scheduler of nested dispatches. We must guarantee that no dispatch is run until the one which caused it finishes. So it is intended that after INIT action you can select DIRECTLY after this action is handled by your reducers (and they are not handling it, cause they are handling only INIT_1 and INIT_2).\nIf you have any further questions please ask them, I would clarify this as much as I can.. you are facing a scheduling problem because the flow of executions is:\ndispatch(INIT)\nsome code after put(INIT)\ndispatch(INIT_1)\nsome code after put(INIT_1)\ndispatch(INIT_2)\nsome code after put(INIT_2)\nand you thought it is smth like\ndispatch(INIT)\ndispatch(INIT_1)\ndispatch(INIT_2)\nsome code after put(INIT)\nsome code after put(INIT_1)\nsome code after put(INIT_2)\nas to the solution you should use - I'll think about it some time later and present you some suitable (hopefully) solution for this problem. So is it requirement for you to buffer INIT actions? If an INIT action happens when handling of one is happening already, should it be handled too/could it be ignored/cant happen?\n\nif it should be handled too\n```javascript\nexport function *onUrlChange () {\n  yield put({type: 'INIT'})\n\nyield call(initSaga);\n  /\n  OR\n  yield take('INITIATED')\n  where yield put('INITIATED') happens at the end of your initSaga\n/\n  const state = (yield select());\n  bin.log(state);\n}\n```\n\nif it could be ignored - basically what I've done in 1. but skip takeEverySync and just do smth like takeAndBlock\n\njavascript\nfunction* takeAndBlock(pattern, saga, ...args) {\n  const task = yield fork(function* () {\n    while (true) {\n      const action = yield take(pattern)\n      yield call(saga, ...args, action)\n    }\n  })\n  return task\n}\n\nif cant happen - nothing to worry about, just use takeAndBlock as precaution. @epikhighs \nThere is not I think, but maybe you could provide a docs for it?\n\nIts all about setting some middleware like this (this is not real thunk! ive made it up now):\n```javascript\nconst thunkMiddleware = ({ dispatch }) => (next) => (action) => {\n    if (!(action instanceof Promise)) {\n        return next(action)\n    }\n    return action\n}\nexport default thunkMiddleware\n``\nas you can see if an action is not a promise we pass it down the middleware chain withnextbut if it is a promise we simple return it, so its returned to thedispatchcaller (redux-saga in our example) and it can be treated byput.resolve` in a special way - so it waits for the promise resolution. Hey, thanks for the PR. Could you provide a test for this?. Thank you for the fix!\nIm just now wondering however - how do you deal with backwards compatibility? I mean do you 'polyfill' Symbol? Fix wont work unfortunately in a fallback situation.. > If you're talking about a case in which Symbol isn't supported at the browser, or even at Node, then typeof would never return a \"symbol\" string and behavior will continue as it does today.\nHm, I guess so - if fallback policy is a plain string and not some object.. That actually would be preferable I think, and would provide a shorter code as well\ndefault   : pattern => input => typeof pattern === 'symbol' ? pattern : String(pattern). Yeah, you are right, missed that cause of the rush. Merged and thank you for your work! :). I'll try to do this in following days, just need to check if everything that got into master is ready for release.. Sorry guys that I hadnt time yet to release the new version. Im preparing it though, didnt have time in the weekend like ive hoped due to illness. . I promise to release this by the end of the week.. @alexgalin @iMoses @just4fun released v0.14.4 with this fix, sorry for such a delay, hope it helps and confirmation from you guys would be great that everything works fine as intended now. When it comes to the library's features etc it is production ready already, many use this already. \nWhen it comes to API stability - we are smoothing things up, but every API change is really minor and not done without consideration.\nThat being said we are on the best way to the v1.. You can always split your action types - if you want 'interception' just dispatch something you do not handle in the reducers and later put from the saga something you do.\nThere is no 'better' here, just 2 different approaches. I bet somebody going from saga to the thunks would probably have other opinion than you right now, but it all boils down to our habits only and what we are accustomed to.. well, if you want to categorize like that i would say that action is a contract - it is defined how based on them (that they have type) system can interact with its parts. Also if you have a convention of 1 action - 1 reducer I think it may lead to so called 'setter actions' which are rather an anti-pattern. What @slorber said about them (actions) being events is a good naming I think. They should be named kinda like events - describing what happened and potentionally carrying some payload with them and every part of the system can react (no pun intended :P) to it how it fits. Personally I dont see \"1 action many reducers\" as anti-pattern and do that quite often.. You need to be more specific, what have confused you?. Well, if that works for you its totally ok. However as @slorber have mentioned redux didnt originated exactly from MVC and it rather tries to present different approach in regards to the architecture. Such mapping as yours can probably be made in most of the architectures on some level, but I would encourage you to try to look on things in a broader spectrum.\nAt least for me it was liberating, trying to use apply MVC mental model on the redux might end up with fighting against it instead of leveraging its potential.. Im not saying that there shouldnt be such actions that have just 1 reducer corresponding to it, but making a rule of thumb of this is an anti-pattern in my opinion. I find it really convenient for more than 1 reducer to respond on some action.\nAbout the flow - most people keep their constants in separate file and use those as keys to the reducers switch (or some custom reducer creator like createReducer), so if you need to check what reducers respond to what action type it really comes down to global search on your project and seeing what files contains reference to the one you are looking for. If you have any new questions, please ask them here or open a new issue. Gonna close this one for now.. Thanks for your PR!. > Would you be against updating other snippets?\nNot at all :) Would only be good to provide reasoning behind each change with links to the places in the project it relates to, so its easier to track the change.. Thanks for contributing!. this is quite easily done with channels, so probably better keeping tasks simple. Ive never have really used server-side rendering, but from what I understand you need to render first and then close. You cannot close first, cause then your saga wont be able to take this - yield takeEvery('FETCH_USERS_REQUESTING', displayUsersListFlow) and wont make the call . Hm, aint sure how the whole thing is structured, but if you are not all-in into sagas yet I guess your server rendering issue must be solved by restructuring your code a little bit. It all boils down to the fact that you cannot close before dispatching your actions, so you need to establish the right logic for the closing in you case.. > I cant run yield call(import, './path') as that seems to fail likely due to the parser just being confused.\nIm not sure if thats the case, but proposed import is not a function (you can read more about it here), although it looks like one. So maybe it cant be passed by a reference to the saga, but aint sure 100% about this, just a thought.\nAnd if thats the case, your wrapping method is fine (rule of thumb - if it works for you, it is fine :P). Is it code-splitting for you like you expect it to?. well, you are doing this yield handleRequest(action); so it will BLOCK here until hanleRequest is done - you have yielded an iterator which is a blocking call\nif you want to make this non blocking, just do this instead - yield fork(handleRequest, action);. > Thus what I'm learning from what you said, yielding an iterator does not allow watchRequest to continue (even if handleRequest completes)\nNot at all, yielding iterator will block your saga to the moment of its completion. Your problem was that you have yielded an iterator (handleRequest) IN WHICH you make put(DONE) while watchRequest is still blocked on handleRequest and when it resumes its geting blocked on take(DONE) but it wont resume cause it has already happened.. just today @wilsaj offered his help to finish this one. and I've just released it under v0.14.7 \ud83c\udf89 . Thanks for the PR, going to merge right away. It depends how your getAddresses looks. Could you share it with us?. well, first of all - you can debounce calls by simply putting a yield call(delay, 300) at the beginning of your getAddresses, so if types.START_LOCATION_SEARCH+\"_destination\" happens quickly one after the another the task will be restarted and restarted all over again until user really stops typing so you can proceed with your autocomplete request\nsecondly - if you would like to cancel a request that has already started but you dont care about it anymore you need to attach a cancellation function as CANCEL to your request, in a similar way like here (keep in mind - it is not possible to cancel a request made with built-in fetch API). It shoukd work exactly as in your edited version. Are u sure that you are using it like that?\n. Why do you feel it is hacky? You just need to compare returned key against how you have named your effects. Still what you get will be injected in under the key you have described in\nthe race effect\nOn Sun, 29 Jan 2017 at 17:17, Moe Sattler notifications@github.com wrote:\n\n@Andarist https://github.com/Andarist not if I use IO that is not\nredux. Then I get whatever that trigger delivers.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/795#issuecomment-275924578,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkuJQVLcLqOmY2evqfgp8I6L5-tU9ks5rXLufgaJpZM4Lwz2G\n.\n. Well, you will just have undefined under the specified key. So if thats ur\nconcern you need to make smth like:\n\nconst result = yield race({ ... })\nif ('isDeclined' in result) {\n...\n} else {\n...\n}\nOn Sun, 29 Jan 2017 at 17:25, Moe Sattler notifications@github.com wrote:\n\nClosed #795 https://github.com/redux-saga/redux-saga/issues/795.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/795#event-940585332, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMks8AAvSwh3-mCC-dh-nFkC-pb5hwks5rXL2GgaJpZM4Lwz2G\n.\n. If you have any better idea how to solve this branching of logic I would be\nglad to hear you out. Was also thinking quite a lot about this in a past\nbut never thought about anything more elegant.\nOn Sun, 29 Jan 2017 at 18:20, Moe Sattler notifications@github.com wrote:\nThe underlying problem is, that it is not easy to immediately understand\nthe mechanism, especially for someone who is new to Sagas. We strive to\nkeep our code easy. We also prefer to code our documentation instead of\ndocumenting our code.\nAnd while Saga helps a lot with that, we are just not 100% happy with race\nfor our use case. It does do the job though, and a comment will explain.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/795#issuecomment-275929431,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkpUjizQtCG5NUIsgnTBd1eOpBFCZks5rXMpNgaJpZM4Lwz2G\n.\n. Not a problem, if you have any problems just ping me. Ill try to explain\nany of your concerns or answer any of your questions\nOn Sun, 29 Jan 2017 at 18:33, Moe Sattler notifications@github.com wrote:\nI am not sure, tbh. Sorry for the rather unconstructive critique. \ud83d\ude1e\nI am relatively new to sagas and try to get all the concepts myself first.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/795#issuecomment-275930534,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkggFzXDr0pVedNHJcYBdXi3Tno4Zks5rXM1mgaJpZM4Lwz2G\n.\n. Hey, did u not send content of the issue by accident or should i close this?. Hey, thanks for noticing. Could you be willing to update the recipes and create a PR with it?. Thanks for the PR!. Well, Im not really sure about what 'saga generator' are you talking about and what problem really it would solve. On the one hand you say we are not wizards and on the other hand I feel like you propose making some magical generator.\nEven React uses classes for components with different predefined lifecycle methods and (static) property names which can be implemented.\n\nFor now... from what I know there is a plan to move away from classes in React, aint sure if it succeeds, but it might. It could possibly even solve some issues (for example with hot reloading), and it is not an attempt for ditching classes just for the sake of... ditching them ;)\nFrom my point of view classes should be used really sparingly, they sneaked to JS by accident to make some comfort for more classy-based languages like Java and there is literally no single thing they actually solves for JS developers, everything they can do could be already done, so its just a sugar, but quite a dangerous one.\nI think class-based object oriented programming tempts people to couple things with each other and creates an inheritance hell. If you can avoid this, by simply not using them (unless you really know what you are doing, and you wont use inheritance), its a good way for keeping yourself constrained in a way. Which can lead you more to composition, than to inheritance, which in the end will make you a better programmer.\nOfc thats just my opinion (and many other ;) ), so dont take it for granted if you do not like it. Just my 2 cents.. I believe it was possible long time ago - just with different function: someAction.toString(). Not exactly, but I thought the same at first.\nDifference is when you need both self cancellation and cancellation from outside via cancel and you need to handle both the same in your finally block within if (yield cancelled()) condition. Simple return wont have impact on the cancelled effect. Well, exception specific logic should be done in a catch block. Or did you mean cancellation by parent's exception for example?. > Another difference is that return just terminates the main task (the currently executing generator) but in order for the whole task to finish it has to wait for all its forked child tasks to terminate. see https://redux-saga.github.io/redux-saga/docs/advanced/ForkModel.html\nwow, didnt know that difference, so many surprises yet to come for me i guess \ud83d\ude04 . Speaking about server rendering and END, could you give a comment here ? \ud83d\ude08 \n. You should communicate this with state changes. So the preferred way is to\nput action from saga, handle it in your reducers so the state changes and\nyour component gets notified about it and rerenders or call smth in your\nlifecycle hooks\nOn Tue, 31 Jan 2017 at 15:27, nda2221 notifications@github.com wrote:\n\nHi.\nHow to access to a component's method from saga? For example, I have this\nhttps://github.com/devBrian/react-native-dropdownalert DropdownAlert\ncomponent in my MainComponent. The DropdownAlert is referenced by it's ref.\nIn one of my saga's I do some async fetching, and onError I want to do\nDropdownAlert.alertWithType('error', 'Error', err).\nI was thinking to put a ref to a redux store. But it is not serializable.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/802, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMktu3RTjmwWjb_e_-vTu5IFotyeEUks5rX0TFgaJpZM4Lys6j\n.\n. Your render should be pure - so generally only return the react elements, no side effects.\n\nIm not sure what exactly you are using, but im assuming that you use react-redux, so your component would get notified about the state change and in your mapStateToProps you could set some props based on this state, so the props can be checked in some lifecycle hook - like componentDidUpdate and based on that run some callback.. That's a really interesting case - a possible bug even. In this case your effect is not handled at all and thats why its not returning anything to you, as its geting skipped. Gonna investigate this and return to you when I have some findings.. So it seems its the regenerator's bug. You can read more about it here (I've filled an issue there). call is fine fortunately ;). So it seems that it got fixed in the regenerator itself and from what I see new builds (if you download fresh node_modules) works as expected.\nGoing to close this as this was fixed by @benjamn (mad props!) with this commit. If you have any further problems, just ask. Thanks for reporting this. Open source \ud83d\udcaa . ill get into the issues and PRs in the weekend hopefully. Could you provide a timeline 'stream' of your actions? What actions happen and in what order + what you expect to happen in your sagas on each of them.. could you post exact actions which happens in your project?\nyour saga might be blocked on yield call(delay, 5000) and it wouldnt be weird if it misses the action then which the race would consume. working as expected - http://www.webpackbin.com/N1hnEHTPM\nare you sure you didnt forget to yield your array?. Should be ok, can u post a reproduced issue on smth like codesandbox?. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. I think its obsolete. Thanks for noticing. Would you like to provide a PR with removing it?. Are tests passing?. Thanks for the PR!. Yep, you are right, forgot to update the docs. Thanks for contributing!. thanks for the PR. Sure you can use sagas for this. Just take what you are interested in and call what you need ;). cc @aikoven . That's probably because your sagas crashed. You need to implement proper error handling. redux-saga is kinda the interpreter of what you yield and handle it on its terms - within the same call stack, so if there is an error somewhere it cannot recover for you to the consistent point. You need to write some try/catch occasionally. It depends what error was thrown though.\nCould you provide a code example of the described behaviour? The issue is desribed really vaguely now.. If you still need a help, please reopen this. Closing for now, as there was no activity here for over a month. Hey, I've read your issue before, but didnt have time yet to respond.\nI think you've raised legitimate concerns about that some things could be explained better in the docs. Such discussions are always welcome on our board. We strive for better!. Would you maybe be willing to create such docs section and send a PR as you have just experienced the problems and know from the first hand what troubled you the most? Would appreciate this greatly, dont have much time for improving the docs lately :/. Thanks for the update!. There should be no problem with that. Could you provide a reproduced example of the failing behaviour on something like webpackbin?. This thread got a little bit stale and it's also a duplicate of other issues, so I'm closing it. If you need to discuss this further, please just reply back here.\nI have started work on v1, gathering all things that need to be done before the release, you can track the progress here and the multicast will be part of the release.. If you still need a help, please reopen this. Closing for now, as there was no activity here for over a month. > For runSaga either we keep the api as it is (and then it should also build a multicast channel itself) or we change the API and make it take a channel as argument (or support both options). The advantage of the second is that multiple runSagas can be connected together using the same channel\nwe could offer both APIs, just wondering if its worth it, channel is simplification in this regard I think as it provide emitter like behaviour and doesnt conflict with redux subscribe (which has different API - its argument-less),\ncc @slorber does subscribe solves any problem for you? would channel API suits u?\n\nThat's right. We can rework channels spec : to support matchers we need to account of the case that we can have buffered channels AND queued takers in the same time. But I wonder if this is worth it?\n\nnot sure if I follow on this one - ideally we drop matchers, it only should be somehow internally exposed for stdChannel's takes\nI've refactored the code - but there are some open issues with it, I've put TODO comments in the code so its easier to point to the problematic parts. Will wait for your review - u can skip test refactors, but please dont skip comments put there.. In runSaga example it would act as a bus for passing ur actions into the redux-saga runtime, so in general should pretty much cover the same use case as subscribe option. Only in a slightly different way.. @ms88privat I will update documentation before the final v1 release (which might take some time :/). I've already published very much usable redux-saga@1.0.0-beta.0 if you are interested in using it.. @aikoven, this thing that its in fact string replacing later is making it hard to reason about, is the updated code better? \ud83e\udd14 \nproblem is that ive spotted now that using process alone is causing its shim to be added to the dist files :s. @forest \nunfortunately i have no idea how to configure the tooling, so you (as aurelia user) could use this and webpack/rollup users at the same time wouldnt be affected by this\na little bit more about the matter can be read here\ndo u know any other package that u use in combination with aurelia and which uses process.env variables? maybe other packages have it configured somehow better and i could look on it, but for now it becomes an open issue here :/\n. The problem is that doing it like this is causing process polyfill to be included in the dist files. We cannot afford doing this :/ \nAs @aikoven observed process.env.SOME_VAR is simply replaced (think about code as a string) in the code in webpack/rollup world. Referencing process alone on the other hand is treating it as process (node's global object) and therefore polyfilling it automatically so it wont crash in the browser. Do u know any project which uses it like this?\nOn Mon, 20 Mar 2017 at 21:21, Forest notifications@github.com wrote:\n\n@Andarist https://github.com/Andarist I understand now.\nCan you change this\nhttps://github.com/redux-saga/redux-saga/blob/master/webpack.config.dev.js#L10\nto\nPRODUCTION: JSON.stringify(false)\nand this\nhttps://github.com/redux-saga/redux-saga/blob/master/webpack.config.prod.js#L10\nto\nPRODUCTION: JSON.stringify(true)\nI think that will create a global constant that is just for your purposes\nand don't conflict with something existing.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/825#issuecomment-287885485,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkhaCfYrN2Qfmoo0q2rHv341Cu8cVks5rnt_XgaJpZM4MBHej\n.\n. I think this would require u to create such globals, which is rather a brute force approach.\n\nIs there a way to incorporate a tool such as https://github.com/hughsk/envify to you aurelia bundling process?. Im going to close this. Thought before it could be handled on our side, but now I realize that its not possible and that both webpack and rollup users actually do the same. Ive just made a PR to replace our umd build tool for rollup and I had to do the same here. Going to close this.\nSorry that it took so much time to finally establish that we cant do this here.. Besides the parts with my comments everything else looks good and is ready to merge. \nBtw thanks for squashing \u2764\ufe0f . Also it might be a good to decouple your saga from the state shape itself, im alway trying to do this, unless it would provide to copying reducers' logic in your sagas.\nYou could create a higher order saga for this, which would look something like this:\njavascript\nfunction* takeOneAndBlock(pattern, worker, ...args) {\n  const task = yield fork(function* () {\n    while (true) {\n      const action = yield take(pattern)\n      yield call(worker, ...args, action)\n    }\n  })\n  return task\n}\nand use it like this:\n```javascript\nfunction* fetchRequest() {\n  try {\n    yield put({type: 'FETCH_START'});\n    const res = yield call(api.fetch);\n    yield put({type: 'FETCH_SUCCESS'});\n  } catch (err) {\n    yield put({type: 'FETCH_FAILURE'});\n  }\n}\nyield takeOneAndBlock('FETCH_REQUEST', fetchRequest)\n```\nIn my opinion this way is far way more elegant and also its behaviour can be easily customized depending on your needs.. Well, this can really be solved in numerous ways.\n1. with passing your map into your worker by reference, so it can reset in the end (mutation making this solution not elegant)\n```javascript\nfunction customTake(pattern, worker, ...args) {\n  let currentTasks = {};\n  const task = yield fork(function () {\n    while (true) {\n      const action = yield take(pattern)\n      const { filter } = action;\n      if ( !currentTasks[filter] ) {\n        currentTasks[filter] = yield fork(worker, ...args, currentTasks, action)\n        currentTasks[filter] = null\n      }\n    }\n  })\n  return task\n}\nfunction* fetchRequest(currentTasks, action) {\n  try {\n    yield put({type: 'FETCH_START'});\n    const res = yield call(api.fetch);\n    yield put({type: 'FETCH_SUCCESS'});\n  } catch (err) {\n    yield put({type: 'FETCH_FAILURE'});\n  } finally {\n    currentTasks[action.filter] = null\n  }\n}\nyield customTake('FETCH_REQUEST', fetchRequest)\n2. inter saga communication with `put`s/`take`sjavascript\nfunction customTake(pattern, worker, ...args) {\n  let currentTasks = {};\n  const task = yield fork(function () {\n    yield takeEvery(pattern, function* () {\n      if (currentTasks[filter]) {\n        return\n      }\n      yield call(worker, ...args, action)\n    })\nyield takeEvery([FETCH_SUCCESS, FETCH_FAILURE], function* (action) {\n  currentTasks[action.filter] = null\n})\n\n})\n  return task\n}\nfunction* fetchRequest(currentTasks, action) {\n  try {\n    yield put({type: 'FETCH_START', filter: action.filter});\n    const res = yield call(api.fetch);\n    yield put({type: 'FETCH_SUCCESS', filter: action.filter});\n  } catch (err) {\n    yield put({type: 'FETCH_FAILURE', filter: action.filter});\n  }\n}\nyield customTake('FETCH_REQUEST', fetchRequest)\n3. using my previous examplejavascript\nfunction takeOneAndBlock(pattern, worker, ...args) {\n  const task = yield fork(function () {\n    while (true) {\n      const action = yield take(pattern)\n      yield call(worker, ...args, action)\n    }\n  })\n  return task\n}\nfunction* fetchRequest() {\n  try {\n    yield put({type: 'FETCH_START'});\n    const res = yield call(api.fetch);\n    yield put({type: 'FETCH_SUCCESS'});\n  } catch (err) {\n    yield put({type: 'FETCH_FAILURE'});\n  }\n}\nyield takeOneAndBlock(action => action.type === 'FETCH_REQUEST' && action.filter === 'all', fetchRequest)\nyield takeOneAndBlock(action => action.type === 'FETCH_REQUEST' && action.filter === 'active', fetchRequest)\nyield takeOneAndBlock(action => action.type === 'FETCH_REQUEST' && action.filter === 'completed', fetchRequest)\n```\nand possibly many more, just using 3 top of my head. Thanks for reporting the problem. I'll try to check whats going on.. Got hopefully fixed by @neighborhood999  . Much thanks to him!. hm, ive had the same problem, but after incorporating @neighborhood999 fix it was gone. @baldwmic did u test on repo with that fix?. as its resolved, im gonna close this. Great PR, thanks for fixing the docs! Ive commented just the smallest thing, once changed Ill merge it right away into the master.. Thanks for the PR! :) great work. According to the source code this log should happen only in dev builds. Are you sure you have correctly configured your build?. Hey, thanks for the PR, but im not sure if we should just drop all logs. Most of the logs are restricted for dev build in the source code + those which are not are only in cases of thrown error. If we drop it it might swallow some info which is easing the post mortem debugging experience.. Just do not chain .then() yourself. Do something like this:\njavascript\nlet response = yield call(restClient, ...)\nresponse = yield response.data\nyield put(...). If you still need a help, please reopen this. Closing for now, as there was no activity here for over a month. Im not sure if i grasped a problem at hand to its full extent - but wouldnt it be possible to implement such concurrent workers etc by simple combination of put + take patterns? Might be hard though if you dont know how many takers there are for the particular action.\nDo you have any possible API in mind which would allow you to create such custom workflows?. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Could you post your original code? It would be helpful in order to track it down. . If you still need a help, please reopen this. Closing for now, as there was no activity here for over a month. join is good, especially as you now can join on multiple tasks with single effect, this works if your tasks run in parallel, if they need to be called in a waterfall manner it might be good to implement a helper for this.\n. as mentioned eventChannel is probably a way to go :). Should work just fine, can you create a reproduced issue on something like webpackbin?. Thanks for the PR!. Aint sure if I got your problem correctly, but you should be able to do this easily with actionChannel:\n```javascript\nconst buf = buffers.expanding()\nconst chan = yield actionChannel(UPLOAD_FILE, buf)\nwhile (true) {\n    const file = yield take(chan)\nyield call(upload, file)\n\nif (buf.isEmpty()) {\n    yield put(UPLOAD_SUCCESSFUL)\n}\n\n}\n``.selecteffect is completely synchronous. Is wrong options object geting passed into youryield call(post, requestURL, options)?. If you useregenerator-runtimeit might twist your code a little bit, ive already once got onto this when I was really surprised that some of myconsole.log`'s were displayed out of order. \nThat's why im asking if the wrong value is geting into the call a line below.. regenerator-runtime transpiles your generators thanks to babel, if you use babel-polyfill you probably use this\nCould u create a reproduced issue on something like webpackbin?. If you still need a help, please reopen this. Closing for now, as there was no activity here for over a month. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. I've just released a new version with #888 fix, should we call this resolved and reopen if needed later? cc @wilsaj @Machiaweliczny . Closing for now, as there was no activity here for over a month. I would love to incorporate some solution for you guys, but unfortunately I have no flow (or TS) experience and I need the community to provide a solution for this.. Thanks to the great work by @Alxandr, flow-typed has now updated redux-saga typings. Closing the issue now, if there are any problems with new typings, please report them here by creating a new issue or fix them in flow-typed repository.\nIf you have any suggestions on what is the best way to incorporate typings directly into redux-saga repository - please let me know. From what I understand the biggest problem is that typings are targeting specified range of flow versions and having them directly in the repository kinda locks them down to that range and might cause problems for people using versions from outside the range.. Unfortunately not, I'm not using any typings with redux-saga at the moment. The typings were provided by @Alxandr, maybe he could give some examples.. What about call usage? Can LHS be typed nicely in relation to RHS?. @Alxandr is result's type in your loginSaga inferable from doTheActualLogin?. yes, i was running this on correct url, r u sure you have refreshed ur tab after setting up throttling? i think it might kick in only after refresh, however im not 100% sure\nwe'll try to test it one more some time later though. Sorry for not responding any time sooner, frankly I missed your reply somehow. I guess you have worked around your issue by now, but if you have any more questions or your issue stays unresolved - please just write in this thread and I will for sure get back to you this time.. Hard to tell without any code snippets. Could u show some problematic fragments?. This issue got a little bit stale, therefore Im closing it. Feel free to respond when you get to it.. thanks! . > The results of the reducers are always calculated before the saga gets activated: https://github.com/redux-saga/redux-saga/blob/master/src/internal/middleware.js#L78\nThat's true if you put sagaMiddleware last in your chain or when or whole chain is sync, but if you put some async middleware in between reducers and sagaMiddlewre then your saga will be called before new state has been computed.\nHowever that's rather unintended and I advise to put sagaMiddleware as the last one.. Thanks :)!. I think yo u can easily make such helper yourself. However I too have found this pattern to be quite common.\nDo you have any API in mind when it comes to this? I think this should be more connected to eventChannel though than what you have proposed - putEvent.. You are right, I think there is a bug, unsubscribe function should be called automatically when END gets emited. The problem is chan reference here. Its pointing on the generic channel's close from here, but it should point to the correct one which gets exposed to the outside world, so this one.\nWould you like to provide a PR to fix this? Or should I do it myself?\nThanks for noticing!. Well, basically you need to fork this repo from its main page on github. And then clone locally your version of it and create a new branch from the master. \nOnce you push your changes out you will see a possibility to make a pull request on the repository's site.\nChanges need to be made in the place I've linked in my previous comment. Would advise just to extract close function from the returning object and put it before const unsubscribe. Then just call this instead of chan.close.. You can also include in your commit's message something like \"fixes #875\", so this issue will be automatically closed when your PR gets merged in.\nAlso remember about updating the code snippet in the docs :) (the one which made you noticing this issue). This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. @frankandrobot do you have any code examples with your testing approach? Would be easier to understand your idea. So the idea of proxying in ur example is really similar to the things discussed here and here. Please look at them and judge if those ideas have merit for ur use case - we could push something similar forward soon-ish in the core.\n\nJust spoke to the team and we're open sourcing our mockStore (coming soon: https://github.com/rstudio/redux-mock-store-middleware) :-)\n\nThat's great!. We do not have sinon dependency, and probably not worth including it now.\nI would recommend to just make some let variable in the closure, so it can be set in unsubscribe. Create eventChannel, emit END there and check if that variable has changed.\nGreat PR and the finding!. Interesting case. Probably if you do emitter(END) in next tick (i.e. setTimeout(() => emitter(END), 0) it should work as unsubscribe will be defined by then. Could u try it?\nBut also its quite interesting case especially in terms of something like BehaviourSubject from rxjs.\njavascript\neventChannel((emitter) => {\n    const subscription = new Rx.BehaviorSubject('smth').subscribe(emitter); \n    emitter(END);\n    return () => subscription.unsubscribe();\n});\nthis emitter in subscribe will get called sync for the first time as BehaviourSubject is holding its last value ('smth' in this case). Its quite a circular dependency but could probably be tackled a little bit in the lib.\nJust make sure that when closing via END unsubscribe is called only if its already defined + check after returning unsubcribe if channel is closed and if it is then call immediately unsubscribe. . As to more complex time dependant scenarios I've used before such test utility - https://github.com/baldwmic/redux-saga/blob/6516de097870805aaed0d6e75c64063a69d961f5/test/sagaHelpers/throttle.js#L9 to control time passing.\nHowever here I think we could make this test independant of others and use something like\njavascript\nchan.take(input => {\n  assert.equal(...) // should be END here\n  assert.end()\n})\nthat way we do not have to hack the global clock and still the test should run till the completion just right. @baldwmic is the PR finished on ur side? should i review it again and possibly merge in? \nthanks for great work!. Looks great. Merged in. \ud83c\udf89 . From what I see this should be sufficient:\njavascript\nfunction getImageVersionsRequest(id) {\n  return http(getRequest(`/images/${id}/versions`, 'GET'));\n}\nAs to this part:\njavascript\n  // fork sagas and add to sagas\n  const sagas = [];\n  functions.forEach((saga) => sagas.push(fork(saga)));\n  yield sagas;\nInstead of iterating by forEach I would suggest just mapping over it, so it would become\njavascript\nconst sagas = functions.map(saga => fork(saga))\nalso if you want to get your task descriptors which u could cancel u need to assign them to the variable, so\njavascript\nconst tasks = yield sagas;\nand later on you can cancel them like this\njavascript\nyield tasks.map(task => cancel(task))\n. this should pretty much work\n```javascript\nconst saga = something()\nlet actual = saga.next()\nlet expected = call(emitterFn)\nconst chan = channel()\nactual = saga.next(chan).value\nexpected = take(chan)\n. smth like this should workjavascript\nexport function* watchShow () {\n    yield takeEvery(SHOW, showNotification);\n}\nfunction* showNotification({ payload: { id: notificationId } }) {\n    while (true) {\n        const { hide, interrupted } = yield race({\n            hide: call(delay, 5000),\n            interrupted: take(ac => String(ac.type) === String(interrupt) && ac.payload.id === notificationId)\n        })\n    if (hide) {\n        yield put(hide({ id: notificationId }))\n        return\n    }\n\n    const { dismissed } = yield race({\n        dismissed: take(ac => String(ac.type) === String(dismiss) && ac.payload.id === notificationId),\n        resumed: take(ac => String(ac.type) === String(resume) && ac.payload.id === notificationId)\n    })\n\n    if (dismissed) {\n        yield put(hide({ id: notificationId }))\n        return\n    }\n}\n\n}\n```. No problem, if you have any further questions, just ask.. Could u rephrase the scenario? I cannot quite understand what is the exact problem.. I believe that your constructor cannot just bail out and it needs to synchronously run till completion.\nFrom my tests on the basically similar code that you have posted it works just fine. Are you sure you have posted complete snippet that is needed for reproduction?\nWhich version of the redux-saga are u using?. Hm, if so then Im gonna close this. If you have any problems in the future, please just ask :). The behaviour is documented in the docs, but rather poorly - you can read about fork model here. It states that \"A Saga terminates only after: It terminates its own body of instructions, All attached forks are themselves terminated\".\nCalled generator (foo) is also a saga and your takeEvery uses a fork under the hood. However the behaviour is implicit.\nThe docs need to be revamped a little bit about this issue, should be explained better. Hoping somebody can chime in and improve it.. What version of redux-saga do u use?\nOn Tue, 28 Mar 2017 at 03:13, Allen Zhou notifications@github.com wrote:\n\nfrom\nhttps://redux-saga.github.io/redux-saga/docs/basics/UsingSagaHelpers.html\n// use them in parallel export default function* rootSaga() { yield\ntakeEvery('FETCH_USERS', fetchUsers) yield takeEvery('CREATE_USER',\ncreateUser) }\nThis doesn't actually use them in parallel, it will never take the\nCREATE_USER action. Am I incorrect or is the documentation wrong?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/885, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkg3tmxSGiUJr2slbmbXSgG44-raIks5rqF6zgaJpZM4MrBK4\n.\n. The change allowing this was introduced in v0.12. Please read the release note. What does it event mean for an action to be completed or not? Its just an event which gets emitted. Nothing more. \n\nWith such mindset i guess u have to have completion event. So it can be taken to resume. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. @flushentitypacket race accepts both a key-ed object and an array. Thanks!. This is PR attempting to solve this issue, however author abandoned it due to lack of time. Would you be willing to give it a shot? Not much there to finish the work. Would be happy to merge it in asap when its finished.. @wilsaj I think the best way is to:\nsh\ngit remote add pbadenski https://github.com/pbadenski/redux-saga.git\ngit fetch pbadenski\ngit checkout pbadenski/master\ngit checkout -b BRANCH_NAME\nand start from there\n. Thanks!. Hey, thanks for the contribution and starting this discussion. I need to analyze the submitted code more before commenting too much, but from what I see you have gone kinda in runtime-agnostic direction. Would be cool if custom effects could use some internal (for now) so they could have more control about the timing of effect resolution.\nCould you post example usage of something more complicated than the example in tests? Would like to see the proposed API in action\ncc @yelouafi . @yelouafi what about the idea to expose resolver (currCb or similar) to the custom effect runner and possibly some more runtime (proc's) stuff to it? it kinda overlaps with https://github.com/redux-saga/redux-saga/pull/729 though, only the approach is different (middleware chain in the other PR). This is somewhat covered with effectMiddlewares option now, so I'm going to close this.. @tugorez this has no buffer internally, but internally we have a scheduler implemented for even more complex scenarios and it is guaranteed that all of those will fire. The only problem which sometimes appear is the order and timing of those, but I would say its really marginal - you have to have complex sagas implemented and rely on timing (which can be avoided with proper code planning).\n. By yield [call(receiver), call(sender1), call(sender2)]; you start them in parallel. If SENDER1 and SENDER2 happen close to each other then your receiver might be blocked on const result = yield call(api.login, payload); so the second one will get lost and stuck forever.\nYou can do something like:\njavascript\nconst chan = yield actionChannel('RECEIVER', buffers.expanding())\nfor (;;) {\n      const { payload } = take(chan);\n      // ...\n}\nin that way no request will get lost. Yes, but they both do yield put({ type: 'RECEIVER' }) which is consumed by the same receiver at this point const { payload } = take('RECEIVER');. So if senders both put RECEIVER there is only 1 receiver to handle it and it might not be listening at the moment for new action.\nAlternatively you could wrap it with takeEvery, so it becomes:\njavascript\nfunction* receiver({ payload }) {\n    const { payload } = take('RECEIVER');\n    const { pid } = payload;\n    try {\n        const result = yield call(api.login, payload);\n        yield put({ type: pid, payload: { result  } });\n     } catch(error) {\n        yield put({ type: pid, payload: { error } });\n     }\n}\nand use it like this:\nyield [takeEvery(receiver), call(sender1), call(sender2)];. latter is using the default buffer. It really depends on what kind of stuff you are trying to achieve, but this should generally work. It depends though what you would like to happen for nextFrame and cancel cases.. JSON.stringify has literally nothing to do with DOM. \nAnyway - redux-saga is an asynchronous tool and it shouldn't block your main thread too much. It is not literally possible to 'pause' sagas when 'next animation frame is requested' in JavaScript, this is not how the language works. If you do too much work in your code and your UI starts lagging, you need to figure out how to chunk ur work in some async way. It has nothing to do with redux-saga per se, but is a general problem when programming in JavaScript.\nThis thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Whats the undesired effect of the current situation? Duplicated dependencies in the dist file?\nFrom what I understand your alias fix is allowing webpack2 to perform tree shaking and all by using es modules, right?\n. Would you like to collaborate on straightening things? Im not too proficient with bundler configurations, would be cool to work on this with somebody more experienced on the matter. We could schedule some gitter/reactiflux/other_channel time . LOL! I was searching and asking around for quite some time how to point /utils and /effects to the right directories for both types of builds\nHad no idea (and could find this info) that such simple package.jsons fixes this....\nHappy to accept a PR from you. Apart from this I'm strongly considering switching the bundler to rollup, but that might be another PR or I can make it later, just dont know when.\nBless you!. It also should fix #689 . Gonna check it out soon and merge afterwards. Thank you very much. what problem did u have with bundling saga with rollup? i didnt test it thoroughly, just that it bundles the lib just fine, also kinda trusted that some other 'big' oss projects switched to it recently and the gain in the file size is obvious. How do you make your requests? Cause the answer depends on that :). As I said - it depends on how do u do your requests. What kind of API/library are u using?. Its also worth mentioning that fetchs are non-cancellable. from what I understand its API you can make some wrapper and use it like this if you want to avoid imperative abort calls\n```javascript\nfunction* callAPI(url) {\n    const req = request.get(url)\n    req[CANCEL] = () => req.abort()\n    const result = yield req\n    return result\n}\nfunction* saga() {\n    const requestTask = yield fork(callAPI, 'http://...')\n// ...\n\nyield cancel(requestTask)\n\n}\n```. Just pass the reference to the request task there so it could be canceled, storing in the store is preventing u from serialization of the store\nYou could have also use setContext/getContext effects.. if you use such solution as above the cancelation process will know how to cancel the forked (internally by takeLatest) task. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Thats weird, ive tested it myself. Could u link to the project which\nresults in error? Which webpack do u use?\nOn Wed, 5 Apr 2017 at 22:37, realseanp notifications@github.com wrote:\n\nRegarding d3139ef\nhttps://github.com/redux-saga/redux-saga/commit/d3139efd5ffeeef901a8cb8c0f186b0efd234387\nI saw package.json was updated 3 hours ago and I just started getting the\nerror:\nUncaught TypeError: (0 , _reduxSaga2.default) is not a function\nI am using webpack.\nimport createSagaMiddleware from 'redux-saga';\nconst sagaMiddleware = createSagaMiddleware();\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/898, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkqqXai-y04JBrPNBrrmvM_gUWIWrks5rs_txgaJpZM4M0x0i\n.\n. Thanks for quick reply, you get me scared for a moment! \ud83d\ude06 . Could u share reproduced situation on some repository ready for download and debug? . Well, you create this channel by passing a socket to it as argument. That mean you can send an event through it from the outside (even in the saga). eventChannel is not bidirectional by design (maybe thats a valid use case though? cc @yelouafi) so you cannot send anything to it.\n\nBut you can emit from its inside a command, which can be interpreted by a channel consumer (which is a saga/generator and therefore can perform select effect) so it eventually could send a message through socket.. Well, each instance of the function holds different reference, you cannot compare even the simplest functions by any form of equality, unless they are truly the same (same reference). That's how it works in javascript and many other languages.\nYou need to extract this predicate function so your test can import it. Im not a TS guy, but have you tried using yield takeEvery(SEND_MESSAGE_TO_SNACKBAR, writeToSnackbar) instead of yield* there?. Webpack per se is not for compilation/transpilation, you need to plug in\nbabel with appropriate transforms (regenerator-runtime in this situation)\nand that will transpile ur generators just fine. Hope it helps\nOn Thu, 6 Apr 2017 at 21:03, Jeff Hull notifications@github.com wrote:\n\nClosed #902 https://github.com/redux-saga/redux-saga/issues/902.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/902#event-1032804031,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMktU74L4QGYHS055-QXvBs0SipC74ks5rtTbmgaJpZM4M14jP\n.\n. Did it work before? Is it some sort of regression? Or just something you have noticed now? Thanks for reporting.. If you didn't upgrade redux-saga I assume the changed behaviour is not a result of our code.\n\nMaybe @zalmoxisus could shed some light on it\n. Great that it end up with improved README, good work!. > I understand that yield passes control to the yielded iterator until no more values are returned but shouldn't yield call() do the same?\nNo, because result of the call is not an iterator, but an object (called effect). yield* cannot pass control to an object.\n\nTL;DR: What is the difference between yield  and yield call() (And if you're feeling generous, yield call()\n\nIve already covered difference between \"yield  and yield call(\", so ill focus on the latter. \"yield call()\" yields result of the call to the caller (an object which is kinda an effect description). When using redux-saga its the caller, because its the one which executes generators given to it. So when saga receives an effect (by calling iterator.next() under the hood) it checks its type and executes it for u. Thats why in tests you can just iterate over ur sagas and receive those objects (and compare them to the expected effects), but NO action, no API call etc is made. Its because you iterate outside of the redux-saga's interpreter.\n\nconst response = yield call(apiRequest, { meta: { endpoint } })\n\nThis should certainly work. Could u share ur problem on something like codesandbox.io? Ill try to help you, but I need a working/broken code to work with :)\nSIDENOTE\nit would be better to structure this like that for readability:\ndiff\nfunction* apiRequest({ meta, payload = {} }) {\n    const { endpoint, params } = meta\n    const config = endpoints[endpoint]\n    const url = formatUrl(config.url, params)\n    yield put(requestFetching(endpoint, params))\n-    let response\n-    let error\n    try {\n-      response = yield call(apiFetch, url, config.method, payload)\n+      const response = yield call(apiFetch, url, config.method, payload)\n      yield put(requestFetched(endpoint, params, response))\n+      return response\n    }\n    catch (e) {\n-      error = e\n      yield put(requestFailed(endpoint, params, e))\n+      throw e\n    }\n-    if (!error) return response\n-    throw error\n}\n. nothing easier for the redux-saga!\n```javascript\nfunction* rootWatcher() {\n    const buffer = buffers.expanding(100)\n    const chan = yield actionChannel(API_CALL, buffer)\nwhile (true) {\n    const actions = []\n\n    for (let i = 0; i < 5; i++) {\n        const action = yield take(chan)\n        actions.push(action)\n\n        if (buffer.isEmpty()) {\n            break\n        }\n    }\n\n    yield actions.map(action => call(api, action))\n}\n\n}\n```\nIve changed the code (requirements?) a little bit to show the idea and how I would try to tackle the problem first. In the code you have posted I would just slice entities to get 5, yield them mapped to calls and continue until I do them all. But another COMMIT_EXPENSIVE_API_CALLS could come in during the process and I dont know how ur state changes so I cannot predict if thats a problem or not\n. Your action is losing its serialibility. Personally I prefer them being plain objects. The question is - what do u want (ui-wise) to do after saving is complete?. If u want to bypass the store I think indeed some Promise-based solution is the best way to achieve your goal. Interesting problem nevertheless, wondering if this could be somehow tackled by us on the library level, but no ideas yet. Any thoughts @yelouafi ?. It would be possible I think to write some kind of sagaConnector HOC, which could glue ur trigger and success actions, inject appropriate handlers into ur wrapped component and effectively allow u to bypass redux's store and just 'react' directly with setState in ur component.\nShould be fairly easy to implement this in user land using context API.. Unfortunately not, it is also not a priority right now for the core team of redux-saga. I really wish somebody could pitch in and provide at least API draft, that way it would be easier to work on this for anyone.. The idea itself is ok, I'd like to enable connecting such pieces as components and sagas more tightly for some use cases, but a builtin mechanism just for this doesn't seem right - unless we figure out better API. Need to think about something more universal.. New library got released that might help some of you solving this problem - https://github.com/erikras/redux-promise-listener. I've just checked how it is behaving on the node + npm versions you have and everything is fine, although I've checked in on Mac. I've noticed though that in the npm-debug.log which you have posted it says npm ERR! npm v2.14.8, could u verify what version of npm is running the install process?\nprepublish is run with each install, but only after it completes, so there should be no conflict in the ordering of those. Could u verify that you have node_modules created with packages in it despite the error? If yes then the next step would be to verify which task is having the trouble - try to run manually npm run lint and npm run test. \nThanks for the report, cannot reproduce so far, but I hope we'll get together to the bottom of this.. It seems that I had outdated master on my local machine and I didnt realize it at first. I've reproduced ur issue and hopefully this should be fixed now. Could u pull and check?. @ahmed3eraqi we need more information about ur configuration and what step of the installation has failed, etc. If u import them from redux-saga/effects the problem will be gone.\nWondering - didnt u have deprecations warnings in the console about the\nform u have tried?\nOn Tue, 18 Apr 2017 at 20:45, Daniel Ji notifications@github.com wrote:\n\n@epikhighs commented on this pull request.\nIn docs/advanced/Concurrency.md\nhttps://github.com/redux-saga/redux-saga/pull/909#discussion_r112033517:\n\n@@ -4,11 +4,14 @@ In the basics section, we saw how to use the helper effects takeEvery and `tak\n\nIn this section we'll see how those helpers could be implemented using the low-level Effects.\n+These helpers return a forked task, which creates an attached task that will block execution of the saga that invokes the helper. If you need the helpers to create a detached task, which is what the official redux-saga's implementation of takeLatest and takeEvery does, then use spawn instead.\n+\nmy import statement is:\nimport {takeEvery, takeLatest} from 'redux-saga';\nI've had this problem on\n\"redux-saga\": \"0.14.6\",\nand\n\"redux-saga\": \"0.14.2\",\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/909#discussion_r112033517,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkl69aFwrLWkyRrnxJuviOmLOyrHWks5rxQThgaJpZM4M-NJN\n.\n. In this particular scenario fetchAll yields an array - that is a parallel effect. So the redux-saga runtime knows that it should immediately start all those 3 effects in the array in parallel and it will only continue to run fetchAll once each of them completes.\n\nUnder the hood it just stores counter of completed effects and increment it with each completion. Once it equals arr.length it can resume the fetchAll. You can see it here in the code. Could u post exact code in question? Wouldnt like to misinform u because of\nwrong misinterpretation or smth.\nOn Sun, 16 Apr 2017 at 08:17, \uc804\ud604\uc900 (Jeon Hyeon Jun) notifications@github.com\nwrote:\n\nThanks :)\nIs it same process on the 'fork fork delay(call)' example, not only [call,\ncall, call]?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/912#issuecomment-294336000,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMklMk5NSwlitT2vYvUzP5TfJGmeELks5rwbKBgaJpZM4M-NeQ\n.\n. fetchAll will:\n- start a fetchResource, 'users' task\n- start a fetchResource, 'comments' task\n- wait 1000 due to call(delay, 1000) ofc\n\nBut even after the mentioned delay it may not resolve right away after it finishes. All forked tasks need to get resolved as well. It's realised internally by a forkQueue - each forked task is geting attached to its parent.. Gonna close this, if you have any further questions - dont hesitate and ask :). redux-saga stays quite agnostic from the use case. We provide the external API for integrations other than redux - https://redux-saga.github.io/redux-saga/docs/api/index.html#external-api .\nIs this what you were looking for? Or you would like to see even bigger seperation/modularization?. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. U wont be able to receive END when using take, for that u need to use take.maybe .\nBut anyway redux-saga is going to end ur generator when END is dispatched if its blocked on regular take. There is no need to test this behaviour on application level. Its geting tested on library level already.\n. hey, the missing piece to understand the whole picture for me is how in this onEachFeature from the first post addBreadcrumb is geting dispatched, cause it isnt used in the mentioned code. Also your middleware chain setup might be crucial here.\nWould be great if you could reproduce your issue one something like webpackbin.. yielding array is fine, its instructing the saga to run each item in parallel and resolve once all of them compelted - pretty similar to Promise.all. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. I think @christopherdiehl is starting his sagas based on routes and once he comes back to the same route he starts new takeLatest(...) task. In such a scenario you need to discard a previously started/injected saga when some LOCATION_CHANGE occurs or something. @christopherdiehl could u describe how do u load sagas on route changes? Im pretty much confident that this is the case and it simply isnt geting discarded automatically for u when you leave the root.. ive seen exactly this way used by others, so its fine :). Thanks for the fix! working for me too. Wow, this night we got so many good PRs! Thanks.. redux has also tweaked their docs task. But for now let's roll with this one and see what will happen ;p. Thanks for making a PR there, was just about to do it too :) also the mentioned copying CNAME to _book  is needed I think and Ive added it on the master. \nGonna cherry-pick your CNAME as gh-pages branch is auto-generated from scratch when publishing.\n. how did u even find this link? :D I mean - is it public anywhere? we have just today asked for it to become available for us and the request is still pending - https://github.com/js-org/dns.js.org/pull/1193 . Reverted the change, I think it should be fine now. Sorry for the mess. Didnt realise it will cause this.\n@baldwmic no worries ;). @baldwmic done, i hope it will go all good this time\n@indus no worries :). @baldwmic done, i think ive found every occurance. Seems good, tests are passing \ud83c\udf89 Thank you for the contribution, great work! We'll release a new redux-saga version in a moment\nalso dont forget about @pbadenski 's initial work, great work too!. This is not an issue and the thread got a little bit stale, if you want to discuss more you can always:\n- respond under this thread - every participant will get notified\n- join gitter or discord (reactiflux) channels\nYou can also always send PRs to the addons list to share your awesome work with the community.. thanks! :). Please look at this issue - https://github.com/redux-saga/redux-saga/issues/917#issuecomment-295425909. This issue got a little bit stale and also seems to be resolved, therefore Im closing it.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Could post some more thorough usage of this? Would be easier to help if you provide a complete problem to solve.. You could maybe leverage join for this use case if you want a single result from each of those parallel tasks and you can stop your saga to wait for each completion. But again - cant advise more without more exact use case description.. Yeah, sure - I can merge in. However not a big fan of those as they tend to become outdated quite fast.. Can u pin point what is slow?. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. What's ur use case of keeping errors in the state?\nIf u need this, I'm open for a PR which would fix this issue for u. Quite the only place to change is here and possibly a test for this would be needed. Great articles, thanks for the input. Noone will blame you here for self promotion ;) Content of those is rock solid . hey @Zacqary , you have found a nice use case here and personally I love what you guys do at Datadog, great product. \nFrom what I see you basically need a multicast channel and as we do not expose such (yet) you need to make this hackery with subscribers. Am I reasoning correctly?\nIf yes then I think such API runSaga(mySaga(), { channel: multicastChannel }) would fit perfectly into your use case and would ofc be more explicit about what it actually does.\nActually I have 2 PRs open and one of them could potentially impact your proposal. \nFirst is - https://github.com/redux-saga/redux-saga/pull/755 and it switches the arguments order for runSaga API. Will merge this one today (I think), so rebasing your work later would be appreciated to reflect the changes.\nMore interesting one is this - https://github.com/redux-saga/redux-saga/pull/824 . Its not finished as I couldnt find enough time lately on refactoring this but the idea behind it is exactly what you need - multicast channel (I think). Would you like to colaborate on this one maybe? If thats something your goal aligns to. Beside making proposed API possible its goals are:\n- perf boost for sagaMiddleware.run API (one shareable stdChannel for internal usage, now each task spawns its own stdChannel)\n- exposing multicastChannel as primitive for people's usage. I've merged the other PR which adds support for this requested feature. \nThe usage will be:\n```js\nimport { stdChannel, runSaga } from 'redux-saga'\nconst channel = stdChannel()\nconst task = runSaga({\n  channel,\n  // ...\n})\n// ... \nchannel.put({ type: 'SOME_ACTION' })\n```\nSorry it took so long. This feature is not yet released though, I'm working on releasing v1, progress can be check here. Hopefully you will be able to enjoy this soon. If you are using npm5 you can try it out by specifying redux-saga's version as \"redux-saga/redux-saga#COMMIT_HASH\" - we have prepare script in our package.json, this means npm5 will be able to download redux-saga's repository contents, install our deps and build it.. Thanks!. The simplest would be this:\n```javascript\nfunction* throttle(ms, throttleChannel, task, ...args) {\n  while (true) {\n    const action = yield take(throttleChannel)\n    yield fork(task, ...args, action)\n    yield call(delay, ms)\n  }\n}\nfunction* flushPending(channel, buffer) {\n    if (buffer.isEmpty()) {\n        return\n    }\nconst action = yield take(channel)\nyield call(callAPI, action)\n\n}\nfunction* saga() {\n    const buffer = buffers.sliding(1)\n    const channel = yield actionChannel(pattern, buffer)\nyield fork(throttle, 300, channel, callAPI)\n\n// ...\nyield call(flushPending, channel, buffer)\n\n}\n```\nsome duplication involved, maybe you could abstract this somehow more nicely, but ive wanted to show the idea how this could have been approached\nother idea is maybe simpler:\n```javascript\nfunction* flushableThrottle(ms, pattern, task, ...args) {\n  const throttleChannel = yield actionChannel(pattern, buffers.sliding(1))\nwhile (true) {\n    const action = yield take(throttleChannel)\n    yield fork(task, ...args, action)\n    yield race({\n        flush: take('FLUSH_THROTTLE')\n        wait: call(delay, ms) \n    })\n  }\n}\n```. > Thanks again for your explanation of delay. Makes perfect sense, though the existence of the two methods in the first place makes less sense.\nAgreed, we probably should hide the second one to make it less confusing. We should only expose it somehow for more advanced users. Maybe through a separate package?. I think its the best solution, its simple + explicit. There are 2 ways of closing the channel:\n\none used by you, so just calling channel.close() and its intended mostly for such finally blocks like yours\nemitting special END (exported by the redux-saga) value from the subscriber function, not for use case as its for closing the channel from inside and you need to close from the outside\n\n\nThe docs however state that The parent will terminate after all launched tasks terminate so I didn't expect the finally block to be executed before the saga terminates.\n\nThe latter snippet satisfies your requirements, right? If so then everything is correct. If not - I dont exactly see how now, please describe the usage more so I can try to help :). That seems not right, cancelled is not a blocking effect. I think your second snippet in the thread post was fine, or Ive missed some requirement. \ntakeLatest will return a task descriptor to your saga so the saga can go on and I think it will immediately meet ur finally block and close the channel.. The correct approach is imgo the one mentioned here. \n\nbut I was wondering how you would do it using join?\n\nCould you give an example you have in mind?\n\nAlso, would it be possible to handle these kinds of situations within the takeLatest implementation? \n\nNot rly, you probably want to create a channel before hand and pass it to takeLatest handler - but for the takeLatest its just an argument, it can be on any position and of any type. Detecting channels would be too magical and also probably not something that everyone would like.. If the pattern solves your problem then its fine :) Dont have anything against it. Its just leveraging the redux protocol (actions) to coordinate various parts of the system, its exactly where redux shines.. Ive seen ur issue just while I was writing new release notes ;) They are available in the regular place, aint publishing anywhere else, so dont worry. Just did a release first and have started to write the new one, wasnt fast enough for you though :). No worries, there were quite some changes. Hopefully didnt screw anyone's project by releasing this. . @younesmln sure thing, nobody else has claimed this, would love a community contribution for this \u2764\ufe0f . Thanks, this looks good. They should be in rows and centered (possibly), but you already know that :) Also I think logos alone are fine, no need for names too.. @bradennapier would u like to work on a PR for that? unfortunately I dont have much time to do this atm. @vivekdwivedi do you import { all } from 'redux-saga/effects' first?. If its missing somewhere in the docs, please report the issue or send the PR with a fix. Thanks in advance ;). Ok, so I've looked into ur issue. Saga's subscribe option is not equivalent to the redux one. It was a surprise for me when I once have learnt about it too ;)\nYou can see what is passed as it in sagaMiddleware.run API here. And read more about its signature here\nWhen you subscribe to the redux store its callback wont provide any arguments to you, it only notifies you that 'something happened'. \nOn the other hand redux-saga needs dispatched actions as input to its subscribe to resolve take effects. Therefore its signature is slightly different from redux one.\nI hope this explanation shows what the problem is, if not - dont hesitate, ask more questions :). Yeah, pretty much. I would advise ubti to for the first one. Its more reasonable to use sagaMiddleware.run anyway if you connect it to the actual store.\nYou can enhance ur store so its easier to access it. Somehow like:\njavascript\nconst store = {\n  ...createStore(...),\n  runSaga: sagaMiddleware.run,\n}. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Could u create a small repo with reproduced issue? Have tried but everything works fine.. It may be obsolete and for now I'm thinking it actually is. The second identifier should easily cover the one from the upper scope. Are you sure that this error is not caused by your eslint config or smth?. Could u fork ur repo, drop its history and erase all files except simplified entry point, config etc? What version of webpack are u using?. Cant see anything wrong with the transpiled code. I've literally just have checked in Safari (it shipped native module support) this code\n```javascript\nimport { array } from './module.js'\nvar matchers = {\n  array: function array(patterns) {\n    return function (input) {\n      return patterns.some(function (p) {\n        return matcher(p)(input);\n      });\n    };\n  },\n}\n``\nand those identifiers **don't** collide. I believe there is some bug out there, just dont think its on our side. Im happy to help with identifying it, filing issues where it is neccessary and even patching this on our side, but only once we find the root cause, otherwise the issue will be forgotten and overlooked. . thisarrayidentifier infunction array(...` should be visible only from INSIDE this function (so its possible to call it recursively, its invisible from the outside.\nTry this\njavascript\nvar a = { b: function c() { console.log(c) } }\na.b() // function c() { console.log(c) }\nconsole.log(c) // Uncaught ReferenceError: c is not defined\nAlso for the time being you can use ur fork with this 'fix' and benefit from all v0.15.x goodies, instead of going back to v0.10.x. Building production build locally is OK? Only when done on the CI server? . U could try 'bisecting' (kindof) ur project to produce the minimal project setting which causes the issue.. https://github.com/ternjs/acorn/issues/527. Thanks!. Thanks! context still needs some more love, but this is a good starting point. Thanks, had to miss this during merging. . Ah, didnt notice this. Gonna update it tonight. Thanks. Fixed, but gonna release later. We should probably make this warning less excessive as it might spam your console quite a bit. Will take care of it today.. No it's not deprecated - in fact its the favored one and is in the docs - https://redux-saga.js.org/docs/api/#alleffects---parallel-effects\nyield [...effects] got deprecated. @crazy4groovy\nMaybe you have used something like yield results.map(res => put(someAction(res))) and missed that when upgrading?. I'll try to check if it's easy to pin point the root causing deprecation warnings. @DominicTobias yes. That's weird, hard to say what's the reason without having the issue reproduced.. gonna release 2morrow morning, thanks for reporting!. > Can takeLatest and actionChannel be subscribed to the same action?\nYes, although probably not the best idea imho\n\nIs there anyway to query an actionChannel for the number of items (or PEEK) at it without using yield take?\n\nno way to check numer of items, but its possible to check if there are any:\n```javascript\nconst buf = buffers.expanding()\nconst chan = yield actionChannel(ACTION_TYPE, buf)\n//...\nif (buf.isEmpty()) {\n  //...\n}\n. Probably not the best idea as you lose serialization of the store. However check out recently added `setContext`/`getContext` effects. No docs yet but you can find the valuable informations linked in [the changelog](https://github.com/redux-saga/redux-saga/releases/tag/v0.15.0).javascript\nfunction* child() {\n    const chan = yield getContext('chan')\n}\nfunction* saga() {\n    const chan = yield actionChannel(SOME_ACTION)\n    yield setContext({ chan })\n    yield fork(child)\n}\n``\nnotice no argument passing, just context sharing. hah, wanted to write go and saga comparison (especially about channels) but never have time to sit down and do it ;).delayis literally a promise wrapper oversetTimeout`, you can check it out in the source code. Nothing changed regarding it and as its usage is quite common - you are the first one to file an issue.\nCould you checl if your's environment setTimeout wasnt tampered with? Or could you reproduce your issue on something like webpackbin? Without this there is not much I can do to help you unfortunately.. Thanks!. > This code does NOT work (and I think it should):\n\n// ...\n@neurosnap what about the first one?\n\nif your action triggers update asynchronously somehow then its expected behaviour, it shouldnt be yet updated when selecting in this snippet. does any async happen between yield put({type: 'someAction'}); and const newModel = yield select(m => m);? Could u reproduce issue on something like webpackbin?\n. Going to close this issue then, if you have any other questions - just ask :). Thanks for sharing - sorry Im replying so late.\nThat actually is quite an interesting approach, it ofc isnt the best pick for everyone - snapshot testing is quite a novelty in the community and also while it automates stuff and provides useful tools - its still kinda a manual process (when tests break), so the human errors might occur and TDD doesnt apply nicely (when adding new tests) to such testing as its a post factum process.\nFrom what I see ur snapshots produce just JSON of effects - their structure is rather convoluted to be quickly human readable. I would suggest to write a custom snapshot serializer for the output.\nAs to function not being easily serrializable - thats ofc true, however we could at least work around it a little bit by serializing them to fn.name, which should give satysfying results even for anonymous functions (if assigned to an identifier - const someFunc = () => {}). > From my point of view, snapshot testing allows us to quickly cover saga testing without much effort and should probably be used in tandem with normal assertion testing.\nisnt is quite a duplication in ur tests? \n\nSerializing functions were something we struggled with and ultimately learned that Jest explicitly doesn't store the function name:\n\nyeah, but with custom snapshot serializer you can read the fn.name urself and include it in the snapshot. What version of the redux-saga do u use?. all was introduced in v0.15.0. \nIt's basically the same thing as 'parallel' effect - yield [eff, eff, eff]. However all is preferred way now to handle this as its more explicit and corresponds in naming to the Promise.all nicely.. Truth to be told, but I'll try to help the best I can.\n@cpBurn \nYou would have to show when MaintainersTypes.FETCH is dispatched. store.dispatch(END) effectively ends all sagas which are stopped on a take and well... takeLatest is using take under the hood. So if you call store.close() before you dispatch MaintainersTypes.FETCH then your takeLatest wont be able to take it\n@gajus \nFrom what I see your watchNewSearchCriteria is puting GET_MOVIES synchronously on each [SET_GEOLOCATION, SET_DATE] so call(getMovies) should run just fine as store wont be closed (yet). Am I missing something?\n. could u share ur whole setup as git repository so i can run it and debug the case?. Sorry for not responding any time sooner, frankly I missed your reply somehow. I guess you have worked around your issue by now, but if you have any more questions or your issue stays unresolved - please just write in this thread and I will for sure get back to you this time.. cc @aikoven @dcolthorp . @dizel3d such util is easily done in user land and its hard to satisfy each one's use case with 'ultimate helper', wouldnt like to put too many things in the library itself, do u think its something most people would benefit from?\nI find this similar to the bindActionCreators which I often need to drop cause I need more controlled action creators , on the other hand its useful in many situations, but thats because those bound actions are passed down as props to the component. With effects they would still have to be imported from somewhere, which kinda defeats its purpose imho. Could we maybe think about something more generic? Some helper easing effects creations, but for all types not only calls. With that I could be onboard.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Thanks for the PR and mentioning the tutorial. Totally forgot about this one.. Interesting, we could extend err somehow, wouldnt like to wrap it in { result1: err } though as people expect err to be an instance of Error.\nWould u like to propose a semantics? The best I can think off now is to add a property to the error by throwing it in with something like\njavascript\nerr.originEffect = 'key'. Ok, we'll wait for ur PR. If you have any questions about the codebase - reach me on gitter and ask :). I was thinking more about adding the second option (annotateErr) as default and for everyone. Dont think there is actually need for options (at least not yet).\nThis would allow keeping the code simpler. . good point about throwing something else than Error, we could check instanceof before assigning this prop\nas to modifying the Error - should be no biggy I think. jqXHR does not implement Promise/A+ specification, thus we won't support its non-standard behaviours.\nIf you want to benefit from this change while using jqXHR I would advise you to write a wrapper for making requests which should use this to pass the Error to the saga:\n```javascript\nfunction request(opts) {\n    var promise = $.ajax(opts)\n        .then(\n        data => data,\n        (jqXHR, textStatus, errorThrown) => {\n            // use those ^ to construct the Error\n            return new Error()\n        })\nreturn promise\n\n}\n``\nwith that approachredux-sagawill be able to handle both cases by chaining.thento the returnedpromise`. Its not really immutable way of wrapping the error - it mutates the original one, but I dont see anything wrong with that in this particular use case.\nWould like to keep this change minimal and adding options to the race is quite a big change, no other effect is configurable like that.. > It seems to me that there are effects taking more than one argument, but I take your meaning about wanting to keep things simple. Will fix.\nSure there are, I ment that there is no 'configurable' effect in such a way now. My comment was not about arguments count per se, just presence of options argument\n\nAlso, I'm trying to write a test for this functionality, but I confess I cannot for the life of me understand what the existing tests are actually doing.\n\nCould u give a link to the lines you have trouble with? I'm happy to explain everything. Sorry for a long delay with this PR, but I've decided not to proceed with this feature right now. If you want to know error's origin you can track it on your own with a simple helper.. Thanks!. Thanks!. R u using umd build from the dist directory? Gonna look into that once i get home. ReduxSaga.default is what u r looking for ;). Yeah, sure. Propose a change, always happy to improve docs. multicast is on its way, although as a primitive, didnt yet consider how to tie this to the actionChannels though. We'll try to put more work into it in the near future so I can finally release it.. @anthonychung14 if you need a multicast here - why do u need actionChannel? Cant u just take those actions? actionChannel's true power is in buffering which doesnt play nicely with multicasting (and wont be supported).. Cant u redispatch (put) it with other type?. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. @navneet-g it's available in redux-saga@beta. Thanks!. Thanks!. You shouldnt wait with dispatching END, however u need to dispatch it in the suitable moment for u which I cannot really predict - in general u should do it as soon as possible once you are sure ur sagas are created and fetching what u need.\nSo the flow should be more like this:\njavascript\nstore.dispatch(END)\nsaga.done.then(() => {\n  // rerender ur app and send it to the client\n}). > but in real-world example https://github.com/redux-saga/redux-saga/blob/master/examples/real-world/server.js store.runSaga(rootSaga).done.then resolves before dispatching END\nNot rly, notice that END is dispatched here. And it causes done promise to resolve. \nThe idea is that END will cause all ur sagas which are hanging on takes to finish. You need to structure ur app in a way that all ur initial data gets fetched during setup and no delayed takes are needed during SSR.\nCode-splitting doesnt change much in this matter. You just need to structure ur logic so it can be handled reasonably on the server side, it doesnt matter what code-splitted code will be ran if all of ur modules follow the same structure making saga SSR possible.\n. Gonna close this then, if you have any further question - just ask :). Well, if this const iv = setInterval(handleIncomingData, 1000); works it cannot be a bug on our side. Please check if your addListener works correctly.. You can quick check demo I've prepared for you - https://codesandbox.io/s/2kL8D2pYK\nEverything is working like expected in my opinion, you can fork this demo and change it so it reflects ur use case more accurately so I can help you with locating the problem.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Are u sure that u are using 0.15+? Im using all just fine. How do you import it?. That's weird, are u geting deprecation warnings while using yield [...] ? Could u share ur setup on something like codesandbox.io or a repository I could check out?. Would have to take a moment to look at the whole example as its quite long, but you can treat LOGOUT here as CANCEL_LOGIN action I think. It would be quite the same and the example would still illustrate the proper logic and how to think about structuring saga logic. Sure, gonna leave this opened as reminder to check this out. . redux-saga cannot be rewritten to async/await - that uses Promises and its way harder to coordinate 'parallel' tasks with those. It would also mean a big change in semantics, how things actually work. In example select effect is synchronous - cant achieve that with Promises. \nSaga being an interpreter of effects is granting us the full control of how and when those effects are resolved + effects are just simple object which are easily comparable and can be monitored which is also way harder with Promises.\nWhere do u see a steep learning curve with redux-saga? Could something be done to ease that? As to the syntax they both (async and generators) are pretty much the same - just using other keywords. What is done under the hood completely different, but this knowledge is not really that much needed for beginners.. @ntomallen thanks for the nice feedback, we understand the steep learning curve of redux-saga - but as said before - we just can't use anything other than generators to reach our goals, because only them are giving us the needed flexibility\nand as u have noticed, you don't even need to understand generators (although I encourage people to get deeper understanding) to get proficient with the redux-saga. Should work with yield cancel(...allTasks) or yield all(allTasks.map(task => cancel(task))). We'll try to add some docs info later.. You would have to show example code of what you are forking here.\nfork means that the task will be started in background - it doesnt mean it will live forever.. No problem.. Hi @gajus , thanks for the PR. i feel though that this should be fixed in other way than this. proposed fix is here - https://github.com/redux-saga/redux-saga/pull/945 and the the issue is here https://github.com/redux-saga/redux-saga/issues/614 . \nGenerally speaking this log should be omitted when saga is canceled via cancel effect, but it should stay when a saga gets cancelled due to error propagation.. Could u describe ur requirements? I can prepare working snippet for u with explanation how is it done. From the posted snippet something is looking off to me and I cannot quite understand what the problem is and how it should be fixed - for instance watchFetchMessages and fetchMessages both have channel but its not the same one.. could u describe in words what flow are u trying to achieve? in the second snippet here i still dont know how u pass the channel and if thats the same one or not\n. so what u have now described, could have been done like this:\n``js\nfunction createChannel() {\n    const ref = firebase.database().ref(messages/${data.channelId}`)\nconst channel = eventChannel(emit => {\n    ref.on('value', snapshot => {\n        emit(snapshot.val());\n    });\n    return () => ref.off();\n})\n\nreturn channel\n\n}\nfunction* observeSuccesses() {\n    const channel = createChannel()\nwhile (true) {\n    const messages = yield take(channel)\n    yield put(Actions.fetchMessagesSuccess(messages))\n}\n\n}\n```\nbut I feel there are some other requirements than this, as this example is quite basic. why would u like to create the same channel multiple times? it doesnt feel right in most cases, maybe ur use case should be delt with some other effects? like\n``js\nfunction fetchMessages(data) {\n    return new Promise(resolve => {\n        const ref = firebase.database().ref(messages/${data.channelId}`)\n        const cb = snapshot => {\n            ref.off('value', cb)\n            resolve(snapshot.val())\n        }\n        ref.on('value', cb)\n    })\n}\nfunction* observeSuccesses() {\n  const chan = yield actionChannel(Types.FETCH_MESSAGES_REQUEST, buffers.expanding())\nwhile(true) {\n    const {data} = yield take(chan)  \n    const messages = yield call(fetchMessages, data);\n    yield put(Actions.fetchMessagesSuccess(messages))\n  }\n}\n```\nif there are some requirements beside what ive included in this snippet - please add them so i provide more help ;). ok, so I think I know ur requirements now, you need something like this\n``js\nfunction createChannel(data) {\n    const ref = firebase.database().ref(messages/${data.channelId}`)\nconst channel = eventChannel(emit => {\n    ref.on('value', snapshot => {\n        emit(snapshot.val());\n    });\n    return () => ref.off();\n})\n\nreturn channel\n\n}\nfunction* observeSuccesses(channel) {\n    while (true) {\n        const messages = yield take(channel)\n        yield put(Actions.fetchMessagesSuccess(messages))\n    }\n}\nfunction* watchRequests() {\n    // neccessary if u need to provide cancelation logic\n    const subscriptions = {}\nwhile (true) {\n    const { data } = yield take(Types.FETCH_MESSAGES_REQUEST)\n    const channel = createChannel(data)\n    const task = yield fork(observeSuccesses, channel)\n    subscriptions[data.channelId] = [channel, task]\n}\n\n}\n``. You can just start a saga with aforkorcall` (one is non-blocking and one is blocking). You do not have an action trigger to start a saga. Hope it helps, but I'm a little bit unsure what the exact problem of yours is - could you describe it some more? You can always join our gitter channel to ask questions and have more direct chat - or you can always reach out to me on Twitter.. It's because we have started to accept multiple task in cancel effects.\nSo you can use it now like this:\njs\nyield cancel(...watchers)\nto make it work in ur original example you would have to cap ur map, its because map used liek that will pass to the cancel its all 3 iteratee arguments, so - element, index, array. And they all are being interpreted by cancel now as tasks.\nSo you can also fix ur code like this\njs\nyield watchers.map(watcher => cancel(watcher))\n// or even better in 0.15\nyield all(watchers.map(watcher => cancel(watcher))). What version of the redux-saga do u use? all was introduced in v0.15. @synchr0n123r u need to distinguish ur actions - u cannot listen in saga for action of type A and in the same listener dispatch the same type A cause it will trigger ur listener once again and so on - infinitely\nYou need to name those 2 differently or use something like:\njs\nyield takeEvery(ac => ac.type === \"MEMBER_FOLLOW_ACTION\"\n  && Object.keys(ac).length === 1, doFollow). thanks for pointing this out, we'll try to fix those asap. could u share ur configuration? os, node, npm versions etc? while something is broken in this example (app-wise) it compiles just fine on my machine and im able to run it. @Viral-Inc I literally cannot reproduce this, everything is fine on my machine. Are u able to investigate this?. Ill close this issue then, as I cannot reproduce it anyway. Hope you enjoy saga nevertheless!. Ur fetching via axios happens asynchronously, so u wont have ur state updates immediately and available in the next synchronous line after dispatching getLocations.\nIt should come though at some later point in time and ur saga will dispatch GET_LOCATION_SUCCESS, making the data available. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Thanks!. Sorry for not being more explicit @alburdette619 . How would u improve the changelog regarding this?. Thats one of the reason the API was made more explicit here, to avoid such ambiguity:). Could u elaborate? Im not sure if I understood what do u mean . @danstepanov yeah, its the culprit here, just change this to:\njs\nyield effects.all(allSagas.map(saga => effects.fork(saga))). There are for sure some other places in ur app which yield arrays. @gajus is the article available somewhere on the web? :). Fixed, thank you guys :). Its possible by splittin action in to 2. U listen for 1 in the saga (with take), use select effect, prepare ur second action and put (dispatch) it. Its an overkill though. U should be able to create the neccessary payload brfore dispatching in the first place\nAlso as thunk is rly lightweight u can mix both - thunk and saga. @jimbol what u have presented is already fairly easy and quite direct in the approach, abstraction would kill a clarity for this case here I think\nthe whole problem depends heavily on the application in place, i.e. i havent yet struggled with any problems with that - treating saga as completely external service which may listen on actions and cause side effects is working for me great so far\nwould rly need to know more about why 1 action needs sometimes trigger a saga and sometimes not, maybe they should be always split into 2 as they represent other state transitions?. What version of redux-saga do u use? Could u show simplified code of fetchTickets and the component which causes this?. is the error thrown into the saga? is it catchable? or does it only result in an error overlay in react native?. @drdaeman You are facing this issue https://github.com/redux-saga/redux-saga/issues/632\nIt's one of my top priorities to establish which behaviour is correct and to stay with it, however more I think about it I think we should fail soundly - so it will be a somewhat breaking change.. Thanks for the help, additional info will be aprpeciated.\nWhen I have time, I'm planning to wrap just few minor things up. Release last 0.x version with new features and at the same time release v1 - getting rid of deprecation warnings and minor breaking changes - this one will be one of them.\nWe'll come back to failing soundly in case of an error during put.. I have started work on v1, gathering all things that need to be done before the release, you can track the progress here.\nIn this release I will change the behaviour of put regarding the errors, it should not swallow uncaught errors.\nGoing to close this issue as it got stale and also its a duplicate of others.. Thanks!. I would greatly appreciate the PR for this as Im not familiar with flow that much. Thanks to the great work by @Alxandr, flow-typed has now updated redux-saga typings. Closing the issue now, if there are any problems with new typings, please report them here by creating a new issue or fix them in flow-typed repository.\nIf you have any suggestions on what is the best way to incorporate typings directly into redux-saga repository - please let me know. From what I understand the biggest problem is that typings are targeting specified range of flow versions and having them directly in the repository kinda locks them down to that range and might cause problems for people using versions from outside the range.. Yes, we are going to bump to v1 once i finish work on multicast channel (already in PRs). Aint sure if i understand correctly, but saga in general is pull-only. Do u have any particular pattern in mind?. Thanks!. This is because actually if u return a promise it wont get resolved automatically for u, so what u get back into ur saga is just a promise. \nPreviously (pre-v0.10) internals were scheduled using Promises, but unfortunately it didnt give us enough power to steer them, introduced some troublesome bugs regarding the reace conditions and so on and such scheduling had to be dropped. \nHow u have used the call effect with combination of the generator returning a promise worked probably quite by accident, because of the how internal promises were chained and that ur returned promise got into this chain.\nThe preffered way to resolve ur promises inside a saga is call a function returning a promise. Its because it encapsulates the promise, making it kinda lazy - wont be evaluated until saga will interpret the call effect. Problem with promises is exactly this - that they are eager, so they execute themselves immediately and u probably dont want that in testing environment etc. I would advise u to wrap those promises in a call.\nThat being said - I will consider supporting such use case as generator is a special function and we allow functions returning promises. Need to think about it though, so no promises (no pun intended ;) ).. Thanks!. Thanks!. Actually takeEvery implementation is closer to:\njs\nconst takeEvery = (pattern, saga, ...args) => fork(function*() {\n    while (true) {\n        const action = yield take(pattern)\n        yield fork(saga, ...args.concat(action))\n    }\n}). Sure, please do, would be greatly appreciated. Please check also if there are such low-level examples of throttle and takeLatest and update them too if neccessary :). I just rely on myself to publish them manually because not everything which gets to the master needs to be published asap, sometimes i merge new features etc and cannot publish updated docs for such cases. Feel free to suggest better workflow - would be great to have this automated reliably. Yeah, task is in place, just need to be ran manually. Gonna do this later tomorrow. Thanks for the PR! I will let it hang here for a moment though, as I'm thinking if the behaviour described by you in the issue should be restored.. I know it took quite some time to merge this - but thanks for your input!. could u share a repo with reproduced issue? its really hard to help with such bare description. Cannot quite run the app, have no react-native experience, had installed it to play with long time ago but didnt have really time to use it. Could u specify how should i run the project? What non node_modules stuff I need to have installed?. That a lot of setup for me for now, wont be able to check this too soon. However you should be able to debug this quite easily by setting up a breakpoint here and investigating the state of whats getting logged exactly. \nBy inspecting the code I guess there might be some problem with AsyncStorage, api or reducers. You can investigate this with console.log like this:\n```js\n// attempts to login\nexport function * login (api, action) {\n  const { username, password } = action\n  let response\ntry {\n    response = yield call(api.login, username, password)\n  } catch (err) {\n    console.log('1', err)\n  }  \nif(response.ok){\n    //set headers\n    const userData = response.data\n    const token = userData.token\ntry {\n  yield AsyncStorage.setItem('@AppLocalStorage:token', token)\n} catch (err) {\n  console.log('2', err)\n}\n\ntry {\n  yield call(api.setHeader, 'Authorization', `Bearer ${token}`)\n} catch (err) {\n  console.log('3', err)\n}\n\ntry {\n  // dispatch successful logins\n  yield put(LoginActions.loginSuccess(userData))\n} catch (err) {\n  console.log('4', err)\n}\n\n} else {\n    try {\n      // dispatch failure\n      yield put(LoginActions.loginFailure('NORMAL LOGIN FAILED wrong user data etc.'))\n    } catch (err) {\n      console.log('5', err)\n    }\n  }\n}\n. aint sure exactly if thats the problem but u probably should use for this AsyncStorage call such form:js\nyield call([AsyncStorage, 'setItem'], '@AppLocalStorage:token', token)\n``. If you still encounter the issue, please respond back. Closing at the issue got stale and you have not followed up to the last comment.. Thanks!. For starters I see that u callfetchChartDatain both cases differently. WithtakeEverythe wholeactionis getting passed into it, with ur custom approach u unpackparams` beforehand. Maybe thats the issue? As the rest seems quite fine.\nIf thats not it, please share a reproduced issue on something like codesandbox.. Getters and setters are part of ES5, which is not supported in ie8.\nWe do not plan to support such outdated browser, most modern tooling is dropping support for those, including React. If you need this to work under IE8 u probably need to setup babel transform for redux-saga which will transform to ES3 + provide a global Promise polyfill (as its used too under the hood - for a delay helper, which is superb useful so you probably want to use it).\n. U would have to share ur bundler config so i could suggest something. Have u added this transform for redux-saga which is in node_modules? Its usually ignored to speed up dev experience. oh thanks! ill definitely check this out, i would also like to create a dedicated working example for this, any ideas where I could upload files too? some restricted free hosting like site would suffice - dont want to setup example node server for this. it would probably need setup of api keys etc, this https://www.file.io/#one looks quite nice though. That would certainly be cool!. The most common pattern I guess is to keep a flag on ur resource in the state, render the component based on it and let the saga do the fetching when its needed (responding to some dispatched 'pure' action). What do u use to transpile generators? It doesnt look quite like the default regenerator-runtime. Anyway - its not redux-saga issue but rather typescript compiler thing and should be reported there.\nDead code can be found in numerous places, in nearly every big framework like react and probably angular too - there are often different code paths for prod and dev builds and its a job for tools like uglify js to get rid of this (as its unreachable).. That's a valid concern. What type of buffer would you use by default? buffers.expanding?\nThe only concern I would have is that with such mistake by mistake people could put endlessly to the channel (consuming memory) without ever taking from it (or not takig fast enough). I.e. Go language has similar channel constructs but you cannot even create (without some magic hackery ;) ) an 'infinite' buffer - that may not be though such a concern on a frontend than on a backend. WDYT?\nImplementation history\nAs to the origins of the default buffer - from what I remember it was acting like an expanding one at first, but the internal implementation was using array and was not rly efficient with all of the shifts, pops etc. Later on it was refactored internally to use a ringBuffer - which uses a 2 pointers on a fixed length array and well, as its fixed it cannot rly support infinite case, so the default of buffers.fixed(10) was chosen. However I've created a PR with expanding buffer some time later as I couldnt possibly know upfront how big channel should I have - and it, only in case of the overflow, creating a new, twice as big, buffer and copy items on it from the old one. At that moment noone looked back on the previous change of the default buffer. I've decided to default to buffers.expanding with some reasonable size in upcoming v1. Stay tuned.. @realtebo \n```js\nimport { buffers, channel } from 'redux-saga'\nconst chan = channel(buffers.expanding())\n```. Yeah. Keep in mind that the changes discussed above were made to the upcoming v1 release.. @jpetitcolas \nIts easily implemented on the user-side with implementation provided by @mpyw . I would suggest creating ur own set of saga helpers anyway, so you can add it to those and import them just like effects - just from the other module.\nThere are no plans at the moment to expand on the built-in 'helpers', as the focus is on something else and the time is rly limited. That being said - I would love to create more robust helpers library in the future.. @aikoven should it get documented or closed?. I would prefer to just close it now, people should be able to find this issue to solve their issues in the future\n@letharion ofc I would gladly accept a PR with an explanation if you can provide one :). info about it is here https://github.com/redux-saga/redux-saga#typescript. Are you sure the key_exited event happens more times? Put an additional console.log to see how many times this callback fires.. Thanks!. Is it failing though? it can be whatever u really want (undefined included, although I would suggest to use some actual value) as long as it can be equaled deeply\nby calling .next() with argument (products in this case) you effectively inject it into the saga and it resumes its execution with injected value. Well, it doesnt really need to be called with it. But if you want to have something assigned as yield's result then yes - it needs to be. I.e.. Cc @aikoven. Merging in, thanks! . Thanks!. its because u are running ur fetch via call, which only executes it, personally I would make a request saga which would include ur jwt token logic, instead of having it in ur middleware chain, but ofc u can integrate those quite easily\nthe problem with ur code is that u do not dispatch (from the saga) ur request functions, so they do not reach obviously ur middleware, you should try yield put.resolve(fetchMenu). Well, it kinda depends how do u want to structure ur sagas and how do handle ur actions, how much are they event-induced or how much they are like commands?\nIf they are commands you could have a single REQUEST type which would describe in its payload what request should be made and then you could make something like this:\n```js\nfunction* makeRequest({ payload }) {\n    const { auth } = yield select()\n// handle here ur auth.token\n// im not really sure right now from the provided snippet whats ur logic\n\ntry {\n    const constructedRequest = // ... construct a request from ur payload\n    const result = yield call(constructedRequest);\n\n    yield put({ type: REQUEST_SUCCESS, payload: result });\n} catch (e) {\n    yield put({ type: REQUEST_FAILED, e });\n}\n\n}\nyield takeEvery(REQUEST, makeRequest)\n```\nOr if you have it more signal based you can do it like this\n```js\nconst withToken = (saga, ...args) => {\n    return function* (action) {\n        const { auth } = yield select()\n        // handle ur token generic logic however u want\n        yield call(saga, ...args, token, action)\n    }\n}\nyield takeEvery(FETCH_MENU_REQUEST, withToken(handleFetchMenu))\n``\n. Well,callis a blocking effect - saga will be paused there untilconnectresolves and I guess yourActionTypes.EMPLOYEE_REQUESTmight happen before that moment, but the listenening for that action (withtakeLatest`) will start listening AFTER that moment. So - such structured code cannot work properly for your use case.\n```js\nfunction connect() {\n       const socket = io('http://localhost:8000');\n       return new Promise((resolve) => {\n           socket.on('connect', () => {\n              resolve(socket);\n          });\n      });\n }\nexport function* watchEmployee() {\n       const chan = yield actionChannel(ActionTypes.EMPLOYEE_REQUEST, buffers.sliding(1))\n       socketGlobal = yield call(connect);\n       const watcher = yield takeLatest(chan, getEmployees);\n       yield take(LOCATION_CHANGE);\n       yield cancel(watcher);\n       yield cancel(watchSocket);\n       yield call(disconnect, socketGlobal);\n }\n```. Im thinking it might be some react-native issue, are there any known timer bugs? I think Ive heard about some, but aint sure as im not into react native programming atm.\nIn general delay is just promisifying setTimeout, its a really thin wrapper - so it doesnt matter if u use 10 or 1000000 as its argument. Its just a setTimeout under the hood.\nCould you maybe try to plug in with sagaMonitor to ur middleware and log ur effects? It would help diagnosing the problem. I would only ask you to comment out unrelated sagas to keep the log clean.. So you dispatch an action like SELECT_SITE in smth like componentDidMount of the component and the data might be available right away (from the state) or asynchronously (needs to be fetched with saga)? And you are unsure how to write a selector for isPageLoading?\nIm not quite sure if Ive grasped the issue you are facing, but cant you just raise a flag on your resource in the state to indicate that its loading or not? some REQUEST_SUCCESS would just put in the store loading: false then and you would be able to query such flag synchronously in every situation I think.. I would try to think how to reorganize ur state better to normalize it, aint sure atm though whats the best approach.\nHowever even with such shape - if if component doesnt know the key it did dispatch the fetching action based on which the saga was able to construct this key - so this could be extracted and the component could query ur state with those params and not the key itself (key would be created from the parama under the hood). Could u share relevant parts of the key composition code? Would be easier to advise further.. Damn! This one is hard. Cannot think right now to restructure it with minimal effort :/ \nHowever component should be able to query the state in your example and I would think how to refactor ur state key and all to make it happen. Will give you benefits in the long run - simpler and more predictable code.. > Let's say that in a render() method of a Component, depending on some logic, I want to call an API.\nThat is rather an anti-pattern, render should stay pure function of props and state. For such things it is advised to use lifecycle methods.\n\nIs it a good use of sagas? Or is it abusing saga, to be something it shouldn't?\n\nRather the latter. The main purpose of saga is to separate ur components from the side effects of your application. Just look at the logo :) Ur state atom communicates with saga and nothing else, saga is acting as a bridge between it and the outside world.\n\ndo you have another solution, instead of copy-paste that fetchShopsAroundLocation saga to a different location?\n\nwhats ur use case? Why and where do u want to reuse it?. Sorry for not responding any time sooner, frankly I missed your reply somehow. I guess you have worked around your issue by now, but if you have any more questions or your issue stays unresolved - please just write in this thread and I will for sure get back to you this time.. ```js\nexport function* delete (action) {\n    yield call(service.deleteanitem)\n    ....\n    yield call(service.getall)\n    yield put({ type: 'getall' })\n    yield take('getall_finished')\n}\n// other saga\nconst chan = yield actionChannel('delete', buffers.expanding())\nwhile (true) {\n    const action = yield take(chan)\n    yield call(delete, action)\n}\n``.actionChannel` will gather ur actions in a buffer (simple FIFO) so you can take them later. That means you dont have to react to the actions as soon as they happen - you can wait. \nAnd later Im consuming those actions from the channel one by one. call is a blocking effect so this saga wont resume until delete saga is finished.\nTherefore no more than 1 delete saga should run at the same time. This should cover your use case (I think). takeEvery will trigger sagas immediately, so there is possibility to run multiple sagas in parallel with this\nExample above is queueing actions in a channel and only 1 saga (delete in the example) can run at a given moment.. It is queing ur action, u just bail out from the first run of ur load~ saga because of this if statement\njs\n    if(action.stopIndex < totalCount) {\n        return\nSo the while (true) loop gets unblocked as called saga gets finished.. cc @aikoven . If similar issue got fixed like mentioned, we should prefer consistency and do the same for this case too.. you could also wrap this like this:\njs\nexport const create = (someClass, ...args) => call(() => new someClass(...args))\nthat way you would be able to use create as an effect, although ofc it needs to be imported from the other place than those which are built-in\nI prefer not adding this to the core, it doesnt seem useful for everybody and its easily implementable on the user's side. That being said I would like to explore possibilities of being able to register ur own effects in the future, so stay tuned.. Thanks!. Thanks!. Actually it even cannot happen like this. Its the reducer who gets the action first and after the state is updated (or not) the saga gets notified about the action.\nWithout full working example Im afraid I cannot do much to help you. If you share a working thing on something like https://codesandbox.io/ I will gladly look at ur code.. This is not possible. takeLatest (and takeEvery and throttle) are just thin wrappers on fork effect which is non-blocking.\nThe way it works is that for a non-blocking effect your saga continues after executing it, so wrapping it like that is not possible because your saga wrapper saga will be already paused at the very end of itself - basically after try/catch block so even if we'd tried to support such thing we wouldnt be able to throw inside ur wrapper saga in such a way that it would active this try/catch.\nIf you want to dedupe ur logic I suggest to make a higher order saga such as:\njs\nconst safe = (recovery, saga, ...args) => function* (action) {\n    try {\n        yield call(saga, ...args, action)\n    } catch (err) {\n        yield call(recovery, ...args, err)\n    }   \n}\nwhich you could use like this\n```js\nfunction* saga1() {}\nfunction* saga2() {}\nfunction* wrapper() {\n  const recovery = err => console.log('caught', err)\nyield [\n    takeLatest('saga1', safe(recovery, saga1)),\n    takeLatest('saga2', safe(recovery, saga2)),\n  ];\n}\n``. Please share a reproduced issue on something like https://codesandbox.io/. I would start by giving eachSTART_NAVIGATE_TOaction a unique ID andconsole.logthis id just after thetaketo get better picture of things, also adding adebuggerinstead ofconsole.logcould show you what's the exact reason why take got triggered at all.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Could u describe your issue more thoroughly? . u cannot useyieldoutside of the theredux-saga` context (i.e. in callbacks)\nThe preferred way of dealing with this is to wrap ur connection into an eventChannel, it would look something like this:\n```js\nvar conn = new jsforce.Connection({\n    oauth2: {\n        loginUrl: salesforceconfig.OAUTH_TOKEN_URL,\n        clientId: salesforceconfig.CLIENT_ID,\n        clientSecret: salesforceconfig.CLIENT_SECRET,\n        redirectUri: salesforceconfig.REDIRECT_URI,\n    },\n});\nconst login = (conn, email, password) => eventChannel(emit => {\n    const promise = conn.login(credentials.email,credentials.password)\n    promise\n        .then(() => emit(saveOauth('success')))\n        .catch(error => emit(signUserIn(error)))\n    return () => {} // this should be some cancellation/unsubscribe function\n})\nconst loginChan = login(conn, credentials.email, credentials.password)\nconst loginResult = yield take(loginChan)\nyield put(loginResult)\nloginChan.close() // close this one time channel to free resources\n``. So theredux-sagais a runner and interpreter of ur effects (things uyieldback to it). When you yield a call effect the redux-saga is instructed to run the supplied function (getCurrentGeoPosition ` in ur example) and it inspects its return type - which can be a regular value, a promise or an iterator. Depending on that return type it makes the decision what to do.\nSo if the return's type is a Promise it simply chains to it with something like .then(result => saga.next(result)). And that's the whole magic. Your goGetCurrentGeoLocation is ofc the saga in this example.. Yeah, its general JS question, but I can answer that. resolve is a callback function which u get while constructing a Promise instance and you use it to pass a result of ur computation to the promise, so its consumers can get notified with the passed value.\nJust look at those examples:\n```js\nfunction delay(ms, value) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(value), ms)\n  })\n}\nconst promise = delay(1000, 'res')\npromise.then(result => console.log(result)) // will print string 'res'\nand to make ur example more clearjs\nfunction getCurrentGeoPosition() {\n  return new Promise(\n    resolve => {\n      navigator.geolocation.getCurrentPosition(position => resolve(position));\n    });\n}\n``. In JavaScript functions are first class citizens and they can be passed around just like any variable. So you can pass them as arguments to other functions etc. In the essence those 2:setCurrentPosition(pos => resolve(pos))andsetCurrentPosition(resolve)`\nare really the same thing, the difference is that the former creates an additional function which is unneccessary here\nTake a notice that this pos => resolve(pos) is also a function, just like what is contained in resolve. The difference is that one is already in a reference (resolve) and one is put as kinda literal, just in place.. Exactly  \ud83c\udf89 !. No problem. Im glad I could help.. I promise to take a look at it as soon as possible, just having tons of work on my plate right now and unfortunately redux-saga gets a little bit neglected in the process :/. https://github.com/redux-saga/redux-saga/commit/f4b52b04eb6bb9094ab07661c98178b55b401a85\nGonna do a release in a moment. \n@neurosnap thanks for the PR, I've analyzed the issue and havent found much merit in keeping this log altogether. Dunno why it was added in the first place \u00af\\(\u30c4)/\u00af so I've just removed it. Hope you dont mind closing this PR.. I dont get quite why UPDATE_USER_FB has to unsubscribe the listener, shouldnt it just update the user isntead of removing the old one and inserting a new one (when it gets subscribed to it again)?. If this solution works for you, its perfectly fine to use. Personally I would think a little if maybe whole firebase can be wrapped in a single channel so probably it would be easier to maintain the logic. \nAlso subscribeUser and listen sagas seem to be overly complicated by the separation of them. You could keep both logics in 1 saga and use something like race to steer taking from the channel and unsubscribing it, that would also allow you to get rid of 'global' subscriptions, but as with everything - it's only matter of personal flavour.. Sure it is, you just need to establish other trigger than component's lifecycle.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Could u propse exact API that you have in mind? Also please read this discussion to see about different approaches that were implemented previously and had some serious flaws we were trying to get rid off.. I dont see the real benefit of doing this now, by being more explicit we force users to compose this behaviour on their stores however they want and its only a few lines of code anyway. I would prefer users being more conscious about this and enhance their stores only when really needed (for the ease of usage).\nIt could also potentially mess with people's TS/flow types.\nAlso benefit of saga being a middleware is also an ability to put it into whatever position in the middleware chain you like, although it being 'last' is preferable and the easiest to maintain in the long run. \nIm still open for a discussion about this though, maybe others will have something interesting to add, but personally I think its more flexible the way it is now. In example the problem with @wtgtybhertgeghgtwtg implementation is that by monkey-patching dispatch it will now not be possible to implement a gate keeper middleware checking users permission levels in a way that the 'blocked' action would be skipped and would not hit the sagas.. > How else would they want to do it? It's just boilerplate that amounts to the same thing.\n1 line of code (store.runSaga = sagaMiddleware.run;) hardly can be called as boilerplate imho.\ngatekeeper example\nIn the simplest scenario its possible and fine, but most of the times people use middlewares to hook into dispatch as it was literally their design goal. By spreading this responsibility between middlewares and enhancers we lose ordering flexibility, cause they cannot intermit each other.. After some thinking I havent found enough compelling arguments to change the way how the redux-saga is used at the moment, we might revisit this in the future.. Thanks!. Why the 2 -> two change?. Thanks!. No you are not, no tests are written for this. It's a test utility and nothing really worthwhile to test there.\nHowever feel free to add extra tests for this. The best one would be really not checking its API but more if it serves its purpose - so I guess injecting this as a result of fork/spawn. i guess example usage could be the test for this. Thanks!. Thanks! :) you are on \ud83d\udd25 !. It's because you have lost the this context. Try any of this:\njs\nyield call([response, response.json])\nyield apply(response, response.json)\nyield call([response, 'json']). Could u share a reproduced issue on something like https://codesandbox.io/ ?. Should work just fine as takeLatest (and takeEvery) are implemented using regular take which ofc accepts a channel as argument. \ndocs + tests\nNoted. Would love to get some help on this * wink *. @erikvold \nyield takeLatest(channel); - this probably is not working because u have not passed in any generator, u need to provide a saga handler for this takeLatest\n. well, it probably be even takeAndForkLatest or smth :D \n\nI was expected it to be a blocking effect when used with a channel.\n\nHow did you want to use it (code-wise)?\n\n@Andarist\u00a0I updated my example, how should it be changed based on your comment?\n\nI think you might find this useful:\njs\nconst channel = yield actionChannel(TYPE, buffers.sliding(1));\n// ...\nconst action = yield take(channel);\nthrottle helper is implemented under the hood using those. \nIf you share what outcome are you reaching for (requirements) I might be able to advise more :). @Amareis both - takeEvery and takeLatest - work fine with channel. @erikvold had concerns about the naming of those, because from the names he has expected different behaviour.\nYou can check out equivalent implementations of those helpers in the docs. Even though they mention only pattern as argument, its passed down to normal take which ofc can be used without problems with channels.\nThis issue got a little bit stale, so I'm closing it. If you both have any questions, remarks, whatever - just write here or open a new one, I will always get back to you.. Unfortunately it's not documented well enough, but you can do something like\njs\nlet eff = it.next() // actionChannel effect\nconst mockChannel = channel()\nit.next(mockChannel) // inject mockChannel back (it will become left value of the assignment in ur saga)\nIt also depends on what test exactly you would like to write, so more details would be appreciated.. This should go like this:\n```js\n    let chan = actionChannel(pattern);\n    assert.deepEqual(\n      gen.next().value,\n      chan\n    );\nconst mockChannel = channel()\n\nassert.deepEqual(\n  gen.next(mockChannel).value,\n  take(mockChannel)\n);\n\n. @erikvold its exported from the main entry pointjs\nimport { channel } from 'redux-saga'\n```. @erikvold Do you feel that there is still something lacking from the docs? Please specify, so we can work on it :) Your input in past few days was really great! Appreciate it a lot.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Thanks!. Thanks!. This would be great, although Im personally more familiar with CircleCI. Solution ofc doesnt matter, its the continous checks that matter.\nHadnt time to setup this, but for sure will try to do this. I want to release v1 some in the near (cough) future, as we've reached stability long time ago already. This would pair really nicely with that. \nAlso incorporating bundlesize check would be cool.. @camflan yeah, this one is not working, it only indicates that we really need the CI :P \nThanks for the PR!. Thanks you guys for the great work. \ud83d\udc4f. Thanks you both!. @zyml @aikoven this PR introduced a failing test (the one testing types definitions), could any of u u check this?. Could u elaborate?. Thanks!. I think this should be possible to be built on sagaMonitor.\n@bradennapier could u create an issue thread with the description of the problem and proposed solution?. Yeah, monitoring options would be really cool - integrated in some kind of redux-saga-devtools. But those are rather plans for the future.. You can check whats getting checked against call's result here. \nIt shouldnt be mistaken for promise as it would incline result to have then method. That is not the case. I was worried that it was mistaken for iterator (because of the next method), but we check not only for next but also for throw method.\nFrom my perspective it should work, could u prepare a quick demo on something like https://codesandbox.io/ so I could debug this? Would greatly appreciate it.. Sorry for not responding any sooner. I don't know how, but I've missed your reply. \nUnfortunately due to JavaScript limitations, present conventions etc it seems the best option for us to detect if something is 'thenable' to classify it as a promise. Symbols are also not yet that mainstream and even native promises do not expose any promise-relate promise.\nI guess you have resolved your issue by now, but I advise anyhow not to use .then method on your classes, because many other libraries would also think it is a promise and that could lead to some nasty bugs.\nIf you have any other questions, please just ask in this thread or create a new one.. Under the hood they are both the same, yield [...effects] will result in a deprecation warning though and inform you about all.\nThis was introduced to make parallel behaviour explicit and it nicely mirrows Promise.all. Thanks for the PR, great work :). @aikoven I'm preparing (slowly \ud83d\ude09) v1. Could you revisit this matter? Unfortunately I'm not able to make any decision regarding this and I trust you with TS related stuff here :). I've created a milestone where I gather all issues I would like to have resolved before releasing v1.\nAnyway - I do not intend to make any major breaking changes, just some minor tweaks, internal changes and dropping previously deprecated features. \nBut v1 is also a commitment to not make any breaking changes in it and ofc it looks nice :P. And when it comes to requestReviews - you need to write a separate test for this as in the one you have provided takeEvery wont execute any task, its just an information for you that such takeEvery has occured when executing watchRequestReviews.. Thanks!. Wow, thanks ! :). What version of the redux-saga do you use?. Oh, I see what u meant! I think buffers.sliding(1) is exactly what you need. :) . Going to close this one as it seems not relevant anymore, please ping me here if you feel it needs reopening though.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Thanks :). Yeah, that's certainly the problem which bite some people in the past as like you have noticed - checking equality wont do us much here.\nPackaging it as some kind of 'effect' - like your proposed array+type - would obscure the API in my feeling.\nIn most cases effects are effects because its the redux-saga interpreter that knows how to interpret and execute them. It also allows effects being pure - no action will be executed (no async calls etc) until it gets interpreted and executed.\nWith buffers the story is simple - they are primitive objects which does not create any side effects and return synchronously, so packaging them as effect would be quite odd I think.\nThat being said - I recognize the problem, just aint sure whats the best way to deal with it.\nAs workaround you can do something like this:\n```js\n// saga.js\nconst chan = yield actionChannel('ACTION', yield buffers.dropping(1))\n// test.js\nimport { is } from 'redux-saga/utils'\nlet gen = saga()\nassert.ok(is.buffer(gen.next().value))\nconst mockBuffer = buffers.dropping(1)\nlet chan = actionChannel('ACTION', mockBuffer)\nassert.deepEqual(gen.next(mockBuffer).value, chan)\n```. The problem is much broader here as you wont be able to test anything that contain local references to functions. This would only help with testing the buffers. \nAlso you can actually test those as effects by changing to yield call(buffers.dropping, 1). No extra effect required.. @erikvold also it should be possible to reimplement buffers to classes (bummer ;P also a breaking change :s) so their methods could be shared on the prototype and therefore make it possible to deep equal them. Thanks! Gonna merge in but if you have any more ideas how the overall issue could be improved please open an issue for discussion.. The snippet you have provided wont cancel the worker. It will listen for both actions and return immediately from the invoked worker for the LOCATION_CHANGE, but the worker will be still much alive and will keep listenening for your DO_SOMETHING.\nTry this:\njs\nfunction* watcher() {\n    const task = yield takeLatest(DO_SOMETHING, worker);\n    yield take(LOCATION_CHANGE);\n    yield cancel(task);\n}. Hm, I guess then ur solution will work fine. When LOCATION_CHANGE happens it will just cancel the worker in progress, but wont proceed with worker's logic and just return.. I guess you dispatch some kind of FETCH_DATA in componentDidMount hooks or something. If that's the case it's not possible to make this in fewer steps.\nYou could restructure your logic though, I guess if B is going to render is determined on some pure logic - which you could extract and use in a saga to load both data for A and data for B (when data for A becomes available) and only then dispatch some DATA_FETCHED action to take down the spinner/loading component and render both A and B in one go.. u probably need to install regenerator-runtime and add import 'regenerator-runtime/runtime' at the top of ur entry point. It was certainly not intentional, however our source code uses single quotes, so the docs should be changed to use those where inconsistent. Would you like to provide an opposite of this PR? :). This should work, could u share a reproduced issue on something like codesandbox.io?. Oh, didnt spotted that there was no implicit return situation there. Good catch @neurosnap !. I would go with the simplest solution - put a fetching/loading state in your store and just consult that state before making a request, so a duplicate will know to skip it.. make both those components dispatch some FETCH_USER action and in the saga\n```js\nfunction* fetchUser({ id }) {\n  const isLoading = yield select(state => Boolean(state.users.byIds[id] && state.users.byIds[id].loading))\n  if (isLoading) {\n    return\n  }\n  const user = yield call(api.fetchUser, id)\n  yield put({ type: USER_FETCHED, user })\n}\nyield takeEvery(FETCH_USER, fetchUser)\n``. @idangozlan You can put a cancel action from one saga/watcher and take it from another (to decide about cancellation). So its possible - just there is no some magic way to do it :) Everything stays explicit. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. Thanks for the PR, but actually I would prefer to keepcheck` as lint+test. I prefer explicit naming and it has always felt weird to put linting inside a test task as those are separate activities in my opinion.. Thanks :). You are right, it seems incomplete in regards of tests. Example alone is working fine though - or have you experienced any issues with it too?. @djskinner do u still have any unanswered questions? or did the example's code clarified all the things for you?. cc @aikoven . Thanks!. @stevenmusumeche included typings are community-driven, so they always need some time to catch up after releasing features etc.\nHowever this one was already merged in some time ago, gonna release new version with it right now. :). should already be released, please check if everything is working fine . @stevenmusumeche could u check why is it happening? does your ./node_modules/redux-saga/utils.d.ts contain cloneableGenerator at the bottom of the file?. @Rokt33r could u check why it might be broken? When I install redux-saga and inspect utils.d.ts contents I can see it has cloneableGenerator definition. Closing this then :). Thanks.. Thank you guys, ive added the deprecation warning for the overloaded put.sync and merged this in :). @Rokt33r could u check (and possibly fix) whats happening with this https://github.com/redux-saga/redux-saga/issues/1096 ? would love to release both at once. @Rokt33r gonna prepare a release later today. @Rokt33r published :)\nbut also do not be afraid of using ur own fork for a while, you can include other version of the library in your package.json instead of the version published to npm. Thanks!. @flyjennyetn \nyou need to add a global module of regenerator-runtime. Please install this package and add this to ur top entry file\njs\nimport 'regenerator-runtime/runtime'. Please add the import only in the index.js, its providing a global regeneratorRuntime object. Do not add this import in each of the saga files.. @flyjennyetn that is completely weird, could u share ur setup as a repository i could quickly run and debug this?. @flyjennyetn How can I run it properly? when I make\nreact-native run-ios\nit runs index.ios.js which is only some starter project and I see that what i should ran is in app/index.js - however aint sure how to run this properly.. For some reason this is whats get generated in your saga modules:\n```js\nvar _marked = [coursesQuery, watchCourses, _callee].map(regeneratorRuntime.mark);\nvar regeneratorRuntime = require(43                   ); // 43 = regenerator-runtime\n``\nSo by the lineregeneratorRuntime.markis called its still not defined. You could apply some hackery on thebabel-preset-react-native, but its probably not worth it. You should try to report the issue in react-native's repository. For some reason their [custom transform](https://github.com/facebook/react-native/blob/6555f9bee865af03a4db09beb9216b8b61e182b8/babel-preset/transforms/transform-regenerator-runtime-insertion.js) doesnt play nicely with standardregenerator-transform(which they include to transform generators syntax).. @flyjennyetn its certainly not aredux-saga` issue. Aint 100% sure if its react-native's issue, or some combination of packages, but I would start from raising issue on their repository to keep ball rolling.\nIf you want a temporary solution until it gets resolved, you would have to drop babel-preset-react-native, use other preset, or just list of the plugins they recommend with the react-native. It seems there is nothing specific for the react-native development here. If you decide to go this road - if you want to ensure redux-saga to work:\n- include babel-plugin-transform-regenerator\n- put `import 'regenerator-runtime/runtime'; at the top of your entry file and ONLY there, no need to include it per saga module. Did it help?. @mammosu's solution works, but it fixes the symptoms and not the underlaying issue.\nAs far as I know this is an issue of babel-preset-react-native and it got fixed in one of more recent releases.. hey @vivekdwivedi !\nYou have put quite a lot of text here, I dont have time right now to analyze the whole thing. From the really quick scan Ive noticed that u have a problem with accessing action params while reimplementing takeEvery as a while loop.\nThis can be done like this:\n```js\nexport function* getChartDataForReportSaga(params) {\n  try {\n    const result = yield call(Api.getChartDataForReport, params.params.chartid, params.params.date, params.params.dimensionFilters, params.params.compare, params.params.dimension, params.params.extraDimension);\n    yield [\n      put({ type: types.CHART_DATA_FOR_REPORT_SUCCESS, data: result.data.response.data, chartId: result.data.response.cid }),\n    ];\n  } catch (error) {\n    yield put({ type: types.CHART_DATA_FOR_REPORT_FAILURE, error });\n  }\n}\nfunction* watchGetChartDataInReport() {\n  while (true) {\n    const { params } = yield take(types.CHART_DATA_FOR_REPORT_REQUEST);\n    yield race({\n      task: call(getChartDataForReportSaga, params),\n      // u dont have to put LOCATION_CHANGE here,\n      // cancellation will propagate downwards from the injectedSaga\n      cancel: take([types.APPLY_DATE_FILTER, types.APPLY_DIMENSION_FILTER]),\n    });\n  }\n}\nfunction* injectedSaga() {\n  const watcher = yield fork(watchGetChartDataInReport);\n  yield take(LOCATION_CHANGE);\n  yield cancel(watcher);\n}\n```\nIf that doesnt help, please report back and Im gonna read through ur problem thoroughly later and help you more.. Thanks. Thanks :). Thanks! I honestly owe you a beer or something \ud83d\ude04 . It seems that besides generating favicon it doesnt take much work - https://github.com/reactjs/redux/commit/3c900de44f1410fd2508401536b6e634e013e048. @r3dcrosse that would be super nice of you, thanks for the help offering :). Thanks! Great work.. Thanks for reaching out. Im afraid that described expected behaviour just isnt possible in javascript (without hackery on setInterval - which we wont do).\nYou setInterval just runs in completely different execution context and redux-saga has no knowledge nor power over it.\nI would suggest you to wrap your setInterval code in a try/catch and emit(END) from the catch block.. > @Andarist\u00a0Is that something specific to\u00a0setInterval(), or are you saying that's just the nature of any async source of events (like, say, an Observable)? \nYeah, though with observables it would be possible to implement if you'd returned observable from the eventChannel factory, but then it wouldnt be possible to auto-unsubscribe when calling chan.close().\n\nSo there's no way to have the saga handle errors which originate in the channel?\n\nAs what happens in the eventChannel is async AND outside of the redux-saga control flow - its not possible to catch those errors on our side. Catching call's errors (like when making a request to API) is possible only because the actual execution of the call is handed to the redux-saga and it can hook up into i.e. promise error handling so it can throw the caught error back to you.. Thanks. Thanks!. Thanks! :) . Could u share ur relevant code on something like codesandbox.io ? Also whats ur use case? Why do u need to know if doTheThing has completed? Cant u yield put({type: 'DO_THE_THING_COMPLETED'})?. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. @dagen-niger it literally just refers to the next section in the docs - https://redux-saga.js.org/docs/advanced/ComposingSagas.html :). you can implement this easily in the user land with something like this:\njs\nconst waterfall = (sagas, ...args) => fork(function* () {\n    let result\n    for (let i = 0; i < sagas.length; i++) {\n        result = yield call(sagas[i], ...args, result)\n    }\n    return result\n}). It would have to use the same for loop :trollface: you just wouldnt see it in ur code. At the moment I dont think there is real need for more built-in effects, what would be interesting though is to find a way to create ur own effects more integrated with the internal runtime.. Nice work! Ive commented on the few things in your repo.. Nope ;). makes sense :) maybe we should consider using files entry in package.json instead of .npmignore?. @danners Ive thought about this a little bit and made a poll on twitter about .npmignore vs files and according to the results (and my personal thoughts on the subject too) we should switch to using files entry in package.json. Would u like to prepare a PR for this or should I just push this issue forward on my own?\nCheers and thanks for bringing this up!. In the redux-saga world it would look something like this\n```js\nfunction* fetchStudentId(id) {\n    // this is an effect for getState\n    const studentData = yield select(state => ...)\n    const options = {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(studentData),\n        mode: 'cors'\n    }\nconst json = yield call(fetch, 'https://url/to/the/student', options)\n\n// this while loop is for fetchSudentDetails\n// could be extracted to other saga\nwhile (true) {\n    const studentDetails = yield call(fetch, 'https://url/to/the/student/details')\n\n    if (studentDetails.details.name !== \"NONE\") {\n        yield call(delay, FETCH_OFFER_DELAY)\n        continue\n    }\n\n    yield put(setStudentDetails(studentDetails.details.success))\n}\n\n// return some useful data, probably not whats inside json now\nreturn json\n\n}\nfunction* watchFetchUsers () {\n    // take listens for dispatched action of the given .type\n    const action = yield take(FETCH_TEN_STUDENTS) \n    // we map ids to call effects, all effects is similar to the Promise.all\n    // calls are blocking so this saga wont resume until those calls are finished\n    const results = yield all(action.payload.ids.map(id => call(fetchStudentId, id)))\n    // put is an effect for dispatching\n    yield put({ type: STUDENTS_FETCHED, payload: { results } })\n}\n```. This is literally only an implementation id, you should be able to adjust my code to your needs with ease - ive only created it quickly to show you how this could be achieved in a saga world. Besides supplying other arguments to those generators it meets all of your requirements.. > yield all(action.payload.ids.map(id => call(fetchStudentId, id))) will this wait for all the 10 async calls to be completely finised?\nYes, it should. As mentioned call is a blocking effect so nothing will resume in the yielding generator until it finishes.\n\nif one call fails from 10 calls, what kind of status I will be getting from yield all call. As I need to revert the processs if any one f the async calls get failed?\n\nWell, that part you need to figure out on your own - you need to implement a failing strategy on top of my proposed code, as it depends on ur needs - but its easy to do whatever u want:\n- retry failed\n- fail whole operation\n- just swallow errors\nIf you implement things correctly you can use regular try/catch blocks on any level of the code you want, ie:\n```js\ntry {\n  const studentDetails = yield call(fetch, 'https://url/to/the/student/details')\n  return studentDetails\n} catch (err) {\n  // handle err\n}\n``\nSo you can decide whats more appropriate for your use case - handle it downstream (directly where the fetch happens) or upstream (where theall(...calls)effect happen).. No problem, feel free to ask any questions :). Have u importedallfromredux-saga/effects?. @thinhtrh Not with what you have pasted in here in regards ofall`. Are those all of your sagas?\nOFFTOPIC\nconst data = yield call(AddProductAPI(action.name, action.id, action.category, action.price))\nwould be better as \nconst data = yield call(AddProductAPI, action.name, action.id, action.category, action.price)\n. I'll look into how I could expose origin of the deprecation better, but you should be able quite easily track down the origin by setting up a breakpoint on the warning line and looking into the stack trace.. @Minishlink it's quite intended at the moment.\nArray is still interpreted as parallel effect (with deprecation warning). Interpreting effects is a little bit 'recursive' process, in theory you can yield nested effect combinators (race, all). So the runtime tries to run each effect contained in all - and you are passing an empty array there as effect to be interpreted, so the runtime recognises it as nested parallel effect. This will change in the future.. This thread got a little bit stale, so I'm closing it. If you need to discuss this further, please just reply back here.. What @seanyu4296 said :)\nGenerators are kinda pauseable functions, so putting while (true) in them doesnt mean blocking infinite loop (if the body of the while contains yield ofc), but rather some kind of infinite task - in your case that saga wont ever stop listening for NAVIGATE action.. END closes internal stdChannel so no other signals than END can be 'taken' from the moment it gets dispatched (like you have noticed).\nYou might want to try restructure your code (cannot give any real advice here without having deeper knowledge about your codebase) in a way that articlesSaga would became independent of the FETCH_ARTICLES_SUCCESS.\nYou might also consider using channels for inter saga communication. I think this would allow you to bypass the stdChannel restriction.. @klis87 aint sure how ur code is structured, but using 2 async sources of actions - axios middleware and sagas - might cause u some headaches like that. They both ofc work just fine together, but sometimes integration in trickier cases (like SSR) might be harder.. You can leverage the context feature (which is not documented unfortunately atm). You can use setContext to store ur reference and getContext to retrieve it (by using the same key) from any children saga - no matter how deep in the tree.. It really depends what solution do u use for routing.. The easiest way would probably be to just integrate with react-router-redux like shown here and to yield put(push('/route')).. According to their README its as easy as:\nimport { push } from 'react-router-redux'. Please recheck as it ur repo works for me.\nI've confirmed that this yield put(push('/route')) dispatches such action:\njs\n{\n  type: \"@@router/CALL_HISTORY_METHOD\",\n  payload: {\n    method: \"push\",\n    args: [\"/person\"]\n  }\n}\nand I got redirected to the page with such content:\n<div>person page</div>. Oh, you need to figure out how exactly react-router-redux works. On the saga part there is nothing more to be done, dispatching redirecting action (push) is working - it just needs to be interpreted correctly (and acted upon) on the router's side. Maybe reach out to the reactiflux community for help and guidance. Unfortunately Ive never used this router and I dont have time at the moment to learn about its APIs more :(. According to their README It should be possible to store.dispatch(push('/foo')) (at least in v4). If it works for you - its a good pattern for you.\nPersonally I dont see quite any gain from this particular abstraction. I think most people dont realise what effects really are - they are just objects, so really this can be simplified to:\n```js\nconst watches = [\n  takeEvery(ActionTypes.ADD_LESSON, addLesson),\n  takeLatest(ActionTypes.SET_CURRENT_LESSON, setCurrentLesson),\n  takeEvery(ActionTypes.SET_USER, setUser),\n];\nexport default function* rootSaga() {\n  const allWatches = [\n    ...watches,\n    ...imagesWatches,\n    ...loggerWatches,\n    initialise(),\n  ]\nyield all(allWatches);\n}\n``` . Glad I could help :). I aint sure which one is not working properly from ur description. Could u be more specific and maybe reproduce the issue on something like codesandbox.io ? This would ensure that I could quickly help you.\nThose should be irrelevant for the mentioned code, but I would still advise u to refactor this:\n```diff\n// expenses.js\n-export function* watchGetUserExpenses() {\n-  yield takeEvery(actionTypes.REQUEST, getUserExpenses)\n-}\n+ export const watchGetUserExpenses = takeEvery(actionTypes.REQUEST, getUserExpenses)\n// index.js \nexport default function* rootSaga() {\n  yield all([\n-    watchAuthenticate(),\n+    fork(watchAuthenticate)\n-    watchGetUserExpenses()\n+    watchGetUserExpenses\n  ])\n}\n. Forgot to specify the identifier for the exported watcher, should be:js\nexport const watchGetUserExpenses = takeEvery(actionTypes.REQUEST, getUserExpenses)\n```\nCould u share ur code somehow? Cannot do much without debugging ur issue properly.\n. You need to reorder ReactDOM.render and sagaMiddleware.run calls.\nYou are dispatching this action planilha_reembolso/expenses/REQUEST in componentWillMount when sagas were not yet started so listener for ur action type was not yet registered - because of this you miss the first dispatched set of actions.. > Should I use fork on every watcher I am declaring?\nIt depends on the requirements and what behaviour do you want to achieve. Read carefully docs about blocking vs non-blocking effects, fork model (all of ur sagas create a tree of tasks, with spawn u can create a 'detached' task from that tree) and also understand how cancellation (downwards) and error (upwards) propagate through that tree. That's what you should understand to pick tools for the job correctly - dont be scared though, those topics are really simple.\nAlso while yielding iterators (and promises) work - yielding wrapping effects (fork, spawn, call) is preferred. \n\nCan you explain me why this refactor its better than my old solution?\n\nNot rly much better, but ur solution have created an extra layer of the generator in between with no actual benefit from it. Let me illustrate with an example with regular functions:\njs\nvar fn = () => console.log('smth')\nsetTimeout(() => fn(), 1000) // unnecessary function layer\nsetTimeout(fn, 1000) // slightly 'better' equivalent. Thanks! :). Could u post your saga code?. What response do u get from the server when redirect happens?\n. Its basic HTTP - you cannot make such redirect for the user automatically. You should return some error type from this request (instead of html) and do the redirect yourself in javascript.. Thanks!. It sounds like a wrongly configured router / components and is not connected to redux-saga specifically by any means. If you share a reproduced issue on a repository to clone, I might look into it briefly. If not I'll have to close the issue here.. Yeah. Nothing strange about this snippet.\nPlease share a reproduced issue on something like codesandbox.io . I'll try to help then with finding a solution. This issue got a little bit stale, therefore Im closing it. Feel free to respond when you get to it.. You can hook up to sagaMonitor or try out redux-saga-devtools.. Im considering adding safe to the redux-saga, which would allow you to do:\njs\nconst results = yield all(someArr.map(\n    someVal => safe(apply(someService, someService.someMethod, [someVal]))\n));\nand receive some kind of pair/tuple of result and error to unpack for urself. So in your example results would become an array of such pairs/tuples.\nYou can use it even today though, by implementing safe yourself:\njs\ncosnt safeCall = (worker, ...args) => call(function* () {\n    try {\n        const res = yield call(worker, ...args)\n        return { res }\n    } catch (err) {\n        return { err }\n    }\n})\nand use it like this:\njs\nconst results = yield all(someArr.map(\n    someVal => safeCall([someService, 'someMethod'], someVal)\n));. I would start debugging from checking this:\njs\nfunction fetchData () {\n  console.log('fetch data')\n  return fetch(${config.base}dashboard_charts.json).then(res => {\n    console.log('res', res)\n    return res\n  }).then(response => (\n    (response.status === 200) ? response.json() : Promise.reject('logon')\n  ));\n}. > Only console.log('fetch data') is found. Does it mean there is problem with fetch ob Android?\nIt seems so. Please file an issue on their repository.\n\nThanks a lot\n\nNo problem :). Fetch returns a promise and thats probably what u have seen by console logging it. Problem is that it doesnt seem to resolve (hence no then/catch is called). yield fork(() => call(fn)) case need to be checked further. But I suspect its as simple as - returned value gets passed to the interpreter.\nIm still a little bit unsure if it should get interpreted. On one hand its just a \"yielded\" value with a {done: true}, OTOH its a little bit magical and might be unexpected, its quite implicit behaviour.\nI.e. for of loops ignore the \"done\" values, but i.e. Promises auto-flatten themselves when chained (also not sure if that behaviour is good on Promises). somewhat related https://github.com/TheNavigateur/proposal-pipeline-operator-for-function-composition/issues/3. Just don't use any of those, those effects are not intended to be used like that.. I would vote on ignoring \"done\" values and passing them \"as is\" to the caller - flattening returned values being not automatic leads to more flexibility. As mentioned adding yield is no big deal and if we return such effects to the callers new patterns might emerge - its up to the caller to run (yield) the effect and it might not be instantaneous so one could implement some kind of \"merging\" strategies, similar to concatMap/mergeMap/exhaustMap/switchMap from stream's world.. Actually we should check if something can be done in createTaskIterator to prevent  yield fork(() => call(fn)) from running. Also why yield fork(takeEvery, 'pattern', fn) is getting flattened and thus executed too.\nBoth are rather low priority though.. @lega0208 everything you have described sounds OK, you are not using any weird patterns.\nThis issue is solely about weird code like yield fork(() => call(someSaga)), yield fork(call, someSaga) and similar. They currently work purely by accident, they don't make much sense and will be \"forbidden\" in the future in a sense that those \"inner\" effects wont get executed. . Don't ever be afraid of contributing back to OSS. Most of the project maintainers are really helpful in reviewing and explaining the internals.. Fixed by #1573. Thanks! I've missed that :). How redux-saga should determine if the action is critical or not?. Im afraid it could potentially lead to memory problems if implemented naively also it still doesn't determine good enough if the handleCategoryFetch was important for SSR or not - I think the same applies for any other actions and without any type of hints (with magic annotations or some kind of helper function which you could use to mark sagas as important) is effectively not possible to determine that. And such solutions are rather brittle, hard to maintain and would have to be manually applied to the source code - it doesn't seem compelling enough to implement anything like this, when you can just write tests for your SSR process and catch the potential problems way better.\nI categorize this request as not possible to implement (unfortunately, I would certainly like to guard you from potential mistakes) and therefore I'm closing this issue. Feel free to comment back though.. It is derivative of the design and how generators work. takeEvery is a non-blocking effect. This means that it will return to  your generator a task descriptor as soon as possible and yielding generator will continue its execution. \nBecause its kinda last statement in your generator it reaches its end and executes code in the finally block. \nTherefore if you want to keep using takeEvery there you need to introduce some blocking effect (thats while inlined while loop worked).\nThe best I can think of is to:\ndiff\nfunction* manageSocket()\n{\n  try {\n    var wsChannel = yield call(subscribeWebSocket, eventChannel, eventHandlers);\n    var task = yield takeEvery(wsChannel, function*(action) {\n      yield put(action);\n    });\n+   yield join(task)  \n  }\n  finally {\n    wsChannel.close();\n    console.log('wsChannel closed');\n  }\n}. > f the above assumptions are correct, then what do you think about writing a wrapper/creator function that assemble these things together? Like a setupSocket function that accepts a created channel, the body inside try block and the body inside finally block so that people won't bother with hand write the fixed structure, also won't make any mistake? Oh and I mean this wrapper will be written in my project, I don't think this should go into redux-saga.\nIf this works for you - go ahead! :) \n\nOr, option 2, any chance the design of channel could get some modification? The goal is to make writing channel codes more easily (or more free), e.g. people could choose to use while (true) or takeEvery without the burden to make the try block blocking. I'm not sure if this is possible, but I think if it's possible and reasonable, this could go into redux-saga.\n\nAint really sure if thats possible. I prefer exposing more primitive/building blocks which you can use to built upon more fine-grained solutions. Including such behaviour in the core library would only limit use cases or we would have to make this configurable which is also a maintenance burden.\nGoing to close this issue, as it seems solved. Feel free to comment more if you want to. I dont miss any answers in any threads here ;). @qpre \nTry this :)\ndiff\n    yield race({\n-      error: yield take(\"INSERT_FAILED\"),\n+      error: take(\"INSERT_FAILED\"),\n-      success: yield take(\"INSERT_SUCCEEDED\"),\n+      success: take(\"INSERT_SUCCEEDED\"),\n    });. @meadch sorry that I have not yet handled this one, Im at the moment overwhelmed with day and OSS work, please know that your effort is really appreciated - docs PRs are the best \u2764\ufe0f, but I need to find time to review this with a clear mind.. Issue is solved, therefore going to close this thread. If you have any other questions, please just open a new issue or comment in here :)\n@sgal thanks for answering. You can check done property of the resulting object when dataTypeName is empty to check if the iterator has finished.. No problem with adding another article, they are always welcome. I would argue however that instead of calling window.ga directly (window.ga('track', 'CreateTodo');) it would be more preferable to wrap it in a call effect.\nAlso im not sure why analytics-sagas.js calls sagaMiddleware.run twice and exports sagas in the same time. I think those might be some artifacts and it would be good to clean them up.. Merging in then :). Thanks! :). No worries. Glad you have figured this out. You can even make this shorter and skip additional layer for sagas.\n```js\nfunction* requestSuggestSaga(action) {\n  const payload = action.payload;\n  const result = yield call(api.getSearch, payload.keyword);\n}\nexport default function* () {\n  yield throttle(100, action.REQUEST, requestSuggestSaga);\n}\n. It is expected, its just how javascript works and there is nothing we can do about here, we provide a special way of using `call` for this use case though. You can do this:js\nconst res = yield call(fetch, 'some-url')\nconst json = yield call([res, 'json']) // or yield call([res, res.json])\n``. @eranimo could u post example snippet that u are trying to use?. I believe this issue is about something else. requestAnimationFrame would be best wrapped in an eventChannel in the saga, from the eventChannel creator u should return an unsubscribe function so it can be called automatically when u call .close on the returned channel (in finally block of ur saga). This thread got a little bit stale, so Im closing it. Feel free to respond back later or create a new issue.. Theactionparameter is injected to urcheckoutautomatically if you use it with combination oftakeEvery,takeLatest,throttle`.\nIf you run checkout manually in ur testing environment you must provide action parameter on ur own.\n```js\nimport test from 'tape'\ntest('sagas:checkout', t => {\n  const action = {type: 'checkout', id: '244242.244324', xxx: 'whatever'}\n  const generator = checkout(action)\n  t.deepEqual(\n    generator.next().value,\n    select(selector.shop),\n    'must be select .....'\n  )\n}\n``. Thanks!. Thanks!. I've managed to reduce it to the simpler case - https://codesandbox.io/s/qlj85r1479. Im working on releasing v1. Part of that is [rewritten internal stdChannel](https://github.com/redux-saga/redux-saga/pull/824), so it becomes a multicast. It solves this bug and some others. I've written [failing test](https://github.com/redux-saga/redux-saga/pull/824/commits/8bc7a378fabb26d50e92c4f6ca40ef867ca953ca) for the bug described in this issue and merged it into the mentioned stdChannel PR to confirm that. Therefore I'm closing this issue now, you can watch progress on v1 [here](https://github.com/redux-saga/redux-saga/milestone/1). I don't have much time to work on this, so however slow the progress is it is steady at the moment, so I hope you won't have to wait too long for the release.. Thanks!. Thanks. Oh, sorry i havent noticed that this is forgh-pagesbranch. This one is generated automatically from the scratch when we rundocs:publish` script - so this should not be a target of any PRs.. Thanks.. It's already working ;) https://github.com/redux-saga/redux-saga/blob/master/test/proc/parallel.js#L125-L130\nAlso documented in the API docs here. Ur code seems to be fine. Did you check if u receive more than 1 items from the firebase? I would advice u to start from putting a simple console.log in the insert function. Im not entirely sure why this happens - but I have a really strong guess ;)\nUr inserts happen really fast (in the same synchronous call stack). put effect while non-blocking it might be a little bit delayed for internal scheduling reasons. So while put is for a brief moment blocked and not released yet, next take happens after ur emits, so it misses them.\nAs a workaround for this problem I propose to specify a buffer for ur channel like this:\n```js\nconst subscribePosts = (socket) => {\n  return eventChannel((emit) => {\nconst insert = (snap) => {\n  emit(addPost(snap.val()));\n};\n\npostsRef.on('child_added', insert);\n\nreturn () => { };\n\n}, buffers.expanding());\n};\n```\nEverything will work as expected then.. It depends on how do u start this watcher in the first place. Cancel only temporary watcher, ie ones that should be active when being on a specific route. Rest in most cases should not be cancelled at all. Sorry for not being active lately, i was busy with other stuff. Did u resolve ur issue or do u still need some help?\n\"route structure of react boilerplate\" doesn't mean much to me. You should provide concrete code examples and provide questions with clear pointers to those code snippets. \nIf you start ur task on some kind of \"onEnter\" hook you can easily cancel it in the corresponding \"onLeave\" hook.. Im closing this issue due to inactivity. If you still have a problem, please don't hesitate to post back here later or create a new issue.. Hey, could u elaborate on ur question? Im not sure what is the part you are asking for. Shouldn't testing with mocha/chai look pretty much the same as with tape?. I think you could do that, u would just have to clone generator before testing a branch and in it block, this way everything would remain \"scoped\"/isolated. The issue is no longer available on stackoverflow, thus im closing this. If you still have any questions, please just create new issue.. you probably want to communicate with actions between sagas, so you might do something like\njs\nyield put({ type: 'REQUESTS_FINISHED' })\nin your watchRequests, so you will be able to just\njs\nyield take('REQUESTS_FINISHED')\nin your multipleActions.. Closing due to inactivity. Feel free to respond back here at any time or create new issue.. helloSaga is what should be there, it's mentioned above. I agree that it might not be obvious why its there and this could be improved. But running incrementAsync instead of it doesnt make much sense, incrementAsync is supposed to be triggered by watchIncrementAsync. \nIf you have any questions, please ask.. Actually it would be better to inject a mocked action there as you are injecting result value of the take('START_BACKGROUND_SYNC'). So maybe something like:\njs\n  it('forks the service', () => {\n    const expectedYield = fork(bgSync);\n    const mockedAction = { type: 'START_BACKGROUND_SYNC' } \n    expect(generator.next(mockedAction).value).to.deep.equal(expectedYield);\n  });. Well, in those regards internals are pretty straightforward. In general redux-saga takes ur generators (sagas) and calls .next() on the created iterators - this is how it receives effects (what you yield) and it knows what to do by inspecting type of the received effect. When it decides the effect has resolved (in case of take it is ofc when it receives action of certain type in the middleware) it simply calls .next(result). \nIn tests you do not handle ur generators to the redux-saga but instead you run them on ur own (by calling .next in the same way it would call it) - so it makes more sense to 'resolve' take effect with a 'mocked action'.. Keep in mind that u probably often want to take 1 action out from the batch. You can do so by providing a custom emit function during redux-saga initialization like here. @maitham1 hey, sorry for being not so active lately - unfortunately i had other things on my mind\ndid you resolve ur issue? do u still have any questions? please respond back so I can either close this issue or help u further. Could u setup a codesandbox.io or something so I could look on the live code and debug this quickly?. @Hauuguu you can use it even today. Sent PR just adds info about this to the docs and adds support for destructuring such race's result:\njs\nconst [a, b] = yield race([effA, effB]). Ok, so one need to be careful when dealing with sparse arrays - empty indices are non-enumerable and deepEqual uses Object.keys under the hood. Therefore we cannot simply compare explicit undefined with the implicit one in sparse array.\nPersonally I think that just suppressing eslint warning is enough and no more trickery should be added to that test.\nIt has also an interesting side-effect for our use case - returned array (if not destructured) remains sparse, so it potentially could surprise someone, but until somebody reports this with some valid use case why he/she would like to have it non-sparse, I dont consider this much of a problem.\nThanks for patience and the PR, gonna merge this in a moment.. Huh, so Safari has tail call optimization already? Nice!\nThe concern i have - doesnt it make debugging harder though? Since it omit stack frames it might be, well, trace the stack and origin of the call.\nAnyway - this is for sure a thing to look into. @bradennapier just going through issues, totally forgot about this one, is it even possible to gain anything here from TCO? what i mean - isnt TCO in javascript applicable only for a \"single-depth\" calls? like when A calls A which calls A etc? does it work through layers of functions like in the given example?. You have started 2 independent tasks depending on the INCREMENT_ASYNC action. Both cancelTheAsyncIncrement and incrementingAsync fork incrementAsync, but only the former gets cancelled.\nIf you remove the incrementingAsync, everything is gonna work as expected.. You should wrap ur ajax call in a promise like this:\n``js\nfunction requestTags({corpusId}){\n  const url =${Config.api}/corpus/${corpusId}/tag`;\nreturn new Promise((resolve, reject) => {\n    apiGet({\n      url,\n      success: resolve,\n      error: reject\n    })\n  }) \n}\nfunction* someSaga() {\n  try {\n    const result = yield call(requestTags, ...)\n    yield put({type: REQUEST_TAGS_SUCCESSED, tags: result.get('tags') })\n  } catch (error) {\n    yield put({type: REQUEST_TAGS_FAILED, error.err})\n  }\n}\n``. You just can't useyieldfrom inside the callback function - it is not possible in javascript. You need to wrap ur code in a promise so the redux-saga runtime can hook into its.then` and therefore pass the result back to your saga.\nAlso I hope this is a mistake but doing 2 yields togethere (yield yield) is probably not what u have wanted.. Im closing this issue due to inactivity, feel free to respond back here later or just create a new issue.. Thanks!. You have to wrap ur data source in eventChannel. Yield keyword can be used only in generator functions.. Closing this issue due to inactivity. Feel free to respond back later here or create a new issue.. Aint sure what you are asking about, could you clarify? You will get error object in your catch block. It is up to you how do you handle errors.. Closing this issue due to inactivity. Feel free to respond back later here or create a new issue.. I have unified error logging in this commit. Hope this fixes your issue, I'm gonna release this soon.\nSorry for not reaching back to you any sooner.. Not really, I'm not aware about this issue. I'm trying to normalize errors here.\nIm preparing v1 and I want to drop this part of the code entirely, it is not our job to normalize browser quirks like this. Unfortunately error's stack property is not standardized yet (they might be some day) and they are not consistent across browsers.\nI realize that debugging sagas might not be the easiest thing, because stack traces are quite enigmatic (although if you are proficient with using the debugger, it is not that hard to get what you want if you setup breakpoints). That's why I want to create a babel plugin that could be used during development - React does it and component stack traces are quite nice, same thing could be done with sagas to achieve saga traces. Please provide some feedback about the idea in the other thread about what type of information would be useful for you in such a babel-generated error.. Hm, I think it's nice approach that React has there, would have to check how they throw two errors at the \"same time\".. I would love a PR, although I'm not sure what kind of PR to the master branch could you send regarding this right now. From what I remember the custom error wrapping got removed, so there is no need to console.error smth and throw something else because there is only one thing that need to be tackled. \nIt got removed because I plan to sit down and work on the mentioned babel plugin and the supporting implementation in the redux-saga's core. In fact @restrry even has started working on this and I plan to review this this week to see what's left to do. Having this released would make great end of the year \ud83d\ude04 \nAs to React's approach - that's neat idea, I've even sent a PR once to this exact piece of code, but didn't thought of using this strategy myself anywhere. Seems like a thing worth exploring.\nIf you have any idea how the situation can be improved or you want to help in any way, dont hesitate before making issues or PRs. I really appreciate any help offers I can get \ud83d\udc4d . Also you could just extract used function to some module, that way call effect creator could use each time the same function, therefore 2 calls would become comparable with regular deepEqual. . You can always send PRs to the addons section. Don't be afraid to share with the community :). @martlaboloa could u share your original code - i think you have altered it since creation, because it no longer uses cancel and it's unobvious to me what kind of problem did you have.. Closing due to inactivity. Feel free to respond back later in this thread or create a new one.. Generators can be paused only \"on\" yield statements. The yielded effects are getting interpreted by the redux-saga runtime. When the effect resolves your generator is getting resumed with the resolved result.\nSo when saga cancellation happens before effect get the chance to resolve, redux-saga runtime cancels all pending effects attached to it and calls smth like yourSaga.return() (iterators created by calling generators have return method on them).\nCalling return causes generators to jump into finally blocks.\nTo sum it up - cancellation can only happen \"after\" yield statement, \"before\" the generator resumes its work.. Closing due to inactivity, feel free to respond back here later or create a new issue.. The issue itself seems to be solved, therefore I'm closing this thread. Feel free to discuss further though if you want.. @Vpr99 yeah, all should do the trick just fine :). Closing this issue due to inactivity. Feel free to respond back later here or create a new issue.. Please format your code with proper indentation - it is unreadable in the current form and it's even harder to help you with your problem.\nThe error means that you have made some kind of mistake in the code that handles ur action. By looking at your code I think it might be here:\njs\nexport const submitData = (state) => state.merge({...state, submitted: true, ...state.propertyObject})\nI think what you have wanted is\njs\nexport const submitData = (state, action) => state.merge({...state, submitted: true, ...action.propertyObject})\nBut ofc it might be some kind of other error. You can always setup breakpoints/debugger statements in your code to get better insight into the matter.\nYou can also setup a breakpoint inside redux-saga code here to inspect caught error which should probably give u better udnerstanding of the problem.. Your shared code is just too minimal to help you, the best way for you to get help would be either share the repository with a bug or reproduce it on something like codesandbox.io. What version of the redux-saga do you use? The best way to receive help is to provide a sample repository with the issue reproduced.. all got introduced in v0.15.\nThe same functionality was already in v0.12.1 - instead of explicit all effect, you could yield an array of effects. We have decided to introduce more explicit effect for this one - the behaviour stayed the same though. While we maintain backwards compatibility during 0.x development, so you still can yield arrays of effects (but you are gonna receive a deprecation warning while doing so). However it will be removed in v1.. Thanks!. @NullVoxPopuli Hi! thanks for the interest in the package. It certainly is possible to use it without redux - https://redux-saga.js.org/docs/api/index.html#external-api + https://redux-saga.js.org/docs/advanced/UsingRunSaga.html\nIt should be fairly simply to find concrete examples of using this API in the issues.. Closing this issue due to inactivity. Feel free to respond back later here or create a new issue.. @neurosnap what information such babel-enhanced error message could possibly have? I thought especially about saga traces - each call, fork, spawn could be tracked and the stack from the root saga could be reported.. This should work very similar to:\nhttps://babeljs.io/docs/plugins/transform-react-jsx-source/\nhttps://babeljs.io/docs/plugins/transform-react-jsx-self/\nHandling those things in the redux-saga itself in the development mode is ofc also needed.. I haven't thought this through yet, but the general idea was to log saga branch - from the root to the failing effect, creating sort of a stack from it, but not exactly the error stack, but the saga stack (similar to what React does for component stacks).\nWhile I know how to manipulate babel's AST to some extent, I have not yet integrated anything with source maps and I guess we are looking for some sort of such integration.\nFor starters we could annotate each generator (we could detect if it yields an effect, but this could potentially cause some false negatives and annotating every generator shouldn't interfere with anything imho) with source line and inferred name with static properties. In addition we'd have to attach to each yielded value (let's assume everything is an effect) \"parent saga\" static annotations. That way those helpful infos could flow through the saga's runtime and it could collect it in case of an error to construct a custom error message.. Yeah, that's true. I'm not sure though if I'd like to include tracking those saga traces in production builds (costs some bytes). But yeah - babel plugin should be responsible for source mapping and collecting maybe some other useful metadata.. There is rollup-plugin-replace for exactly the same thing and I plan to use process.env.NODE_ENV !== 'production' trick to make it dev only.\nI thought React do some of this stuff in prod mode too (i know it often do some stuff in dev mode exclusively), but I might be wrong, havent really checked it.. Closing because the babel plugin has been implemented already.. Could u put ur code on smth like codesandbox.io ? Then I would be able to check ur issue quickly once I get home. the codesandbox example is broken and incomplete, you do not create store anywhere, nor do u actually render ur FAQ component. Bitbucket repo is also great, I'm asking for codesandbox, because in most cases people can't share work-related repositories.\nI would like to ask you for the future, to test examples you give others for testing - I had to put my time into making it work. From the very beginning there was no mentioned error. I had to tweak ur code to use correct imports and stuff and when I have 'fixed' those issues example is working as expected (at least I guess so). You can check this out here - https://codesandbox.io/s/02rnnwv1l\n. Im just about to get sleep, gonna respond in full tomorrow.\nAs to the codesandbox tweaked by me - u need to click the button to trigger the action which will trigger ur getData saga. Please check my sandbox again, I think I have forgotten to save every file in there (action is triggered with a button click as mentioned before). Well, I haven't listed all the changes I've made - you should be able to compare codesandbox provided by you with mine, file by file. Honestly I haven't done much changes (logic-wise), just fixed some bad imports/usage.\nGonna close this issue as it seems to be resolved. Don't be afraid to post more comments with new findings, I'm always do my best and try to reply, even in the closed issues.. Getters got removed from channel's API (it was 'private' anyway'). Also task.done was changed to task.toPromise(). eventChannel is a special case of a channel and it doesnt expose put method in its interface. \nYou can work around this with something similar to this:\n```js\nfunction subscribeToSocket(ws) {\n  return eventChannel(emitter => {\n    ws.onmessage = (e) => emitter({type: 'MESSAGE_CREATED', payload: e.data}) \n// you can use ws here just fine\n\nreturn () => {\n  ws.close();\n}\n\n})\n}\nconst createWS = new WebSocket(wsUrl + '/client')\nexport default function* wsSagas() {\n  const ws = yield call(createWS)\n  // you can pass reference to the ws anywhere you want to call ws.send later\n  const channel = yield call(subscribeToSocket, ws)\n  while (true) {\n    const action = yield take(channel)\n    yield put(action)\n  }\n}\n```. Solution to your problem is described here - https://redux-saga.js.org/docs/advanced/Channels.html#using-channels-to-communicate-between-sagas. If you have anything you would like to ask about, don't hesitate. You can always ping me here or on gitter.. I dont think @nuc is still working on this, anyone is free to pick this work up and get it to the finish line. . Hm, I guess you are right as native english speak, although in few places added commas confuse me - do you have by any chance any good (short, concise) resources about comma rules in english? :P It seems that they are quite different than in polish (my native language).\nThanks for the PR! . > Should we extract them into multiple modules like @redux-saga/delay, @redux-saga/channel, @redux-saga/is, or should we just extract them all into one extra module @redux-saga/utils?\nFormer - more packages -> better modularization\n\nIf we extract them into multiple modules, then putting all symbols in @redux-saga/symbols seems good to me.\n\n\ud83d\udc4d \n\n@jeffvandyke I think this modular packages separation should be internal. Users only need to add redux-saga as the dependency.\n\nThis.\n\nalso @shinima should we make effectTypes public? to simplify such cases\n\nMight be a good idea too, not necessarily the priority though.\n\nFurther more, I'd like to remove asEffect and expose the structure of effects(though it breaks encapsulation), which results in much simpler usages like this. I will make a PR to see if it makes a good difference.\n\nGood idea about the trial PR \ud83d\udc4d \nBack to the topic though - I'm going to extract those packages soon (hopefully) & also tweak the core's build script to be more optimized.. Some more packages can be extracted, but it's not blocking the v1 release in any way.. The proposed name is quite misleading, because you only compare last payload with the current and by looking at the name itself I thought you want to compare with every past payload.\nI dont quite think saga wrapper is needed here, you could simply create a memoized pattern like this:\n```js\nconst skipConsecutiveEqualPayloads = desiredType => {\n    let lastPayload\nreturn ({ type, payload }) => {\n    if (type !== desiredType) {\n        return false\n    }\n\n    if (deepEqual(payload, lastPayload)) {\n        return false\n    }\n\n    lastPayload = payload\n    return true\n}\n\n}\nfunction* rootSaga() {\n    yield all([\n        takeEvery(skipConsecutiveEqualPayloads('SOME_ACTION'), someSaga, someArg)\n    ]);\n};\n```. At the moment I consider such effect to be too specific, I'm not opposed to introducing new helpers, but I feel there are just many more common patterns that should make their way to the core lib before we start adding things like this.\nIt's the beauty of redux-saga that such helper is really easy to be implemented in the user land and I do not see (at the moment) great value of adding it into the library itself.. js\nconst get = (prop, obj) => call(() => obj[prop]) \nyield get('name', user). js\nexport const get = (prop, obj) => obj[prop]\nyield call(get, 'name', user). You pass the action type as argument to the take effect creator. redux-saga's runtime is hooked into redux with a middleware and it simply checks action object - when it sees the action of type you have previously taken it resumes your saga with the action object. The questions seems to be answered, so I'm closing this.. You have right intuition - take is setting up a \"once\" listener.\ntakeLatest and takeEvery are just helpers which set up regular take under the hood, but when it gets resolved they create a new one instantly. So they act as persistent listeners.\nAbout the snippets - dont forget to put yield before effects.\nYour first snippet is kinda how takeEvery could look like:\njs\nfunction* takeEvery(pattern, saga, ...args) {\n  while(true){\n     const action = yield take(pattern);\n     yield fork(saga, ...args, action)\n  }\n}\nThe second snippet creates a persistent listener (with takeEvery), doSomething once and exits - listener being still active ofc.. > Sorry but I'm confused. Isn't the first snippet persistent? Would you describe what are the exact difference between using a while in conjunction with take VS using takeEvery?\n(I've added the forgotten yields)\nI didn't mean that second snippet is creating a persistent listener in opposed to the first one. Ive only meant that second one is creating a persistent listener and so does the first snippet.\nThe difference is that first one will doSomething each time it gets notified about action, but second one when we write it properly:\njs\nfunction*(){\n  yield takeEvery(action, someSaga); //or takeLatest(action, someSaga)\n  doSomething();\n}\nwill doSomething only once after it sets up the takeEvery persistent listener AND will fork someSaga each time it gets notified about the action.. Isnt Iterator a built-in type?. cc @aikoven . Closing as it seems not related to the redux-saga itself, many others use it with TS and that's the first issue about this.\nFeel free to comment further if you still have the issue, we'll try to figure out it with you.. Actually the problem is different. It's described at the bottom of this section\nJust add at the top of your entry file\njs\nimport 'regenerator-runtime/runtime'. Have you installed regenerator-runtime module?. That is weird, although the issue is not redux-saga's issue per se, I can have look at your project, but you would have to:\n- push out the most recent work\n- provide the instruction how to run it (im not using react-native and had some issues in the past with configuring given projects). So that is your transpiled file (only the very top of it):\n```js\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.watchLists = exports.ListDown = exports.listUp = exports.listModified = exports.listRemoved = exports.listAdded = undefined;\nexports.rootSaga = rootSaga;\nvar _firebase = require(842       ); // 842 = firebase\nvar _firebase2 = babelHelpers.interopRequireDefault(_firebase);\nvar _reduxSagaFirebase = require(987                  ); // 987 = redux-saga-firebase\nvar _reduxSagaFirebase2 = babelHelpers.interopRequireDefault(_reduxSagaFirebase);\nvar _reduxSaga = require(821         ); // 821 = redux-saga\nvar _effects = require(835                 ); // 835 = redux-saga/effects\nvar _types = require(839      ); // 839 = ./types\nvar _types2 = babelHelpers.interopRequireDefault(_types);\nvar _marked = regeneratorRuntime.mark(rootSaga);\nvar regeneratorRuntime = require(444                  ); // 444 = regenerator-runtime\n```\nAs you may notice regeneratorRuntime is used before being required. This is an issue between regenerator-transform and react-native preset. The import for the regeneratorRuntime is inserted by you version of react-native preset. Newer version should not behave like this, as this commit removed the inserting transform.\nWhy are things hoisted?\n- require imports are hoisted to the top of the file, because its how es6 modules behave\n- regeneratorRuntime.mark is also hoisted when you transpile generator function declarations, because its how declaractions work, right? you can use functions before they appear in the source code\nSo 2 independent transforms are hoisting here 2 different things and it just doesn't play well together. The issue was previously reported many times, i.e. here. \nYou need to upgrade your packages or use a custom (copied from the one you are using already) babel preset.. Tests are using arrayOfDeferred so it should be fixed there too.. There shouldn't be any perf issue, its only matter of allocating the memory. buffers.expanding is gonna reallocate new, bigger array under the hood in case of the overflow - so I think you shouldn't be concerned too much about this anyway.\nSide note - I'm preparing v1 of redux-saga and it will default channel's buffers to buffers.expanding(10) - when at the moment it is buffers.fixed(10).\nAs the original question got answered Im closing this issue. If you still have any more questions, you can respond here or create a new issue.. Done in https://github.com/redux-saga/redux-saga/commit/e8da9c912cf4a65ff7dcf53081f35e315aff9381. Thanks!. Would you like to make a PR for this?. This should work just fine\n```js\nfunction getRequest(url) {\n  // prepare request\n  // ...\nreturn fetch(url)\n  .then(response => response.json())\n  .catch(error => error)\n\n})\n}\n```\nIf it is not - you'd have to provide a repository with the bug reproduced. I'm pretty sure though this works as intended, using it my own project and it's covered with redux-saga's tests. This is excellent blog post about file uploading with redux-saga https://decembersoft.com/posts/file-upload-progress-with-redux-saga/. The issue seems to be resolved, therefore I'm asking it. . The issue seems to be resolved, therefore I'm asking it. . You can wrap ur superagent request function to create a custom one like this\njs\nconst makeRequest = (...args) => {\n  const request = makeApiRequest(...args)\n  request[CANCEL] = () => request.abort()\n  return request\n}\nand call that wrapper instead of the original function\njs\nconst result = yield call(makeRequest, ...args). You can wrap ur superagent request function to create a custom one like this\njs\nconst makeRequest = (...args) => {\n  const request = makeApiRequest(...args)\n  request[CANCEL] = () => request.abort()\n  return request\n}\nand call that wrapper instead of the original function\njs\nconst result = yield call(makeRequest, ...args). Not sure what do u mean by a general case here, it is pretty general already. The CANCEL need to be attached by some kind of wrapper function/generator if you want to benefit from it. We cant recognize external APIs to automate proper cancellation.. Not sure what do u mean by a general case here, it is pretty general already. The CANCEL need to be attached by some kind of wrapper function/generator if you want to benefit from it. We cant recognize external APIs to automate proper cancellation.. Hm, creating wrappers like this is imho quite fine. If you want to wrap arbitrary promises with arbitrary updaters I guess this is a way to go. If you are willing to ditch any of those 2 requirements, the code would look cleaner though.\nAs to adding a new effect for non blocking call - Im a little bit in the fence. Doesn't seem that much useful and it is quite easy to achieve this in user land. OTOH adding custom effects is something I would be interested in - don't know if Im gonna implement this (ain't sure about API etc), but I will look into it before releasing v1.. Hm, creating wrappers like this is imho quite fine. If you want to wrap arbitrary promises with arbitrary updaters I guess this is a way to go. If you are willing to ditch any of those 2 requirements, the code would look cleaner though.\nAs to adding a new effect for non blocking call - Im a little bit in the fence. Doesn't seem that much useful and it is quite easy to achieve this in user land. OTOH adding custom effects is something I would be interested in - don't know if Im gonna implement this (ain't sure about API etc), but I will look into it before releasing v1.. It might be some kind of an issue for async cleanups. Could you specify when that's needed for you? We could introduce cancelAsync if you find compelling use case for this. Changing existing API would require really strong arguments and I think sync cancellation just makes sense in most of the cases.\n\nHowever, the blocking / non-blocking table says it is blocking. Experimentally it appears to be blocking, and I think it is very important that it is blocking.\n\nIt is a mistake then. The cancellation is non-blocking. It might be some kind of an issue for async cleanups. Could you specify when that's needed for you? We could introduce cancelAsync if you find compelling use case for this. Changing existing API would require really strong arguments and I think sync cancellation just makes sense in most of the cases.\n\nHowever, the blocking / non-blocking table says it is blocking. Experimentally it appears to be blocking, and I think it is very important that it is blocking.\n\nIt is a mistake then. The cancellation is non-blocking. Thanks!. Thanks!. Thanks for the fix!. Thanks for the fix!. @borovik96 your use case seems simple enough that using lower-level runSaga API should get you everything you need. You'd have to provide a specialized dispatch to runSaga that would interpret input action based on some prop and would use appropriate logux dispatch flavour accordingly, so you could just use smth like\njs\nyield put({ type: 'SOME_TYPE', meta: { crossTab: true } })\nwhere ofc you could hide this behind a helper function\njs\nconst putCrossTab = ac => put({ ...ac, meta: { ...(ac.meta || {}), crossTab: true } }). @borovik96 your use case seems simple enough that using lower-level runSaga API should get you everything you need. You'd have to provide a specialized dispatch to runSaga that would interpret input action based on some prop and would use appropriate logux dispatch flavour accordingly, so you could just use smth like\njs\nyield put({ type: 'SOME_TYPE', meta: { crossTab: true } })\nwhere ofc you could hide this behind a helper function\njs\nconst putCrossTab = ac => put({ ...ac, meta: { ...(ac.meta || {}), crossTab: true } }). Thanks for raising this issue @frankandrobot. I agree that error story is not perfect at the moment. \nImho what needs to be done:\n- remove custom error wrapping\n- implementing https://github.com/redux-saga/redux-saga/issues/1199\nRemoving custom error wrapping might be considered a good first issue, if one want to contribute to the project.. Thanks for raising this issue @frankandrobot. I agree that error story is not perfect at the moment. \nImho what needs to be done:\n- remove custom error wrapping\n- implementing https://github.com/redux-saga/redux-saga/issues/1199\nRemoving custom error wrapping might be considered a good first issue, if one want to contribute to the project.. Hm, Im not sure what do you mean. Both are kinda saga issues and should be implemented to make the error story better.. Hm, Im not sure what do you mean. Both are kinda saga issues and should be implemented to make the error story better.. > The context for Issue 2 is that we started seeing related issues in production---debug statements always point to the original source code, but thrown errors point sometimes point to the source and sometimes point to the bundle... and this is for non-saga code. So there's a chance that webpack is causing part of this issue.\nThat's probably some unrelated stuff then. Nevertheless custom error wrapping should get removed from the core, because it doesn't seem to be right doing it like that. Implementing babel's plugin for the development use would be way more useful and user-friendly.\n\nConfession time: I would have started contributing a long time ago but last time I looked at the source code, I couldn't make heads or tails of it... and I'm pretty experienced. One of the main problems I had with it is that it's OOP style but it seems to inject object properties dynamically.\n\nIf you want to try again, I'd appreciate the feedback and pointing out what parts are especially hard to understand. Also pointing out places when \" it's OOP style but it seems to inject object properties dynamically\" happens would be highly appreciated, I'm not sure where the issue lies. Saga's code is mostly keeping things in closure and passing effects through \"layers\" (not too many!) of interpretation logic.\n\nI suppose I can try again and if I have code questions, maybe you guys are on gitter?\n\nhttps://gitter.im/yelouafi/redux-saga and you can always write DMs to me.\nAs to the implementation details. once I have started working on the project (Im not the original creator) the biggest blocker for me was to understand the interpreter's (./src/proc.js) flow and truth to be told there are still times when I just have to look things up and test so I can get a better grasp of what's going on. Most of that confusion for me is caused by the fact that it's passing different types of callbacks to the functions and they are all named like cb, currCb, next etc.\nI plan to find better names for them so the codebase should become more accessible, also I would like to document a little bit how this stuff works (once you get a little bit familiar with it, it really stops looking like a magic, I admit that a first look is quite frightening though) and I feel that the mentioned ./src/proc.js is the hardest part to understand, so I'd like to refactor it slightly in exploration for what it would take to implement support for custom effects.\n. > The context for Issue 2 is that we started seeing related issues in production---debug statements always point to the original source code, but thrown errors point sometimes point to the source and sometimes point to the bundle... and this is for non-saga code. So there's a chance that webpack is causing part of this issue.\nThat's probably some unrelated stuff then. Nevertheless custom error wrapping should get removed from the core, because it doesn't seem to be right doing it like that. Implementing babel's plugin for the development use would be way more useful and user-friendly.\n\nConfession time: I would have started contributing a long time ago but last time I looked at the source code, I couldn't make heads or tails of it... and I'm pretty experienced. One of the main problems I had with it is that it's OOP style but it seems to inject object properties dynamically.\n\nIf you want to try again, I'd appreciate the feedback and pointing out what parts are especially hard to understand. Also pointing out places when \" it's OOP style but it seems to inject object properties dynamically\" happens would be highly appreciated, I'm not sure where the issue lies. Saga's code is mostly keeping things in closure and passing effects through \"layers\" (not too many!) of interpretation logic.\n\nI suppose I can try again and if I have code questions, maybe you guys are on gitter?\n\nhttps://gitter.im/yelouafi/redux-saga and you can always write DMs to me.\nAs to the implementation details. once I have started working on the project (Im not the original creator) the biggest blocker for me was to understand the interpreter's (./src/proc.js) flow and truth to be told there are still times when I just have to look things up and test so I can get a better grasp of what's going on. Most of that confusion for me is caused by the fact that it's passing different types of callbacks to the functions and they are all named like cb, currCb, next etc.\nI plan to find better names for them so the codebase should become more accessible, also I would like to document a little bit how this stuff works (once you get a little bit familiar with it, it really stops looking like a magic, I admit that a first look is quite frightening though) and I feel that the mentioned ./src/proc.js is the hardest part to understand, so I'd like to refactor it slightly in exploration for what it would take to implement support for custom effects.\n. @frankandrobot not yet, from what I remember we've removed custom error wrapping after releasing last beta, I'm waiting on implementing #1199 (its partially done already) to release next beta which I hope will improve debugging experience. @frankandrobot not yet, from what I remember we've removed custom error wrapping after releasing last beta, I'm waiting on implementing #1199 (its partially done already) to release next beta which I hope will improve debugging experience. The issue was about poor DX (error messages) - this has been improved lately, changes are available in v1-beta and stable release should come this month. Closing this issue for now.. The issue was about poor DX (error messages) - this has been improved lately, changes are available in v1-beta and stable release should come this month. Closing this issue for now.. It is possible to add this type of validation in the development environment. Gonna add this in upcoming v1 release. It is possible to add this type of validation in the development environment. Gonna add this in upcoming v1 release. When you have mentioned that joining cancelled task cancels the joiner I have immediately thought that this is a serious bug, but it seems this is done by design. Just a proof that maintaining some code doesn't mean knowing it all \ud83d\ude04 \nTruth to be told I need to think for some time about this issue. Im in the preparation for v1, so it is a perfect moment for some breaking changes, ain't sure though if this is one I would like to do.\nThat being said I plan to support your use case, just ain't sure about the API yet.. When you have mentioned that joining cancelled task cancels the joiner I have immediately thought that this is a serious bug, but it seems this is done by design. Just a proof that maintaining some code doesn't mean knowing it all \ud83d\ude04 \nTruth to be told I need to think for some time about this issue. Im in the preparation for v1, so it is a perfect moment for some breaking changes, ain't sure though if this is one I would like to do.\nThat being said I plan to support your use case, just ain't sure about the API yet.. redux-saga comes from the different background than a threading systems and it actually conforms to the standard behaviours of joining a cancelled task in fp Task libraries like folktale's task, fun-task, funfix, avenir and more.\nHowever Im very interested in providing APIs to create custom effects and possibly exposing for them internal stuff like taskQueue, so other semantics could be implemented easily. Dont know if its even possible (but atm I think it is), dont know when it will be done (I really dont have much time to work on this atm, im really slowly pushing things forward here :/ if you want to collaborate on it, i would be glad to receive any help, introduce you to some internal stuff so the things can be understood easier etc), but for sure I will get to it eventually.\nI still need to consider how task.isRunning() and task.done (which is renamed on master to task.toPromise()) behave during cancellation and if the current behaviour is OK.. redux-saga comes from the different background than a threading systems and it actually conforms to the standard behaviours of joining a cancelled task in fp Task libraries like folktale's task, fun-task, funfix, avenir and more.\nHowever Im very interested in providing APIs to create custom effects and possibly exposing for them internal stuff like taskQueue, so other semantics could be implemented easily. Dont know if its even possible (but atm I think it is), dont know when it will be done (I really dont have much time to work on this atm, im really slowly pushing things forward here :/ if you want to collaborate on it, i would be glad to receive any help, introduce you to some internal stuff so the things can be understood easier etc), but for sure I will get to it eventually.\nI still need to consider how task.isRunning() and task.done (which is renamed on master to task.toPromise()) behave during cancellation and if the current behaviour is OK.. As mentioned I want to explore exposing API for custom effects to see if it could support this use case, adding an option to toPromise doesn't seem like ideal API and would also make implementation harder to maintain.. As mentioned I want to explore exposing API for custom effects to see if it could support this use case, adding an option to toPromise doesn't seem like ideal API and would also make implementation harder to maintain.. @kennethlynne while such inter saga communication works, there is no guarantee that DONE was dispatched by the same task's instance. Imagine 2 parallel tasks performing the cleanup phase at the same moment, dispatched DONE would resume both \"joiners\". @kennethlynne while such inter saga communication works, there is no guarantee that DONE was dispatched by the same task's instance. Imagine 2 parallel tasks performing the cleanup phase at the same moment, dispatched DONE would resume both \"joiners\". After thinking about it I also don't think async cancellation should be supported, at least not in the core. Don't think there is anything actionable right now for us here, I of course encourage further discussion - would i.e. love to see if other Task-based libraries allow for such patterns.. After thinking about it I also don't think async cancellation should be supported, at least not in the core. Don't think there is anything actionable right now for us here, I of course encourage further discussion - would i.e. love to see if other Task-based libraries allow for such patterns.. By looking at redux-saga-location source code getCurrentLocation doesn't return the location, but only put that data on the channel.\nThis should work:\njs\nimport { locationChannel, getCurrentPosition } from 'redux-saga-location';\n// ...\nyield call(getCurrentPosition);\nconst { position } = yield take(locationChannel);. By looking at redux-saga-location source code getCurrentLocation doesn't return the location, but only put that data on the channel.\nThis should work:\njs\nimport { locationChannel, getCurrentPosition } from 'redux-saga-location';\n// ...\nyield call(getCurrentPosition);\nconst { position } = yield take(locationChannel);. Gonna think both about allowing:\n- custom effects which could hook directly to the saga runtime - allowing u to create whatever you want, this would have to expose low level state/structures of the proc.js\n- some kind of \"non-blocking\" call which would allow to return task descriptor to the caller, I've had similar issue with this in the past and couldn't find a proper way for this in user land. Gonna think both about allowing:\n- custom effects which could hook directly to the saga runtime - allowing u to create whatever you want, this would have to expose low level state/structures of the proc.js\n- some kind of \"non-blocking\" call which would allow to return task descriptor to the caller, I've had similar issue with this in the past and couldn't find a proper way for this in user land. I think some other request from the past seems to be same-ish - https://github.com/redux-saga/redux-saga/issues/559#issuecomment-272587069. I think some other request from the past seems to be same-ish - https://github.com/redux-saga/redux-saga/issues/559#issuecomment-272587069. Value passed to the first .next() call (your mockTask) is always missed at the moment (that's how javascript works - there is open proposal to the language to add a posibility to access this value with function.sent)\nBut even if it gets lost, your code looks quite fine. Are you sure it is all of your code and that what u have pasted in here is what you are using? Jest's report suggests that you compare iterators/generators but in your tests you should have effect object here.. Value passed to the first .next() call (your mockTask) is always missed at the moment (that's how javascript works - there is open proposal to the language to add a posibility to access this value with function.sent)\nBut even if it gets lost, your code looks quite fine. Are you sure it is all of your code and that what u have pasted in here is what you are using? Jest's report suggests that you compare iterators/generators but in your tests you should have effect object here.. What version of redux-saga do you use and how do you import takeLatest? With newer version of the library it should be done like this:\njs\nimport { takeLatest } from 'redux-saga/effects'. What version of redux-saga do you use and how do you import takeLatest? With newer version of the library it should be done like this:\njs\nimport { takeLatest } from 'redux-saga/effects'. Oh damn, I haven't noticed before the really important thing.\nIf you want to test against effects equality you cannot yield requestResponse(getProfiles()) directly because each call to requestResponse will end up giving u new instance which has new identity and you wont be able to compare it in tests.\nYou should change your code to:\njs\nexport function* fetchInitialInfo() {\n  yield call(requestResponse, getProfiles());\n  yield call(requestResponse, getSubscribers());\n  yield call(requestResponse, getProjects());\n}\njs\nit('Expect to have unit tests specified', () => {\n    const gen = fetchInitialInfo();\n    const takeLatestDescriptor = gen.next();\n    expect(takeLatestDescriptor.value).toEqual(call(requestResponse, getProfiles()));\n  });. Oh damn, I haven't noticed before the really important thing.\nIf you want to test against effects equality you cannot yield requestResponse(getProfiles()) directly because each call to requestResponse will end up giving u new instance which has new identity and you wont be able to compare it in tests.\nYou should change your code to:\njs\nexport function* fetchInitialInfo() {\n  yield call(requestResponse, getProfiles());\n  yield call(requestResponse, getSubscribers());\n  yield call(requestResponse, getProjects());\n}\njs\nit('Expect to have unit tests specified', () => {\n    const gen = fetchInitialInfo();\n    const takeLatestDescriptor = gen.next();\n    expect(takeLatestDescriptor.value).toEqual(call(requestResponse, getProfiles()));\n  });. There are various attempts over the issues to make more integration-like tests and I think it is a good direction, because it hides the internal saga implementation.\nPersonally I would advise you to use v1.0.0-beta.0 (there was really no big changes!), leverage added effectMiddlewares feature to resolve your API-related effects (what you already do in tests) and change the testing approach to more integration-like one. It would require creating real redux's store, connecting it to the saga, dispatching some real actions and finally inspecting the state's shape in your assertions.. There are various attempts over the issues to make more integration-like tests and I think it is a good direction, because it hides the internal saga implementation.\nPersonally I would advise you to use v1.0.0-beta.0 (there was really no big changes!), leverage added effectMiddlewares feature to resolve your API-related effects (what you already do in tests) and change the testing approach to more integration-like one. It would require creating real redux's store, connecting it to the saga, dispatching some real actions and finally inspecting the state's shape in your assertions.. @eloytoro im merging this in a minute, if you want you can compare ur PR to what I have done to it. Changes are rather minor and cosmetic, thanks again for your work and I'm sorry it took so long to merge it in.\nNotable changes:\n- Ive written separate tests for the feature\n- if we use redux's compose it needs to be a dependency and not a devDep, its easy to miss such thing especially that it had to be \"upgraded\" in a sense and during development it was available\n- to simplify things, I've renamed it to effectMiddlewares and accept only an array of middlewares\n- compose is used only once in the runSaga and not during each effect's execution, so its result is cached\n- createSagaMiddleware accepts now that option too and pass it trough to the underlaying runSaga API. @eloytoro im merging this in a minute, if you want you can compare ur PR to what I have done to it. Changes are rather minor and cosmetic, thanks again for your work and I'm sorry it took so long to merge it in.\nNotable changes:\n- Ive written separate tests for the feature\n- if we use redux's compose it needs to be a dependency and not a devDep, its easy to miss such thing especially that it had to be \"upgraded\" in a sense and during development it was available\n- to simplify things, I've renamed it to effectMiddlewares and accept only an array of middlewares\n- compose is used only once in the runSaga and not during each effect's execution, so its result is cached\n- createSagaMiddleware accepts now that option too and pass it trough to the underlaying runSaga API. Wouldnt creating this in ur code:\njs\nconst tick = () => new Promise(resolve => requestIdleCallback(resolve))\nand using it like this:\njs\nyield call(tick)\nsolve it for you?. Wouldnt creating this in ur code:\njs\nconst tick = () => new Promise(resolve => requestIdleCallback(resolve))\nand using it like this:\njs\nyield call(tick)\nsolve it for you?. Im not sure exactly what is your desire here, could u give a usage example + describe what is happening sync and what after a requestIdleCallback is resolved?. Im not sure exactly what is your desire here, could u give a usage example + describe what is happening sync and what after a requestIdleCallback is resolved?. cc @aikoven , also it would be nice to know which makes more sense from typings perspective - join(...tasks) vs join([...tasks]). cc @aikoven , also it would be nice to know which makes more sense from typings perspective - join(...tasks) vs join([...tasks]). > @Andarist Actually there's not much difference for TS between variadic and an array.\nwhat do u think about it from the user perspective then? :P being pre-v1 I have a perfect opportunity to change it, but Im not sure which one is better. > @Andarist Actually there's not much difference for TS between variadic and an array.\nwhat do u think about it from the user perspective then? :P being pre-v1 I have a perfect opportunity to change it, but Im not sure which one is better. > BTW calling join([...tasks]) will create copy of tasks array and pass array to function, not tasks as arguments.\nI understand the technical difference of how it gets passed further, Im only wondering which one is preferable and would be easier to use in majority of use cases.\nAlso when using join(...tasks) there is a little bit of disconnect between what you pass in and what you get in return: const results = join(...tasks) where results is an array ofc.\nIm really fine with either, I only remember that I thought about it some time ago and wanted to be sure which one is more preferable. \nWhat's the status of the PR anyway -  is it ready to merge @Zaitsev @aikoven ? I see there is some failing test which needs to be fixed.. > BTW calling join([...tasks]) will create copy of tasks array and pass array to function, not tasks as arguments.\nI understand the technical difference of how it gets passed further, Im only wondering which one is preferable and would be easier to use in majority of use cases.\nAlso when using join(...tasks) there is a little bit of disconnect between what you pass in and what you get in return: const results = join(...tasks) where results is an array ofc.\nIm really fine with either, I only remember that I thought about it some time ago and wanted to be sure which one is more preferable. \nWhat's the status of the PR anyway -  is it ready to merge @Zaitsev @aikoven ? I see there is some failing test which needs to be fixed.. > Why should we merge it if there are concerns about should we have (...tasks) syntax, ( we could use join([...tasks]) ) ?\nSorry for not being clear, I ment beside (...tasks) vs ([...tasks]) \"problem\".\n\nAs for me, pass list of args and get array as return value is pretty good, (...join) is ES6 way to pass iterrable and no need to change Docs.\n\n\ud83d\udc4d \n\n\nbe easier to use in majority of use cases.\nbut we are talking about TypeScript declarations, dont we?\n\n\nTS declaractions are based on actual API, so it's kinda the same-ish thing IMHO.\n\nwe have cancel and should be consisent with (...tasks) or [...tasks] for all functions\n\nYeah, if we decide to change join then cancel should follow.\nMaybe we should also include all in this discussion, as it seems similar in this regards and it accepts array.\nI'm more inclined to leaving things as they are now, just raising this minor concern.. > Why should we merge it if there are concerns about should we have (...tasks) syntax, ( we could use join([...tasks]) ) ?\nSorry for not being clear, I ment beside (...tasks) vs ([...tasks]) \"problem\".\n\nAs for me, pass list of args and get array as return value is pretty good, (...join) is ES6 way to pass iterrable and no need to change Docs.\n\n\ud83d\udc4d \n\n\nbe easier to use in majority of use cases.\nbut we are talking about TypeScript declarations, dont we?\n\n\nTS declaractions are based on actual API, so it's kinda the same-ish thing IMHO.\n\nwe have cancel and should be consisent with (...tasks) or [...tasks] for all functions\n\nYeah, if we decide to change join then cancel should follow.\nMaybe we should also include all in this discussion, as it seems similar in this regards and it accepts array.\nI'm more inclined to leaving things as they are now, just raising this minor concern.. > But I'd also expect to always get a result of the same shape, i.e. an Effect descriptor object that may contain one or more tasks to cancel. I rarely look into the result of effect creator, though there might be more cases for this since Effect Middleware landed.\nThat a great point! At the moment join(...tasks) creates under the hood all([...join(task)]). It probably should be changed, so the effect descriptor preserve its type.\n\nThat said, I see nothing wrong in supporting both variants since both can be handy.\n\nWould prefer keeping API as simple as possible, and do not support excessive forms of doing exactly the same.. > But I'd also expect to always get a result of the same shape, i.e. an Effect descriptor object that may contain one or more tasks to cancel. I rarely look into the result of effect creator, though there might be more cases for this since Effect Middleware landed.\nThat a great point! At the moment join(...tasks) creates under the hood all([...join(task)]). It probably should be changed, so the effect descriptor preserve its type.\n\nThat said, I see nothing wrong in supporting both variants since both can be handy.\n\nWould prefer keeping API as simple as possible, and do not support excessive forms of doing exactly the same.. It depends where and how do you use all.\nI.e.\njs\nconst { parallel, cancelled } = yield race({\n    parallel: all([\n        call(fetch, '/users'),\n        call(fetch, '/repos')\n    ]),\n    cancelled: take('CANCEL_TRIGGER'),\n})\nor \n```js\nfunction* parallelTask() {\n    return yield all([\n        call(fetch, '/users'),\n        call(fetch, '/repos')\n    ])\n}\nconst task = yield fork(parallelTask)\n// ...\nyield cancel(task)\n```\nor \n```js\nconst tasks = yield all([\n    fork(fetch, '/users'),\n    fork(fetch, '/repos')\n])\nyield cancel(...tasks)\n```\nand possibly some more others way of structuring ur sagas are possible. You need to understand that cancellation happens from the outside of the effect and you need to have access to some task descriptor to call cancel on it + knowing the difference between blocking (call here) and nonblocking (fork here) is useful.. It depends where and how do you use all.\nI.e.\njs\nconst { parallel, cancelled } = yield race({\n    parallel: all([\n        call(fetch, '/users'),\n        call(fetch, '/repos')\n    ]),\n    cancelled: take('CANCEL_TRIGGER'),\n})\nor \n```js\nfunction* parallelTask() {\n    return yield all([\n        call(fetch, '/users'),\n        call(fetch, '/repos')\n    ])\n}\nconst task = yield fork(parallelTask)\n// ...\nyield cancel(task)\n```\nor \n```js\nconst tasks = yield all([\n    fork(fetch, '/users'),\n    fork(fetch, '/repos')\n])\nyield cancel(...tasks)\n```\nand possibly some more others way of structuring ur sagas are possible. You need to understand that cancellation happens from the outside of the effect and you need to have access to some task descriptor to call cancel on it + knowing the difference between blocking (call here) and nonblocking (fork here) is useful.. Im not yet exactly sure about the API, but one idea is to:\n```js\nconst safe = effect => (effect[SAFE] = true)\nfunction* someSaga() {\n  // where result is of type Error or Result\n  const result = yield safe(call(someAPI, arg1))\n  // in case of an error would die gracefully instead of failing the parent \n  yield safe(fork(otherSaga, arg2))\n}\n```\nIn this variant SAFE would have to be interpreted in the redux-saga's core. \nOther way of implementing it would be require implementing equivalent of:\njs\nfunction* safe(effect) {\n    try {\n        return { result: yield effect }\n    } catch (err) {\n        return { err }\n    }\n}\nIn this variant fork would have to be treated differently, so the task descriptor could get returned to the caller, instead of blocking.. Im not yet exactly sure about the API, but one idea is to:\n```js\nconst safe = effect => (effect[SAFE] = true)\nfunction* someSaga() {\n  // where result is of type Error or Result\n  const result = yield safe(call(someAPI, arg1))\n  // in case of an error would die gracefully instead of failing the parent \n  yield safe(fork(otherSaga, arg2))\n}\n```\nIn this variant SAFE would have to be interpreted in the redux-saga's core. \nOther way of implementing it would be require implementing equivalent of:\njs\nfunction* safe(effect) {\n    try {\n        return { result: yield effect }\n    } catch (err) {\n        return { err }\n    }\n}\nIn this variant fork would have to be treated differently, so the task descriptor could get returned to the caller, instead of blocking.. Cool!\nSeems to be that second variant of what I have proposed (no SAFE symbol, but rather just a simple wrapper around yield effect) is what we should implement.. Cool!\nSeems to be that second variant of what I have proposed (no SAFE symbol, but rather just a simple wrapper around yield effect) is what we should implement.. @younesmln go ahead, if you need any help - please just ask. @younesmln go ahead, if you need any help - please just ask. Sorry for that. I was cleaning up some stale branches and I've deleted by accident gh-pages which contained the docs. The issue is resolved now.. Sorry for that. I was cleaning up some stale branches and I've deleted by accident gh-pages which contained the docs. The issue is resolved now.. I imagine it requires removing the --force flag and changing the behaviour of the script to commit new content each time at the gh-pages branch. I imagine it requires removing the --force flag and changing the behaviour of the script to commit new content each time at the gh-pages branch. I got an advice from a friend who knows git way better than me, that it would probably require:\n- GIT_WORK_TREE=docs/ git checkout gh-pages - which should unpack gh-pages into docs\n- GIT_WORK_TREE=docs/ git commit -am 'update book'\n- and then just do a push\nThis recipe is probably missing something, but at least it is a suggestion what would need to be explored to implement this.. I got an advice from a friend who knows git way better than me, that it would probably require:\n- GIT_WORK_TREE=docs/ git checkout gh-pages - which should unpack gh-pages into docs\n- GIT_WORK_TREE=docs/ git commit -am 'update book'\n- and then just do a push\nThis recipe is probably missing something, but at least it is a suggestion what would need to be explored to implement this.. It certainly is a possibility, I don't mind using any package if it works :). It certainly is a possibility, I don't mind using any package if it works :). Sure thing! Gonna review, hopefully soon :). Sure thing! Gonna review, hopefully soon :). closed by #1290 thanks to @lukePeavey . closed by #1290 thanks to @lukePeavey . You won't get OPTIONS response in your code, unless it is an error I guess (not sure 100% though about the latter). Its the browser which makes the OPTIONS request for you and once it gets its response and if it's a correct one it just sends your original request - POST and notify you about it when it gets its response.. You won't get OPTIONS response in your code, unless it is an error I guess (not sure 100% though about the latter). Its the browser which makes the OPTIONS request for you and once it gets its response and if it's a correct one it just sends your original request - POST and notify you about it when it gets its response.. > I didnt have this problem with angularJs, for example.\nYou had to have some different setup. The issue is totally framework independent - it's just how CORS situations need to be handled because of the browser specifications.. > I didnt have this problem with angularJs, for example.\nYou had to have some different setup. The issue is totally framework independent - it's just how CORS situations need to be handled because of the browser specifications.. Hi there! This high-level thing here cannot be optional, because it helps us in distinguishing saga-induces actions from the others and that helps with some edge cases in scheduling.\nHowever I was looking at this 'hack' recently and Im very interested in changing it, because it's a little bit gross. Ideally I would just use Set for storing those actions temporarily, but I do not want to require people loading polyfills to support old environments. Any ideas how this could be solved? There is always possibility to store them in an array, but Im wondering if some better, maybe more performant, solution could be found.. Hi there! This high-level thing here cannot be optional, because it helps us in distinguishing saga-induces actions from the others and that helps with some edge cases in scheduling.\nHowever I was looking at this 'hack' recently and Im very interested in changing it, because it's a little bit gross. Ideally I would just use Set for storing those actions temporarily, but I do not want to require people loading polyfills to support old environments. Any ideas how this could be solved? There is always possibility to store them in an array, but Im wondering if some better, maybe more performant, solution could be found.. I will try to figure this thing out before releasing final v1 (beta already released!). I will try to figure this thing out before releasing final v1 (beta already released!). Problem with that approach is that whatis dispatched by wrapSagaDispatch is not only dispatched into the saga runtime but also to the outside world - other code has to operate on normal action objects. Problem with that approach is that whatis dispatched by wrapSagaDispatch is not only dispatched into the saga runtime but also to the outside world - other code has to operate on normal action objects. Thought - the whole problem boils down to the scheduling. redux-observable has recently introduced dispatch scheduling, would be great to rewrite out scheduling-concerned tests (those around inter saga communication with puts/takes) to redux-observable equivalents to see if their solution behaves the same as ours. If yes then we should be able to rewrite our scheduler using their technique and that would allow us to remove SAGA_ACTION completely.\nI may be talking \ud83d\udca9 - the idea might be totally wrong, not 100% sure if our fork model can be precisely expressed with streams.. Thought - the whole problem boils down to the scheduling. redux-observable has recently introduced dispatch scheduling, would be great to rewrite out scheduling-concerned tests (those around inter saga communication with puts/takes) to redux-observable equivalents to see if their solution behaves the same as ours. If yes then we should be able to rewrite our scheduler using their technique and that would allow us to remove SAGA_ACTION completely.\nI may be talking \ud83d\udca9 - the idea might be totally wrong, not 100% sure if our fork model can be precisely expressed with streams.. Actually the easier task would be to just reimplement their scheduling technique here and see if tests are still passing.. Actually the easier task would be to just reimplement their scheduling technique here and see if tests are still passing.. I've started the research here - https://github.com/redux-saga/redux-saga/commit/7e56d81bedc9b058b043e1dcba40e3ac10b09892\nWith those changes we \"only\" have 2 failing tests, I've started to dig into why they are failing & comparing that to redux-observable behaviour, but can't yet tell much about it. . I've started the research here - https://github.com/redux-saga/redux-saga/commit/7e56d81bedc9b058b043e1dcba40e3ac10b09892\nWith those changes we \"only\" have 2 failing tests, I've started to dig into why they are failing & comparing that to redux-observable behaviour, but can't yet tell much about it. . I've tinkered with the scheduler quite a bit over the weekend and I have not found any way to make it work without this unfortunate mutations. Even WeakSet approach would just generate other issues. \nHaving only a single report about this being a problem I'm forced to close this due to minor impact on the community & obvious lack of other solution. If anybody finds out how to make it work without this I would be more than happy to incorporate such a solution, but I strongly believe that this might be just impossible - we need to distinguish \"external\" and \"internal\" (aka put) dispatches to handle them slightly differently and without call stack introspection I have no idea how to solve it.. I've tinkered with the scheduler quite a bit over the weekend and I have not found any way to make it work without this unfortunate mutations. Even WeakSet approach would just generate other issues. \nHaving only a single report about this being a problem I'm forced to close this due to minor impact on the community & obvious lack of other solution. If anybody finds out how to make it work without this I would be more than happy to incorporate such a solution, but I strongly believe that this might be just impossible - we need to distinguish \"external\" and \"internal\" (aka put) dispatches to handle them slightly differently and without call stack introspection I have no idea how to solve it.. Thanks for the input @topaxi - it would probably be a good idea to detect this in dev mode & warn the users that if they want frozen actions then it would be better done in the middleware than in the action creators (accompanying README section would be nice too). I'll probably add this soon, before releasing final v1.. Thanks for the input @topaxi - it would probably be a good idea to detect this in dev mode & warn the users that if they want frozen actions then it would be better done in the middleware than in the action creators (accompanying README section would be nice too). I'll probably add this soon, before releasing final v1.. I've created a PR with more helpful error for development mode - https://github.com/redux-saga/redux-saga/pull/1578. I've created a PR with more helpful error for development mode - https://github.com/redux-saga/redux-saga/pull/1578. Also I was wondering yesterday - should we maybe just move delay into redux-saga/effects and make it:\njs\nexport const delay = call.bind(null, _delay)\nWe've kinda made this for helpers in 0.14 and Im wondering if we should do the same for this one.. Also I was wondering yesterday - should we maybe just move delay into redux-saga/effects and make it:\njs\nexport const delay = call.bind(null, _delay)\nWe've kinda made this for helpers in 0.14 and Im wondering if we should do the same for this one.. Gonna update the code + tests later with the change, but I guess if you have time you can already include it in this PR. Gonna update the code + tests later with the change, but I guess if you have time you can already include it in this PR. delay as effect \ud83c\udf89 . delay as effect \ud83c\udf89 . Instead of calling .next on your iterator just call .return - the execution flow will jump into your finally block.. Instead of calling .next on your iterator just call .return - the execution flow will jump into your finally block.. Something like this:\n```js\nimport { is } from 'redux-saga/utils'\nit('should successfully run and loop', () => {\n   const elasticStatsFlowSaga = getElasticStatsFlow();\n   const payload = {};\n   const mockBuffer = buffers.expanding(10)\n   const chan = actionChannel(PARSE_ES_STATS, mockBuffer);\n   const mockChannel = channel();\nexpect(is.buffer(elasticStatsFlowSaga.next().value)).toBe(true);\nexpect(elasticStatsFlowSaga.next(mockBuffer).value).toEqual(chan);\n   expect(elasticStatsFlowSaga.next(mockChannel).value).toEqual(fork(getAllDocumentStats));\nexpect(elasticStatsFlowSaga.next().value).toEqual(fork(getMetaDataStats));\nexpect(elasticStatsFlowSaga.next().value).toEqual(take(mockChannel));\nexpect(elasticStatsFlowSaga.next(payload).value).toEqual(call(handleParseAndPut, payload));\nexpect(elasticStatsFlowSaga.next().value).toEqual(put(finishESStats()));\n });\n. Something like this:js\nimport { is } from 'redux-saga/utils'\nit('should successfully run and loop', () => {\n   const elasticStatsFlowSaga = getElasticStatsFlow();\n   const payload = {};\n   const mockBuffer = buffers.expanding(10)\n   const chan = actionChannel(PARSE_ES_STATS, mockBuffer);\n   const mockChannel = channel();\nexpect(is.buffer(elasticStatsFlowSaga.next().value)).toBe(true);\nexpect(elasticStatsFlowSaga.next(mockBuffer).value).toEqual(chan);\n   expect(elasticStatsFlowSaga.next(mockChannel).value).toEqual(fork(getAllDocumentStats));\nexpect(elasticStatsFlowSaga.next().value).toEqual(fork(getMetaDataStats));\nexpect(elasticStatsFlowSaga.next().value).toEqual(take(mockChannel));\nexpect(elasticStatsFlowSaga.next(payload).value).toEqual(call(handleParseAndPut, payload));\nexpect(elasticStatsFlowSaga.next().value).toEqual(put(finishESStats()));\n });\n. You can use `XMLHttpRequest` if you want (it's still useful, even these days), but you'd need to wrap it in a `Promise` so it could be returned from the function and processed later by `redux-saga`.. I guess you want something like this:js\nimport { all, call } from 'redux-saga/effects'\nimport zipWith from 'lodash/fp/zipWith'\nconst fruits = [{iconUrl: xxx}, {iconUrl: xxx}...]\nfunction* loadFruits() {\n  const responses = yield all(fruits.map(fruit => call(Api.get, fruit.iconUrl)))\n  const iconDatas = yield all(responses.map(response => call([response, 'base64'])))\nconst updatedFruits = zipWith((fruit, iconData) => ({ ...fruit, iconData }), fruits, iconsData)\nyield call([AsyncStorage, 'setItem'], updatedFruits)\n}\n. You'd have to do something like this:js\nimport { all, call } from 'redux-saga/effects'\nimport zipWith from 'lodash/fp/zipWith'\nconst fruits = [{iconUrl: xxx}, {iconUrl: xxx}...]\nfunction loadFruits() {\n  const responses = yield all(fruits.map(fruit => call(function () {\n    try {\n      return yield call(Api.get, fruit.iconUrl)\n    } catch (err) {\n      return { err }\n    }\n  })))\nconst iconDatas = yield all(responses.map(response => !response.err ? call([response, 'base64']) : response))\n  const updatedFruits = zipWith((fruit, iconData) => !iconData.err ? ({ ...fruit, iconData }) : fruit, fruits, iconsData)\nyield call([AsyncStorage, 'setItem'], updatedFruits)\n}\n``. Isnt [asEffect](https://github.com/redux-saga/redux-saga/blob/658372c9cfbaf7435600e1372739e9c78c32b202/src/utils.js#L4) what you are looking for mostly?. Are you sure that you do not have multiple versions of theredux-sagainstalled? I have no problem with usingall` and it's exported just fine. >  I wonder if there is anything affected by the NODE_ENV=development flag\nNot when it comes to exports.\nYou should probably inspect your node_modules and determine which exact file is loaded as redux-saga/effects.. I would advise to get to the bottom of it instead of using a temporary workaround. Just put a console.log in both node_modules/redux-saga/es/effects and node_modules/redux-saga/lib/effects to see if any of them gets imported by your bundler.. For me it looks like your redux-saga got imported from the other version laying in your node_modules or something and that it is a version that do not understand all yet - values that are not recognized by the saga's runtime are returned to the caller \"as is\". \nIm not sure how were you possible to import all from redux-saga/es/effects in such case, but possibly you import all and createSagaMiddleware (default export) from other directories and your's bundler resolution algorithm is going nuts somehow.\nYou can try:\n- console.log(all.toString()) + console.log(createSagaMiddleware.toString()) and try to locate those modules on your disk\n- removing manually found module and checking if you still can import it in your project (if yes then it would mean you have the module somewhere else on the disk too). If you could share some repository with this thing reproduced, I could try to help you figuring this out. Feel free to response back here at any time - even though I'm closing this issue now.. Thanks for the PR. I find the idea useful and would like to merge this in in some form.\nI'd like to finish https://github.com/redux-saga/redux-saga/pull/1263 first, as it has direct influence on your PR. There is not really much to do there, I'd like to hoist effectRunners, so the map can be reused, instead of creating a new one each time redux-saga gets an effect. Some effect runners depend on the variables from the closure, so I need to inspect each one, write them down, gather them under single state object so it could be passed to the respective effect runners in the place of effectId argument. If you want to help with that I highly encourage you to do so :)\nOnce the mentioned PR gets merged in, we could adjust your PR, review it some more and merge it in. Hope you understand.. Ok, I will have this PR hanging around here for some time, until I finish #1263 and then I can even just make necessary adjustments and merge it in. Thanks for the work!. Thanks for the PR, after procrastinating on it too much and rethinking some things - we've decided that effects' shapes are stable enough to recommend just checking them like regular objects if needed, you can build ur own inspection utils if you want ofc, but we dont feel its particularly useful as part of the core library, especially considering the use cases for inspection rather niche.. Note to myself: I have no idea how task and mainTask work in the proc. Ideally (?) we should be able to hide both in 1 abstraction.. Idea - is effect serializability a goal? By encapsulating effect runner in an effect we could slim down the core library, because the interpreter wouldn't have to know upfront about all possible effects and their respective runners.\nAnd effects would still be somewhat serializable, such JSON.stringify would simply omit a runner key.. This happens after you clone the repository, right? Not when installing the package from npm. Truth to be told - I have no idea what's the problem. I've done fresh installs on my machine and they are working fine. Could you describe exact steps that led to this problem? Also specifying node/npm versions would be helpful.. For some reason your npm has downloaded master branch from babel-plugin-annotate-pure-calls instead of the specified babel7. \nUpgrading your npm can probably fix this issue.. I'll release the babel plugin later under other tag than latest, should fix problems like this.. I've published the babel plugin to npm and changed redux-saga's dep on it. Things should work for you guys now, let me know if all is ok.\n@Arhane unfortunately engines field specifies which versions of i.e. npm are capable of installing/using the package as user, not as developer of the package and there is no devEngines field :(. Thanks for the PR. Im wondering if doing those snippets with diff would be beneficial, like:\ndiff\n-export function* incrementAsync() {\n+function* incrementAsync() {\n  yield delay(1000)\n  yield put({ type: 'INCREMENT' })\n}. How do you load your defaultSaga saga? Is it injected somehow during runtime? In example during a route transition?. I bet that your exported component gets rendered twice and thus the defaultSaga gets injected twice and it's run also twice.\nYou should cancel the injected saga when the component gets unmounted (that's probably your intended use case). from what I see it should be handled for you already: here + here\nPlease add componentWillMount with a console.log to your MyComponent to see how many times it tries to get rendered.. If you share a repository with the issue reproduced I could help you debug this, without that it's really hard to pinpoint the exact cause.. Did you solve your problem?. We have react only as dev dependency. redux-saga doesn't care about what framework do you use, it's completely agnostic of this. You can integrate it with whatever you want - react, angular, embed, vue, etc.\nSo to answer your question - it works with any React :) . Pretty much - yeah, it's just a little bit easier to integrate redux-saga with redux (it's the \"default\" integration), but you can integrate any data source with redux-saga thanks to runSaga API (where \"default\" integration of sagaMiddleware is just a thing wrapper around runSaga).\nFrom what I see in the redux's changelog we won't have to adjust our setup in any way - they are not breaking any changes to the applyMiddleware stuff and things should just continue to work.. Super cool, thank you!. Could u elaborate? I'm not sure if I understand.. Yeah, most common mistakes should get listed higher on the error page. The main point of this issue is to create an error system which could create links (by ids or something) to error pages - instead of hardcoding the error in the source code. That way helpful error messages can evolve over time without need for publishing new version of the library and without people downloading it.. Closing this in favour of our descriptive errors enhanced with babel plugin (coming in stable v1 this month). What you are asking for is actually impossible. Your Api.delete rejects asynchronously, that means if you want to use a non-blocking fork to execute it, the execution flow of saga will be already past the try/catch block when the rejection actually happens therefore it's impossible to catch it reliably in the logout saga.\n\nI don't want to use blocking call method because a bit slowly)\n\nCould you explain your issue? Blocking calls are not any slower, it's only a matter of when the caller saga gets resumed.\nI would advise to restructure your control flow somehow to achieve your goal, but to help any further I would actually need to know more business requirements for your logic.. Love this contribution \u2764\ufe0f\nI think you might be interested in effectMiddlewares feature introduced in v1.0.0-beta.0, which would allow you to resolve effects with custom data instead of mocking the API (although in the end those are pretty similar things). It depends on how your sagas are structured. It should be possible to structure your sagas in a way that you ask for the orderNo only in the moments you know it's there. If not you could do something like:\n```js\nexport function waitForState(selector, ...args) {\n    do {\n        const state = yield select(selector, ...args)\n        if (typeof state !== 'undefined') {\n            return state\n        }\n        yield take('')\n    } while (true)\n}\n// in your saga\nconst orderNo = yield call(waitForState, selectors.orderNo)\n``. For starters you can rethrow the error infetchResourceA/fetchResourceB` catch clauses. All the rest kinda depends on your requirements.. Please check now, I've pushed out the fix.. Sorry, I haven't pushed out the changes or the push went wrong and I haven't noticed. I've pushed it now.. Cool, thanks for confirming.. Im not entirely sure what are your requirements, but simple\n```js\nfunction* sendRequest(request) {\n    try {\n        const res = yield call(api, request)\n        return { res }\n    } catch (err) {\n        return { err }\n    }\n}\nfunction* handleRequest(request) {\n    const task = yield fork(sendRequest, request)\nconst { res, timeout } = yield race({\n    res: join(task),\n    timeout: call(delay, 10 * 1000)\n})\n\nif (timeout) {\n    yield put({ type: 'REQUEST_TIMEOUT' })\n    return \n}\n\nif (res.err) {\n    yield put({ type: 'REQUEST_ERROR', err: res.err })\n    return \n}\n\nyield put({ type: 'REQUEST_SUCCESS', result: res.res })\n\n}\n```\nshould do the trick :). @be-next-hotdog \nIt is a simple promise wrapper around setTimeout. You can import it like this:\njs\nimport { delay } from 'redux-saga'. This doesn't seem like an issue. If you were planning to ask a question or report something, please create a new issue about the matter.. No worries :). import { takeEvery, takeLatest, throttle } from 'redux-saga' was deprecated already since 0.14 which got out nearly a year ago.\n1.0-beta just removed this form of import entirely, but as you have noticed they are still available in redux-saga/effects.. same as others:\njs\nimport { throttle } from 'redux-saga/effects'. You could possibly handle your handleContextMiddleware in a slightly easier, but arguably more hacky, way - you could create a dummy task with fork which would attach itself to the parent in regular fashion and call createdFork.getContext instead wrapping this in a call(handleContextCalls) and using channel to get the result back.\nBoth solutions are far away from perfect though. I have a strong feeling that having this implemented and released would let you achieve your goal in a more straightforward way. OTOH you want your wrapped saga to be agnostic of any funky stuff going on and custom effects won't give you that. It seems that what you want is some sort of combination of:\n- effectMiddlewares (for top level saga without need to use runSaga in a middle of execution tree)\n- access to the formalized internal state from the effectMiddlewares, that way you could somehow resolve take effects with replaced channel\nOr maybe it would even require creating a single custom effect of fork (used in the wrapper), which could create a task with custom stdChannel.\nIt's quite hard to say though at this point, your use case is quite specific and also quite interesting. If you have any suggestions how the saga runtime could ease such an integration I would be glad to review any proposals. For now I'd like to finish the mentioned PR (any input, review, comments highly appreciated!) and see afterwards if it helps you in any way.\nAlso it's really nice to see that you are using v1-beta already \ud83c\udf89 . It occured to me just now that with custom effects you would be able to create getAllContext and pass the result to the runSaga.\nStill - ideally you wouldn't have to use runSaga directly.. > Yes, this would make it a bit less obfuscated. However, Task doesn't seem to expose getContext, only setContext, or am I missing something?\nOh, you are right \ud83d\ude04 Was quite sure both getContext/setContext are just proxying to Task's methods. I think when I have introduced those effects I had to expose a way to set top level context from outside the saga runtime and that's why I have added setContext method on Task. I could consider adding a sibling getContext method, would like to think of use cases first though. Obviously yours is one, but I'm wondering if there are any other - context was primarily implemented as way to share stuff within saga without having to pass it explicitly through call/fork arguments in nested saga trees. getContext method seems to escape this initial assumption, because it allows outside world to manipulate internal context.\n\nI think it's useful to be able to add functionality through higher-order function composition in general.\n\nCouldnt agree more \ud83d\ude03 \n\n\\o/ The new mutiCast channel is very nice, I'm already using it for some stuff.\n\nGlad to hear that you enjoy it! :). > @Andarist, am I correct to interpret this discussion as saying there's not currently (as of v0.16) a clean way to do compose saga functionality via higher order functions?\nIt is very much possible, example:\n```js\nimport Backoff from 'backo2'\nexport function* backoffRetry(min, max, saga, ...args) {\n    const backoff = new Backoff({\n        min,\n        max,\n    })\n    for (;;) {\n        try {\n            const result = yield call(saga, ...args)\n            return result\n        } catch (err) {\n            yield call(delay, backoff.duration())\n        }\n    }\n}\n// with such example usage\nconst answer = yield call(backoffRetry, 100, 20000, mightThrowSaga)\n```\nThe issue described here is caused by some specific requirements - described by @saboya above.\n\nAlso, is it currently possible to create custom effects? If so, can you please point me to any docs/examples/etc. for them?\n\nNot yet, but I would like to make custom effects possible.. @mpeyper ur proposal with spread would actually just copy \"one level\" of the context, saga contexts are chained together using prototype chain (thanks to Object.create) and spread wont do such a deep copy.\nWhat would be ur desired behaviour? To fork a saga (preserve context, it being linked to a parent so preserving error/cancel propagation) just with namespaced select/put effects?. Yeah - it makes sense. Preserving context wouldn't be really that hard, but keeping error/cancellation propagation in place and at the same time having configuration (env nowadays) replaced for the subtree (to support namespacing) is not that easy - API-wise. I'd really like to avoid exposing some setters/getters pairs for those internal things.\nI doubt we'll tackle this problem any time soon - but if you have any ideas how we could make this supported (what the API would look like?) I'd be happy to discuss possibilities. . > I noticed there is an effect middleware feature just above the env section you linked. Is there more documentation on that anywhere (I can't spot any scanning the docs)?\n\nI'm wondering if it can be used to intercept the take, select and put effects?\n\nI don't think we have any docs for this (yet), but yes - it's possible to intercept any effect using this feature.. Why is it going to be an error? It should just overflow the number or something. Anyway that's definitely something that needs to be tuned in the core somehow. You are right, this is non issue.. I've fixed the issue, please try now.. Closing the issue then. Thanks for confirmation. Hi! Thanks for the PR. Could you specify a use case for this? I don't see any advantage in the given scenario of nested calls vs all. \nI personally also ain't sure if returned effects (not yielded ones) should resolve automatically (related https://github.com/redux-saga/redux-saga/issues/1130). \nAnd also I'm pretty sure that the actual function call should be moved into the setTimeout if we want to add this (I realize though that it's probably not what you had in mind.). IMHO this use case is obscuring the saga mechanism for a little benefit of slightly shorter/terser syntax. \nIf you want to use it in such form I'd really prefer you creating a custom helper, don't have a perfect name for it, but the implementation would be:\njs\nconst callWithPostponedResult = (ms, saga, ...args) => all([call(delay, ms), call(saga, ...args)])\nThe only thing it doesn't do is unwrapping your result from the array, but that could also be achieved with other implementation:\n```js\nconst postponedResult = (ms, saga, ...args) => function* () {\n    const res = yield all([call(delay, ms), call(saga, ...args)])\n    return res[1]\n}\nyield call(postponedResult, 1000, fetchApi, '/session')\n```\nYou could possibly also migrate to v1-beta version and use effectMiddlewares option to ease your integration or wait for custom effects feature (dunno when it is gonna happen, first step PR is here).. > and also because the current delay already works with things like delay(500, delay(200, 'test')), this promise gives 'test' after 500ms, so my PR wasn't really changing this current behavior. I just needed to use call for tests\nIt probably would also work with delay(1000, call(fetchApi, '/session')) - although it wouldn't act as all but rather like a waterfall - the call would get executed after 1 second.\nThat's however just a side effect of how redux-saga works under the hood. There is no intention for any of this pattern to actually work (delay(500, delay(200, 'test')) and delay(1000, call(fetchApi, '/session'))). Unfortunately this is not a good fix, the check need to be incorporated into each of the helpers (takeEvery, takeLatest and throttle).\ngetFnCallDesc is used by other effects - call, apply, spawn, fork and your check would throw for simplest (and valid):\njs\nyield call(someAPI, arg1, arg2)\nTests are passing because all runtime type checks are hidden behind development flag and tests are running in different environment.. Could we move the validation here? It would be centralized in the ./internal/io with other effects. As addition we could also validate patternOrChannel argument.. The questions cannot be answered, it is a matter of personal taste. Personally I wouldn't use a race if I didnt want to throw - I'd rather wrap the response in some kind of wrapper object which could be inspected later. Something of type {err} | {res} (or similar).\nIt really depends on how you want to handle your errors, but I would like to have a strong connection (in any form) between a request and its failure, in your proposed race solution you have no guarantee that the failure actions has happened in response to your request.. @aikoven do you know any good resources about the topic?. Sure thing, this would be nice. Do you have any particular contributing guidelines for other projects that you like? What are the most important things that such guideline should alway cover in your opinion?. @AbdulKabia go ahead, would love your contribution for this \ud83d\udc4d . Thanks! Great PR. Thanks for the PR! We should go even further - removing sagaStack entirely, that way logError probably could be removed too.\n. Thanks, I need to revisit each of those calls some time to determine if they are needed there, but that's a matter of followup PR to this. . The changes are fine as far as I can tell, if they are working :)\n\nThere is one caveat... if the gh-pages branch is deleted from the remote repository, you need to run gh-pages-clean to clear the package's cache before running the publish script again. Otherwise you'll get an error. (see this issue).\n\nCan this become a problem? The whole point is to make the remote branch protected, so it won't be possible to delete it.. Cool, gonna merge in and see how it plays out. Thanks for your hard work, I really appreciate it \ud83d\udc4d . It depends on how u transition from book flow (which you havent pasted in) to failure/login. your AUTH_FAILURE action should contain some useful data which you could use in something similar to put({ type: REDIRECT_BACK: location: failureAction.redirectBack }) and ofc take this REDIRECT_BACK action from your submit book saga.. Just to add some more info. fork is useful when you do not want to block on the forked saga but to continue doing some work in the forking saga - you do not have to join the forked task (if you are not interested in its result), you can cancel it later (as mentioned) or just forget about it.\ncall will block your saga until the called saga resolves. \nIf you have any other questions or something is unclear about this - please ask :). You'd have to share your code to get the proper help - otherwise we might only guess where the mistake might lie.. While this might work, it's suggested to use it like this:\njs\nyield call(esperaAceptarPagoChannel);\nHow do you check that your timeout is being called to late? With this console.log(secs);? Maybe the placement of this console.log confuses you? Please move it above yield call(delay, 1000); and you will see that it's called immediately.. Sorry but there is no console.log('state after') in the given snippets so once again its hard to track the flow of the whole program. Please also put a console.log in place of THE PROBLEM comment. Could u console.log(setTimeout.toString()) before delay? In what env are you running this? What browser? What system?. I think that React Native warning about debugger being in a background tab sums the problem nicely. Chrome is throttling timers such as setTimeout when they are fired in the background tab.. Unfortunately this is very likely problem with React Native and using the chrome debugger with it. There are bunch of issues about this in RN's github repository.\nYou can test this out with simpler:\n```js\nconst countdown = (secs = 10) => {\n    const next = () => setTimeout(() => {\n        if (secs === 0) {\n            return\n        }\n        secs--\n        next()\n    }, 1000)\nnext()\n\n}\n. Blocking the whole (and the only one) thread is not the best idea. You should ask React Native community if there is a way to work around this issue in more proper way.. The best what I can say for now is commented [here](https://github.com/redux-saga/redux-saga/blob/32646061d27fe5e31a99b75ed128a05630af1190/src/internal/proc.js#L27). They were extracted to the symbols file, but remain conceptually different values - previously were created without using `Symbol`, so nothing has changed. Need to investigate the situation though and I'd like to get rid of at least similar names for them.. On the master (not yet released to npm) `delay` is now an effect, check the [implementation](https://github.com/redux-saga/redux-saga/blob/62fecd710576bd3e28aae87aaba551475a31f5c2/src/internal/io.js#L223). I believe it should ease distinguishing it from other effects. If not please comment back.. Thanks!. This might not be possible, it's caused by semantics of for/of loop used on the generator. The yielded (and received by the for/of loop) value won't magically get injected back into the subgenerator. .js\nconst createChannel = eventChannel(emit => {\n    chatClient.on('messageAdded', function * ({ channel })  {\n        emit({ type: CHAT_CHANNEL_UPDATE, channel })\n    })\n    return () => {\n        // ... you should return some unsubscribe function\n    }\n})\n// ...\nconst chan = createChannel()\nwhile (true) {\n    const chatAction = yield take(chan)\n    yield put(chatAction)\n}\n``. Thanks. Thanks!. We'd like to support task libraries but there is no universal protocol for retrieving values (as mentioned) and we cannot make it built-in, but we'd like to provide a way to write custom effects - that way you could just extend abilities of our internal effect runner with a custom effect resolved and you could easily create integration effect for Fluture.. There are other issues about custom effects already, this is not an effort we are currently pursuing (because of lacking time resources), therefore I'm going to close this particular issue about it. Would love to see some external contributions for this feature.. You'd have to share a repository with the issue reproduced to get help, unfortunately I'm not familiar witheslint-plugin-importthat much.. Thanks for providing a sample repository. I've commented on the plugin's boards already. As this is not an issue withredux-sagaitself I'm closing this thread. Hopefully we'll be able to fix this issue in the plugin soon.. Actually console might show you a snapshot of this data from some point in time. If you mutate the object you might see such \"weirdo\" numbers. I'd advise you to serialize data (withJSON.stringify` or something) and trust only those logs.\nAnyway - as you have also noticed, this \"happens\" without redux-saga being involved at all. Im not sure if we can help you here with non-saga issues like this - there is no fix that we could provide for that.. Please use putResolve with v1.0.0-beta.0. Forgot to add this to the release note.. @j-wang it shouldnt happen silently, if sagas fail the redux-saga just kills itself (well, it's part of the task tree - which in most cases means the whole tree). Does it happen in development for you? Maybe not silently but with a warning?\n@ianhowe76 You'd really have to debug this a little bit more to see what happens, your description is too vague without any info that we could have used for debugging this. I find people often having problems with broken react-native presets and such stuff, maybe you could check and confirm your setup?. Yeah, many people implements some restarting mechanisms - although such approach should be used with caution, your saga might easily die again and again, creating somewhat infinite loop (not necessarily synchronous) of restarting.\nAs mentioned this is expected behaviour, preferrably you should handle any possible errors yourself. In general sense it is unwise to just restart things at any cost, because your app has landed in unknown state and you cannot possibly know how to fix it at runtime and this might lead to worse UX. \nIf you want to guard urself, I'd advise organizing your sagas on per \"feature\" basis and wrap each feature with something like safe:\njs\nconst safe = function* (saga, ...args) {\n  try {\n    yield call(saga, ...args)\n  } catch (err) { /* just let it die */ }\n}\nand use it like:\njs\nyield fork(safe, featureA, arg1)\nyield fork(safe, featureB, arg2)\nThat way in case of an unexpeted error your app will become unusable only partially and you won't cause weird auto restarts.\nThat's my opinion though but it lines up with many people's opinions (react@16 unmounts your whole tree too in case of an error in render, unless u specify componentDidCatch somewhere). > I suppose my original expectation here was closer to redux-observable and React Native itself, where \"red screens\" cause the entire app to crash.\nInteresting, Im wondering now what's better for the overall app - to kill all sagas or to crash an entire app? \ud83e\udd14 . Actually redux-saga has this dependency only for redux's compose utility - nothing more. This won't break and for the time being no upgrade has to be done as redux@3 will still be more common in the community for quite some time.. > but it might pull in both redux versions in builds (depending on how the packagers work)\nTree-shakers should pull only that compose function from the duplicated module - so I havent concerned myself much about it.\n\nMaybe loose the constraint to allow both versions of redux?\n\nHappy to accept PR for this, do you have a specific range in mind? I see that redux has compose since v0.10. It probably won't remove it, like ever, but using >=0.10 is a little bit like a wildcard and that doesnt seem like a good idea. Maybe >=0.10 <5? And we could loosen this with next major if it ever gets released. Let me know what do you think. I think that should be possible - we do such things for peer deps on babel integrations, like here.. As discussed - we should update the dependency range to >=0.10 <5. Anyone up for creating a PR? :). Thanks for raising this, Im evaluating error handling at the moment and I might change this soon-ish.. Hm, looking into the source code each \"error\" should get reported. Could u double check that you are using v1.0.0-beta.1?. It seems that it really could have not been rebuild. We are probably going to prepare a new release in following weak or two - I'll make sure to check our build process if it is setup correctly for publication.. The new release is out for some item, we should also release final v1 this month. Hope this resolves your problem, closing this issue for now.. Gr8 work! I really like this idea (as you know). Originally I had something like this in mind - https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html#component-stack-traces , just for \"sagas traces\". I'd suspect it being more noticeable by the users.\nOpen questions:\n- is this technique useful for us?\n- would it be possible to hook into react-error-overlay with our errors? \nI'll give this a spin this weekend, to see how it actually works - I know that I've promised to do it before, just having loads of unexpected stuff in my life lately and didn't have my head in the game here. . 1. gonna prepare a proposal of the content/format for various cases (although ideally they should boil down to a single format, dunno if that will be possible at the moment though)\n\n\ncool, both of those are possible enhancements and not the core of this feature anyway. Simple example:\n```js\nconst someAPI = () => {\n    if (Math.random() > 0.5) {\n        throw new Error('example error')\n    }\nreturn 42\n}\n\n\nfunction* fetchSaga() {\n    yield call(someAPI)\n}\nfunction* rootSaga() {\n    yield fork(fetchSaga)\n}\n```\nshould create similar message:\nThe above error occurred when executing \"call(someAPI)\" effect:\n    in call(someAPI)\n    created by fetchSaga\n    created by rootSaga\nIt seems to me that most valuable are:\n- failed effect\n- \"saga trace\" - only names of chained \"parent\" tasks\nAt the moment it seems to me that displaying effects that created certain sagas would just clutter the message, alternative message could be created:\njs\nThe above error occurred when executing \"call(someAPI)\" effect:\n    in call(someAPI) (at fetchSaga)\n    created by fork(fetchSaga) (at rootSaga)\nThoughts?\nAdditionally we could list sagas that got cancelled because of the error (siblings of the failed top most saga in the tree).\n. > if we don't show effects for the whole failed sagas stack it could be hard to understand which effect created the failed task (especially if we have conditions in the code or race. on the other hand, saga shouldn't be so huge to have such a problem)\nFair point, although source mapped line numbers, should mitigate this issue, right? I'm not really holding onto any of the proposed formats.\n\nwe format failed saga stack and log it only when error bubbles to the root\n\nWe should log it whenever detached or root saga fails - you could very well mean the same, just thought this needs clarification, so we are on the same page.\n\nprobably we should just update sagaStack while error is bubbling and let user decide what to do with error stack (imho, sagaStack should be provided to users, in our app we use it to report error in sagas)\n\nI don't really feel that comfortable about extending built-ins such as Error. Seems a little bit clunky, maybe we could just pass both original javascript error and sagaStack to the onError handler? If it would bring more complexity than it is worth, then we certainly shouldn't do it and we should just stick to the sagaStack.\n\nstill working on it, could be done in follow up requests\n\nSure thing, those are just possible nice enhancements, not the core of the feature.\nNote\nI haven't yet read the new code, just replying to your post. . I've looked through the code and it's certainly nice that we can get some readable output even without babel plugin!\nNeed to check out how React handles this without babel plugin and with it, and what benefits jsx-self gives to the error output.\nI'd like to re-check if we could somehow omit passing those meta objects around and maybe pass something else around that would already be tied to meta, like this __self or something.\nThis might not be possible though or would rely on babel plugin entirely and probably babel should only enhance our error messages and not be a requirement for them as the cost of having this in runtime seems to be negligible. \nSome play testing is still ahead of me, but it looks great and I hope to wrap this up in following week, let's ship it soon \ud83d\ude80 . Just to let u know - I'm working on making this repo a monorepo managed by lerna. When it's done I plan to import your babel plugin repo here (ideally with git history untouched), then make some minor changes and publish.. @AriaMinaei thanks for sharing, this is an interesting technique but imho it seems more old-fashioned and heavy than a \"simple\" babel plugin. Note that we will show \"nicer\" (than today) errors even without babel plugin.. @Slapbox We are working on merging this PR - https://github.com/redux-saga/redux-saga/pull/1374 and when we do that (should be soon) I'm going to publish a new beta release with it.. Thanks!. You should be able to do something like this\njs\nconst saga = sagaMiddleware.run(someSaga)\nsaga.done.then(() => {\n  // assertions\n}). Does your saga contain any \"infinite\" tasks? Like takeEvery/takeLatest/throttle or custom while (true) loops? If yes then do this\n```js\nimport { END } from 'redux-saga'\nstore.dispatch(END)\n```\nat some point of your test (when you know that you want to do assertions). You'd have to show some code and explain the flow, hard to advise without seeing specifics of the problem.\n. Could u setup a simple repro on something like codesandbox? or as separate repository? I will be able to debug this quickly then and let you know how it can be handled.\nWhich version of redux-saga do you use? Also what kind of code is following a faulty put?. done can resolve only if your saga ends its execution. At the same time every attached task (called, forked - where takeLatest etc use fork under the hood) must end before the parent resolves.\nIn other words - whole task of trees has to finish first.. Here is an excellent article about testing approaches - http://blog.scottlogic.com/2018/01/16/evaluating-redux-saga-test-libraries.html \nI strongly advise to use a different approach than presented at the moment in the docs, because it's tightly coupled with internal structure and results in problems described by you.\nI'd go for more integration-like testing. Setup a simple part of your app in test, run your saga and assert on actual app effects (this might be an updated state shape, outgoing request, or something rendered by an isolated component), rather than effect objects. It might be a little bit harder with latest redux-saga, but should be WAY easier (regarding network requests) with redux-saga@beta. I consider this version stable, just lock your installed version in package.json. If you use the beta you will be able to use a new effectMiddlewares feature to mock your network etc responses more easily. Please checkout the release note of the beta.. takeOnce would mean for me \"take once and exit\", so I'd appreciate a better (more descriptive) name. It seems like you have a kinda leadingDebounce mechanism which takes only a leading action in a sequence until it finishes a task - debounce most often is parametrized with some time parameter, so it's probably not a best name for this though.\nIt can also be implemented a little bit easier (without introspecting task):\njs\nfunction* GIVE_ME_NAME(pattern, saga, ...args) {\n    cosnt chan = actionChannel(pattern, buffers.dropping(1))\n    while (true) {\n        const action = yield take(chan)\n        yield call(saga, ...args, action)\n        yield flush(chan)\n    }\n}\nIf we can come up with a better name I would be glad to merge this addition. Keep in mind though that internally helpers (takeEvery, takeLatest, throttle) are not implemented with generators syntax, you'd have to implement this with internal fsmIterator - if you need any help with understanding how it works I can explain it.. Let's start with providing a fsmIterator-based implementation and tests. Docs would ofc be great too - adding it to the API docs with an example usage would be superb.. Actually I have posted even simpler (I think its the same use case) implementation for this once - https://github.com/redux-saga/redux-saga/issues/589#issuecomment-348344469\n. @atlanteh It will be published soon-ish as v1.0.0-beta.1. We are reworking errors at the moment, so this is very much subject to discuss right now. There is no way though for you to \"catch\" uncaught errors from saga - because they are thrown asynchronously - if you want to really handle them you need to put appropriate try/catches in your sagas.\nWhen creating your middleware you can pass onError function, but you can't recover from it - just use it for some logging purposes etc.\nIs this what you were looking for? What you'd have expect us to handle differently? What your ideal situation would look like?. Adding useful warnings is definitely a good idea. Will think what we can do about it, although one will get notified only after his/her saga crashes. Definitely need better guides too.. Errors in saga can be caught at any level IF you are \"chaining\" (nesting) blocking calls.\nIt's not possible if you start using fork because it would actually make it really, really weird - by the time inner saga crashes the outer saga might be way past try/catch block.. In redux-saga@1 (currently in beta) errors always bubble up (cannot bubble through fork boundaries though - u need to handle them inside the forked task). onError can be used for reporting purposes - but this might change a little bit because at the moment we can specify both logger and onError and it seems that their purpose is pretty much the same.\nIf this matter is still unclear please open a new issue.. This should be possible\njs\ndescribe('watcherSaga', () => {\n  const watchAll = watcherSaga()\n  it('should watch otherAction', () => {\n    const effect = watchAll.next().value\n    expect(effect).toEqual(all([\n        takeLatest(action, someSaga),\n        takeEvery(otherAction, otherSaga)\n    ])),\n  })\n}). Sorry, ain't sure what do you mean - could you rephrase?. I recommend you to read - http://blog.scottlogic.com/2018/01/16/evaluating-redux-saga-test-libraries.html .\nIf you want to test by iterating generators, then I'd go with the snippet I've written above - but in general it might be better to use approaches mentioned in the article.. Personally I do not scope my actions like that, it's a beauty of redux that multiple reducers and sagas (and anything else) can react (\ud83d\ude04) to the same action. I understand though that this can become quite a mess sometimes - so really use whatever works for you.\nIt's still good to have convention about naming, i just don't make distinction between actions targeting reducers and actions.. @restrry good idea. Sorry - could you be more precise? Which typings? Are you having any problem with this?. @gauravsaini Pasting code lines without any kind of commentary is not really a good way of reporting an issue.. If there are some typings missing, somebody will have to provide them. Typings are community-driven, I'd happily accept a PR for this.. More correct fix is to include helloSaga in this snippet - incrementSaga is supposed to be wrapped by watchIncrementAsync and not ran by its own.. Thanks for the contribution!. Thanks for noticing. IMHO export shouldnt be added here. The point of this tutorial is to add piece by piece and at the point of this snippet there is no need to add export here.\nA note about the need to add it when it's imported in the snippet above would be nice though.. @aikoven any idea what has changed?. @aikoven Thanks for the help!. You are probably looking for something like this:\n```js\nexport const takeX = (ms, pattern, worker, ...args) => {\n    return fork(function* () {\n        const chan = yield actionChannel(pattern, buffers.sliding(1))\n    for (;;) {\n        const action = yield take(chan)\n        yield call(worker, ...args, action)\n    }\n})\n\n}\n. If this works for you, then it works for you. Do not complicate things prematurely trying to do them \"the right way\" (or any other way \ud83d\ude09 ).. I'm not familiar with the Firebase, but it seems that what u return as `unsubscribe` is not a function. To get better help, you'd have to share a repository containing the problem.. Functions have their unique identity, it's the very same as in:\nconst foo = {a:1}\nconst bar = {b:2}\nfoo === bar // false\nIf you want to compare effects using deep equality you are probably looking for this:\nsaga.next().call(axios.post, '/api/v1/users/signin', user);\n```\naxios.post will not be executed, because in tests you do not run your effects.. takeLatest is built on top of fork so it using it won't block your saga.\nThere is no real difference between those two snippets. Subtle technicality is that first one \"asks\" redux-saga runtime 2x times to do something (starting a watcher in this case) while the latter asks only once - holding both in a 'batch'. yielding arrays is deprecated though - I'd recommend using explicit effect for this:\njs\nconst rootSaga = function * () {\n    yield all([ takelatest(A, Asaga), takelatest(B, Bsaga) ])\n} . This is what I think about this:\n- solve problems (ideally without convoluted code)\n- don't be idealistic about \"idiomatic\" redux or idiomatic \"saga\" - be practical\n- trust your gut \n- don't be afraid of refactors (you always change the code anyway)\nI don't see anything wrong with your approach of using selectin saga (\ud83d\udc4bwe have this effect for a reason, right?). This sentence in docs cause more harm than good and we should probably rephrase it somehow (perfect PR opportunity :>). redux is not a peerDep of this library, while it's primary target audience are in fact redux apps it can successfully be used in other setups too (i know numerous people using it outside of redux) thanks to runSaga API. Therefore making it a peer is not really true and might discourage people from experimenting with other setups. It might be optionalDependency, but I was never sure how to use them properly.\nAlso what this duplication of compose gives us? If used without redux tree-shakers just should remove unused parts of redux and leave us just with compose, if used with redux (which is the most common setup) it won't get duplicated.. > I don't think that everyone uses tree-shakers, although people probably should, so this may have a negative impact on some users.\nBut it benefits (I realize it's not much, just few bytes, but still) majority of users.\n\nThis duplication of compose also guarantees that the maintenance of this project is not impacted by changes in the redux API or publication issues (I'm thinking of the left-pad incident for instance).\n\nleft-pad incidents don't happen too often. All software depends on other software one way or another and imho reinventing the wheel somewhat contradicts OSS goals.\nOfc if redux would change anything regarding compose I'd ditch it right away and just inline their current implementation into the redux-saga, but I trust them not to break semver so having dep on it should be safe.\nTo sum it up - I'm not entirely sure what best solution for this is, I'm just not convinced that dropping this dep solves anything and having just yet another compose util just result in increased bundle size of redux-saga, maintenance burden etc.. Looks really good \ud83d\udc4d need to spend more time with it later to read all the docs and stuff. Thanks \u2764\ufe0f . This helper is not released yet - it will be soon-ish, but as part of v1-beta line (which should be safe to use, breaking changes are minor & the library is well-tested). TS typings are community driven, so I encourage you to prepare a PR for this :). You can use takeLatest(action => action.type === SOME_ACTION && action.payload.id === id, ...), but with the simple takeLatest you want be able to takeLatestBasedOnKey - you will have to create this on your own. Should be quite simple actually, just cache tasks in the map per id and manage that.. Keep in mind that's true if you do not introduce async middleware AFTER redux-saga's one (there is like noone doing that, but it's worth noting that the described behaviour might not be ALWAYS true).. It somewhat depends on the used request approach/library. If you want to handle this in saga then you should have a single place in saga making those requests and after you get the response you should handle it there or let it communicate to some external handler that this response is got 204 and that should be handled.. I think effectMiddlewares described in v1-beta release notes - https://github.com/redux-saga/redux-saga/releases/tag/v1.0.0-beta.0 - could help you.\nYou'd have to hijack your requests, execute them on your own and inject the return value back yourself.. Thanks!. @augbog sorry that I haven't yet replied here, I am occupied with some other stuff at the moment. Please leave the PR open, when I get time I will come back to it and merge/reject appropriately. Wouldn't just separating action types from authentication sagas fix your circular dep concerns?. Maybe you could restructure it so you won't listen for authentication actions but rather just call authentication saga? Not sure if authentication request saga depends on this generic request handler though - maybe it doesn't have to? If it does it's a little bit unclear to me how it works because authentication request could cause authentication waterfalls which would be bad too, right? Or is it supposed to retry authentication process indefinitely?. I would probably go with 1, seems OK to me and what I had in mind as one of possibilities when I have commented on the issue earlier. . I think the issue can be closed, if you have any more questions u can ask at any time.. Not as part of this project, there are existing boilerplates with redux-saga included - ie https://github.com/react-boilerplate/react-boilerplate. > Whats the effect on redux-saga when some sagas never call the put method?\nThere is no effect, put is just a wrapper around dispatch and you are not obliged to use any particular effects, you are using whatever you need in particular saga.\nAs to the problem in general - wouldn't you be able to prevent double dispatches by recognizing action's origin (single store) and prevent from dispatching it again into the source store?. > Your idea would be my fallback option. Since every app is developed by a independet team and every app runs in a container, its diffucult to make assumptions on the globalEventDispatcher level.\nDon't you have to register your stores in it? If you do then you have a clear-ish link between a particular store's instance and place where you hook into its actions.. Do you even need to know about globalEventDispatcher in your sagas? Couldn't just put (which is using dispatch under the hood) cause globalEventDispatcher to re-dispatch it into all other stores?\nWhat I mean - I ideally most parts of the app(s) shouldnt really know at all about globalEventDispatcher, it should be hidden from the world, encapsulated in few places.. Thanks!. I have nearly zero experience with TS, but maybe you could try this:\njs\n    programs = yield call(programAPI.getAllMembersAsync);\ncall is responsible for actually executing ur function, so invoking it here is probably not what u were looking for.. I guess this can be closed then. Glad it helped :). There are 2 possibilities:\n- u dispatch GET_USER_TOKEN twice\n- u fork loginSaga twice. I had not time yet to play with webpack@4, could you prepare a slimmed down repro repository so I could check it out?. Will try to look into this 2morrow, thanks for repro.. I've tried right now and it worked. Even after changing this:\njs\nconst sagaMiddleware = typeof createSagaMiddleware === 'function' ? createSagaMiddleware() : createSagaMiddleware.default()\nto this\njs\nconst sagaMiddleware = createSagaMiddleware()\nI see in your webpack config that you set mainFields - is there any reason why u override the default? It could be the source of the problem.. No problem. Going to close this issue then \ud83d\ude03 . You'd have to share repository with the issue reproduced (or some codesandbox). Also - please paste in formatted code, unfortunately this is completely unreadable right now.. Ideally we'll remove this extra symbol in the near future, but in the meantime it's intentionally not enumerable and Object.assign copies only own & enumerable properties.\nAs you know what the problem is you can just set it yourself conditionally on the resulting action, smth like\n```js\nimport { SAGA_ACTION } from 'redux-saga/utils'\nexport default function payloadWrapperMiddleware() {\n  return store => next => defaultAction => {\n    const action = Object.assign({}, defaultAction)\n    action.payload = payloadWrapper(action.payload)\n    if (defaultAction[SAGA_ACTION]) {\n      Object.defineProperty(action, SAGA_ACTION, { value: defaultAction[SAGA_ACTION] })\n    }\n    return next(action)\n  }\n}\n```\nIs there any reason why do u want to copy this object? Wouldnt it be easier to just mutate it? Why is it happening in the middleware? Shouldnt this be handled by action creator?. > Thanks for the suggestion @Andarist. Is that symbol the only one that will be present on an action? I don't need to check for any other symbols?\nIt's the only one and even if we remove the need for it, we will probably have to rely on action identity and store it in some Set or something for a short period of time - in that case ur approach with copying the action instead of mutating it would actually hurt saga's scheduling (for some edge cases, but still), because you wouldn't be able to 'fix' it with copying a symbol\n\nI could mutate it, but I'd prefer not too. I don't want to cause any side-effects.\n\nSure, but avoiding side-effects for sake of avoiding side-effects is not good either. There are places where I'd avoid them at all costs and there are places where they just make our lives easier - this seems like the latter.\n\nSpecifically, the middleware I'm using is redux-normalizr-middleware. The idea is that the action-creator will add some meta information that is used by this middleware to wrap the payload.\n\nLooking into its code and it doesnt seem there is a reason to do this in the middleware, this would make it way easier to reason about if that normalizing could happen in action creator, seems more appropriate. I might be missing some use case, but at first glance this makes code more convoluted (action creation is becoming a 2 step process). > Does LOGOUT always follow LOGIN ? I dont think so. For example when user logged in to web site once as usual session will be stored in cookies of web site and when user will visit this web site again how loginFlow saga will catch LOGOUT action?\nIt depends how your application is structured. Remember that this is just a simple example and it's goal is to present the idea that saga is not simply responding to actions whenever they happen but that actually it is a state machine - so at certain points it time it can listen to different actions, depending on its state.. If you feel that this example could use some work to reflect better actual use cases, I strongly encourage you to send a PR changing this.. > In my opinion, even if examples are basic and showed just for demonstration purposes of the system, they must fit real needs.\nSure, that is ideal.\n\nThese examples looks like not fit real cases and second example is too complicated while in real case its not even necessary to catch logout action while authorization not complited yet because any website wont show logout button to nonauthorized user.\n\nTruth to be told LOGOUT doesn't have to be triggered by a logout button, source of this action might be entirely else and the real-world saga would have to consider it.\nIf you have any better example to show in this section, please share it with us for consideration or even better send a PR with a change. Without that I doubt it will get changed any time soon as our resources are very thin.. > In my opinion, even if examples are basic and showed just for demonstration purposes of the system, they must fit real needs.\nSure, that is ideal.\n\nThese examples looks like not fit real cases and second example is too complicated while in real case its not even necessary to catch logout action while authorization not complited yet because any website wont show logout button to nonauthorized user.\n\nTruth to be told LOGOUT doesn't have to be triggered by a logout button, source of this action might be entirely else and the real-world saga would have to consider it.\nIf you have any better example to show in this section, please share it with us for consideration or even better send a PR with a change. Without that I doubt it will get changed any time soon as our resources are very thin.. Could u prepare a reproduced example on something like codesandbox.io ? . Could u prepare a reproduced example on something like codesandbox.io ? . It's rather unlikely that TS compiler would interfere this anyhow. If you share your repository I could try to debug this, but without that it's really hard to tell. You'd have to dive into internal runCancelEffect to see what's happening and why the other saga is not getting cancelled.. It's rather unlikely that TS compiler would interfere this anyhow. If you share your repository I could try to debug this, but without that it's really hard to tell. You'd have to dive into internal runCancelEffect to see what's happening and why the other saga is not getting cancelled.. Not having the issue reproduced forces me to close this for now.. Not having the issue reproduced forces me to close this for now.. That's one option, you could also inject this cognitoIdentityServiceProvider with setContext effect (or pass it as context when creating the middleware), that way you could achieve easy dependency injection for things like this.. That's one option, you could also inject this cognitoIdentityServiceProvider with setContext effect (or pass it as context when creating the middleware), that way you could achieve easy dependency injection for things like this.. Thanks!. Thanks!. Hopefully new beta will get shipped this week with some really cool DX feature \ud83d\ude09 . Hopefully new beta will get shipped this week with some really cool DX feature \ud83d\ude09 . You could try to utilize effectsMiddleware feature from v1 to track and resolve other effects based on END.\nTruth to be told END is a hacky solution in itself, if you have any proposal on how it could be improved, I'm all ears. What would you see handled differently?. You could try to utilize effectsMiddleware feature from v1 to track and resolve other effects based on END.\nTruth to be told END is a hacky solution in itself, if you have any proposal on how it could be improved, I'm all ears. What would you see handled differently?. https://github.com/redux-saga/redux-saga/pull/1493 got merged in, this should \"resolve\" ur issue by aligning the behaviour with all - END is going to cancel the saga waiting on take. https://github.com/redux-saga/redux-saga/pull/1493 got merged in, this should \"resolve\" ur issue by aligning the behaviour with all - END is going to cancel the saga waiting on take. Thanks for sharing a codesandbox it let me identify the issue way quicker than it would be possible without it.\nThe problem is that your \"Is really canceled ?\" is comming from NEXT \"instance\" of handleWeb3Actions. You can verify it by looking into the console, you will actually see this:\n\"Is really canceled ? \" false // this is from the first instance that you are going to cancel in the future\nweb3 chanel\nweb3 chanel\nweb3 chanel\nweb3 chanel\n// dispatch cancellation action\n\".isCancelled()\" true // this is about first instance\n\"Is really canceled ? \" false // this happens immediately in second instance, because it reaches the `finally` block\nThe reason is because takeEvery is non-blocking so you allow saga reaching your finally block prematurely. You should block your saga so the cancellation could work:\n- either by joining a forked (from takeEvery) task\n- writing takeEvery manually with while(true) loop - it would block your saga in the loop. Thanks for sharing a codesandbox it let me identify the issue way quicker than it would be possible without it.\nThe problem is that your \"Is really canceled ?\" is comming from NEXT \"instance\" of handleWeb3Actions. You can verify it by looking into the console, you will actually see this:\n\"Is really canceled ? \" false // this is from the first instance that you are going to cancel in the future\nweb3 chanel\nweb3 chanel\nweb3 chanel\nweb3 chanel\n// dispatch cancellation action\n\".isCancelled()\" true // this is about first instance\n\"Is really canceled ? \" false // this happens immediately in second instance, because it reaches the `finally` block\nThe reason is because takeEvery is non-blocking so you allow saga reaching your finally block prematurely. You should block your saga so the cancellation could work:\n- either by joining a forked (from takeEvery) task\n- writing takeEvery manually with while(true) loop - it would block your saga in the loop. Could u please create a repository illustrating the issue? I'd like to investigate this.. Could u please create a repository illustrating the issue? I'd like to investigate this.. Thanks for the repro! However it's not working, you forgot to include ./config.js \ud83d\ude09 . Thanks for the repro! However it's not working, you forgot to include ./config.js \ud83d\ude09 . It would be really nice if you could also include a script using siege. I'd like to reproduce your test scenario as close as possible.. It would be really nice if you could also include a script using siege. I'd like to reproduce your test scenario as close as possible.. I just don't have time now to learn this tool, would appreciate clear instructions on how to reproduce ur issue.. I just don't have time now to learn this tool, would appreciate clear instructions on how to reproduce ur issue.. I couldnt yet found time to debug your repro, so sorry for that.\n\nWhen will those two recursion expected to end ?\n\nWhat do you mean by that? This part just pass action to next middleware (most likely reducer) & emits the action to saga's internals so it can resolve pending takes. I couldnt yet found time to debug your repro, so sorry for that.\n\nWhen will those two recursion expected to end ?\n\nWhat do you mean by that? This part just pass action to next middleware (most likely reducer) & emits the action to saga's internals so it can resolve pending takes. @JulianKingman posted code is not enough to judge what might be the issue here. @JulianKingman posted code is not enough to judge what might be the issue here. @hendywijaya I've tried to run siege on ur repo but you have not included urls.txt in the repository. @hendywijaya I've tried to run siege on ur repo but you have not included urls.txt in the repository. You cannot share middleware array like this and mutate it later. You are running this on the server and with each created store (once per request I suppose) you just push & push duplicated of your middlewares.\nYou have to move those into the createStore closure. You shouldn't also share sagaMiddleware like this, you should move it into the closure too, each store should get its own instance of sagaMiddleware.. You cannot share middleware array like this and mutate it later. You are running this on the server and with each created store (once per request I suppose) you just push & push duplicated of your middlewares.\nYou have to move those into the createStore closure. You shouldn't also share sagaMiddleware like this, you should move it into the closure too, each store should get its own instance of sagaMiddleware.. No problem, I'm glad we have figured it out :). No problem, I'm glad we have figured it out :). This seems like a bug, but also as something that shouldn't really happen, because underlaying mechanism doesn't differ for regular strings and for action creators with toString.\nCould you post a codesandbox.io demonstrating the issue? I would be happy to take a look at it.. This seems like a bug, but also as something that shouldn't really happen, because underlaying mechanism doesn't differ for regular strings and for action creators with toString.\nCould you post a codesandbox.io demonstrating the issue? I would be happy to take a look at it.. A generator function is special kind of function - it doesn't \"run\" immediately when it gets invoked, but rather return an iterator. It's up to the caller to handle this case and iterate over the returned iterator with .next(). But anyway your onGetCameras won't be able to call getCamerasSuccess meaningfully, because effects are just objects that have to be interpreted by redux-saga runtime - this means that it's redux-saga which should always be responsible for calling your generators/iterators (it glues all of this together).\nWhy won't you just do this?\njs\nconst response = yield call(onGetCameras);\nconsole.log('SUCCESS', response);\nyield put(actionCreators.getCamerasSuccess(response);. A generator function is special kind of function - it doesn't \"run\" immediately when it gets invoked, but rather return an iterator. It's up to the caller to handle this case and iterate over the returned iterator with .next(). But anyway your onGetCameras won't be able to call getCamerasSuccess meaningfully, because effects are just objects that have to be interpreted by redux-saga runtime - this means that it's redux-saga which should always be responsible for calling your generators/iterators (it glues all of this together).\nWhy won't you just do this?\njs\nconst response = yield call(onGetCameras);\nconsole.log('SUCCESS', response);\nyield put(actionCreators.getCamerasSuccess(response);. Could u give an example os the two callbacks situation?. Could u give an example os the two callbacks situation?. joining a cancelled task cancels a joiner (at least it should), does ur cancelTaskOnAction really hangs unresolved when task gets cancelled? Could u provide a repro on something like codesandbox.io ?. joining a cancelled task cancels a joiner (at least it should), does ur cancelTaskOnAction really hangs unresolved when task gets cancelled? Could u provide a repro on something like codesandbox.io ?. 1. the winner has taskStopped key, it's value just happens to be undefined because worker doesn't return anything\n2. seems like a problem, gonna look into how it is handled internally and what we can do to fix this. Just to clarify - in your eyes workerAborter should get cancelled based on regular cancellation propagation  to joiners rule, right?\nEDIT:// @yelouafi's task library - https://github.com/yelouafi/avenir doesn't cancel the race if 1 of the involved tasks gets cancelled, it ends as cancelled though if both gets cancelled (which redux-saga doesn't do). Need to spend some time thinking about this, let me know what do you think though!. 1. the winner has taskStopped key, it's value just happens to be undefined because worker doesn't return anything\n2. seems like a problem, gonna look into how it is handled internally and what we can do to fix this. Just to clarify - in your eyes workerAborter should get cancelled based on regular cancellation propagation  to joiners rule, right?\nEDIT:// @yelouafi's task library - https://github.com/yelouafi/avenir doesn't cancel the race if 1 of the involved tasks gets cancelled, it ends as cancelled though if both gets cancelled (which redux-saga doesn't do). Need to spend some time thinking about this, let me know what do you think though!. https://github.com/redux-saga/redux-saga/pull/1493 got merged in, this should \"resolve\" ur issue by aligning the behaviour with all - END is going to cancel the saga waiting on take. https://github.com/redux-saga/redux-saga/pull/1493 got merged in, this should \"resolve\" ur issue by aligning the behaviour with all - END is going to cancel the saga waiting on take. How do you install redux-saga? I don't think prepare should run if you install the package from npm. How do you install redux-saga? I don't think prepare should run if you install the package from npm. please try to use npm run bootstrap instead of npm install, u might want to run npm run clean before u do that. please try to use npm run bootstrap instead of npm install, u might want to run npm run clean before u do that. Why does {{filename}} work? is it a built-in feature of tape?. Why does {{filename}} work? is it a built-in feature of tape?. Oh, it was already in the code and not the addition in the PR - thanks for clarifying.\nThe nice thing about expected files is that they might be auto generated on the initial run, with that template in we lose that trait. Wondering if we could preserve it by not using this template - I think it's doable by replacing transformFileSync in test runner with transformSync and passing a filename option to it. That way we could just trim the filename to the project's root to avoid conflicts between machines.. Oh, it was already in the code and not the addition in the PR - thanks for clarifying.\nThe nice thing about expected files is that they might be auto generated on the initial run, with that template in we lose that trait. Wondering if we could preserve it by not using this template - I think it's doable by replacing transformFileSync in test runner with transformSync and passing a filename option to it. That way we could just trim the filename to the project's root to avoid conflicts between machines.. Cool! Let us merge this before merging yours though, as we'll have 100% certainty that your branch pass on CI (at the moment tests are broken due to absolute paths included in babel plugin's tests). Cool! Let us merge this before merging yours though, as we'll have 100% certainty that your branch pass on CI (at the moment tests are broken due to absolute paths included in babel plugin's tests). Could u rebase ur branch against latest master?. Thanks!\n\nI don't know if one gets notified with a \"thumbs up\" \n\nIt doesn't notify people, which sometimes is a bummer \ud83d\ude09 . Hi @NeoLegends! Hope you enjoy reading the source, if you have any questions you can always reach out to me. If you have any thoughts on how it could be improved (both the API/behaviour or the implementation) I would gladly hear you out and ofc you can always make a PR \ud83d\ude09 \nBack to the original question - reason is quite simple, with poor-ish es6+ support (many people still need to support IE10) we didn't want to force people to transpile redux-saga source to use it. Most people usually ignore node_modules in bundlers' rules.. > It would allow listening to multiple action types and would return an object like the one returned from race as soon as its got one action of every type. If it encounters one action multiple times it'll take the latest one.\nThis would match rx semantics, right?\n\nbecause we cannot return anything custom through yield.\n\nNot sure if I follow could u explain?\nThe idea seems good, I always wanted to implement more built-in helpers. Do you want to work in this?. You can create your custom effects, as long as they are just wrappers around what we offer today.\nBut as you have observed, for a thing like combineLatest you must encapsulate handler in the effect. There is a problem with your first snippet - it assumes that u'd like to handle result of the combineLatest at the yield site, but that way we wouldn't be able to implement easily long-running effects (like combineLatest). Generators are kinda state machines and by advancing from yield combineLatest(...) state to another we wouldn't be able to resolve combineLatest again when new action would happen.. Oh, I get it. Thought it should be long-lived and resolve each time new action happens after its resolved for the first time.\nI think (not sure though) that it should be possible to do what u want, u'd have to use internally fork and return join(forked) to the yielder.. We are working on improving those.. The release of v1 is really coming soon-ish (hope to get it out this month) - so closing this issue in favour of using v1 which will have better errors by default\n. Are you sure this happens on a real device and not only on RN simulator? The latter (not sure about real devices) has known issues around timers and throttle has to use setTimeout under the hood.. Need to close this as not actionable on our part. I think there are some workarounds for this on RN, but you'd have to search for them on your own as I have no experience with that platform. Feel free to comment if you find the solution for this!. @aikoven could you take a look if you have some spare time? Sorry for pinging you for those cases over and over again. Thanks!. No.\nFrom the user perspective it is no different than async/await - effects are yielded and u can think of that as they would be \"awaited\". \nFrom the library's (redux-saga) point of view async/await is to generators like a younger, dummy brother \ud83d\ude09 You can do much, much more with generators than with async/await.\nPlease also read this comment. I'm totally open for adding it, just not for adding it myself. Would you like to compile those 3 comments into a single short-ish section of the README?. Cool, thank you very much! \ud83d\udc4d . @sincerekamal cancellation for starters - u cant cancel promises (which are ultimately created when calling async functions), but u can stop iterating through an iterator (u can even call its return method). @antialias \nIt's also iterator's method \ud83d\ude09 \njs\nfunction *saga() {}\nvar it = saga()\nit.return(). Please use \njs\nyield takeEvery(SEARCH_FOR_TWEETS_REQUESTED, fetchTweets);\ninstead of\njs\nyield* takeEvery(SEARCH_FOR_TWEETS_REQUESTED, fetchTweets);. @TechyTimo you should be importing it from redux-saga/effects.. Contex api has nothing to do with redux-saga, you can use beta safely.. > It looks like the library was using Error.prototype.stack to log errors but this doesn't seem to be the case anymore (I can't find the faulty code in the repo now, so maybe it will be fixed in next release ?)\nFor a brief moment I've even tried to normalize those, but IMHO it isn't something sustainable in a long run - so I've removed this thing entirely. \nThe plan now is to log original error but log additionally a prepared \"saga trace\" to improve debuggability (which can be enhanced with file names & line numbers with a babel plugin that we are working on). \nI don't expect to be an issue with future redux-saga@1 (beta.0 already got published some time ago) and because of limited resources we do not plan to release anymore in the 0.x line.. @pizza-r0b If you want to work on improving this in 0.x line I can gladly review a potential PR and release it once it gets merged in.\nAlso - I encourage you strongly to use redux-saga@1-beta. Improved error messages are coming really soon, breaking changes were minimal (check out the change log) and I do not plan to do any big breaking changes in future beta/rc/stable releases (although something still might be changed). Just remember to pin your dependency to a specific exact version and you should be good to go.. I've created it now - https://github.com/redux-saga/redux-saga/tree/0.x. The release of v1 is really coming soon-ish (hope to get it out this month) - so closing this issue in favour of using v1 which will have better errors by default. Have u tried running a bootstrap command? With new version (not yet released) it is an effect - https://github.com/redux-saga/redux-saga/blob/7827597d3855edbed1e5e2dc7a219e9dbe859106/packages/core/src/effects.js#L25. Could u share a reproduced issue on something like codesandbox.io ? Are u sure that the first request of those in question is not an OPTIONS preflight? Does ur CHILD_DATA_SUCCESS get dispatched twice?. Closing because original author did not respond in a very long time. If you post a runnable example of the described behaviour I might take a look, but if not I won't be able to help.. Good to hear, but don't expect it to work in IE8, if it does - it might work purely \"by accident\". We do not plan to support ie8 officially. . Is there any downside of importing sagas to other files? IMHO it's just the same problem of organizing stuff as with \"regular\" functions.. You'd have to share some example code to get better help. If you need conditional logic you typically branch ur sagas based on dispatched actions (with help of take) or based on selected state (with help of select). You can also build some customized strategies based on all effects (which tend to be quite low level). Would something like this work for you?\n```js\nconst loggedInTasks = all([\n  fork(syncNotesSaga),\n  fork(firebaseFileIndex),\n  fork(firebaseUserParams),\n  takeLatest(types.NOTE_TEXT_UPDATE, handleUpdateNoteText),\n  takeEvery(types.NOTE_ADD, updateNoteFirebase),\n])\nexport default function* rootSaga() {\n  while (true) {\n    if (!(yield select(getUserStatus))) {\n      yield take(types.LOGGED_IN)\n    }\nconst activeTasks = yield loggedInTasks\nyield take(types.LOGGED_OUT)\nyield cancel(...activeTasks)\n\n}\n}\n``. To usejoineffectively u need to sequence ur sagas usingfork`s rather than with message passing (combination of put+take). It's useful if u need to start a task, you need to wait on its result too AND you need to perform some logic in between of those 2. \nI understand that given code is simplistic on purpose at the moment, but such simple case can be modelled with a simple call.\n```js\nfunction* updateObjectStart({ objectToUpdate }) {\n  try {\n    const shouldDoExtraThings = yield select(getShouldDoExtraThings);\nif (shouldDoExtraThings) {\n  yield call(updateObjectExtra, { objectToUpdate });\n}\n\nyield call(updateObject, { objectToUpdate });\n\n} catch (err) {\n    log.error(err);\n  }\n}\n```\nIf you have some more complex logic that would need using join then this could look more like this\n```js\nfunction* updateObjectStart({ objectToUpdate }) {\n  try {\n    const shouldDoExtraThings = yield select(getShouldDoExtraThings);\nif (shouldDoExtraThings) {\n  const task = yield fork(updateObjectExtra, { objectToUpdate });\n  // ... more processing\n  const result = yield join(task)\n  // maybe do smth with `result`?\n}\n\nyield call(updateObject, { objectToUpdate });\n\n} catch (err) {\n    log.error(err);\n  }\n}\n``. Idiomatic way of sequencing and reusing generators in saga are call/fork effects rather thanyield. That said usingyield is possible, ur code is incomplete though and have few minor syntax issues, so I cannot judge what problem are u facing here. Could u share a reproduced issue on smth like codesandbox.io?. As you can see this repository has no flow typings, those live inflow-typedrepo and you should report/fix it there. cc @Alxandr . > As you can see this repository has no flow typings, those live in flow-typed repo and you should report/fix it there\n.eventChannel` is \"hot\" - if there is no subscriber at given moment emitted msg has to be dropped.\nTo solve this you can introduce buffering though:\n```js\nimport { buffers } from 'redux-saga'\nconst createBrowserHistoryChannel = () =>\n  eventChannel(emit => {\n    const unlisten = browserHistory.listen(location => emit(location.pathname))\n    emit(browserHistory.location.pathname)\n    return unlisten\n  }, buffers.expanding())\n``. Your report is unfortunately unreadable. Could you reformat it? . are those relative paths clickable in most scenarios?. U need to introduce some temporary array, track completions in it and dispatchgetTodoListconditionally based on the fact if there is still anydeleteTodoListItemrunning.. I didnt mean tracking those completions with state/reducers, but in the saga itself (as some local variable). You have done exactly that \ud83d\ude09 If this code solves ur case I dont see anything wrong with it.. U might be able to achieve this witheffectMiddlewares` feature which is available in v1-beta. Not sure though if it's possible at the moment. I'd go with some higher order saga and wrap sagas that I'd like to track with it.\nKeep also in mind that those sort of questions are better suited for stackoverflow or gitter channel than GitHub's issues.. Sorry but this place is about redux-saga issues & your problem looks like a developer mistake, it's usually better to ask such questions on sites like stackoverflow.\nAlso your screenshot & component sample is not enough to help you here, I'd inspect what's going with cloneWithRows more closely on your place.. Such questions are better suited for stackoverflow. I guess u might store some not serializable data (i.e. errors) in your redux store.. If it works for you, it's ok. I'd probably just store map of ids to channels and add to it & remove from it (on cancellation requests) - but it depends on the rest of your app.. This is most likely caused by rejecting with undefined instead of an actual error. Is there any reason why this happens in your app? It would be good to guard against that in redux-saga though - PRs are welcome. If you need any help with this - please reach out to me on gitter or by asking questions here.. It's some installation issue, if it happens on master I'll investigate this later - but for now thanks for the great work!. Could u replicate the issue? Quick test on codesandbox works fine for me\n\n. Actually this was just a plain saga monitor - but yeah, pretty much the same thing as the package linked by you.. @max-winderbaum dont worry about CI, its a separate problem. Thanks!. 1. probably some leftover, would u like to send a PR removing those assignments? OTOH there is a chance that we should set isRunning to false there, but it would require more thorough investigation\n\ntruth to be told - im not sure about this, CHANNEL_END is a somewhat hacky solution for SSR - I guess the intention is that every started task should be completed until it hits take effect which ends this particular task with CHANNEL_END but not necessarily its forks - they should end in the same way (by getting take effect). I agree this is somewhat confusing, I'm not sure though if we should track those flags on task. Need to investigate this to evaluate out options and relations between those things, thanks for the PRs! I'm quite busy at the moment though, so I won't have time to tackle this now, but I will for sure get back to it whenever I have some spare time.. I think the problem is that those are in fact 2 different states - when the whole task is \"active\"/running and when mainTask is finished. Iterator got exhausted but there still some child tasks running.\n\nBoth flags have different meaning and both are used for other things, I agree though that naming them both similarly is unfortunate and confusing, we could rename one of them to make it more obvious what's going on.. Downside of this change is that we have 2 delays now :s might be confusing for newcomers, but \ud83e\udd37\u200d\u2642\ufe0f . Actually this is correct for v1-beta .. good idea @restrry , that way we wouldnt confuse ppl about having 2 delay functions. Thanks!. I'd like to release a new version this week, until then - please be patient.. This should work too (if new Fingerprint2().get returns a promise)\njs\nconst { result, components } = yield call(() => new Fingerprint2().get((result, components) => ({ result, components })))\n. if its callback based it should be possible to do this\njs\nconst { result, components } = yield cps((err, cb) => new Fingerprint2().get((result, components) => cb({ result, components }))). Sorry, I've made a mistake, it should actually be this:\njs\nconst { result, components } = yield cps(cb => new Fingerprint2().get((result, components) => cb(null, { result, components }))). No, we do not want to call everything with custom this when we do not use this at all ourselves. You might consider decoupling ur services from this, i.e. by using factories.. Thanks. It's because you are not supposed to yield within effect combinator, effect combinators (all, race) are supposed to be yielded and be constructed from effect objects - by yielding within effect combinator definition you are effectively yielding \"nested\" effect instead of yielding the combinator (and ofc later yielding combinator with resolved result instead of effect object).\nIt should be:\njs\n    const {\n      result\n    } = yield all({\n      leaveSystem: call(UserApi.LeaveSystem),\n      result: race({\n        success: take(LEAVE_SYSTEM_REQUEST_SUCCESS),\n        failure: take(LEAVE_SYSTEM_REQUEST_FAILURE)\n      })\n    });. It's unobvious from your code snippet what goalChannel is. Idiomatically it should be an eventChannel.\nI'm not familiar with the firebase, so it's hard to tell if querySnapshot.forEach is sync or not. . Due to lack of followup answer from the original poster we have to close this issue as stale.. By injecting mockTask you \"bind\" bgSyncTask reference to this particular mock's instance, so actually when you later get expected cancel(mockTask) out of your saga (by iterating with .next(...) you have 100% certainty that what you have previously injected into your saga got cancelled later. \nYou can test it by creating a second mock task and comparing against expectedCancelYield = cancel(secondMock).. www.stackoverflow.com is much better suited for those kind of questions. . @fjorgemota could u try with the current master? CI is passing at the moment. > Based on some Redux state, I want to generate (and be able to cancel) event emitters for React Apollo to subscribe to.\nIt should be possible with channel (it's bidirectional).. Thanks!. Seems weird. Could you prepare a repro case on something like codesandbox.io ?. You could achieve it by putting your whole redux store in a worker/thread, but that requires some additional setup. I don't think putting only redux-saga's middleware in a thread is a good idea, because it has to have access to your store (getState and dispatch methods) so you'd have to tie your integration yourself to achieve this.. Not rly, saga should be \"fast enough\". Experimentation around this would be cool, but would have to be done outside of this project.. > now there are 3 local dependencies:\nI think lerna should update used versions across all packages when bumping a version, but we'll see.\n\nserver.js and its dependencies are not handled with webpack.\n\nThis should be covered with this, but I forgot to use env var for this script, we should define start script as:\njs\n\"start\": \"cross-env BABEL_ENV=cjs node --require @babel/register server.js\"\nand I think it should work.\nOTOH not sure why this example has webpack config and if it's used anywhere \ud83d\ude1f . 1. suggested approach is to use opt-in to cjs format, while modules: false is an opt-out. In this case it's kinda an equivalent of modules: 'commonjs'\nI generally like using modules: false everywhere as a rule of thumb and opting into cjs on demand with env vars. Generally tooling which supports esm supports cjs too and when using cjs u end up with unoptimized builds and in most cases you are not even warned about it. cjs-only tools fail immediately on esm though and let you opt-in into cjs format easily, so the problem is easy to spot.\n. Closing because the original author did not respond in over 20 days.. U want be able to compare those values like that, watchStartTimer() creates new reference each time it gets called.\nYou can use it like this\n```js\n// saga\nyield all([fork(watchStartTimer), fork(watchResetTimer)])\n// test\nexpect(gen.next().value).toEqual(all([fork(watchStartTimer), fork(watchResetTimer)]));\n``. It would work both with fork and call in here, difference is the same as with regular fork/call. One is non-blocking and one is blocking. Ur problem was caused by creating new references withwatchStartTime()`.. U'd have to share complete runnable code to get help with this.. > All actions that come while it's blocked are automatically buffered.\nthrottle starts a task both on leading and trailing action (in a sequence). If we flush after delay it would make no sense to use actionChannel at all, we'd just take(pattern) in the while loop.. You are right, buffers.sliding(1) is missing - it shouldn't use flush though (as in your first proposal). Would u like to send up a PR fixing this in the docs?. closed with #1449 . U might want to try out redux-saga@beta for more descriptive errors. Anyway - one of your sagas throw something that it not an Error object (u are probably throwing - or rejecting with - null). Any reason why you have decided to close the PR?. @zgavin1 PR is ready to be merged now, but I think you've rebased or merged something slightly in a wrong way as this PR shows numerous other commits that would be merged with it. Could u prepare a fresh PR with just ur changes?. It's both \ud83d\ude04 You don't have to worry about - this circular dep shouldn't cause any trouble, but it's also a known issue. Would you maybe like to restructure the project here to get rid of it? We would appreciate the PR!. There is already pending PR (#1453 ) for this by @ziel5122. 1. U might be right, would u like to remove this if statement, check if tests pass & send a PR?\n2. you can just yield someGenerator() (someGenerator returns an iterator), but it's not recommended, it's better to yield call(someGenerator)\n\nI also checked its history, it seems to me that it needs to be cleaned up\n\nNot sure what do u mean. Could u elaborate?. > but I can't find the source code for yield* someGenerator(\nThere is no source code for this, because it's language feature. yield* \"inlines\" content of the iterator.\n```js\nfunction* someGenerator() {\n  yield 2\n  yield 4\n  return 6\n}\nconst res = yield* someGenerator()\nis equivalent tojs\nyield 2\nyield 4\nconst res = 6\n``. Thanks!. Thissemaphore` is used for sync task startups & put scheduling (all happens within a single synchronous call stack!).\nIt helps to handle cases such as this:\njs\nfunction* watchFirst() {\n  yield takeEvery(FIRST, function* () {\n    yield all([\n      takeEvery(SECOND, function* () {\n        yield put({ type: 'THIRD' });\n      }),\n      put({ type: 'SECOND' })\n    ]);\n  });\n}\nThis example is a little bit convoluted, but I hope you see that without this semaphore THIRD wouldnt be dispatched, because SECOND wouldnt be taken by takeEvery. As to if (!semaphore) - it's equivalent to if (semaphore === 0) here. We could change it to this latter - more explicit - form. Would you like to send up a PR for this? \ud83d\ude09 . Some similar tests can be found here. If you feel that something is missing we'd appreciate a PR with more tests \ud83d\ude09 . To sum it up:\n- https://redux-saga.js.org/ - contains docs for 0.16\n- master branch contains newer version of the docs, we've not yet updated it to be be fully compatible with v1 though\nWe'd appreciate a PR with a fix! \ud83d\ude09 . Thanks!. I must say I don't quite understand your 2 mentioned requirements. How delete.type should both cancel update request and wait for update to finish?. You could i.e. buffer those actions with channels, race takes on them - if u take update.type then u should just process update channel until it gets empty and then process delete.\nCode for this might get a little bit messy, so probably better to just make a local variable that would act as a \"lock\". Keep in mind that u can write nested generators, so u can do things like:\n```js\nfunction* () {\n  let updating = false\n  let pendingDelete = null\nyield takeLatest(update.type, function*(ac) {\n    updating = true\n    yield call(updateHandlerFunction, ac)\n    updating = false\nif (pendingDelete) {\n  // spawn to detach this task, so it wont get cancelled if new update.type arrives\n  yield spawn(function* () {\n    // preserve reference + clear the local \"state\"\n    const deleteAc = pendingDelete\n    pendingDelete = null\n    yield call(deleteHandlerFunction, deleteAc)\n  })\n\n}\n\n})\nyield takeEvery(delete.type, function*(ac) {\n    if (updating) {\n      pendingDelete = ac\n      return\n    }\n    yield call(deleteHandlerFunction, ac)\n  })\n}\n```\nThis might not work, not adhere to your exact requirement etc but it should be pretty close to it \ud83d\ude09 . No problem, we are not in a rush with this. Enjoy your vacation \ud83d\udc4d . Thanks!. Just to expand on previous answer - in v1-beta it got renamed to putResolve.. You can also pass predicate to takeLatest/takeEvery instead of action type. Smth like \njs\nfunction* ordersRequestSaga() {\n  yield takeLatest(ac => ac.type === OrderActions.TypeKey.GET_ORDERS_REQUEST && ac.payload.requestType === OrderData.RequestType.Open, fetchOpenOrders);\n  yield takeEvery(ac => ac.type === OrderActions.TypeKey.GET_ORDERS_REQUEST && ac.payload.requestType !== OrderData.RequestType.Open, fetchOtherRequests)\n}. @jyboudreau What's ur motivation behind using Symbols for this? Handling Symbols is slightly inconvenient and I'm wondering if we have to do this.. Ok, so generally this seems to be ready to merge. But it got me wondering - there is some inconsistency between setContext & getContext effects, 1 accept a map of properties to set and one accept a single prop to get.\nUnifying both to accept single props would make the whole problem with symbols just go away (we wouldnt have to use Object.assign or any kind of equivalent) - we'd just do regular assignments. OTOH it would be far less ergonomic to use :s. Wouldnt using npm@6 make more sense? I think it supports node 10. Do u know why those has started to fail anyway? What has changed? Weren't tests passing on node@10 previously?. Can we just pin the version to 10.2.1 for the time being? If not then just merge this in its current form for the time being.. Thanks for the PR. I agree with u, that we should probably avoid such words.. Issues such as this without a runnable example will be closed. Please follow your issue template instructions.. > What am I doing wrong in code here, that is making componentDidMount not display a populated component, whereas componentWillMount and componentWillReceiveProps works?\nWithout a runnable example we cannot know what's causing the issue.\nOur question template mentions that \"The best way to provide an example is repository or use Code Sandbox\". \n. You are right about the other question being similar. The problem is that saga got more and more popular and maintaining is more and more of a burden, especially when it comes to answering general questions. I would suggest to ask such questions on sites like stackoverflow.com or join our gitter and start a discussion there. \nI would restraing from using componentWillMount & componentWillReceiveProps as both are somewhat deprecated nowadays and will be removed in the future. You don't have to dispatch reads from componentDidMount (but u can ofc), I assume your component might be rendered conditionally and you might want to start fetching based on the same condition (state change or whatever) and not postpone it until React calls componentDidMount. It all depends on your application though and your personal preferences.\n. Maybe u dispatch ur action before u run ur saga? \nAnyway - issues such as this without runnable example will be closed.. This looks good, I'm only thinking that maybe keeping those on iterator is somewhat leaky. It feels wrong to mutate it. Maybe we could try to keep those flags on the task's instance instead? It's our custom object and makes more sense to keep it there. WDYT?. I'm not against introducing breaking changes for this, so option 2 is fine. It has additional drawback though - properties might imply that they can be changed and those should really be read-only outside of redux-saga code. So I'm kinda leaning towards option 3 at the moment.\n\nI have tried this option in my little-saga\n\nThat is really cool! What are your goals for this project? You might be also interested in this project.. @restrry WDYT about this?. @divyanshu013 they would certainly work well - but they would require quit a bit of work initially to setup, Im afraid that we don't have time resources to do that right now. Would you be willing to work on it? My personal choice out of those 2 would be gatsby. > @Andarist I also lean towards gatsby. I can surely pick it up but can't promise a timeline (apologies), if you're okay with it.\nNo problem, it's just an enhancement - we are not in a hurry :)\n\nAny references for docs you have in mind? Gatsby themselves have a good docs site, for reference.\n\nNot really - something rather standard, similar to what we currently have.. Thanks, those are great !. > So I need to figure how to write in-page links that works both in GitHub and in GitBook.\nMaybe worth asking on GitBook's live chat or something? Seems like a popular problem.. > My English is a bit poor, so sometimes I may not be able to explain logic/code/situations clearly.\nThat's not a problem, I'm not a native english speaker either \ud83d\ude09 You can always reach out to me on gitter to have a talk about the codebase etc. Thanks!. This is out of scope of redux-saga repository. If you want you might find some place in documentation and create a PR linking from there to this, but other than that I'm closing this as unactionable.. Thanks!. Could u rebase this? CI fix got merged onto master today.\n. Not sure if this rename is needed, mainTask is internal anyway. I'm also not strongly opposed to it either. Whatever u both work out regarding this one.. closed by #1484. I think we can safely remove asEffect for the time being and just re-add it later in other form - probably some mix of current asEffect and this. This API seems not like a core feature, but rather an inspection util. So IMHO would be better to just take it out of the picture for now.. I've liked the effectTypes change that I think you have reverted, I think it should get reinstated - only I would create a separate file for it and import them with a namespace import (import * as effectTypes), that way the code could be slightly better minified than in case of exported object.. @Slapbox no rough estimate, probably few months (2-3?), we are moving quite slowly, although things got a little bit faster lately. Keep in mind that v1 will be just a small evolution and not a revolution, core APIs are here to stay and released betas should be stable, after all the codebase is tested \ud83d\ude09 I would only advise to pin your redux-saga dep to an exact version and you should be ready to go (after reading our release notes). @SeregaSE yeah, smth like that, retry creates call effect descriptor that has that exact logic embedded in it, you dont have to go into such details while describing - you can look how i.e. throttle is described and do this one in a similar fashion. Very nice change \ud83d\udc4d . After a thought - let's just keep the channel there, for the proc it doesn't really matter what kind of channel it is. It only expects certain interface.\nAs to stdChannel - not the best name, didnt think of any better name at a time of implementing it. It's just a multicasting channel with some scheduling involved, but the scheduling thing is very proc-specific. . As it's not actionable right now on our side, I'm going to close this issue. Feel free to comment further or to create a new one.. no idea - im unfortunately not a TS expert. > As the doc says, runSaga could be used to connect external input/output, but currently runSaga requires options.dispatch and options.getState, which means our runSaga/proc is still coupled with redux since dispatch and getState are APIs from redux. Ideally, runSaga should not require any redux-related options. Removing options.dispatch and options.getState makes it easier to run sagas in non-redux environments.\nWe can certainly discuss alternative API, but even though dispatch/getState names are obviously taken from redux you can pass any functions as those to connect external input/output. Don't quite think this is a blocker for anyone if they need this lower level API.\nAt the moment I don't particularly feel like removing internally used dispatch/getState is an important thing to do, I don't see it making things any easier. They are kinda a nicely defined way of integrating saga with anything - where getState is used for querying something and dispatch is acting like an \"emit\" function. \nWhat is more interesting to me is to see how exactly have you separated various effect categories in your little-saga. I will have to take a look into that in the following week.\nDon't be discouraged by my words though, I'm happy to discuss any idea.\n. Thanks!. I think this is quite enough, I don't think babel can be configured on codesandbox anyway.. Oh, good to know! Ives is making an impressive job on this thing \ud83d\ude0d . Thanks for your great work!. Could u rebase this against the master? Would be cool to see only new changes in the diff for this PR. The idea itself is nice and super thumbs up for experimenting with it \ud83d\udc4d\nI don't feel that we should use middleware approach for some of current core effects. They all seem quite core to me and while ofc we could remove them from the core I don't see much benefit from it. That being said - refactoring the core so that their implementation could be moved to separate files would be super nice.\nAlso I'm wondering about using middleware approach at all. Middleware's purpose seems to be more about introducing a transparent logic layers, whereas custom effects would have to have distinct types and thus a simpler effect type to effect runner map sounds like a more appropriate tool for the job.. It's already importable from redux-saga/effects when using redux-saga@beta\nDocs in the repository might be already updated to use it from redux-saga/effects. Published docs to https://redux-saga.js.org/ shouldnt yet have this change. . While we are at it - take.maybe became takeMaybe so it's a good opportunity to rename it too.. At least it's consistent with all now \ud83d\udc4d Thanks you both for great work, I'll try to catch up with other issues/PRs in following days\nEDIT:// after a thought - I need to check some more cases around this before merging. Damn, I cant remember what cases I've wanted to check \ud83e\udd26\u200d\u2642\ufe0f. Do u have any resources about the lifting concept explained or with just with other examples of this technique? Would like to understand the idea and how it's used better before moving with this forward.. @RXminuS Out of curiosity - is flow able to infer those?. Seems like this is not actionable right now on our side, so gonna need to close this. . Are you sure that u do not end up with some kind of infinite loop when dispatching CHANGE_LOCALE? Could u check ur action log to confirm/invalidate this guess?. To test ur catch logic you should call gen.throw when you are still \"inside\" try block and then just compare yielded value (first one in the catch block) against ur expected effect - then u can follow iterating with gen.next. This one was a mistake of some 0.1x version - errors should always crash ur sagas if they stay uncaught. It's fixed in v1 line (even if it's beta, do not be afraid of using it - it's not a rewrite, just mild evolution of the codebase, it's still tested and all. Just pin your version in package.json). Nesting throttle inside takeLatest looks generally like a not good idea - especially without cleaning the inner channel on cancellation. Could u describe ur desired behaviour in more detail? I cant decipher it quickly from given code.. I also think that debounce is what u are looking for. Going to close this as solved, feel free to open a new issue though.. Not sure, we'll try to cut a new release in following weeks.. Need to publish them manually for now, I'm not sure though if current docs are not mix of v0.16 and v1. We are heading towards making v1 stable, so I would prefer holding for a little bit longer with deploying the docs.. You have convinced me to array argument with simplicity of input arg type to output arg type mapping \ud83d\udc4d . Generally all side-effects should be encapsulated into effects (which are pure, could be referentially transparent etc), so I think sagas should be pure in a sense - but not sure if we really should put any emphasis on it. It doesn't matter as much as in redux case & explaining this (while also being completely correct) might be confusing people.. While the change is good I would prefer creating a dedicated config file for this - such as .prettierrc. IMHO it's better to keep those configs in separate files - there are so many tools we already have and there might be more in the future that package.json can quickly become a dumpster for configs.. What issue is supposed to be fixed by .babelrc.js -> babel.config.js rename?. \"use strict\" is probably inserted because those files are considered to be modules (rather than scripts) and when transforming them to CJS this directive has to be added to achieve strict semantics\nI suppose failing tests are just a matter of updating the fixtures, but you should run tests locally and check each one individually - if diff looks OK then just accept new one.. I like the overall refactor that has been done here - extracting effect runners to separate files (out of the proc closure) is a really good thing. \nI'm not confident enough in exposing custom effects runner right now, but obviously those changes would help in possibly making this in the future - I would leave custom effects out of the scope of this PR.\nAt the moment redux-saga sits nicely under 7kb and ideally we'd like to keep the size under this threshold - I suspect though that the reported size here is inaccurate right now because this branch is quite old and that actual size is lower (i suspect though it's over 7kb, but I might be wrong).\nThis is an internal refactor, so it shouldn't block v1 release. Could you rebase this PR to see how things look then (especially regarding the library's size)?. Just some nitpicking around import style & file extension. Other than that - ready to merge.. Yeah, sorry I have been out of touch lately, a lot going on in my life right now. I will try my best to review everything by the end of the week.. Adding this to v1 milestone - want to review it soon (hopefully for real this time \ud83d\ude05 ). I've looked through this and it seems to me that it complicates things a little bit - just to allow for enhancing the put method, which could be done easier in userland now (when emitter got introduced to the codebase initially it wasnt possible, because we didnt expose stdChannel back then, in fact each saga had its own stdChannel, so things were quite different).\nWe could make sagaMiddlewareFactory accept a channel option which would default to = stdChannel(), we would remove emitter option entirely and then people could do this\n```js\nconst channel = stdChannel()\nconst put = channel.put\nchannel.put = action => {\n  if (action.type === 'batch') {\n    action.batch.forEach(put)\n    return\n  }\nput(action)\n} \nconst sagaMiddleware = createSagaMiddleware({ channel })\n```\nWDYT?. I've prepared this PR https://github.com/redux-saga/redux-saga/pull/1539 in response to this problem, hope it won't cause any troubles in the future. I wouldnt like to be so defensive in the code. I dont fully understand the problem at hand (why wrong saga was reported to be causing the problem) - could u reproduce this on something like codesandbox.io ? It's possible that there is a bug sitting somewhere else and could be fixed.. sure, seems like a good check \ud83d\udc4d . > imho we shouldn't export delay from utils to avoid confusing and implementing it in user land (if needed) shouldn't be a problem\nI second that.\n\nbefore you have import 2 different functions from saga and use them in right order, you need to understand that delay returns a promise, that saga can handle promise correctly etc.\n\nThat was exactly the reason to introduce delay as effect. Things like delay, throttle, takeEvery & takeLatest are not technically effects, but keeping them separate was quite confusing for many people - so I've decided to just move them to effects for simplicity.\nYou don't have to worry about it, I'm going to move this delay util to separate package (@redux-saga/delay-promise or something) or move it out of this repository entirely and just make it a dependency of redux-saga.. You have to handle successful responses in a specific handler (fetchSingleReportRequest). The same would happen with Promises (Promise.all([fetchSingleReportRequest(), fetchSingleReportRequest()]).then(() => {}).catch(err => {})) - if 1 fails and u have an error handler which handles whole operation's error then u wont be notified about successful subtask.. Left a minor comment, other than that it's cool!. @BenLorantfy will you be able to prepare a PR for this? if not we might close this issue because we are not actively working on typings, this is a community effort, not ours.\n@aikoven is it possible to type check this?. Sorry, I haven't time yet to review this, we'll take care of this in following days. Just letting you know that I haven't forgotten, just don't have time lately to focus on this \ud83d\ude22 . @restrry  could u resolve the conflict and merge this in?. This is a good suggestion, would you like to prepare a PR for this?. Could u rebase this PR? \nI'm wondering if we need more inspection utils - they will only abstract simple object property access. I would be good with providing only is.effect + effectTypes. WDYT?. 6.1.0, dont have any issues with installing deps. I'm migrating to jest from tape for the core package right now, after I do that I think this PR will be ready to review (CI should be green too). > Should we name our es-modules as *.mjs?\nPersonally I'm on the fence, would prefer to keep .js for now.\n\n.mjs seems a better extension for me. Node supports ECMAScript Modules as *.mjs files\n\nIt doesnt bring much benefit to node users for now as we distribute CJS format either way.\n\nand webpack supports *.mjs out of box too.\n\nThis also doesnt matter much at the moment, because we distribute \"module\" entry in package.json.\n. Also, sorry for the big PR! \ud83d\ude05 I hoped to do less in it, but kinda went down the rabbit hole. @shinima would love your review on this one :). > I have trouble in installing deps with npm (using yarn is okay), and I fails to run build script on my Windows \ud83d\ude02. However tests are passing in CI, maybe I need to switch to a Mac.\nThat's not good, could u paste in the error? Ideally it should work fine on any system.. I've deleted lock file for the time being, its gains seems to be questionable for libraries anyway.. Sure, can do that, but it shouldnt be created anymore now with current .npmrc anyway.. Oh, lol, I haven't committed it - I've created it while removing the lock itself. Gonna push it in a moment\n. The reason is that they are truly unique, unlike strings. Your tests should share the same symbols as redux-saga's core, so not sure why this happens - we might look into your repo later to check this out.. Interesting, it seems that we might need to revert using those symbols, cc @restrry @shinima . Actually the problem lies here in smth different - put effects are somewhat scheduled (within a sync frame). This means that if you should reset ur flag ASAP and only then \"revert\" ur addLike action (if cancelled ofc).\nSo your code should look like this:\n```js\nfunction* fetchData(action) {\n  const timelineId = action.timeline.id;\n  try {\n    console.log(\"fetch-1\", action.timeline.likes);\n    yield put(actions.setLoading(true));\n    yield put(actions.addLike(timelineId, 1));\n    yield call(callApiLike);\n  } catch (error) {\n    console.log(\"fetch-2\", action.timeline.likes);\n    yield put(actions.setError(error));\n    yield put(actions.addLike(timelineId, -1));\n  } finally {\n    console.log(\"fetch-3\", action.timeline.likes);\n    yield put(actions.setLoading(false));\nif (yield cancelled()) {\n  console.log(\"fetch-4\", action.timeline.likes);\n  yield put(actions.addLike(timelineId, -1));\n}\n\n}\n}\nexport default function* watcher() {\n  yield all([takeLatest(types.REQUEST_LIKE, fetchData)]);\n}\n```\nHope that helps.. I agree - we can't guard you automatically from this though. Would be good to explain this better in the docs though.. Could you rephrase your question? Are you saying the redux-saga's internal code is convoluted & hard to follow and you'd like it to be simpler?. > I have no idea what the acceptance rate, bug count or internal reputation of redux saga is at FB \nNot sure why do u mention FB here - this is not FB project, I personally don't know if it's even used anywhere in the FB apps.\n\ncombined with redux implicitly creates a message pump within javascript.\n\nRight, but also - javascript itself is a message pump based (referring to the event loop). Also this message pump is imho quite explicit, this is the whole point of redux - to centralize message receiving point (to a reasonable extent) & make order of actions predictable.\n\nHere is an example of the problem a reasonably adept programmer could rewrite most of the 30 or so module of saga into several less modularized ones that are easier to follow and will be easier to extend.\n\nI actually believe this is not a valid accusation, because the whole complex logic is actually located in a single file (proc.js), other files are far easier to understand and you shouldn't need to jump through the codebase that much to understand how the whole thing works, because as mentioned the only thing that needs better understanding is proc.js.\n\nAnother good example is the separation of proc.js with runSaga and its default reference in index.js.  proc is only used with runsaga. Why are they separated? \n\nBecause actually proc is also used by proc. So the separation here is IMHO completely valid.\n\nwhy not reduce the total code base by combining these obviously interdependent modules into one that removes most of the complexity of formatting and error checking and then calling in to proc which then performs many of the same tests before calling individual methods.\n\nIf you feel they those files are duplicating some efforts, please point me to exact lines - I'd love to improve the lib by removing unnecessary code.\n\nHere is another exampe. takevery takelatest etc. all reference the same modules to build their code. So what is the point of putting each of these is separate modules. All it does is make the code more complex.  The end result is that the same modules are imported into ones code base no matter which options are chosen so why not just consolidate these into a well formed module with multiple exports? \n\nI guess this is a matter of personal tase, but imho having separate files for those makes perfect sense as they are independent from each other and their source code is often easier to read without the surrounding code.\n\nHere is another one. Abstracting fsmiterator from makeiterator is nothing\nshort of infuriating.\n\nThey both are different things, while I agree that maybe their names could be improved the abstraction here makes sense, because we need fsmIterator and if we would have only this one then code calling makeIterator would actually be more convoluted than it is now.\n. > For example I have distilled my usage of a few key functions down to these one ( or two) line module implementations but for some reason I am not able to cause them to behave as saga does. If it is a small problem I will submit these as substitutions (with appropriate abstractions) as possible simplification and performance optimizations\nIf you need any help with that please reach out to me. I'm happy to help.\nThe only \"convoluted\" part of the codebase you have directly mentioned are effect creators - which I don't really agree on. It's super thin abstraction and in the long run makes a code easier to read (at least for me) because you don't have to focus your eyes on repeated returned nested objects - which would span across multiple lines & would cause extra indentation being added. This part of the code is also super stable (because it's so easy) and we just don't have to come back to it very often.\nYou are mentioning also this:\n\nIf anyone can figure out why these do not work (which was the original reason for my post) I would be very appreciative.\n\nBut I'm not sure what do you refer to, could you be more precise?. Yeah, those helpers only output objects of certain shape.\n\n(as an aside i removed the brackets from the ['@@redux-saga/IO'] because they were unnecessary.(I believe that either way should work with the new syntax but i am not 100% certain.\n\nBoth should work.\n\nif I understand these calls and others they should be able to be translated directly in to message literals without all the extra code and abstraction. Perhaps there is a good reason to abstract the rest of the code base but it seems to me that put, get, takeevery, takelatest, cancel and fork combined with a simplified createMiddleware could be its own really simple stand alone repo?\n\nMaybe, not sure how would u like to simplify createMiddleware though, it still has to call runSaga & thus proc which is the most complicated part of the codebase. \nAlso wouldn't it be againt your original point? You were advocating merging files and now you are proposing to extract some of them to a standalone repo.. > 2 - the interrupt stack in browsers rarely have user code when these problems occur (they end up mostly in react or redux code modules)\nHave you seen our babel plugin that works with v1-beta? It helps significantly with showing the user code that actually triggered an error.\nYou could also try to use sagaMonitor feature to read what effects triggered which and visualize sagas in a tree manner.\n\nTherefore I am volunteering to (with the help of you and others ) to rewrite a subset so that saga is not the most complex link in the chain.\n\nThe offer to help is really appreciated, would be good though to establish some kind of a plan. What's your main concern? How a rewrite could fix it? How do u plan to refactor the code?. The code itself on the sandbox is not mine, I just have forked it and made it work with stdChannel, so other than that I won't discuss the logic there.\nThe difference between eventChannel and stdChannel is that later is unicast (single emit hits a single observer, supports buffering) and the latter is multicast (single emit hits all current observers, doesn't support buffering).\nstdChannel is used internally to emit redux actions to a saga runtime, but also can be used to connect any other IO (other than redux) with saga (as the integration layer between redux and the saga is actually very thing and the saga is complete independent of the redux) with { dispatch, getState, channel } config object (used with runSaga API).. Without providing sufficient information (ideally a repository with the issue reproduced) we are not able to help you any further, if you manage to prepare one we will reopen the thread.. @ronen thanks for the report, going to cut a new beta release today so u dont have to hack around this issue. Published. This is the typings issue & not the issue of redux-saga itself. As it's not actionable here and we do not have flow typings in the repository itself I have to close this issue. Please make an issue in flow-typed repo.. Without working code (or rather not working) we cannot do much to help you. Could u prepare a repro?. I meant the complete working (runnable) code in a separate repository or on smth like codesandbox.io .. Thanks for the change (@screendriver ) and for the review (@aikoven )!. > mean time probably we could release beta-v2. @Andarist ?\nYeah, want to do it this weekend \ud83d\ude03 . the new beta is out, gonna write down the release note some time soon. Sorry, but your issue is not clear to me - you'd have to describe it in more detail to get an answer.. To get fork's result u can do this:\njs\nconst task = yield fork(saga)\n// ...\nconst res = yield join(task). Yeah, exactly. Keep in mind that we are preparing v1 release and you'll have to use (once it's released) either:\n- join(tasks)\n- or join(tasksArray). Thanks for starting a discussion around this but the solution itself seems to be hacky (brute forcing the expected result) in its current state.\nThe whole problem lies in how createTaskIterator wraps the forked simple functions (not generators). If we try to comment out this part of the (refactored) code - https://github.com/redux-saga/redux-saga/blob/7895e4be95e414cf814068c9a2c490370dd07eb2/packages/core/src/internal/proc.js#L124-L135 we'll get 3 failing tests:\n- saga fork/join handling : functions\n- middleware's custom emitter\n- saga detached forks failures\nBy replacing the quoted code with this:\njs\nreturn makeIterator(() => ({ done: true, value: result }))\nthe only still failing test is the first mentioned one.\nTracing it to its roots we can find those commits:\n- test itself\n- tested implementation\nThe question is what is supposed to be a \"simple effect\" here? What actual use cases are covered by this behaviour of forked function returning an interpretable effect?\n. > seems that the intention was to cover a case when fork returns any kind of effect that we can interpret, especially a promise and an iterator.\nYeah, I suppose the promises are the most useful use case. Dropping support for this feature would force this:\njs\nconst fn = () => delayP(200).then(() => 'foo')\n// ...\nconst task = yield fork(fn)\n// ...\nconst result = yield join(task)\nto be refactored to\n```js\nconst _fn = () => delayP(200).then(() => 'foo')\nfunction* fn() { return yield call(_fn) }\n// ...\nconst task = yield fork(fn)\n// ...\nconst result = yield join(task)\n```\nSeems like the current behaviour for promises (and maybe iterators, although questionable they both probably should be handled the same way because they are in other parts of the code) is useful.\nNo other effect should be \"flattened\" like this, because it is not flattened in other scenarios:\n- when using generator syntax and returning an effect descriptor\n- when using a call effect on a function returning an effect descriptor\nIf we agree on that behaviour the mentioned part of the code could be rewritten like this:\n```js\n let shouldResolve = is.promise(result) || is.iterator(result)\nconst next = (value = result) => { \n   if (shouldResolve) { \n     shouldResolve = false \n     return { done: false, value: result } \n   } else { \n     return { done: true, value } \n   } \n } \nreturn makeIterator(next) \n``. Would u like to rebase this, implement my proposal & check if this is covered nicely by tests?.selectis just a wrappedgetState`. It can't be blocking because there is no \"releasing trigger\". I suspect that by the time ur select got yielded ur state-changing action didnt yet hit the reducers.. > The trigger is not, as I understand it, necessarily tied to state, but to the status of the command itself.\nExactly. And as select is just a wrapped getState it has no status - or rather it gets to fulfilled state right away automatically & synchronously.. You will have to walk me through this problem a little more.\n\nIt's synchronous, but the overall code execution of a saga containing select isn't necessarily.\n\nKinda depends on how you look at this, the saga code around select is executed synchronously. When you yield select effect, it is received by a saga runtime, it's executed (getState) and its result is returned to your saga synchronously, so the code line just after you yield select is executed \"right away\".\n\nWhat's the right way to handle rare cases where select takes long enough that it's not ready in time for the following lines of code that depend on it. For example, when using reselect to get some derived state which is computationally intensive?\n\nEven when using reselect you cannot \"request\" a recomputation and wait for the result asynchronously. reselect performs the recomputation synchronously.. Hi, not sure what do u mean - according to the youtube recording all previous requests get cancelled correctly. Maybe your API hangs on cancelled requests for too long? redux-saga certainly won't work for cancelled tasks to finish before returning your \"10th\" result.. This transform was removed because it wasn't actually used. redux-saga doesn't use generator syntax in its codebase so the advise from README is still relevant - you have to transpile your generators if you need to be compatible with older environments.. > @Andarist I see, now it makes sense :) so actually does it make any difference then? I just wonder why it is excluded, for build performance reasons?\nactually probably it doesnt matter and this exclude can be just removed\n\nBtw, sry for a little off-topic but this is why my initial question arised, would u advise to use babel-runtime in saga library addons?\n\nYou could use babel-plugin-transform-runtime with this such options:\njs\n['transform-runtime', { helpers: false, polyfill: false, regenerator: true }]\nUnfortunately when it comes to such things - supporting older browsers but providing also a more modern version there is no good practice worked out in the community, so you kinda either transpile to es5 or you just drop the support for ie11 and such.. I've 'discovered' why the exclude was in our babel config - it stops the babel from transpiling generators in our tests.. As @shinima said - localStorage should be primarily used for persistent data, the one that has to survive page reloads.\nAnd context is bringing some magic to the table and is supposed to ease \"argument passing\" through several layers of saga - for simpler use cases just use function arguments.\nIf you need a state that has to be accessible (& updateable) in different parts of your app this sounds as a perfect use case for redux's state.. There is no such option, channels are primitives for communication and the don't embed any special logic for different item types.\nIt seems that u might look for a join effect, that would require restructuring the given code a little bit though.. The babel plugin needs to be updated as well, cc @restrry - what do you think about it? seems like strings should be \"just fine\" for the SAGA_LOCATION too, right?. I would say integration tests for this should be kept in the core package - theoretically the babel plugin only aids the metadata being generated for us, but those things could come from any source. The more important thing is if the core package can read those than if babel plugin generates them correctly (the latter being covered by snapshot tests in the plugin package). I'm not sure though if this fix the other issue completely. I'd like to debug the reported issue to see if we can improve it any further.. There are no plans to support async in buffers at the moment, truth to be told I don't know how you would like it to work in combination with AsyncStorage.. I've merged ur PR, thanks for it! Keep in mind that debounce is available only in v1-beta. Thanks!. I actually want --ignore-scripts behaviour when bootstrapping - otherwise lerna will run i.e. prepare scripts in each package.. IMHO this complicates the API surface (lots of argument overloading) for a little gain. You could maybe create some eslint rule guarding you from this?. Thanks for sharing, but because of wanting to keep the API smaller we'd have to decline this request at the moment - especially that this is first time anyone requesting this.\nWe might reconsider this in the future though.. Thanks for the report, I'm planning to look into the issue - to see if we can avoid stack overflow when processing a large amount of sync consecutive effects.. I would like to explore this:\n\nswitch from recursion to an iteration - probably, but that could require significant code changes\n\nI know it would be a significant change, but it would fix some long standing issues. I'm not entirely sure yet how feasible it is to do that now though - need to make a code assessment.. Could u describe the faced issue in more details? My idea to fix that would be actually quite similar, tracking isSync in the closure and queueing tasks, why exactly it fails? Maybe knowing why would help figuring out how to tackle this properly.\nAlternative solution would be to use some kind of special completion value but that would force us to return each sync value (instead of passing it through completion callback) and probably would make handlers like runPutEffect more complicated. Well, this should be unrelated - but this reminds me that we root should be considered a regular task (its just being run from outside instead of being forked inside) and thus normal scheduling should apply for it. \nSo we should suspend the scheduler before running, I can dig up a test case for this as I had it somewhere, going to create a ticket for this.\nBut going back to the topic here - gonna play around with ur code when I find the time to and going to try pinpoint the problem. BTW does your queue ever becoming bigger than 1? . > Indeed I was able to fix the failed test with adding in https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/runSaga.js\nWhile this maybe fixes the failing test i dont think it should be considered as a proper fix - this means that the internal order of things has changed and this refactor should be completely transparent, otherwise I'm not confident if it doesnt break some other real world use cases that are not covered currently by our test suite.\n@shinima takes are indeed async as they act as watchers for actions, but their resolution is sync\nputs are completely sync, the only hard part of this problem is that they dont necessarily are executed right away when they are scheduled, but we have certainty that they will get executed in the same frame in which they are scheduled\nso in theory it should be possible at least for puts to benefit from stack reduction, it's only tricky to pull it off for some reason, probably because they might be handled because different tasks. The fix is the same, but the other PR targets a specific situation - it makes the behaviour of root sagas the same as forked ones.\nBut when it comes to \"stack flattening\" I believe the change should be transparent to the scheduling, nothing should really change as our desired change is solely avoiding a stack overflow, not changing how things behave.. I believe we should still try (if possible) to implement stack flattening on top of older code, without #1628 merged in. That way we'd be more confident that the change is indeed transparent to current use cases.. Stack flattening seems hard to implement, we couldn't do it quickly - it would require further exploration.\nMaybe what we could do is implementing a DEV counter and warn when encountering such pattern in the code way before it actually throws on its own? \ud83e\udd14 . If u want to fork ur requests, then you should join those tasks and make your select after the join resolves - that way it will run AFTER ur store got updated with fetched data. It depends on what do u want to test, using manual iteration testing (with .next()) u might test the anotherGenerator yielded effect. \nThere is no \"best way\" . Write your tests in a way to get more confidence in your code, but what gives you more confidence is somewhat a personal taste. Personally I would look around for more integration-like testing approaches than using the mentioned manual iteration way.. > When testing, anotherGenerator() should have tests of their own. But when testing the generator above, calling .next() takes me to the first yield of that generator but what I really want to get to test that anotherGenerator() has been ran.\nIf that's your goal then it's better to use yield call(anotherGen). I've looked into this now briefly, but I don't see how END relates to the problem - it's never dispatched in this scenario.\nThe chan.close is also never called automatically because yield actionChannel() just connects to stdChannel, but it doesn't actually register itself to the task, so when task gets cancelled it has 0 chance to close the channel (it simply is not aware of it).\nWe could track created actionChannels and close them on cancellation, but we would have to think through if there are any downsides of closing them automatically - like is there any possible scenario when one wouldnt want such behaviour? Remember that created channels can be passed around, but it seems to me that without abusing context feature they can only be passed down the task tree, so it should be quite safe to assume that if the creating task gets cancelled it should close its actionChannels (maybe we could extend the behaviour for all channels later, but it would require introducing a new effect for channel creation).. Yeah, you are right - we should cancel the taker on stdChannel in that case. Good thing is that this put is effectively a noop - https://github.com/redux-saga/redux-saga/blob/9523169a31d4ae90d00a6adc3482697478c2271a/packages/core/src/internal/channel.js#L176-L178 , but ofc it doesn't free up resources and we need to fix that.\n\nNot sure whether we should close the channels automatically \ud83d\ude15 . Users could close the channels manually in the finally-block if they want to ensure the channels being closed when exiting task.\n\nCan u think of any use case for actionChannel that would make auto closing undesirable?. fixed by #1606 , as mentioned we cannot call close automatically, but at least we've fixed a memory leak thanks to your report \u2764\ufe0f . In general I dont think this testing approach is worthwhile, it doesnt give u much confidence and is testing low level implementation details - so I'm not sure if we should make it easier by extending the core API.\nIn theory you could achieve this by creating ur custom version of take\n```js\nimport {take as sagaTake} from 'redux-saga/effects'\nconst testTake = (patternOrChannel, ...args) => {\n  if (\n    typeof patternOrChannel === 'function' &&\n    !patternOrChannel.hasOwnProperty('toString')\n  ) {\n    return { type: '@@TEST_TAKE', fn: patternOrChannel, args }\n  }\nreturn sagaTake(patternOrChannel, args[0])\n}\nexport default process.env.NODE_ENV === 'test' ? testTake : sagaTake\n``. Your problem is that u can just doputReceipt` outside of saga context, each generator call, yielded effect has to be executed by the saga.\nI've fixed your example - https://codesandbox.io/s/jl6jk1jzmw . If you have any more questions just ask. Slightly tweaked previously posted code - https://codesandbox.io/s/1yq1lx77jq . Seems to work \ud83d\ude09 the responsewins the race. I've updated the sandbox to work with beta.2 - https://codesandbox.io/s/1yq1lx77jq. It should be in the docs (we haven't yet updated them to v1). Most users do not use runSaga directly, so they don't have to worry about this stdChannel thing, but when integrating external IO this API makes more sense (is less confusing IMHO) than previous version with subscribe.. It depends on what u are trying to achieve exactly, but u shouldnt probably cancel sagaTask in this case, but rather take some action in ur exampleSaga & cancel created tasks more granularly.. Sorry, I have hard time focusing right now and Im not sure what your requirements are.\nI know that you have 2 actions and 2 workers (1 for each of the actions). Could you describe ur dispatch/cancel requirements?. When cloning the master branch and trying to test those it might not work. This is a lerna-managed monorepo, instead of installing modules in an example directory please run bootstrap script in the project's root. This should install all dependencies in managed directories - so after that you should be able to run the example.. I believe that this should be resolved by https://github.com/redux-saga/redux-saga/commit/71d2caa6a558036dfd526d2aac41734da587022b . If not please reopen the issue.. Thanks. I guess this can be CHANGELOG.md that we would add to the docs. We cannot close channels automatically, because you hold a reference to the channel and we don't how it is used.\nConsider this.\njs\nexport function* saga() {\n  const myChannel = yield call(createMyChannel);\n  const ac = yield take(myChannel);\n  yield takeEvery(myChannel, put);\n  yield fork(whatever);\n}. > Would that pollute the API too much? Anyways, I can always create my own generator that does that, no worries!\nI prefer to keep API surface minimal, especially given a fact that those kind of things are easy to implement in userland (as you have noticed \ud83d\ude09 ).\n\nAlso, perhaps it would make sense to add a little note in the docs to remind others that if they use takeEvery/takeLatest with a channel, it's their responsibility to close that channel (if they want to) when the task gets cancelled.\n\nThat's a good suggestion, would you like to provide a PR for this?. Thanks!. Should be also fixed with 0.16.1. I hope to release v1 this month, but beta2 is generally stable - it's just an evolution of the 0.x line, not a complete rewrite. Just pin your dependency to exact version and you should be fine.. yeah, my test case that I was supposed to find was really similar, ill probably use urs to create a PR for this \ud83d\udc4d . Thanks for the detailed explanation! I really enjoy when one takes time to describe their issue thoroughly. \nThat being said this sandbox is not an exact reproduction of your cause - codesandbox uses a custom babel plugin which wraps potentially infinite loops (such as while(true)) with a \"stack frame counter\" and throw the error if they detect such potential issue. It's implemented to avoid freezing the browser.\nWhen you refresh your sandbox you might see that it's not responsive for a while - until the injected code throws because of the stack overflow.\nThe other question is - why this error is not visible and why it doesnt seem to be caught by redux-saga runtime? I dont have an answer for that now, but I definitely need to dig into this.\nThe only thing that comes to my mind why this might behave differently across browsers is that each browser has different stack space dedicated for your JS, basically each engine might allow for various depths of recursion. \nThis still doesn't explain the issue in full - but maybe somehow stack limit exceeded errors are somehow handled differently and causing weird errors.\nIn any case takeEvery/takeLatest/etc in while loop is not a good idea and has zero chance of working properly in any environment. If it works anyhow in Chrome I'm pretty confident that saga runtime is in some inconsistent state because of this and might cause bugs in unpredictable ways.. So this happens because of this lonely finally https://github.com/redux-saga/redux-saga/blob/2aecdb310db8760ddd2c2513bf1cce7174c289d9/packages/core/src/internal/proc.js#L528 . It doesn't have corresponding catch and thus errors during initialization of a task are swallowed. It is used kinda recursively so I'm not yet sure how to fix it, because it's not as easy as catch+rethrow - we use callbacks to communicate about errors but in this case it's not really feasible.\nWe are discussing how to avoid stack overflows in comments of other issue, but we are still unsure how to do that properly without breaking existing code. Such solution wouldn't help you much though - as it would result in the code freezing the browser. Avoiding stack overflow here means that those would become possibly infinite loops.. #1592. Looks good, gonna merge it and release a patch version tomorrow. Would be good to test against it in master - rollup detects circular deps, not sure though if it's possible to fail the build automatically when such situation occurs.. I've released this as 0.16.1\n. I've added a test and wrapped root saga's proc in try/finally - in the same way runForkEffect is already, to keep the scheduler's state more safe.\n@shinima can't move suspend+flush into proc, because proc is also used for call effects which are not scheduler and because flush has to happen in runForkEffect AFTER the the task descriptor gets returned to the caller and not before that. TIL, the issue with stack limit exceeded is weird then as the error gets swallowed somewhere, but I had hard time debugging this because devtools became quite unresponsive with such deep call stacks :s. Kinda makes sense - engine might want to protect itself from infinite recovery, although it's really surprising as error handling becomes unreliable for this case. Going to close this, as it's obviously not something that we'd like to do.\n. Cool! Always was too lazy to fix this \ud83d\ude05 . I've released 0.16.2 with the fix, the only affected versions were UMD ones (in dist directory) - they are generally not supposed to be consumed with webpack. main/module entry points are more optimized for this.\nThanks for the report though!. All executes all its effects in parallel - immediately. If u want FIRST to\nfinish before executing next effects then do this:\nyield call(FIRST)\nyield all([fork(notFirst), fork(notFirst)])\nOn Fri, 12 Oct 2018 at 18:08, nuam notifications@github.com wrote:\n\nHello everyone.\nI want the FIRST to always be executed first, and the rest all how\nusually. How can I do it?\nSorry if it sounds stupid :)\nexport default function* myName() { yield all([ fork(FIRST),\nfork(notFirst), fork(notFirst), ]); }\nCan it resolve my problem?\nyield all([ call(FIRST), fork(notFirst), fork(notFirst), ]);\nI don't understand documentation. In documentation written about parallel\nexecution, but I need to block everything else while the first not finished.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/1634, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkq5zJgxzSU-bN0JJJv6VIikHKjs0ks5ukL5tgaJpZM4XZw0f\n.\n. Closing the issue then. Glad you have figured it out.. Sideways question - why do you need this feature? Seems quite odd to rely on it.. Could u provide a full working repro for your problem?\n\nThe mentioned entry from the changelog shouldnt affect you, it's about not interpreting returned effects from forked functions, as in\njs\nyield fork(() => {\n  return put({ type: 'TEST' })\n})\nThe TEST action won't be dispatched starting from 1.0.0-beta.3. adjusted the docs, i hope it wont be as confusing now. Just adding to what @restrry has said - u wont actually be able to handle the error (u cant recover), u just might be able to take some action based on the error (such as logging it to your backend service). The main rationale here is to ensure that select can get a state AFTER the action has a chance of changing the state in the reducers. This approach is used also by other saga-like libraries, i.e. redux-observable. \nWe had to decide on some logic there and this seems better for most cases, so unfortunately you'll have to work around it.. Thanks - you can create a PR with your dispatch -> channel change so we can discuss further, keep in mind though Im not convinced yet that we should follow this path.. @aikoven I've tweaked this PR - decided to create @redux-saga/types package to avoid cyclic dependency (i.e. lerna is giving warning when it encounters cycles).\nI had to tweak types a little bit - Effect is generic now, old Effect got renamed to SagaEffect and I've introduced AnyEffect for usage in some places. Could u validate that this OK? Unfortunately for some reason it broke all & race tests - I would really appreciate you taking look at this, because I'm unsure why it broke and how to fix it.\nI'm also having a small problem with END - I think the problem is that it was both a exported as type and as value, I've moved it to types package and tried to just reexport it but it seems that it's not equivalent to the previous situation - not sure how to proceed with this one either.. > So to fix this, you should change SagaIterator from IterableIterator to IterableIterator.\nDamn, I think I understand this. Would it be possible to create something like EffectCombinator to account for all & race and define AnyEffect differently - so the TS could know that if EffectCombinator is used it should use current Effect<any, any> (that would be only a fallback for non-combinator case)? Maybe that's possible with conditional types?. > To make it work, we could make a condition on the T of Effect, and if T extends 'ALL' | 'RACE', set a more narrow type for payload. Or, if you're ok with changing runtime stuff for the sake of typings, add another field to distinguish combinator from a regular effect.\nSeems like an additional runtime field wouldnt be that bad of a solution - I would rather do that instead of hardcoding ALL & RACE in \"generic\" EffectCombinator type.\nI'm toying with this in TS online playground but cannot make it work - I'd love some help with that if possible. Im currently stuck on a fact that SagaIterator is not parametrized and I need to have a type parameter to use conditional types. This leads me to the conclusion that I might not understand how this all should be tied together in the TS world \ud83e\udd14\nAfter a second thought - by introducing an additional runtime property we shouldnt be forced to using conditional types, going to try make it work without them. I think I havent fully understood how conditional types work - but from what I understand now they have to be used in combination with generics and I've wanted to use them in non-generic situation. THIS IS GREAT \u2764\ufe0f Thank you so much! Have you also reviewed the rest of this PR? Does those changes make sense to you? \nYou should probably also add yourself to the contributors list of the types package (and the core package too) if you want. Your help on those things is invaluable. I was concerned about naming too - so definitely something that I'd like to improve. This PR in regards to typings was rather a quick hack on my side, so I wasn't paying much attention to the naming as I couldn't figure out better names quickly.\n\nOff-topic: I would like to refactor the typings a bit before major release, but I've been too busy lately. Could you please ping me before it's final?\n\nSure, this is one of the last PRs I was going to make before releasing rc, but we got into some other refactors lately which we would like to finish before releasing it - it shouldnt take much time though. Anyway - I think we can still change TS typings during RC time as TS typings are just additional thing that we support, but its not part of the strict core. We can treat them as DefinitelyTyped types which only happens to live in this repo.. The question is what are your reasons for joining the cancellable task? If you only want to be notified once it gets finished (no matter the result), maybe you could leverage\njs\nyield call(this.currentlyRunningTask.toPromise()) // in redux-saga 0.x it should be this.currentlyRunningTask.done. Flow typings are not maintained in this repository. They are located here - https://github.com/flow-typed/flow-typed/tree/master/definitions/npm/redux-saga_v0.16.x/flow_v0.56.0- \nThe best way to move forward would be to prepare a PR fixing those typings and sending it there.. I've made some changes - gonna probably merge this in in a moment but you can always comment it when you will have time and we can revisit/correct things.. Is this PR/branch supposed to target effectRunnerMap branch and not the master?. Could you also rebase this?. I still dont like that mainTask is using properties and task is using getter methods - but we can postpone changing this until we explore merging statuses into a single variable.\nAlso - I would explore trying to hide mainTask as implementation detail of the task, or the forkQueue. It's slightly confusing thing at maybe it could be hidden? Im not sure about it - just a thought I had right now.. you could build redux-saga locally, do npm link in redux-saga/packages/core and do npm link redux-saga inside of your other repository, that would make your repository to use local version of redux-saga\nthat said - I'll try to look into it too, but not sure when I will have time to do so. This works because technically you can yield promises (but its not quite recommended, its better to use call effect).\nPersonally I would do this:\njs\nfunction readAsText(blob) {\n  return new Promise(resolve => {\n    const reader  = new FileReader();\n    reader.onload = () => resolve(reader.result)\n    reader.onerror = reject\n    reader.readAsText(blob)\n  })\n}\n// ...\nconst content = yield call(readAsText, blob). No, there are no other strong benefits. Redux-saga conceptually deals with effects and promise is not an effect, so generally it's advised to avoid yielding them. . This just an example showcasing how saga performs as sort of state machine. It's not intended to cover all edge cases - it really all depends on how do you structure ur sagas and actions.. Thanks!. > yield select does not work in unit tests with the runSaga method. Apparently this is a known issue.\nIt's not known, I don't see why it wouldn't work. Could you prepare a simple codesandbox showcasing the problem? \n\nI'd rather not test my sagas as generators.\n\nI definitely applaud that \ud83d\udc4d \n. While it's true that put is a dispatch this is slightly more complex. To make various fork+take+put scenarios work we use a simple scheduler under the hood which queues the \"nested\" puts - that whole queue gets processed within single stack frame, but it means that a single put might not be executed right away.\n\n\nIs it safe to assume, that the new store is ready after yield put(...)?\n\n\nIt is safe to assume that.. Thanks for pointing this out but we are aware about this issue - we are using that module temporarily because we want to support both babel@6 and babel@7 in our babel plugin. Using that module made it slightly easier for the time being from what I remember.. How many times this has happened to your app? Which useragents have been associated with this?. That's really strange - might be some obscure v8 engine bug :s If the source map is correct then it means that most likely it has thrown on \"missing\" isEnd which is statically available, its never redefined and its always a function.\nI have a strong suspicion that you are using webpack older than v4 and if you are using webpack@3 then you are not using ModuleConcatenationPlugin in your production build. Could you confirm this guess?. Do you disable it somehow? (it should be used by default in production mode in webpack@4). Ok, so part of my guess is wrong about this - I'm wondering how reliable those source maps are (I've seen some misplaced infos on Sentry before). \nYou most likely use ModuleConcatenationPlugin and on that line there is nothing that should even reference Object to cause such an error. This bug is obscure - I doubt we'll be able to investigate it further without additional information, repro case etc (which most likely we wont get, as you have encountered it only once). \nYou could try to use redux-saga onError option to log this error with some additional info - just to ensure that this thing happen inside the saga (im cautious about trusting those source maps).. was the bug reported to sentry through that onError handler?. I would classify this as impossible then - we won't be able to act on it anyhow as it seems it just can't happen and that sentry might be reporting some false positives on this one.. Thanks! For now I'm not going to close this issue, but let us know if you find more about it.. It's handled like this because errors are bubbled up through the sagas (so you can catch the error in a parent with try/catch) - so that check is basically supposed to mean \"call onError when there is no parent that could catch this\". Could u prepare a simple condesandbox.io for us to take look at that would demonstrate your issue?. Just adding to what @restrry has said - they should still be received by the onError option and I believe they are right now - so if you are seeing something different it would be great to get a codesandbox showcasing your problem.. > The only thing I can't get is why in rootSaga I can intercept bubbled errors from forked tasks with a finally block, but not with a catch one.\nNot sure what do u mean by that.\nThe problem with forked sagas is that after forking the forking generator is at unknown (to us) state - we can't inject an exception into it, because it might be already at the point past any catch clause. That's why those errors are not catchable in the parent saga. . Sorry, I still dont quite understand the problem - could u prepare a codesandbox showcasing it? It would ease getting us on the same page.\nI think u might mix block and non-blocking effects in your try clause, but Im not sure without looking at the concrete example. finally shouldnt work either (at least not fully) - that's why I have requested the demo, because it would make easier for me to explain you why this works in a way it works.\nConsider this:\n```js\nfunction* foo() {\n  yield delay(0)\n  throw new Error('err')\n}\nfunction bar() {\n  try {\n    yield fork(foo)\n  } catch (err) {\n    console.log({ err })\n  } finally {\n    console.log('finally')\n  }\n  console.log('after try/catch')\n}\nAt the time when the error gets thrown the bar saga is already AFTER try/catch/finally, so its not possible to have the catch (and finally) clauses executed in response to error. Finally is executed though here because its just how finally works - it's executed synchronously after your code exits the try clause. eventChannel. \ud83d\udc4c . Thanks!. @aikoven do u know when you will be able to refactor those typings? (no pressure - just asking). Sure thing :) . Done in #1695. There is currently no plans regarding including this in the core - I believe it's too specific and should be implemented in your app or as npm package if you want to share it with the community. Saga's effects are nicely composable so you can leverage that instead of relaying on us providing it for you. Hope this makes sense for you.. Why it has to be a better way? What you are doing is building a specialized higher order thing, based on provided primitives - this is composition and I would say that it's actually the best way of solving the problem here :). Without providing a runnable example showcasing the problem we won't be able to help you. That being said - I'm 100% sure it's a problem with your code somewhere.. Thanks!. Early experimentation - https://codesandbox.io/s/82vmz6r198. yeah, this hook works only for component-specific sagas, if you want to register long running tasks you have to implement some kind of provider on top of your app which would receive registration requests, u'd have to rethink when such saga should die though. . Wouldnt this work for you?js\nconst createSelectorChannel = (selector, buffer) => call(function() {\n    const chan = channel(buffer)\n    let previous\nyield spawn(function*() {\n    try {\n        while (true) {\n            yield take('*')\n            const result = yield select(selector)\n            if (previous !== result) {\n                previous = result\n                chan.put(result)\n            }\n        }\n    } finally {\n        chan.close()\n    }\n})\n\nreturn chan\n\n})\n```. Usually it's after - if you dont have any async middleware after saga's middleware. We first pass the action to next middleware (so it most commonly reaches the reducer first) and only after that we emit an action inside the saga runtime (so take effects can resolve).\nSo you should get a state AFTER the actions get processed by the reducer.. 1. Yes, this wont change.\n2. Sure thing, go ahead :)\nOn Fri, 30 Nov 2018 at 14:45, Ken Powers notifications@github.com wrote:\n\nAwesome. That only leaves me with two questions:\n\nIs that order of execution something that the redux-saga\n   maintainers would be willing to commit to? Meaning if it changes that would\n   be considered a breaking change which would constitute a major semver bump?\nWould you mind if I were to distribute that code snippet as an NPM\n   module under the MIT license?\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/1694#issuecomment-443207744,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMku-UNSni1gXyDUIh-_GS0aKZkfGAks5u0TaOgaJpZM4Y5ub2\n.\n. I've added a refactoring commit - please take a look.\n\nI'm trying to bookkeep the sagaStack separately from passing the real error around. This allows me to just pass the thrown thing without converting it back to the real thrown error before passing it to user's code.\nThis also has a nice benefit of saving over 100 bytes \ud83d\ude03 We might be able to sit under 6.5kb now.\nTests are failing now, because I don't reset the sagaStack - Im wondering where is the best place to do that - seems like we have to do it at 2 places:\n- after user handles the error\n- when we stringify the sagaStack (its passed to onError then and we know it wont be used anymore)\nGonna try with that ^ in a moment.. Tests are failing, but it seems that they should actually pass (expected results are wrong?). Those failing tests have no info about crashed effect in the sagaStack - not sure how exactly I have affected this, but it seems that current behaviour is more correct, right?\n. Makes sense. Before going further with this - WDYT about current implementation?. I agree that in general this is a weird pattern - but sometimes it comes really handy. Fun fact is that React uses such things heavily \ud83d\ude09 \nI've fixed tests by stretching the singleton usage even further and I'm not that happy about it, but couldn't figure out quickly how to fix it in a better way. I've added an explanatory comment about it to help the future readers, if anybody comes to better solution - I would be more than happy to merge it in. It's an implementation detail though so I'm going to merge in this PR in a moment.\nThis means that we are ready to release release candidate version this week \u2764\ufe0f Gonna wait for improved TS typings before releasing stable v1 but there is generally nothing else to be done here - implementation-wise. The only thing we need to do before releasing v1 is figuring out how to deal with README file. Im not sure but maybe ur api call fails synchronously? Could you check this:\n``js\nfunction* fetchImages() {\n  let randomWord = require('random-words')\n  let API_ENDPOINT =https://api.giphy.com/v1/gifs/searchapi_key=MYKEY&q=${randomWord()}&limit=12`\nwhile (true) {\n    try {\n      const res = yield call(() => axios.get(API_ENDPOINT))\n      const images = yield res.data\n      yield put({ type: 'API_CALL_SUCCESS', images })\n    } catch (e) {\n      yield put({ type: 'API_CALL_FAILURE', e })\n    } \nyield call(delay, 5000)\n\n}\n}\n```. Without giving a link to the repository (or codesandbox) with the issue reproduced im afraid i wont be able to help you. I'm not sure what do you mean by:\n\nWell at long last I got it figured out. I realized that yield takeLatest(API_CALL_REQUEST, fetchImages) only calls the function, but doesn't pass the data on to the store. \n\nCould u elaborate?\nThe given snippet looks weird, because:\n1. it first creates takeLatest task (because you have yielded it)\n2. then it creates 2 tasks in parallel - one of the returned value from takeLatest (co the task object) and one call(fetchImages), so basically the task is returned as is and the call gets executed\nThe more correct form would be:\njs\n export default function* giphySaga() {\n  yield all([\n    takeLatest(API_CALL_REQUEST, fetchImages),\n    call(fetchImages)\n  ]);\n }\nbut as both refer to fetchImages I strongly believe this is incorrect. Could you describe what you are trying to achieve?. This should work https://github.com/MirelesCloud/nextjs_boilerplate/pull/1/files \nI have not run this though. You probably have not initialized your state properly before making your request with saga.. Actually delay is an effect now (in upcoming v1), so the docs are correct.. I plan to release release candidate of v1 this week and on your place I would wait for it. I would use onError option to createSagaMiddleware to listen for all errors and show a modal from there (i.e. by dispatching a redux action there).\nsafe wrapper can be easily implemented in userland:\njs\nconst safeCall = (saga, ...args) => call(function* () {\n    try {\n        return { err: false, result: yield call(saga, ...args) }\n    } catch (err) {\n        return { err: true, result: err }\n    }\n}). docs are merged into the master branch, as to the breaking changes and stuff the best thing you can follow is our release notes here https://github.com/redux-saga/redux-saga/releases . As you can see there are really not that many of breaking changes, v1 is just a slight evolution, not the revolution. Just use the store reference from the outer scope. ```js\nimport { createStore, applyMiddleware } from 'redux'\nimport createSagaMiddleware from 'redux-saga'\n// ...\nimport { helloSaga } from './sagas'\nconst sagaMiddleware = createSagaMiddleware({\n  onError: () => {\n    store.dispatch({ type: 'SET_ERROR_STATE' })\n  }\n})\nconst store = createStore(\n  reducer,\n  applyMiddleware(sagaMiddleware)\n)\nexport default store\n``. I think dispatching an action here (to trigger some UI change) is fine but yeah - this should be used mostly for logging purposes / terminating the app. You can't recover there, ifonError` gets called your app is already in unpredictable state and it's better to gracefully destroy your resources and fix your bug asap.. Sure, good idea \ud83d\udc4d . You can easily built that on top of existing APIs. You just need to think about your system in explicit manner without hiding implementations in some global handlers implicitly.\nJust built a generic request saga which you can use whenever you'd like to use fetch (or similar). The problem lies in that only you as app developer can know which errors are expected and which are not. We pass only completely unhandled errors to the current global onError and u can log all of them there.. technically u might be able to implement this with effectMiddlewares feature in v1, not something I would personally do in my app, but if you want it then I think it's doable. I think we can close it. If you have any further questions feel free to open new issue.. If you have synchronous communication like this between sagas you can only perform a synchronous effects (ie select) before you setup take for the SUB_PROCESS_SUCCESS. \nIf your success response is always synchronous you dont even have to take it though. // EDIT: i guess you need it if you want to receive some result from that take. > How do I know which effects are synchronous? It does not seem to be explicitly mentioned in the docs. For some it's clear (e.g. select), but for others not (e.g. put, put.resolve, cancel, call,...).\nWhat can be async? call/apply/cps (but they dont have to if called things return synchronously), join (if joined task is running when joining it), take (always when taking redux actions & when taking from channels when there are no buffered items on the channel), delay ofc (as its just bound call). And ofc combinators race/all when they contain mentioned effects. fork/spawn are synchronous but they might start asynchronous tasks, the effect itself resolves with task instance synchronously.\n\nEDIT: I have found, for instance, that yielding a put does not necessarily immediately return control back to the yielding saga, and that it may transfer to a different saga.\n\nThat's true, but a line after put gets executed synchronously in the same call stack, it just might not happen immediately - this is rather an implementation detail, unless u do really weird stuff you should be able to consider it as immediately returning effect.. > To make it more concrete: does redux-saga guarantee this to not throw an error?\nYeah, I cant think of anyway how that would broke - dispatch resolves take in takeEvery which in turn forks callSaga, select gets executed immediately (and resolved ofc). So this should be considered 100% safe.\nYour first demo thought will throw. put/dispatch gets executed in the same frame but not necessarily right away - dispatching START suspends the scheduler, no put will actually get executed until START gets fully processed. So you basically schedule 3 puts, but all of them executes after START resolves.\nThe whole scheduling thing is slightly tricky, but in general you shouldnt be much concerned with it.\nWe try to emulate concurrent programming with threads (kinda), if you consider all a truly concurrent effect it makes sense that state read after put might be different, because state is shared memory accessible to all threads/sagas.. 1. not sure, gonna go through latest changes when preparing release notes for rc-0 this week.\n2. yeah, i dont think we have to document this change much\n3. it's indeed an implementation detail, it's accessed as task's property in runCancelled effect though - maybe it doesnt have to be? I think statuses of task & mainTask are kept in sync right now, so this could be checked directly on task rather on task.mainTask, cc @shinima . mainTask is special anyway so maybe we should just transition it to CANCELLED state when the task gets cancelled?. I'm investigating switching to task.isCancelled() in runCancelledEffect. The problem is in order of things when propagating the cancellation. I'll report back when I will have more concrete findings or a solution for this.. Ok, so:\n- when propagating cancellation mainTask gets cancelled here https://github.com/redux-saga/redux-saga/blob/1b3ea61b41d322f28d288a32bc0eb931f430cb5e/packages/core/src/internal/proc.js#L85\n- it first calls iterator.return which might yield cancelled()\n- and then calls a continuation and it reaches end here - https://github.com/redux-saga/redux-saga/blob/1b3ea61b41d322f28d288a32bc0eb931f430cb5e/packages/core/src/internal/newTask.js#L46\nI believe we should switch task to CANCELLED state in the end when receiving TASK_CANCEL, otherwise it will become DONE which is really confusing - after all the task received TASK_CANCEL and its mainTask is cancelled.\nThat's a minor thing though - because how TASK_CANCEL is propagated & when runCancelledEffect gets called it's hard to refactor this, because we want to preserve in what order things are handled. \nI propose refactoring this - https://github.com/redux-saga/redux-saga/blob/1b3ea61b41d322f28d288a32bc0eb931f430cb5e/packages/core/src/internal/newTask.js#L119 to:\njs\nisCancelled: () => status === CANCELLED || mainTask.status === CANCELLED\nArguably other methods (isRunning & isAborted) should also be adjusted (if needed - need to rethink each case by case) to account for mainTask status. \nWDYT?. Could u rebase?. \u2764\ufe0f gonna drop RC this week! Thanks for all the work you have put into the project. Yes, errors propagate through the \"saga stack\". So if you inner doesnt handle it the outer saga has a chance to handle it. This applies to call/apply/cps effects (and other blocking ones, i dont mention here ie select as u generally dont want ur select effects to throw). takeEvery is basically fork(internalTakeEveryImplementation), errors caught in forked tasks cannot be caught like this.\nWhy? Because of this:\n```js\nfunction* foo() {\n  console.log(2)\n  yield delay(0)\n  console.log(4)\n  throw new Error('test')\n}\nfunction* saga() {\n  try {\n    console.log(1)\n    yield fork(foo)\n  } catch (err) {\n    // never\n  }\n  console.log(3)\n}\n```\nWhen the error in forked task gets thrown your parent saga might be already outside of the try/catch block. You have to update redux-saga across whole project. At the moment you are using v1 runtime but 0.16 effects.. They are still part of the core package, but your redux-saga-requests package has dependency on 0.16 and take imported from that directory uses this 0.16 package (according to regular resolution algorithm).. Yeah, shape of the effect object has changed slightly but it has obviously major implication for our runtime code. You had to import take from 0.16. Please try to update to v1 everywhere in that monorepo, if it doesnt help you - then please prepare a branch I can take look at.. Thanks for the great work @aikoven  \u2764\ufe0f . Thanks for the thorough comments! \u2764\ufe0f I'll try to analyze this some time later to give proper feedback back.. Ok, so it seems that a simple tweak to:\njs\ntask.isCancelled = () => status === CANCELLED || (status === RUNNING && mainTask.status === CANCELLED)\nshould do the trick, right?\n. > How about add a method (e.g. isMainCancelled()) on Task object? Then we can call task.isMainCancelled() in runCancelledEffect(), and then we can remove mainTask property from the Task object. It should be much more straightforward than hacking task.isCancelled().\nWe could do that, it's better than exposing whole mainTask. I'm only worried that whole notion of mainTask is an implementation detail and it might be better to hide it entirely. WDYT? cc @restrry , let's reach consensus on that, I'm not overly attached to either option, so let's speak up with your preferences.. Im not graphic designer either, if anyone makes a square version of our logo then I'll merge it in. . Super cool \u2764\ufe0f !. https://redux-saga.js.org/docs/advanced/Channels.html#using-channels-to-communicate-between-sagas. ```js\nfunction* uploadSinglePhoto(photosChannel) {\n    while (true) {\n        if (photosChannel.isEmpty()) {\n            return;\n        }\n        const photo = yield take(photosChannel);\n        yield call(uploadSinglePhoto);\n    }\n}\nfunction* uploadAdminPhotos(action) {\n    const photos = action.payload.slice();\n    const buffer = buffers.expanding();\n    const photosChannel = channel(buffer);\n    photosChannel.isEmpty = buffer.isEmpty;\nfor (let i = 0; i < photos.length; i++) {\n    yield put(photosChannel, photos[i]);\n}\n\nconst workers = yield all(Array.from({ length: 5 }).map(() => fork(uploadSinglePhoto, photosChannel)));\n\nyield join(workers)\nphotosChannel.close();\nyield put({type: 'ALL_PHOTOS_UPLOAD_SUCCESS!!'});\n\n}\n``. Oh, I've used v1 semantics and it should beyield join(workers), but in v0.16 you are right -yield join(...workers)`. It's mentioned here in Changed section.\n\nAlso, I think you should have an \"Upgrade\" link from v0.16 to v1 that will summarize all the upgrade processes needed. WDYT?\n\nSure - I'll prepare a single list before releasing final v1.. that's true - but it's quite cumbersome to create a buffer on ur own each time when u need this. The public, recommended way, of importing both redux-saga and effects would still be:\njs\nimport createSagaMiddleware from 'redux-saga'\nimport * as io from 'redux-saga/effects'\nThose entries would just proxy to @redux-saga/core & @redux-saga/core/effects (respectively).\nI don't want to remove old entries (or recommend switching to new ones) because it will cause huge confusion for newcomers (there are plenty of redux-saga resources out there in which you are going to find old entries being used), and advantages of dropping old or recommending new ones are just too low.. it should clear the channel - https://github.com/redux-saga/redux-saga/blob/f55c6d2f34afd86962424303dfa72dda18a9f34d/packages/core/src/internal/buffers.js#L34 . In fact it's even implemented with take under the hood. while flush is blocking, its a synchronous effect - if you get more than 1 action put into the channel when your saga is blocked on the delay then actions should be non-empty array. Could you describe your exact use case? It's hard to give advice without knowing more.. I believe your snippet should just work with builtin buffers, could you showcase your problem in example on https://codesandbox.io/ ?. How would you expect to consume this bundle (assuming we would add it)?. Im still wondering how do you plan to consume it - do you use any bundler? redux-saga has no peer dependencies but if it would - how would u consume them (they would be referenced as npm modules in the source)?. But how do u access that es bundle? do you copy the file from node_modules? or do u just serve node_modules content when receiving requests?\nDo you use react?\nDon't take me wrong - I'm not opposed to merging it (in some form). I just try to understand the problem at hand better.. So no dependency of yours have any dependencies? \n\nWe do not use React. Just good old JavaScript with some libraries (like yours).\n\nInteresting, out of curiosity - how do you use redux-saga? Most commonly its used with react, i'd love to hear your use case :). My question was more about how do u technically use it (how browser knows what file it should request etc) rather how combine saga with other framework. Its really cool that u have found use for it outside of react!\nIm nly concerned about understanding ur build setup, seems like u have to manually maintain mapping between node modules names to disk files? And parse imported files to rewrite imports to those (during build)? \nDont u have currently a waterfall of requests on the startup of ur app? \n. > We just don't want a dependency on webpack.\nThere are other bundlers out there though, seems like you are going to have to reimplement some existing stuff - I'm not the one to judge though.. This will need a rebase now - please move the new rollup configuration to this file: https://github.com/redux-saga/redux-saga/blob/6d7cb99cf489da0b4de72eee44b7333d3c8f2cba/packages/redux-saga/rollup.config.js. @TimvdLippe @martijnjanssen I've merged with upstream master & tweaked the build to output those bundles correctly. From my POV this is ready to be merged (I'd appreciate second look though).\nOne question got sort of unanswered - are u aware of the fact that generated chunks (not entry files) contain a hash in their filenames and you will have to handle it? redux-saga update is probably going to change the hash each time\n. Well - I'm still unsure when you rewire import statements, so maybe it just works. What I meant is that both those files reference at the moment \"./chunk-18a48331.js\" - you can check this out by looking at the beginning of both files. . Ok, merging this then \ud83d\ude09 . Yes - you are right that forks are probably not technically needed there, but by using forks you are allowing yielding generator to reach its end (because task descriptors will be returned to the yielding generator and it will proceed to next line, while with calls it would block indefinitely - waiting till all watchers end). that's also true, using all saves a runtime roundtrip (saga can just handle them all internally in one pass instead of going back & forth from the runtime to your saga to receive new effect to be handled) - ultimately it doesn't matter, i doubt it's even noticeably faster or anything. Still I like to group them with all because it's slightly more evident to me what's happening.. The issue is not related to redux-saga, ESM imports are static & read-only. I think you just have to use jest.mock appropriately.. Thanks!. I've updated docs around this API -  https://github.com/redux-saga/redux-saga/commit/466c5a4f8e941fb0f30a6e6dfb40310883876856 . Keep in mind that it was adjusted to v1, which we are going to release soon. \nIs this now clearer or do you feel something still could get improved?. It's available in v1 - which is at RC stage right now.. The most likely answer is thar you don't pass enough arguments to your addPromotionRequested. redux-saga doesnt do anything special with your actions - it just resolves takes and let you deal with received action.. This should work - please provide a repro case on codesandbox.io so we can help you.. > Or these are the parts where I should split the sage into multiple stages?\nProbably best solution - you should just handle the initialization logic (after refresh) within the saga, you can't just jump automatically jump to arbitrary point of generator execution.. Yes, we know - that's why it is listed in https://github.com/redux-saga/redux-saga/releases/tag/v1.0.0-beta.3 \"Fixed\" section.. could you prepare a codesandbox.io showcasing the problem?. From what I see the @GuillaumeCisco has handled the problem on his side (inside redux-saga-injector) and originally reported issue actually works as expected - therefore Im closing this issue as resolved, feel free to open new issues though if needed. I think it's already updated - if you can please check it in the git repository, not on the website. I'm planning to redeploy docs website after doing a patch release which I'm sort of preparing right now.. @Zaitsev which version of redux-saga is affected?. We plan to release v1 this weekend which has those typings, so Im afraid we wont do any more v0.16 releases (unless you want to prepare a PR against this line yourself). This is an issue that should be reported in redux-saga-test-plan. This is fixable on their side - no need to export those internal stuff from redux-saga. Thanks for the report - I've fixed this link, this section is available under https://github.com/redux-saga/redux-saga/blob/v1.0.0/docs/advanced/UsingRunSaga.md. Could you provide a self-contained reproduction case? Preferably on something like codesandbox.io. Just to repeat myself:\n\nCould you provide a self-contained reproduction case? Preferably on something like codesandbox.io\n\nYou must understand that any maintainer's time is really limited (I have a day job) and I just can't try to replicate your issues on my own. It would be way faster if you could prepare a repro case and then I could dive straight away into debugging and fixing the issue.. Glad you have figured it out!\n@JacquesBonet could you check if that might be your problem as well?. You have to have import { delay } from 'redux-saga' somewhere, but it's available as effect now - so you can import it from redux-saga/effects. Glad you got it working. Closing this then. Could we maybe use conditional types and do some fancy stuff like:\njs\ntype Unpack<T extends ActionTypes> = T extends Array<StringableActionCreator<infer A>>\n  ? ActionPattern<A>\n  : T\nNote that actual type names are probably different, I'm not using saga together with TS and I dont have correct type named remembered by heart.. Thanks for the report! Could you prepare a repro case? It's hard to debug this without sample code which crashes when being transformed.. @dorian-marchal could u describe your use case? why do you want to restart your saga?. Thanks for pointers, they are really helpful. I've commented in the next-redux-saga repo with a question. Hopefully we'll be bale to fix this soon.. As to the showcased problem - instead of using .done getter you have to call .toPromise() method.. Hi - sorry for not responding back earlier.\nI'm unsure if this is in scope of the core library. Would love to see community-maintained addons package and maybe this would fit such perfectly?. Thanks!. @rybon could you prepare a simple repro case showcasing the problem?. Thanks \u2764\ufe0f . Thanks!. We could consider it, but unfortunately the proposed API would be a breaking change right now.. putResolve will wait for actions which result in a promise being returned from dispatch, not for promises embedded within action object. https://github.com/redux-saga/redux-saga/blob/50efcd293414d6c73db93d09faebaadb47b06387/packages/core/tests/interpreter/put.js#L67-L72. Thanks \u2764\ufe0f . Seems the same to me, you are probably looking for:\nexport function* getImages(action) {  \n  try {\n    const data = yield call(api.get, `/${action.payload.siteName}/images/${action.payload.groupName}/${action.payload.currentPage}`);    \n    yield put({ type: \"FETCH_IMAGES_SUCCESS\", payload: data });\n  } catch (error) {\n    yield put({ type: \"FETCH_IMAGES_FAIL\" });\n    console.log(error);\n  }\n};. Thanks!. Thanks. Thanks \u2764\ufe0f . Actually both APIs are supported - you can pass an object or an array to race. Thanks!. > (which on web atm i believe would translate to Promise.resolve().then(...) although i havent kept up with things).\nThis is a nice point of reference for this problem~:\nhttps://github.com/jamiebuilds/tickedoff/blob/99129560b3b788188c575f907488a3922b17e604/index.js\nAs to your proposal - I'm not against adding things to the core, but as a rule of thumb I would like to add only things that makes sense and which cannot be implemented in userland OR which benefits greatly from being in the core.\nSeems like the whole proposal is simply about executing things ASAP but not in the same stack trace and this seems like a simple saga composition. What would be the argument in your eyes behind implementing this in the library itself?. Thanks for the PR, I believe though that the issue should be resolved by this https://github.com/redux-saga/redux-saga/commit/71d2caa6a558036dfd526d2aac41734da587022b . . Could you link to some resources about this? I've never heard about this thing. The CI tests got fixed in https://github.com/redux-saga/redux-saga/commit/3bcfbd535e3c01c9a616e1f69c325c6406b713ca . If you believe there is still some work to be done here please open a new PR. Thanks for the PR, I left some minor comments to be addressed . Its available in @redux-saga/testing-utils. You are more than welcome to improve the docs in this regards.. You would have to share some logs to get help. You mention using such form:\njs\nyield race({\n  someAction: yield take(...),\n  cancel: yield take(...)\n})\nwhere it should be \njs\nyield race({\n  someAction: take(...),\n  cancel: take(...)\n}). Thanks for clarifying this - it seems that this is some problem in redux-saga-monitor. Do you use it?. Yes - seems that it's sagaMonitor implementation is broken somehow https://github.com/infinitered/reactotron/blob/master/docs/plugin-redux-saga.md#step-2---plugin-to-redux-saga. Please provide a runnable repro - we just don't have time to prepare a dev environment ourselves for each issue reported.\n. We have type tests here - https://github.com/redux-saga/redux-saga/tree/928c6fbdcd73405690a8f3ef1483f172c3a49bdf/packages/core/tests/typescript . Please add tests so we can know the context of this change.. CI failure seems to be unrelated, thanks!. That's true I guess - but not sure what we can do about it right now. This would be a breaking change and I would like to avoid those if we can. Implementing support for this would also cause some not so pretty code included in those helpers as this is a special case.\nThe best what we could offer in terms of APIs would be:\njs\nyield takeLatest([channel, '*'], worker);\nAnd that's only because channel is not a valid \"pattern\" so we could check first argument against being an array and later agains being an array of patterns or this channel + matcher tuple. If you are willing to implement this feature - we would merge this in, but Im afraid we might not have time resources to do this ourselves at the moment.. Truth to be told - I dont understand the purpose of any of this. . Could you describe the purpose of this PR? It changes a lot of files and I have no idea why \ud83d\ude09 . > * Should context be persistent between saga executions?\nYes - if you dont change it.\n\n\nCan forked saga change context of parent?\n\n\nNo. Only in mutable manner.\n\n\nWhat is use case for context in general?\n\n\nStoring top level stuff, often not simple data that can be stored in state and having it accessible within whole saga subtree (thanks to context). It helps to avoid passing same arguments everywhere.. Thanks for pointing out there is a problem with this example - your fix was not a proper one though. \nYou can check out how I've fixed this reference problem here and also had some build/setup issues which I've fixed here.. Using [] directly was supported in the past - it got deprecated long time ago and removed in v1. You'd have to implement this yourself, something like:\njs\nconst allSettled = effects => all(effects.map(effect => fork(function* settle() {\n    try {\n        return { error: false, result: yield effect }\n    } catch(err) {\n        return { error: true, result: error }\n    }\n}))). Glad to hear that :). Glad to hear that :). Thanks \u2764\ufe0f . Thanks \u2764\ufe0f . If i read the code correctly - we already support this, but it's not documented nor included in the typings. Right?. If i read the code correctly - we already support this, but it's not documented nor included in the typings. Right?. @gustavopch would you be interested in working on this and providing a PR?. @gustavopch would you be interested in working on this and providing a PR?. Ye, gonna amend it in few minutes\nOn Wed, 3 Aug 2016 at 13:02, Yassine Elouafi notifications@github.com\nwrote:\n\nIn docs/advanced/Channels.md\nhttps://github.com/yelouafi/redux-saga/pull/464#discussion_r73314259:\n\n-export function* saga() {\n+function* pong() {\n-  yield call(delay, 5000)\n-  socket.emit('pong')\n  +}\n  +\n  +export function* watchOnPings() {\n-  const socketChannel = eventChannel(emit => {\n\nIt's not possible to test this form. Can we extract this into a separate a\nfunction like createWebSocketChannel and then call it using a declarative\nform yield call(createWebSocketChannel)?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/pull/464/files/0c5927d0625bcce6e70238c70084592c9a9a8a65..2217327829bf6420bcf262ffd278acb3955a0f1e#r73314259,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkmcXZtcJ-hTvoylReZfUC8jwSL7oks5qcG8WgaJpZM4JZkn9\n.\n. @yelouafi changed\n. Ye, you are right ofc. ;) I just remember now that's the reason I had to create buffer on my own and pass it to the channel, so I could reference it later and take directly from it instead of the channel, to achieve this flushing in my app.\n. maybe add here synchronously on the end of the sentence?\n. What do you mean? Just indicating that they can be utilized by the user if he wants to and thats it not mandatory?\n. ah, ofc, you are right, didnt catch it while second reading, thanks!\n. added, thanks \ud83d\udc4d \n. you are right, gonna remove that line in a minute\n. ok, have added a check for that\n\nif (arguments.length) {\n    check(patternOrChannel, is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined')\n  }\n. Oh, missed that as I've focused on checking if default argument has an impact on arguments.length. Could change check(patternOrChannel, ... to check(arguments[0], ..., but dont know how much you like such solution.\nIn previous version of take was defaulting too to *, so I just wanted to keep that behaviour cleanly in the code and it seems better to make it a default parameter than to override argument later. \nJust checked againt behaviour for some scenarios:\n```\n// function test(a) {}\ntest() // arguments.length === 0\ntest(undefined) // arguments.length === 1\n// function test2(a = '') {}\ntest() // arguments.length === 0, a === ''\ntest(undefined) // arguments.length === 1, a === '*'\n``\n. \ud83c\udf89  its already pushed out\n. isnt this one testing effectivelytrue === true`? \nthis watcher.return().done will always evaluate to true\n. I was wondering what to do with this PR and then realised that the whole test is broken with 0.12 as now helpers - takeEvery/takeLatest/throttle - return task descriptors (just like the fork) instead of iterators.\nWould you consider accomodating this PR to the new behaviour?\n. Hm, you are right, but there is a caveat. Look at what is returned by takeEvery:\n{ name: 'takeEvery(INCREMENT_ASYNC, incrementAsync)',\n      next: [Function: next],\n      throw: [Function],\n      return: [Function: kReturn],\n      '@@redux-saga/HELPER': true }\nAnd now because of this - '@@redux-saga/HELPER': true its gonna be interpreted by the redux-saga in the special way:\n: is.helper(effect)                                    ? runForkEffect(wrapHelper(effect), effectId, currCb)\nSo effectively in real saga the task descriptor is going to be injected into the saga, and not an iterator.\n. you are missing an assignment here\n. could you refactor it, so both IS_BROWSER and IS_REACT_NATIVE cases are handled at the same time? some kind of obtaining global object at the top and checking here if it got obtained\n. could be made const with ternary operator like so:\nconst globalScope = (\n  typeof window.document === 'undefined' && navigator.product === 'ReactNative' ? global\n  : typeof window !== 'undefined' && window.document ? window\n  : null\n)\n. from ...args to args - thats a breaking change, could be avoided maybe?\n. ah, you are right ofc, didnt spot that :)\n. Its not really a get but more of a create function here. I think createAsEffectType is a sufficient name here. \n. kinda weird this else if being put after a whiteline, no place in the code follows that pattern (i think)\n. wondering if distinguishing permanently regular dispatches and puts could be leveraged to handle asap queue better in order to fix cases like - https://github.com/yelouafi/redux-saga/issues/598\n. wondering if asap.suspend() shouldnt be used here for consistency, but then semaphore-- maybe should get its own function, with more descriptive name, smth like - asap.lift()\n. performing\n. I see there is a new try here, but without corresponding catch, shouldnt something be done with the error? Also - what is it guarding from? fn throwing? \nthis simple try can swallow errors easily and make debugging a nightmare\n. arent those comments here a little bit too extra? scheduler is already pretty heavily commented (in general I always try to put close to 0 comments in the code, but thats personal flavour ;) )\n. Right, forgot its not swallowing here, rarely using such construct\n. really nice job with that refactor, scheduler got much clearer now\n. I wouldnt use ` syntax here, as you are not interpolating anything. '' would suffice. you have the opening bracket here in the comment, but no closing one. is there any particular reason of [bracket] notation here? wouldntdelete options.onerrorbe more natural?. You could put its implementation here between the lines, so people dont think its some kind of magic, but just a simple function returning a promise.. hm, it should have a comment of smth like \"depends on the effects, if at least 1 is blocking then it will be blocking, no-blocking otherwise\" - could be phrased much better ofc.identityis already implemented inutilsso you can import it from there - https://github.com/yelouafi/redux-saga/blob/250e722419f9fcaade729c51aaf5d97a3de2b16a/src/internal/utils.js#L11. its only guarding from theundefined, but I thinknullshould filtered out too, cant use simple!itemthough as we need to pass i.e.0(in case somebody emit numbers). should be \"undefinedornull\". should bereturned afteremitAllas it would emit twice in your scenario\n1. batch action\n1. unpacked batch actions. wondering also ifprocessActioncould be made a concern ofemititself, right now you are passing already processed actions intoemit. thats a breaking change as even withoutprocessActionoption is theoretically possible to dispatch an array and with that change it would suddenly start to emit each item in it instead of the original item. i didnt do that because of the API differences, I've changed it to to accept 3rd parameter which is a callback receiving a saga from thesyncDispatchTest ` and need to run a saga with appropriate API\n. could you import takeEvery also from the 'redux-saga/effects'? Its upcoming change and will be released before the weekend. this one should not be a part of runDeclarativeEffect i think. this one could have been checked before entering runDeclarativeEffect and runDeclarativeEffect should run only if this returns something other than effect itself. also aint sure if I feel naming this a middleware might be confusing for people, maybe it could be something more specific, like effectMiddleware? OTOH crippling the API to just declarativeEffects would be kinda crippling, why one couldnt mock other things with this?. im wondering if we should restrict this to functions only, also as naming convention suggests (is.func) the name should be is.stringableFunc. this one could be completely avoidable with combo of\ndefault   : pattern => input => input.type === String(pattern),\n+\n: is.stringableFunc(pattern) ? matchers.default\n. hm, often I see libs taking precautions and store first {}.hasOwnProperty so it can be called later as your code would fail on this\njavascript\nfunction func() {}\nfunc.toString= () => 'func'\nfunc.hasOwnProperty= () => false. yeah, basically yes, I know that it is uncommon for people doing that etc and thats just being me too cautious, especially that people could always shoot themselves in the foot (i.e. Object.prototype.hasOwnProperty overriding), but when lodash do smth I feel confident there is a reason to that and maybe we should apply the same thing here:\nlinks - 1 2. you've missed correcting the name of this one, should be stringableFunc. dont worry about this ordering, circular dependencies are fun ;)\nthough I feel like hasOwn would be better name for this utility, from hasProperty somebody could read that it should return true also for inherited ones\n. still wondering if this should be restricted to just stringable functions, although when I wonder about this:\njavascript\n{\n  type: 'TYPE_A',\n  toString: () => 'TYPE_B',\n}\nI have cold chills, so maybe only functions after all, WDYT? do u know about any other libs with different approach to actions than basic one?. ye, it wouldnt be now... (just like function with toString on it now) \nim just wondering how broad use cases should we cover here and what other libs should be considered in this context. eh, you static typing guys and your habits! \ud83d\ude04 \n\nContext property could be anything, not just plain object, so we can't safely copy it.\n\nofc it would be checked beforehand if it is a plain object to see if we should make a shallow copy. it should point to the https://github.com/redux-saga/redux-saga/blob/master/README_ko.md. maybe it should be a direct link to the - https://unpkg.com/redux-saga/dist/redux-saga.min.js ?. you are right, didnt spotted that by looking on the diff alone. regexp: exp => exp instanceof RegExp would be rather easier. But we dont need to retrieve here the class of object but rather just test it against one (known one).\nYour way is a more general, but should be rather used when somebody doesnt know against what to test, or just log something etc which might be of any type.. reasoning behind it - spawn creates a detached task, which is acting like a top task, so would it be good to propagate taskContext (parent context) to it? behaviour would differ from other propagations (error/cancellation) in terms of detached (spawn) and non-detached tasks (fork). could be ofc, but what i have proposed felt more natural when i was implementing this, however that was just a question for reviewers (so mostly you :P) left in the source code\nalso a little bit connected is this - https://github.com/redux-saga/redux-saga/issues/763#issue-200765663\nin regards of spawn/fork debate, cancel propagation and maybe even need to distinguish rootTask from regular tasks for code-splitting purposes and proper cancelation logic on route changes, would appreciate your input about those matters there greatly!\n. @yelouafi \nwhat do you think about those checks, it feela a little bit clunky, but I think this is what it takes to support both forms of the APIs, but maybe we should just drop one, so the code stays cleaner, aint sure however which one - join(...tasks) or join([...tasks]). simple middleware.run would suffice here, this const runSaga = (saga) => middleware.run(saga); is referantially transparent, so can be simplified to - const runSaga = middleware.run;, therefore it can be completely omitted\nofc this const runSaga = (saga) => middleware.run(saga); could be used to cap arguments list, but no point here for that. couldnt it be simplified to something more like \njavascript\nwhile (task = queue.shift()) {\n  // ...\n}\nI see that first task is passed into the exec, but maybe we could just move flush (from the finally block) up and make the loop iteration there, not in the exec itself?. SELF_CANCELLATION could be omitted if we return effect(CANCEL, { task }), but in that case self cancellation would depend on creating a cancel effect with { task: undefined } so it can be interpreted later in runCancelEffect, didnt chose it as it seemed too implicit and non obvious. Im not sure including external READMEs is the good idea, cause its really easy for them to get stale once original repos get updated.\nAlso the included README for Redux Saga Test Plan is much longer than the one for Redux Saga Test which might give the impression its the preferred way etc (people tend to judge based on such criteria really often).\nI think I would keep only the links to those repos with a NOTE above that those are community attempts to provide a more robust testing tools, but that we do not favor one over another and also we do not recommend using them per se. It is up to individual developer to chose.\nWDYT?. It even should be changed further - generator function returns an iterator object when run. I dont like including the README's there for the beforementioned reasons and wouldnt like to include them in our docs as they are. Maybe we could reach to the authors for providing us a brief description (why & how) of the libraries? cc @jfairbank @stoeffel. For sure we would like to have some official stand for testing library and possibly include it in the organization, however its not yet time for this.\nThe primary goal for now is to reach API stability (mostly done), fix some bugs (minor ones), add some missing features (ideas are welcome!) and ship v1 with all mentioned things. \nThen I think the testing story will get one of the highest priority. I wouldnt like yet to favor one of the approaches over another (which taking over the repo kinda is), as I didnt rly have time to gather my own thoughts about testing properly and also didnt evaluate thoroughly available helper libraries (such as yours) to see what approach did they chose and how they differ.. @jfairbank do you know about other libraries than those 2? we certainly should include all or none within this PR if we decide to proceed with it further\nas to API stability - we are trying to get there ;) although not much breaking changes lately! and not much comming in the future, so some stability is there already. well, one is needed upon creation and latter might be used in a runtime, could be ofc in response for some action but for more complex contexts it would require action to contain ur dependency which could be not serializable fully, which i dont like - if you for example need to pass some event bus with methods on it. actually as React's setState is available on the instance of the component - it could be used outside and therefore its not so private. such checks are usually performed in effect creators, it would only double the same check if we put it here also, as its not possible to reach this - runSetContextEffect in any other way that yield setContext(...). cc @aikoven . hm... at first I thought that this is a valid point and should be done, but after a while i think in the world of code-splitting its nice to have a possibility to share this top-level middleware context among root sagas, as there could be many of those, and when puting this only on task itself it would require such verbose code in order to share it 'globally':\njavascript\nconst context = {...}\nsagaMiddleware.run(...).setContext(context)\n// ... later\nsagaMiddleware.run(...).setContext(context). the only thing im not so happy about is that sagaMiddleware is kinda superior to the runSaga here, as the latter do not have possibility to share such things in an elegant way, but I guess one can always write some wrapper function up to his needs. actually it is not the only place we use process, there are few (like 2 or so) more\nDo you want to update your PR or should I just do it? by mistake Ive already done it on my local branch, but wouldnt like to take this away from you, so let me know :). Thanks for the comment, I need to definitely look into this.. this file has wrong name - it lacks the 'e'. technically this is an iterator, not a generator\ndefinition of the generator is a function which produced an iterator object. tests should include an example of the logic which it simplifies - branching . i think rest of the code is not commented like this. same remark about generator vs iterator semantics, this should be const it. generatorFunction feels verbose, probably just generator would be ok\nalso thinking if this should be just called cloneable, but pick whichever you want for now. couldnt it be tested like rest of the code? I mean pushing to the actual within next, throw, return etc and in the end just comparing actual vs expected? . i would keep change it to iterator, as it brings less confusion, dont u think?. rather remove, i think this function is quite self-explanatory. would add here \"all pending takers\". missing whitespace before equals sign. other parts of the docs when describing the testing story are using tape, consistency would be appreciated by the reading users i think. it would, thanks for noticing! gonna fix it with default param in a minute\n. previous tests in this file were not directly dependant on scheduler, is it neccessary to expose this implementation details here?. Shouldnt this while loop be a responsibility of flush rather than exec?. yeah, i even think i had that thought but forgot to do something about it, will add this and merge in, thanks for the review . we'll do! :). maybe a better name would be a shorter unsubscribed?. probably this wont even be checked as this test is synchronously going further till assert.end(), I would recomment splitting this whole test in some smaller ones and then in more scoped test call assert.equal (like you did) + assert.end(). this could be rather simplified, all of this logic (complexity) boils down to the fact that END is emitted asynchronously, so simple setTimeout(() => emitter(END), 0) should be enough\n\nofc propert assert.end() should accompany this. Fixed it on your branch, take a look at this commit. \n\nI'll review the whole thing once more later and gonna merge it in. Thanks for the great work and noticing this.. ive debugged it to the moment ive realised that this was caused by this ordering -  unsubscribe vs chan.close and I think its reasonable anyway to have this fixed ordering of things, it seems... better, dont you think? i couldnt find any argument against this. Thanks for the PR. Could u specify ur original problem? takeEvery etc are using fork internally, so they are very much attached. This paragraph implies they are not, so maybe there was some other issue u were facing.. could u specify from which package do you import takeLatest and which version of the redux-saga do u use?. was adding this neccessary?. I think ive made a mistake there and the correct version should be this\n```\nfunction takeLatest(pattern, saga, ...args) {\n  return fork(function* () {\n    let lastTask\n    while (true) {\n      const action = yield take(pattern)\n      if (lastTask)\n        yield cancel(lastTask) // cancel is no-op if the task has already terminated\n  lastTask = yield fork(saga, ...args.concat(action))\n}\n\n})\n}\n```\nWould u like to fix this in the docs? Probably there are like 3 places to correct this when describing takeEvery, takeLatest and throttle. Thinking about the name for this - any other ideas than raceOrigin, effectOrigin ?. also seting this property should be done with defineProperty I think and it should be excluded from enumerability. not yet, will try to think about the most appropriate name. should be else if, not a nested if. hm, could u be more precise? i dont see any local variable here named abort, the only one is promise. oh yeah, thanks for noticing, gonna change this in a moment. this should be removed. and this too. this should be revamped and replaced with RACE_ORIGIN mention and example. hm, thats becoming quite a long list, but newline shouldnt be inserted here yet, gonna think how those utils could be splitted later. those comments are really not neccessary. most tests do not put assert calls inside a generator, but rather have actual and expected arrays which are compared at the end, so basically that would look something like\n```\ntest('processor race error has origin', assert => {\n  assert.plan(1);\n  const actual = []\n  const expected = ['willErr']\nfunction* genFn() {\n    try {\n      yield io.race({\n        wontResolve: new Promise((resolve, reject) => {}),\n        willErr: Promise.reject(new Error(\"FAIL\")),\n      })\n    } catch(err) {\n      actual.push(err[RACE_ORIGIN])\n    }\n  }\nproc(genFn()).done.then(() => {\n    assert.deepEqual(actual, expected, 'thrown error should have RACE_ORIGIN set on itself')\n  })\n})\n```\nsometimes smth like Promise.resolve(1) is used in test to cause asynchrony, no need for that here though\nthis should also be accompanied by a test which do not set RACE_ORIGIN, when something else than an Error is thrown. cc @yelouafi . cc @yelouafi . let's -> let. Hm, this has realized me that even though Object.keys indeed allows us to pass in an array, the race's outcome is not an array in such case, but an object - so i.e. it cannot be destructured. If we want to put it into the docs, we should convert the result to an array.\nWould you like to add this to the PR and adjust the proposed docs? Conversion can be made simply by adding a length property to the object and calling [].slice.call(result). The whole work would needs to be done in this function and should be really straightforward to implement. If you want to do it, please do not forget about adding tests for this :). Result is returned through cb. Array.from would be better but its a part of es6 standard and we cant require everyone to polyfill it. Thanks for taking the time to work on it. Disabling the rule for this line is an option, you can do it with // eslint-disable-next-line no-sparse-arrays\nOnce you push it out im gonna checkout ur branch and why assert.deepEqual fails when passing [[undefined, 1]]. @klis87 Sorry for the long wait, I was really busy lately. I'm going atm through the issues and PRs, expect this to be handled soon.. im not yet sure if this should be treated as effect, but that's not important right now, I can easily decide about it after merging your PR in and just move the public export appropriately. retry would be a new thing, we don't need to provide old-style export for it with a deprecation warning. would prefer some simpler test case, not based so heavily on the clock\nyou can just put a counter variable here, increment with each worker call and just decide in the worker if based on the counter it should fail or succeed, and ofc based on it test retry behaviour\nthe clock needs to be ticked ofc, but only to move the test-timeline forward. the problem with this implementation is that it is generator based and we cannot distribute generators yet in the source code, as old browsers/nodes dont support it, library should be pretty much ready for usage in any es5-compatible environment when downloaded from npm\nwe also cannot transpile generators ourselves as it would require opinionated runtime to be included in out bundle (most popular being regenerator-runtime) which tend to be quite big\nfor those reasons other helpers are created with fsmIterator internal helper - it's quite easy to use, once you know what it does - I have once described it here\nIt doesn't yet support errors though, so it would have need to be adjusted so it could support retry helper. While technically this is correct, because saga will allow for it - the best option is to pass stdChannel here, maybe typings could enforce it? Dunno what best practices are in such cases.. Hm, probably not worth it then. I guess that somebody might find it useful to pass in a unicast channel anyway, so it's better to not strangle one's creativity.. in general it's way better not to export objects, when they expose only static methods, as exporting objects in most cases prevents tree-shaking. would creating a new entry point - redux-saga/inspection (like /effects and /utils) make sense for you here?\nI'd like also to split redux-saga in few packages https://github.com/redux-saga/redux-saga/issues/1213 . However for the time being redux-saga would mainly stay the same, reexporting other packages etc. The reason for the change is just being able to install subpackages in other projects when the redux-saga itself is not needed. In such case - should inspection become other official subpackage or do you see it as part of the core?. hi @yelouafi ! \ud83d\udc4b \nif we remove IO won't it create the same problem? How today's situation is different in terms of name clashes?\n. also - without IO its hard to determine if the object is an effect for the purpose of introduced is.effect, hard to distinguish it from any other { type, payload } objects, its a popular shape i.e. for redux actions. OTOH we could do { [IO]: type, payload } instead of the dynamic type property. Yeah, that would totally work. Gonna play with it later. Thanks for the input, it's nice to know that you still have an eye on the project \ud83d\udc4d \nI've started to refactor a little bit to extract things (like effect runners) from the proc's closure - but as things, especially those runners, access closure's variables I've started to look into what they access and I will try to gather those things under single saga's state variable - this potentially could unlock possibility to create custom effects in the user land.. well, it could also always be importable from the redux-saga, so we dont have to rely on globals. what do you mean by \"where tasks are used\"? how did it matter for the implementation? . Hm, I think it would really be a matter of inserting an import for appropriate export from redux-saga package. It seems that lodash is doing some more magic there in the quoted code - for some other reasons.. mainTask is completely internal, see this comment. I dont think it needs to have any meta attached to it (regarding location etc). it seems to me that we could accept saga (generator) instead of iterator here and just use saga's static properties later when needed - no need for meta object as arguments, we could even (possibly) eliminate passing explicit name arg. looking through the code now and im not sure if it can actually be done - but would certainly be worth checking. > And automatically ignores any coming new saga task if it's still running.\nThis is imho slightly inaccurate. It would be better to just say that it blocks until spawned saga completes AND then starts to listen for a pattern again.. This paragraph described the behaviour again in slightly inaccurate way. Would be easier to say that it's listening for the actions when it doesn't run a saga.. this should be takeLeading. personally i dont like disabling rules at the top of the file, its hard to determine why they were disabled\nwould prefer to mute rules at call sites, if possible. actually i have included actual.js (or how those files are named at the moment) on purpose, i know we sometimes might want to write code that breaks our lint rules, but we can always use eslint-ignore comments for that\nWDYT?. I don't have a strong opinion on this, but I don't believe that \"those are for machine\" is a right statement here.\nThey are our tests and they need be reviewable by humans for them to have any purpose.. we have a typo here, should be ['babel-plugin-redux-saga', { /* options */ }] or mention of the options should get removed from here. u are mixing const and var here, minor nit, dont have to be changed right away. \ud83d\udc4d . huh, funny that we do not have to fallback to more custom solution because babel got migrated to scoped packages. we do not import/require it from the babel plugin (and probably we won't, using global symbol registry is \"good enough\"), so probably better to just hide it in the internals, probably not even worth to keep it as a map as we have only a single item there\nI'd just go with same, duplicated, implementation for SAGA_LOCATION in both core and babel plugin (and wouldnt also export SAGA_LOCATION from here, until somebody requests it). I have lately really enjoyed using @babel/template, you can access it from the babel object here too, without need to import it yourself):\nj\nvar { types: t, template } = babel\nWe can only use template (no template.ast, template.expression, etc) to keep babel@6 compatibility.\nIMHO it improves the readability quite a lot.. symbols are not enumerable, so maybe we should wrap this fallback output with Object.defineProperty?. shouldnt we just visit yields? probably would make reasoning about this easier. not sure on which line I should comment about this, but it should be easy to replace those IIFEs with comma separated expressions\njs\nvar _ref;\nyield _ref = call(smthelse), _ref[_SAGA_LOCATION] = { fileName: ..., lineNumber: ... } ,_ref;\nCan be achieved with things like scope.generateDeclararedUidIdentifier('ref') and path.replaceWithMultiple - or smth like that \ud83d\ude09 . technically this is also possible:\njs\nconst saga = function* saga() {}\nand won't be visited with the plugin right now.. @restrry WDYT?. When using real symbols we don't have to use Object.defineProperty, but using it consistently makes the code easier, so let's leave it that way for now.. with babel@7 u can use more accurate toString:\njs\nvar { hasOwnProperty: hasOwn } = {}\nvar sourceCode = hasOwn.call(path, 'toString') ? path.toString() : path.getSource();. hm, those snapshots are imho less readable. Would it be possible to go back to separate files and suffix expected files with babel's version?. I'd appreciate the change, imho separate files are easier to browse & inspect + syntax highlighting works in editors. what do u think about this one?\n\nshouldnt we just visit yields? probably would make reasoning about this easier\n\n@restrry . nit: typo cannelled -> cancelled. well, idiomatic way of working with sagas is generally yielding effects only which are just objects - so generally it should be quite \"safe\" to wrap even more complex expressions, as their completion values should be objects, right? . string key will still be used with defineProperty, what concern do u see about this in comparison with Symbol situations? Seems to me that both of them are the same regarding \"safety\" of this. Could u explain how I could reproduce it so I could debug later? Exact input and options used (I guess we are talking about most recent version of this plugin). I have both today's and tomorrow's evenings already planned but I can work on it on Saturday and hopefully release it then. You should unpack expression from returned value, so:\njs\nreturn extendExpressionWithLocation.expression;\nBabel don't know how did you want to parse this code and it assumes statement here - in babel@7 there are actually various versions of template, ie. template.expression, template.statement and others - but we cant use them if we want to keep babel@6 compat for now.\nAlso It would be better for perf to cache extendExpressionWithLocationTemplate in outer scope - just before createLocationExtender declaration.\n. I've pushed out the fix for this. \"to help better redux-saga.\" -> \"to help make redux-saga better.\". Would be cool to mention that reproduction case helps a lot and if one is provided it's usually WAY quicker to fix the issue. Repros can be made as separate git repositories or created on http://codesandbox.io/. actually this should be npm run bootstrap now as we've started using lerna which manage this monorepo. I dont think we should actually convert those not-errors to errors. Let them flow through the system and guard against them at later point - before attaching properties to them and before logging them. I would remove this part, it mentions redux-saga concepts, which are a little bit irrelevant here. Would be better just to focus on the fact that generators are more powerful primitive than async/await.. are process.cwd() calls considered to be costful? if not it would be more readable imho to just inline this variable here. You are targeting at the moment v1-beta line (and I really wouldnt like to do any development on 0.x line), breaking changes can happen during a beta period and this also shouldnt break too many ppl, so it's fine to just pass what was thrown \"as is\" to onError. Previously I've just installed redux and it got me latest version at that time in the range. Later I've backtracked in which version compose (the only thing we are using from the redux package) got introduced to redux and it was 0.10. actually I would prefer not relaying on those packages being in a monorepo and stuff, with \"real\" dependencies we can in example easily upload those examples to things like codesandbox.io etc and it should download its copies of those deps \n. why the change here? this demo uses webpack and it's better not to transpile modules when using it. in readme it would be more clear to use some dummy path here like, ../src/sagas/index.js . imho would be good to use a valid JSON here. personally i kinda like tuple-approach, it's really concise - however this is not using it \"correctly\", tuples should be of fixed size and we return different lengths here - also accessing out of bounds indexes is a v8 deopt and should be avoided\nto sum it up - i agree that we should refactor it to object, i propose { nextQ, errQ, eff, updater }, although we could also go with { nextState, errorState, effect, stateUpdater }, wdyt?. this is wrapped in parenthesis unnecessarily . using a default parameter in the middle of argument list is rather futile. Sure thing! . -D is a short hand that many people might not recognize, let's just use more explicit --save-dev for clarity. should be its instead of it's. please change this filename to io-helpers.js. this line still need a change to reflect recent file rename. this actually won't work as expected. Using Object.assign works fine, but for .. in doesn't iterate through symbols. Adjusted version of this should be used.\nI'm not sure if we need:\n- supporting multiple sources (maybe rename our assign helper to smth like assign2?). Atm we do not need it and from what I know it's better to avoid arguments access for perf reasons\n- we do not need to use Object.defineProperty like babel helper \n. I get a feeling that something is off with our prettier/lint-staged config, single arrow param should be reformatted without parens \ud83e\udd14\nthis needs to be investigated, but not as part of this PR. I think this comment was referring to https://github.com/redux-saga/redux-saga-devtools but this project is unmaintained atm, so probably it doesnt matter much and as mentioned other workarounds exist. from what i see res cannot be falsy, so this check here is not necessary. I don't quite like naming this shouldTerminate in relation to TERMINATE because it implies that their relation is stronger. @JSoet would u like to remove those changes here? The only needed change is this one. . this array should be wrapped in all. I would probably explain that all([fork, fork, fork]) gives back a single effect (all) to be handled to the saga runtime and fork fork fork gives a single fork effect 3 times. Ofc ultimately it doesn't matter and both would execute those effects in the same order etc.. Not sure if mentioning yielding iterators (helloSaga()'s result in this case) in yet another place is a good thing, while those are technically handled by redux-saga I would restrain from using it over call/fork which should be the recommended way.. effort -> effect. We could put more emphasize here (and probably a little bit above too) about need to handle thrown errors. It's developer's responsible to handle potential errors to prevent his/her app from crashing. Making spawn a solution for unhandled errors might sometimes hide broken parts from the developer's eyes and should be used carefully. \nIt might be wort adding that spawn might be considered similar to error boundary in React. The difference is that you can't handle errors & recover when using spawn, but it can be used as extra safety measure at some level of the saga tree, cutting off a single feature or something and not letting the whole app crash.. there was also a discussion about sync errors here, this could be included here\nIn general I think we should mention those things as possibility, but should also mention that we do not actually recommend applying it bluntly. Again - it IMHO nicely relate to error boundaries in react. React docs recommend using them for error logging & displaying information to the user about broken part of the page, BUT it is not recommending developers to try to render the same broken subtree again (restarting is imho such a rerender attempt). > @Andarist that was done intentionally, since if you use Symbol, you have Object.assign defined in your browser. and I didn't want to add additional check for Object.getOwnPropertySymbols existence\nIn world with polyfills that is unfortunately not true in all the cases. You can polyfill Symbols and skip polyfilling Object.assign.. which one? you already have deleted CHANNEL_END from here, which I think is fine \ud83d\udc4d \nI think this comment \"toString is used to have ability to log actions in devtools.\" might be removed too.. wouldnt shouldTerminate be more appropriate? just thinking out loud, let me know what do u think. could u explain this comment? Im not sure if I get what case are you talking about. could u point me to the duplicate of this one?. Probably some wrong merge artifact \ud83d\ude05 . gotcha. can u think of any use case for extending the input with a flag? maybe we could just pass special completion value - TERMINATE here, like this:\njs\nif (isEnd(input) && !maybe) {\n  cb(TERMINATE)\n  return\n}\nI know I'm probably one who wrote this spread here, but can't think of any use case of it now.\nIf we would follow that path, then we could skip implementing isTerminated altogether and just use direct TERMINATE comparisong, i.e.\njs\n } else if (arg === TERMINATE) {\nand\njs\nconst isCompleted = res => res && (isEnd(res) || res === TERMINATE || res === TASK_CANCEL). I don't know how asEffect was used outside of the core, let's just ditch it for now & wait to see if it breaks anyone's use case. We are in v1-beta period right now, so I'm not concerned with making some breaking changes.\nI like refactoring runEffect in the way you have proposed here.. whats the reason behind this comment?. I think splitting them into 2 declarations makes sense, but setting them explicitly to undefined is too verbose to my taste, its after all their default value anyway. we could be more explicit here and do if (typeof env.onError === 'function'). i would prefer naming this stdChannel as its not just any channel. imho we should reorder those args\nenv & iterator should be first 2, im a little bit more inclined to put env as first as its constant and making it first it would be easier to curry proc (although not something we actually want to do)\nmeta should become very last as its the least important one and I think we should also check if its possible to put parentEffectId in the meta object too\nOTOH cont is callback and it seems reasonable to put it last, maybe cont should be the one before last one (meta)?\nlet me know what do u think. this in fact can be cached now,\njs\nconst finalizeRunEffect = !is.func(middleware) \n    ? runEffect\n    : runEffect => {\n      return function finalRunEffect(effect, effectId, currCb) {\n        const plainRunEffect = eff => runEffect(eff, effectId, currCb)\n        return middleware(plainRunEffect)(effect)\n      }\n    }. oh, havent noticed that u call this later in proc initialization. we should remove returns from this function, as this function runEffect shouldnt actually return anything to the caller (we can ofc use return to exit the function, just we shouldnt return any value). isnt this test a duplicate of \"saga onError is called for uncaught error\"?. do we even use decorators anywhere?. we could update this to ^0.3.0 . We should remove stage-2 preset anyway and use specific transforms if needed. I suspect the only thing we really use is @babel/proposal-object-rest-spread. this looks quite nice. \ud83d\udc4c . IMHO we are at perfect place for making breaking changes, let's just drop support for join(...tasks) & cancel(...tasks)\ncontextual breaking change warning is nice though! we could move that env check into if (arguments.length > 1) & drop taskOrTasks = array.from(arguments) (and ofc change the deprecation warning to throw error so the developers can quickly fix their call sites). this got me thinking - what happens when we cancel a task? it calls it.return(), right? what happens if finally block throws? is that case handled? \ud83e\udd14 . correct (typing wise, and probably more future-proof) is import * as React from 'react', both versions work now, because react is packages solely as CJS package, but this might change in the future. I would prefer using standard .js, I don't see much value in .jsx extension as JSX is handled just fine in regular .js files by all the tools.. \ud83d\udc4c . isnt object-rest-spread included in preset-env? (not sure if its on by default or not though)\nalso - it accepts loose flag too and we should use it\ngreat change about removing stage-2 \ud83d\udc4c . we dont care about return value, so it's better to wrap the body in curly braces\njs\ntakers.forEach(taker => { taker(END) }). so it's handled - thanks for checking!. It's also included in preset-env - https://github.com/babel/babel/blob/75767e92730a7437c9b499ef0508ee9bb3783d4e/packages/babel-preset-env/data/plugins.json#L234 . But as mentioned - it might need some extra config to make it work. I'm fine with keeping it separate.. ideally I'd like to just drop low-level rollup for microbundle (its a rollup wrapper) in the future, so wouldnt bother with that, just need to find some time to contribute to microbundle more to cover more advanced use cases \ud83d\ude05 . its not rly actionable right now, i would only like to move to microbundle if it will be able to tackle all the required tasks with simpler config (so config doesnt have to be updated in multiple places, which I tend to do a lot :/). \ud83d\ude22 do u know how to setup this correctly then? we need to have those files untouched by prettier and I find it easier to do this in overrides-like section of the config than in a single glob matching which files have to be prettified (like before). good point, it's supported in trailing commas in functions are allowed since node@8 so we should be able to use it in all files. oh, this is leftover, has to be removed - I've used it to migrate \ud83d\ude05 but the migration is complete now (at least in core package). this is kinda a temporary hack for now, we should be able to just use babel-jest, but we'd have to install https://github.com/babel/babel-bridge and cant do it right now because we test babel plugin with both babel@6 and babel@7. not sure how to share such a helper appropriately between packages without making it a package (and i dont think its worth to make it a package), and imho we shouldnt reach out to anything outside a single package directory - that would break package encapsulation. yeah, that was the intended directory\nbabel@7 stopped using babelrc files outside of current working directory (which is packages/core here) - one have to opt in to using them with babelrcRoots option. \nThe intention of this is to always build (& test etc) from our source directories instead of some build artifacts which might be outdated at the time of running the script . Hm, not sure which one is better - join([...tasks]) seems to indicate that the argument type is an array, join(tasks) does not hold any information regarding this (except pluralized word). let's keep it then, I doubt people will actually make those copies, at least not most commonly. this shouldnt be needed because we already do this \"test\": \"jest --env=node\". this should also handle is.iterator case, it seems that this can even be shortened to\njs\nconst next = (value = result) => {\n  return {\n    done: !is.promise(value) && !is.iterator(value),\n    value,\n  }\n}. also probably better to reorder value and done, value should comes first, because its the order used by v8. i dont think we are using describes anywhere else, do we?. cool, havent noticed it. is this necessary? effect ids should be numbers already, right?. seems like we should bookkeep the tree structure here too for perf reasons. why the change? why to move it to the function?. oh, yeah - havent quite noticed they are coming here from Object.keys. i dont think I quite like this change - seems like ROOT is different from other effects because its purely internal\ncould u describe what do u think about it? what are advantages of having it in your opinion? (remember that I can always be persuaded! \ud83d\ude09 ). \ud83d\udc4d . this could be just const payload = { ...eff.payload, detached: true }. yeah, in general function declarations and expressions are one of the easiest things to dead code eliminate, it's better to hoist this to the top level scope to avoid recreating this function inside each detach call. if we decide to keep it then it should stay in effectTypes, it shouldnt be exported from effects (as in import {root} from 'redux-saga/effects'\nthere is also a perspective of redux-saga itself - this effect is not interpreted like other effects, its executed eagerly on the startup. im quite sure it shouldnt be exported, im still unsure if it should be an effect at all \ud83e\udd14 this only seems to satisfy monitor needs, from core's perspective it still seems to be weird imho - @restrry  wdyt?. OTOH it is super minor thing, and was classified as an effect already when passing info about it to the monitor. it could be kept as purely internal effect - not user facing, but I think I like rootSagaStarted hook proposal by @shinima better, it's more explicit and less confusing about what effects are. I'd probably like to move it to separate module - but gonna handle it in separate PR. the redux-saga/utils entry is starting to look useless, we should get rid of it later in favour of modular packages. all those things apply to the yield all([ fork(saga1), fork(saga2), fork(saga3) ]) case - by yielding that the code after this all effect should be executed immediately because each fork effect is synchronously returning something (a task descriptor) - and ofc those descriptors would be very much usable in the calling saga, like this:\njs\nconst [task1, task2, task3] = yield all([ fork(saga1), fork(saga2), fork(saga3) ])\n. that's true for race, using fork in a race is pointless, but imho all([fork, fork]) is very much OK for the reasons mentioned in the previous comment. this is a good explanation overall, but imho should be purely informative, without advising not do this, because the pattern itself is OK. actually I've wanted to migrate every process.env.NODE_ENV === 'development' check to process.env.NODE_ENV !== 'production', would u like to do this as part of this PR?. My logic behind using true as default is that it's easier to catch a mistake with it (in this case). \nIf we use useESModules: true by mistake in cjs environment it will fail loudly (even if after releasing a broken version) and will give us a chance to fix it quickly.\nIf we use useESModules: false in a wrong way we might not know that at all, because most commonly ESM environments (webpack, rollup) are configured to consume CJS as well.\nuseESModules = output.format !== 'cjs' - we can do that though. right, gonna move validation to the effect creators from get getFnCallDescriptor itself. Oh, this is a bummer \ud83d\ude05 had no idea this is publicly supported, gonna have to restore it & write a test for this . this is a hot path, so a for loop should be better here, perf-wise. > Errors from the forked tasks bubble to the parent task rather than to the all effect.\n\"Uncaught errors from forked tasks bubble to the parent task and thus abort it (and all its child tasks) - they cannot be caught by the parent task.\". could we use jest for this?. seems to me that we dont need both onError & logError, having them both is confusing. imho this was too annoying, ive always used --no-verify flag just to turn it off. aren't they the same? takeEvery is also using proc internally, as it's yielding fork which is wrapped with proc.. good catch! should be handled as well. would prefer avoiding additional closures in the saga code, so Im reluctant to using decorator approach\nand Im not sure if we can move this safely into the proc, as runForkEffect would slightly change the order of how things happen (when the cb callback gets invoked) - I will experiment with it though. It seems that tests are passing if we move this to proc, I'll try to do further experimentation to see if I can break some case. actually ur given snippet doesnt work, as it yields a generator and not the iterator, even if we correct it to:\njs\nfunction* root() {\n    yield all([\n      put({ type: 'FIRST' }),\n      (function*() {\n        yield take('FIRST')\n        yield put({ type: 'SECOND' })\n      })(),\n    ])\n  }\nthe second yielded item in all is equivalent to call effect (kinda) and thus scheduler doesn't apply to it\nor did I miss something?. > updated: there is another problem with onError we build saga error stack only when error bubbles to the root, so if user handles errors on their own (say try/catch on the upper layer), they don't have normalized saga error stack\nBut that's OK I think. People shouldnt rely on the stack anyhow - it doesnt matter if we are talking about normal errors or saga errors, stack inspection is shady and unreliable. \nThe whole point of saga stack is to improve developer experience because errors caught by saga are otherwise really cryptic. No runtime code should rely on them though.\nI think we should get rid of logError entirely and just recommend using onError for logging purposes. Explaining in the docs that it's role is primarily for logging purposes and it's called only for entirely uncaught errors from which we couldnt recover.. we should tweak out lintstaged config to format .md files too. codesandbox example is cool, we could make it an official example in the example directory and then we could point to it here with url like this:\nhttps://codesandbox.io/s/github/redux-saga/redux-saga/tree/master/examples/run-saga-demo. > should I remove the whole description how retry is implemented under-the-hood? \nno, i think (as you) that its helpful for the readers. could we check how other libraries handle such errors? (ie. react). actually delay is an effect now (its just bound call, but still). so basically both are handled the same way, i think we can safely assume this is what people expect, so both type of errors should just get handled to onError or logged with console.error if onError is not provided. a short comment above this line that we assign undefined and not null to make default parameter work at later point would be helpful. I would inline this destructuring into sagaMiddlewareFactory declaration, without it I'm thinking that options might be used later on and search for references to it\njs\nexport default function sagaMiddlewareFactory({\n    channel = stdChannel(),\n    context = {},\n    effectMiddlewares\n    logger,\n    onError,\n    sagaMonitor,\n} = {}) {\n    // ...\n}. doesnt it mean that if somebody would use custom channel through the option then his/her action wouldnt get dispatched automatically?. regarding my comment here - https://github.com/redux-saga/redux-saga/pull/1654/files#r228758007 \njs\nyield takeEvery('*', function*(ac) {\n  actual.push(ac.type)\n  yield put({ type: 'saga_action' })\n})\nbecause of making dispatch \"optional\" you have made this put here not hitting reducers automatically. cc @aikoven . cc @aikoven . Ok, we can just throw internal errors - but I suspect this will force us to distinguish those 2 types of errors in the code.\nonError indeed might be seen as componentDidCatch. Our onError cannot recover from errors, but nor componentDidCatch should - it's possibly to recover with it in React for the time being to keep backward compatibility, but it's deprecated. Recovery should be done with static getDerivedStateFromError. dispatch is used in saga for emitting actions outside of its runtime\nchannel.put is used for emitting into saga runtime\nHaving them separate makes a nice distinction, although might be a little bit confusing.\nCurrent solution has other problem though, by making this:\njs\nchannel: { ...channel, put: wrapSagaDispatch(dispatch || channel.put) },\n\nIn cases that users are using sagaMiddlewareFactory, options.dispatch in runSaga is always not null, put effects will always hit reducers.\n\nI've pushed out a change to the test to showcase the problem, you can check out that simply removing dispatch is causing a problem there.. > \ud83d\ude15 Looks the expected result is wrong to me. Can you double check that?\nYou are right, I've made a silly mistake there \ud83d\ude05 \nI think there might be edge cases around current solution, but Im not saying it's a wrong direction - we only might need to tweak it a little bit. I need to give this a little bit more thought, gonna experiment today with how it works exactly now and what can and what cannot be done to see if we can follow that direction.\n. no, need to move them too, thanks for reminding about it\n. yeah, gonna do it as part of this PR. this file should be removed, while you are at it you could add yarn.lock to .gitignored files. could we just switch to using lodash entry directly in those places? like import { findKey } from 'lodash'. actually lodash exports everything from the \"main entry\" too, u dont have to \"scope\" it under object/lodash\nif you dont feel confident in doing this, let me know and I'll merge this as is. onError validation should be kept. sure it is weird, those checks are dev-only though and meant to help people not using TS/flow. Oh, I see you have moved it entirely to runSaga file \ud83d\udc4c . Maybe, just maybe, it would be possible to consolidate proc and newTask and make digestEffect a task method? Im not sure if this is a good idea, just thinking out loud. We could maybe experiment with it in separate PR (so it's easy to track the changes). Just posting both here for convenience:\njs\nfunction newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont)\njs\nfunction proc(env, iterator, parentContext, parentEffectId, meta, isRoot, cont)\nThey indeed seem to relate to each other really closely, wondering if we can do smth about it.. seems like it would be better to make those a single enum, i believe only one should ever be true, smth like\n```js\nconst RUNNING = 0\nconst CANCELLED = 1\nconst ABORTED = 2\nconst DONE = 3\nlet status = RUNNING\n``\nshould make the trick. this is slightly weird for me that task uses getter methods but mainTask uses an instance properties (so checking those things in the code is different, depending on what kind of task we check). Not sure when this can happen, maybe this comment is outdated/inaccurate?. We dont support async cleanups though, so the finally block should return synchronously, therefore it should in theory make it safe to transition from running to cancelled either before making calling into cancellation logic or just after that (preferably former). This could require some minor code changes, but sounds like a reasonable assumption to me that it should be doable, right?. Hm, good point about put/select but Im not sure if there is any code which relies on running being true in finally block.. \"may be\". CANCELLED should be resolved somehow too - in the Promise worls it seems like it should be treated as rejection (unfortunately) and that we should inject some artificial cancellation error here. this is somewhat leaky (but the problem is not exclusive to the digestEffect) - because we give those tasks to users and things like -digestEffect` should never be called by them (except in effect runners)\nWe don't necessarily have to fix it, but its a pity nevertheless. Not sure how we should split those in public and kinda protected interfaces. Well, we can treat TASK_CANCEL as public completion value - I'm only unsure if this is what people would have expected. WDYT? cc @restrry . seems reasonable \ud83d\udc4c . is there any reason why we have to differentiate CANCELLING from CANCELLED?. this could be adjusted and kept as dev-only error. a comment above this line about what's happening would be helpful here\nI suspect that this reuses the existing error (saga error here) or wraps a new (just thrown) error, but its not that obvious at first glance. when this can be not wrapped? shouldnt the wrapping happen right away after catching the error? so it should be already wrapped when it reaches this line?. I really like removing this from the task \ud83d\udc4c . this changes how it behave previously - could u explain how it behave and how it will behave after this change?\npreviously locally caught error was passed to mainTask.cont, currently arg gets reused. ok, after a thought i think i know how it works - previously arg and locally caught error were actually the same, right?. ok, so it seems this gets actually called before wrapping as currCb in which we are here is actually the first thing to be called by effect runners \ud83d\ude05 . after a thought - falsy values cannot crash saga, so the whole UNIQUE thing can be removed, and a simple truthy check should suffice. Also - shouldnt namespaces be avoided?. \u2764\ufe0f . it's used in effect.d.ts, in general I'd prefer not using namespaces, you have also pulled in all helpers from the linked issue, but you are using only 3 of them, so probably we should remove unused ones (even if they might come handy in the future) - or you could maybe publish those types as a package and we could depend on it here? :). I have no problems with adding dependencies - especially non-runtime ones \ud83d\ude04 Outsource all the things \ud83d\ude09 . I'd call it something like ErrorInfo or something, onErrorRuntime suggests to me that this is a handler function. Yeah, tests are passing because I havent add a new one (yet). It's true that cancel sets the status to CANCELLED, but end (as task.cont or mainTask.cont, cant remember right now) might be called from the proc too (without calling task.cancel here) when propagating the TASK_CANCEL through saga tree. Right, this was a quick draft and I have not finished it (and obviously made a mistake here).. this is a new test which didnt work previously. this has worked but I have added in nevertheless when testing things out. If we are updating this - we should update to v1.. This is not quite true, I'd prefer to transpile this - just not to the es5. We could leverage https://babeljs.io/docs/en/babel-preset-env#targetsesmodules .\nThis would make the setup slightly more complicated (how to turn it on & off in babelrc files?), but maybe we could leverage upcoming .custom feature of rollup-plugin-babel (available in v5.0.0-alpha.0), I don't have time right now to investigate this, but it would look smth like this:\nbabel.custom(() => ({\n  config(config) {\n    // manipulate the config here (it should contain `@babel/preset-env`)\n    // or just return untouched config back for every other build\n    return config\n  }\n})). are u aware of the fact that generated chunks (not entry files) contain a hash in their filenames and you will have to handle it? redux-saga update is probably going to change the hash each time. I'm also not fond of using .mjs for this, just make it smth like:\njs\nentryFileNames: 'redux-saga-[name].esmodules-browsers.js',. this is somewhat a problem because this example is marked as private now - we can add a build step & publish it, that way codesandbox will know how to consume it. Is Parameters builtin type in TS@3.2?. @levenleven would you like to prepare a PR fixing this?. We definitely don't have manpower to maintain more than one set of typings. From what I see though this is implemented using constructs available before that, so maybe we could just use Parameters copy temporarily.\nNot sure though what TS version is requirement for the rest of the typings. If we have more typings depending on >3.1 then we'll have to just require that version from our users. cc @aikoven . yeah, that would be nice too - i dont know how up to date it is though & don't have time personally to adjust those examples to use it, publishing saga-monitor-example has just seemed like smaller effort. Let's sit on this one until final release to see what's the initial feedback.. That's true - it could be removed, but I didnt want to change too much here. The proper way would be to remove latter assertion AND making sure that this one is happening (probably by wrapping the whole thing in return new Promise(...) and resolving it in onError.\nThis could be done, but as I've said - I didn't want to change too much, I just finally got annoyed by messy output which has been produced and I've fixed it in the fastest way I could.. that's also kinda true - this relation is implicit, maybe we could just add a note to the test's description, smth like:\njs\ntest('saga onError is optional (the default is console.error)', () => {\n  // ...\n}). @restrry u know that logic better, is this condition a good one for this check? Can it yield false positives?. hm, shouldnt \"lastSaga\" have location nearly in all cases then? \ud83e\udd14 . do you know what's the problem? i guess codesandbox doesnt support babel customization?. do we plan to publish this? . was this causing a problem? \ud83e\udd14 . is this testing the reported issue though? the reporter mentions async functions being involved (which makes them trnaspiled to generators)\nisnt this code here having location? (its not inserted by babel). hm, this seems terrible for our use case as preset-env is really popular (as it should be - it's primary use case for babel now)\nI'll try look into this as soon as possible to see how babel handle this and if there is anything we can do to overcome this. That would definitely help, I'll try to dig into the babel location stuff in the meantime. this will still throw unhelpful error for\njs\nyield call(delay, Symbol())\nIMHO better solution would be to just stringify explicitly args[0] - String(args[0]). good catch, could u add a test for this?. Could you rewrite this test (or add another one) to cover this in more explicit manner? The fact that race cancels losers is an implicit one, would be good to have a straightforward test for this.. as there is no assertion here it would be at least good to add a comment here that the true assertion is that it doesnt fail - or add\n.catch(() => {\n  throw new Error(\"This shouldn't happen, this saga shouldn't crash.\")\n})\n(or similar). its a dev path and it's strictly addressing the delay case, so maybe we could do this typeof args[0] === 'number' ? args[0] : 'ms'?. Not sure if this is needed in main README. ",
    "abettadapur": "I packaged redux-saga-devtools into a Chrome extension for folks to use\nhttps://github.com/abettadapur/redux-saga-devtools-extension. Thanks for the reply!. I think it would be really helpful to add a doc section on this, or beef up the get/setContext api reference, because these gotchas aren't exactly clear. ",
    "DjebbZ": "Thanks @slorber for link to the (long) discussion. My understanding is that Sagas are a way to represent side-effect as pure data (declaratively) and let a special runtime/manager execute them. In this case CSP can be viewed as an implementation detail of the manager. Could use callbacks, Promises, whatever. Am I right ?\nWith regards to synchronization between forked tasks @yelouafi, indeed channels may make flow harder to reason about when there's a lot of them but they provide all the power to handle async cases. I hope you'll find a way to synchronise them, because handling any complex async flows declaratively would be just awesome.\nBTW, have you seen Cycle.js ? It uses Observables from Rx to manage flow and side effects. In Cycle, the program is a pure function from input Observables to output Observables. You get the testability benefit from Saga, and while not completely declarative (flows are not data, they're operators on Observables), you get some \"declarativeness\" since each Observable must declare all the other Observables it uses and no one can change this from the outside. I know that Cycle.js auhor is working on generating flow diagrams from code just by reading the Observables declaration.\nMakes me think : all declarative is nice to read/write but always seems limiting, whereas full imperative/functional is limitless but can lead to spaghettis. Sagas seem to be somewhat in the middle ground. Is it because it's impossible to have both ? Are we using the wrong paradigms ? Is it a limitation of the language ? Should we all move to LISP (half a joke, really) ? Or Dedalus (watch this GREAT talk, you'll understand my point on languages) ?\n. My bad, I can't find any difference. I must have mistaken a .md file with the wrong page. Expect some easy \"typos\" PR(s) soon !\n. I finished my round of typos fixes. Hope this helps !\n. Haha :)\n. ",
    "mocheng": "@yelouafi In my understanding, CSP works in blocking approach. Every put holds until the message is take-ed by another process. Every take holds until there is message put into the channel.\nIn Redux-saga, the Store is the global channel, but take and put don't work in blocking approach. This makes Redux-saga not actually CSP. Am I correct?\n. ",
    "mheiber": "@mocheng as far as I can tell, redux-saga is most like CSP with a single channel. put and take block the current saga (\"coroutine\" in CSP terms):\n- Calling take(actionType) blocks the current saga until an action with actionType is dispatched\n- Calling put(action) immediately dispatches the action, causing the store state to be synchronously updated. Any lines of code in a saga after a put are executed after action is processed by the reducer and the store is in its next state.\n. @andarist thanks for the correction. I think the main point stands, however, which is that put blocks (The next line of code in the saga doesn't run until after the reducer has done its work). Not 100% sure, but I tested with some small examples. \n. I don't know enough about the implementation of react-native-sqlite-storage to know if this creates a memory leak or something, but you can use a promise to pull out the transaction from the callback and await it using yield:\n``` js\nconst getTxn = () => new Promise((resolve, reject) => {\n    db.transaction(txn => resolve(txn))\n})\n// in a saga\nconst txn = yield getTxn()\n```\n. whoops, duplicate of #516\n. ",
    "b4stien": "Hey @yelouafi, the link you mentioned is not reachable anymore, can you update it? This page is the first link googling redux saga and async/away\n. ",
    "fhelwanger": "I think the link @yelouafi pointed to is in the docs now. Check: http://redux-saga.github.io/redux-saga/docs/basics/DeclarativeEffects.html\n. Great work @yelouafi ! :+1: \nThis issue has just affected me, I was dispatching on componentDidMount.\nI'll just use setTimeout for now.\n. Perfect! Tested it and is working as expected.\nThank you so much @yelouafi \n. It stands for Continuation-passing style.\nMaybe it should be mentioned in the docs?\n. Maybe we could have an eslint-plugin-redux-saga for that, like eslint-plugin-react.\nDo you think it's worth?\n. I don't know what is expected to happen in this case, but why you need to take USERDATA_PENDING?\nIf it's always dispatched after you put loadUserData, I think you don't need it.\nThe success and failures actions being asynchronous should be taken normally.\n. I think you can do that without taking the USERDATA_PENDING action. Navigation can be done as follow:\njs\nconst { id } = yield take(SHOW_PROFILE)\n(typeof id !== 'undefined') ? yield put(loadUserData) : yield put(<someOtherAction>)\n// You don't need it, just navigate to the other page immediately\n// yield take(USERDATA_PENDING)\nyield call(history.push, 'other-page')\nThe loading spinner should be shown based on your app state, which is managed by your reducer.\n. Take a look at https://redux-saga.github.io/redux-saga/docs/api/index.html#runsagaiterator-subscribe-dispatch-getstate-monitor\n. Your listenBefore callback is in a different context than your saga, it's a normal function, not a generator. Thus, you can't use yield and redux-saga insn't aware of it.\nI'd call listenBefore outside my saga (maybe where you setup react-router?) and use store.dispatch to dispatch LOCATION_CHANGE. Then, inside the saga, you can yield take('LOCATION_CHANGE') to handle additional side effects.\n. I don't know why it works with yield*, but you should probably change the following line:\ndiff\n- const action = take('FETCH_COMPANY')\n+ const action = yield take('FETCH_COMPANY')\n. It was changed on 0.10. Check: https://github.com/redux-saga/redux-saga/releases/tag/v0.10.0\n\nRemoved deprecated getState argument passed to Sagas. You can use the select Effect to get the store state\n\nTo see how to use select: https://redux-saga.github.io/redux-saga/docs/api/index.html#selectselector-args\n. Take a look at https://redux-saga.github.io/redux-saga/docs/advanced/Channels.html, specially eventChannel.\n. ",
    "ducin": "redux-saga won't be internally rewritten to use async/await instead of lower-level coroutines, according to #987. But is it safe for developers to write sagas as async functions? All places, where we actually yield async stuff would make sense, but call is synchronous - would that be a problem? And the only reason for call is clean testing (which is , as a side effect, disabling async await)?. @Andarist thanks for great explanation!\nOk, so basically, replacing generators/promises with async/await would limit the range of possibilities. Is the reason for async await-based sagas incapable of performing effects the fact, that what is yielded with redux-saga is a POFO object (representing the effect), whereas with A/A it's a promise, natively?\nBTW is there any docs page discussing A/A vs redux-saga?. ",
    "corysimmons": "\nGenerators might seem like an overkill, they are certainly less familiar to most of JS developers - but they are uniquely powerful.\n\nSuper interesting. Kinda makes me sad async/await exploded in popularity before people (me) really got to explore generators.\nThanks for sticking to guns on generators. Now I have a good reason to grok them.. ",
    "youknowriad": "Hello,\nThere are some problems I see here : \n- This breaks the redux principle of single source of truth\n- It could make devTools harder to implement (time travel)\n- Personally, I dont' see the Redux State as an UI state but more as the Application state, The UI state is extracted from the application state using selectors. I've found your approach of using the getState in the root Saga only quite nice, somehow equivalent to the \"smart/dump React components\" approach of using the redux State.\n- What about isomorphic support ?\nThanks\n. @slorber May be It is because I have not the necessary backend knowledge you have to consider the event log as the source of truth for frontend application. I think I need to see an implementation of this to have a precise idea about this.\nBut what I'm certain of is that we need to have only one single source of truth for the entire frontend application. Redux suggest the state of the store is this source of truth and It works quite well for any frontend application. \nIf I understand what you suggest, It's storing a log of events (actions) that happened from the bootstrap of the application (or from the backend for isomorphism first loading), and generate the state (redux state and sagas state) by \"playing\" those events. While I understand that storing those events is helpfull when implementing TimeTravel (debug features), I think that It may overcomplicates things compared to juste using getState on root Components and root Sagas to achieve quite the same thing.\n. @yelouafi what an answer :smile: this could make a good blog (medium) post I think to show the strength of Sagas\n. Actually when writing my post, I really thought we should extract the saga runtime from redux-saga, and make something like co, but more generic. I mean a generator runtime in which we can configure how to deal with each type of yielded value :\njavascript\nconst myGenerator = function*() {};\nconst config = function(next, yieldedValue) {\n  if  (yieldedValue && typeof yieldedValue.then === 'function') {\n    return yieldedValue.then(next);\n  }\n};\nconst myRuntime = createRuntime(config);\nmyRuntime(myGenerator);\nI would love to have your opinion about this, and may be a less ambitious option (more pragmatic), is to extract the redux-saga runtime as is in a saga-core lib ? \n. Using promises in the runtime core can lead to some weird bugs like this one #50 \nI did a small experiment of I can imagine being a generic generator runtime without using promises to avoid synchronisation problems, you can check here.\nhttps://github.com/youknowriad/generator-runtime-experiment\nWhat do you think ?\n. @yelouafi you're absolutely right, just made the replacement. I don't handle all the uses cases (race, cancel) etc... and errors are not yet handled correctly but It seems very doable to me, I'll try to add this stuff later.\n. @yelouafi great, good news, even if the promise code looks nicer, I think this is the right choice to avoid any unwanted side effect :)\n. I think one of the main ideas behind redux-saga is avoid using action creators (thunk or whatever). I don't know exactly what is myAction doing, but may be you should consider rewrite myAction, to return a promise and do something like.\njavascript\nconst promiseResult = yield call(myAction)\nyield put({ type: 'myActionTriggered', payload: promiseResult })\nBut If you really want to dispatch thunks using 'put' you might have to change the order of the middlewares in the applyMiddleware call.\n. May be you should consider https://tonicdev.com for code snippets. I have to admit I've never used it yet, but I was really impressed by the possibilities (embed a live running code).\nIt have also a Gitbook plugin.\n. I've found this workaround, make the promise uncancelable : \n``` javascript\nexport function* mySaga() {\n  const task = yield fork(myApiCallSaga)\n  const taskPromise = new Promise((resolve, reject) => {\n    task.done.then(resolve, reject)\n  })\n  let { timeout, result } = yield race({\n    timeout: delay(500),\n    result: taskPromise\n  })\nif (timeout) {\n    yield put({ type: 'display-something' })\n    result = yield taskPromise\n  }\nreturn result\n}\n```\nWhat do you think ?\n. great, that means we can close the issue \ud83d\udc4d.  Thanks a lot for the hard work.\n. ",
    "timdorr": "\nActually I don't know what is the claim of Redux, but for me Redux has never been the source of truth. \n\nWell, then you're using it wrong :smile: It's the first of Redux's three core principles. \n\nYou can project this event log to 2 or * redux store instances.\n\nThere is only one view in your application. You don't need multiple stores. That just needlessly complicates your application. I think you might be influenced a bit too much by backend systems. Browsers and Javascript are a very different paradigm.\nYour UI is simply a function on state, i.e. React(state) = view. Replaying an event log to compute that view doesn't make any sense. You should let your state container (Redux) handle that computation of final state so that React can render it.\n\nIt is really worth projecting everything in a Redux store and immutable data structures if they are not even rendered?\n\nAbsolutely! You may have non-visible state that needs to be managed. Take analytics data for instance. You might collect that into your state to occasionally ship back to your server. \n. That could work. What happens when one of those promises isn't invoked during startup? \n. Sorry, I may be getting my terminology mixed up here.\nSo, say you have sagas for loading up users, products, and orders. If I visit the product page, then it will probably not fire actions that invoke the sagas for users or orders. So, if I want to Promise.all(sagaMiddleware.promises).then(render), I'm going to have promises in there that will never resolve. \nThat may be a contrived example. Does it get the point across well? If not, I can try to think up something more concrete.\n. ",
    "dts": "A canonical example of a JS application where multiple replicas might be kept in sync with streams of actions would be a browser extension with a background page and content scripts, or a web page with web workers.  In these cases, the way for these contexts to communicate is through actions, and sending \"diffs\" or copies of the state is less advantageous.  These all also have the additional benefit of only caring about certain subsets of actions - a content script, for example, only subscribes and and processes actions relating directly to it, whereas the redux context for the background page evaluates and manages the ones that it needs to (which in most cases is probably all of them).\n. Phrasing it another way: is there a way at any given time to see if there are any sagas outside of the \"waiting to take\" phase?  This way you could, in the server-side renderer look and see if there are any outstanding processes, and wait for those to terminate (with a timeout race condition!) before releasing the HTML.\n. The downside of this is that you have to specify startup sagas as a specific category, which might be a different set for every different page.  For me, sagas that get initiated during the routing/matching process that happens are \"startup\" sagas - a preferred syntax would be (modified form https://github.com/rackt/react-router/blob/master/docs/guides/advanced/ServerRendering.md)\n```\nimport { renderToString } from 'react-dom/server'\nimport { match, RouterContext } from 'react-router'\nimport routes from './routes'\n// this is made up, obviously:\nimport { activeSagas } from 'redux-saga'\nserve((req, res) => {\n  // Note that req.url here should be the full URL path from\n  // the original request, including the query string.\n  match({ routes, location: req.url }, (error, redirectLocation, renderProps) => {\n    if (error) {\n      res.status(500).send(error.message)\n    } else if (redirectLocation) {\n      res.redirect(302, redirectLocation.pathname + redirectLocation.search)\n    } else if (renderProps) {\n      waitToComplete(activeSagas).then(() => res.status(200).send(renderToString()));\n    } else {\n      res.status(404).send('Not found')\n    }\n  })\n})\n```\nWhat this entails is that some care needs to be taken with authentication and other long-lifed sagas such that they detect whether they are on the server side or client side (or be written and included separately), and do their business in slightly different ways:\nClient auth: \nwhile(true) {\nif(!token) { yield take(SIGN_UP); yield put(authenticating) -> yield take(SIGN_OUT) }\nelse      { yield put(call(authorize,token))); yield take(SIGN_OUT) } \n}\nServer auth:\nif(token) { yield put(call(authorize,token); }\n. @slorber - I don't think that half-executed sagas and server-side rendering are going to play nicely- we don't want to encode all aspects of the current state of the sagas (meta-state) in the state.  I think the only reasonable solution is to have some sagas execute differently on the client and on the servers, which is quite straightforward - there is a list of sagas that is executed on the client, and a possibly intersecting but not identical set of sagas that run on the server.  Resource fetching, for example, might have a much shorter timeout on the server than on the client.\nThere may be a need for some halfway piece, with some server-side sagas beginning and handing off to client side sagas, but I think the only clean way to mediate that is through officially ending the server-side saga, and picking up where it left off by leveraging the current state.\n. The saga methodology is IMHO perfect for a lot of different client/server asymmetries.  On the server side, an externally-similar saga does resource fetching compared with the client.  The server-side saga would have different timeouts and error management, but the trigger and effect would be the same or similar.  When some component wants a resource, it triggers an action that on the server triggers one saga, and on the client triggers a different one.  I love the simplicity of this approach, and I wouldn't call it a downside, I'd call it, \"let's keep shit simple, people\".\n. So the whole API would be to mount saga middleware, just without the list of sagas, then call this when you want to fire up individual sagas?  This makes sense to me.  This way, on the server-side you say runSaga(fetchResource,store).then(renderToString)\nWhere fetchResource forks off into as many as needed (each fork racing against a timeout), and the global waiting for a DONE_ROUTING signal, at which point it cuts off waiting for more fetches.\n. @yelouafi - will task.done.then() only return once all forks are finished, or only when the main one in question is completed?\n. I am loving where this all is heading!  For me, constantly \"racing\" the SIGN_OUT take is problematic for the simple reason that it is shortsighted - perhaps there will be some other action should cancel this in the future, and then you have to add an item to each of the races.  Having forked \"processes\" be generally cancellable is the only way to go long-term IMO.\nI see the advantages of using the exception system for this: it does the 'correct' thing and immediately stops what is going on, and allows you to handle the cancellation in any way you see fit.  However, it does seem like an abuse of the exception system - someone \"canceling\" a behavior is not exceptional behavior at all, and I shy away from using exceptions for non-exceptional behavior for semantic reasons.\nThe obvious (though admittedly horrible) alternative is a more \"opt-in\" system where you check against some state variable whether or not the current thread has been canceled  (this.isCanceled() or whatever).  Are there any other thoughts on the mechanics for this cancellation?\n. Oh, I am sure that it currently is, and that it probably should stay that way.  Adding another important keyword to the mix is likely to do more harm than good with this framework! The this.isCanceled() syntax was honestly intended to be a straw-man in order to elicit a better one :smile: \n. We're arguing about a very small point here, so I would like to say that the exception mechanism is the best I've seen - I am merely trying to point out what I see as a weakness that we may be able to improve.\nWith that out of the way, I would argue that any event that is triggered by a user action is inherently \"non-exceptional\". KeyboardInterrupt is related to a SIGTERM, so I'd put it in the \"borderline\" category, and OutOfMemoryError is not a result of user action at all.  That's the high-level view that I see, anyway.\nAs for the mechanics, the default behavior of the exception mechanism is to drop everything semi-immediately, cleanup must be explicit with a try/catch/finally syntax.  If there are asynchronous tasks that need to be performed in order to safely cancel something, that's additionally complicated (I assume it's possible, though).\n. In my experience debugging sagas, there were a few different behaviors that would have made sense at different times, and that was in the span of a very short time.  The general takeaway that I had was that trying to debug these effects without the redux dev tools visible and able to \"turn off\" some of the effects from a previous-reload saga, it was awkward to debug stuff.  I'd change some code to change the behavior of a saga, which would hot-load things, prevent the previous saga from completing, and I'd have to undo the actions the saga performed (leaving it in a now-incorrect state), so that I could trigger it again.  This was fine in my case, because of the simplicity involved.  Using the reset/revert/sweep/commit buttons would make this approachable for more complex interactions.\nAll this is to say that this does complicate the dream of \"just keep iterating, and don't touch the app much\", though I don't see a way of dealing with this unless we build sagas into a dev tool.  In such a dev tool, we could indicate what kind of behavior we want, such as \"I am interested in THIS point in the saga\" - if we add first-class support for timeouts in the sagas API, we can have the saga timeline appear with a \"scrubber\" that moves in response to user action & the flow of time, but we can also \"peg\" it somewhere.  Every time a reload happens, we play back the actions and the saga flow until we get to that point in the saga.\n. ",
    "billyjanitsch": "I elected not to because:\n1. Mixing webpack-resolved requires with Babel-transformed exports is kind of a hack to get around lack of support for conditional imports. My proposed solution requires knowledge of Babel internals and could break in future versions; maybe there's a more robust way to solve the problem.\n2. Given this fragility, I'm not sure how much documentation @yelouafi would want along with a fix.\nThis is the sort of situation where, as a lib author, I'd prefer if someone just pointed out the problem and let me figure out the best solution. However, if you're content with my proposal and don't think anything like a // HACK is necessary, I'll gladly submit a PR. :)\n. Didn't realize that, thanks for the clarification! :) PR: #11\n. There's no infinite/blocking loop here (see the switch cases with return statements). For more info about how this works, look into Facebook's regenerator, used by Babel. Generators (both natively and as simulated by regenerator) are non-blocking. Promises don't quite accomplish the same goal.\n. ",
    "satispunk": "@yelouafi \nIt is not very convenient to check it without npm release at the moment. But will do it as it released\n. Got it! Seems it works now.\n. Interesting! Didn't know about React handlers. I have noticed that there is a difference while dispatching actions in component handlers and promise callbacks\nSo what do you suggest guys if I have similar code? I would like that last 3 put calls will not call render each time. Shall I use batch-actions for that?\n``` javascript\nyield put(request())\n        try {\n            const state = getState()\n            const login = state.LOGIN_VIEW.get('login')\n            const password = state.LOGIN_VIEW.get('password')\n            const data = {login, password}\n            invalidate(data)\n        const response = yield call(post, loginUrl(), data)\n        yield put(success())\n        yield put(user(response))\n        yield put(navigate(V.USER_INFO_VIEW))\n    }\n    catch (error) {\n        console.error(error)\n        yield put(failure(error))\n    }\n\n```\n. @gaearon Thx. I will try.\n. ",
    "bgerm": "Thanks, @yelouafi.  Works great.\n. Thanks for the reply, @slorber.  I wound up using task cancellation to achieve the same thing.  You pointed me in a just-do-it-another-way direction.\n. ",
    "ashaffer": "IMO trying to serialize the state of a saga/effect is the wrong approach. It's complicated, error-prone, and unlikely to capture the exact semantics that you want all the time.\nA better approach, I think, is to create some function of state that decides when to complete the rendering process on the server. E.g. isReady(state) is true when no relevant sagas are in progress. This is the approach i'm trying to take with vdux-server.\nIf you take this approach, then it is simply the saga's responsibility to let things know when its done, if this particular saga is one that you want to be completed server-side first. If it's a saga you don't care about, then it doesn't need to contribute to this loading state.\nThis also neatly addresses problems like certain sagas not necessarily beginning immediately and therefore possibly being skipped if you tried to collect all promises, for instance.\nEDIT: In thinking about it a bit more, it does seem like there is possibly an exceptional case for sagas that are non-transient. Like if there is some kind of saga that you want to begin server-side, and persists indefinitely on the client, but you wish to restore it's state. This seems like a weird case though. Are there any actual examples of something like this being desirable?\n. ",
    "tappleby": "\nI don't really like the monkey patching solution used to make this work.\n\n@yelouafi Since you need a store instance to run a saga this could be a good use case for a store enhancer instead of middleware:\n``` js\nexport function reduxSagaStoreEnhancer(...startupSagas) {\n  return next => (...args) => {\n    const store = next(...args)\n    const sagaEmitter = emitter()\nfunction dispatch(...dispatchArgs) {\n  const res = store.dispatch(...dispatchArgs)\n  sagaEmitter.emit(action)\n  return res\n}\n\nfunction runSaga(iterator) {\n  check(iterator, is.iterator, NOT_ITERATOR_ERROR)\n\n  return proc(\n    iterator,\n    sagaEmitter.subscribe,\n    store.dispatch,\n    action => asap(() => dispatch(action))\n  )\n}\n\nconst sagaStartupTasks = startupSagas.map(runSaga)\n\nreturn {\n  ...store,\n  dispatch,\n  runSaga,\n  sagaStartupTasks\n}\n\n}\n}\n```\nUsage:\n``` js\nconst finalCreateStore = compose(\n  applyMiddleware(...middleware),\n  reduxSagaStoreEnhancer(...startupSagas);\n);\nconst store = finalCreateStore(...);\nstore.runSaga(iterator);\n```\nAn added bonus of using a store enhancer is you can expose the promises for startup sagas:\njs\nPromise.all(store.sagaStartupTasks).then(renderToString)\n. Yeah ordering can be an issue, since they are composed from right to left any enhancer that comes after in the chain that uses dispatch wouldnt trigger sagaEmitter.emit(action). I recently had to document this in redux-batched-subscribe... This is where I wish redux almost had more hook points for extending it eg. beforeDispatch, afterDispatch etc.\n. > A side issue of this approach is that replaying the Saga will re-triggers all api calls inside the Saga\nThis seems like an undesired effect (pun intended), especially if you have API calls creating resources on the server. \nThis is more of a brain dump; I'm not sure if this makes sense or is possible to implement in a maintainable way:\nWith \"pure effect/operations\" it seems like you could safely replay these to get the saga back into the proper state without actually executing the effects (would involve capturing the effect description + result); The challenge is what to do with impure operations (and how to detect them).\nOnce you hit a point where a saga starts to branch from the previous timeline any future actions or operations (in redux devtools / all sagas) are no longer valid since they could depend on values which were only valid in the \"alternate universe\".\nGit almost has a similar issue with merge conflicts where with manual user intervention you can get to the desired end result; I could see a devtool possibly having a similar interface which would give you the choice to keep the previous result or execute the effect again when we detect a possible branch point; If the effect had the same result it would be safe to continue replaying future actions + operations, otherwise we would have to stop at the point it branched.\n. Yeah a component was probably a bad example (though I have been curious if proc could be used locally within a component to manage complex flows). I mainly wanted to show the cancelling of saga on unmount.\nStarting the saga at module load time seems like the correct approach; I could see this working well with dynamic routes in react-router.\n. I do like the idea of keeping it generic, would remove the need for things like emitterFromStore or store enhancers mentioned in #13.\nIs there a common interface that other libraries seem to be using for channel like functionality? closest thing I can think of is Rx.Subject.\n. :+1: \n. Would it make sense to keep it similar to Function.prototype.call and Function.prototype.apply?\ncall works as is, if you need binding use apply?\njs\ncall(method, arg1, arg2, argN) // Could be an alias for apply(method, null, [arg1, arg2, argN])\napply(method, context, [arg1, arg2, argN])\n. not sure if the same applies for RN but browsers need to include the babel-polyfill - https://babeljs.io/docs/usage/polyfill/\n. @yelouafi perhaps its worth mentioning in readme?\n. ",
    "pavelkornev": "\n@dts it will only resolve with the main one. If you want to wait on some or all forked sagas, you have to use join to wait their termination\n\n@yelouafi could you give an example with fork/join? Is it something like the that?\n``` javascript\nfunction* rootSaga() {\n  const task = yield [\n    fork(subtask1, ...args),\n    fork(subtask2, ...args),\n    ...\n  ]\nyield join(task)\n}\nconst task = runSaga( rootSaga(store.getState), store )\ntask.done.then( renderAppToString )\n```\n. @yelouafi thanks \ud83d\udc4d\n. @Dattaya i can describe what we've done in our app. We've created simple sagas which don't listen for a specific action to happen. When request happens, components return lists of sagas they need to perform for prefetching data. Then we compose this list of sagas in one root saga and run it. Afterwards, when all sagas are completed, we render the page. On the other side, on client side, we wrap all these simple sagas in wrappers which are waiting for a specific action to happen, we call them 'watcher'. We took some ideas from this example - https://github.com/yelouafi/redux-saga/blob/master/examples/real-world/sagas/index.js\n. In my opinion it would be perfect if components don't even know about sagas existence. Components should operate only with actions. But i can't figure out an appropriate way how can we distinguish on the server the moment when all sagas are done. I mean, we can register all sagas on the server like we do on the client, then emit actions to run them, but when to render? I will appreciate if someone can come up with ideas or with ready to use solution :-)\n. @yelouafi i do exactly what you have just described. But it does not solve the problem i've mentioned above.\nHow can we determine which tasks (serverSagas) we should run for getting data to render particular page? The only way i see is asking component's what they need by shaking tree of components which we have in call callback of match function from react-router. But question is \u2014 what should return components \u2014 task or action? In my point of view, the power of redux-saga is that it can make components more abstractive from data loading and all async stuff which means components should not even know about sagas existence; components should operate only with actions. In other words it should return an action. I hope it sounds logically. Now let's see how we can implement it step by step:\n1. First step is easiest one. As many solutions for server-side data fetching suggest, we can write static method. This method will simply dispatch actions or set of actions.\n2. We need somehow be aware which sagas to run. We can't figure this out by those actions which our components have just emitted in Step 1 since actions don't depend on sagas at all. Easiest way is to register all serverSagas at once, but we need to filter those of them we don't need. In other words, we need to exclude those tasks which was not triggered by emitted actions because our Promise.all will never be resolved with them. And that is a problem.\nI hope it's clear now.\n. @yelouafi what do you think if i make an example of our approach of universal saga usage and PR?\n. I've just committed the approximate solution. If you disable JavaScript in the browser you will clearly see that server return page with necessary data:\n\nDevTools has been disabled (see file ./containers/Root.dev.js) since there is an error around it:\nWarning: React attempted to reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injected new markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server:\n (client) 1.1.$/=10.1.$1.0.0\">LOAD_USER_PAGE</div>\n (server) 1.1.$/=10.1.$1.0.0\">USER_REQUEST</div><d\nIt's not that obvious how to fix it. I would ask @gaearon as an author of these dev tools for an advise.\n. @casertap my solution is obsolete. Please use END effect. More details in #255.\n. Redux-saga semver change is crucial in this PR. It does not work at this moment with 0.3.3 version.\n. No, since i have committed to my master branch realworld-universal example. I need to clean up solution a bit, and then i will make a new PR with new example and fixes in original realworld example.\n. What we need is an indicator when sagas are not running. Instead of returning Promises from sagas itself i propose sagaMiddleware.done similarly to done property of the tasks.\nThen we can use client and server side sagas on both sides and isolate our components from sagas existence (see my solution in #13).\nThe only problem i see so far is endless cycles in sagas which we use to demonization:\nwhile(true) { ... }\nAs a work around sagaMiddleware can track take effects internally and and resolve global promise when all registered sagas in the first stage; this means all sagas are waiting for an initial take effect.\n. @yelouafi\n1. Yes, react-redux-universal-hot-example uses redux-async-connect. But it actually doesn't collect promises \"on the server from mounted components\". It collects promises from statics of the resolved with react-router components. Where is difference? If we collect from mounted components that means we called renderToString, then wait while all collected promises resolved and then render again, so it's rendering twice. On the other hand, downside of collecting promises from resolved components via react-router is that we collect promises only from them and we don't have access for possible children which means we obligate parent components to know which data need their children.\n2. About middleware we are talking about almost same problem but on different angle. Difference between two approaches is: you say \u2014 we should not register unnessary sagas on the server which give us a problem to know which ones we need and it's not that trivial as it seems, mine \u2014 start all sagas and kill those are not using.\nStarting all sagas is a way easier then determine which ones we need for our rendering tree. That's why we do so on the client and it works like a charm. So why it could not be same useful on the server?\nBut there is one little thing. How to determine which ones we need to kill out of our waiting list? As it proposed above we can kill those are at the initial take effect. So, on the server side components will emit events to run necessary sagas, then we filter list of registered sagas by killing Idle sagas and return promise which resolves when working sagas finish their work.\n. @yelouafi 'saga driver' sounds promising. Could you help with implementation?\n. @quicksnap @yelouafi\nI'm currently working on that kind of solution which makes it possible to run same sagas on both sides without pain. It's based on idea of orchestration sagas in custom Saga Monitor. Hopefully i can show it soon.\n. Each saga effect actually emit events. For more details look in sagaMonitor implementation.\n. Have you tried like so:\nstore.runSaga(rootSaga).done.catch((e) => {\n  console.log(e.message)\n})\n. ",
    "Dattaya": "Does anyone have an example of a universal app with redux-saga? Or maybe I don't need it on the server since there is no user interaction there and I can process my simple LOAD actions as it was before with a special redux middleware that returns a promise?\n. @pavelkornev thank you so much for your response and example. I've been busy with other stuff, so haven't had a change to try it, but I'm definitely going to.\n. ",
    "ntkoso": "I'm using almost the same solution, but instead generators / sagas fecher functions return fork effects.\ngist\n. I think main point of redux-saga is total isolation of components from side effects. With ability to dispatch sagas you effectively enable ability to dispatch side effects. And people will try to use redux-saga the same way they are using redux-thunk, redux-promise, etc... \nSome confusion for new users in this case:\n``` javascript\n// some ./src/actions.js\nexport function fetchSomething(...args) {\n  return function* () {\n    return yield call(fetch, ...args);\n  }\n}\nexport function clickFetch() {\n  return function* () {\n    const result = yield put(fetchSomething(...args)) // put === dispatch ?\n    // or\n    const result = yield call(fetchSomething(...args)) // put vs call ? put vs fork?\n  }\n}\n```\nThey will miss whole point that sagas operate on single 'reduxStoreActions' channel. And then will ask why put named 'put' instead of 'dispatch'.\nIdea of flux was in clear separation of business logic and views using action log. \nAnd redux-saga takes it to the new level with 'daemons', making action creators pure.\n. ",
    "ganarajpr": "Is there an example somewhere that shows how we could use saga with a universal app ? \nI am currently working on a universal app and I wanted to integrate saga with it. Any examples or pointers would be highly appreciated. \n. @wizardzloy I can understand where you are coming from - and I had the same initial reaction with saga. It feels soo much like emitting an event and catching it somewhere else to do something. BUT.. the real power of saga comes in because it allows you to specify complete user interaction flows as a single function / generator. This is something you cannot do - as elegantly with event emitters is my guess. This is mostly enabled because of the control flow constructs provided by the generators. \nHere is an example \n``` javascript\nfunction * onEditAddress(action) {\n  yield put(showAddressFormDialog());\n  const { success } = yield race({\n    success: take(SAVE_ADDRESS_SUCCESS),\n    error: take(SAVE_ADDRESS_ERROR),\n    close: take(HIDE_ADDRESSFORM_DIALOG)\n  });\n  if (success) {\n    yield put(hideAddressFormDialog());\n  }\n  // ... further control flow logic..\n}\nexport function * watchStartEditAddress() {\n  yield* takeLatest(START_EDIT_ADDRESS, onEditAddress);\n}\n```\nBy just seeing this generator its quite clear how the application flow is structured. This same elegance is not possible with event emitters as far as I can tell. Let me know if you think otherwise.\n. ",
    "prashaantt": "@pavelkornev Please do, that would be amazing! I was just going to ask you for the same on this thread.\n. Thanks for the pointers guys, things are certainly clearer to me now. I have now begun to understand sagas as intercepts to regular redux actions, which can then carry on async background jobs, and call other redux actions in turn when done.\nWhat I'm still figuring out to do properly is to decide on how to structure multiple sagas in a complex app and wondering how many of these async actions can I keep checking for in an infinite-ish while loop. For example, I may have tons of API requests to make at various points in my app \u2014 will I have to boot my app with all those forked while loops waiting for those future actions without needing to worry about any performance issues?\n. My bad, I just noticed that examples/real-world has its own package.json. But I was misled by the real-world script in the root package.json that somehow made me believe I should be able to run it from root itself.  Perhaps you could remove it from there to prevent this confusion.\n. I just found a better way to handle this:\n``` json\n// package.json in root\n\"scripts\": {\n  \"real-world\": \"npm --prefix examples/real-world install examples/real-world && node examples/real-world/server.js\"\n}\n```\nI'll submit a new PR if you like it.\n. I missed this: it's possible now to also change the README and make it conform to other example instructions:\n~~cd examples/real-world~~\n~~npm install~~\n~~npm start~~\nJust:\nnpm run real-world\nWould you like this too?\n. ",
    "casertap": "@pavelkornev ok thanks for the link\n. Hey @gigavinyl I am happy to see that you got everything working :-)\nOn my case I am still struggling to make it works. It works on client side but not on server side and I am thinking this is related to react-router-redux. \nCan you please have a look to my issue and share what you did to make it work?\nhttps://github.com/yelouafi/redux-saga/issues/418\nCheers.\n. Hey @sompylasar thanks a lot for the answer.\nYour gist looks so complicated.\nI am mainly trying to replicate what is done on the real-world example under the redux-saga repo. This example does not have that amount of complexity compared to your sagaMonitor. \nI am sorry for the naive question I am about to ask but I am new to redux-saga: What functionality sagaMonitor is bringing to perform server side rendering while the real-world example is performing server side rendering and does not have all this complexity?\n. I am modifying a fork of the redux-saga/examples/real-world and I introduced react-router-redux without any trouble so this is not related to my problem.\nMy problem is that store.runSaga(rootSaga).done because no render is every done.\nI do not understand why the Root component never get rendered.\n. for the console I get from the real-world exemple, I get\nsaga run\nsaga dispatch END\nhydrate ON SERVER !!!!\nstart sagas\nwatchRequestLoadUserPage1\nROOT rendering\nWarning: Failed propType: Invalid prop `inputValue` of type `object` supplied to `App`, expected `string`. Check the render method of `Connect(App)`.\nrender app\nWarning: Failed propType: Invalid prop `value` of type `object` supplied to `Explore`, expected `string`. Check the render method of `App`.\ncomponent UserPage\naction oadUserPage\nwatchRequestLoadUserPage2 login casertap\nloaduser 1 casertap\ngetuser function getUser(state, login) {\n  return state.entities.users[login];\n}\nloaduser 2 undefined\nfetchEntity1\nentity directory [object Object]\ncasertap undefined\nwatchRequestLoadUserPage3\nwatchRequestLoadUserPage1\nfetchEntity2\nwebpack built 8ec321a4c5bdc20b3169 in 3780ms\nfetchEntity3\nloaduser 3 \"undefined\nsagas complete\nROOT rendering\nrender app\nWith my version I get\n[1] saga run\n[1] saga dispatch END\n[1] hydrate ON SERVER !!!!\n[1] start sagas\n[1] watchRequestDirectory1\nand I am stuck.\nOn both exemple I have\nconsole.log(\"start sagas\");\n      store.runSaga(rootSaga).done.then(() => {\n        console.log('sagas complete')\nthe difference is that the real-world exemple run many event starting from ROOT rendering while my version is never running the root render method.\nAny idea?\n. Thank you @sompylasar \nI updated the source code of my first post (I should have done that before). \nYou should be able to see all logging that I made.\nThe saga dispatch END is when the store get configured and created:\nconsole.log('saga run');\n  store.runSaga = sagaMiddleware.run;\n  console.log('saga dispatch END');\n  store.close = () => store.dispatch(END);\n  return store;\nI do not have the permission to reveal all the code sorry about that. This make debugging even more complicated, thank you for your patience.\nI made a clone of redux-saga and I simplified the real-world example to the bare minimum and it is working fine. I even updated the packages version number to match all the versions I have.\nI checked hundred of time and replicate exactly the same code but real-world example is working fine while mine do not.\nIf you do not find any problem with the code I provided. I will publish a slim version of the code base on a public repo.\n. Hey @sompylasar I created a slim version of the project so you can have a look and guide me through this. I really appreciate the help, thanks.\nhttps://github.com/casertap/try-redux-saga\nOk I understand the store.close = () => store.dispatch(END); but why this is not setup by the library itself? the library is modifying the store anyway because it added the runSaga function.\nMy end goal is to use your sagaMonitor code to have a solid universal rendering. I just would like to take baby step to try to learn saga along the way.\n. Sure @sompylasar but I want to have the server-rendering first. I am very close I think. I am just missing a little thing.\nCan you please have a look to my app? https://github.com/casertap/try-redux-saga\nI am sure you will detect the problem in no time. all the code as been slim down to the bare minimum.\n. I am sorry but the redux-saga/example/real-world app works perfectly. And it is a very close code base as what I have currently.\nSo I guess my question is: How is the  redux-saga/example/real-world app do to trigger the rendering of its components?\nhttps://github.com/yelouafi/redux-saga/tree/master/examples/real-world\n. Nice! I am starting to understand. I will try the TWO renders and then try your solution.\n. @budarin it was a long time ago, I can not remember sorry.\nI am pretty sure redux-saga developed some new and neat ways to perform server rendering in the mean time.. ",
    "aikoven": "Wow, thank you for detailed answer, it was extremely helpful!\nWhat I missed in my attempt were subroutines as generators with return statement.\nOne thing that still bothers me a bit is that we need to take SIGN_OUT in two places: authorize subroutine and main authFlowSaga. One idea is to race between authorize subroutine and take(SIGN_OUT), but I'm not sure if I can cancel the subroutine so that it won't continue execution upon sign-out. Still maybe that's overcomplicating, after all we can introduce another sign-out subroutine to remove duplication.\n. Further development strengthened my concern:\nIf my flow takes more async steps (e.g. fetching user info) then I have to introduce even more races with take(SIGN_OUT). But if I could cancel forked subroutine then it would become much simpler:\n``` js\nfunction* authorize() {\n  let token;\n  while (true) {\n    token = yield call(authService, token)\n    yield call(setAuthToken, token)\n    yield put(authSuccess, token)\n    yield call(delay, token.expires_in);\n  }\n}\nfunction* authFlowSaga() {\n  while (true) {\n    yield take(SIGN_IN);\n    const authLoopTask = yield fork(authorize);\n    yield take(SIGN_OUT);\n    authLoopTask.cancel();\n  }\n}\n``\n. Yes, throwing special error was what I thought about. I can work on PR with\nthis feature.. @dts Could you please add more detail on your point against exceptions? \nIt feels ok to me to use exceptions for canceling. As I see it, from subroutine's point of view cancellation _is_ an exceptional behavior. It is some external event that makes it interrupt, just likeKeyboardInterruptin Python or evenOutOfMemoryErrorin Java.\n. With automatic cancellation ofrace` competitors (see https://github.com/yelouafi/redux-saga/pull/17) it became even more concise:\n``` js\nfunction* authorize(refresh) {\n  try {\n    const token = yield call(auth.authorize, refresh);\n    yield call(auth.storeToken, token);\n    yield put(authorizeSuccess(token));\n    return token;\n  } catch (e) {\n    yield call(auth.storeToken, null);\n    yield put(authorizeFailure(e));\n    return null;\n  }\n}\nfunction* authorizeLoop(token) {\n  while (true) {\n    const refresh = token != null;\n    token = yield call(authorize, refresh);\n    if (token == null)\n      return;\nyield call(delay, token.expires_in);\n\n}\n}\nfunction* authentication() {\n  const storedToken = yield call(auth.getStoredToken);\nwhile (true) {\n    if (!storedToken)\n      yield take(SIGN_IN);\nconst {signOutAction} = yield race({\n  signOutAction: take(SIGN_OUT),\n  authLoop: call(authorizeLoop, storedToken)\n});\n\nif (signOutAction) {\n  yield call(auth.storeToken, null);\n}\n\n}\n}\n``\n. @Marinolinderhof In my project I used Google auth library that storedtoken` somewhere in memory and there was no need to keep it in Redux store.\nI guess the best solution for your case is to use select effect: https://redux-saga.github.io/redux-saga/docs/api/index.html#selectselector-args\n. @nouveller A common path is to start refreshing token before it expires, so that your current requests (and token refresh request as well) have time to finish.. I'd go with a generic generator for all API calls that first gets the token from Redux store using yield select(...), checks the token and if it needs refresh, waits for a TOKEN_REFRESHED action before making a request.. @marcelaraujo It's there already: https://github.com/redux-saga/redux-saga/issues/14#issuecomment-168997804. 1. Good point, I will make another commit to fix that\n2. I guess that makes sense too\n3. In my auth example I have following code:\n``` js\nconst authLoopTask = yield fork(authorizeLoop, storedToken);\nconst {signOutAction} = yield race({\n  signOutAction: take(SIGN_OUT),\n  authLoop: join(authLoopTask)\n});\nif (signOutAction) {\n  authLoopTask.cancel();\n  // ...\n}\n```\nauthLoop here is an infinite cycle that ends only when cancelled. I use fork here, not call, but if we did as you propose, it would be shorter:\n``` js\nconst {signOutAction} = yield race({\n  signOutAction: take(SIGN_OUT),\n  authLoop: call(authorizeLoop, storedToken)\n});\nif (signOutAction) {\n  // ...\n}\n```\nSo probably it's a good idea, but I need to think a bit more about this.\nMaybe it would be convenient to make promise returned from proc() cancellable and make race cancel every cancellable promise that had lost. Although I don't know if there is a standard for cancellable promises yet. See this discussion: https://github.com/whatwg/fetch/issues/27\n. @yelouafi Done. \nI decided not to go with cancellable promises because there is no convention and it would result in additional complications with making chained promises cancellable as well.\nSo I just cancel all subroutine that is still running after race resolves.\n. You are right, my code will go wrong if there was another called subroutine outside of race, e.g.:\njs\nyield [\n  call(subroutine1),\n  race({\n    subroutine2: call(subroutine2),\n    subroutine3: call(subroutine3),\n  })\n]\nIf race finishes before subroutine1, then it will be cancelled\n. I made a fix. I can make another PR, or you can revert the merge \ud83d\ude00\n. Sounds very reasonable!\nSo we'll need a _cancel method attached to promise returned from proc as well as promise returned from each run*Effect. \nWe can also make automatic cancellation of parallel / race effects simpler: just cancel the whole parallel / race effect after it completes. Race winner subroutine will already have _isRunning = false so _cancel becomes noop and we won't have to filter losers from winner.\n. One more thing: if we cancel called routine, then exception will be thrown in it, and if we don't catch it, then it will propagate to parent routine. Should we prevent propagation?\n. If we start two subroutines without handlers in parallel, then if first one\nfails then the second will be cancelled. Which exception should be pulled\nto parent?\n\u0421\u0440, 6 \u044f\u043d\u0432. 2016 \u0433. \u0432 21:19, Yassine Elouafi notifications@github.com:\n\nI think we should not prevent propagation. All cancellables Sagas should\ncatch cancellation exceptions to do any cleanup. If the canceled Saga omit\nthis; then the parent could handle the exception (for example, if one\ncleanup is relevant to mulitple child called sagas, the parent saga can\nhandle the cancelltion exception).\nOtherwise, we should IMO propagate the exception as JavaScript does with\nnormal errors\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/yelouafi/redux-saga/pull/26#issuecomment-169352952.\n. I guess we need to define semantics for thrown exceptions.\n\nFirst of all, the only way to cancel effect is to cancel routine that is currently blocked on it.\nSuppose that main routine is blocked on yield call(child). Then cancelling main effectively cancels call effect which in turn throws exception inside child routine. But if child routine caught SagaCancellationException and did not rethrow it, then it won't be thrown in main routine. I see two ways here: warn user when they don't rethrow, or just always explicitly throw same exception in parent routine. I would go with latter as less error-prone, but maybe there is a valid case with catching and not rethrowing.\nAs for manual cancellation of parallel/race effects: we throw exception in every subroutine, but it's unclear how propagation should work here, so we again have to explicitly throw exception in parent routine.\nCancelling join effect works the same as call: cancelling joined subroutine, then propagating to main routine.\nCase of automatic cancellation of parallel/race effects is simple: just ignore any exceptions from losers that come after parallel/race effect finishes.\n. > if someEffect failed, then we will cancel call(subroutine); if subroutine omitted to define cleanup code then we should propagate the exception to warn the developer and abort subroutine as well as main \nThen we'll end up with two exceptions: one for someEffect failure and the second for CancellationException; which one should we throw in main?\nI think that the way user handles cancellation in subroutine should not influence main routine; that our two operations should be completely independent: we first cancel current effect and then throw exception in main routine regardless of how current effect reacted on cancellation.\nI just don't see benefit in propagating CancellationException to parent assuming that it will be thrown in parent routine explicitly by (2).\nI propose the following:\n- If we have unhandled CancellationException then we stop parent routine immediately with exception; not via iterator.throw(), but by throwing it inside of next()\n- Any other exception propagates as usual\nThis way we won't burden developer to write extra boilerplate for rethrowing. And in my opinion it would be easier to reason about execution flow if it was only subroutine's business to handle its own cancellation. \n. About cancelling race losers:\nWhat if loser had some async cleanup code? Should we wait for it to complete before returning control to parent routine?\n. In regular Promise.race any loser promise rejection would be unhandled and I guess there is no way to warn about it other than just logging to console.\n. Maybe I'm wrong; I just think that result of cancellation of subroutine should have predictable effect on parent routine regardless of cancellation handling in subroutine.\nAnd in my opinion it would be easier if  CancellationException is local \u2014 i.e. if we caught it, then it means that current routine was cancelled from outside, not that some child routine was cancelled.\n. Ok then. \nI'm almost done, will push tomorrow.\n. Pushed. Here's how unhandled cancellation is reported:\n\nThinking about displaying effect stack in more readable way, maybe something like how you do in DevTools.\n. Looks great! Glad I could help \ud83d\ude00\n. In my case I first fetch some entities and then parse them according to locale setting. Entities and settings are stored in different branches of state tree, so I can't do the parsing inside entities reducer as it can't see anything outside of entities branch. I also don't like the idea to have a global reducer that can see the whole state.\nThe only place that seems right for it is saga (or thunk).\nBut there is a problem with getState: sagas (and thunks) must be aware of state shape. I was thinking about not using getState at all, but then I have no place where I can do my data processing that depends on different state branches.\nWe already have nice and composable way to collect dependencies from state \u2014 selectors. We can also reuse selectors between connected components and connected sagas.\nThis way the only place that depends on state structure is selectors; everything else uses selectors as a unique interface to the state. And reducers remain locked to their own branch.\nI've already implemented custom middleware that allows this approach and now I'm refactoring existing sagas. There isn't much boilerplate because I mostly reuse existing selectors.\n. @yelouafi I did that before, but it doesn't feel right that component has to query some state data that's not needed by component itself, only to pass it to saga via action. Again, if that saga would eventually require another dependency, we'd have to update every component that fires that action.\n. @yelouafi My current view is aligned with what you wrote: Saga is responsible for extracting all data required for API call. \nThere is ambiguity in whether it should process response or processing should be done in API service, but I think that it depends on how complex your service is. If every call is just simple fetch(), then maybe it doesn't make much sense to write a service to wrap it. But when it becomes more complicated, probably it's best to move that logic out of Saga.\nAny way if response processing requires some extra data from the store then we have to do extraction inside Saga.\nAnother ambiguity is separation of concerns between Saga and reducers: nothing stops us from calculating next state inside Saga and just passing it to reducer via action. On the other hand we could put response plus extra state data into action and do all processing in reducer. In my preferred model reducers are responsible only for create/update/delete in their specific state tree branches, without any other logic, and action payload contains minimal amount of data needed for reducer.\nConsidering implementation: there's no need to couple proc() with Redux. We can use dispatch argument of proc to pass child saga up to the middleware:\n``` js\nconst CONNECTED_SAGA = Symbol();\nfunction run(connectedSaga, params) {\n  // replace with new effect type:\n  return put({\n    [CONNECTED_SAGA]: true,\n    connectedSaga,\n    params,\n  });\n}\nfunction sagaMiddleware(...sagas) {\n  return ({getState, dispatch}) => {\n    const sagaEmitter = emitter();\nconst wrappedDispatch = (action) => {\n  if (action[CONNECTED_SAGA]) {\n    return proc(\n      action.connectedSaga(getState, action.params),\n      sagaEmitter.subscribe,\n      wrappedDispatch\n    ).done;\n  } else {\n    return dispatch(action)\n  }\n};\n\nsagas.forEach(saga=> {\n  proc(\n    saga(getState),\n    sagaEmitter.subscribe,\n    wrappedDispatch\n  )\n});\n\nreturn next => action => {\n  const result = next(action);\n  sagaEmitter.emit(action);\n  return result;\n}\n\n};\n}\n```\nConsidering decorators: from the discussion I linked to it seems that function decorators won't be supported any time soon. So maybe connectSaga should return some wrapper object, like \njs\n{\n  selector: function (getState) {...}, \n  saga: function generatorName(getParams) {...}\n}\nOr it can assign selector property to the generator function.\n. Just found out that you can actually change function name by \njs\nObject.assign(fn, 'name', {value: 'new name'})\n. @slorber Thanks for elaborative answer. I get your point.\nI agree that there are some drawbacks with this approach. One more that I already encountered is that state may change between effects which makes Sagas harder to test, i.e.:\njs\nfunction* saga(getParams) {\n  yield ...\n  const params1 = getParams();\n  yield ...\n  const params2 = getParams();  // may differ from params1\n}\nI'd like to have Sagas completely decoupled from state, still there are several cases that need to be resolved:\n- Replaying event log only works for sagas that were started on app startup. Which means that subroutines can't be connected. They can probably be refactored, something like:\n``` js\n// before\nfunction* subroutine(getParams) {\n  return yield call(service, getParams().param)\n}\nfunction* saga() {\n  while(true) {\n    const result = yield run(subroutine);\n  }\n}\n// after\nfunction* subroutineSaga(getParams) {\n  while(true) {\n    yield take(START_SUBROUTINE);\n    const payload = yield call(service, getParams().param);\n    yield put({type: SUBROUTINE_DONE, payload})\n  }\n}\nfunction* saga() {\n  while(true) {\n    yield put({type: START_SUBROUTINE});\n    const result = (yield take(SUBROUTINE_DONE)).payload;\n  }\n}\n```\nAlthough this is very verbose (which may be ok considering gained decoupling), but more importantly, there is no way to run several instances of subroutine in parallel.\nA workaround for this would be to just pass subroutine dependencies via arguments, but it would become a mess if parent saga calls many subroutines each having dependencies.\nAnother solution I see is to be able to clone running saga with all its internal state (similar to Unix fork). This way parent saga can clone subroutine before putting START_SUBROUTINE. But again we'd introduce coupling between parent saga and subroutine.\nThird solution is to extract another routine from subroutineSaga:\n``` js\nfunction* subsubroutine(param) {\n  const payload = yield call(service, getParams().param);\n  yield put({type: SUBROUTINE_DONE, payload})\n}\nfunction* subroutineSaga(getParams) {\n  while(true) {\n    yield take(START_SUBROUTINE);\n    yield fork(subsubroutine, getParams().param);\n  }\n}\n```\nWhich makes it even more verbose \ud83d\ude2b.\n- If we connect Saga using reducer, we'd again rely on state shape. Not global state, only one branch, but still. But here we can use selectors that accept this substate.\nI'll try to refactor my code with new approach to see if I can come up with more ideas.\nStill I'm not sure what are real benefits in having slice of state recomputed locally for each saga. In any way we'd have to query the state, even if it is local.\n. > Like React we have smart/dumb components. Wouldn't it make sens to only manage state in a \"smart generator\" (ie the saga) and the factorized/reusable subroutines could just receive required state as a parameter?\nThis proposal enables nesting \"smart\" sagas inside \"smart\" sagas, just as you can do with react-redux. But I admit that there aren't many cases for deeply nested saga calls compared to react components.\n\nA reducer is not a \"slice of state\" it's just pure code to project an event log into a meaningful state snapshot.\n\nWhat I meant by \"slice\" is the part of state that is computed by given reducer. So if I have settingsReducer that manages state of shape {locale: ..., /* other data */}, and connect it to Saga, then querying state.locale means relying on the shape of that part.\nThis is probably not an issue in this particular case, because locale is computed independently from other settings, so I can introduce localeReducer that only manages locale value.\nAlso I'm starting to think that exposing state shape to Saga is ok in case of local state, because it's already structured for that particular Saga means.\nHere's my current vision on this:\nWe allow to connect Saga to arbitrary reducer. When Saga starts, we start background process that listens to the event log and computes local state. This state may be queried by getState argument, or by some new effect.\nWe can reuse reducers that manage parts of the state that we are interested in and combine them using combineReducers.\njs\n@connectSaga(combineReducers({\n  locale: localeReducer,\n  other: ...\n}))\nfunction* saga() {\n  // ...\n  const {locale, other} = yield getState();\n}\nAlso now I see that we can easily have connected sagas that aren't started on app startup, by supplying their reducers with current state as initial.\n. So here's what I've come up with:\n``` js\nfunction connectReducer(reducer, saga) {\n  const store = createStore(reducer);\nconst storeSaga = function storeSaga() {\n    try {\n      while (true) {\n        const action = yield take('');\n        store.dispatch(action);\n      }\n    } catch (e) {\n      if (e instanceof SagaCancellationException)\n        return;\n  throw e;\n}\n\n};\nconst connectedSaga = function*() {\n    const task = yield fork(storeSaga);\ntry {\n  yield call(saga, store.getState);\n} finally {\n  yield cancel(task);\n}\n\n};\nObject.defineProperty(connectedSaga, 'name', {value: saga.name});\nreturn connectedSaga;\n}\n```\nEach connected saga gets its own store which receives every action dispatched to the main Redux store. That local store state getter is passed to saga as getState argument. Wrapper connectedSaga has no arguments \u2014 it doesn't depend on main Redux state anymore.\nI've split out localeReducer from settingsReducer and reused it for Saga:\njs\nconst fetchEntitiesSaga = connectSaga(localeReducer, \n  function* fetchEntitiesSaga(getState) {\n    // ...\n    const entities = yield call(service);\n    const locale = getState();\n    const parsedEntities = parse(entities, locale);\n    // ...\n  }\n);\n. > What happens if you use connectSaga multiple times last one wins right?\nNo, the first one will already have zero arguments, so connecting second time won't change anything, except for creating another store and starting background saga for it.\nUnfortunately I don't know how to connect sagas that aren't started on app startup. Rebuilding their local state would require having entire event log to the time they start.\n. For now this has been very convenient way to pull a part of Redux state to Saga. It also made me refactor my reducers to split them into smaller ones that manage smallest possible state slice. Which is great even if I didn't use redux-saga, as it makes it much easier to reason about update logic and also to test it. And when some update logic requires data from other parts of the state, I treat it as a side-effect instead of introducing reducer that manages larger slice.\nI'm thinking about publishing this as a separate repo.\nI guess this issue can be closed.\n. @yelouafi Yes, I'm following that discussion. \nStill current approach seems more clean for me, it makes everything decoupled: reducers in the tree are completely independent from each other and from sagas. \nHowever it can be that my app is just not complex enough yet. \nAnyway, it is obvious that this approach won't fit everyone, so it should be kept separate.\n. @slorber My proposed approach aims to decouple every piece of computation and any dependency is resolved by passing computed results via actions. Decoupling reducer means that getting any data that is external to it is a side-effect and thus must be handled by saga. So I'm currently doing all computation that has dependencies inside sagas.\nBut with rereduce we can go in another direction, i.e. do more pure computation in reducers and minimize code in sagas. It would also allow us to keep action payloads to minimum. Actually I think it's better, because amount of code handling side-effects is smaller.\nStill there remain two different possible ways of decoupling saga from state shape: connecting saga to reducer or to selector.\n. @yelouafi \ud83d\udc4d\n. Good work on feature and docs!\n. @aft-luke redux-saga/lib/proc module exports CANCEL symbol. You can use it to add cancellation to any promise:\n``` js\nimport {CANCEL} from 'redux-saga/lib/proc';\npromise[CANCEL] = () => { / cancellation logic / }\n```\n. Great, thanks!\n. It was approved yesterday.\nhttps://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/redux-saga%2Fredux-saga.d.ts\n. Typings are incomplete, I only wrote ones for stuff I'm using in my\nproject. But I plan to fill the missing parts when I have time.\n\u0412\u0442, 9 \u0444\u0435\u0432\u0440. 2016 \u0433. \u0432 16:44, Yassine Elouafi\nnotifications@github.com>:\n\n@aikoven https://github.com/aikoven It seems the apply function is\nmissed\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/84#issuecomment-181810948.\n. Something like\n\njs\nfunction *saga() {\n  while (true) {\n    yield take([action1, action2])  // watch multiple actions\n    // ...\n  }\n}\nOr even\njs\n    yield take(action => /* ... */)\n. @wizardzloy You are right, this would work and IMO it's a valid use case. Still daemon saga is more flexible approach, e.g. you can do things like error handling:\njs\nfunction *errorHandlerSaga() {\n  while (true) {\n    const action = yield take(action => action.error)\n  }\n}\nIf you do this via action creators, you would have to trigger the saga manually from every action creator for error action.\n. I agree that it may be hard to trace when and where an action was dispatched when your app grows. \nStill I prefer to isolate every possible side-effect in Sagas and keep action creators pure.\nTo address this specific issue I'm using following trick:\nI have action creator factory that looks something like this:\njs\nfunction actionCreator(type) {\n  return payload => ({type, payload})\n}\nBecause all my action creators are pure, I'm using this factory for all of them. Now I can use Error to add stack trace to every action:\njs\nfunction actionCreator(type) {\n  return payload => {\n    let stack;\n    try {\n      throw new Error()\n    } catch (e) {\n      stack = e.stack;\n    }\n    return {\n      type, payload,\n      meta: {stack}\n    }\n  }\n}\nWith little help from error-stack-parser I can get the following result:\n\n. I think this is great, the only concern is about how this would be implemented. How does saga runtime skip to finally block in the event of cancellation?\n. I have updated the PR to use 2-arguments version of setTimeout. \nAlso probably there's a better place for delay function than root module, maybe src/utils.js?\n. > OTOH thought this would involve more imports for the user\nYep, that's not very convenient. Besides, src/utils module acts as a facade, only exporting values from other modules.\nLast options I see are to put it in internal/sagaHelpers or to introduce new module.\n. Updated PR.\nNot sure if notifications are sent with new commits.\n. What if you want to put to a channel of type other than Action?\n. You can wrap your code to a function that returns promise, something like\njs\nfunction connect() {\n  return new Promise(resolve => {\n    const database = firebase.database();\n    const connectionRef = database.ref('.info/connected');\n    connectionRef.on('value', resolve);\n  });\n}\nThen use it in saga:\njs\nconst snapshot = yield call(connect);\nif (snapshot.val() === true)\n  yield put(actions.connected());\n. @Andarist You're right, in this case using channels is a way to go.\n. \ud83d\udc4d\n. Can you please post the code fragment where it fails?\n. Seems to be a result of some of yielded value types, although it's not enough to tell where the problem is exactly.\nTypeScript is still not very good at generators, but at least it can check types of values you yield. My current approach is to set return type of every saga to SagaIterator:\n``` ts\nimport {SagaIterator} from \"redux-saga\";\nfunction* someSaga(): SagaIterator {\n  // ...\n}\n```\nThis way you always know that you only yield correct values i. e. effects.\n. Covered by https://github.com/redux-saga/redux-saga/pull/740.. IMO it's still not very convenient. Cancellation is a regular situation, nothing like uncaught exceptions, so I don't think it should be logged. Also you can actually see it in Saga Monitor if you need.\n. It would be nice if this could also be configured per generator. \nAlso, not sure if it was proposed already, it'd be great if we could supply a custom displayName for generators, different from generator.name, to be shown in these log messages as well as saga monitor. Would be useful for higher order generators. Setting Function.name doesn't work on some browsers.. > or is it cancel caused by cancel propagation when something throws\n\nfor this, we could also group these messages to more clearly indicate where the error originated and to which cancellations it lead.\n\n\nWould be also useful for overriding display name for helper effects like takeEvery\n\nActually I have a lot of higher order sagas / custom effects, both could benefit from this. For now I'm using this:\n```js\nfunction setFunctionName(func, name) {\n  try {\n    Object.defineProperty(func, 'name', {\n      value: name,\n      configurable: true,\n    });\n  } catch (e) {\n    // ignore\n  }\nreturn func;\n}\n```\nBut it only works on Chrome AFAIK.. > Is there any particular reason you are using defineProperty here instead of just assigning?\nIf I remember correctly, assignment didn't have any effect at all.\n\nCould you share some of your ideas for higher order sagas / custom effects?\n\nSure! The one higher order saga I use most is bindAsyncAction, where async action is actually a set of three actions: started, done and failed. The returned generator first puts started, then calls the source generator, then done or failed depending on the result. Useful when you want to track the execution of your worker in reducers.\nAnother one, runBetween, runs given generator between two given actions, i.e. starts with the first action and cancels with the second. I use it for processes that should be run only when user is logged in. Of course I could just start these processes from the saga that controls log-in and user session, but there are a lot of them and I wanted to decouple.\nI use custom effect for subscriptions to remote data updates, works like this:\njs\nconst task = yield subscribe(modelName, filters, worker)\nWorker gets updates through a channel that it receives as argument. The task has a special cancellation logic that sends unsubscribe request to the server.\nOne more custom effect / helper is listenState(selector, worker), which invokes worker once selected state slice changes.\nAs we discussed before, I think that custom effects and helpers like takeEvery are basically the same concept. I can't think of anything that couldn't be expressed as a composition of built-in effects. Therefore each of them is just a convenience function returning call, fork or whatever else effect.. > Is listenState implemented using take('*')?\nYep:\n```js\nfunction* listenState(selector, worker) {\n  let prevValue = undefined;\nwhile (true) {\n    yield take('*');\nconst value = yield select(selector);\n\nif (value !== prevValue)\n  yield spawn(worker, value, prevValue);\n\nprevValue = value;\n\n}\n}\n```. What if you had to pass six arguments?\nActually the right way would be to have something like this:\nts\n(fn: CallEffectArg<CallFuncRest>, \n arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, \n ...args: any[]): R;\nThis way the last signature would be selected only for 5+ arguments functions.\n. @tvedtorama Can you please submit a PR? I don't have enough time for it right now. \nThere are tests for TS definitions, you can add this case there. There are also other effect typings that should be fixed as well. \nIf you're not up to contributing, I will fix it once I have time.\n. @Andarist Yes, actually I'm in the middle of reworking the typings to make them more strict, support new APIs and add tests. Will make a PR in a few days.. Covered by https://github.com/redux-saga/redux-saga/pull/740.. Nice observation with sync errors on startup!\nI typically use a higher-order saga, like this:\n``js\nfunction autoRestart(generator) {\n  return function* autoRestarting(...args) {\n    while (true) {\n      try {\n        yield call(generator, ...args);\n      } catch (e) {\n        console.log(Unhandled error in '${generator.name}'`, e);\n      }\n    }\n  }\n}\nconst mySaga = autoRestart(function* mySaga () {\n  // ...\n});\n```\nAnother option is to make a custom effect creator:\n``js\nfunction forkAutoRestarting(fn, ...args) {\n  return fork(function* () {\n    while (true) {\n      try {\n        yield call(fn, ...args);\n      } catch (e) {\n        console.log(Unhandled error in '${generator.name}'`, e);\n      }\n    }\n  });\n} \nfunction* rootSaga() {\n  yield forkAutoRestarting(childSaga);\n}\n```\nHowever, I like the first one more, because it's probably saga's own concern whether it supports restarting, not its parent's.. @Andarist \n\nWould you agree on using your code in the docs or maybe even making one of them a built-in helper?\n\nAbsolutely! @granmoe's sync error detection should be included as well. I think we should fail loudly in that case.\n@granmoe \n\nSorry, the actual difference with @aikoven 's solution is that I take into account synchronous errors and I DO let the saga die in that case.\n\nThe purpose of these snippets was to show generic ways to handle restarts, without needing to keep that logic inside real saga code, by using higher order saga or custom effect creator. Surely they're now incomplete without your sync error handling trick :). Typings enforce you to always yield effects, not regular values or promises or generators. To get the most out of them, annotate return type of every saga with SagaIterator:\n```ts\nimport {SagaIterator} from \"redux-saga\";\nfunction* someSaga(): SagaIterator {\n  // ...\n}\n```\nIn your particular case you should replace this:\nts\n    yield [\n        confirmSaga()\n    ];\nwith this:\nts\n    yield [\n        call(confirmSaga)\n    ];. \ud83d\udc4d. Oh wait, more accurate would be actionDispatched<A extends Action>(action: A). It's good now. Thanks. That's just how it's done in Redux: https://github.com/reactjs/redux/blob/v3.6.0/index.d.ts#L46\nI'm not sure if it adds any strictness right now, but I think that it describes the function contract more precisely. In TypeScript saying that something has interface T doesn't always mean that it has properties from T. Sometimes it means that there are no other properties that aren't in T, e.g.:\n```ts\ninterface T {\n  prop: string;\n}\n// this would fail:\nconst t: T = {prop: 'foo', otherProp: 'bar'};\n``\nHowever, I can't think of any non-exotic case like this forMonitor.actionDispatched`.. > Effect creator is a function returning a description-object, look at this.\n\nAlso the created effects are later interpreted here.\n\nYep, I know, and I agree that it's probably an overkill for this problem, however I still think that custom effects is a feature that should be added one day. It would be useful for many things. Currently you can code it as a composition of built-in effects, e.g.\njs\nfunction safeCall(...args) {\n  return call(function* safeWrapper() {\n    try {\n      return yield call(...args);\n    } catch (e) {\n      return null;\n    }\n  });\n}\nBut it won't look nice in the monitor and there's no way for it to access saga runtime stuff. \n\nIm wondering - isnt just importing an external module containing a reference to your connection viable option?\n\nI'm trying to refactor some code that uses this approach to something that won't involve global variables. These connections are not singletons and are created and destroyed often. \nReact Context allows components to access objects owned by their far ancestor, while avoiding globals and passing objects down the whole hierarchy via props. This makes it possible to attach a Redux store once near the root component and then use it in any other descendant. I think this kind of inversion of control would be really useful in sagas, because they too often form a deep hierarchy.\n\nAlso - the title of the issue implied for me that this could be used.\n\nI want to still be able to put to Redux along with accessing non-redux store. I think it's possible to build some smart dispatch and getState options that would somehow route actions and state to the correct store. Seems fragile though.. > Out of curiosity - what saga runtime stuff you would like to have access to?\nMaybe the options passed to middleware, or arguments of root saga.\n\nBut would abstract your connections and you wouldnt need to care about it in your sagas\n\nI would still need to care about it, by putting some special kind of actions and selecting in some other non-trivial way. Things would get even worse when I have to use several instances of different third-party clients. Overriding dispatch and getState is a hack and doesn't scale.. After some more thinking I agree that custom effects are actually useful only for Monitor. But I guess there are simpler ways of making them look nice, while still having them composed of built-in effects.\nIntroducing context seems like a better option to me. Something like this maybe?\n```js\nfunction* parent() {\n  yield setContext({foo: 'bar'});\nyield fork(child);\n}\nfunction* child() {\n  const foo = yield getContext('foo');  // 'bar'\n}\n``. When parent component is updated, it can return newcontextobject each time. You only specify how context is computed from component'spropsandstate`, not setting it imperatively. \nWe could make it more minimalistic, allowing only getContext effect, and setting context globally:\n```js\nconst sagaMiddleware = sagaMiddlewareFactory({context: {...}});\n// or\nsagaMiddleware.setContext({...});. Closing in favor of https://github.com/redux-saga/redux-saga/pull/735.. \ud83d\udc4d\nCurrent definitions are slightly outdated and contain some mistakes, I'm planning to review and fix them soon.. \ud83d\udc4d. > > For removing context we can make setContext replace all own properties instead of assigning. This way we can keep API surface smaller.\n\nI think that could lead to unexpected bugs and also updating the context would be quite unwieldy\n\nAnother way to avoid unsetContext is to use symbols for context keys on the library user's side.\n\n\nContext property could be anything, not just plain object, so we can't safely copy it.\n\nofc it would be checked beforehand if it is a plain object to see if we should make a shallow copy\n\nIs this really a library responsibility? We don't shallow copy selected state and actions returned from take.. Here's a counterexample:\n```js\nconst obj = {\n  foo: null,\n  setFoo(foo) {this.foo = foo},\n  getFoo() {return this.foo}\n};\nyield setContext({obj});\n// ...\nconst obj1 = yield getContext('obj');\nyield call([obj1, obj1.setFoo], 1);\n// ...\nconst obj2 = yield getContext('obj');\nconst foo = yield call([obj2, obj2.getFoo]);  // null\n``\nHere, the value ofobj.foo` is lost due to shallow copying. In real world, this could happen when you store observable objects in context and later add callbacks to them.. > In general im in favor of immutability and this-less programming\nI absolutely agree with you, but my reasoning is this: for pure things we already have Redux store and actions which we can access in sagas at any level using appropriate effects. We would use Context to access non-pure third-party library objects.\nAnother use case is to share Channels between sagas, however I guess shallow-copying a Channel would be safe.. Resolves https://github.com/redux-saga/redux-saga/issues/608 and https://github.com/redux-saga/redux-saga/issues/619.. Resolves https://github.com/redux-saga/redux-saga/issues/608 and https://github.com/redux-saga/redux-saga/issues/619.. > wont it be limiting? aint possible making those of completely variadic length?\nLatest TS only supports vararg at the end of arguments list, so it's impossible to strongly annotate (...args, action). I think I'll return the ...rest version, but action argument won't be type-checked.. > wont it be limiting? aint possible making those of completely variadic length?\nLatest TS only supports vararg at the end of arguments list, so it's impossible to strongly annotate (...args, action). I think I'll return the ...rest version, but action argument won't be type-checked.. @nbostrom IMO yielding promises is an anti-pattern, since it means you create a side-effect in the generator itself instead of saga runtime. You can use yield call(delay, 50) instead, which is pure.. @nbostrom IMO yielding promises is an anti-pattern, since it means you create a side-effect in the generator itself instead of saga runtime. You can use yield call(delay, 50) instead, which is pure.. @Andarist There are a couple things that should be done:\n- [x] yield cancel(...tasks). I'm confused about whether it is in master already.\n- [x] onError option for runSaga\n- [x] Possibly a solution for https://github.com/redux-saga/redux-saga/pull/770. @Andarist There are a couple things that should be done:\n- [x] yield cancel(...tasks). I'm confused about whether it is in master already.\n- [x] onError option for runSaga\n- [x] Possibly a solution for https://github.com/redux-saga/redux-saga/pull/770. Updated the PR. Added some missing APIs and loosened restriction on generators passed to SagaMiddleware.run as well as iterators passed to runSaga. Strict type-check of yielded values is still possible by annotating return types of generators with SagaIterator.. Updated the PR. Added some missing APIs and loosened restriction on generators passed to SagaMiddleware.run as well as iterators passed to runSaga. Strict type-check of yielded values is still possible by annotating return types of generators with SagaIterator.. Do you expect all of these to be merged for v0.15? Otherwise I could just make another PR.. Do you expect all of these to be merged for v0.15? Otherwise I could just make another PR.. - [x] New runSaga signature\n- [x] Self cancellation via yield cancel()\n- [x] all effect\n- [x] Context feature. - [x] New runSaga signature\n- [x] Self cancellation via yield cancel()\n- [x] all effect\n- [x] Context feature. - [x] Support for passing method names to call etc. https://github.com/redux-saga/redux-saga/pull/826. - [x] Support for passing method names to call etc. https://github.com/redux-saga/redux-saga/pull/826. I think that more generic way is to have the same stuff but for single effect, something like this:\njs\nfunction safeCall(fn, ...args) {\n  return call(function* () {\n    try {\n      return {result: yield call(fn, ...args)};\n    } catch (error) {\n      return {error};\n    }\n  });\n}\nThis way you can wrap any call that could potentially throw, without needing to try/catch. And you can achieve what you want with:\njs\nyield [\n  safeCall(fetchCustomers),\n  safeCall(fetchProducts),\n]. I think that more generic way is to have the same stuff but for single effect, something like this:\njs\nfunction safeCall(fn, ...args) {\n  return call(function* () {\n    try {\n      return {result: yield call(fn, ...args)};\n    } catch (error) {\n      return {error};\n    }\n  });\n}\nThis way you can wrap any call that could potentially throw, without needing to try/catch. And you can achieve what you want with:\njs\nyield [\n  safeCall(fetchCustomers),\n  safeCall(fetchProducts),\n]. I think the reason why you got an error here is because you yielded an iterator instead of effects. To me this sounds like an anti-pattern, just like yielding promises. Typings were designed to enforce you to always yield effects.\nHowever, I may be missing something. cc @Andarist \nAlso, what's the reason for making SagaIterator an interface instead of type alias?. I think the reason why you got an error here is because you yielded an iterator instead of effects. To me this sounds like an anti-pattern, just like yielding promises. Typings were designed to enforce you to always yield effects.\nHowever, I may be missing something. cc @Andarist \nAlso, what's the reason for making SagaIterator an interface instead of type alias?. It is actually possible to yield any value and runtime will work fine, but if we change SagaIterator to be IterableIterator<any>, the typings will become much less strict and TS will miss much more errors.\nI guess we need more opinions here.. It is actually possible to yield any value and runtime will work fine, but if we change SagaIterator to be IterableIterator<any>, the typings will become much less strict and TS will miss much more errors.\nI guess we need more opinions here.. I think we can make a compromise here. Currently SagaIterator type only allows yielding Effects, but the only place where it is checked is SagaMiddleware.run() method. Which means that only root saga is checked, unless you annotate return type of non-root sagas like this:\nts\nfunction* nonRootSaga(): SagaIterator {\n}\nWe could loosen the type SagaIterator to IterableIterator<any>, but introduce another type EffectIterator = IterableIterator<Effect>, so that anyone who wants more strict checks could use it instead of SagaIterator to annotate their sagas.. I think we can make a compromise here. Currently SagaIterator type only allows yielding Effects, but the only place where it is checked is SagaMiddleware.run() method. Which means that only root saga is checked, unless you annotate return type of non-root sagas like this:\nts\nfunction* nonRootSaga(): SagaIterator {\n}\nWe could loosen the type SagaIterator to IterableIterator<any>, but introduce another type EffectIterator = IterableIterator<Effect>, so that anyone who wants more strict checks could use it instead of SagaIterator to annotate their sagas.. Fixed in https://github.com/redux-saga/redux-saga/pull/740. Fixed in https://github.com/redux-saga/redux-saga/pull/740. Isn't it easier to just return?. Isn't it easier to just return?. I see. So, if I understand correctly, there are three ways to end up in finally block: return, cancellation and exception. If so, wouldn't it be more generic to be able to distinguish between return and exception somehow?. I see. So, if I understand correctly, there are three ways to end up in finally block: return, cancellation and exception. If so, wouldn't it be more generic to be able to distinguish between return and exception somehow?. This will be covered by https://github.com/redux-saga/redux-saga/pull/740.\nFor now, if you're not using strictNullChecks, you can set emitter: null. Otherwise, you can try this:\nts\nconst sagaMiddleware = sagaMiddlewareFactory({...options} as any). This will be covered by https://github.com/redux-saga/redux-saga/pull/740.\nFor now, if you're not using strictNullChecks, you can set emitter: null. Otherwise, you can try this:\nts\nconst sagaMiddleware = sagaMiddlewareFactory({...options} as any). @Andarist Unfortunately I'm not aware of the most robust way of doing this.\nCurrent Redux approach is just evaluating process.env.NODE_ENV without any checks: https://github.com/reactjs/redux/blob/v3.6.0/src/index.js\nHowever, in the next branch they still do the check for process: https://github.com/reactjs/redux/blob/next/src/index.js. @Andarist Unfortunately I'm not aware of the most robust way of doing this.\nCurrent Redux approach is just evaluating process.env.NODE_ENV without any checks: https://github.com/reactjs/redux/blob/v3.6.0/src/index.js\nHowever, in the next branch they still do the check for process: https://github.com/reactjs/redux/blob/next/src/index.js. Isn't it the same as trying to solve the Halting problem?. I think it's enough to test all the states where the process can possibly be, and that it then comes back to the first state.. This is a really cool trick, thanks for sharing it, @Ephys!. This is a really cool trick, thanks for sharing it, @Ephys!. Please have a look at https://github.com/redux-saga/redux-saga/pull/740. Please have a look at https://github.com/redux-saga/redux-saga/pull/740. The Context feature is what you're looking for, see https://github.com/redux-saga/redux-saga/pull/735. The Context feature is what you're looking for, see https://github.com/redux-saga/redux-saga/pull/735. The Context feature might solve your problem, see https://github.com/redux-saga/redux-saga/pull/735. The Context feature might solve your problem, see https://github.com/redux-saga/redux-saga/pull/735. I think it can be closed now because typings work fine with default TS config. We could consider adding docs if there's a demand. . I think it can be closed now because typings work fine with default TS config. We could consider adding docs if there's a demand. . We should add a test for this.\nAlso, how about this:\nts\ntype CpsCallback = {\n  (error: any, result: any): void;\n  cancel?(): void;\n};. We should add a test for this.\nAlso, how about this:\nts\ntype CpsCallback = {\n  (error: any, result: any): void;\n  cancel?(): void;\n};. Current typings were designed to protect users from yielding function calls directly, but use effects instead. This way we catch situations where you unintentionally introduce side-effect in your saga forgetting to wrap function call with effect.\nIMO the example should be updated to use more idiomatic way:\njs\n// single entry point to start all Sagas at once\nexport default function* rootSaga() {\n  yield all([\n    call(helloSaga),\n    call(watchIncrementAsync)\n  ])\n}\nOtherwise, we could try to solve it like in https://github.com/redux-saga/redux-saga/pull/770, i. e. to make the strictness opt-in by declaring the return type of generator to be SagaIterator.. Current typings were designed to protect users from yielding function calls directly, but use effects instead. This way we catch situations where you unintentionally introduce side-effect in your saga forgetting to wrap function call with effect.\nIMO the example should be updated to use more idiomatic way:\njs\n// single entry point to start all Sagas at once\nexport default function* rootSaga() {\n  yield all([\n    call(helloSaga),\n    call(watchIncrementAsync)\n  ])\n}\nOtherwise, we could try to solve it like in https://github.com/redux-saga/redux-saga/pull/770, i. e. to make the strictness opt-in by declaring the return type of generator to be SagaIterator.. Fixed in https://github.com/redux-saga/redux-saga/pull/1047. Fixed in https://github.com/redux-saga/redux-saga/pull/1047. \ud83d\udc4d. \ud83d\udc4d. I guess this had been solved already, please ping me once more if not.. I guess this had been solved already, please ping me once more if not.. Why doesn't Repository.add() declare a correct return type in the first place?\nAlso, what's the benefit from this type casting? The types are lost anyway after the yield.. Why doesn't Repository.add() declare a correct return type in the first place?\nAlso, what's the benefit from this type casting? The types are lost anyway after the yield.. I see, and this makes sense. But you would also have to declare types for all of the arguments. And yes, this is a breaking change. We could check back on this before v1.0. Fixed in https://github.com/redux-saga/redux-saga/pull/1255. This error message has nothing to do with the exact error in the code. Unfortunately, when failing to match with multiple signatures, TypeScript shows an error with the last signature only.\nTo get the right error message, you may comment out all call signatures in typings file except for the one you're using.. Yeah, that makes a lot of sense. \ud83d\udc4d. Aside from the minor comment, \ud83d\udc4d. That's because anotherSaga has type () => SagaIterator, not just SagaIterator.\nUnfortunately, these error messages are quite misleading, they are shown because the signature of call with context is the last one TS tries to match. If you manually comment out these signatures in the typings file, you'll get the correct error message.. The following works on my side:\n```ts\nimport {SagaIterator} from 'redux-saga';\nimport {all, call} from 'redux-saga/effects';\nfunction* anotherSaga(): SagaIterator {\n  yield all([]);\n}\n// changed type of saga from SagaIterator to () => SagaIterator\nfunction* someSaga(saga: () => SagaIterator) {\n  yield call(saga);\n}\nexport default function* rootSaga() {\n  yield call(someSaga, anotherSaga);\n}\n``. Could you please post a bit more code? What's the type ofsomeSaga? Do you importtakeEveryfromredux-sagaorredux-saga/effects?. Type definition fortakeEvery` has two groups of overloaded signatures: one for taking actions by pattern and another for taking from channels. When TypeScript is unable to match any of these signatures, it shows error regarding the last one it tried.\nI'm certain that you have some type error that prevents TS from matching the first group.\nYou may try this: open node_modules/redux-saga/effects.d.ts, find takeEvery definition, and comment out all the signatures with Channel. You'll get the correct TS error after that.. > The thing is, I just changed this file's extension from .js to .ts.\nHopefully, someday it would be as easy as this.\n\nAny compiler settings I should look in to?\n\nIf you're migrating an existing project, I suggest using defaults. Once you get more confident with TS, use --strict option.\n\nAlso, I've noticed that if instead of using object destructuring syntax I simply use fetchExampleSaga(action) the error goes away. Suggestions?\n\nI suggest to always declare the types for arguments of standalone functions (that is, functions that are not inlined callbacks). This way you give TS a starting point for type inference. The return type is almost always optional because it can be inferred from your function returns.. SagaIterator is meant to be used for strict type checks where you only yield effects. It is completely opt-in, if you don't need such strictness, you may just remove SagaIterator annotation.. It indeed is a built-in type, but it's not included in every library TypeScript provides.\nSee \"lib\" option in tsconfig.json: https://www.typescriptlang.org/docs/handbook/compiler-options.html. Current typings have two signatures:\nts\njoin(task: Task): JoinEffect;\njoin(task1: Task, task2: Task, ...tasks: Task[]): JoinEffect[];\nThe problem with the fully variadic signature is that there's an ambiguity when we write\nts\njoin(...tasks)\nWhen tasks has length 1, we should return JoinEffect, and if it's >= 2, it should return JoinEffect[]. There's currently no way to express array length on the type level. That's why TS doesn't match join(...tasks) with the second signature; it would only work if you pass tasks one by one: join(task1, task2, task3).\nI think the most strict version of the fully variadic signature is this:\nts\njoin(...tasks: Task[]): JoinEffect | JoinEffect[];\n@Andarist Actually there's not much difference for TS between variadic and an array.. > Also when using join(...tasks) there is a little bit of disconnect between what you pass in and what you get in return: const results = join(...tasks) where results is an array ofc.\nI'd prefer to use variadic variant because it's consistent with joining with a single task. But I'd also expect to always get a result of the same shape, i.e. an Effect descriptor object that may contain one or more tasks to cancel. I rarely look into the result of effect creator, though there might be more cases for this since Effect Middleware landed.\nThat said, I see nothing wrong in supporting both variants since both can be handy.. > should we maybe just move delay into redux-saga/effects\n\ud83d\udc4d for me, in our projects, we only use delay inside call.. Updated typings.. @huntwj The error you see is a result of TypeScript's way of resolving overloaded signatures. takeLatest has two kinds of signatures: one for taking actions and another for taking from channels (see effects.d.ts). For some reason TS failed to match your arguments with the first kind. Then it tried to match with the second kind, and of course it failed too, and returned an error for the last signature it tried.\nUnfortunately, I don't know of a way to get the correct error message here, except for commenting out all the signatures of takeLatest with channels in node_modules/redux-saga/effects.d.ts.\nYou may also try the new typings for the 1.0 (https://github.com/redux-saga/redux-saga/pull/1255), where these two groups of signatures are swapped, so that users are more likely to get the correct error message, since takeLatest is more often used with actions than channels.. Actually, there are breaking changes \u2014 in TypeScript typings. Although it should still be compatible with the current redux-saga typings.\nAlso, I wouldn't include 4.0.0 in the range, since it doesn't yet exist and stuff may change. Maybe there's a way to only include beta versions? Something like >=0.10 <=4.0.0-beta.1.. What you have encountered is a weak point of TS compiler error reporting. In a case when TS fails to match against a union of types, it shows an error regarding the last type of the union. The same goes with overloaded signatures.\nIn your particular case the problem type is this:\nts\n// redux-saga/effects.d.ts#152\nexport type CallEffectFn<F extends Function> =\n  F | [any, F] | {context: any, fn: F};\nTry to comment out all union members except for F and see what error you get.. @dyesseyumba Ok, so now it resolves to a wrong signature. Please find interface CallEffectFactory (line 160), and comment out all signatures that mention CallEffectNamedFn. These are the ones that handle this form:\nts\nyield fork([obj, 'method'], ...args);\nThen try to compile once again.\nI'm sorry about this being so frustrating. Hopefully, it will get at least a little better with the new typings for redux-saga 1.0.. Ah, sorry, I can see that you've already tried that.\nBy the way, why do you need to fork takeLatest? It's already non-blocking, see https://github.com/redux-saga/redux-saga/blob/v0.16.0/src/internal/io.js#L188. @cwmacdon Unfortunately, for now, there's no way to handle this in a type-safe manner. We could add a variadic signature for call, something like:\nts\nfunction call<T>(fn: (...args: T[]) => any, ...args: T[]): CallEffect;\nBut if we did, then this code would compile without errors:\n```ts\nfunction someFunc(foo: string) {...}\nyield call(someFunc);  // foo argument is missing\n```\nbecause TypeScript doesn't allow to control the number of arguments in a variadic function.\nThat's why current typings don't include fully variadic versions for effects like call, fork etc. That's a tradeoff to provide type safety for the most common usage, where arguments are static.\nFor the dynamic case, like yours, I'd go with:\nts\n(call as any)(fn, ...args),\n@Andarist Don't apologize, I wouldn't expect you to take the burden of maintaining typings that you don't even use \ud83d\ude00. Please feel free to ping me anytime.. Looks like a conflict with some other type definition. Could you try to open effects.d.ts and navigate to the declaration of Action from your editor? Where does it lead to?. Note that the type of value returned from yield depends on the runtime that runs the generator. So there's no way for a compiler to infer it without a hint.\nThat hint could be a function on types, that tells you the type of the result you get back if you yield value of given type (the type of the effect in our case). \nThe interesting thing is that TypeScript already has the way to express this kind of function, called Conditional Types. With it we can turn effect type to the result type, something like:\nts\ntype EffectResult<T extends Effect> = \n  T extends CallEffect<infer R> ? R :\n  T extends ForkEffect<infer R> ? Task<R> :\n  ...\nAlas, there's no way currently to attach this to a generator. And I don't think that there'll be one soon, since the use of generators is still niche.\nWe could do it manually, like this:\nts\nconst effect = call(...);\nconst result: EffectResult<typeof effect> = yield effect;\nThough it looks really ugly.\nMaybe we could make a TSLint plugin that could insert that code automatically to get type checking.. This indeed looks pretty complicated, since you can use many different things as pattern: predicates, action creators, action types and arrays of those.\nThis is how ActionPattern type is defined:\n```ts\nexport type ActionType = string | number | symbol;\nexport type StringableActionCreator = {\n  (...args: any[]): A;\n  toString(): string;\n};\nexport type ActionSubPattern =\n  | GuardPredicate\n  | StringableActionCreator\n  | Predicate\n  | ActionType\nexport type ActionPattern =\n  | ActionSubPattern\n  | ActionSubPattern[];\n``\nThe path we're interested in isActionPattern -> ActionSubPattern -> ActionType, andActionType` is not parametric.\nWe could parametrize it like this:\nts\ntype ActionType<A extends Action = Action> = A['type'];\nBut unfortunately in Redux typings the type of Action.type is any, so this would effectively cast ActionPattern to any when used without a type parameter.. > Unfortunately for some reason it broke all & race tests \nHere's why: the SagaIterator type is meant for strict type checking of yielded stuff \u2014 i.e. it checks that you only yield effects. The GenericAllEffect is a non-strict version of AllEffect; it was introduced to allow you to use non-effects inside all, but distinguish that use from the strict one. That's why GenericAllEffect is not part of SagaEffect union. Same goes for race.\nSo to fix this, you should change SagaIterator from IterableIterator<AnyEffect> to IterableIterator<SagaEffect>.\n\nI'm also having a small problem with END\n\nYou can re-export the END type in core/index.d.ts:\nts\nexport const END: END;\nexport type END = END;. This might be possible.\nI can see only two possibilities: define a union of all accepted types, or handle particular cases of all and race in a special way (via conditional types).\nOtherwise, there's no way for TS to know that e.g. yielding a promise inside all should fail with strict typings: it will only affect the type of Effect.payload and the resulting payload type might be perfectly valid for another effect.\nTo make it work, we could make a condition on the T of Effect<T, P>, and if T extends 'ALL' | 'RACE', set a more narrow type for payload. Or, if you're ok with changing runtime stuff for the sake of typings, add another field to distinguish combinator from a regular effect. . Uh, I'm sorry, I accidentally pushed to this repo, not my fork. I'll explain the fix in the next comment.. So we're trying to distinguish between a valid and invalid effect in types. We've already split Effect and CombinatorEffect:\n```ts\ninterface Effect {\n  '@@redux-saga/IO': true;\n  combinator: false;\n  type: T;\n  payload: P;\n}\nexport interface CombinatorEffect {\n  '@@redux-saga/IO': true;\n  combinator: true;\n  type: T;\n  payload: CombinedEffects;\n}\n```\nAnd we assume that everything that's assignable to Effect is a valid effect (because we don't want to have a union of all known effects anymore). \nNow CombinatorEffect is valid if it combines valid effects. To type check what's inside combinator effect, I've added a type parameter to CombinedEffects:\nts\ntype CombinedEffects<E> = {[key: string]: E} | E[]\nNote that this doesn't mean that all combined effects would be of the same type. E.g.:\nts\nconst effect = all([call(...), fork(...)]);\n// effect.payload would have type:\ntype P = CombinedEffects<CallEffect | ForkEffect>;\nSo a combinator effect is valid if its payload is assignable to CombinedEffects<ValidEffect>, which gives us the type:\nts\ninterface AnyCombinatorEffect extends CombinatorEffect<any, ValidEffect> {}\nThe interface is needed to allow type recursion, which is impossible with type declarations (TS limitation).. I have concerns about the naming: the presence of Effect, AnyEffect and ValidEffect might be confusing. As a user I would expect a type named Effect to reflect everything that redux-saga considers an effect, not just \"simple\" effects (non-combinators). How about this:\n```ts\ninterface SimpleEffect {\n  '@@redux-saga/IO': true;\n  combinator: false;\n  type: T;\n  payload: P;\n}\ninterface CombinatorEffect {\n  '@@redux-saga/IO': true;\n  combinator: true;\n  type: T;\n  payload: CombinedEffects;\n}\n// default type parameter lets us avoid extra AnyEffect type\ntype Effect = SimpleEffect | CombinatorEffect;\n```\nFor strict checks we could go with:\n```ts\ninterface StrictCombinatorEffect extends CombinatorEffect> {}\ntype StrictEffect = Effect | StrictCombinatorEffect;\n```\nAlso, CombinedEffects could be renamed to CombinatorEffectDescriptor to be consistent with other effects.\n. > Does those changes make sense to you?\nEverything else looks good to me.\nOff-topic: I would like to refactor the typings a bit before major release, but I've been too busy lately. Could you please ping me before it's final? \nParticularly I wanted to copy documentation to the typings, as we did for redux, so it's visible in IDE quick help popups. For VS Code users this would even work with non-TS code! \nI also wanted to use generic rest parameters (TS 3.0 feature) for stuff like call effects, where we now have multiple overloaded signatures. . I\u2019m planning to do this within the next two weeks. Is that ok?. Try to specify the type parameter:\nts\ntakeLatest<Action1 | Action2>([...], ...)\nDon't know yet how we could make it inferred. We need to have\nts\n[StringableActionCreator<Action1>, StringableActionCreator<Action2>] \ninferred to \nts\nActionPattern<Action1 | Action2>. Pretty busy right now, but this issue is on my list. . @slorber Could you please check if https://github.com/redux-saga/redux-saga/pull/1769 fixes your case?. @mattvperry You're right. Here's the fix: https://github.com/redux-saga/redux-saga/pull/1795. That's correct. Although I'm not sure about current browser compatibility requirements for redux-saga, so maybe I should revert it.\n. That's not what I meant. With this version you can do this:\nts\nthrottle(100, 'some_type',  (arg: number) => {}, 'not-a-number')\nSo even if there are less than four arguments, it still won't type-check correctly because it matches the last overload.\nThe correct way would be to add ...rest overload with four five parameters:\nts\n  <A, T1, T2, T3, T4, T5>(ms: number,\n                   pattern: Pattern<A>,\n                   worker: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, ..rest: any[]) => any,\n                   arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, ...rest: any[]): SagaIterator;\n. Context property could be anything, not just plain object, so we can't safely copy it.. Also, I think we should throw if property doesn't exist in context to distinguish between the case where context doesn't have a property and the case where context has property with value undefined.. Yep, I think we should restrict props to be a plain object.. What's the purpose of this API? I can see cases where you need to change the root context as a result of some event, but I think it's more convenient to do this in the root saga.. IMO the context of a task should be a private thing, just like state in React components. The component itself is an owner of its state and it shouldn't be accessible from its parent. . Agree with @yelouafi, if we disable propagating context on spawn, it would make context a much less convenient mechanism for dependency injection.\nThat said, I think that runSaga should behave just like you said \u2014 starting with an empty context by default. Another reason is that otherwise we'd have to somehow link runSaga with sagaMiddleware instance.. Ok, I tend to agree with you that throwing is not really necessary here as any relevant checks could be easily performed on the user side.. A check for props being a plain object should be added here as well.. Just found out this was proposed by myself: https://github.com/redux-saga/redux-saga/issues/713#issuecomment-268750352\nAlthough I think only one of options.context or sagaMiddleware.setContext() is enough.. Good point. \ud83d\udc4d. Since we do Object.assign and not deep merge, I'd view context as a flat object. Thus not sure if complex accessors are needed. Maybe I'm missing some use cases, but I'd rather add such features on demand.. Yep, also I can see some parallel with sagaMiddleware.setContext. Maybe then we just leave task.setContext and remove sagaMiddleware.setContext, as the latter can be done with sagaMiddleware.run(...).setContext?. You're right, I've overlooked the case when sagaMiddleware.run is called multiple times.. There's a chance that this won't work with this Webpack configuration:\njs\nnew DefinePlugin({\n  'process.env': JSON.stringify({NODE_ENV: 'development'}),\n})\nBecause Webpack only replaces process.env and not process. This is how it's done in e.g. create-react-app: https://github.com/facebookincubator/create-react-app/blob/v0.9.0/packages/react-scripts/config/env.js\nI may be mistaken, but I remember I've ran into such issue before.. Won't this break if we call factory without arguments?. I think this can be simplified to:\nts\nfunction cloneableGenerator<S extends (...args: any[]) => SagaIterator>(\n  generator: S,\n): S & {clone(): ...}. Oh, sorry, disregard that. Let's mark second sync signature as deprecated as well. We can use MulticastChannel type here, though that wouldn't enforce exactly stdChannel.. Totally fine, circular imports of types are not a problem.\nIt's also ok to just copy them. Not sure actually. Probably optional, since this package can be used without TS. If you're ok with adding a dependency, there's a package that has similar helpers: https://github.com/ksxnodemodules/typescript-tuple. Done!. If it was, TypeScript users would have to install it manually along with redux-saga. . Yeah, I think that we now require TS >= 3.1. We could make it 3.0 by copying Parameters if that makes enough sense for someone.. I think we can just use Effect here, without adding new types.. ",
    "johnsoftek": "There may be cases where cancellation would be useful, but I don't think it is needed here. Sign-in and sign-out are triggered by real world events.\nConsider a UI containing Sign In and Sign Out buttons. Only one of these buttons would be enabled at any time. Sure, refresh could be in progress when sign_out occurs, but each refresh attempt could be time limited, so the delay to sign out would be un-noticeable.\nAs @yelouafi said, \"progressively introduce more requirements\". I think this is a step too far.\n. AS James D. Cook says: \"You can\u2019t avoid state, but you can partition the stateful and stateless parts of your code. 100% functional purity is impossible, but 85% functional purity may be very productive.\"\nWe eliminate \"side effects\" when coding pure functions so our code is easier to understand and test. Where our functions meet the real world, we are dealing with \"effects\", not \"side effects\".\nBut \"effects\" seems such a weak term to describe the interface to the environment in which an application runs. A saga is a story, so maybe \"effects\" are \"story lines\" or sub-plots, definitely not \"side effects\".\n. ",
    "Marinolinderhof": "@aikoven nice! i do have a follow up question. \nAbout this line const token = yield call(auth.authorize, refresh); \nCould you elaborate how this function works? \ncause in my flow it's just a service which uses fetch and returns the token. But my problem is that i need the token something like: token: {id: '1', token:'1234-abcd-1234-abcd', expires: 6000} or the credentials, username and password, if refresh is false.\nbut then i need access to my store and because auth.authorize is just some dumb javascript service it hasn't access to the store. I could pass in the credentials or the 'old' token but then i think i break the and i quote \"So I'll first refactor localStorage calls into some isolated service\" rule.\nSo if you could elaborate how that part works i would be grateful, sorry for the beginners question.\n. @aikoven nice! i do have a follow up question. \nAbout this line const token = yield call(auth.authorize, refresh); \nCould you elaborate how this function works? \ncause in my flow it's just a service which uses fetch and returns the token. But my problem is that i need the token something like: token: {id: '1', token:'1234-abcd-1234-abcd', expires: 6000} or the credentials, username and password, if refresh is false.\nbut then i need access to my store and because auth.authorize is just some dumb javascript service it hasn't access to the store. I could pass in the credentials or the 'old' token but then i think i break the and i quote \"So I'll first refactor localStorage calls into some isolated service\" rule.\nSo if you could elaborate how that part works i would be grateful, sorry for the beginners question.\n. ",
    "tobyl": "@yelouafi this was amazing, it really helped me understand how saga might be used for async login requests. One question though - I'm a little confused about some of the put commands.\nif(response && response.token) {\n    yield call(setAuthToken, response.token) // save to local storage\n    yield put(authSuccess, response.token)\n    return response.token\n  }\nIn this block, it makes sense that a function is called to save the token in localStorage, but what is the put doing? Is this the reverse of take(ACTION_NAME) and calling a function from the actions file? The saga below seems to be doing a similar thing, except called in a different way - is there a reason for this?\nfunction* signout(error) {\n  yield call(removeAuthToken) // remove the token from localStorage\n  yield put( actions.signout(error)  ) // notify th store\n}\nThank you in advance!\n. thanks for the response - I actually meant these two specific references:\nyield put(authSuccess, response.token)\nyield put( actions.signout(error)  )\nThe format of the rest of the code suggests that authSuccess is a helper function like setAuthToken, but if it's an action, what is the reason for storing the token in state?\nThanks.\n. My form values come from redux-form (v6.0.0-rc.5 with immutable support) and my submit function is:\nshowResults(values) {\n    this.props.loginRequest(values);\n  }\nThis is referenced is mapDispatchToProps like so:\nfunction mapDispatchToProps(dispatch) {\n  return {\n    loginRequest: (values) => dispatch(loginRequest(values)),\n    logoutUser: () => dispatch(logout()),\n    dispatch,\n  };\n}\nThe action this is passed to is:\nexport function loginRequest(data) {\n  return {\n    type: LOGIN_REQUEST,\n    payload: data,\n  };\n}\nAnd finally, authorize is the saga that communicates with auth function:\n```\nexport function* authorize({ data, isRegistering }) {\nyield put({ type: SENDING_REQUEST, sending: true });\ntry {\nlet response;\n\nif (isRegistering) {\n  response = yield call(auth.register);\n} else {\n  response = yield call(auth.login, data);\n}\n\nreturn response;\n\n} catch (error) {\nyield put({ type: REQUEST_ERROR, error: error.message });\nreturn false;\n\n} finally {\n    yield put({ type: SENDING_REQUEST, sending: false });\n  }\n} \n```\nBasically, I'm following saga-login-flow, except in their example they are simply passing the plain strings, whereas I'm trying to work with an immutable object.\nMany thanks for the response.\n. Sorry - just saw your example, trying that now - thanks again!\n. Your example totally makes sense - but the console log in authorize now shows undefined.\nTo clarify, my action is:\nexport function loginRequest(data) {\n  console.log(data);\n  return {\n    type: LOGIN_REQUEST,\n    payload: data,\n  };\n}\nand that console log DOES show the immutable map as expected. Could it because I'm using yield race ?\n```\nwhile (true) {\n    const { data } = yield take(LOGIN_REQUEST);\nconst winner = yield race({\n  // auth: call(authorize, {data, isRegistering: false}),\n  auth: call(authorize, { payload: data, isRegistering: false }),\n  logout: take(LOGOUT),\n});\n\nif (winner.auth) {\n  yield put({ type: SET_AUTH, newAuthState: true });\n  forwardTo('/account');\n} else if (winner.logout) {\n  yield put({ type: SET_AUTH, newAuthState: false });\n  yield call(logout);\n  forwardTo('/');\n}\n\n}\n```\nAnd:\n```\nexport function* authorize({ payload, isRegistering }) {\nconsole.log('payload: ', payload);\n  ...\n```\n. Well, I'm not sure why - but for some reason, using the es6 practice of switching:\npayload: data,\nto:\ndata,\nIn my action just completely fixed this. I might have been referencing something wrong, or the simplicification might have solved another problem I wasn't aware of - either way, this works.\nThank you so much for your help @Andarist !\n. Found a solution - by changing the structure and switching to a map, the yields seem to work perfectly:\nconst newArray = yield array.content.map((item) => call(auth.get, item.url, token));\nHope this helps someone else.\n. Thanks @slorber - that actually works well for me, since I can do response/error as though it were one call rather than having to handle each and then partially handle data.\nThanks!\n. When your data is fetched, you can pass it to a container/component as props:\nif (!this.props.data) {\n    return <LoadingSpinner />;\n} else {\n    return <Component />;\n}\nNot really a redux-saga thing, more of a component thing.. ",
    "jamesblight": "put dispatches an action to the redux store. It's the same as store.dispatch(action.signout(error))\n. ",
    "thangchung": "@yelouafi @aikoven It is really saving my time a lot. Love your works \ud83d\udc4d . ",
    "benjaminreid": "@aikoven This is a really nice example. I'm struggling to see how you combine other API requests with this though.\nFor example, refresh token has expired, a request to an authorized resource is about to be made. How would you delay that request until the refresh token is done in here? \nUnless every other saga that hits the api has to check the expiry of the auth token? \n\ud83e\udd14 . @aikoven That makes sense, keep an eye on your expiry time then trigger a refresh 5 minutes before or something.\nI suppose the only edge case to that may be the app goes into the background, token expires, app goes into the foreground and then you've got to do a refresh before any other api call.\nWhen I was using redux-thunk for this, all the api calls were going through one piece of middleware, which was queueing up requests that were attempting to be called while the refresh token had expired/was refreshing. I'd then run through the queue of requests after the refresh had been completed. It was fairly solid but confusing to read and not very portable.\nUnless there's an obvious solution to the edge case I mentioned above, maybe there's a nice way to wrap each saga so that it can wait until the expiry of the token is far enough in the future it won't interrupt a refresh.\nThanks for your thoughts though either way.. @aikoven Sounds perfect, thanks for your input \ud83d\udc4d . I think the loop is still valid, I have mine so that it checks every few\nseconds if the token has expires and then refreshes it. I've not seen any\nperformance problems because of it, so far.\nI've yet to implement the other requests however. But having a single saga\nto handle other requests as suggested maybe the way to go. As it will need\nto check the expiry, and then wait for the refresh before continuing. It\nalso need to set the new auth token into the request too.\nThe downside here is you loose the nice single sagas per request. Though\nyou could have a \"helper\" saga that was run before each request to check\nthe expiry.\nOn Sat, 25 Feb 2017 at 06:35, Chappo notifications@github.com wrote:\n\n@nouveller https://github.com/nouveller that's what I'm worried about\ntoo. Having a delay on token.expires_in then the thread goes to sleep as\nthe app is not focused, when you re-open it the delay is still running but\nis going to fire late. I haven't ran tests to see if this is the case yet.\n@aikoven https://github.com/aikoven is on the money with having the\ngeneric data saga and having it check the token expiry each time, I might\nneed to abandon the authorizeLoop for this approach.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/14#issuecomment-282464687,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AArhqNZIsGRbGfQOVWe0N7X7xEhY9wNbks5rf8upgaJpZM4G6rUL\n.\n. \n",
    "lukeggchapman": "@nouveller that's what I'm worried about too. Having a delay on token.expires_in then the thread goes to sleep as the app is not focused, when you re-open it the delay is still running but is going to fire late. I haven't ran tests to see if this is the case yet. @aikoven is on the money with having the generic data saga and having it check the token expiry each time, I might need to abandon the authorizeLoop for this approach.. ",
    "shengnian": "that's nice, i do have a follow up question, see the below code:\n```\nfunction* authentication() {\n  const storedToken = yield call(auth.getStoredToken);\nwhile (true) {\n    if (!storedToken)\n      yield take(SIGN_IN);\nconst {signOutAction} = yield race({\n  signOutAction: take(SIGN_OUT),\n  authLoop: call(authorizeLoop, storedToken)\n});\n\nif (signOutAction) {\n  storedToken = null;  <-  Is it necessary to set it null now?\n  yield call(auth.storeToken, null);\n}\n\n}\n}\n```. thanks, if not set the null, the sign out action will be failure, refresh token is still valid.. ",
    "msageryd": "I throttle most of my api calls and put them through a specialized throttle function. I'm not queuing the calls (other than throttle-wise), because I don't care if I miss a call due to Internet outage or invalid token. These \"missed\" calls will be handled by another saga upon \"INTERNET_ON\" or \"RECEIVED_TOKEN\".\nI hope it helps someone. Please chime in if you think there is some wrong thinking in this.\n//A special saga helper that acts exactly like effects.throttle, but only\n//calls the throttled function if there is an Internet connection and access token is valid\nexport function* throttleIfOnlineAndTokenIsValid(ms, pattern, task, ...args) {\n  const throttleChannel = yield actionChannel(pattern, buffers.sliding(1));\n\n  while (true) {\n    const action = yield take(throttleChannel);\n    const isOnline = yield call(NetInfo.isConnected.fetch);\n    const isAccessTokenValid = yield select(selectCheckAccessToken);\n    if (isOnline && isAccessTokenValid) yield fork(task, ...args, action);\n    yield call(delay, ms);\n  }\n}\n\nexport function* throttleIfOnline(ms, pattern, task, ...args) {\n  const throttleChannel = yield actionChannel(pattern, buffers.sliding(1));\n\n  while (true) {\n    const action = yield take(throttleChannel);\n    const isOnline = yield call(NetInfo.isConnected.fetch);\n    if (isOnline) yield fork(task, ...args, action);\n    yield call(delay, ms);\n  }\n}. * **Edit:** I see now that you want to implement \"request new token\" into this. You could do this in my function by dispatching a token-request action when token is missing. I handle token refreshing in a separate saga, so I don't need to handle this in the functions below.\n\nSorry, I don't have time to dive into your code. Instead I'll post my take on this. The below code serves me well in my app.\nThe function takeEveryIfOnlineAndTokenIsValidis almost the same as the takeEvery function in redux-saga. My version only starts the task (via fork) if I have an Internet connection and a valid token. \nIf a task won't be forked due to no network or no token, this task will be retried automatically due to the extended pattern.\nI had problem with NetInfo.isConnected.fetch (remarked), so I implemented a network listener which dispatches actions when Internet comes and goes. This way I can select network status from my store instead of relying on the shaky isConnected.fetch function.\n```js\nfunction extendPattern(pattern, actions) {\n  if (!Array.isArray(pattern)) pattern = [pattern];\n  if (!Array.isArray(actions)) actions = [actions];\nactions.forEach((action) => {\n    if (!pattern.includes(action)) pattern.push(action);\n  });\n  return pattern;\n}\nexport function* takeEveryIfOnlineAndTokenIsValid(pattern, task, ...args) {\n  //Add two triggers to the pattern in order to auto-resume if the action gets discarded due to network or token problems\n  pattern = extendPattern(pattern, [AUTH_GET_USER_TOKEN_SUCCESS, NETWORK_INTERNET_ON]);\nwhile (true) {\n    const action = yield take(pattern);\n    const isOnline = yield select(selectNetworkStatus);\n    //    const isOnline = yield call(NetInfo.isConnected.fetch);\n    const isAccessTokenValid = yield select(selectCheckAccessToken);\nif (isOnline && isAccessTokenValid) {\n  yield fork(task, ...args, action);\n} else {\n  console.log(\n    `Action ${action.type} discarded due to no network or invalid token (isOnline: ${isOnline}, isAccessTokenValid: ${isAccessTokenValid})`\n  );\n\n  if (DeviceInfo.isEmulator()) {\n    //The iOS simulator does not cope well with irregular Internet connections.\n    //We need to manually probe for internet if the simulator thinks that we are offline\n    if (!isOnline) yield put(networkSimulatorProbeAction());\n  }\n}\n\n}\n}\n. Here is athrottle```-like version of the above\n```js\nexport function* throttleIfOnlineAndTokenIsValid(ms, pattern, task, ...args) {\n  pattern = extendPattern(pattern, [AUTH_GET_USER_TOKEN_SUCCESS, NETWORK_INTERNET_ON]);\n  const throttleChannel = yield actionChannel(pattern, buffers.sliding(1));\nwhile (true) {\n    const action = yield take(throttleChannel);\n    const isOnline = yield select(selectNetworkStatus);\n    const isAccessTokenValid = yield select(selectCheckAccessToken);\n    if (isOnline && isAccessTokenValid) {\n      yield fork(task, ...args, action);\n    } else {\n      if (DeviceInfo.isEmulator()) {\n        //The iOS simulator does not cope well with irregular Internet connections.\n        //We need to manually probe for internet if the simulator thinks that we are offline\n        if (!isOnline) yield put(networkSimulatorProbeAction());\n      }\n    }\n    yield call(delay, ms);\n  }\n}\n```. Thank you @Andarist \nyield someArray.map bit me. I had used it in many places and it was not an easy thing to search for. I had to search for all of my \"yield\" and manually locate the places to update.\nIt would be great if the deprecation warning could pin point the place in the code that is bad. Is that hard to fix?\nI'm good for now, but I suspect more will be biten by this.. ",
    "alvelig": "Hi, I made an auth flow library (token based), which consists of 2 libs:\nhttps://github.com/alvelig/redux-saga-auth\nhttps://github.com/alvelig/redux-saga-api-call-routines\nIt makes use of redux-saga-routines for compatibility with redux-form. Any comments are appreciated.. Hi, I made something similar which consists of 2 libs:\nhttps://github.com/alvelig/redux-saga-auth\nhttps://github.com/alvelig/redux-saga-api-call-routines\nIt makes use of redux-saga-routines for compatibility with redux-form. Any comments are appreciated.. @dispix thank you for your interest. Though these are rather early versions, but I plan using this libs in production heavily, so I will be maintaining them anyway if this approach is suitable.\nSome help is required more on defining input and output data for the libs, as I don't have this part clear to be able to cover most production cases.. ",
    "marcelaraujo": "@aikoven Could you post the complete auth flow somewhere? It will be great.. @aikoven It was incomplete because you didn't handle the credentials on yield take(SIGN_IN);. ",
    "zcmgyu": "@aikoven @yelouafi\nSIGN_IN -> AUTHORIZE -> REFRESH* -> SIGN_OUT\nHow could I retry to refresh access_token when api throws 401? Might you give me some hint?\n. ",
    "UchihaVeha": "@zcmgyu \n Create wrapper saga function on fetch\nexport default function* apiCaller({\n  headers = {},\n  ...rest\n}) {\n  const authorizeHeader = yield call(getAuthorizationHeader);\n  const props = {\n    ...rest,\n    headers: {\n      ...headers,\n      ...authorizeHeader\n    }\n  };\n  const response = yield call(request, props);\n  if (response) {\n    if (\n      response.statusCode === 401 &&\n      response.message !== 'refreshToken is expired'\n    ) {\n      const isRefreshed = yield call(tryRefreshTokens);\n      if (isRefreshed) {\n        return yield call(apiCaller, props);\n      }\n    }\n    return response;\n  }\n  return {};\n}\nUsage:\nfunction* loadTodos({ onDate }) {\n  const { payload } = yield call(apiCaller, api.getTodos({ onDate }));\n  if (payload) {\n    yield put(payload )\n    );\n  }\n}. @zcmgyu \n Create wrapper saga function on fetch\nexport default function* apiCaller({\n  headers = {},\n  ...rest\n}) {\n  const authorizeHeader = yield call(getAuthorizationHeader);\n  const props = {\n    ...rest,\n    headers: {\n      ...headers,\n      ...authorizeHeader\n    }\n  };\n  const response = yield call(request, props);\n  if (response) {\n    if (\n      response.statusCode === 401 &&\n      response.message !== 'refreshToken is expired'\n    ) {\n      const isRefreshed = yield call(tryRefreshTokens);\n      if (isRefreshed) {\n        return yield call(apiCaller, props);\n      }\n    }\n    return response;\n  }\n  return {};\n}\nUsage:\nfunction* loadTodos({ onDate }) {\n  const { payload } = yield call(apiCaller, api.getTodos({ onDate }));\n  if (payload) {\n    yield put(payload )\n    );\n  }\n}. instead if (isFetching(getState()))  u can use if (select(isFetching))\nfunction* fetchSaga() {\n  try {\n    const isFetching = yield select(isFetchingSelector);\n    if(!isFetching){\n       yield put({type: 'FETCH_START'});\n       const res = yield call(api.fetch);\n       yield put({type: 'FETCH_SUCCESS'});\n    }   \n  } catch(err) {\n    yield put({type: 'FETCH_FAILURE'});\n  }\n}\nAfter action 'FETCH_START' set isFetching to true in store. Don't forget after action 'FETCH_SUCCESS' and 'FETCH_FAILURE' set isFetching to false\n. instead if (isFetching(getState()))  u can use if (select(isFetching))\nfunction* fetchSaga() {\n  try {\n    const isFetching = yield select(isFetchingSelector);\n    if(!isFetching){\n       yield put({type: 'FETCH_START'});\n       const res = yield call(api.fetch);\n       yield put({type: 'FETCH_SUCCESS'});\n    }   \n  } catch(err) {\n    yield put({type: 'FETCH_FAILURE'});\n  }\n}\nAfter action 'FETCH_START' set isFetching to true in store. Don't forget after action 'FETCH_SUCCESS' and 'FETCH_FAILURE' set isFetching to false\n. Why just not call?\n```javascript\nfunction *createTag(name) {\n    yield call(Api.create, {name}); \n    // then fetch all\n    const tags = yield call(Api.listTags);\n    // store in redux state\n    yield put(setTagData({tags}));\n}\nfunction createTagAndDoSomething({ name }) {\n   yield call(createTag, name)\n  // do something, Tag already created\n}\n. Why just not call?javascript\nfunction createTag(name) {\n    yield call(Api.create, {name}); \n    // then fetch all\n    const tags = yield call(Api.listTags);\n    // store in redux state\n    yield put(setTagData({tags}));\n}\nfunction *createTagAndDoSomething({ name }) {\n   yield call(createTag, name)\n  // do something, Tag already created\n}\n```. ",
    "nachoargentina": "\n@zcmgyu\nCreate wrapper saga function on fetch\nexport default function* apiCaller({\n  headers = {},\n  ...rest\n}) {\n  const authorizeHeader = yield call(getAuthorizationHeader);\n  const props = {\n    ...rest,\n    headers: {\n      ...headers,\n      ...authorizeHeader\n    }\n  };\n  const response = yield call(request, props);\n  if (response) {\n    if (\n      response.statusCode === 401 &&\n      response.message !== 'refreshToken is expired'\n    ) {\n      const isRefreshed = yield call(tryRefreshTokens);\n      if (isRefreshed) {\n        return yield call(apiCaller, props);\n      }\n    }\n    return response;\n  }\n  return {};\n}\nUsage:\nfunction* loadTodos({ onDate }) {\n  const { payload } = yield call(apiCaller, api.getTodos({ onDate }));\n  if (payload) {\n    yield put(payload )\n    );\n  }\n}\n\nHi! sorry to revive the thread again. I have been trying your suggested approach to refresh a token if an API call is made that comes back with 401. I created wrapper saga function on fetch and it's all working fine except for one thing.\nQuoting the example, let's say that htis function to get all todos runs on the click of a button:\nfunction* loadTodos({ onDate }) {\n  const { payload } = yield call(apiCaller, api.getTodos({ onDate }));\n  if (payload) {\n    yield put(payload )\n    );\n  }\n}\nThis will go through the API caller, make the call, and if it fails, it will refresh the token and make the call again with the new token. Awesome!\nNow, this is the problem I'm facing. To make it simple, let's say someone clicks the button 10 times in a row. This will trigger 10 API calls.\nMy expectation would be that the first API call will fail and it will request a new token.\nIn the meantime, the other calls will start to fail too. Since a new token is being requested, I just want to make it so that they wait for the token refreshed action to be dispatch, and when that happen, retry the calls with the new token.\nAll in all, I'm eventually expecting all 10 API calls to be made successfully.\nHere's the code I came up with:\n```\nexport default function* ApiCaller(method, url, params = null, body = null, avoidHeader) {\n    const props = {\n        method,\n        url,\n        params,\n        body,\n        avoidHeader\n    };\n    if (localStorage.getItem('isRefreshingToken')) {\n        const { success } = yield race({\n            success: take(AUTH_ACTIONS.userTokenRefreshSuccess().type),\n            fail: take(AUTH_ACTIONS.userTokenRefreshFailure().type)\n        });\n        if (success) {\n            localStorage.setItem('isRefreshingToken', '');\n            console.log('token refreshed, retrying');\n            return yield call(ApiCaller, props.method, props.url, props.params, props.body, props.avoidHeader);\n        } else {\n            console.log('token refresh failed, logging out user');\n            yield put(AUTH_ACTIONS.LOGOUT_REQUEST);\n        }\n    } else {\n        const response = yield call(callApi, props);\n        const { success } = response;\n        const { error } = response;\n        const errorData = error && error.response && error.response.data;\n        if (errorData) {\n            if (\n                errorData.httpErrorType === 401\n                && errorData.type === 'unauthorized'\n            ) {\n                if(!localStorage.getItem('isRefreshingToken')) {\n                    localStorage.setItem('isRefreshingToken', true);\n                    yield put(AUTH_ACTIONS.userTokenRefreshRequest());\n                const { success } = yield race({\n                    success: take(AUTH_ACTIONS.userTokenRefreshSuccess().type),\n                    fail: take(AUTH_ACTIONS.userTokenRefreshFailure().type)\n                });\n\n                if (success) {\n                    localStorage.setItem('isRefreshingToken', '');\n                    return yield call(ApiCaller, props.method, props.url, props.params, props.body, props.avoidHeader);\n                } else {\n                    console.log('token refresh failed, logging out user');\n                    yield put(AUTH_ACTIONS.LOGOUT_REQUEST);\n                }\n            } else {\n                const { success } = yield race({\n                    success: take(AUTH_ACTIONS.userTokenRefreshSuccess().type),\n                    fail: take(AUTH_ACTIONS.userTokenRefreshFailure().type)\n                });\n                if (success) {\n                    console.log('token refreshed, retrying');\n                    return yield call(ApiCaller, props.method, props.url, props.params, props.body, props.avoidHeader);\n                } else {\n                    console.log('token refresh failed, logging out user');\n                    yield put(AUTH_ACTIONS.LOGOUT_REQUEST);\n                }\n            }\n        }\n    }\n    return success;\n}\n\n``\nI hope it's not too bad.\nThe problem here is that the moment a second API call get's made and it goes throughconst response = yield call(callApi, props);`, it's like the response get's overwitten and you are always listening ONLY to the last API call. So, after 10 clicks, you would have made 10 API calls that failed, 1 refresh token call and then only 1 of the calls (the last one) will be made with the new token!\nAny suggestions on how I may address that?\nThanks in advanced for your time guys!. ",
    "jimbol": "Does all serve the same purpose as batched-actions?  I am assuming no, but perhaps you can shed light on this, @yelouafi.. Thought so, thanks @Andarist!. @axelson, I agree that put and call are the main items that should be tested.  They are the items which have an effect on the application.\ntake should be tested as well seeing as how it is what triggers the saga.  We want to test what triggers the saga.\nselect, then, is an input.  i.e. Given select(myData) yields { foo: 'bar' }, I expect call to myApi with some payload.\n. What I would like to see a sort of saga spy, which gives us the ability to write a test like this.\n``` es6\nlet sagaSpy;\nbeforeEach(() => {\n  sagaSpy = spyOnSaga({\n    saga: mySaga,\n    selectors: {\n      myData: () => myDataStub,\n      token: () => stubToken,\n    }\n  });\n});\nit('is triggered by MY_ACTION', () => {\n  sagaSpy.dispatchAction(myAction());\n  expect(sagaSpy.called).to.be.true();\n});\ncontext('when MY_ACTION is dispatched', () => {\n  context('when myData is clean', () => {\n    beforeEach(() => {\n      sagaSpy = spyOnSaga({\n        saga: mySaga,\n        selectors: {\n          myData: () => myCleanDataStub,\n          token: () => stubToken,\n        }\n      });\n  sagaSpy.dispatchAction(myAction());\n});\n\nit('dispatches UPDATE action', () => {\n  const updateAction = put(createUpdateAction({ foo: 'bar'}));\n  expect(sagaSpy.getCall(0).puts(updateAction)).to.be.true();\n});\n\n});\ncontext('when myData is dirty', () => {\n    beforeEach(() => {\n      sagaSpy = spyOnSaga({\n        saga: mySaga,\n        selectors: {\n          myData: () => myDirtyDataStub,\n          token: () => stubToken,\n        }\n      });\n  sagaSpy.dispatchAction(myAction());\n});\n\nit('dispatches REFRESH action', () => {\n  const refreshAction = put(createRefreshAction({ foo: 'bar'}));\n  expect(sagaSpy.getCall(0).puts(refreshAction)).to.be.true();\n});\n\nit('calls refresh api', () => {\n  const refreshAction = call(doRefresh, { token, foo: 'bar'});\n  expect(sagaSpy.getCall(0).calls(refreshAction)).to.be.true();\n});\n\n});\n});\n```\n. Spent a little more time on this approach with the goal of having this api.\n``` es6\nconst spy = effectSpy(generator)\n  .next('init')\n  .next('getToken', token) // name and pass in yield values\n  .next('getUpdatedFooBars', fooBars)\n  .next('putFooBars');\n// in beforeEach\nmySpyRun = spy.run({\n  getToken: 'invalid-token' // accepts overrides\n});\n// in it statement\nexpect(mySpyRun.getToken.value).to.deep.equal(select(getToken))\nexpect(mySpyRun.putFooBars.value)\n  .to.deep.equal(put(fooBarsAction, fooBars))\n```\nFeel free to use, the implementation is simple, I could turn this into a module if there's interest.\nhttps://gist.github.com/jimbol/fe660007487e57a6e172ba26c3ada23b\n. I have been working on this generator test runner for the past couple months that my team seems to enjoy for testing sagas/effects.  I laid out the API earlier in this thread.\nI just added a match method, which allows you to define catch-alls for yielded values.\n``es6\n// In this example, all yields which meet the conditions of thedetectSelectorfn\n// Will use thecallSelectorresult instead of the normal iterator flow (usingrunner.next()`)\n// Returns true if step meets desired conditions, otherwise false\nconst detectSelector = (step: YieldedStep): boolean => {\n  return step.value && step.value.SELECT;\n};\n// Returns argument to be passed into step.next\nconst callSelector = (step: YieldedStep): * => {\n  return step.value.select.selector(); // call spy (edit: \"spy\" not \"promise\")\n};\nsinon.stub(selectors, 'getToken').returns('fake-token');\nsinon.stub(selectors, 'barIdsSelected').returns([ 1, 2, 3 ]);\nrun = genRunner(onArchiveThreads)\n  .match('select', detectSelector, callSelector)\n  .next('start')\n  .next('finish')\n  .run();\n```\nThis way it doesn't matter the order that our selectors are called, but we can still test the order of things that we care about.. Whoops, spy, not promise.\nThe selector detector could be any function, whatever makes the most sense!  So long as it returns a bool.  I would appreciate some advice on what is the best way to detect a selector from the yielded value.  Would you share a better way?. Yes! We can get the steps off the run later for testing.  \nFor match, you get an array of the yielded values\n```es6\nconst SELECT = 'select';\ntype Step = { next: Function, done: Boolean, value: * };\nconst run = genRunner(generator)\n  .match(SELECT, detect, callSelector)\n  .run();\nconst steps: Array = run.get(SELECT);\nexpect(steps[0].value).to.deep.equal(select(getThing));\n```\nFor next, you get a single value this way.\nes6\nconst step: Step = run.get('finish');\nexpect(step.done).to.be.true();. What are your thoughts on snapshot testing sagas and effects?. @kwnccc @neurosnap yes you can do snapshots on partial generator runs.. yield shouldUpdate(); bypasses the declarative goodies that redux sagas give you.  For example, when I'm unit testing, I'll often test the result of the yield.\nexpect(effect.next().value).to.deep.equal(call(shouldUpdate));\nAs opposed to testing the output of shouldUpdate.\nexpect(effect.next().value).to.deep.equal(shouldUpdate());\nIn the second example, we have to stub or run shouldUpdate which might involve a bunch of set up and a whole separate effect run.\nI'm sure there are other reasons.. You're welcome!. This is due to the switch to the new parallel effect combinator, all\nIn the places where you are doing this\nes6\nyield [\n  call(effectA),\n  call(effectB),\n]\nyou have to do this instead\nes6\nyield all([\n  call(effectA),\n  call(effectB),\n]). Perhaps action creators could add a role of some sort, then saga middleware could check for that role.\n```es6\ncreateSagaMiddleware({\n  emitter: emit => action => {\n    if (!action.meta.role) return emit(action);\nif (action.meta.role === SAGA) {\n  emit(action);\n  return;\n}\n\n}\n});\n```\nThen a higher order reducer could do a similar intercept on the reducer side\n```es6\nfunction todoReducer (state, action) {\n  // ... normal reducer stuff\n}\nfunction createRoleReducer(reducer) {\n  return function(state, action) {\n    if (!action.meta.role) return reducer(state, action);\n    if (action.meta.role === REDUCER) {\n      return reducer(state, action);\n    }\n  }\n}\ncreateRoleReducer(todoReducer);\n```\nWhich leaves us with the ability to do this\n```es6\n// only hits the saga\ndispatch({\n  type: ADD_TODO,\n  meta: {\n    role: SAGA,\n  }\n})\n// only hits the reducer\ndispatch({\n  type: ADD_TODO,\n  meta: {\n    role: REDUCER,\n  }\n})\n// hits the reducer and the saga\ndispatch({\n  type: ADD_TODO,\n})\n```\nIs there an easier way of supporting \"roles\" like this? . Perhaps race is what you're looking for. Heres the official guide.. Perhaps I'm missing some nuance of event channels but this should be possible\n```es6\nconst { actionA, actionB } = yield race({\n  actionA: take(ACTION_A),\n  actionB: take(ACTION_B)\n});\nif (actionA) {\n  console.log('A won');\n} else if (actionB) {\n  console.log('B won');\n}\n``.put` takes a single argument, an action object.\nYou are passing in two arguments. Perhaps you meant:\nconst action = { type: \"INSERT_REQUESTED\", id };\nyield put(action);\nYou could even write a function which returns an action \nfunction createInsertRequestedAction (id) {\n  return { type: \"INSERT_REQUESTED\", id }\n}\nThen just do \nyield put(createInsertRequestedAction(id));\nSaga put docs\n. I think the saga is getting hung up on the put because it's not being passed an action. Can you verify?. We use redux-batched-actions for this.\nAfter setting up you just go.\n```es6\nimport { batchActions } from 'redux-batched-actions';\nyield put(batchActions([\n  updateEntity(ENTITYS.COMMENT, id, comment),\n  updateEntity(ENTITYS.STORY, storyId, entity => ({ commentIds:entity.commentIds.map(commentId => commentId === id ? comment.id : commentId) })),\n]))\n```. You're welcome!\nThis is might be a comment on Redux. You'll notice store.subscribe is part of the Redux api, not Redux-Saga.\nFrom the Redux issue on the subject, the suggested approach has been implemented by the redux-batched-actions library.\nStealing the example from that issue.\nYou could create an action creator which takes a list of actions.\n```es6\nfunction batchActions(actions) {\n  return {\n    type: 'BATCH_ACTIONS',\n    actions: actions\n  };\n}\n// usage\nstore.dispatch(\n  batchActions([\n    doSomething(),\n    doSomethingElse()\n  ])\n);\nThen you could use a [Higher Order Reducer](http://redux.js.org/docs/recipes/reducers/ReusingReducerLogic.html#customizing-behavior-with-higher-order-reducers) to handle those actions all at once.es6\nfunction enableBatching(reducer) {\n  return function batchingReducer(state, action) {\n    switch (action.type) {\n    case 'BATCH_ACTIONS':\n      return action.actions.reduce(batchingReducer, state);\n    default:\n      return reducer(state, action);\n    }\n  }\n}\n// usage\nlet store = createStore(enableBatching(reducer));\n```\n(source)\nHope this helps!. ",
    "joshrtay": "Another thing I have been messing around with, which is pretty relevant to this discussion is https://github.com/redux-effects/redux-flo. The idea is one generic control flow middleware that can be leveraged by a whole suite of action creators, other middleware and reducers.\nThat particular implementation is tied to redux, but the basic idea is that actions are processed in two phases: a map and a toPromise.\njs\ntoPromise(map(io, control)).then(successHandler, errorHandler)\nThe map function, maps values over the io function, and handles controls that are generators, arrays, and objects by default. Any control can define it's own behavior by implementing it's own map method. Here's the implementation of map https://github.com/micro-js/map/blob/master/lib/index.js.\nThe toPromise is basically plucked from co. It converts arrays, objects, generators, and thunks to promises. The only difference between my toPromise and the one in co is that it's not recursive (maybe it should be). Here's the implementation of toPromise https://github.com/micro-js/to-promise. \nLove to hear what you guys think.\nEdit:\nThe motivation behind the toPromise(map(io, control)) paradigm is to try and completely generalize IO/async flows. An indication of how general this paradigm is that both yio and co can be roughly implemented with it in one line:\nyio is toPromise(map(io, flatten(control)))\nco is toPromise(map(toPromise, flatten(control)))\n. On a side note, I think that redux middleware is a really powerful way of creating interpreters. I don't know that it's as important to decouple the middleware api from saga as it is to be able to leverage redux-saga in non-redux contexts. I've created a little package that let's you do just that. It's called bind-middleware and it basically composes redux middleware and binds them to a ctx. Here's an example:\n``` js\nvar bindMiddleware = require('@f/bind-middleware')\nvar logger = require('redux-logger')\nvar thunk = require('redux-thunk')\nvar dispatch = bindMiddleware([\n  thunk,\n  logger()\n])\ndispatch(dispatch => {\n  setTimeout(() => {\n    dispatch({type: 'INCREMENT'})\n  })\n})\n// log => {type: INCREMENT}\n```\nI've started toying around with using bind-middleware with redux-flo for IO on the server. Makes for very testable code.\n. @yelouafi Let me think about it a little bit... I think however, that redux-saga with support for take, put, and delay can be implemented in just a few lines with the help of redux-flo.\n. K. This is definitely going to be a bit more than a few lines :)\nBut here's a really modular way of implementing sagas with on support. Take-put and delay can similarly be implemented as their own middleware. And then saga can package it all together with something like @f/compose-middleware.\nsagas\n``` js\nimport {flo} from 'redux-flo'\nfunction middleware (...sagas) {\n  return ({dispatch}) => {\n    dispatch(flo(sagas.map(flo))).then(res => console.log('all sagas exited'))\n    return next => action => next(action)\n  } \n}\nexport default middleware\n```\non\n``` js\nimport {flo} from 'redux-flo'\nimport compose from '@f/compose'\nimport PromiseEmitter from 'promise-emitter' // this doesn't exist \nconst ON = 'ON'\nfunction middleware () {\n  let pemitter = new PromiseEmitter()\n  return ({dispatch}) => next => action =>\n    action && action.type === ON\n      ? pemitter.on(action.payload.event, compose(flo, action.payload.listener))\n      : (pemitter.emit(action.type, action.payload) || next(action))\n}\nfunction on (event, listener) {\n  return {type: ON, payload: {event, listener}}\n}\nexport default middleware\nexport {\n  on\n}\n```\nsaga\n``` js\nimport compose from '@f/compose-middleware'\nimport flow from 'redux-flo'\nimport sagasw from 'sagas'\nimport onw from 'on'\nfunction middleware (...sagas) {\n  return compose([flow(), sagasw(...sagas), onw()])\n}\nexport default middleware\n```\napp\n``` js\nimport sagas from 'sagas'\nimport bind from '@f/bind-middleware'\nlet dispatch = bind([sagas(rootSaga)])\ndispatch({type: 'SOME_ACTION'})\nfunction * rootSaga () {\n   yield on('SOME_ACTION', handlerSaga)\n}\n```\nThis is all very rough and I'm not very familiar with saga, but treating incoming actions as part of the flow should not be a problem. Let me know if I missed something.\n. @yelouafi The code is just a basic implementation of saga with only on support. The sagas module is middleware that simply runs the saga daemons. The on module attempts to simply treat the control flow units of saga as redux-effects (middleware that returns promises). The saga module composes flow, saga, and on into a single middleware and would ultimately add take, put... in a fully fleshed out version. app is just a stupid example of an app using sagas nothing special and probably not even relevant.\nI don't think canceling propagation would have to do anything that special, but I too would have to think about it.\nThe main idea here is come up with a powerful model for control flow (whether it be redux-flo or something else), stick it at the top of the middleware stack, create middleware for starting your sagas, then everything else is redux-effects style middleware and actions.\n. ",
    "kurtharriger": "Technically it is possible to externalize the state of an iterator.  See ramdajs.unfold for example.  Perhaps some sort of babel transform might make it possible to capture the state of a generator.  \nHowever you will run into the issue that not all state is serializable in a meaningful way, a websocket once closed is closed, a completed promise once completed wont complete again unless restarted.  You would probably need some sort of hook that can be called when generator state is being serialized and deserialized to allow this state to restore the state or reset it as needed.  \nA bit like suspending a laptop, internet connections will be lost and it may or may not be possible to restore them when the laptop resumes... but its a feature I use everyday and have all but forgotten how much time I wasted shutting down and booting up my laptop and with a few hooks from the os to inform the process that it is being suspended and resumed it works quite well.\nI don't think it will be easy to do with generators, but it can be done with externalized state and a few hooks. \n. ",
    "ghost": "I've been exploring various strategies centered around redux for handling side effects, and this is one of the key implementation details that has kept me from adopting any solution: side effects break time travel (by their very nature).  However, we might be able to skirt around this issue with regards to sagas.\nAs @slorber has mentioned, the real source of truth for an event sourced application is not a collection of states, but rather a log of events. If we capture and replay this log, we should be able to time travel by starting with a fresh application and replaying events 0...N. The trick here I believe is to morph sagas while events are being replayed. I say \"morph\" here because I don't think \"disable\" is the right word. \nConsider \"disabling\" a saga:\nIn the simplest case, if you have a saga that waits for event_a then eventually performs task_a_1 ... task_a_n, you must disable the saga middleware because you don't want to duplicate task_a_1 ... task_a_n when replaying event_a. You (more than likely) already have the results of those tasks (along with any data they fetched) stored inside the event log, so as far as the non-middleware part of the application is concerned, the saga did actually trigger and the resulting side effects were pumped into the system.\nIn the non-simple case, you are part-way through a saga's side effects when the time travel begins. Consider a saga at step 2 out of 4 steps. If we start with a fresh application and replay events 0...N with sagas disabled, our reset saga will never receive the necessary events to move from step 0 back to step 2 where it belongs, and thus future events that would have triggered step 3 and step 4 are dropped on the floor.\nMy initial solution in this case is that we need to have sagas enabled, but somehow prevent them from performing their side effects... just let them capture incoming events to move into their appropriate positions. I can't think of a generic way to do this as it would, at the very least, require disabling any xhr during replay, and more than likely require other hacks of a similar fashion. But even then, disabling xhr that ultimately returns to emit another event means our saga will get stuck in an abandoned state.\nAnother possible solution is (at least for the purposes of debugging) to only replay events in acceptable \"chunks\" corresponding to sagas. If your saga is 3 steps, but the event log only has 1/3 steps completed, only replay 0...N-1 to where the saga has not yet started. I don't know how this would hold up to scrutiny. \n. Does that require a memoization wrapper around everything exported by io that extracts a value, such as race/take, or are we talking about a higher level memoization of the saga itself (as you say, by the executor)? I can't see how a higher level memoization of the executor would allow you to invoke the sagas to \"put them back where they should be\" when replaying events... so it must be the first case?\nI like this idea of memoization, but it gets more complex if your side effects aren't idempotent. Given event_a, move saga to step 1 if state a - or move saga to step 2 if state b. I'm digging through a few github projects to find the comments/issues stream where others were talking about this issue; how can we eliminate getState() entirely from either a thunk or a saga, so it's simply handed exactly what it needs to know and remains idempotent.\n. After some more thought, I wonder if we can get away with ignoring this issue entirely and accept a \"good enough\" solution. What are the chances that you want to debug something not related to a saga, but takes place during the lifetime of a saga? Seems like a very edge case to me. With that in mind, If we just accept the hard truth that \"when writing/debugging sagas, we are going to have to f5\", simple solutions become more plausible.\nJust disable sagas when replaying events... don't worry about trying to memoize their results or capture their partially-completed state or \"guarantee\" that they are restored to the proper state during a replay. The caveat here is that if you want to step back in time, wait until your saga has completed (returned xhr, timeout, whatever) so the event log has everything it needs and no saga is left in a partial state. \nDoes that sound reasonable? Can someone think of use cases where it becomes such an inconvenience to not have time-travel in sagas that we have to have a complicated solution implementing state serialization/deserialization, generator forwarding, side effect memoization, and whatever else might be required?\n. I too struggle with getState in any sort of action creator or side effect, whether that be redux-thunk or redux-saga... it just smells wrong that the details of the state shape have to leak into a component that just shouldn't care.\nThis is interesting, selecting a state slice from the saga. It's a tradeoff of more boilerplate for a centralized location where we can explicitly extract state, but is that tradeoff worth it? I'm not sure.\nOne approach I've tried is normalizing my state for components where I have not been able to avoid getState() inside a side effect. The normalization puts all these state objects inside a state._entities and then offers up the id when dispatching. This, of course, requires assigning targets to events (which is a prerequisite of reusable components across the app anyways). so there's a bit more complexity here required. All in all it offers a nice API, though:\n// thunk example\nactionCreator() {\n  return (dispatch, getState, target) {\n    let relevantStateSlice = getState()._entities.get(target.id)\n    // do stuff with the state slice ...\n  }\n}\n. Just some thoughts as I work through these problems myself...\nI'm not sure that a put(..).should.equal(put(..)) or fork(...).should.eql(fork(...)) approach is the simplest path forward. It's only a marginal advantage/convenience to not have to mock out a service to return some data object, but it introduces weird implementation burdens on the testers - having to use some sort of library mocking service, for example.\nI'm in a pinch where my ./some-feature-sagas.js exports only the root sagas for that feature, and a ./root-saga.js later scoops up these exports and forks all the processes. If we are going to test the \"full\" generator in a behavioral style - which may be many forks/calls/puts/takes, it seems very inconvenient to have to say something like:\nit('should dispatch a fetch request', function() {\n            const mock = { id: 'foo' } \n            sut.next() // take the first action to start the gen\n            sut.next(mock) // feed back some mock data present on the first action\n            sut.next() // move into a fork or a call - not really testing anything here, just moving along\n            sut.next().value.should.eql(io.put(creators.fetchRequest())) // testing the correct dispatch\n            ... etc.\n        })\nOn the other hand, if we want a unit-style test (which I am not a fan of ... I don't care that y was invoked and z were arguments, I want to know that invoking x returned the appropriate thing in the appropriate shape, or failed and threw the correct error, etc), we have to export all the sub-step/nested generators along the way. Exporting those generators places a burden on the app code - whether it's something cheesy like \"if this feature-saga exports functions like _function, don't fork it from the root reducer\", or something more complicated/orthogonal.\nedits: \nsorry, I got a new keyboard and keep missing keys and hitting tab -> update comment.\n. On a related note, this pattern is becoming quite common across a lot of my sagas. Fetch something, but do it in a non-blocking manner so if the user has quick fingers or the interface offers a cancel button, we can abort the outstanding xhr, capture the errors, and fire off another forked fetch.\nIt is fantastic to have this capability, since it can guarantee you don't pipe stale data through the system (in the case of the first-click xhr returning before the second-click xhr).\nThat being said, I don't really like the idea of a scoped \"global\" variable and doing things like task && task.isRunning()... it reminds me too much of recursion and doesn't seem to nicely line up with a structured programming paradigm. I wonder if there's a better way?\n. I'm also trying to understand the problem here so I might be able to patch my local version while waiting for a PR from @gaearon (which I'm sure will be a better solution than my own).\nWhen you invoke the middleware with sagaMiddleware(...sagas) it creates one new emitter. For each saga the emitter's subscribe is handed over to proc along with the store's dispatch function. That subscribe fn is immediately invoked and handed a callback that will use a closure to capture deferredInputs (which is an array that receives gets a new item each time a runTakeEffect is invoked). \nAt some point in the future (during the middleware next chain) that same emitter instance is invoked via sagaEmitter.emit(action), which trigger's a flushing of the matching deferredInputs... then a whole bunch of other stuff happens that I don't quite follow yet-- generating descriptions of events... somewhere in there is the kick-start to the whole process... dispatch is finally triggered with a runPutEffect (not sure who's running the put)... chaining/reducing of actions + events and resolving deferred values via next and runEffect, etc.\nWhen you call runSaga it creates a new emitter instance, and hooks up the subscribe of proc to this different instance's subscribe, and attempts to hand over the same dispatching function. It can't hand over the exact same function, though, because it needs a way to invoke emit(action) for this new emitter instance... and since the middleware chain is set and locked during startup, we can't become another step in the middleware. Instead, we slip ourselves into the middleware at the tail end of the original call to dispatch, which is redirected to a monkey-patched dispatch to flush this separate emitter's subscribers.\nAnd here we arrive at @dmitriykharchenko much more concise explanation: \n\nsaga called with runSaga can dispatch actions to store and all sagas from middleware will see it, but actions dispatched from middleware sagas can't be taken by saga called with runSaga\n\nThe proposed solution is to get rid of runSaga and instead offer sagaMiddleware.run so that on a run we can just invoke another proc but this time utilize the original emitter instance and have a handle to the original dispatch function? \nI'm a little confused by this statement: \n\nso it has access to the dispatched actions\n\n\nBy the way @yelouafi really neat stuff, I'm learning a lot from reading your code.\n. I also don't like the pattern of exporting middleware, it just seems smelly.\n``` javascript\nexport default function createSagaMiddleware(...sagas) {\n    const sagaEmitter = emitter()\n    let _dispatch\nfunction middleware({ getState, dispatch }) {\n    _dispatch = dispatch // better way to do this? really hacky\n    sagas.forEach(saga => {\n        proc(\n            saga(getState),\n            sagaEmitter.subscribe,\n            dispatch,\n            action => asap(() => dispatch(action)),\n            0,\n            saga.name\n        )\n    })\n\n    return (next) => (action) => {\n        const result = next(action) // hit reducers\n        sagaEmitter.emit(action)\n        return result;\n    }\n}\n\nmiddleware.run = (iterator, { subscribe, dispatch }, monitor = noop) => {\n    if (!subscribe) {\n        subscribe = sagaEmitter.subscribe\n    }\n\n    if (!dispatch) {\n        dispatch = _dispatch\n    }\n\n    check(iterator, is.iterator, NOT_ITERATOR_ERROR)\n\n    return proc(\n        iterator\n        , subscribe\n        , dispatch\n        , monitor\n    )\n}\n\nreturn middleware\n\n}\n```\nIf someone is using an IoC container, they now have to jump through some hoops to have access to run ( which was previously exposed directly as runSaga ). I'm not sure how, though, you could split this up into two modules - they seem rather dependent on one another's scope.\nIt would be nice if you could still have a runSaga exposed as it is now, perhaps (optionally) curried with the results of createSagaMiddleware (with the ability to override for different IO schemes).\n. I'm more referring to how to manage instance-sharing. If invoking the middleware creates a new EventEmitter and we need that emitter to be shared between runSaga and all the ...sagas, it becomes sort of a 'conditional export', if that makes sense. You have to have invoked the sagaMiddleware before you can use runSaga with the above strategy, unless you can think of a more clever way to share the same emitter? Maybe some sort of ...\n``` javascript\nimport { runSaga } from 'redux-saga'\nconst runner = runSaga(emitterInstance)\nrunner(saga(), storeIO(store))\n```\nThe issue with running an IoC container becomes something like this...\n``` javascript\nioc.register('sagaMiddleware', () => {\n    const saga = require('redux-saga')\n    // or import { saga } from 'redux-saga'\nlet runSaga\nfunction createMiddleware(sagas) {\n    // generate the middleware\n    let middleware = saga.default(sagas)\n\n    // now that we have the instance, hook up to 'run'\n    runSaga = middleware.runSaga\n\n    return middleware\n}\n\ncreateMiddleware.runSaga = (args) => {\n    if (!runSaga) {\n        throw new Error('cannot runSaga before initializing sagaMiddleware')\n    }\n\n    return runSaga(args)\n}\n\nreturn createMiddleware\n\n})\n```\nIt's a lot of hoops to jump through, and in the end we cannot register a runSaga component to be injected where it's needed across the app. Instead we have to utilize the opaque createMiddleware.runSaga. Not a huge deal, and can probably be solved by runtime/dynamic IoC registration, but it's still jumping through hoops. If someone smarter than me could devise a way to share the emitter instance while exposing two independent modules for export that would make life a lot easier.\nioc.register('sagaMiddleware', require('redux-saga').default)\nioc.register('runSaga', require('redux-saga').runSaga)\n. I realize cancellation is not standard yet, but my favorite promise library bluebird does support cancellation, and I have a decorated/promisified xhr library that will xhr.abort() when told.\nThanks again @yelouafi, you are right. I'm not sure I totally understand the syntax here, but return (yield someVar = ... )) makes someVar declared inside a catch block.\n. Perhaps I'm missing something here, but I'm dropping events across the websocket connection using this deferred method. \nIt seems like this is a result of the event loop and next-tick mechanics, because if I change the code to this:\njavascript\n  socket.subscribe(event, payload => {\n    if(deferred) {\n      deferred.resolve(payload)\n      deferred = null \n    } else {\n      console.log('dropped event', payload)\n    }\n  }\nI get a whole lot of dropped event logs. \nHowever, if I utilize a simple queue as demonstrated here I do not run into any dropped frames. Hopefully this is helpful to someone else with the same issue.\nI would be curious if someone could explain to my why this is happening, however.\n. Sorry, I left out an important piece - the root saga invoking this chain.\n``` javascript\n    function* root() {\n        let process\n        while (true) {\n            yield take(SOME_TRIGGER)\n            if (process && process.isRunning()) {\n                yield cancel(process)\n            }\n        process = yield fork(fetchSomeStuff)\n    }\n}\n\n```\nI use this pattern when the user can click on a list of items, and each click will trigger a data fetch for that item. If the user changes his mind and clicks on a different item while one is already loading, we can cancel the first data fetch.\nIt's not a huge ordeal, I'm just pointing out that when yield cancel(process) is triggered, it will throw SagaCancellationException in each branch of the fetchSomeStuff- which is fine, but it might be too ambitious to console.warn in each branch that doesn't explicitly handle that exception. I don't want to have to write a try/catch for every level of my saga if only one (bottom-most) or two (bottom most and top most) levels actually do anything after the exception.\n. I would :+1:  that... perhaps just the NODE_ENV=\"production\" convention. I have used that with something like envify in the past and it works well.\n. Looks like this was taken care of in https://github.com/yelouafi/redux-saga/blob/no-promise/src/proc.js#L79-L81\n. Looks like this was taken care of https://github.com/yelouafi/redux-saga/blob/no-promise/src/middleware.js#L25-L27\n. Thanks for the reference @yelouafi. I never considered runSaga for this approach, but it looks like it's more or less suitable. I have been struggling to find a way to have truly reusable components (where a component is a packaged set of actions, a reducer, and a view) inside the redux architecture. I think I managed to get what I'm looking for by exposing a .create() function on all reusable components that generates a uuid, wraps all their action creators with that unique id, and embeds the uuid in the state slice. When reducers are invoked, I first check if that id matches up with the instance id and only proceed if this is the case.\nThe issue I'm having, and perhaps this is related to https://github.com/yelouafi/redux-saga/issues/48 (but I don't really think so), is that when I spawn a runSaga during .create(), those reusable component's sagas never catch their first take.\n``` javascript\nfunction* watchComponentMount(id) {\n    while (true) {\n        // ...this never triggers\n        const event = yield io.take(acitons.COMPONENT_MOUNTED)\n        if (event.id !== id) continue\n        ...\n    }\n}\n...\ncreate(reusableComponent) {\n    const uuid = cuid()\n    if (reusableComponent.hasSagas()) {\n        const dynamicSagas = reusableComponent.getSagas().map((saga) => {\n            return runSaga(\n                saga(uuid)\n                , storeIO(store)\n            )\n        })\n    }\n...\n\n}\n...\n```\nIf I utilize the normal middlewares, though, the same saga will capture that event.\njavascript\ninitSagas() {\n    return function* rootSaga() {\n        yield io.fork(watchComponentMount)\n    }\n}\nI have dug around a bit making sure that my app code isn't doing something funny, but I just can't see what the source of the problem might be.\n. To give you a bigger picture, here's a bit more detail.\nIn short, create is invoked prior to mounting. I can prove this by introducing breakpoints, but also by the fact that a io.fork(watchComponentMount) saga that runs through the \"normal\" middleware captures this event without issue.\n``` javascript\nfunction parentReducer(state, action) {\n    switch (action.type) {\n        case ACTION_THAT_REQUIRES_CREATING_CHILD:\n            state = {\n                ...state\n                , childState: reusableChildReducer.create()\n            }\n            return state\n        ...\n    }\nfunction reusableChildReducer(state, action) {\n    switch (action.type) {\n        case '$create':\n            // special key invoked on .create()\n            // ...do some initializing stuff\n            return { ...state, someInitValue: 'foo' }\n        ...\n    }\n}\n// any component that wants to be \"reusable\" is decorated by this wrapper\nreusableDecorator.create = (initialState = {}, action = {}) => {\n    const id = cuid()\n// wrap the action creators of this reusable component so each call\n// to a creator enchances the { type: some_type, ...args } action\n// object with the unique id associated with this created instance\nconst wrappedActionCreators = wrapActionCreatorsWithId(id, initialState)\n\n// run the reducer once with a special key to initialize any default\n// properties.\n//\n// <<Important>> provide the wrapped action creators as functions on\n// the initial state... this allows components to reuse our implementation\n// by simply handing down all properties (including the action creators)\n// to the view via <ReusableComponent { ...this.props.reusableStateSlice } />\nconst reusableInitialState = reducerToDecorate(wrappedActionCreators, { type: '$create', ...args })\n\nif (reducerToDecorate.hasSagas()) {\n    // same runSaga code as above\n}\n\nreturn reusableInitialState\n\n}\n```\nI hope the above ^ makes sense.\nAs for the actual implementation, it's something like:\n``` javascript\ncomponentDidMount() {\n    this.props.mounted()\n}\nactionCreators() {\n    mounted() {\n        return {\n            type: actions.COMPONENT_MOUNTED\n        }\n    }\n}\nreducer(state, action) {\n    switch (action.type) {\n        case '$create':\n            ...\n            return state\n        ...\n    }\n}\n// parent\nrender() {\n    return (\n        \n            // this is where the wrapped action creator is provided\n            // to the reusable component (without each parent having\n            // to \"know\" or implement its own versions of these creators)\n            \n\n    )\n}\n```\n. Just for completeness' sake, here is the basics of the function that generates wrapped creators:\n``` javascript\nfunction wrapActionCreatorsWithId(id, initialState) {\n    // redux makes dispatch hard to get a handle onto - you only have the decoupled\n    // handle during a mapDispatchToProps invocation on a Connect() component. instead\n    // we are going to sideskirt the issue by taking a handle directly after the\n    // store has been generated by the bootstrap, and use that handle to invoke\n    // dispatch from within reusable components\n    const dispatch = store.dispatch\n// store this on the state if needed for later use\ninitialState._reusable = {\n    id\n}\n\nlet wrappedCreators = {}\nfor (let p in actionCreators) {\n    // each call to an action creator is really a call to the wrapper\n    wrappedCreators[p] = (args) => {\n        // get the original action object\n        let created = actionCreators[p].call(null, args)\n\n        // can only use this strategy without thunk-able action creators\n        if (typeof created !== 'object') {\n            throw new Error('reusable action creators must return plain objects')\n        }\n\n        // wrap each action creator with the id before dispatching\n        created = { ...created, target: initialState._reusable }\n        return dispatch(created)\n    }\n}\n\n// return any initial state enhanced with the wrapped creator functions\n// present right on the state object-- this allows implementers using a\n// reusable component to remain ambivalent about the inner details of\n// the component\nreturn { ...initialState, ...wrappedCreators }\n\n}\n```\nI noticed the monkey-patching used in runSaga to rewire store.dispatch, but my handle onto dispatch is taken after this patching completes, so that is also not the source of the issue.\n. I'm slammed with work currently, I'll get back and let you know.\n. Hey @yelouafi I looked into this further after updating to 0.6.1 and the problem still remains. I'm pretty sure it's related to #48. The simple reason seems to be that runSaga has its own instance of eventEmitter when it should really be subscribing to the existing instance of middleware's eventEmitter. \nI have patched this in my own fork and things seem to be working as intended there, but the api is admittedly gross/difficult to use.\n. Just from perusing the implementation I can tell this will fix the problem, thanks!  \nIs the API abandoning the ability to provide a different IO implementation? \n. I have the same question pointed out by @bgerm, but here's a different scenario where a callback might be convenient to have: dialogs. If I want a generic dialog service, I would like to just say \"open the dialog, use this view, use this model, use these callbacks when the dialog is closed/confirmed/cancelled\" instead of having to repeat myself for different dialogs throughout an app.\n```\nfunction* listener() {\n    yield take(OPEN_DIALOG)\n// notify the dialog service\nyield put({ \n    type: 'CREATE_DIALOG'\n    , onConfirm: specialPut({ type: 'CONFIRM' })\n    , onCancel: specialPut({ type: 'CANCEL' })\n    , model: { ... }\n})\n\n// wait for close or confirm\nyield race({\n   cancel: take(CANCEL)\n   , confirm: take(CONFIRM) \n})\n\n....\n}\n// this doesn't work for a variety of reasons\n// 1) coroutine belongs to another lib and is promise based; redux saga doesn't handle promises\n// 2) even with an adapter that allows for resolving non-promise values, the put never seems\n// to resolve... the EFFECT_TRIGGERED shows up in dev tools, but never EFFECT_RESOLVE\nfunction specialPut(action) {\n    return Promise.coroutine(function* putter() {\n        yield io.put(action)\n    })\n}\n// this does seem to work but is also heavy-handed\nfunction aDifferentPut(action) {\n  return function() {\n    runSaga(function* putter() {\n      yield put(action)\n    }())\n  }\n}\n```\n. Thanks for the input @slorber . This issue is probably not the best place to discuss, but here it goes anyways. \nHaving used redux for a few months now across a large project, my biggest pain point is the reusability/composability of components. I think the mentioned use case is another example: how do I reuse something like a dialog service if I need to provide each instance varying dispatch callbacks?\nApp-level architecture flows relatively naturally, but building a single encapsulated unit is really difficult. I feel like it's too simple for the \"api surface\" of a redux app to grow very large, and that makes refactors or redesigns rather difficult. \nFor example, if I have a component concerned with EVENT_HAPPENED, and that component is made up of a handful of reducers (each managing a relatively complex unit of state), do I pipe EVENT_HAPPENED from the root of the component all the way down the reducer hierarchy? Do I translate EVENT_HAPPENED in the root to an internal API call? In the former case it feels like I'm pouring concrete, and the latter case results in a lot of boilerplate.\nA domain driven design approach would translate any event that is external to the component's domain into an internal representation, at which point the root of the reducer hierarchy becomes an aggregate root. This, unfortunately, means a very large reducer at the top of the hierarchy that must capture and translate every single event used by any component below. \n```\nfunction rootComponentReducer(state, action) {\n    switch (action.type) {\n        case 'child_a_1':\n            childAReducer(state, { type: 'internal_a_1' })\n            ...\n        case 'child_a_2':\n            childAReducer(state, { type: 'internal_a_2' })\n            ...\n        case 'child_b_1':\n            childBReducer(state, { type: 'internal_b_1' })\n            ...\n        case 'child_b_2':\n            childBReducer(state, { type: 'internal_b_2' })\n            ...\n            ...\n            ...\n        case 'child_z_2':\n            ...\n}\n\n}\n```\nOn one hand this is a very explicit contract between a component and the rest of the world (good), but on the other it results in an enormous reducer (bad) where a lot of the capture world event -> translate aggregate event is duplicated effort that grows with the number of reusable components nested inside a particular root.\nI would be interested in your thoughts on this. Maybe I'm coming at it from the wrong angle?\nI agree with you that this is (mostly) classical event sourcing. I haven't been very disciplined about maintaining \"has happened\" events and have fallen into the \"action trap\" which may be at the root of some issues I'm having.\n. For those interested, here's a not-great solution to \"how do I put from a callback\". It's not great because this really isn't the way things should be structured, as @slorber mentions above.\n``` javascript\n// because of the way \"call\" works, if we want to \"put\" an action\n// after a callback is invoked, we can return a promise that is\n// bound to resolve when the callback is invoked\nfunction bindCallbackToPromise() {\n    let _resolve\n    const promise = () => {\n        return new Promise((resolve) => {\n            _resolve = resolve\n        })\n    }\n    const cb = (args) => _resolve(args)\nreturn {\n    promise\n    , cb\n}\n\n}\nfunction* watchForDialog() {\n    yield take(DIALOG_REQUESTED)\nconst cancel = bindCallbackToPromise()\nconst confirm = bindCallbackToPromise()\n\nyield put({\n    type: DIALOG_OPENED\n    , cancel: call(cancel.cb)\n    , confirm: call(confirm.cb)\n})\n\n// the race will wait for either the cancel or confirm callback to be invoked - which skirts\n// around the problem of trying to \"put\" from within a callback: don't put an event, instead\n// rely strictly on the resolution of a promise\nconst race = yield race({\n    cancel: call(cancel.promise)\n    , confirm: call(confirm.promise)\n})\n\n...\n\n}\n```\n. Thank you @slorber. Sorry for the very late response. I spent the last weeks with the Elm architecture and have been investigating CSP/core.async and the feasibility of clojurescript. Lots to think about on many different fronts.\n\nInstead of doing this translation into reducers you should do it inside a saga\n\nThis is the key. In order to keep modules decoupled, communication should be as limited as possible. If module A is interested in something about module B, it should setup a saga to listen for B.SOME_EVENT. A module's reducer(s) can then respond exclusively to that module's actions. Following this pattern is a great way to stay away from \"action soup\" where the api surface of a particular reducer has to handle events from all across the app.\n. In a similar vein, it looks like the auto-cancellation caused by race is thrown as a warning as well. I suppose this is intentional, though it feels pretty heavy to have to do this:\nfunction* someTaker() {\n  try {\n    yield take(ACTION)\n  } catch (e) {\n     ...\n  }\n}\nyield race({\n  a: call(someTaker)\n , b: call(someGenerator)\n})\nversus this:\nyield race({\n  a: take(ACTION)\n , b: call(someGenerator)\n})\nMaybe the cancellation wouldn't be thrown when caused by a race for those actions racing a simple take?\n. Hey,\nI am using a React Universal environment and I am loading some data through static component from the router that loads from server initially.\nThe problem I am facing is that the saga is called properly on the server-side but unless I dispatch the same action again inside either componentDidMount or componentWillMount it is not reflecting on the client-side store. Also doesn't show up on the redux-devtools as well. So the yield put is basically the issue\n```\nimport { call, put, takeEvery, all } from 'redux-saga/effects';\nimport axios from 'axios';\nimport jwt from 'jsonwebtoken';\nimport { port, host } from '../appConfig';\n// const getHomeState = state => state.home; const homeState = yield select(getHomeState);\nexport function* fetchData() {\n  try {\n    const token = jwt.sign({ exp: Math.floor(Date.now() / 1000) + (60 * 60) }, 'wrongrightwhatever');\n    let response = null;\n    if (port) {\n      const reqURL = http://${host}:${port}/api/data;\n      response = yield call(axios.get, reqURL, { headers: { authorization: token, 'Content-Type': 'application/json' } });\n    } else {\n      const reqURL = '/api/data';\n      response = yield call(axios.get, reqURL, { headers: { authorization: token, 'Content-Type': 'application/json' } });\n    }\n    console.log(response.data.msg); // sends the response message and shows up on the console\n    yield put({ type: 'FETCHED_JWT', data: response.data.msg });\n  } catch (err) {\n    console.log(err);\n  }\n}\nexport function* watchFetchData() {\n  yield takeEvery('FETCH_DATA', fetchData); // Take the 1st page data snapshots, draftdata from draftid\n}\nexport default function* rootSaga() {\n  yield all([\n    watchFetchData(),\n  ]);\n}\n```\nDo I need to run the saga dispatching action for sure on the client & server both because then the middleware router function is called like 3 times which I want to avoid\n. @yelouafi is it possible to handle errors of each call individually when doing it this way?. Hi, how are you?\nI am facing similar to error. \n\nmy code is:\nmport { take, call, put } from 'redux-saga/effects'\nimport Types from '../actions/ActionTypes'\nimport { loginSuccess, loginFailure } from '../actions/Creators'\nexport default (api) => {\n  function * worker (authData) {\n    const response = yield call(api.login, authData)\n    if (response.ok) {\n      if (response.data && response.data.status !== 'error') {\n        yield put(loginSuccess(response.data))\n      } else {\n        yield put(loginFailure(response.data))\n      }\n    } else {\n      yield put(loginFailure(response.data))\n    }\n  }\nfunction * watcher () {\n    while (true) {\n      const authData = yield take(Types.LOGIN_ATTEMPT)\n      yield call(worker, authData.user)\n    }\n  }\nreturn {\n    watcher,\n    worker\n  }\n}. I found that. \nThanks for your help.\nBest wished and regards.. @budarin @casertap I checked your code, turns out I am having the same problem as well.\nCould you please help me. The code I have presently is \nThis helps me render the server-side\n```\n/ eslint-disable import/no-unresolved /\nimport 'babel-polyfill';\nimport React from 'react';\nimport Helmet from 'react-helmet';\nimport { resolve } from 'path';\nimport { renderToString } from 'react-dom/server';\nimport { Provider } from 'react-redux';\nimport { StaticRouter, matchPath } from 'react-router-dom';\nimport sass from 'node-sass';\nimport serialize from 'serialize-javascript';\nimport { CookiesProvider } from 'react-cookie';\nimport routes from '../routes';\nimport App from '../containers/App';\nimport configureStore from '../redux/store';\nconst theme = sass.renderSync({\n  file: 'node_modules/grommet/scss/vanilla/index.scss',\n  includePaths: [resolve(__dirname, '../../node_modules')],\n  outputStyle: 'compressed',\n});\nconst renderFullPage = (html, preloadedState) => {\n  const head = Helmet.rewind();\n  let vendorJS = ''; let bundleCSS = ''; let bundleJS = '/bundle.js';\n  if (process.env.NODE_ENV !== 'development') {\n    const assets = require('../../webpack-assets.json');\n    bundleJS = assets.bundle.js;\n    bundleCSS = assets.bundle.css;\n    vendorJS = assets.vendor.js;\n  }\n  return <!DOCTYPE html>\n    <html ${head.htmlAttributes.toString()}>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta httpEquiv=\"x-ua-compatible\" content=\"ie=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\" />\n        ${head.title.toString()}\n        ${head.base.toString()}\n        ${head.meta.toString()}\n        ${head.link.toString()}\n        <link rel=\"stylesheet\" type=\"text/css\" href=${bundleCSS}>\n        <style>${theme.css}</style>\n      </head>\n      <body>\n        <div id=\"app-container\">${html}</div>\n        <script>window.__PRELOADED_STATE__ = ${serialize(preloadedState, { isJSON: true })}</script>\n        <script src=${vendorJS}></script>\n        <script src=${bundleJS}></script>\n      </body>\n    </html>;\n};\nfunction serverRender(req, res) {\n  const store = configureStore();\n  const loadRouteData = () => {\n    const promises = [];\n    routes.some((route) => {\n      const match = matchPath(req.url, route);\n      if (match && route.loadData) promises.push(route.loadData(store.dispatch, match.params));\n      return match;\n    });\n    return Promise.all(promises);\n  };\n  loadRouteData().then(() => {\n    const context = {};\n    const componentStr = renderToString(\n      \n\n\n\n\n\n);\n    if (context.url) {\n      res.status(301).setHeader('Location', context.url);\n      res.end();\n      return;\n    }\n    const status = context.status === '404' ? 404 : 200;\n    console.log('rendering now');\n    res.status(status).send(renderFullPage(componentStr, store.getState()));\n  }).catch((err) => {\n    res.status(404).send('Not Found :(');\n    console.error(==> \ud83d\ude2d  Rendering routes error: ${err});\n  });\n}\nmodule.exports = serverRender;\n```\nThe problem is I have a function that is loading from the server-side through routes more like a prefetch \n```\nimport Home from './containers/Home';\nimport { fetchData } from './containers/App/action';\nimport NotFound from './containers/NotFound';\nexport default [\n  {\n    path: '/',\n    component: Home,\n    exact: true,\n    loadData: dispatch => Promise.all([\n      dispatch(fetchData()),\n    ]),\n  },\n  {\n    path: '*',\n    component: NotFound,\n  },\n];\nInside my `store.js`\nimport 'babel-polyfill';\nimport createSagaMiddleware from 'redux-saga';\nimport { createStore, compose, applyMiddleware } from 'redux';\nimport rootReducer from './reducers';\nimport rootSaga from './sagas';\nconst composeEnhancers = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && window.REDUX_DEVTOOLS_EXTENSION_COMPOSE ? window.REDUX_DEVTOOLS_EXTENSION_COMPOSE : compose;\nexport default (initState) => {\n  const sagaMiddleware = createSagaMiddleware();\n  const store = createStore(\n    rootReducer,\n    initState,\n    composeEnhancers(applyMiddleware(sagaMiddleware)),\n  );\n  sagaMiddleware.run(rootSaga);\n  return store;\n};\n```\nNow on console.log I can see that the sequence of the operations are \n1) sagaMiddleware.run\n2) loadData is being called\n3) server renders\n4) Asynchronous API call from the loadData() is executed\nI want to wait the render till my saga is resolved\nI have tried the example here with all the necessary steps from Redux saga server-render example\nBut could not make it wait. Could you please help?\nThanks,\nRahul\n. looking forward to help guys, desperately. Can anyone please explain how this part works as I am not able to get this to work:\nrequest[CANCEL] = () => source.cancel()\nFrom what I can understand with axios, calling source.cancel() will cancel the request. And from my saga understanding, cancelling a saga will call this method:\n```\nfunction cancel(task) {\n  (0, _utils.check)(task, _utils.is.notUndef, 'cancel(task): argument task is undefined');\n  if (!isForkedTask(task)) {\n    throw new Error('cancel(task): argument ' + task + ' is not a valid Task object \\n(HINT: if you are getting this errors in tests, consider using createMockTask from redux-saga/utils)');\n  }\nreturn effect(CANCEL, task);\n}\n``\nAnd this returns that CANCEL effect that we are referring in our helper. But I can't understand how this all is connected. How does arequestknow that CANCEL is returned from sagas and it should now callsource.cancel()`\n. That makes sense now. Thanks a lot :). I think I may have figured out what the problem was. I have a parent component that was displaying a  element if the state.isLoader was true, else it would render the component that dispatches FETCH_BOOK_REQUEST on componentWillMount().\nSo on dispatch of FETCH_BOOK_REQUEST, the loader is set to true, FETCH_BOOK_SUCCESS will be called and the loader is set to false. By doing so it triggers again componentWillMount(), ...\nSo is the best way to implement a loader per container? Or is there a better way to have a HOC with a Loader that can listen to a LoaderReducer? Or is this ill-advised?\n. Makes sense, thank you. @Andarist yes, in the end it did work (see the edited text). Though it's seems a bit hacky. I was wondering if there was a better way to do it.. @Andarist not if I use IO that is not redux. Then I get whatever that trigger delivers.  E.g. using redux-saga with alt. There I get the complex action definition back.. Fair enough. It will work for my use case. \nJust out of curiosity: what if the effect returns undefined? (I know, quite edge-case-y). The underlying problem is, that it is not easy to immediately understand the mechanism, especially for someone who is new to Sagas. We strive to keep our code easy. We also prefer to code our documentation instead of documenting our code. \nAnd while Saga helps a lot with that, and we are super happy with it. we are just not 100% happy with race for this particular usecase. It does do the job though, and a comment will explain. \n. I am not sure, tbh. Sorry for the rather unconstructive critique. \ud83d\ude1e \nI am relatively new to sagas and try to get all the concepts myself first. \nI am thinking to write a wrapper around race for this use case. But not sure if this is a good solution in general.. The error was that I did not yield :(. Upgraded to 0.15.3 and still getting the same error. Is there something specific to watch out here? Just uninstalled redux-saga and installed again to get the latest package.. No. I guess it wasn't mentioned anywhere in the tutorials. I tried that in previous version thinking I needed to import it, but all wasn't available then. Importing all fixes things. Thanks!. My bad, wasn't looking in the catch block for errors. The issue was that initially I was passing the entire action and later the params were extracted, but the API call was not modified to factor that in. I was expecting API call to be made with even undefined params if that was the case, but it actually landed in the catch block. We can close this ticket. . Thanks a lot for the quick response. Getting the params was main issue and this fixes my case. . I can confirm this behavior. It might be related to connected-react-router. Given code\n```\nimport { push } from 'connected-react-router';\nimport { put } from 'redux-saga/effects';\nfunction *navigateTask() {\n    yield put(push('/path'))\n}\n```\nthe action push('/path') is logged into Redux debugger, but it is not intercept by connected-react-router/middleware.. @Andarist don't get me wrong, I have also lot thinks to do, just wanted to mention, that I have similar problem and I wanted to provide more information.\nMeanwhile, I've realized, that my problem was caused by window.__REDUX_DEVTOOLS_EXTENSION__, I've applied it as ordinary middleware, which, as turns out, is only meant to work when you do not have any other middleware. It might be recent bug, but window.__REDUX_DEVTOOLS_EXTENSION__ wrapped my actions onto another action object, which broken resolving by action.type. For multiple middleware scenario, I used window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ as described here and now connected-react-router works with redux-saga@1.0.0 correctly.. @JacquesBonet I've attached my own middleware just above connected-react-router to observe actions passed to it, you can try it also, the simple log middleware is\napplyMiddleware(_ => next => action => (console.log('MIDDLEWARE ACTION', action), next(action)))\nand you will see if the actions are not the cause\nalso, quite common problem in my codebase was deprecation of yielding multiple effects as array yield [put(...), put(...)], you must now use all effect like yield all([...]). But without isolated example as @Andarist suggested, all my advices are only blind shots.. ",
    "hoschi": "Here is my try to get HMR working with sagas. Time traveling doesn't work. Feedback is greatly appreciated :)\nhttps://gist.github.com/hoschi/6538249ad079116840825e20c48f1690\n. @yelouafi thanks for the warning that problems occure with spawn effects :+1: I add a note to my code repo for my team members.\nYour idea with replaying an event log sounds interresting, but has this approach the same problem with serializing things discussed already? This ist just something which cames to my mind when thinking about it, I have no deep knowledge about saga/effects, yet.\n. It is OK when the hell breaks loose and nothing works at this moment in the browser. I just want to send as much information as I can before this error to a logging service to:\n- know I have a bug\n- get information about the bug\nWhen the solution of @pavelkornev catches the error before the logger in proc.js, this is the \"good enough\" solution for my use case.\nInitially I thought it would be more complicated to catch these kind of errors and I wanted to reuse the existing code of proc.js, but replace console.log with sendToBackendLogger. Perhaps this was confusing.\n. This works in the way mentioned, but good enough for me, thanks. \n. This would help :)\n. ",
    "inyono": "Nice, thanks :+1: \n. Yeah, that was also the workaround we did in this case. But there could be problems somewhere else, when there is no implicit delay introduced by the user. So do redux-saga's watchers implicitly require a very short delay between actions? Just so that we don't run into an issue later.\n. Thanks for the clarification.\n\nIMO; it's more than a workaround; whenever I dispatch multiple actions synchronously; then it feels (still IMO) like a code smell. If I have all the user/server/... input at a given moment, I should dispatch the whole input as one batch to the store.\n\nIn this case, you are definitely right. But what about when the action is not dispatched because of a user input but, for example, by a saga. So maybe (I have no use case for this, yet, so everything a little theoretical) my saga dispatches CREATE_ASSET_REQUEST_SUCCESS and I have a watcher that listens for this action (for whatever reason ;) ). Then I couldn't be sure that there is a delay between two actions. Not sure, if this could even be a valid use case and if it isn't covered by your last paragraph anyway...\n. Okay, thanks!\n. Cool :+1: \n. ",
    "voodoods": "In addition: Binding the class Object itself with yield call(MyClass.myMethod.bind(MyClass)) seems to preserve the this context as well, even though apply should be the solution of choice. . ",
    "murtraja": "using arrow functions instead of methods also does the trick\nfor example:\nconvert this code\nexport default class API {\n  fetch() {\n    console.log(this);\n  }\n}\nto this\nexport default class API {\n  fetch = () => {\n    console.log(this);\n  }\n}. ",
    "rayd": "Ah, awesome! Thanks so much for the quick response. That makes a lot of sense.\n. Ah ok, thank you very much for the quick answer. This clears things up a lot.\nI think using a \"wrapped spawn\" and \"wrapped takeEvery\"\n``` javascript\nfunction* wrap(saga, ...args) {\n    const reportError = yield select(getReporter);\n    const task = yield spawn(saga, ...args);\n    task.done.catch(reportError);\n    return task;\n}\nexport function spawnWrapped(saga, ...args) {\n    return call(wrap, saga, ...args);\n}\nexport function takeEveryWrapped(pattern, saga, ...args) {\n    /eslint-disable no-constant-condition*/\n    while (true) {\n        const action = yield take(pattern);\n        yield spawnWrapped(saga, ...args.concat(action));\n    }\n}\n```\nwill work best for me. I'm using the \"while true, take and fork\" pattern quite a bit in my code and any uncaught error (perhaps due to an unexpected null value in state for example) in the fork part will kill that whole saga, which is not what I want. So I think using the wrapped spawn insulates me from these uncaught errors without entirely swallowing them (i.e. they're reported and I can address them now).\n. ",
    "KamuelaFranco": "Can this go in the docs? Please?. ",
    "worc": "this doesn't work if you're running mocha/chai synchronously. iterator.throw('error') itself causes the error Error: the string \"error\" was thrown, throw an Error :)\n. this doesn't work if you're running mocha/chai synchronously. iterator.throw('error') itself causes the error Error: the string \"error\" was thrown, throw an Error :)\n. with that e is still undefined in the catch block. . with that e is still undefined in the catch block. . ",
    "eelfonik": "@worc \nJust use iterator.throw(new Error('error')). ",
    "nhusher": "It occurs to me that I should be using the built-in exception system:\n``` js\nfunction* createAudienceSaga (getState) {\n  let action, cancelLastAudienceBuild = () => {};\n// When a new audience create action comes along, cancel the previous one\n  // by resolving the currently-active promise. We're using a promise here\n  // so that race(...) calls can be our mechanism for determining cancelation\n  /eslint no-cond-assign:0 /\n  while (action = yield take(CREATE_AUDIENCE)) {\n    cancelLastAudienceBuild(new TransactionCancelledError());\nlet transaction = new Promise((_, reject) => cancelLastAudienceBuild = reject);\n\nyield fork(buildAudience, transaction, action.payload);\n\n}\n}\n// Create a new audience\nfunction* buildAudienceFromPlaceId(tx, params) {\n  try {\n    let [place] = yield [call(api.places.get, id), tx];\n    yield put(showPlace(place));\nconst [ audienceId ] = [\n  call(createAudienceWithDefinition, {\n    definition: params.definition,\n    geography: [makePlaceGeography(place)],\n    product_id: params.product\n  }), tx ];\n\nconst [ audience ] = yield [call(api.audience.get, audienceId), tx ];\n\nyield put(showAudience(audience));\n\n} catch (e) {\n    if (e instanceof TransactionCancelledError) {\n      console.info(\"Transaction cancelled\", id, product);\n      return;\n    } else {\n      throw e;\n    }\n  }\n}\n```\nThis resolves the issue to my satisfaction.\n. Thanks! I'll give this a look over and attempt to grok it.\n. I ended up taking your higher-order function and making it lower-order. This makes it easier to test:\n``` js\nexport function* guard(tx, ...args) {\n  const { result } = yield race({\n    result: call(...args),\n    tx\n  });\nif(result) {\n    return result;\n  } else {\n    throw new TransactionCancelledError();\n  }\n}\n```\njs\n// Create a new audience from a place and product id\nexport function* buildAudienceFromPlaceId(tx, id, product) {\n  try {\n    // Step 1: retrieve the place that the user wants to build the audience in\n    let place = yield call(guard, tx, api.places.get, id);\n    // ...\nIt obscures intent somewhat because the actual function being called is deep in the arguments list, but it makes the test very straightforward:\n``` js\nimport { guard } from 'wherever';\nlet tx = new Promise(() => {}),\n    iterator = buildAudienceFromPlaceId(tx);\nassert.deepEqual(\n    iterator.next().value,\n    call(guard, tx, api.places.get, placeId));\n```\n. I had also considered (but have not tested) the following because it uses private values that might break:\n``` js\n// A saga that waits for CREATE_AUDIENCE actions and uses the data to construct and load a new audience:\nexport default function* createAudience (getState) {\n  let action, lastAction;\nwhile (action = yield take(CREATE_AUDIENCE)) {\n    if(lastAction && lastAction.isRunning()) {\n      lastAction._generator.throw(new TransactionCancelledError());\n    }\n    lastAction = yield fork(buildAudience, action.payload);\n  }\n}\n```\nNot sure what the implications of that are.\n. > I see, you can also define a higher order effect creator\nYeah. Again, it means peeling the function instance out of the iterator.next().value, which I'd rather avoid if possible. If I use a lower-order function, I can share the function more overtly between the application code and tests, at the cost of somewhat obscured intent. Either way has tradeoffs, and I might change my mind later.\n. The result of a higher-order function is always unique:\nfunction add(a) { return function(b) { return a + b; } }\nassert(add(5) === add(5)); // untrue, fails\nThis means that the call to guardedCall in the generator won't equal the equivalent call in the test.\n. Oh yeah. I knew that but wasn't really understanding what was going on. Concern retracted.\nThanks for all your help, by the way!\n. ",
    "mattmarcello": "I can achieve the desired functionality by wrapping the calls to take in generator functions, as follows:\n``` js\nfunction* waitForDashboardChange() {                                                                                                                                                                                                                                                \n  return yield take(DASHBOARD_LOAD_REQUEST);                                                                                                                                                                                                                                       \n}                                                                                                                                                                                                                                                                                    \nfunction* waitForExplicitLogout() {                                                                                                                                                                                                                                                \n  return yield take(LOGOUT);                                                                                                                                                                                                                                                       \n} \n```\nThen, the race becomes: \njs\n    const { explicitLogout, dashboardChange } = yield race({                                                                                                                                                                                                                          \n      dashboardChange: call(waitForDashboardChange),                                                                                                                                                                                                                                   \n      explicitLogout: call(waitForExplicitLogout),                                                                                                                                                                                                                                   \n    })\nIs this the intended API?\n. @yelouafi \nWould you say there is anything fundamentally wrong with wrapping the takes in functions as demonstrated above?  If not, would it make sense to document? \n. ",
    "cef62": "Thanks @yelouafi, happy to help! \nAfter you'll push a new version on npm services like npmcdn.com will be able to serve the library with url like https://npmcdn.com/redux-saga/lib/redux-saga.js.\nI'll let you know when the post is ready :)\n. I like the idea of better explain the term saga proposed by @slorber. A first good step could be to split the current readme in smaller docs and organize them. \nIf you like the idea of using gitbook I can prepare an initial setup to use it. I like the approach of redux where docs is available both as plain markdown files and as compiled gitbook.\nI could work on a PR tomorrow night.\n. Great @yelouafi! \n\nthere was an issue with docs:publish.\nI've run the script on OSX, I'll try to investigate what is different on windows and fix it.\n\nI think your draft for the TOC is good!\nNow we should improve and expand current contents.\nThis night I'll add more thoughts on the topic :)\n. Thanks! I really think this library is awesome and I'm trying to contribute to it as I can.\n. @philipchmalts I don't know if you already resolved the issue but for me it worked simply moving FsmIterator outside the redux-saga module declaration.. ",
    "aeneasr": "Doesn't this imply that synchronously incoming event's (e.g. two callbacks resolve at the same time, aka sequential in the cpu commands) have the same issue. I know that this is a highly unusual case but if you're serving millions of requests it's definitely something worth considering\n. thanks for clarification :+1: \n. ",
    "tgriesser": ":+1: \n. Excellent explanation and proposed solution!\n. Cool thanks for all that @yelouafi! \nDo you still think on is something you'll consider adding for the case of a stateless while(true)?\n. Oh of course! Looks great, thanks!\n. I had this issue as well, I ended up changing my root saga to yield an array and that took care of things. For the the example above, it'd be:\njs\nexport default function *root(getState) {\n  yield [\n     fork(watchProfilesPage),\n     fork(watchPaymentsPage)\n  ]\n}\n. Something like https://github.com/bjyoungblood/es6-error\n. Yep that definitely does work, I think I missed that the createSagaMiddleware could be called without any arguments before calling sagaMiddleware.run. Excellent solution / API!\n. Do you think it'd also be possible to detect missing yield for effect?\njs\nvar x = effect(asyncFunc)\nRather than\njs\nvar x = yield effect(asyncFunc)\n. Yep, that's exactly what I'm looking for.\n. ",
    "cherta": "I think you are right @yelouafi. it uses an enhancer.\nHere is the store setup, please let me know if you need anything else:\n``` javascript\nimport { createStore, compose, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\nimport { persistState } from 'redux-devtools'\nimport { reduxReactRouter } from 'redux-router'\nimport { createHistory } from 'history'\nimport DevTools from '../containers/DevTools'\nimport rootReducer from '../reducers'\nimport rootSaga from '../sagas'\nimport sagaMiddleware from 'redux-saga'\n//store/configureStore.js\nexport default function configureStore(initialState) {\nlet finalCreateStore = null\nif(process.env.NODE_ENV === 'development') {\n    finalCreateStore = compose(\n      applyMiddleware(\n        thunk,\n        sagaMiddleware(rootSaga)\n      ),\n      reduxReactRouter({\n        createHistory: createHistory\n      }),\n      // Lets you write ?debug_session= in address bar to persist debug sessions\n      persistState(window.location.href.match(/[?&]debug_session=([^&]+)\\b/)),\n      DevTools.instrument()\n    )(createStore)\n  } else {\n    finalCreateStore = compose(\n      applyMiddleware(\n        thunk,\n        sagaMiddleware(rootSaga)\n      ),\n      reduxReactRouter({\n        createHistory: createHistory\n      })\n    )(createStore)\n  }\nreturn finalCreateStore(rootReducer, initialState)\n}\n``\n. Thanks @mjrussell, I triedredux-simple-routersome time ago but ended up not using it because the little information the change event had, I can now give it another shot now that I understand the differences in more depth.\n. Great @mjrussell! I'll give it a try then, you convinced me :smiley: \n. Sure thing!\n. Hey @slorber thanks for jumping in, I think what you are describing is exactly what @mjrussell and I wanted to do, dispatch an action,takeit inside a saga and only thenpush` the url change. That was also my original idea and why I wanted to make it play with react redux.\nWhat you describe can be done with or without the redux routing components, the interesting part of having a router that plays nice with redux is that you gain actions that you can reduce or -in this case- create effect after them.\nJust as a follow up I'm preparing a gist showing how I made it work with simple-react-redux both for user triggered actions and back/forward button support.\n. Hey @mjrussell I did a follow up on this and came out with a solution using redux simple router, probably not the best one out there but a decent one I think.\nhttps://gist.github.com/cherta/6e2890b3dc561dcc6a58\n. You are welcome @mjrussell, please if you have the time I would like to see a different approach than mine!\n. I like the idea! I think people learn by example, so if we can put together some cook book it will be awesome, I guess it similar to what @yelouafi says on point 5.\nJust for future reference I posted an article of how I solved a particular issue with router, I guess is mostly the same I mentioned on #37.\nCount on me to create some of this docs.\n. > The main difficulty I'm encountering now (to write a tutorial) is how to introduce things one by one, even a simple Counter example needs multiple concepts at once (Declarative Effects, the event pull concept, forking if we need to provide a correct example)\nIs there a need to explain things one by one? I think is a better approach to show a problem explain one thing then upgrade the example. I guess a tutorial can push explaining declarative effects until it shows how to write test, on that scenario declarative effects make sense and it is more likely a person understands the concept that way.\n. Hello @prashaantt, as @mjrussell says you can listen to any action on a saga using take, I was facing the same problem (I guess) and it was discussed on #37. Basically redux-router eats the actions before they can be handled by sagas middleware, simple-redux-router doesn't so I came up with an example on #37 on how I solved it.\nLet me know if you need some more guidance.\n. Thanks for the answers, I think both are good options, I do like more explicit APIs instead of filters, having worked a lot with rails I tend to think filters lead a more obscure API design in favor of magically gaining the functionality. Anyway we are not more than 2 developers, I imagine if there were 5+ people filters can be an option.\nChanging the subject, do you know if there are any plans to add gitter or slack to the project? I think these type of questions belongs there and not here. Maybe @yelouafi wants to say something about that.\n. You are right @yelouafi I was missing that case, ex:\njavascript\nimport { dataLoaded, handleError } from '../actionCreators'\nexport function* dataRequested() {\n  let action = null\n  while(action = yield take('DATA_REQUESTED')) {\n    const result = yield callCheckingAuthentication(fetchData)\n    if(result.status === 200) {\n      yield put(dataLoaded(result.data))\n    } else {\n      yield put(handleError(result))\n    }\n  }\n}\nI think I can also try catch for errors but I don't like to handle business logic in catch blocks but that's my personal taste.\n. yeap, that would definitely work, I like that approach\n. Im not an expert @yelouafi but I won't mind change the way my apps instantiate the sagas because, as you said, I'm doing it only once per app. Nice explanation BTW.\n. ",
    "fusionstrings": "That worked like charm. Thanks a lot. Everyday I am learning new and awesome stuff about sagas. Best complement to Redux.\n. ",
    "romseguy": "Thank you! Looking forward to the apply version of cps.\nMeanwhile is it okay to listen to DOM events like this?\n``` javascript\nconst waitForEvent = (el, type) => new Promise(resolve => el.addEventListener(type, event => resolve(event)))\nfunction* listenToClick() {\n  while (true) {\n    const el = document.querySelector('.some-class')\nconst event = yield call(waitForEvent, 'click')\nyield put(someActionCreator(event))\n\n}\n}\n``\n. Thank you for 0.5.0 with improvedcps, it works fine for this issue's original use case, but I haven't managed to use it to wait for a DOM event, I getlistenToClick: uncaught MouseEvent`:\n``` javascript\nfunction* listenToClick() {\n  while (true) {\n    const el = document.querySelector('.some-class')\nconst event = yield cps([el, el.addEventListener], 'click')\nyield put(someActionCreator(event))\n\n}\n}\n```\n. Makes sense, thanks for the tips :+1: \n. FWIW I'm using https://github.com/blakeembrey/make-error-cause in my apps.\n. Adding\njavascript\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"development\"'\n      }\n    })\nworked like a charm, thank you. Might be useful to get a warning from the monitor when process.env.NODE_ENV !== 'development' then. I can open a PR if you like.\n. ",
    "floydwch": "Hi @yelouafi !\nThanks for your awesome work, but I have a question here: how to remove listeners in the automatically canceled race effects?\n. ",
    "iam-peekay": "@yelouafi yes, it is. thank you for getting back so quickly.\n. ",
    "d7laungani": "Where is the return statement missing and what should it be? I am having this exact same issue. Thanks!. ",
    "jkeihl": "Thanks!. ",
    "josebalius": "@yelouafi I was going to open another issue for a question very similar to this one, so I hope this is okay. Here is another case for testing\nfunction* watchDoSomething() {\n        while (true) {\n            const response = yield io.take(actions.DO_SOMETHING)\n            if(response.success) {\n                 yield io.fork(fetchSomething())\n            } else {\n                // do something else\n            }\n        }\n    }\nHow can I test that flow?\n. @yelouafi @aft-luke I may not know enough about the codebase, but I am making the assumption that call etc know when it is called from an iterator or not and that's how it decides to run the effect or return the description?\nWhat if somehow we could detect or a set a \"testing\" environment as true, or something similar, that would allow you to not only receive back the description of the effect, but also make that specific call() return a mock value that you could pass when running that effect? \nLike here run this effect, and return this mock value + plus the description of the effect. Some sort of test utils.\nI need to put some code together.\n. ",
    "dmitriykharchenko": "Looks like problem caused by the fact that there are different emitters and same dispatcher inside middleware and runSaga:\nmiddleware code:\n``` javascript\nexport default (...sagas) => ({getState, dispatch}) => {\nconst sagaEmitter = emitter()\nsagas.forEach( saga => {\n    proc(\n      saga(getState),\n      sagaEmitter.subscribe,\n      dispatch,\n      action => asap(() => dispatch(action)),\n      0,\n      saga.name\n    )\n  })\nreturn next => action => {\n    const result = next(action) // hit reducers\n    sagaEmitter.emit(action)\n    return result;\n  }\n}\n```\nstoreIO code, that creates subscribe/dispatch io for store:\n``` javascript\nexport function storeIO(store) {\nif(store[IO])\n    return store[IO]\nconst storeEmitter = emitter()\n  const _dispatch = store.dispatch\n  store.dispatch = action => {\n    const result = _dispatch(action)\n    storeEmitter.emit(action)\n    return result\n  }\n   store[IO] = {\n    subscribe: storeEmitter.subscribe,\n    dispatch : store.dispatch\n  }\nreturn store[IO]\n```\nBoth functions are taking dispatchers from store and creating new emitter for subscribe. So, saga called with runSaga can dispatch actions to store and all sagas from middleware will see it, but actions dispatched from middleware sagas can't be taken by saga called with runSaga\n. I believe this is the completely different case.\n@butchmarshall could you share the code?. ",
    "butchmarshall": "I still seem to be getting this in 0.15.4, v0.16.0 and v1.0.0-beta.0\nredux-api-middleware is dispatching actions that my reducer gets but my saga does not (both via takeEvery and race).. I just put together a minimal example - the kicker... it works as expected!  I'll keep investigating as to why it doesn't work in my full react app.\nIn my full app if i don't \"fork\" it works. I think i'll just not fork.\n```\nimport fetch from 'node-fetch';\nimport {createStore, applyMiddleware, compose, combineReducers} from \"redux\";\nimport createSagaMiddleware, { delay, END } from 'redux-saga';\nimport { apiMiddleware,CALL_API } from 'redux-api-middleware';\nimport { all, race, take, put, call, fork, select, takeEvery, takeLatest, takeFirst, actionChannel, cancelled, throttle } from 'redux-saga/effects';\n// Action\nfunction createAction() {\n    return {\n        [CALL_API]: {\n            endpoint: '/create',\n            fetch: () => {\n                return fetch(\"https://www.google.com\");\n            },\n            method: 'GET',\n            body: {},\n            types: [\n                {\n                    type: \"CREATING\",\n                    payload: {some_data_for_ui_update:1}\n                },\n                \"CREATED\",\n                \"CREATE_FAILED\",\n            ],\n        }\n    };\n}\n// Saga\nfunction * createActionResource(data) {\n    yield put(createAction());\n    yield call(delay,3000);\n}\nfunction * createActionSaga(action) {\n    yield fork(createActionResource, {});\n    //yield put(createAction());\nconsole.log(\"OK WAITING FOR RACE\");\n    const response = yield race({\n        success: take(\"CREATED\"),\n        fail: take(\"CREATE_FAILED\"),\n    });\nconsole.log(\"ANTYHING AFTER FORK???\", response);\n\n}\nexport function* watchCreateAction() {\n    yield takeEvery(\"CREATE_ACTION\", createActionSaga);\n}\nfunction * rootSaga() {\n    yield all([\n        watchCreateAction(),\n    ]);\n}\n// Reducer\nconst reducer = (state = {}, {type, payload}) => {\n    console.log(\"in reducer:\", type, payload);\nreturn state;\n\n}\nconst rootReducer = combineReducers({\n    reducer,\n});\n// Store\nconst sagaMiddleware = createSagaMiddleware();\nconst middlewares = [\n    apiMiddleware,\n    sagaMiddleware,\n];\nconst middlewareEnhancer = applyMiddleware(...middlewares);\nconst storeEnhancers = [middlewareEnhancer];\nconst composedEnhancer = compose(...storeEnhancers);\nconst store = createStore(\n    rootReducer,\n    undefined,\n    composedEnhancer\n);\nstore.runSaga = sagaMiddleware.run;\nstore.runSaga(rootSaga);\nstore.dispatch({\n    type: \"CREATE_ACTION\"\n});\n```. ",
    "ProphetDaniel": "\nSagas started with runSaga can't take actions from Saga started with the middleware\n\nIn the other hand, according to @butchmarshall 's example, reducers are able to take actions from the sagas started with the middleware.\nSo my workaround to this problem is to dispatch a new event triggered by the reducer capture so that the sagas started with runSaga can properly take them indirectly in a two step process. Just make sure this anti-pattern is avoided.. ",
    "wmertens": "Promise cancellation is still under discussion. Whatwg fetch (the next-gen xhr) is discussion cancellable fetching separate from promises here: https://github.com/whatwg/fetch/issues/27 (interesting but very long)\n. ",
    "emirotin": "It seems to be related for my problem though I'm not sure how to fix it.\nI have the following XHR API saga: http://pastebin.com/rpkiZzXv\nIt receives an XHR request config and issue the request, communicating the result to the reducer by dispatching different actions.\nNow I have an app with 2 pages (index and content). Both of them have the same sidebar, and the second page (content) also has a component in the page body. Both the sidebar and the component dispatch the API call actions. \nIf I first go to index I see the sidebar API request dispatched, taken by the saga and executed. Then if I navigate to the content page I see the 2nd request properly dispatched and executed.\nBut if I directly visit the 2nd page, so that the 2 actions are dispatched almost simultaneously, the 2nd action is not taken by the saga. I see both actions properly dispatched through the redux chrome extension, but the 2nd one doesn't reach the saga code. Any hints?\n. The 2 actions are from the different components, so TBH I have no idea how can I coordinate them and if I want to (actually I know that I don't \u2014 they are completely unrelated, 2 independent requests for different pieces of data). For the same reason, it doesn't make sense to change the API (which I don't own) to handle these combined requests.\nCan you please give me a better idea what are \"synchronous\" actions and what would be \"asynchronous\" in that case? I really don't mind how things are called, the only thing I care about is that my middleware doesn't miss a single API request and that these requests can be dispatched independently. For now, it looks like I have to drop sagas here in favor of the custom middleware.\n. Thanks for your detailed response, I really appreciate it!\n\n\nFor now, it looks like I have to drop sagas here in favor of the custom middleware.\n\nThe project is still young and evolving (2 months). So you can't expect it to handle every possible use case yet. It can only evolve and mature by gathering feedback from developers and then handling reported issues through reusable and consistent solutions.\n\nSorry if I sound irritated here. It wasn't meant to criticize the project by any means. I really value how you listen to your users and look open to adapting the library behavior to real use-cases (that should be a pain to address side-effects issues for someone fascinated with FP I assume :)).\nI have a good understanding of promises and what you say makes sense. I should've actually considered the timeout/immediate trick myself.\n\nInitially I thought the above issue won't occur because of how event loop works as described above.\nRight, I had the same feeling that the two dispatches coming from different components should be separated by the event loop ticks.\n\nI think the actual problem here is the mental dissonance. Sagas are middleware and other middlewares are guaranteed to be called for every action dispatched. When one reads the saga code it looks like it will be the case as well, with just the code being suspended between the events. So one (me :)) imagines the unhandled actions queued until the saga unshifts them and executes.\nThinking about this how about this possible solution: a special saga kind (daemon) that declaratively defines its trigger:\n```\nfunction* callApi(getState, action) { ... }\nexport default const myDaemon = daemon(CALL_API , callApi)\n```\nThis will create a normal middleware that picks every CALL_API action and forks the callApi method.\nSuch kind of notation will also make the actual sagas code shorter as I always find myself writing\nfunction* myDaemon(getState) {\n  while (true) {\n    const action = take(CALL_API)\n    // do actual stuff here\n  }\n}\n. Update: setImmediate (Chrome has native implementation and in this case the library bails out) doesn't work for me. setTimeout or raf (https://www.npmjs.com/package/raf) work fine.\n. Just sharing my needs as the user: I care about 2 things:\n- not missing actions (its really hard for me to imagine the case where I really want the middleware to miss the action. If the events need debouncing (scroll events, for example) that should be addressed in the events source IMO. Redux actions in my understanding are intents that should not be missed\n- having the expressive, readable and manageable code\nSagas indeed have a steep learning curve, but I managed to grasp it quite quickly.\nThe biggest advantage I have is with complex flows like: after the API request X is done emit the socket event Y to get further updates for the resource, also subscribe to socket event Z and translate it to action T, as well as notify the store that it was assigned the subscription ID U so that we can later unsubscribe.\nSaga works really well here in terms of expressiveness and manageability.\nAs long as that saga is started I really don't care how it runs, I only want it to run forever and be fired on every action X.\nAs sagas already work here I've migrated the API middleware to saga as well. Again I want it to run as a daemon and I don't need any coordination of that - just run forever and issue API calls on each CALL_API intent action.\nI actually like the idea of channels. It could be even like that:\n```\nconst apiChannel = channel.fromStoreActions(CALL_API) // it can get the store from the wrapping middleware I think\n// const eventsChannel = channel.fromObservable()\n// const socketEventsChannel = channel.fromGenerator()\n// const thirdPartyServiceChannel = channel.fromCallback(service.sibscribe.bind(service, someArgs))\nexport default sagaFromChannel(channel, singleActionSaga)\n```\n\nA generic action queue can't determine in advance which action to keep or discard\n\nYeah, that's why I suggest the API where it declares in advance which action it depends on\nBut channels look more generic and flexible indeed. Though they add another level of abstraction\n. I like it :)\nOn Mon, Jan 25, 2016 at 5:42 PM Yassine Elouafi notifications@github.com\nwrote:\n\nActually I think we may need both solutions.\nThe daemon approach could serve many uses cases where all we're doing is\nreplicating the same behavior inside a main true. it also doesn't have the\nflaw of missing actions\nfunction* rootSaga() {\n// avoids state-less/logic-less while(true)\n  yield on('SOME_ACTION', handlerSaga)\n  ...\n}\nThe channel approach would serve for non trivial complex flow and also\nsolves the problem of missing actions\nand even daemon sagas instances can coordinate using a dedicated channel\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/50#issuecomment-174525952.\n. Great news, eager to try it :+1: \n. +1 for separate repo, minimalistic core API is good\nOn \u0421\u0440, 3 \u0444\u0435\u0432\u0440. 2016 \u0433. at 20:57 Yassine Elouafi notifications@github.com\nwrote:\n@tgriesser https://github.com/tgriesser with the new promise-less\nversion; on helper can be created like this\nfunction* on(actionType, workerSaga) {\n  while(true) {\n    const nextAction = yield take(actionType)\n    yield fork(workerSaga)\n  }\n}\n// start incrementAsync on each INCREMENT_ASYNCon(INCREMENT_ASYNC, incrementAsync)\nOther concurrency patterns can also be created (as discussed here #68\n(comment)\nhttps://github.com/yelouafi/redux-saga/issues/68#issuecomment-178086859)\nSo I'm not sure if an addition to the core is needed. Thinking of creating\na separate repo like redux-saga-contrib where we can gather multiple\nhelpers for different concurrencey patterns\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/50#issuecomment-179376628.\n. Thanks for the idea.\nredux-saga works well for the XHR middleware and for the general orchestration, that's why I tend to keep the socket stuff there as well\n\nSo now I have this:\n```\nfunction* listenToSocket(event, actionType) {\n  let promise\n  let resolveFn\n  const callback = (payload) => {\n    resolveFn(payload)\n  }\n  const unsibscribe = socket.subscribe(event, callback)\nwhile (true) {\n    promise = new Promise(resolve => {\n      resolveFn = resolve\n    })\n    const payload = yield promise\n    yield put({ type: actionType, payload })\n  }\n}\nfunction* subscribeSocket(getState) {\n  while (true) {\n    const nextAction = yield take(SUBSCRIBE_SOCKET)\n    const subscribeConfig = nextAction.payload\n    const { event, actionType } = subscribeConfig\n    yield fork(listenToSocket, event, actionType)\n  }\n}\n```\nWhich suprisingly works (insult towards my understanding of sagas, not your idea :)). But indeed looks less readable than a middleware that can call store.dispatch directly at any given time. I'd like to hear @yelouafi's opinion on this.\n. Thanks for your response. Indeed a very similar question, though I tried searching before asking and it didn't come. I like the concepts separation, will update my code.\n. @gajus this seems to only fire once for the given event?\nBut the purpose is to translate every occurrence of the event into an action.\n. Interesting, I was confused by .once.\nOn Fri, Jun 10, 2016 at 11:35 AM Gajus Kuizinas notifications@github.com\nwrote:\n\n@gajus https://github.com/gajus this seems to only fire once for the\ngiven event?\nBut the purpose is to translate every occurrence of the event into an\naction.\nBoth implementations that I have proposed fire for every event.\nWe have been using this in staging env for over a week now.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/51#issuecomment-225149759,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAgGCEiZwsyfz0wsoGOJr2tWCkJtdLWxks5qKT3agaJpZM4HKwvq\n.\n. Thanks for the clarification.\n. \n",
    "mxstbr": ":+1: Amazing work @yelouafi!\n. This is a really good showcase of a login flow with redux-saga: https://github.com/sotojuan/saga-login-flow\n. I gotta agree with @jzaefferer, the current introduction text doesn't explain what redux-saga is and why it's awesome very well.\nIt's great if you're familiar with all the related terminology and have used thunks before, but I don't think that most users will be in that group. You shouldn't need to have used redux-thunk to understand why sagas are awesome, they're awesome in their own right without being compared to redux-thunk too!\nWhat do you think about this? Specifically @jzaefferer, does this explain the idea better maybe?\n\nredux-saga is a library that aims to make asynchronous flows (e.g. data fetching) in react applications easier and better.\nThe mental model is that a saga is like a separate thread in your application that's solely responsible for asynchronousity. This thread can be started, paused and cancelled from the main application with normal redux actions, it has access to the full redux application state and it can dispatch redux actions as well.\nIt uses a soon-to-be-built-in JavaScript feature called Generators to make those asynchronous flows easy to read, write and test. (if you're not familiar with here are some introductory links) By doing so, these asynchronous flows look like your standard synchronous JavaScript code. (kind of like async/await, but generators have a few awesome features we need)\nYou might've used redux-thunk before to handle your data fetching. Contrary to redux thunk, you don't end up in callback hell, you can test your asynchronous flows easily and your actions stay pure.\n\nThis first introduces the solution and the problem, explains the mental model, explains the assumed technical familiarity and then compares it to redux-thunk for those who have used it, but doesn't necessitate the understanding of thunks or anything.\n. Submitted a PR for further discussions: #437.\nI don't expect it to be merged straight away, but it should be enough to kick off some exploration hopefully!\n. Thanks @yelouafi, if you have any comments I'll gladly update the PR so we can get a better introduction out!\n\nI'm not particularly proud of the current Section on Sagas; Either we should put content related to how Sagas work in the context of frontend/React apps, giving example with redux-saga; or at the very least we should put the links in the resources section. The point is that people are not required to go through the academic papers or backend specific content to start using the library.\n\nI agree, let's take a look at that in a separate issue/PR?\n. Updated with your feedback! Let me know what you think, I definitely think this is a lot clearer.\n. > The library is a redux middleware (although it can be used outside of Redux)\n:+1: Done\n\n[Optionally define what is Redux] a library which makes managing application state consistent and predictable\nredux without middleware can not perform side effects but only transform state inside reducers\n\nI don't think we should add this to the introductory text, I think assuming that people know redux is a fair assumption for a library called redux-saga that mentions it's a redux middleware\n. Awesome! \ud83c\udf89\n. Yeah, I kinda counted long lived transactions to side effects? I guess the terms aren't clear enough\u2026\n. > and another concern is about maintaining 2 repos\nYou could go with a monorepo with the two packages in the same repo! That'd solve the issue problem \n. ",
    "jbaxleyiii": "Awesome stuff @yelouafi! I love the explanation (both here and on twitter). Super informative \n. ",
    "andrewhickey": "Nice, thanks! Looking forward to trying this out\n. ",
    "jskz": "Thank you for the clarification and fix @yelouafi \n. ",
    "jedwards1211": "Here's an idea.  Fork a subtask that:\n- subscribes to the websocket events\n- enters a while loop that:\n  - yields a Promise that gets fulfilled with the next websocket message when it comes in\n  - yields a put for that message.\n- catches cancelation exceptions and unsubscribes when that happens\n. I have to say though, I wonder if redux-saga really provides a clear advantage for subscribing to things over a simple custom middleware that just dispatches the events/messages from a websocket/whatever as they arrive.  It seems like testing might be easier with redux-saga.  Does anyone else have an opinion on this?\n. ",
    "gajus": "@yelouafi I am probably overlooking something, but the solution that you have proposed looks to me over-engineered.\nWouldn't this achieve the same result?\n``` js\nfunction socketEventIterator (eventName) {\n    let resolveNextValue,\n        resolved;\nresolved = true;\n\nbridge.on(eventName, (event) => {\n    resolveNextValue(event);\n\n    resolved = true;\n});\n\nreturn () => {\n    if (!resolved) {\n        throw new Error('Iterator can be used by only one agent.');\n    }\n\n    resolved = false;\n\n    return new Promise((resolve) => {\n        resolveNextValue = resolve;\n    });\n};\n\n}\n```\nor even\njs\nfunction socketEventIterator (eventName) {\n    return new Promise((resolve) => {\n        bridge.once(eventName, (event) => {\n            resolve(event);\n        });\n    });\n}\n. > @gajus this seems to only fire once for the given event?\n\nBut the purpose is to translate every occurrence of the event into an action.\n\nBoth implementations that I have proposed fire for every event.\nWe have been using this in staging env for over a week now.\n. > Interesting, I was confused by .once.\nsocketEventIterator will be called every time the previous promise is resolved. Therefore, once binding will be created/ discarded upon each event.\nFor the record, we are using the first variation (because it is more performant than creating/ discarding an event listener upon each iteration). I haven't extensively tested the once approach beyond ensuring that it is passing all the test cases.\n. Related http://stackoverflow.com/questions/43834756/how-to-handle-multiple-interdependent-sagas-when-rendering-server-side. > @gajus I think you need to define a Iterable in your functions as below:\nThats a bad idea. A better option is Iterable<*, *, *>.. > [..] but it doesn't seem to resolve (MAINTAINERS_SUCCESS) [..]\nWhat do you mean by \"resolve\"?\nYou are stopping the saga after the first render:\njs\nrenderAppToString(store, renderProps);\nstore.close();\nAssuming you have a routine that is taking MAINTAINERS_SUCCESS, the saga will be stopped by the time it is issued.. I've asked a related question http://stackoverflow.com/questions/43834756/how-to-handle-multiple-interdependent-sagas-when-rendering-server-side. For the record, this is how I sorted the issue in my setup.\nhttp://stackoverflow.com/a/43839772/368691\n@Andarist can you please take a look at this solution and comment whether it makes sense?. > @gajus\nFrom what I see your watchNewSearchCriteria is puting GET_MOVIES synchronously on each [SET_GEOLOCATION, SET_DATE] so call(getMovies) should run just fine as store wont be closed (yet). Am I missing something?\nClarified the description of the problem on the stackoverflow.\nThe flow is:\n\nComponent componentWillMount dispatches GET_GEOLOCATION and GET_DATE.\nAn asynchronous saga completes execution of GET_GEOLOCATION|GET_DATE and dispatches SET_GEOLOCATION|SET_DATE.\n\nIt is then that GET_MOVIES is dispatched and by this time the saga is stopped.. Thats what I am using for all simple async actions:\n```js\n// @flow\nimport {\n  call,\n  put,\n  takeLatest\n} from 'redux-saga/effects';\nimport {\n  GraphqlError\n} from '../errors';\nimport type {\n  ActionType\n} from '../types';\ntype RequestRoutineType = (\n  eventName: string,\n  execute: (payload: P) => Promise,\n  setResult: (result: R) => ActionType<>,\n  setError: (error: string) => ActionType<>\n) => () => Generator<, , *>;\nconst createRequestRoutine: RequestRoutineType = function (\n  eventName,\n  execute,\n  setResult,\n  setError\n) {\n  return function () {\n    yield takeLatest(eventName, function (action) {\n      try {\n        const result = yield call(execute, action.payload);\n    yield put(setResult(result));\n  } catch (error) {\n    if (error instanceof GraphqlError) {\n      yield put(setError(error.message));\n    } else {\n      // eslint-disable-next-line no-console\n      console.error(error);\n\n      yield put(setError('An unknown error has occurred.'));\n    }\n  }\n});\n\n};\n};\nexport default createRequestRoutine;\n```. Thank you. Is there a way to filter out these logs at all? (e.g. in Chrome dev tools)\nI had to go to the source code and just delete the console.log logic.\n```js\nexport function log(level, message) {\n  var error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\nif (level === 'info') {\n    return;\n  }\n/eslint-disable no-console/\n  consolelevel;\n}\n```. > Is there a way to filter out these logs at all? (e.g. in Chrome dev tools)\n/^((?!has been cancelled).)*$/ as a filter. This is far from perfect though as it will filter out warnings too.. @Andarist Understood. I will comment on the respective issue/ PRs.. > https://github.com/gajus/gajus.com-blog/blob/master/posts/the-definitive-guide-to-the-javascript-generators/index.md ?\nThats correct. Sorry, didn't see the original notifications.. ",
    "sslotsky": "Maybe this is a dumb question, but would it also be possible to do this using an event channel? Here's some totally untested code to serve as an example, am I way off base here? \n``` javascript\nfunction socketEmitter(subject) {\n  return eventChannel(emitter => {\n    const channel = channel(subject)\n    channel.on('message', payload => {\n      emitter(payload)\n    })\nreturn () => {\n  channel.removeAllListeners('message')\n}\n\n})\n}\nfunction* listen(subject, actionType) {\n  const chan = yield call(socketEmitter, subject)\n  try {\n    while (true) {\n      let payload = yield take(chan)\n      yield put({ type: actionType, payload })\n    }\n  } finally {\n    if (yield cancelled())\n      chan.close()\n  }\n}\nfunction* subscribe(subject, getState) {\n  while (true) {\n    const nextAction = yield take(SUBSCRIBE_SOCKET)\n    const { subject, actionType } = nextAction.payload\n    const listenTask = yield fork(listen, subject, actionType)\n    const unsubscribed = yield take(UNSUBSCRIBE_SOCKET)\n    const { cancelledSubject } = unsubscribed.payload\n    if (cancelledSubject == subject)\n      yield cancel(listenTask) \n  }\n}\n``\n. For what it's worth, I got around to testing my code and it was almost correct. Here's a working version witheventChannel`\n``` javascript\nimport { eventChannel, takeEvery } from 'redux-saga'\nimport { take, call, put, fork, cancel, cancelled } from 'redux-saga/effects'\nimport socket, { channel } from './socket'\nimport * as actionTypes from './constants'\nfunction socketEmitter(subject) {\n  return eventChannel(emitter => {\n    socket.emit('track', subject)\n    const newChannel = channel(subject)\nnewChannel.on('tweets', tweets => {\n  emitter(tweets)\n})\n\nreturn () => {\n  newChannel.removeAllListeners('tweets')\n  socket.emit('untrack', subject)\n}\n\n})\n}\nfunction* listen(subject) {\n  const chan = yield call(socketEmitter, subject)\n  try {\n    while (true) {\n      let tweets = yield take(chan)\n      yield put({\n        type: actionTypes.TWEETS_RECEIVED,\n        subject,\n        tweets,\n        read: false\n      })\n    }\n  } finally {\n    if (yield cancelled())\n      chan.close()\n  }\n}\nfunction* subscribe(action) {\n  while (true) {\n    const listenTask = yield fork(listen, action.subject)\n    const unsubscribed = yield take(actionTypes.STOP_TRACKING)\n    if (action.subject == unsubscribed.subject)\n      yield cancel(listenTask) \n  }\n}\nfunction track() {\n  yield takeEvery(actionTypes.TRACK_SUBJECT, subscribe)\n}\nexport default track\n```\n. Thanks, I was attempting to take the easy option from the following advice:\nhttps://github.com/redux-saga/redux-saga/issues/1006#issuecomment-348142339\n\nplease report them here by creating a new issue or fix them in flow-typed repository.\n\nI realize this is old advice :smile: . ",
    "m-2k": "javascript\n  yield* takeEvery(actionTypes.TRACK_SUBJECT, subscribe)\n       ^. ",
    "skellock": "Yeah. All the right Babel transforms are working great. The code I'm running has lots of es6. This surprised me too. \nPerhaps React Native is using an older JavaScriptCore version on Android?\nI wonder if this fails on iOS 8 as well?  I think that predates es6 inclusion as well. Will test when I get back in front of my computer. \nI've seen a polyfill out there too for injecting Symbol globally too.  Of course, that feels wrong though. \n. Just checked on iOS 8.4.  Doesn't work there either unfortunately.\nhttps://kangax.github.io/compat-table/es6/\n. A ugly work-around for now uses this polyfill: https://github.com/medikoo/es6-symbol\nnpm install es6-symbol --save\nThen, in ./node_modules/react-saga/lib/index.js, on line 2 add this horrible hack: require('es6-symbol/implement').  Eep.  I feel dirty just typing that.\nWorks on iOS 8 and Android devices (4 and 6) now.\n. Unexpected indeed.  Symbol certainly seems different than the rest of the es6'isms.\nUntranspilable.  \nI'd be your Internet BFF if you'd replace Symbols with the something that ensured compat for these platforms. \nLemme know if I can test anything.  I'd be happy to.\n. Great point Terry.  More of an environmental issue than a redux-saga issue?  Lemme chase that lead.  Perhaps just modifying my .babelrc might be an easier way out?\n. I didn't have any luck with babel-polyfill.  Upon import it threw undefined is not a function (evaluating 'babelHelpers.typeof(window)').  Makes sense I guess.  There is no window.  \nI guess that's more for browser land?  Was worth a shot!\nSo I removed the hack from the redux-saga index.js file and I placed it in my entry point index.ios.js and index.android.js now have their line 1 say:\nimport 'es6-symbol/implement'\nWorks good so far.  Tested on ios 8 sim, ios 9 device, android 4.4 device, android 6.x device.\n. Cheers.  Thanks for the advice @yelouafi & @tappleby !\n. npm install es6-symbol --save\nindex.android.js & index.ios.js\nimport 'es6-symbol/implement'\nJust until either the React Native polyfill works or Symbols get removed from redux-saga.\n. Curious.  Thanks for sharing.  \nThe only mobile platform that currently supports Symbol is iOS 9+.  (actually that's not entirely true, I haven't tested all Androids, just a handful of old & new).  The missing Symbol is on iOS 8 as well.\nThe lightest way I've found to support this is to use the es6-symbol plugin from above.\nbabel-polyfill does more, but you still need to import it manually somewhere in your entry point.  I'm guessing you might have forgotten to do that step?  Which is why it will be failing on iOS 8 & Android.  (Just guessing, no disrespect meant).\nTruthfully, I find this all so complicated.  What really helped was reading this article:\nhttps://medium.com/@housecor/babel-6-cheat-sheet-7344f7936f2d\nSpecifically the section on \"Be Sure To Polyfill\".\nWe shouldn't need the monkeypatch to get it to work, but kudos:  you're a smarter & braver man than I.\n:+1: \n. You can turn it off in the predicate that powers your redux logger.\nconst predicate = (getState, { type }) => type !== 'EFFECT_TRIGGERED'\nconst logger = createLogger({ predicate })\nIn my own version, I have a blacklist of messages I dodge and use Ramda to filter them out.  Overkill?  Absolutely.  Works great. >:)\n. put.resolve() means your stack trace will be meaningful.\nPUT is a sneaky little guy.  You're giving a chance for the rest of the redux environment to react (lulz).  This means anything from connected components to reducers to selectors can bring down the house.\nWith put.resolve the inner stack trace shows you exactly who caused it.  With put, you have to wait until next tick and you go hunting for answers.\nMy vote (wait, are we even voting?) is for put.resolve to be the default put behaviour.  Breaking changes be damned.  I thought it always worked like that.  \ud83d\ude03 \nWhat I'm doing now is:\njs\nimport { put, take } from 'redux-saga/effects'\nconst dispatch = put.resolve // ignorance is bliss\nI know the naming is probably going to cause ya'll ulcers, but dispatching is exactly how I think of the behaviour.  Synchronous dispatching.\n. Oh wow.  You're right.  \nPreviously, in React Native, if I had an error in code path in a render() method of a connected component, and my saga did a PUT that would trigger a reducer to trigger a redraw, I'd get a gloriously irrelevant stack trace of redux-saga internals.\nNow, when I check... that's not happening anymore!\nJust checked on react-redux@5.x and 4.x, react-native@0.40 and 0.41.1, and redux@12.1 and 0.14.3.  Every combination works.\nWell then.\nMyth busted.\nYou enjoy your night.  I'm going drinking now.\n. Hey, going to throw this hail mary out there.\nAre you running remote debugging in React Native?  If so, turn that off for a sec.  Was chatting with a fella on Friday with the exact same problem.\n. I think this might be a Reactotron bug that we recently fixed.\nWe're monkeypatching (lulz) AsyncStorage so we can track it.  When we swizzled we forgot to return the promise.  So up above (where you work with AsyncStorage), you're yielding undefined. \ud83d\ude31 \nCan you update your reactotron-redux-saga and try again?  \nSorry about that!  Programming is hard.\nAlternatively, in your reactotron config, set this:  useReactNative({ asyncStorage: false }) to opt out.. ",
    "lukehedger": "A Symbol transform has now been added to the babel-preset-react-native in RN so should have support in an upcoming release\nEdit - this is now supported in 0.20\n. ",
    "peterlazar1993": "I still have this issue running react native v0.20 :( \n\n. ",
    "babbarankit": "I have used the line import 'es6-symbol/implement in index.android.js\nWhat could be the reason? \n. ",
    "ryyppy": "Not sure if this fits to this issue, but I can remember we looked in here for a solution... so we had also problems with symbols, after importing babel-polyfill we got it running on iOS, but not on Android.\nWe realized there was some issue in the redux-saga/util submodule, so we monkeypatched following code:\n``` javascript\nimport { fork } from 'redux-saga/effects';\nimport watchFetchComments from './watchFetchComments';\nimport watchFetchLikes from './watchFetchLikes';\nimport watchFetchSocialFeed from './watchFetchSocialFeed';\n// TODO this should be removed as soon as rn can handle\n// the weird is.func(it[Symbol.iterator]) thing\nimport { utils } from 'redux-saga';\nutils.is.iterator = function iterator(it) {\n  return it && utils.is.func(it.next);\n};\nexport default function* root(getState) {\n  //....\n}\n```\nNow we can use redux-saga on both platforms :-)\n. @skellock You are totally right, monkey-patching is probably the worst way to fix things, but for our use-case it worked out really well! We used version 0.8.2 in that time... I was very sure that the next minor patches will fix this issue (hence the TODO comment) ;-)\n@yelouafi Looking good, will try this out and probably deprecate my comment if everything works\n. I linked the related flow-typed issue and will hopefully start working on it soon!\nThe thing is, TypeScript definitions actually look very similar, but they sadly behave differently in very subtle ways, which makes them hard to convert... we will see how far I get :-)\n. Yeah. Progress is tracked in the linked flow-typed issue, but right now I am quite busy with other stuff :-/ ... not sure when I can create a first working PR\n. Sure, will do this as soon as possible... the thing is that flow cannot deal with these super generic interfaces (like strongly typed call() and such) ... and I only have a very raw scaffold\n. Man I am so sorry,... right now I have so many other tasks that I can't work on it properly.\nI was also waiting for some syntax enhancements of flow, since they also introduced named exports and other stuff lately.\nhttps://gist.github.com/ryyppy/23db18faba8e5e031b1f81adfc050eb9\nThis is what I wrote so far, but I already completely lost the track and would also probably pull in the newest progress of redux-saga as well.\n. Also a good thing about newest flow releases is that they completely reimplemented the union-evaluation, which will be very useful for this lib as well.\n. Hm, yeah generic Next values are problematic. \nTo get the full type-safetiness, you have to do some type refinement:\n``` javascript\nfunction mySaga(): Generator<, , > {\n  // I am expecting a string\n  // but yield type can't really be type checked, since they are dynamic\n  // other issue are that return type of yield are maybe type\n  const foo = yield call('something');\n// In the corresponding branches, flow\n  // will recognize the different types\n  // of foo \n  switch(typeof foo) {\n    case 'string':\n      console.log(foo.length);\n      break;\n    case 'number':\n      console.log(foo.toFixed(2));\n      break;\n    default:\n      console.log('meh');\n  }\n// Of course, also with if()\n  if (typeof foo === 'string') {\n    console.log(foo.length);\n  }\n}\nconst iter = mySaga();\niter.next('asdf');\niter.next(1);\n```\n. Here is a sound explanation of samgoldman why this is designed like this: https://github.com/facebook/flow/issues/2080\n. @tychota : if you are able to get something going, I can definitely do the review and testing for it :-) ... a few posts above is my gist to what I started... right now I build so much vim infrastructure for flow and I barely can find time for that right now\n. Short update: I feel confident now that I can publish the redux-saga libdefs latest in the end of this week. \nShort teaser: https://twitter.com/ryyppy/status/767470833472311297\n. ",
    "Junam": "Encountered the same issue with web-stomp over sockJs (react native) on android device, inspired by @yelouafi solution adding \nrequire(\"babel-polyfill\");\non the entry point js fixed it after few hours of digging the net.\nThanks a lot.. ",
    "lvgunst": "I had the same problem.\n```\nfunction *watchProfilesPage() {\n  while (true) {\n    console.log('listening for LOAD_PROFILES_PAGE actions');\n    const { payload } = yield take(actions.LOAD_PROFILES_PAGE);\n    console.log('LOAD_PROFILES_PAGE triggered');\n  }\n}\nfunction *watchPaymentsPage() {\n  while (true) {\n    console.log('listening for LOAD_PAYMENTS_PAGE actions');\n    const { payload } = yield take(actions.LOAD_PAYMENTS_PAGE);\n    console.log('LOAD_PAYMENTS_PAGE triggered');\n  }\n}\nexport default function *root(getState) {\n  yield fork(watchProfilesPage);\n  yield fork(watchPaymentsPage);\n}\n```\nIn both my ProfilesContainer and PaymentsContainer I have componentWillMount where these actions are triggered:\n// ProfilesContainer\ncomponentWillMount() {\n  console.log('trigger LOAD_PROFILES_PAGE');\n  this.props.dispatch(loadProfilesPage(this.props.filters));\n}\n// PaymentsContainer\ncomponentWillMount() {\n  console.log('trigger LOAD_PAYMENTS_PAGE');\n  this.props.dispatch(loadPaymentsPage(this.props.filters));\n}\nWhen my ProfilesContainer is active my console reads:\n\nlistening for LOAD_PROFILES_PAGE actions\ntrigger LOAD_PROFILES_PAGE\nlistening for LOAD_PAYMENTS_PAGE actions\n\nThe LOAD_PROFILES_PAGE action is successfully triggered and performed by the saga.\nBut when my PaymentsContainer is active my console reads:\n\nlistening for LOAD_PROFILES_PAGE actions\ntrigger LOAD_PAYMENTS_PAGE\nlistening for LOAD_PAYMENTS_PAGE actions\n\nThis time the seconds saga (LOAD_PAYMENTS_PAGE) is not listening on time to perform the LOAD_PAYMENTS_PAGE action.\nI had to change the componentWillMount of my PaymentsContainer to wait a tick:\n// PaymentsContainer\ncomponentWillMount() {\n  requestAnimationFrame(() => {\n    console.log('trigger LOAD_PAYMENTS_PAGE');\n    this.props.dispatch(loadPaymentsPage(this.props.filters));\n  });\n}\nConsole reads:\n\nlistening for LOAD_PROFILES_PAGE actions\nlistening for LOAD_PAYMENTS_PAGE actions\ntrigger LOAD_PAYMENTS_PAGE\nLOAD_PAYMENTS_PAGE triggered\n\nEdit. Thanks @yelouafi I will try to use the requestAnimationFrame on the render call for now.\n. No, these containers are route components. So only 1 container is active based on the active route. The thing is the second saga (watchPaymentsPage) is not listening when PaymentsContainer is triggering the action. Only the first registered saga (watchProfilesPage) is listening on time.\nrequestAnimationFrame solves this.\n. Installed 0.6.0 and it seems to fix the problem. No need to use yield [] or requestAnimationFrame()\nThank you @yelouafi!\n. ",
    "AriaFallah": "Just kidding. \n. Sagas are amazing\n. @braco not really sorry. I haven't worked on that project where I was using redux-saga in a while.\n. This has made me wonder that now that you're using map, throttle, or filter in your example, what differentiates sagas from streams?\nFrom my understanding, you have a synchronous actions pipeline:\n// actions\n---x---x---x---x---x---x---x---x--->\nand your sagas can fork off async actions off this main pipeline\n```\n---x---x---x---x---x---x---x---x---x---x---x---x---x---x--->\n                          | // take(someAction)           | // put (resultantAction)\n                          |                               |\n                          | _  _  _  _  _  _  _ _ _ |\n                        ^            ^          ^\n                        map      filter    throttle\n\n```\nand you can map, throttle, and filter before returning the new, transformed, action.\nIsn't this the same thing streams achieve? The only thing I can think of that's different is that sagas appear more synchronous like async/await, they are arguably more testable, and that sagas can be blocking.\nHowever, I'm very new to sagas, I'm very new to redux, and I'm very new to streams, so perhaps its my inexperience. @yelouafi could you help me see the differences between the two? \n. @slorber hmmm, but if that's the case why not use RxJs as it's a more mature and featureful library? What differentiates sagas from the alternatives that makes it the de facto \"preferred\" library for managing side effects?\nAlso to make it clear, I use and like using sagas. I just want to truly understand it's benefits.\n. @slorber Alright thanks for the perspective! I'm curious to see what he and @gaearon think about it as well.\n. @yelouafi wow great response; I've read it about three times now. I'm going to take some time to think about what you said, and then maybe I'll have some more questions :sweat_smile:\nDefinitely something you can put in the docs though. It was a great overview of sagas vs. other stuff.\n\nYour article also made me want to go more in depth on monads, which led me to this article, which led me to @slorber:\n\nsmall world :smile:\n. I have a question now that I've done a good amount of reading:\nAre sagas really an example of pull or do they just seem to be pull? For example, you used this code to demonstrate generators as observers:\n``` javascript\nfunction* logEvents() {\n  // wait for a value that will get passed as argument to next\n  while(true) {\n    const event = yield;\n    console.log(event)\n  }\n}\nconst observer = logEvents()\nobserver.next() // forward one step since w're not interested on yielded values\ndocument.addEventListener('click', observer.next.bind(observer))\n```\nIt's true that once you're inside the generator it seems like you've pulled the event synchronously, but haven't you in reality, behind the scenes, pushed the event to the generator by using an event listener?\nWithout having read the saga code, I assume you do something similar by taking advantage of how actions fall through the middleware. Something like\njavascript\n// Saga Middleware\nexport default (store) => (next) => (action) => {\n  pushToAllSagas(action)\n}\nthen inside a generator\njavascript\nfunction* saga() {\n  while(true) {\n     const event = take('click')\n     doSomething(event)\n  }\n}\nSo you push to your sagas and then your sagas can decide what to pull from that based on the names of the actions.\nGiven this, isn't the only difference between a stream and a saga that a stream\njavascript\n// result is an Observable\nresult = domElement.on('click')\nresult.forEach(eventData => doSomething(eventData) )\nis a functor (maybe also a monad? just learned what a monad is today so not sure) that wraps multiple actions, and a saga\njavascript\nfunction* saga() {\n  while(true) {\n     const event = take('click')\n     doSomething(event)\n  }\n}\nyields the individual actions?\nThus, sagas are very helpful when you want to finely manipulate individual actions, but streams would be better if you're trying to map functions to actions.\nDoes this make sense @yelouafi @slorber @gaearon ?\n. @yelouafi okay this has been an immense learning experience. Thank you! I'm going to read the source code for sagas now, and see how it all actually works. Once I've done that, I see if I could contribute to the docs.\n. @yelouafi awesome, glad I was right about the monad part, and I'll take a look at that article! \nAlso, as politely as possibly, I'd like to point out that sens is actually written sense. Hope you don't mind; I've been reading everything in this whole repository, and it's the only mistake you ever make.\n. @yelouafi I was thinking some more about this. Could you provide examples of how streams are bad at control flow? This seems to work: https://gist.github.com/tomkis1/8b3573ca9483d60c8b34, and I don't see a huge problem except that perhaps it looks a little unnatural.\nI think if eventually we were to put this into a section of the docs justifying the usage of generators (which people seem to think is convoluted) over streams, it'd be nice to see how streams aren't able to as easily achieve the same results as a generator.\n. ",
    "querie-cc": "@aft-luke I like the one-to-one comparison. Using a login example highlights the differences between redux-thunk and redux-saga quite well. \nI'm just starting out with redux-saga and getting familiar with it so I can't answer your first question.\nShould it appear in the docs? As a new user I think it would help to have a one-to-one example from redux-thunk considering most people using redux will be familiar with it.\nIf it would be a welcome addition, I wouldn't mind working on a PR to use gitbook for documentation. The cost would be harder upkeep of the docs (e.g. making sure these types of examples still work, etc). There is a certain beauty about keeping all the documentation in a single README.md, but by using something like gitbook these additional examples can be added in without worrying about bloat.\n. ",
    "danscan": "I'm new to redux-saga and checking out the Readme with no prior knowledge.  The one thing I'm really puzzled by is the difference between take, put, etc.  Even a bulleted list of the API methods with one-liners would be very helpful.\n. Not sure if this is the result of a transformation from babel-preset-react-native... \n\n. \nThis is what I'm passing to sagaMiddleware.  (I'm spreading that array)\n. That worked.  Thank you!\n. Ok\u2013 I missed this.  This should work for my use case.  My issue is that I\nwant to filter out the internal redux-saga actions in my logger, so it only\naffects me in dev.\nOn Mon, Apr 4, 2016 at 9:51 AM Yassine Elouafi notifications@github.com\nwrote:\n\nActually they are already exported from redux-saga/utils (see this example\nhttps://github.com/yelouafi/redux-saga/blob/master/examples/sagaMonitor/index.js#L5-L9\n).\nAlse note the actions are only fired on dev. mode not in production.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/yelouafi/redux-saga/pull/240#issuecomment-205303603\n\n-- Dan Scanlon\nSenior Software Engineer @ Tabtor\n267.373.8883\n. \n",
    "braco": "@yelouafi: what do you think of what @AriaFallah wrote, as a pattern? I too am put off by the repetitive boilerplate.\n@AriaFallah: do you have more complete code anywhere public? Would be interested in seeing how that developed.\n. ",
    "ryankask": "I found this issue after looking for solutions to reduce the amount boilerplate. For example, an API call like login \"needs\" three LOGIN_* actions, a login action creator, a login saga, and a login API utility function.\nI haven't spent much time abstracting this although I did write an API request saga factory that looks something like the code posted above.\nI'm eager to see what other users are doing.\n. Check out the release notes for v0.15.0. It mentions the new all effect. See also 7078c204a22.\nIf you're not yielding an array in your code, are you possibly using a third party package that is?. ",
    "jiayihu": "I had the same issue, so I just created a small gist with my own implementation of an action creator factory: https://gist.github.com/jiayihu/811f2dc704d6ce6308d679a987348b20\nCan be used as following:\njavascript\nexport const addInvoice = createAction('ADD_INVOICE', {\n  request: (invoice) => ({ invoice }),\n  success: (invoice, result) => ({ invoice, result }),\n});. I had the same issue, so I just created a small gist with my own implementation of an action creator factory: https://gist.github.com/jiayihu/811f2dc704d6ce6308d679a987348b20\nCan be used as following:\njavascript\nexport const addInvoice = createAction('ADD_INVOICE', {\n  request: (invoice) => ({ invoice }),\n  success: (invoice, result) => ({ invoice, result }),\n});. Sorry it was a Work In Progress actually \ud83d\ude05 There are also some other places in the docs where it's still used getState, so should I make a new commit instead of --amend right?\n. Sorry it was a Work In Progress actually \ud83d\ude05 There are also some other places in the docs where it's still used getState, so should I make a new commit instead of --amend right?\n. ",
    "antoinerey": "Thanks for this answer !\nThe solution you exposed worked fine, but looping over the full saga (even while hiding the assertions) is a concern for me. \nSo, I extracted this ...\njavascript\nif (response)\n  yield put(actions.checkoutSuccess(cart))\n} else {\n  yield put(actions.checkoutFailure(error))\n}\n... to a function, which is fully testable in its own, without loops.\n. ",
    "ForbesLindesay": "If you want the flexibility of things like watchLatest, you could implement them outside of saga:\njs\nfunction* mySaga(action) {\n  // ... business logic here ...\n}\nconst mySagaWrapped = createSaga(MY_ACTION_NAME, mySaga);\nlet lastSaga = null;\nexport default function (action) {\n  if (lastSaga) lastSaga.cancel();\n  return lastSaga = mySagaWrapped(action);\n};\nBut I can understand how that might start to get confusing.  With this in mind, I would propose codifying the separation.  Define two types \"Watchers\" and \"Sagas\".\n- Watchers should only be able to yield take, fork and cancel.  (maybe also put if that can be made consistently non-blocking).\n- Sagas should be able to access everything except take.\nAt the very least, your examples should all religiously enforce this separation, or you will just leave users with these subtle race conditions.\nAs for promises, you could have any non-blocking calls (e.g. take, fork and cancel) return plain values, and delay etc. can return promises.\n. Yes, using this lib as it currently stands would mean that a tiny mistake can result in subtle race conditions that are the kind of thing that take weeks to track down in large apps.\n. Yes, that's an interesting example.  Based on this, it's OK to call any blocking method, as long as it's racing against a take method.  You could support validating that still I suppose.\n. I think there are interesting ideas here, and if we can find ways to enforce that sagas are always \"safe\", it will be great.  As it stands, most examples in saga's own documentation contain race conditions. I think it is safe to say if the docs for a library contain race conditions, so will real world programmes that use that library.\nOne possible alternative solution, instead of:\n``` js\nimport { put, subscribe } from 'redux-saga'\n// sagas/index.js\nconst incrementAsync = subscribe(['INCREMENT_ASYNC'], function* (take) {\nwhile(true) {\n// wait for each INCREMENT_ASYNC action  \nconst nextAction = yield take()\n\n// delay is a sample function\n// return a Promise that resolves after (ms) milliseconds\nyield delay(1000)\n\n// dispatch INCREMENT_COUNTER\nyield put( increment() )\n\n}\n});\nexport default [incrementAsync]\n```\nYou explicitly specify up-font which action types you are interested in, which are then buffered until you take them.  I don't think this removes any of the flexibility you would want, but it prevents the current footgun.\n. ",
    "khankuan": "I did tried swapping the middleware but it seems to be the same hmm\n. Ah nvm, found the issue :/ mixed up compose and applyMiddleware..\n. ",
    "paul42": "I'd like to :+1: the 5 - example solutions for some common flows - I'm still just digging in and haven't done much more than a hello world for react and redux, so if it's not too much trouble the examples would help me the best. maybe even a 'hello world' example for people like myself who like to 'code along' and see it work. \n. sorry to digress from the current conversation, but as I'm reading the docs DeclarativeEffects what does cps stand for?\nThanks!\n-Paul\n. Ah, having worked with node I recognize now - I've started with node so I've only seen them referred to as 'node-style callbacks' and it's amusing to me. It couldn't hurt, but I would say it's not necessary - I was just more curious and mistakenly assumed it was some internal designation\n. interesting... so the root cause was different behavior because of node version, I'll have to go back and read the actual logic being tested to verify to understand why I got the {token: ... } stuff in there - what is the suggested resolution for this?\n. I'm a complete novice, but coming from backend programming I just want to say I like the saga model, and I would prefer it to thunk, even sacrificing simplicity of setup because I like the api around sagas. I feel that @wizardzloy does have a valid point that we can't see into and around and know who is calling what but I'm wondering if that's more of a tooling problem rather than anything - there was a very interesting .gif I saw from the cycle.js team (guy?) where he dispatched an action and it had a moving diagram I have zero clue how it was implemented/drawn but I think adding a visual component might help some people - rambling aside I wanted to underscore that I like the saga model and I think tooling can fix the proposed issue without modifying the base library. (redux-devtools-visual-map?)\n. ",
    "vire": "Do you think a transition guide from redux-thunk would be useful? Because I've started with thunks but they're hard to maintain when the app grows... (+hard to test)\n. @staltz I like your suggestion. Despite the fact I like saga as something special, your point is valid and it's acceptable for wider audience.\n. ",
    "nirrek": "\n5- Example solutions for some common flows (authorization, infinite scroll ...)\n\nIn this section I think it would be useful to show how to adapt event-based APIs for consumption inside sagas. Websockets, Firebase, Web Audio/Video etc. only expose EventEmitter-style APIs. Wrapping these to provide a pull-based interface that can be used in sagas will be a fairly common pattern.\n. ",
    "staltz": "I came here because of https://twitter.com/dan_abramov/status/696689725797769216 and would like to just point out one thing:\n\nAn alternative Side Effect model for Redux applications. Instead of dispatching thunks which get handled by the redux-thunk middleware, you create Sagas to gather all your Side Effects logic in a central place.\nThis means the logic of the application lives in 2 places:\n- Reducers are responsible for handling state transitions between actions\n- Sagas are responsible for orchestrating complex/asynchronous operations.\n  Sagas are created using Generator functions.\n\nAvoid heavy beginner-unfriendly jargon for the first text they will ever read. Drop \"saga\" (why not rename it to \"Redux coprocesses\"?), drop \"side effect model\", drop \"dispatching thunks\", drop \"redux-thunk middleware\".\nHere's a suggestion:\n\"Redux Coprocesses is a library for listening to actions, spawning background work, and dispatching results, ideal for HTTP requests and other side effects\"\nTrust me, I have experience explaining Cycle.js in a weird way (\"Honestly reactive framework for Human-Computer Interaction\"), I learned how to keep it dumb (\"Functional reactive JavaScript framework for cleaner code\").\nJust my cents, make your own mind about it :+1:\n. This is what my brain understands when I parse the word \"saga\":\n\nhttp://www.thefreedictionary.com/saga\n:)\n. ",
    "ngerritsen": "Would it be nice to have some kind of block diagram? Just to show where you could use saga's in Redux.\n. Seems valid. We use a requestSaga in our application which handles the request and it's status codes. We use that saga in multiple places and it works perfectly, plus it's testable.\n. @mjrussel I also requested that\n. ",
    "markerikson": "A side-by-side comparison of how you'd do something in thunks vs sagas would be helpful.  Also a description of why you would want to prefer sagas over thunks, and maybe even some bits on what generators are and how to use them.  I grok promises, and my team mostly understands them, but generators I'm still pretty confused on, and sagas doubly so.\n. ",
    "nickzarate": "Hey there @yelouafi I have a suggestion, what do you think about adding a section (even real short) about best practices using redux-saga? It could very well just be me (or maybe I missed it in the docs), but I am not 100% sure how to organize my sagas, for instance which sagas to dynamically call and which sagas to call at the beginning, and how to use sagas together. I read somewhere, and I can't find it again, where you mentioned a separation between worker sagas and watcher sagas, maybe elaborate a bit more on that? In terms of which to dynamically call, I'm wondering what is better, to start one saga and branch off from there? Or fire off all possible sagas at once? Or maybe a combination? Again, I might just be missing something here.\nEdit: Or maybe not best practices, but even something like Redux's \"Three Principles\" that could help shape best practices.\n. Oh ok, sorry I should have mentioned, I have actually tried that as well but when I use:\nobject = yield call(query.first())\nThe error is:\nError: call/cps/fork first argument must be a function, an array [context, function] or an object {context, fn}\nAlso, console.log(query.first()) logs a ParsePromise Object. Actually what I first tried was:\nyield call(query.first)\nbut then I got an error in the query.first function, because it tries to access this, which has the value of null. I realize this may be a Parse issue.\n. Wow, that works great, thank you so much! I will change the title in case anyone else has the same issue as this has nothing to do with jQuery compatible promises.\n. ",
    "guybenron": "Came here looking for best practices. I'd love to see the following in the revised docs:\n- Where should the line cross between reducers and sagas? I've seen two basic approaches: split responsibility according to some guideline (sync/async, UI/backend), or have the sagas handle everything and dispatch an updateState action for a dumb reducer to incorporate the new state into the store.\n- How should independent sagas initiate each other? For example, a login saga and an API fetch saga which runs post-login. Should the login saga put a fetchAPI action? Should the fetch saga take a loginSuccess action? Should there be a third saga responsible for this?\n. ",
    "bradennapier": "Ahh, shortly after this I did find a post about it and was able to make this work.  I think this would belong in the documentation somewhere as it's likely a common need.  Perhaps even some sort of pattern officially supported may be nice?\nAnyway, not sure I did it in the best manner possible, but here is the working results for anyone whom it may help:\nHow It Works: It listens to global paths once an account has been authenticated.  It doesn't do anything with the response yet but the idea is to listen to data that is needed anywhere the user is on the app and handle the logic based on the data received from Firebase.  It returns the getNext and the listenerID (which is used to cancel the callback if needed for some reason).  \nRace is used to allow for cancelling by listening for a cancellation action and seeing if the paths match.  Probably will need to enhance that a bit.\nAwesome Stuff!\n```\nfunction registerListenerPromised(ref) {\n  var listener\n  const listenerID = ref.on('value', snapshot => {\n    if (listener) {\n      listener.on(snapshot.val())\n      listener = null\n    }\n  })\nreturn {\n    listenerID,\n    getData() {\n      if(!listener) {\n        listener = {}\n        listener.promise =\n          new Promise(response => listener.on = response)\n      }\n      return listener.promise\n    }\n  }\n}\nfunction* onFirebaseData(accountRef, path, getState) {\n  const localRef = accountRef.child(path)\n  const { getData, listenerID } = yield call(registerListenerPromised, localRef)\n  // set this to false at any time to cancel this listener\n  var active = true\n  while (active) {\n    const {data, cancel} = yield race({\n      data: call(getData),\n      cancel: take(action => action.type === CANCEL_LISTENER && action.path === path)\n    })\n    if (cancel) { var active = false } else {\n      console.log('Received Data from Firebase Path!', path)\n      console.log(data)\n    }\n  }\n  console.log('Cancelling Firebase Listener at Path: ', path)\n  localRef.off(listenerID)\n}\nfunction* setupGlobalListeners(getFirebaseRef, getState) {\n  const accountRef = getFirebaseRef()\n// We can't use options like forEach and map in generators\n  for (let i in GLOBAL_PATHS) {\n    const path = GLOBAL_PATHS[i]\n    yield fork( onFirebaseData, accountRef, path, getState )\n  }\n}\nfunction* waitForAuth(getFirebaseRef, getState) {\n  // We must wait for the firebase account to be authenticated elsewhere\n  yield take(ACCOUNT_READY)\n  yield fork(setupGlobalListeners, getFirebaseRef, getState)\n}\nexport default function* root(getState) {\n  const getFirebaseRef = () => getState().auth.firebase\n  yield fork(waitForAuth, getFirebaseRef, getState)\n}\n```\nFeel free to let me know if I made any mistakes, still learning this pattern but reminds me of good ol' coroutines from tcl days.\n. Cool, this is opening a lot of options with sagas!  Here is another example where we can make a promise resolve with an error  as well as utilizing the HTML5 GeoLocation API and a little bit different styling of promise handling\n```\nfunction userPositionPromised() {\n  const position = {}\n  if (navigator.geolocation) {\n    navigator.geolocation.getCurrentPosition (\n      location  => position.on({location}),\n      error     => position.on({error}),\n      { enableHighAccuracy: true }\n    )\n  }\n  return { getLocation: () => new Promise(location => position.on = location) }\n}\nfunction* getUserLocation() {\n  const { getLocation } = yield call(userPositionPromised)\n  const { error, location } = yield call(getLocation)\n  if (error) {\n    console.log('Failed to get user position!', error)\n  } else {\n    console.log('Received User Location', location)\n  }\n}\nexport default function* root(getState) {\n  // Fork each required daemon on startup, for now only one\n  yield fork(getUserLocation)\n}\n```\n. Thank you!  So I spent the entire day playing with this just to see what might come out of it.  I really like this pattern.  In my mind one thing that is needed is a better way to handle asynchronous events as discussed.  This provides a way to do it but can be cumbersome if doing often, so I wanted to try to create a pattern which could help to automate this a bit... I am no pro at javascript but I do generally have a grip on coroutine-style programming.\nI am sure I am doing a lot of things completely wrong here, but the end result seems to be a pattern which is re-useable and very easy to work with.  It's a lot to read, but it seems to be a good start - would like an honest opinion if possible and would be happy to share more of it if desired:\n```\nfunction* waitForAuth(getState) {\n  while (true) {\n    yield take(ACCOUNT_READY)\n    yield fork(setupGlobalListeners, getState)\n  }\n}\nexport default function* root(getState) {\n  yield fork(waitForAuth, getState)\n}\n```\nSimple enough, I await the action telling me the authentication is available...\n```\nfunction* setupGlobalListeners(getState) {\n  const accountRef = getState().auth.firebase\n  const globalKeys = Object.keys(GLOBAL_LISTENERS)\nfor (let key of globalKeys) {\n    const { path, types } = GLOBAL_LISTENERS[key]\n    const Saga = new SagaState(path, getState)\n    yield fork(generateObserver, Saga)\n  }\n}\n```\nI am using classes to generate a react-like pattern for handling redux actions and only dispatching properly handled data to the store...\nfunction* generateObserver(Saga) {\n  console.log('Process Saga!', Saga)\n  var cancel, saga\n  while(!cancel) {\n    ({saga, cancel} = yield race({\n      saga:     apply(Saga, Saga.sagaShouldMount),\n      cancel:  apply(Saga, Saga.__checkStatics__)\n    }))\n  }\n  console.log('Done')\n}\nI am attempting to provide cancel however at this time the cancel does not appear to work as desired.\nHere's the look at what an instance of SagaClass looks like:\n```\n@onStore('firebase')\nclass Example extends SagaState {\nstatic cancelTypes = [\n    'CANCEL_SAGACLASS'\n  ];\nstatic monitorTypes = [\n    'FIREBASE_UPDATED'\n  ];\nshouldSagaCancel(action) {\n    console.log('Should I Cancel?')\n    console.log(action)\n    return true\n  }\nonMonitoredType(action) {\n    console.log('Monitor Executed!  This shows listening for an action and responding, in this case when the firebase is updated by the observer')\n    console.log('Action: ', action)\n  }\nasync observer() {\n    const { getNext, on } = this.createObservable('firebase')\n    const ref = this.getStore().ref.child('unadopted')\n    const observerID = ref.on('value', on)\nwhile (!this.cancel) {\n  const data = await getNext()\n  this.dispatch({type: 'FIREBASE_UPDATED', data: data.val() })\n}\nref.off('value', observerID)\n\n}\n\nsagaRender() {\n    this.observer()\n    yield take(action => action.type === 'LOGOUT_CLEAR_TOKEN')\n    this.dispatch({type: 'GOODBYE!'})\n  }\n\n}\nexport default Example\n```\nSo there's more to this but I thought I would just post the example... essentially this does a few things...  Keeping in mind I took all the extra logic out of handling the data in this case since it would muddy up the example with firebase-specific logic...\n1. You define in the decorator what part of the state this class will be responsible for.  You receive this.getStore() which allows you to get that part of the store at any point in time.  My goal would be to somehow restrict this in a way there are less side effects.\n2. You define two statics, if desired... cancelTypes and monitorTypes - these allow you to define actions that you want to receive whenever they occur. In both cases the action is given as an argument.  You can define multiple types in the array.\ncancelTypes:  With cancelTypes the \"shouldSagaCancel\" is called and you return true or false with true resulting in the termination of the observer.  In the example, the SagaClass will be cancelled upon the first time any of the cancel types are received.\nmonitorTypes: With monitorTypes you receive these in \"onMonitoredType\" and can handle this in any way you desire.\n1. We move outside of redux-saga in some parts but redux-saga is still controlling everything.  For example, we can have redux-saga do a put(ACTION) simply by calling this.dispatch(ACTION) whenever we need\nNow to the \"magic\" - i wanted to make it super easy to handle push callbacks in this type of environment, so I came up with the following pattern... I am not sure if this ends up giving any kind of issue, but here goes:\nUsing an async function rather than a generator (just was simpler at the end of the day, however I still have to handle the cancellation properly which I haven't done yet), we can call to capture an \"observer\" object which includes the following elements:\nconst { getNext, on } = this.createObservable('firebase')\n(note that the 'firebase' in the create observable is just because we generate a reference using Symbol() at the moment so it's mainly for debugging that)\nwe then call the push-style callback and provide the observers \"on\" value to it as the callback.  In this example, firebase returns an ID which can be used to cancel the listener:\nconst observerID = ref.on('value', on)\nNow we simply use the await command to wait for a resolution and loop it so we receive future iterations (firebase returns a ref and you use data.val() to capture it's actual value) :\nwhile (!this.cancel) {\n     const data = await getNext()\n     this.dispatch({type: 'FIREBASE_UPDATED', data: data.val() })\n}\nWhat's beautiful is how simple the pattern is to reason about the cancellation (once I get that working fully)\nasync observer() {\n    const { getNext, on } = this.createObservable('firebase')\n    const ref = this.getStore().ref.child('unadopted')\n    const observerID = ref.on('value', on)\n    while (!this.cancel) {\n      const data = await getNext()\n      this.dispatch({type: 'FIREBASE_UPDATED', data: data.val() })\n    }\n    ref.off('value', observerID)\n  }\nthere's a lot going on to make this work that isn't shown here, but here is the createObservable from the parent class... i am sure it will look familiar to you :-) \n```\ncreateObservable(name) {\n    const actionQueue = []\n    const dispatchQueue = []\n    const observerRef = Symbol(name)\nthis[observerRef] = response => {\n  if (dispatchQueue.length) {\n    const nextDispatch = dispatchQueue.shift()\n    nextDispatch(response)\n  } else {\n    actionQueue.push(response)\n    console.log(actionQueue)\n  }\n}\nreturn {\n  on: this[observerRef],\n  getNext() {\n    if(actionQueue.length) {\n      return cancellablePromise(\n        Promise.resolve(actionQueue.shift())\n      )\n    } else {\n      return cancellablePromise(\n        new Promise(resolve => dispatchQueue.push(resolve))\n      )\n    }\n  }\n}\n\n}\n```\nWhat the final result looks like as I modify data in firebase (note in the code when i ran this i had NOTIFICATIONS_READY as the cancelType)... I also changed it so i returned false when the shouldSagaCancel was triggered:\n\n. Agreed, by default forked tasks should cancel just like linux but with the ability to fork with an argument (nohup &) to break off from it's parent.\n. Hey there, wondering if this could have to do with the very weird issue I am seeing now as of updating. Only when inside of a saga and the saga is cancelled.  Basically in the snippet below (which I have modified to reduce unneeded code, although the issue does still occur... the finally statement is executed but \"After Finally\" is never called...\nAm I not allowed to use catch to handle errors now?\n``\n* observer(ref, type) {\n    console.log('Create Observer: ', type)\n    const { getNext, onData, onCancel } = this.createObservable(general-${type}`)\n    const observerID = ref.on(type, onData)\ntry {\n  while (true) {\n    const data = yield call(getNext)\n    yield fork(::this.processReceived, data, type)\n  }\n} catch(error) {\n  console.warn('Catch Called in Observer', error.message)\n} finally {\n  if (yield cancelled()) {\n    console.log('Saga Cancellation Occurs') \n  }\n}\nconsole.log('After Finally')\n\n}\n```\n. Any update on this?  When I hot reload during development this gets pretty obnoxious.  If you're wondering why it looks like a ton of the same saga is being cancelled - that is very much on purpose as we have built a fairly extensive framework around redux-saga \n\n. @Andarist no problem at all - I wanted feedback!  I appreciate it.\nSome of the concepts for those static properties were inspired largely by reduxsauce which provides some helpers to do such things.  \nThe general idea is to create a modular and pluggable architecture where one can implement a background process in their application that can handle logic, data fetching, etc as well as provide the mechanism for updating the UI when required (via redux store).  Adding the class infrastructure provides some unique benefits. Since the reducers are created automatically as you add new processes (while that could theoretically be dangerous in its own right... we considered name-spacing them in some way) the updates are provided. \nI know most of these things have become simpler since we started using redux-saga but it is still amazingly powerful to be able to build a process and export it and it be running and working with the entire structure you require ready to go.\nWhile those concepts are in no way required, it could literally be as simple as this, although I would probably implement this as a pure saga:\n```javascript\nimport Process from 'redux-saga-process'\nconst PAIR_DEVICE = 'PAIR_DEVICE'\nexport default class SimpleProcess extends Process {\n  static actionRoutes = { [PAIR_DEVICE]: 'startPair' };\n\nstartPair(action) {\n      / Do Something /\n  }\n}\n```\n\nor a simple middleman that may store data as it receives input on its this context and output normalized data in response when it thinks the UI should be updated:\n```javascript\nimport Process from 'redux-saga-process'\nconst INPUT = 'INPUT'\nclass MyProcess extends Process {\n  static actionRoutes = { [INPUT]: 'input' };\n  static actions = { output: ['output'] };\n  * input(action) {\n    / Do stuff with input /\n    this.output = { ...this.output, ...action.input }\n    yield* this.dispatch('output', this.output)\n  }\n}\n```\nEDIT In addition to that I wanted a task system that would auto cancel if an overwrite was made with the same category/id - also allowing easy cancellation of a group of tasks in the process.  Abstraction, true.  That is why I am using \"pattern\" instead of saying its a package or anything else.  It's really just a way for composing sagas in an encapsulated api with some abstractions to automate various parts.  \nFYI: I have committed and published the changes you recommended so far.   Much appreciated!. Let me know what you think once you've looked over things and thanks for taking the time :). @codepunkt hey there - i have an example of firebase specifically with my redux-saga-process package.  You may gain some insight from taking a look.  \nI actually register hundreds if not thousands of firebase listeners without any problem using this package with automatic handling of listeners / cancelling.  \nThe example shows a few things:\n\nListening and waiting until firebase should startup\nImporting the firebase package dynamically so that we take advantage of code splitting\nRegistering listeners via redux actions\n\nredux-saga-process essentially attempts to provide the same concept that react provides for the ui, but for data handling.  You gain similar lifecycle hooks to specific categories and can internally modularize the \"api\" of the process (how it will receive and dispatch from and to the redux store). \nFirebase Examples\n. I don't think logs should ever be forced upon a user in any situation unless they are opted into.  Instead there should simple be a setting when configuring the middleware to opt-into debug information. . As posted in the other threads, would definitely like to see this merged!  Each hot reload can spam the console quite a bit and would like that to be cleaner !\nThis could also potentially go with my other post discussing more powerful logging / analysis capabilities in the long-run.\n\n. @tamal-appsbee you may find this (alpha) package useful.  We are using it pretty heavily \nhttps://github.com/Dash-OS/firebase-listener\nalong with \nhttps://github.com/Dash-OS/saga-observable\nto ilsten to hundreds of firebase paths efficiently.\n\n. This would be nice to have -- some sort of analysis capability to check if there are runaway sagas not be handled.  Especially since spawn() can make this situation happen extremely easily since it also detaches from the ROOT saga (something I dont agree with personally - i think spawn should just be a separate context still attached to the root saga so that you can cancel it knowing ALL sagas are cancelled). I actually (kind of) already have a solution built that could possibly be extended upon to provide a graph-like functionality.  I use it for redux-saga-process v2 which is a signifcant upgrade of the entire concept there.\nIt includes the capability to get a graph-like result of all your running tasks as well as keeping them all organized, logging errors in a much more helpful way, etc etc.\nNot that this would make sense integrating directly in - but @andresmijares you may find it useful to accomplish something along the lines of what you are wanting here.\nhttps://github.com/Dash-OS/saga-task-manager\nIt's definitely not something i would use in production -- it's definitely reliable but may require some code reading to understand the internals.\nAlso has some nice logging options:\n\n\n. The more I use it, the more I realize how essential it is truthfully.  In terms of handling tons of forks and spawns while making sure it all comes together nicely it is critical.  Today was troubleshooting a few things and it made fixing something that would no doubt take hours extremely simple.  \n@Andarist @yelouafi - i wonder if the option to enable a high-quality logging option internally may not be extremely useful?  sagas introduces a concept which can be hard to understand what is really occurring behind the scenes.  I feel it's probably fairly easy to have things accidentally happening in the background that are eating up users performance if they don't understand some of the core details of how it all works.  \nPerhaps some way of monitoring things like if there seems to be a high number of running tasks that are not completing (memory leaks), etc?\nIf not part of core, perhaps at some point using the monitor you describe.  I may look into at some point but since all my forks/spawns and such are done through the task-manager i have little use for it personally. \n\n. To be a bit more clear, here is the code for the given library (which is just a wrapper around promise-queue-observable  which provides a buffer / channel similar to the redux-saga api's but with a few different semantics.  In this case returning the instance of the library directly will cause the issue.\nI see that some properties are also being added to the instance when this occurs. \nIn the end all it does is producers publish() promises and consumers get promises (.next()) \n```js\nimport PromiseQueue from 'promise-queue-observable';\nimport { CANCEL } from 'redux-saga';\nexport default class SagaObservable {\n  constructor(config = {}) {\n    this.observable = new PromiseQueue({\n      ...config,\n      promiseFactory: promise => {\n        if (config.promiseFactory) {\n          promise = config.promiseFactory(promise);\n        }\n        promise[CANCEL] = () => {\n          this.observable.cancel();\n        };\n        return promise;\n      },\n    });\n  }\n  next = () => this.observable.next();\n  publish = (...args) => this.observable.publish(...args);\n  cancel = () => this.observable.cancel();\n  cancelled = () => this.observable.cancelled();\n}\n```\neasy enough for me to simply return an object instead of the instance directly but may be worth looking into a better or more reliable way of handling this situation as I am sure there are other libraries out there that implement .next() methods . Ahh, PromiseQueue itself actually has throw and next methods.  The example above does not -- which is what I use 90% of the time, but the PromiseQueue that the above uses just happens to be what I was using instead this time. \nIt may be a good idea to tag a symbol or similar onto it instead?  . Ok here is a simple example.  Obviously this doesnt make much sense -- but it doesnt increment because it is waiting on observer itself which is the response of the createObserver function.  If you simply change that so the observer is instead created in the main body it works no problem\nI added a working and non working example and commented out the working one.\nhttps://codesandbox.io/s/Z6xAqZng6\n. @eranimo sounds like the same question that was asked a few questions later.\nhttps://github.com/redux-saga/redux-saga/issues/1169\nI answered it there.. Heh, that is exactly what is being done there.  :-) But great, glad you figured it out.  You should probably also validate the task first using the TASK symbol as done in the task-manager example.  That was recommended by the core team.. If JavaScript has proper TCO it would resolve the issue as it removes the current frame from the stack entirely, as long as you continually use them and know when and how they should be used you\u2019d be able to remove unwanted frames like we need here. \nMy experience with true tailcall optimization lies within Tcl. Definitely a huge benefit in cases like this. \nIn my case it became enough i actually rewrote redux AND redux saga into what I would consider far more sane for performance-critical applications. :) \nI do really hope to see Js world take a more prioritized stance on TCO though! \nHowever, I don't think it would work on generators anyway.. I can also put a PR together to implement this if its agreed that it would be something we want to add.  Initially looking at this I am thinking of this as a rough idea:\n``javascript\n// nextTickPromise.js (or potentially apart ofdelay-p` package)\nlet nextTickPromise\nexport default function getNextTickPromise() {\n  if (!nextTickPromise) {\n    nextTickPromise = Promise.resolve().then(() => {\n      nextTickPromise = undefined\n    })\n  }\n  return nextTickPromise\n}\n```\njavascript\n// io.js\nexport function defer(deferredEffect, fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(deferredEffect, is.effect, 'defer(effect, fn, ...args): argument effect is not a redux-saga effect')\n    check(deferredEffect, () => deferredEffect !== defer, 'defer(defer, ...): argument effect may not be defer')\n    validateFnDescriptor('defer', fnDescriptor)\n  }\n  return deferredEffect(nextTickPromise, call(fnDescriptor, ...args))\n}\n\nWould need to validate its a fnDescriptor effect\nResult would be the result of the deferredEffect\nNot 100% positive this is the right general api but it seems like a good idea\nProbably also useful to allow yield defer() to simply await next tick\nClearly would need to blacklist some effects like take which would not make any sense to defer in this manner\n\nIdea would be to add a general defer effect\n```javascript\n// @implementation yield defer(effect, fnDescriptor, ...args)\n// -->\nyield defer(fork, fnDescriptor, ...args)\nyield defer(spawn, fnDescriptor, ...args)\n// this may confuse people but could be useful in cases \n// since it will be pause execution until next tick but remains\n// synchronous\nyield defer(call, fnDescriptor, ...args)\n// and potentially (but with more consideration as we obviously \n// cant use the above in this case) things like\nyield defer(cancel, tasks)\n// ...\n```\nThen helpers could be provided just to basically sugar that but potentially not required at that point.\n\nRaw implementation using similar api to above without the internal support \n```javascript\nlet nextTickProm;\nfunction* deferredExecute(fn, ...args) {\n  if (!nextTickProm) {\n    nextTickProm = Promise.resolve().then(() => {\n      nextTickProm = undefined;\n    });\n  }\n  yield call(() => nextTickProm);\n  if (typeof fn !== 'function') {\n    return;\n  }\n  return yield call(fn, ...args);\n}\nfunction* defer(effect, ...args) {\n  if ([cancel].includes(effect) || !effect) {\n    // deferred effects without fnDescriptor\n    // footprint\n    yield call(deferredExecute);\n    if (!effect) {\n      return;\n    }\n    return yield effect(...args);\n  }\n  return yield effect(deferredExecute, ...args);\n}\n// const task = yield defer(spawn, () => console.log('next tick spawned!'));\n// yield defer(spawn, onClick, ...args);\n```. Thanks for the reply!\nIt\u2019s not about ASAP it\u2019s about ensuring that your take is captured and/or the local function continues until it yields before the forked/spawned/etc code runs.   Trying to be as similar to Go Defer as possible.  \nIn my case I was running into cases where it was missing some events since a fork was called which put again to be handled by the same loop, which ofc could be dangerous but in this case it was critical.  \nI think in general there are many times one would do things where they\u2019d want to make sure their main saga is reset and ready before actually calling the code.\nSo it\u2019s actually opposite, instead of wanting to run things ASAP it ensures your function continues after any request is made and that the action won\u2019t occur until AFTER the event loop is then opened again, hopefully occurring before any standard events such as setTimeout, etc (although that behavior cant be guaranteed).\n\nMy reasoning for this being a core piece of the API is that the event loops in general can be a bit confusing and this calls it out to show actually what behavior with and without the defer can be expected.\n```javascript\nfunction* sagaOne() { // --> 4\n  // do some stuff that isnt async\n  yield put({ // --> 5 (IGNORED)\n    type: 'TWO',\n  });\n}\nfunction* sagaTwo() { \n  // nope wont be called :(\n}\nfunction* parentSaga() { // --> 1\n  while (true) {\n    const action = yield take(['ONE', 'TWO']);  // --> 2, --> 6\n    switch (action.type) {\n      case 'ONE': {\n        yield fork(sagaOne); // --> 3\n        break;\n      }\n      case 'TWO': {\n        yield fork(sagaTwo);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}\n```\nWhereas this will work as expected without adding much overhead.  \n```javascript\nfunction* sagaOne() { // --> 5\n  // do some stuff\n  yield put({ // --> 6\n    type: 'TWO',\n  });\n}\nfunction* sagaTwo() { // --> 8\n  // yay!\n}\nfunction* parentSaga() { // --> 1\n  while (true) {\n    const action = yield take(['ONE', 'TWO']); // --> 2, --> 4\n    switch (action.type) {\n      case 'ONE': {\n        yield defer(fork, sagaOne); // --> 3\n        break;\n      }\n      case 'TWO': {\n        yield defer(fork, sagaTwo); // --> 7\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}\n```\n\nOf course those are implementing similar to takeEvery but there are other cases that I've run into similar here (and havent tested but takeEvery may suffer from this issue already).  \n\nHere is a rough sketch of where it was needed although I've come across this most times using redux-saga in various ways.  \n. @Andarist I would also point this out https://github.com/whatwg/html/issues/512 which is the upcoming queueMicroTask that implements this in browser nicely without the boilerplate \n\nChrome Status\nExplainer\nNode v11 Docs. Yes I was simplifying it and you are right, that specific simplification does not capture the condition properly, although below I have updated with logging to show why the condition occurs and why defer as-similarly provided by many languages makes sense to provide.\n\nSince yield take is composing a redux action it clearly works in my simplification. It starts to break down in cases where you have more complex interactions and you expect the same behavior to exist when forking and spawning tasks.  It still makes sense to make the behavior of when things are going to actually occur explicit so the user is well aware of them and how they can be controlled (without adding randomyield Promise.resolve() which I would imagine many people would be confused about why that would be necessary).\nhttps://codesandbox.io/s/xjp7nnr744?fontsize=14\nAs you can see sagaOne called occurs here before take next occurs which can lead to confusing and hard to understand race conditions if a user expects that a fork will give them asynchronous handling.\nIn my case things were changed and in the end a dispatch was called from another place in the application unrelated to sagas which was not being caught, but I've run into this in other similar areas as well.\n\nI would also point out this isnt the only time this has come up.  I actually am positive I've seen quite a few issues all related to users not being aware of the execution flow that will occur based on the effects they use.  \nAgain, defer provides a documented method which makes this flow more clear to users and provides a simple tool to try when they run into weird race-conditions like these.\nI would even argue that actionChannel and other helpers were probably needed due to not having defer in the first place as users continually had problems making what should be such a simple thing work out. \nIt's a very simple thing, sure and easy to add yield Promise.resolve() but -- what do you think when you open the code a year later and see random yield Promise.resolve() in places and are like \"wtf was this for?\" - its a concept that makes sense to be represented imo.  Or like in my case when you only end up needing to work on your saga-related things once a year and every time you come back you sit there fighting these things for a few hours because you forget about how the exact flow of execution works.. @shinima took a sec to put together this specific case where you end up running into the issue.   I can outline more cases by digging into my other projects to find where these things came up and I am sure I could find more issues that highlight users having confusion around this topic if needed.\n\nWithout Defer: https://codesandbox.io/s/moq877oqx9\n\n[watchNotification] | take next event from channel \n[watchNotification] | handle event from channel with type:  click \n[onClick] | onClick Called, emit update \n[watchNotification] | take next event from channel\n\nAlso note that the argument about just needing yield Promise.resolve() isn't very valid here because it would actually take a good amount of refactoring to handle these cases and strong understanding a lot of mechanics internal to redux-saga.\n\n\nWith Defer: https://codesandbox.io/s/ol9l48nz36\n\n[watchNotification] | take next event from channel \n[watchNotification] | handle event from channel with type:  click \n[watchNotification] | take next event from channel \n[onClick] | onClick Called, emit update \n[watchNotification] | handle event from channel with type:  update \n[watchNotification] | take next event from channel\n^ handled when clicking the div with the \"notification\"\n\nAlso note that the example above is copy and paste of a larger implementation so some of the specifics may not make sense without the larger context surrounding it.  I cut some corners to get the same effect without it being too large of an example.\n\n. ",
    "aweary": "This is an intermediate step towards https://github.com/yelouafi/redux-saga/issues/70\n. ",
    "patrickheeney": "So basically as it stands now its not possible, but an \"official\" api (run method within the middleware) is being considered? I just wanted to make sure I didn't miss anything from the current API as I am new to sagas. \n. I haven't tried this out yet but this is the pseudocode I will be experimenting with. \n``` javascript\n// app\nimport createSagaMiddleware from 'redux-saga'\nconst rootReducer = createReducers(reducerRegistry.getReducers());\nconst sagaMiddleware = createSagaMiddleware(sagaRegistry.getSagas());\nconst store = createStore(\n  rootReducer,\n  initialState,\n  applyMiddleware(sagaMiddleware)\n);\nreducerRegistry.setChangeListener(reducers => {\n  store.replaceReducer(createReducer(reducers));\n});\nsagaRegistry.setChangeListener(sagas => {\n  sagaMiddleware.run(sagas);\n});\n// routes\nfunction createRoutes(reducerRegistry, sagaRegistry) {\n  return \n {\n      require.ensure([], require => {\n        reducerRegistry.register(require('./reducers').default);\n        sagaRegistry.register(require('./sagas').default);\n        cb(null, require('./views/Index').default);\n      });\n    }}/>\n  \n}\n```\n. ",
    "johanneslumpe": "@mjrussell I'm at the stage now where I need to implement the saga library. I'm still new to sagas, which is probably why this is a bit harder for me right now. I am trying to figure out how to do hot-reloading and code-splitting for sagas. Would you mind sharing your approach? I realize that i can call sagaMiddleware.run multiple times for different sagas. That will not get rid of the original saga though. So if I run a saga, then change some code inside said saga and hot-reload it, how can I make sure to replace the old saga without losing state?\nMaybe @yelouafi can chime in too :)\nOne way I figured it might work is by storing the returned tasks for each .run call and then cancel them when updates arrive before registering the new saga - not sure if this really works though.. @mjrussell that's the way I went for now - only adding new sagas to the store and passing them to .run - seems to work fine. Hot reloading might still be possible - apart from the fact that it is going to reset the reloaded saga (which might or might not be an acceptable trade-off).. ",
    "GuillaumeCisco": "Hello there,\nI had the same issue and found redux-injector for injecting reducers asynchronously via routing.\nI decided to create the same philosophy for redux-sagas : https://github.com/GuillaumeCisco/redux-sagas-injector\nYou can find an exemple in the README.\nUsing injectReducer and injectSaga, you can easily load your js code asynchronously via routing and deciding what route need only what it needs.\nHope you'll enjoy it :tada: \nPS: It also works with SSR Stream Caching and with react-redux >= 6.0.0. I have the exact same issue from version >= 1.0.0.\nI use this pattern for loading my sagas:\n```javascript\nimport {fork} from 'redux-saga/effects';\nimport my_saga from './my_saga';\nexport default function* root() {\n    yield fork(my_saga);\n}\nThe `my_saga.js` file looks like:javascript\nimport {takeLatest} from 'redux-saga/effects';\nfunction* myGenerator(request) {\n    // do stuff, yield stuff\n}\nexport default function* () {\n    yield all([\n        takeLatest(MY_ACTION_TYPE, myGenerator),\n    ]);\n}\n```\nThe myGenerator function is never called :/\nAND it looks like the yield all is never reached too.. @Andarist Simply using the beginner tutorial.\nFollowing: https://redux-saga.js.org/docs/introduction/BeginnerTutorial.html\ngithub repo : https://github.com/redux-saga/redux-saga-beginner-tutorial\nClone it, go inside the sagas branch, modify the package.json for having \"redux-saga\": \"1.0.1\".\nThen, yarn install, yarn run.\nGo to the webpage, it does not work on my computer.\nyarn : 1.13.0\nnode : v11.10.0\nIf someone can confirm it.\ncodesandbox is here: https://codesandbox.io/s/nwj4jrm1n0\nThe one with old version : https://codesandbox.io/s/qkr84w2w is working\nThank you,. @shinima I took the code from the official tutorial as you can see.\nI succeeded to make the tutorial work by adding the yield all([...]) and replacing the yield call(delay, 1000) by yield delay(1000) with an import { all, put, takeEvery, delay } from \"redux-saga/effects\";\nThe tutorial is not up to date.\nUnfortunately, it changed nothing in my own project, effects are not called.... Ok I just found out my issue.\nI use redux-sagas-injector https://github.com/GuillaumeCisco/redux-sagas-injector.\nI'm the maintainer of this lib.\nIssue is redux-sagas-injector use a old version of redux-saga and is in charge to create the sagaMiddleware: const sagaMiddleware = createSagaMiddleware();\nWhen mixing old and new versions of redux-sagas with dependencies, effects are not called.\nI'm thinking how to make the code compatible for both versions without breaking changes...\n. Thanks @Andarist.\nHowever, I think the beginner tutorial should be updated ;). ",
    "navneet-g": "We recently built a library called redux-dynamic-modules. The library helps in code splitting Redux applications and allows loading reducers, middlewares, sagas dynamically. It also comes with a HOC to load/unload a module when the component requiring them mounts or unmounts. . @luskin we use immer in our web application and do not see any issues using it along with redux-dynamic-modules. Please share any issues you are observing with immutable.. Thanks @luskin , let us continue the discussion on the issue there. Seems like Alex plans to take a stab at it.. Hi @Andarist,\nDid multicast made to the API yet? I looked up in APIs but could not find a reference.\nhttps://redux-saga.js.org/docs/api/\nThanks,\n. ",
    "luskin": "@navneet-g cool library, any roadmap to support immutable?. @navneet-g Is this issue irrelevant then?\nhttps://github.com/Microsoft/redux-dynamic-modules/issues/52. When using immutable with redux-dynamic-modules you receive the following error:\nThe previous state received by the reducer has unexpected type of \"Object\". Expected argument to be an object with the following keys: \"accountCredit\". ",
    "laurelnaiad": "node.js uses the term detached to describe forked/spawned processes that do not end with their parent.\nFWIW, at first I thought that the default for sagas would be detached (or whatever it ends up being called), but I guess I now realize that the norm for canceled parents would be to cancel children, as opposed to finished parents, which would never have a terminating effect on the child (if a parent yields a fork, then it's up to the recipient to handle that saga). This would make the path of least resistance to be that the cancelation of a parent saga could be used to \"turn off\" event streams that you have running in its forks, sort of an \"unsubscribeAll\" for forked child sagas.\n. ",
    "savethefails": "Sorry, a bit late to the party but running into something similar that I'm trying to wrap my head around.\nIs it a good idea for a component to specify the actions that have taken place after an async call?\nIn this case, FormContainer gets its state from Redux Store and needs to know when an async call was successful in order to navigate away or show an error. Reducers know how to handle the success or error actions and update the state (not shown) Would love your feedback @slorber!\njavascript\nfunction* callApi(){\n  while(true) {\n    const action = yield take(CALL_API)\n    const {success, error} = fetch(action.url)\n    if (success) {\n       yield action.successActionCreators.map( creator => put( creator(success.data) )\n   }\n   if (error) {\n       yield action.errorActionCreators.map( creator => put( creator(error.data) )\n   }\n}\n``` javascript\nimport {formSubmitted, formFailed} from './actions'\nconst mapStateToProps = (state) => {\n return {\n  formStatus: state.form.status\n }\n}\n@connect(mapStateToProps)\nclass FormContainer extends Component {\n componentWillReceiveProps(nextProps){\n    if (nextProps.formStatus.success) push('/success')\n  }\n handleSubmit(){\n   dispatch({\n     type: CALL_API,\n     successActionCreators: [formSubmitted],\n     errorActionCreators: [formFailed],\n   }\n } \nrender(){\n    \n }\n}\n```\n. Thanks for the response @slorber!\nSorry if this veered off topic. This thread came up while trying to search for the answer and since I know your work thought I'd interject.\nThere are two things which I'm unsure about:\n1. how many Sagas are too many? Every 'flow' through an app (in my case signing up, confirming signing up, signing in, signing out...) should they each get their own Saga? Should I dynamically mount Sagas when they're  needed for a specific flow? For example, Sign up is used once throughout the app, but the Saga would be there forever waiting to TAKE its action.\n2. I think the code I presented is a bit too generic. My components get their state injected as props from the Redux store. Where a component's specific state can be found in the store dynamic and depends on lineage. This is also passed in by props (stateKey in the below example), so actions need the path in order to update a component.\njavascript\n{  \n \"components\": {\n  \"SignUpController\": {\n   \"state\": {},\n   \"children\": {\n    \"SignUpLayout\": {\n     \"state\": {},\n      \"children\": {\n       \"SignUpFormContainer\": {\n        \"state\": {\n         \"email\": \"test@example.com\"\n        }\n      }\n     }\n    }\n   }\n  }\n }\n}\nThe issue is more like the below. Can a component dictate the story of a Saga when the specifics of how to respond to async actions can't be known by the Saga itself?\nThe example is therefore more like:\n``` javascript\nimport { componentStateChangedActionCreator } from './actions'\nconst mapStateToProps = (state, ownProps) => {\n const { stateKey } = ownProps  / \"Map/City/NorthWest/SnorgleTank15\" /\n const componentState = stateKeyToComponentState(stateKey, state) \n return componentState / { \"lat\": \"-44\", \"long\": \"-77\" } /\n}\n@connect(mapStateToProps)\nclass SnorgleTank extends Component {\n handleClick(){\n   const orderSucceeded = componentStateChangedActionCreator(\n         this.props.stateKey,\n         { snorgleBlaster: 'fire' }\n      )\n   const orderFailed = componentStateChangedActionCreator(\n        this.props.stateKey,\n        { retreatTo: 'basecamp' }\n     )\n   dispatch({\n     type: FIRE_OR_RETREAT,\n     current: { lat: this.props.lat, long: this.props.long },\n     successActions: [orderSucceeded],\n     errorActions: [orderFailed],\n   }\n }\n render(){\n  \n }\n}\n``\n. Perfect! I will look into cancelling Sagas and maybe even dynamically creating them for a specific flow. My action creators return only objects, but they should be run before being passed to the Saga action instead of being produced by the Saga action so that the log is serializable. Thank you very much!\n. Hey @andreialecu, would this help?\n [_runSaga(iterator, {subscribe, dispatch, getState}, [monitor]_)](http://yelouafi.github.io/redux-saga/docs/api/index.html#runsagaiterator-subscribe-dispatch-getstate-monitor):Allows starting sagas outside the Redux middleware environment. Useful if you want to connect a Saga to external input/output, other than store actions.`\n. @mhoffmanniseki Thanks! Can you explain what you mean by \"misses the connection to redux\"?\n. ",
    "andreialecu": "I ran into the same issue with the following scenario:\n``` javascript\nfunction* _subscribeFlow() {\n  while (true) {\n    var action = yield take('SUBSCRIBE');\nvar fn = (x) => {\n  if (x.id === action.eventId) {\n    ... dispatch other action to refresh here...\n  }\n};\n\nsocket.on('x:changed', fn);\n\naction = yield take('UNSUBSCRIBE');\nsocket.off('x:changed', fn);\n\n}\n}\n```\nThis uses socket.io, and I need to dispatch an action from the callback.\nI could wrap the socket.on function in a promise but that seems wrong, because it can be called multiple times, and a promise is only supposed to resolve once.\nAny suggestions?\n. Alright, I came up with the following (with help of some stackoverflow answers):\n``` javascript\nfunction createHandler(event) {\n  var deferred;\nvar cb = e => {\n    if (deferred) {\n      deferred.resolve(e);\n      deferred = null;\n    }\n  };\nsocket.on(event, cb);\nreturn {\n    cancel() {\n      socket.off(event, cb);\n    },\nnextMessage() {\n  if (!deferred) {\n    deferred = {};\n    deferred.promise = new Promise(resolve => deferred.resolve = resolve);\n  }\n\n  return deferred.promise;\n},\n\n};\n}\nfunction* watchMessages(msgSource, filterId) {\n  try {\n    let message = yield call(msgSource.nextMessage);\n    while (message) {\n      if (message.id === filterId) {\n        yield put( ... ); // this works\n      }\n  message = yield call(msgSource.nextMessage);\n}\n\n} finally {\n    if (yield cancelled()) {\n      msgSource.cancel();\n    }\n  }\n}\nfunction* _subscribeFlow() {\n  var subscriptions = {};\n  while (true) {\n    var action = yield take('SUBSCRIBE');\nvar msgSource = yield call(createHandler, 'x:changed');\nvar task = yield fork(watchMessages, msgSource, action.eventId);\n\naction = yield take('UNSUBSCRIBE_TOURNAMENT');\nyield cancel(task);\n\n}\n}\n```\nSeems to work, but it's a lot of boilerplate.\n. ",
    "mhoffmanniseki": "Hey @andreialecu and @savethefails ,\nI had the same Issue. As runSage misses the connection to redux, which I also required an EventChannel does exactly what I need: http://yelouafi.github.io/redux-saga/docs/advanced/Channels.html\n. @savethefails By my opinion runSaga(iterator, {subscribe, dispatch, getState}, [monitor]) is a way to use saga without redux. So it is an separat running instance without an connection to an redux instance. I've never tried this and my guessing is based on the documentation.\nFor me event channels are a clean solution to listen for async events. In my case I am using this to connect redux to firebase events.\n. ",
    "MrsBookik": "I still don't get it. I've read several issues and other texts about this topic... Mostly they solve complex problems and not a simple thing like mine. Can someone point me to a tutorial or something else that shows me how to pass a simple \"yield put\" within a callback? \nIn my scenario i have to place a callback to receive the progress of a download-task and i want to put it into the redux-store with \"yield put\".\nAll i want to do is something like this:\nfunction onDownloadFileProgress(data) {\n  yield put({type: ACTIONS.S_PROGRESS, progress})\n}\nHow to achieve that simple case? And why is it so difficult?. Thx @Andarist  :) I'll give more context: \nI have a saga that downloads files from the internet using react-native-fs. There i have to pass a plain javascript function to receive the progress of current file download. \nAnd there we go (or not, because yield isnt working here and i need to do some fancy stuff):\n```\nfunction onProgress(progress) {\n  yield put({type: ACTIONS.S_DOWNLOAD_PROGRESS, progress}) \n}\nexport function * loadMedia(id) {\n  let url = media/files/${id};\nconst filename = RNFS.CachesDirectoryPath + '/' + id;\nconst download = RNFS.downloadFile( {\n    fromUrl: url,        \n    toFile: filename,\n    background: false,\n    progressDivider: 10,\n    progress: onProgress,\n  })\nyield download.promise;\n}\n```. thx @Andarist, will provide more context/code:\n```\nfunction onProgress(progress) {\n  // this isn't allowed here:\n  yield put({type: ACTIONS.S_DOWNLOAD_PROGRESS, progress})\n}\nexport function * loadFile(id) {\n  let url = media/${id};\nconst tmpFilename = RNFS.CachesDirectoryPath + '/' + id;\nconst download = RNFS.downloadFile( {\n    fromUrl: url,        \n    toFile:tmpFilename,\n    background: false,\n    progressDivider: 5,\n    progress: onProgress,\n  })\nyield download.promise;\n}\n```\n. ",
    "benwiley4000": "@aft-luke your bindCallbackToPromise is a very slick temporary solution in my case. In the medium-to-long-term I expect we'll be able to eliminate the callback but our system uses a separate middleware which expects callbacks on certain actions. Appreciate the ingenuity. \ud83d\ude09 . ",
    "niconistal": "Hey @MrsBookik did you find a solution? I'm trying to do the exact same thing.. ",
    "SoundBlaster": "@Andarist thank you!. ",
    "dhruvdangi": "@Andarist Thanks!. ",
    "musbaig": "Is there some way to turn off the log warnings dev mode? In my specific use case I'm continuously starting a race every 5 secs, as a result, the log warnings are flooding the console, drowning out other logs.\nFantastic work btw, redux-sagas are by far the best usage of generators this side of the galaxy!\n. @tokenvolt brilliant! Thanks so much for sharing that tip, totally solved the problem. You should blog/gist it somewhere. May be do an add-a-note PR here or over at redux-form. It really helps address the interaction between redux-sagas and redux-form.\n. redux-form wraps and exposes connect(), http://redux-form.com/5.2.5/#/api/reduxForm?k=myjcva, so you technically don't need to worry about order, but, YMMV.\n. @timothyallan really? Interesting, wonder what the new mechanism is, or lack thereof. Thanks for the heads up!\n. In my specific use case I'm continuously starting a race every 5 secs, as a result, the log warnings are flooding the console, drowning out other logs. Being able to turn them off in _dev mode would be a godsend?\nFantastic work btw, redux-sagas are by far the best usage of generators this side of the galaxy!\n. Checkout issue #161, solution is near the bottom, cheers.\n. @TomMahle yup, that's the correct one, I still use both the original approach and improvements thereof. ",
    "bradynapier": "Yep, just noticed that after some initial confusion! \n. Oops just removed the label you had added.  Can close this. \n. ",
    "gunar": "Well, I tried to use npm run docs:publish, but it failed trying to push to your repo.\n\"docs:publish\": \"npm run docs:clean && npm run docs:build && cd _book && git init && git commit --allow-empty -m 'update book' && git checkout -b gh-pages && touch .nojekyll && git add . && git commit -am 'update book' && git push git@github.com:yelouafi/redux-saga gh-pages --force\"\nNow I see I could have easly replaced your repo for mine in that script. Would you like me to PR for the gb-pages branch?\n. ",
    "lennerd": "Sorry to interrupt the topic, but are there any examples, ideas or some tipps on how to implement throttle and debounce with sagas?\n. Found a solution by using fork, a simple delayed promise and cancel.\n``` js\nfunction* watchAction() {\n  let task = null;\nwhile (true) {\n    const { payload } = yield take(ACTION);\nif (task != null)\n  yield cancel(task);\n\ntask = yield fork(subSaga, payload);\n\n}\n}\nfunction* subSaga() {\n  try {\n    // Delay photon request (debounce).\n    yield delay(millis);\n// Do stuff like caling APIs etc.\n// ...\n\n} catch(error) {\n    // Cancel was called inside watchAction.\n    if (error instanceof SagaCancellationException)\n      return;\nthrow error;\n\n}\n}\n```\n. @yelouafi Thanks for your thoughts and ideas for best practices. I also thought about debouncing directly in the component when firing the action. But my usecase is a bit different. Imagine a component where the user types in an address and at the same time there is a map which get updated by geocoding this address and showing a marker for the resulting latitude and longitude. The problem here is, that the underlaying user input needs to be updated in the application state immediately while the geocoding needs to be debounced to not reach some kind of API rate limit.\nLet me extend my example to explain this a bit better:\n``` js\nfunction* watchAddressUpdate() {\n  let task = null;\nwhile (true) {\n    // The payload is an immutable node with the new address \n    const { payload: node } = yield take(actions.UPDATE_ADDRESS);\nif (task != null)\n  yield cancel(task);\n\ntask = yield fork(updateMap, node);\n\n}\n}\nfunction* updateMap(node) {\n  try {\n    // This can be also done directly in the reducer ...\n    yield put(actions.SET_NODE, node);\n// Delay request (debounce).\nyield delay(millis);\n\nconst { lat, lon } = yield geocode(node.address);\n\nyield put(actions.SET_MAP_CENTER, { lat, lon });\nyield put(actions.SET_NODE, node.merge({ lat, lon }));\n\n} catch(error) {\n    // Cancel was called inside watchAction.\n    if (error instanceof SagaCancellationException)\n      return;\nthrow error;\n\n}\n}\n```\nSure, I could fire two actions in the component where one action get debounced, but I find it more convenient to do this kind of complex async stuff in the saga. What do you think?\n. > even if updateMap sleeps for some time, watchAddressUpdate will continue to take UPDATE_ADDRESS events and continually fork new updateMap tasks. So IMO the sleep should be inside watchAddressUpdate\nI forgot to mention but my code shows an example of debouncing actions with sagas. So yes, you're right, it's not throttling but debouncing.\nMaybe I misunderstand your point, but as far as I tested this snippets, it worked fine. Let me try to explain why the updateMap task is not continually forked. Please correct me if I'm wrong. I'm quite new to the concept of sagas.\n1. Watch for an UPDATE_ADDRESS action.\n2. Cancel old forked task if one saga as been forked already. Combined with the delay in the updateMap saga, this should give us the desired debouncing effect. The updateMap is therefore not continually forked but canceled if it was not finished yet.\n3. Fork the updateMap saga.\nInside the updateMap saga:\n1. Update the node.\n2. Delay execution of the saga.\n3. Execute async geocode helper.\nSo, when the user updates the address and the according action is fired, the old forked saga from previously called UPDATE_ADDRESS actions is restarted (if not yet finished). So IMO this should give us the desired debounce effect, doesn't it?\n\nI think you don't need this code. starting from 0.6.0 Cancellation exceptions do not propagate to parent\n\nGreat news and thanks for your intensive work on this library. Never really worked with generators in a project. Sagas were a great way to learn about their awesome neatness and advantages.\n. Yes! You are right. I initially thought, that throttling kind of delay execution of every function call but instead it just passes some function calls after a specific delay. So putting the delay into the watchAddressUpdate as you described should indead throttle the geocoding requests. I often find throttle functions to start with an initial function call and delaying only following calls, but this is just a matter of placing the delay behind the fork.\nBoth scenarios would make good examples for the receipt section of the documentation. What do you think?\n. Would love to see that, too, but I tried to came up with a simple solution for my special use case to be reused in other parts of my application. Honestly I wasn't able to find the right place to add this.\n. ",
    "rosendi": "@yelouafi Should I use the same technique with RxJs or is there a better way? For example how could the dispatch method be avoided here?\nfunction *saga(dispatch) {\n  while (true) {\n    take(SUBSCRIBE);\n    const subscription = observable.subscribe(x => dispatch(...));\n    take(UNSUBSCRIBE);\n    subscription.unsubscribe();\n  }\n}\n. I've just found the way. With the wrapObservable helper from the https://github.com/eggers/async-generator package we can do:\n```\ntype ResolvePromise = (value: T) => void;\ntype RejectPromise = (value: any) => void;\ntype PromiseArguments = [ResolvePromise, RejectPromise];\nexport function* wrapObservable(observable: Observable): IterableIterator> {\n  let subscription: any;\ntry {\nlet done: boolean = false;\n\nconst sentPromises: PromiseArguments<T>[] = [];\nconst completedPromises: Promise<T>[] = [];\n\nsubscription = observable.subscribe(\n  (item: T) => {\n    if (sentPromises.length > 0) {\n      let [resolve, ] = sentPromises.shift();\n\n      resolve(item);\n    } else {\n      completedPromises.push(Promise.resolve<T>(item));\n    }\n\n  },\n  (error: any) => {\n    if (sentPromises.length > 0) {\n      let [, reject] = sentPromises.shift();\n\n      reject(error);\n    } else {\n      completedPromises.push(Promise.reject<T>(error));\n    }\n  },\n  () => {\n    done = true;\n  });\n\nwhile (!done || completedPromises.length > 0) {\n  if (completedPromises.length > 0) {\n    yield completedPromises.shift();\n  } else {\n    yield new Promise((r: ResolvePromise<T>, e: RejectPromise<T>) => sentPromises.push([r, e]));\n  }\n}\n\n} finally {\n    subscription.unsubscribe();\n  }\n}\nfunction *saga() {\n  while (true) {\n    yield take(SUBSCRIBE);\nconst { observable } = yield select();\n\nfor (let next of wrapObservable(observable)) {\n  const { action } = yield race({ action: next, overwise: take(UNSUBSCRIBE) });\n\n  if (action) {\n    yield put(...);\n  } else {\n    break;\n  }\n}\n\n}\n}\n```\n. A temporary solution could be:\n```\nimport { stopSubmit } from 'redux-form';\n...\nonSubmit: ({ name }) => {\n  setTimeout(() => dispatch({ type: 'CREATE_TODO', name }));  \nreturn new Promise(() => {}); // Set the form state to 'SUBMITTING'\n}\n...\nfunction* createTodo(action) {\n   try {\n      const todo = yield call(Api.createTodo, action.name);\n      yield put({ type: 'CREATE_TODO_SUCCESS', todo });\n   } catch (e) {\n      yield put({ type: 'CREATE_TODO_FAILURE', reason: e.toString() });\n   }\n}\nfunction* watchTodo() {\n  while (true) {\n    yield call(createTodo, yield take('CREATE_TODO'));\n  }\n}\nfunction* watchForm() {\n  while (true) {\n    const { failure } = yield race({ \n      success: take(CREATE_TODO_SUCCESS),\n      failure: take(CREATE_TODO_FAILURE)\n    });\nif (failure) {\n  yield put(stopSubmit('form', { _error: failure.reason.message }));\n} else {\n  yield put(stopSubmit('form'));\n}\n\n}\n}\nfunction* saga() {\n  yield [\n    fork(watchTodo),\n    fork(watchForm),\n  ]\n}\n```\n. @yelouafi Could you please change the label to 'feedback wanted'.\n. Thank you for a solution. What if the one saga should wait for another one. For example:\n```\nfunction* sourceSaga() {\n  take(DATA_LOAD_REQUEST); // this action dispatched from the component before END\nyield put({ type: DATA_LOAD_SUCCESS, payload: { ... } });\n}\nfunction* destSaga() {\n  const payload = yield take(DATA_LOAD_SUCCESS)\n// now we have data to proceed. for example convert slug to id. \n}\nfunction watchSourceSaga() {\n  let action = yield take();\nwhile(action !== END) {\n    yield fork(sourceSaga)\naction = yield take(DATA_LOAD_REQUEST)\n\n}\n}\n```\nHow would this scenario be implemented using END?\n. So, is it possible to take an action from the other saga after the END? In my case in the destSaga.\n/cc @yelouafi @Andarist  . @Andarist :-( could you please provide a simple example? I think this is a common case.. @Andarist yep, I checked the throttle's source code, but it's a little bit tricky at first glance. Thank you for you answer!\nI don't like throttling the emitter, because this way it becomes less generic, i.e I have to create a two different eventChannel for throttling and debouncing; or check the eventChannel's options to conditionally apply throttle or debounce inside it. \nYou added the enhancement label so I leave the issue open.\n. ",
    "kuy": "Douitashimashite (Your welcome) :smile: \n. I noticed you need to use  yield* for takeEvery helper instead of yield.\n. Ah, you can't call delay function directly. Because delay is NOT an effect. It's a utility function that returns a Promise. Please try like this.\nes6\nyield call(delay, 2000);\n. When you use takeLatest utility function, it just cancels the last forked task. So you can't receive the second response.\nBut I think takeLatest function can be used to help your situation. Your solution without using redux-saga has the state that contains lastAPIToken property to check whether it's the latest response.\nOn the other hand, you don't need to have lastAPIToken prop in the state if you use takeLatest function. It manages which task you launched last internally and cancels the in-flight task automatically when you launch a second task. If you want to track cancelled requests, you can write it down with effect primitives because takeLatest function is not an effect primitive, just a helper function.\n. Yes! In redux-saga context, both \"task\" and \"saga\" terms express the same thing. Your example has 3 spawned tasks from takeLatest function.\n. Like this.\n``` es6\nfunction* runRequest({ payload }) {\n  const { id } = payload;\n  const { data, error } = yield call(callAPI, id);\n  if (data && !error) {\n    yield put({ type: FETCH_OBJECTS_SUCCESS, data });\n  } else {\n    yield put({ type: FETCH_OBJECTS_FAIL, error });\n  }\n}\nfunction rootSaga() {\n  yield takeLatest(FETCH_OBJECTS_REQUEST, runRequest);\n}\n``\n. @minhyeong-kim Yes, you don't need to write validation logic because the previously spawned task is always cancelled bytakeLatest` function internally.\n\n1. [A] Task A is spawned by FETCH_OBJECTS_REQUEST action\n2. [A'] Receive AJAX result and Task A was finished successfully\n3. [B] Task B is spawned (there is no running tasks at this time)\n4. [C] Before Task C is spawned, Task B (waiting AJAX response) is cancelled. Then Task C is started.\n. @minhyeong-kim Can you close this issue? If you have other problem, please ask me \ud83d\ude04 \n. Agreed. So I use emit instead of listener in my project and examples.\nhttps://github.com/kuy/redux-saga-examples/blob/master/startstop/sagas.js#L50\nhttps://github.com/kuy/redux-saga-examples/blob/master/microblog/firebase.js#L8\nhttps://github.com/kuy/redux-saga-chat-example/blob/master/src/client/sagas.js#L18\nes6\nfunction subscribe(socket) {\n  return eventChannel(emit => {\n    socket.on('users.login', ({ username }) => {\n      emit(addUser({ username }));\n    });\n    socket.on('disconnect', e => {\n      // TODO: handle\n    });\n    // ...\n  });\n}\n. I think that there is no difference between redux-saga and redux-thunk on the ability for reporting the progress to user. Because of Redux is single state, we need to put the operation progress to the store. And the state is changed only by Actions. So you can dispatch Actions based on the progress of operations.\nNote: callAPI(...) returns Promise object\nredux-thunk (action creator)\nes6\nfunction fetchRequest(id) {\n  return dispatch => {\n    dispatch({ type: FETCH_OBJECTS_REQUEST });\n    callAPI(id).then(data => {\n      dispatch({ type: FETCH_OBJECTS_SUCCESS, data });\n    }).catch(error => {\n      dispatch({ type: FETCH_OBJECTS_FAIL, error });\n    });\n  };\n}\nredux-saga (without try-catch)\n``` es6\nfunction* runRequest({ payload }) {\n  const { id } = payload;\n  const { data, error } = yield call(callAPI, id);\n  if (data && !error) {\n    yield put({ type: FETCH_OBJECTS_SUCCESS, data });\n  } else {\n    yield put({ type: FETCH_OBJECTS_FAIL, error });\n  }\n}\nfunction handleRequest() {\n  yield takeLatest(FETCH_OBJECTS_REQUEST, runRequest);\n}\n```\nredux-saga (with try-catch)\n``` es6\nfunction* runRequest({ payload }) {\n  const { id } = payload;\n  try {\n    const data = yield call(callAPI, id);\n    yield put({ type: FETCH_OBJECTS_SUCCESS, data });\n  } catch (error) {\n    yield put({ type: FETCH_OBJECTS_FAIL, error });\n  }\n}\nfunction handleRequest() {\n  yield takeLatest(FETCH_OBJECTS_REQUEST, runRequest);\n}\n``\n. Umm... I understand what you want to say. I have no idea to do directly like that with redux-saga.\nIf you do so, React component (which callsthis.props.dispach`) is no longer pure. This causes decreasing of testability.\n\nwhen interacting with other APIs that are imperative rather than declarative\n\nDoes this mean an use-case like chained API calling?\nFor example, please consider two API endpoints; /users and /users/<id>/posts.\nYou want to load a list of users from /users endpoint first, and then load a list of latest posts for each user. But if you get an error on calling /users, you don't want to call /users/<id>/posts.\nes6\nthis.props.dispach(fetchRequest()).then((data) => {\n  this.props.dispatch(fetchOtherRequest()).then((data) => {\n    // Do something upon success both\n  }, (err) => {\n    // Error handling\n  });\n}, (err) => {\n  // Do something upon failure\n})\nIf chained API call is your hidden needs, it's a common pattern in redux-saga.\n``` es6\nfunction* handleRequestSearchByLocation() {\n  while (true) {\n    const action = yield take(SUCCESS_USER);\n    const { payload, error } = yield call(API.searchByLocation, action.payload.location);\n    if (payload && !error) {\n      yield put(successSearchByLocation(payload));\n    } else {\n      yield put(failureSearchByLocation(error));\n    }\n  }\n}\nfunction* handleRequestUser() {\n  while (true) {\n    const action = yield take(REQUEST_USER);\n    const { payload, error } = yield call(API.user, action.payload);\n    if (payload && !error) {\n      yield put(successUser(payload));\n    } else {\n      yield put(failureUser(error));\n    }\n  }\n}\nexport default function* rootSaga() {\n  yield fork(handleRequestUser);\n  yield fork(handleRequestSearchByLocation);\n}\n``\n. @mistre833 How about to separate login and logout flows and skip login if it's already authorized?\n. @mistre83 You callnext()with payload twice in your test code. Please remove the linegenerator.next({'payload': {'username': 'admin', 'password': 'admin'}});` like this.\nit('watchLogin Saga', (done) => {\n        const generator = watchLogin();\n        expect(generator.next().value).toEqual(take(actions.LOGIN_USER));\n        expect(generator.next({'payload': {'username': 'admin', 'password': 'admin'}}).value)\n            .toEqual(fork(loginCall, 'admin', 'admin'));\n        expect(generator.next().value).toEqual(take(actions.LOGIN_USER));\n        done();\n    });\n. Fix yield console.log(email); to console.log(email);. You can yield only redux-saga's effect objects from sagas.\n. Umm... I can't tell you clear hint but please try following (pseudo) code. In this code, I use Promise as a return value for dummy purpose. In real-world, you may use Fetch API and it return Promise object.\n``` es6\nfunction authorize(email, password) {\n  return new Promise((resolve, reject) => {\n    const session = 'fake';\n    console.log('in authorize');\n    resolve(session);\n  });\n}\nfunction* loginFlow() {\n  while (true) {\n    const submit_action = yield take(types.LOGIN_SUBMITTED);\n    const email = submit_action.payload.email;\n    const password = submit_action.payload.password;\n    console.log(email);\n    // Wait for auth\n    const session = yield call(authorize, email, password);\n    // Todo: Error handling to make sure success and failure of auth\n    // Dispatch action (move from authorize function)\n    yield put({type: types.LOGIN_SUCCESS, session});\n    // After we're logged in, only thing we can do is log out\n    // TODO: figure out what to actually do here?\n    if (session) {\n      yield take('LOGOUT')\n    }\n  }\n}\n``\n.takeeffect doesn't support RegExp aspattern` argument, but you can write a custom effect.\nDemo: http://kuy.github.io/redux-saga-examples/takex.html\nGitHub: https://github.com/kuy/redux-saga-examples/tree/master/takex\n``` es6\nfunction takexSaga(pattern) {\n  let action;\n  while (true) {\n    action = yield take('');\n    console.log('takex', action.type);\n    if (pattern.test(action.type)) {\n      console.log('takex:match', action.type);\n      break;\n    }\n    console.log('takex:ignore', action.type);\n  }\n  return action;\n}\nfunction takex(pattern) {\n  return call(takexSaga, pattern);\n}\nfunction* handleActions() {\n  while (true) {\n    const action = yield takex(/^FETCH_/);\n    console.log('handle', action.type);\n  }\n}\n``\n. In your 'react-redux-saga-messenger', use default export tocomponent and named export to saga. In the host application, you also needfork` messenger's saga in the root saga like this.\n``` es6\nimport { messenger } from 'react-redux-saga-messenger';\nexport default function* rootSaga() {\n  yield fork(yourSaga);\n  yield fork(messenger);\n}\n```\n. @sibelius We recommend you to ask a question on StackOverflow with redux-saga tag.\n. @sibelius Even if you have one or more Messenger components, messenger's saga is always needed one. So you don't need to worry about the conflict. Why? It's similar to Redux's reducers. When you have 10 tooltip components, do you need 10 reducers? The answer is No. All actions from tooltips are processed in one reducer because all tooltip components have the same business logic.\nYour Messenger component will provide <Messenger /> component, reducers, action types, action creators, and sagas.\n. @Moeriki Yes, it's a good workaround. I also use the same approach in my exmaple.\n. @sergej-s  We recommend you to ask on StackOverflow with redux-saga tag.\nUnfortunately, delay is not a redux-saga's effect, just a function that returns Promise object. So you need to use call effect in anotherSaga generator function.\nfunction* anotherSaga() {\n  yield call(delay, 1000);\n  console.log(2);\n}\n. @kefirchik We recommend you to ask on StackOverflow with redux-saga tag.\nIn this line, call effect won't wait for a callback of saveTicket function.\nes6\nconst { err, res } = yield call(saveTicket.call, ticket);\nPlease consider using eventChannel to handle a callback of saveTicket function properly.\neventChannel is often used integrating saga with external services that have a callback/event-based API.\nFor example, the following code is an example of using Page Visibility API of web browsers with redux-saga.\nhttps://github.com/kuy/redux-saga-examples/blob/master/startstop/sagas.js#L49\nDemo: http://kuy.github.io/redux-saga-examples/startstop.html\nGitHub: https://github.com/kuy/redux-saga-examples/tree/master/startstop\n. @mydearxym Please consider asking a question on StackOverflow with redux-saga tag next time \ud83d\ude04 \nYou can use race to implement a timeout like this.\nes6\nfunction* loginFlow() {\n  while (true) {\n    const { user, password } = yield take('LOGIN_REQUEST')\n    const { token, timeout } = yield race({\n      token: call(authorize, user, password),\n      timeout: call(delay, 3000)\n    });\n    // ...\n  }\n}\n. @Andarist Ah, you're right. I wanted to say that onerror doesn't follow camelcase but I forgot that JavaScript uses onerror in many places as a specification.. @yelouafi Thanks. The most of code and docs contains onError not onerror. In case of we adopt onError, it doesn't cause a huge impact to the users because API docs and the actual code use onError. The code that is not working is just three lines that verify the given options.\njs\n  if(options.onerror && !is.func(options.onerror)) {\n    throw new Error('`options.onerror` passed to the Saga middleware is not a function!')\n  }\nhttps://github.com/redux-saga/redux-saga/blob/b5e42c983a20715ecd4c627124a9f1ffb49168a1/src/internal/middleware.js#L43-L45\nI also choose onError but wait for replying @Andarist .. Even if API docs say onError, it's better to add a warning message for the users who spell onerror not onError.. @Andarist Thank you! I send PR for this. I'm happy if you help me on the review phase.. @schuchowsky  First, I'd like to explain a difference between while(true) and while(yield take(...)). If you don't need to use an action that is yielded from take effect, you may use while(yield take(...)) pattern. If you want to use an action, please use while(true) with var action = yield take(...).\n\nSo, my doubt is that I don't understand the need of having that while(true) loop, if we have takeEvery function.\n\nYes, you're right. But sometimes I feel it's overkill to always use takeEvery instead of while loop in small sagas.. @Andarist \n\nthe while(true) could be replaced by while (yield take (FETCH_POSTS), because the function yielded from take effect is not being used in that case, right?\n\nYes!\n\nOverkill? Hm... What would be the correct use for takeEvery then?\n\nTo use takeEvery, you need to split a saga. This is what I feel it's overkill for small sagas. For example, I use takeEvery to avoid dropping dispatched action.\njs\nfunction* watchFetch() {\n  while (true) {\n    yield take(FETCH_POSTS)\n    yield call(fetchPosts)\n  }\n}\nThis code will work well only if fetchPosts function returns quickly and FETCH_POSTS actions are not dispatched frequently. If nextFETCH_POSTS action is dispatched before calling of fetchPosts returns, it will lost (drop) FETCH_POSTS action. Since takeEvery = take + fork, dropping actions will not be occured in takeEvery. You can also avoid this issue by actionChannel.\n\nI feel like it's more readable using takeEvery because in one function I declare all my watchers.\n\nIt depends on a case you're facing. I would like to say that always using takeEvery is not wrong. If you don't feel splitting a saga is boring, it's not a problem \ud83d\ude03 . Thanks. There is no reason to use bracket notation. I fixed in a new commit.. ",
    "larsbs": "Yeah, that was it! Thanks for the quick response. So, in every next() call you have to pass the context/variable that the generator expects to exist, isn't it?\n. ",
    "kumar155": "Hi i have obstacle while testing my saga function which consists the different saga calls \nexport function* fetchFromSource() {\n  try {\n    const site = yield select(selectedSourceSite);\n    const siteId = site.Id;\n    const plant = yield select(selectedSourcePlant);\n    if (plant.Id !== undefined) {\n      const plantId = plant.Id;\n      const application = yield select(getRdsmApplicationSelected);\n      }\n   }\n}\nhere im writing the jest tests for this \ndescribe('fetch From Source', () => { \n    let generator = saga.fetchFromSource();\n    it('should return selectedSourceSite selector', () => {\n      expect(generator.next().value).toEqual(select(selectedSourceSite));\n    });\n    it('should return selectedSourcePlant selector', () => {\n      const genNext = generator.next();\n      console.log(genNext.value);\n      expect(genNext.value).toEqual(select(selectedSourcePlant));\n    });  \n}\nFirst selecte test is passing here when i'm testing the second select test is failing here when i remove the\nconst siteId = site.Id; this line from saga  function second select test  is passed , how to test this with siteId i need SiteId in the function but i'm not pasted full function here. ",
    "zalmoxisus": "Thanks a lot for such a fast fix! Works as expected now.\n. I think having intermediate states in the history is better as we can debug why and from where the user got redirected. If If you don't have to wait any async response before changing the state, the user will not get any intermediate states and React will render only the last one. You can find an example here.\n. You shouldn't have * in this case. See https://github.com/yelouafi/redux-saga/issues/124 and this post for more details.\nIt should be\njs\nexport default function* root() {\n  yield [\n      takeEvery(types.LOGIN_FACEBOOK.REQUEST, workerLoginEmailPass),\n      takeEvery(types.LOGIN_EMAIL.REQUEST, workerLoginFacebook)\n  ]\n}\nAlso, probably you want to use takeLatest to avoid simultaneous login requests.\n. @yelouafi, yes. I didn't have try-catch in doSomeStuff function as it just calls subtasks where I was catching the errors, but we need catching errors along all children tree, even if we can have nothing than SagaCancellationException there.\nTo clarify this, I have a lot of socket subscribers. When the category is changed, I cancel everything and subscribe again to new channels with new data. Since the watcher has a lot of subtasks children, there are a lot to cancel there.\n. Hey @evgenyt1.\nOne solution would be to use channels as described on SO. It is also planned to be supported out of the box.\nAnother solution would be just to use dispatch (and getState in your case) parameters passed into rootSaga. Though it seems uglier than above one, I usually use this solution for binding events. A bit harder to test, but cleaner and guaranteed that you'll not miss any event.\n. @evgenyt1, you could pass state to watchHistory and return true or false inside hashHistory.listenBefore listener, but it will recreate additional listener every time, so I removed that solution.\n. I tried a rough example as mentioned here, but don't seem to reproduce the issue.\n. Should be fixed in the latest version of the extension. @lukebarton please confirm.. There are 2 ways you can use remote-redux-devtools:\n\nAs a store enhancer (importing as default). In this case Redux DevTools enhancer is not aware of other enhancers, because they are applied before it. So, the dispatched actions from the monitor will not trigger sagas.\nAs a custom composer (importing composeWithDevTools), which is a workaround to solve this Redux limitation. In this case it should trigger sagas.\n\nDo you use the second approach? I guess, you accidentally imported default from remote-redux-devtools. If not, could you please share a repro?. @sglocastic, a PR to amend the README on remote-redux-devtools would be much appreciated.. ",
    "phaistonian": "This got me wondering too.\nThanks for resolving this.\n. Oh boy.\nA lot to grasp and refactor on Monday then :-)\n. ",
    "Gpx": ":+1: \n. :+1: again :smile: \n. No problem, I'm learning redux-saga and fixing one type here and there just takes few seconds.\n. ",
    "ALF-er": "Also, who will call mySaga.next() after each side-effect (put, call etc)?\n. Also, who will call mySaga.next() after each side-effect (put, call etc)?\n. ",
    "vovaguguiev": "@aikoven\n- do you really need to use take if you're able to trigger saga execution by dispatching it? \n- if so, I still don't see why it's not possible to have that effect working with dispatched saga. Same mechanism of subscribtion to internal action emmiter would perfectely work,  wouldn't it? \n@ALF-er \nside effects would be executed by the same middleware as now. I am not talking about getting rid of middleware\n. @yelouafi \nI totally see your point and agree that for certain situations the \"daemon\" approach fits better. But I was working on the redux-based application for quite a while and from my personal experience those scenarious you describe are somewhere around 10% of all use cases. They are important, but I really worry about the fact that all my business logic is detached from the views that call for it.\nI have an impression that we are moving towards eventEmitter approach and I am not a huge fan of that.\nSo basically the question I really wanted to ask is would the PR that adds support of dispatching sagas be appreciated? Just for sake of giving people an option to choose either push or pull approach. Or maybe the daemons approach is the only one that library wants to enforce,  which is perfectly fine as well btw)\n. @yelouafi\n\nCan you elaborate on this ? At a first glance it seems like a good thing to have this kind of decoupling. But I'd like to hear you opinion\n\nIt sounds good theoretically, but it's not that easy practically. We actually have all same problems as with eventEmitter based architecture. It becomes hard or (for really large apps) even impossible to find all the places that react to certain event. We dont have single entrypoint for your business logic anymore, instead application responds to your event from different places (multiple different sagas) which makes it hard to reason about the scope of that response. \nYou may say that we could create sort of one-to-one relationship between Action and Saga to be sure that we could easily find the corresponding Saga and don't bother searching through the entire app. But in this case we effectively getting back to the dispatch(saga) approach but with artificially created indirection (matching Action with our Saga)\n. @slorber fair enough. Maybe it makes sense to create a different library for those who prefer redux-thunk approach but with all goodies of declarative side effects and call, fork/join, put operators. Because trying to satisfy everyone we might break the library's consistency. \nOne question though, @slorber, was my analogy with EventEmitter right or maybe I just didn't get the idea? \n. @slorber thank you for explanation, it indeed reminds me of Backbone/Marionette apps that were highly relying on EventBus communication between components.\n@yelouafi thanks for examples, I'll try that\n. @aikoven nice trick! \nRegarding:\n\nStill I prefer to isolate every possible side-effect in Sagas and keep action creators pure.\n\nI don't see how the fact that you could dispatch sagas contradicts the idea of having pure action creators.\n. @ganarajpr man, I totally enjoy the generator based API for control flow and declarative side effects, but I think @kloy described exactly what are my concerns there. Sometimes having sagas as daemons is beneficial (e.g. for long lived business logic flow, like maybe login/logout flow). But most of the time on the front end you use short lived sagas that are spawned, executed and killed within couple of seconds. For latter I believe dispatching sagas is a better alternative, as an additional lib feature of course\n. ",
    "kloy": ":+1: \nDispatching generators like how thunks work is something I found to be missing as well. I understand that the same goal can be accomplished by triggering sagas inside of sagas. This however seems like additional boilerplate with little value for a good portion of use cases. My common use case for generators is to coordinate asynchronous behaviors for submitting forms. In traditional submit -> wait for response while showing some type of spinner forms a saga that is taking a submit action then starting a sub saga for the request seems like over kill. This is a very short lived saga and a more obvious implementation if dispatched as part of an onClick handler.\nI agree sagas taking actions is a good approach, and I am in no way advocating for the removal of this behavior. I am advocating for when a generator is dispatched the saga middleware handles and executes it as a new framework feature. By keeping these short lived processes closer to the initialization code (onClick -> dispatch action) you keep the code base simpler and easier to triage as it is declarative. If all sagas must wait for an action you add the additional overhead of first tracking down what action (event) is fired then searching in the codebase for that action type to locate the saga operating on it. If you have multiple sagas listening on the same action types this of course adds even more overhead of search for the effect. This quickly starts to smell like event soup when applied to all effects in a UI code base.\n. @yelouafi Thank you for the example. Below I have pasted a working middleware.\n``` javascript\nfunction isGenerator(fn) {\n  return typeof fn === 'function' && 'next' in fn.prototype && 'throw' in fn.prototype;\n}\nconst createSagaDispatcher = sagaMiddleware => () => next => action => {\n  if (isGenerator(action)) {\n    return sagaMiddleware.run(action).done;\n  }\nreturn next(action);\n};\nexport default createSagaDispatcher;\n```\nHere is an example of dispatching a generator...\nhttps://github.com/kloy/saga-playground/blob/master/src/index.js#L33\nThis is not meant as a good example of when to dispatch a generator, just a way for me to prove the functionality.\n. Thank you for the detailed explanation. \nI could see you getting the same issue opened for Rx, bacon, etc. What may be a better solution is to provide a facility for decorating call. Alternatively, I like the idea of actually implementing a pure eventEmitter since adapters already exist for many observable implementations. If you consider the approach of calling Promises or node style callbacks, the current philosophy seems to be one of interoperability with popular async strategies. With that said, I am very interested to see what you come up with as an alternative observable mechanism.\nIf I rephrased the issue to not be channel specific I think it may go something like...\n\"I would like to use my observable based framework that my code base already depends on with sagas\".\n. ",
    "panzerdp": "First of all, thanks for this awesome library!\nI faced almost the same issue. But with the difference that I need to take the latest action from a collection of different types.\nUnfortunately takeLatest('ACTION', handler) works with a single type of action.\nI implemented a custom effect named takeMultipleLatest() that accepts an object with keys as actions and values as corresponding handlers:\n```javascript\nfunction takeMultipleLatestSaga(sagasByPatterns, ...args) {\n  const patterns = Object.keys(sagasByPatterns);\n  const task = yield fork(function () {\n    let lastTask;\n    while (true) {\n      const action = yield take(patterns);\n      if (lastTask) {\n        yield cancel(lastTask);\n      }\n      lastTask = yield fork(sagasByPatterns[action.type], ...args.concat(action));\n    }\n  });\n  return task;\n}\nexport function takeMultipleLatest(sagasByPatterns) {\n  return call(takeMultipleLatestSaga, sagasByPatterns);\n}\n``\nThen it can be used almost the same astakeLatest()`, but with the difference that it supports multiple actions from which only the latest will be taken and other ones cancelled:\njavascript\n  yield takeMultipleLatest({\n    'ACTION1': handlerForAction1,\n    'ACTION2': handlerForAction2\n  });\nI hope someone will find it useful!\n. Hi @Andarist,\nI tried you first suggestion, and unfortunately it does not cancel the tasks of different types (i.e. ACTION1 cancels ACTION1, but ACTION1 does not cancel ACTION2). Maybe I'm missing something.\nThanks.. ",
    "dalexand": "Thank you. I forgot what call function returns plain object and tried to build complex constructions with yield operator inside map function.\n. ",
    "kjr247": "@yelouafi I'm loving your work these past few months especially. I came up with something similar to what you have here \nyield urls.map( url => call(parallelFetch, ...) )\nBut I'm needing the group of calls/forks to block eventually as a single task so that they don't block each other but in the end once they all finish then as a group they block.\nyield [ \n    urls.map( urls=> fork(parallelFetch, ...) ) \n ]\nWhat's your opinion on this? Do you think there is a better way? Is this redundant?\n. ",
    "jokeyrhyme": "One of the stated benefits of the actor approach is that becomes simple to redirect a navigation internally without the user seeing any intermediate states.\n. Thanks everyone, that's given me a lot to think about. :)\n. ",
    "mohebifar": "I used es6-symbol and it solved the issue.\nAt first, the error was \"Can't find variable Symbol\". So I imported babel-polyfill by mistake while I should had rather used es6-symbol mentioned in #54. For some reason that I still do not understand, it was passing the \"Symbol\" error and was stopping on \"not an iterator\" error instead.\n. ",
    "budarin": "thanks\n. @casertap \nhave you resolved the problem?\nI run into the same situation and can't figure what to do. HI @rahulbasu710 !\nRender with sagas should be completed into some steps:\n- start render with ruining sagas\n- configure 2nd render in Promise.all(store.getSagasPromises()).then(() => ...2n render with fiilled store ...) \n- send END command (store.dispatch(END);) to sagas to stop all sagas after finishing their work in order to run code in Promise  in step 2. maybe this thread will help you. I'm talking not about canceling a fetch task but about abort real http request. Hi !\nI use to superagent as HTTP request library\nSo, as I've understood, I have to save the instance returned by call superagent instance and than manually call abort/cancel method on it?. Thanks for the sample.\nBut I need to cancel running request not from within the same saga - it must be another saga which look for an action { CANCEL_UPLOADING_FILE, id }\nso I need to store result of the request in a store by id ?\n. repository - https://github.com/budarin/redux-saga-app\nstore.runSaga(rootSagas).done - doesn't resolve. but in real-world example https://github.com/redux-saga/redux-saga/blob/master/examples/real-world/server.js  store.runSaga(rootSaga).done.then resolves before dispatching END\n```\n      store.runSaga(rootSaga).done.then(() => {\n        console.log('sagas complete')\n        res.status(200).send(\n          layout(\n            renderToString(rootComp),\n            JSON.stringify(store.getState())\n          )\n        )\n      }).catch((e) => {\n        console.log(e.message)\n        res.status(500).send(e.message)\n      })\n  renderToString(rootComp)\n  store.close()\n\nand I don't know at what moment to dispatchEND```... especially if using code-splitting\n. you are right!\nI've missed it. Thanks a lot!. unfortunately it's hard to reproduce as a snippet - there a lot of infrastructure around it - redux, routing & etc\ncan you help me find a solution with an advice where to find?. Hi!\nYou are right! It was error in my code\nThanks a lot!. ",
    "mynameistechno": "Instead of depending on the fact that reducers execute before sagas, I'm wondering if it's less brittle and more explicit to have a saga trigger the reducer by putting another action. E.g.\njs\nfunction* updateItemSaga(item) {\n  yield put(putItemAction(item)) // this updates the state in a reducer\n  const item = yield select(getItemSelector); // grab the updated state\n  yield call(request.put, {path, item})\n}\nThoughts? We now need two actions, but it's arguably more readable/obvious?. ",
    "rmoorman": "@mynameistechno this is also how I approach this. Having the main flow/logic within sagas and not being split between sagas and something else interacting with the store can make things easier to follow IMO.. ",
    "csorfab": "\nInstead of depending on the fact that reducers execute before sagas, I'm wondering if it's less brittle and more explicit to have a saga trigger the reducer by putting another action. E.g.\njs\nfunction* updateItemSaga(item) {\n  yield put(putItemAction(item)) // this updates the state in a reducer\n  const item = yield select(getItemSelector); // grab the updated state\n  yield call(request.put, {path, item})\n}\nThoughts? We now need two actions, but it's arguably more readable/obvious?\n\nWell, now you depend on the assumption that put() returns after updating the state in the store... Which might not be the case if you use an async action middleware.. ",
    "j": "I'm probably being an annoying chime-in, but I just refactored from redux-thunk and it wasn't too painful... until I got to server-rendering for redux-saga.  I modified to fit #13 and and for me, the promise is completing before my api responds.  So far I thought I basically copy/pasted, but I guess I can dig further later.  None-the-less, it was slightly painful to do.\n. ",
    "will-harrison": "I'll dig into those. See if I can wrap my head around them a little more. Thanks.\n. ",
    "wasd171": "This looks like a lot of boilerplate code, unfortunately. Perhaps it should be merged into lib as some kind of utility?\nI personally feel that it might be achievable with runSaga and custom subscribe, which would probably look more natural. Unfortunately, it's still too complicated for me =(\n. ",
    "axelson": "We have a use-case for this as well since we're using websockets (via pusher.js). We thought about using the deferred pattern found in #51 but it is more code than we feel is necessary and we're worried that we might drop events.\n. We have a use-case for this as well since we're using websockets (via pusher.js). We thought about using the deferred pattern found in #51 but it is more code than we feel is necessary and we're worried that we might drop events.\n. I'd vote for just adding a delay() util function to the docs or a contrib folder.\n. I'd vote for just adding a delay() util function to the docs or a contrib folder.\n. @ronanwize that's a very interesting approach! Thanks for sharing. But wouldn't this still not catch uncaught exceptions in your doSomething() method? For example if the myLongRunningFunction() did not exist, than no error would be reported.\n. @ronanwize that's a very interesting approach! Thanks for sharing. But wouldn't this still not catch uncaught exceptions in your doSomething() method? For example if the myLongRunningFunction() did not exist, than no error would be reported.\n. If END is usually not expected, would it make more sense for take() to raise an exception if END is received? Otherwise wouldn't we have to specifically check for END every time we do a take()?\n. If END is usually not expected, would it make more sense for take() to raise an exception if END is received? Otherwise wouldn't we have to specifically check for END every time we do a take()?\n. IMO checking the type of error is preferable because I do not have many try/catch blocks, but I do have many take() calls. I have some sagas with 6+ take() calls, so rather than change all of them to check for END, just one try/catch could be added that would check for an END.\nAlthough I'm not trying to claim that I know enough to make a well-reasoned decision, just giving my 2 cents.\n. IMO checking the type of error is preferable because I do not have many try/catch blocks, but I do have many take() calls. I have some sagas with 6+ take() calls, so rather than change all of them to check for END, just one try/catch could be added that would check for an END.\nAlthough I'm not trying to claim that I know enough to make a well-reasoned decision, just giving my 2 cents.\n. It looks to me like the current behavior of takeEvery in 0.10.5 still doesn't handle the example laid out in  MichalBures comment on April 25th: https://github.com/yelouafi/redux-saga/issues/277#issuecomment-214477089 \nI think this should be added as a note to the API documentation of takeEvery or change the implementation of takeEvery to add an automatic delay in the saga being executed. For now I am working around it by calling a fixedTakeEvery.\nfunction * fixedTakeEvery (pattern, saga) {\n  const worker = function * (...args) {\n    yield Promise.resolve()\n    yield fork(saga, ...args)\n  }\n  yield * takeEvery(pattern, worker)\n}\nThe bottom line is that I don't expect takeEvery to miss any actions, even if those actions are created by the saga that is run by takeEvery. Also let me know if I should open this as a new ticket.\n. It looks to me like the current behavior of takeEvery in 0.10.5 still doesn't handle the example laid out in  MichalBures comment on April 25th: https://github.com/yelouafi/redux-saga/issues/277#issuecomment-214477089 \nI think this should be added as a note to the API documentation of takeEvery or change the implementation of takeEvery to add an automatic delay in the saga being executed. For now I am working around it by calling a fixedTakeEvery.\nfunction * fixedTakeEvery (pattern, saga) {\n  const worker = function * (...args) {\n    yield Promise.resolve()\n    yield fork(saga, ...args)\n  }\n  yield * takeEvery(pattern, worker)\n}\nThe bottom line is that I don't expect takeEvery to miss any actions, even if those actions are created by the saga that is run by takeEvery. Also let me know if I should open this as a new ticket.\n. Yes here you go:\n```\nexport default function * rootSaga () {\n  yield fork(watchPing)\n  yield put({type: 'PING', val: 0})\n}\nfunction * watchPing () {\n  yield * takeEvery('PING', ackWorker)\n  // yield * fixedTakeEvery('PING', ackWorker)\n}\nlet first = true\nfunction * ackWorker (action) {\n  // yield Promise.resolve()\n  if (first) {\n    first = false\n    yield put({type: 'PING', val: action.val + 1})\n    yield take(ACK-${action.val + 1})\n  }\n  yield put({type: ACK-${action.val}})\n}\nexport function * fixedTakeEvery (actionType, saga) {\n  const worker = function * (...args) {\n    yield Promise.resolve()\n    yield fork(saga, ...args)\n  }\n  yield * takeEvery(actionType, worker)\n}\n```\nThe above code results in PING, PING, ACK-1. But if you uncomment the yield Promise.resolve() or switch from takeEvery() to fixedTakeEvery() you will get the full sequence of PING, PING, ACK-1, ACK-0.\nI tried to put this into an actual test case, but I'm getting different behavior (although the test is still failing).\n```\ntest('inter-saga fork/take back from forked child 3', assert => {\n  assert.plan(1);\nconst actual = []\n  const chan = channel()\nconst middleware = sagaMiddleware()\n  const store = createStore(() => {}, applyMiddleware(middleware))\nlet first = true\nfunction* root() {\n    yield [fork(watchPing)]\n  }\nfunction* watchPing () {\n    yield * takeEvery('PING', ackWorker)\n    // yield * fixedTakeEvery('PING', ackWorker)\n  }\nfunction* ackWorker (action) {\n    // yield Promise.resolve()\n    if (first) {\n      first = false\n      yield put({type: 'PING', val: action.val + 1})\n      yield take(ACK-${action.val + 1})\n    }\n    yield put({type: ACK-${action.val}})\n    actual.push(1)\n  }\nfunction* fixedTakeEvery (actionType, saga) {\n    const worker = function * (...args) {\n      yield Promise.resolve()\n      yield fork(saga, ...args)\n    }\n    yield * takeEvery(actionType, worker)\n  }\nmiddleware.run(root).done.then(() => {\n    assert.deepEqual(actual, [1,1],\n      \"Sagas must take actions from each forked childs doing Sync puts\"\n    );\n    assert.end();\n  })\nstore.dispatch({type: 'PING', val: 0})\n  store.dispatch(END)\n});\n```\nIn the test case actual ends up with just [1] which is expected. But I would expect that uncommenting the yield Promise.resolve() which give [1,0], but instead it gives [].\n. Yes here you go:\n```\nexport default function * rootSaga () {\n  yield fork(watchPing)\n  yield put({type: 'PING', val: 0})\n}\nfunction * watchPing () {\n  yield * takeEvery('PING', ackWorker)\n  // yield * fixedTakeEvery('PING', ackWorker)\n}\nlet first = true\nfunction * ackWorker (action) {\n  // yield Promise.resolve()\n  if (first) {\n    first = false\n    yield put({type: 'PING', val: action.val + 1})\n    yield take(ACK-${action.val + 1})\n  }\n  yield put({type: ACK-${action.val}})\n}\nexport function * fixedTakeEvery (actionType, saga) {\n  const worker = function * (...args) {\n    yield Promise.resolve()\n    yield fork(saga, ...args)\n  }\n  yield * takeEvery(actionType, worker)\n}\n```\nThe above code results in PING, PING, ACK-1. But if you uncomment the yield Promise.resolve() or switch from takeEvery() to fixedTakeEvery() you will get the full sequence of PING, PING, ACK-1, ACK-0.\nI tried to put this into an actual test case, but I'm getting different behavior (although the test is still failing).\n```\ntest('inter-saga fork/take back from forked child 3', assert => {\n  assert.plan(1);\nconst actual = []\n  const chan = channel()\nconst middleware = sagaMiddleware()\n  const store = createStore(() => {}, applyMiddleware(middleware))\nlet first = true\nfunction* root() {\n    yield [fork(watchPing)]\n  }\nfunction* watchPing () {\n    yield * takeEvery('PING', ackWorker)\n    // yield * fixedTakeEvery('PING', ackWorker)\n  }\nfunction* ackWorker (action) {\n    // yield Promise.resolve()\n    if (first) {\n      first = false\n      yield put({type: 'PING', val: action.val + 1})\n      yield take(ACK-${action.val + 1})\n    }\n    yield put({type: ACK-${action.val}})\n    actual.push(1)\n  }\nfunction* fixedTakeEvery (actionType, saga) {\n    const worker = function * (...args) {\n      yield Promise.resolve()\n      yield fork(saga, ...args)\n    }\n    yield * takeEvery(actionType, worker)\n  }\nmiddleware.run(root).done.then(() => {\n    assert.deepEqual(actual, [1,1],\n      \"Sagas must take actions from each forked childs doing Sync puts\"\n    );\n    assert.end();\n  })\nstore.dispatch({type: 'PING', val: 0})\n  store.dispatch(END)\n});\n```\nIn the test case actual ends up with just [1] which is expected. But I would expect that uncommenting the yield Promise.resolve() which give [1,0], but instead it gives [].\n. @yelouafi Published as issue #413 \n. Thanks for the detailed response! I'll keep that in mind for the workaround that I'm doing.\n. I think a good step for me would be an easy way to only test the effects that I care about. So I generally don't care about when and in what order my saga is calling select, but I definitely do care for put and call. take is a little situational but I usually care about it.\n. @Andarist You are correct that you cannot dispatch within a reducer, that was a typo, I am dispatching within a saga.\nYour suggested solution works but the data in question is a list of entities that's potentially 500+ long and the EXTERNAL_UPDATE only affects one of them so I'd rather not cache all of them.\nI ended up going with creating a new event channel but I still think it would be nice to have something built into redux-saga to help with this case. Maybe a custom/new effect. It could operate like a hybrid of take and select\nfunction takeWithPreviousState(pattern, previousStateSelector)\nIt would return when pattern is matched but in addition to returning action it would return the result of the previousStateSelector run against the state immediately before the action matching pattern was processed by the reducers.\n. Here's my 2 cents, worth what you paid for it:\nI really like the idea in general, testing right now IMO is overly tied to the internal implementation. While I think the effect interceptors may be a good choice for a low-level primitive that will aid testing. I can't reasonably see myself constructing them due to the complicated signature/behavior:\n```\ninterceptors: {\n    call({context, fn, args}, execBuiltin, cb) {\n      if(fn === api.fetchData) {\n        cb(mockApiResults.shift())\n      } else {\n        execBuiltin(cb)\n      }\n    },\n    put({action}, execBuiltin, cb) {\n       // exec both builtin (dispatch to store) && custom (store dispatched actions)\n       //  We could have monkey-patched the store.dispatch function but this would give us\n       //  all dispatched actions (both dispatched by the Saga and from outside)\n       // With this we're only interested in the actions dispatched by this Saga\n   dispatchedActions.push(action)\n   execBuiltin(cb)\n}\n\n} \n```\nBut I could see myself doing something like #518 and running the saga with the full set of reducers and a given initial state but requiring certain effects such as call to be mocked so that we're limiting effect/state-riddled code (since the reducers should be pure). But it would probably be easiest as a library on top of redux-saga, or something built on top of the lower-level primitives.\n. As a work-around for this in Chrome devtools you can filter your logs to not include these logs. Filter for /^((?!has been cancelled).)*$/ which is a regex that excludes lines with has been cancelled.. Can this at least be changed to a verbose-level while waiting for a fuller fix? That would make it easier to filter out.. As a user it would be nice to have throttle imported in this example so that I know where to find it from.\n. ",
    "paulxtiseo": "My issue was different, but thanks for the notification.\n. ",
    "jwhitley": "@paulxtiseo, I'm having trouble getting sagaMonitor to run in my RN app.  Did you have to do anything unusual to get the monitor to work with RN?\nFWIW, I've verified it's being imported correctly, but I'm not seeing any saga logging in the Chrome debugger, nor is $$LogSagas() defined in the debugger console.  My store is being created using a fairly standard setup:\njavascript\nexport default function configureStore(initialState) {\n  return createStore(\n    reducer,\n    initialState,\n    applyMiddleware(\n      sagaMonitor,\n      createSagaMiddleware(...sagas)\n    )\n  );\n}\n. ",
    "tsemerad": "When I start the app, it will log \"inside rootSaga!\" and the console shows 2 EFFECT_TRIGGERED actions, followed by 2 EFFECT_RESOLVED actions. The action.effect.FORK.fn of the EFFECT_TRIGGERED actions is routingSaga, as is the action.result.FORK.fn of the EFFECT_RESOLVED actions. It never logs \"inside routingSaga!\", and none of the generator functions in /sagas/routing.js are triggered in response to actions anymore.\n/sagas/index.js\n``` javascript\nimport { fork } from 'redux-saga/effects';\nimport routingSaga from './routing';\nexport default function* rootSaga() {\n  console.log('inside rootSaga!');\n  yield [\n    fork(routingSaga),\n  ]\n}\n```\n/sagas/routing.js\n``` javascript\nimport { takeEvery } from 'redux-saga'\nimport { take, call, fork, put, select } from 'redux-saga/effects'\nimport * as types from '../constants/ActionTypes';\nimport * as toolNames from '../constants/ToolNames';\nimport * as routingActions from '../actions/RoutingActions';\nimport { requestPolylineRoute } from '../utils/routing';\nimport { getRoutingCoordinates } from '../selectors';\nfunction* getPolylineRoute(action) {\n   try {\n      const responseJson = yield call(requestPolylineRoute, action.fromLatLng, action.toLatLng);\n      const route = responseJson.routes[0];\n      yield put(routingActions.getRouteSuccess(route))\n   } catch (err) {\n      yield put(routingActions.getRouteFailure(err));\n   }\n}\nfunction* getRouteIfWeHaveOriginAndDestination(action) {\n  // if we activate the Routing tool, request a route\n  const state = yield select(); // passing in undefined gets current state\n  const { currentLocation, targetLocation } = state;\n  if (currentLocation && targetLocation) {\n    yield put(routingActions.getRouteRequest(currentLocation, targetLocation));\n  }\n}\nfunction watchActivateRoutingTool() {\n  const conditions = action => action.type === types.ACTIVATE_TOOL && action.id === toolNames.TOOL_ROUTING;\n  yield takeEvery(conditions, getRouteIfWeHaveOriginAndDestination)\n}\nfunction handleSetTargetLocation(action) {\n  const routingToolIsActive = yield select(state => state.tools.get(toolNames.TOOL_ROUTING).active);\n  if (routingToolIsActive) {\n    yield getRouteIfWeHaveOriginAndDestination(action)\n  }\n}\nfunction watchSetTargetLocation() {\n  yield takeEvery(types.SET_TARGET_LOCATION, handleSetTargetLocation)\n}\nfunction watchGetRouteRequest() {\n  yield takeEvery(types.GET_ROUTE_REQUEST, getPolylineRoute);\n}\nexport default function* routingSaga() {\n  console.log('inside routingSaga!')\n  yield [\n    fork(watchActivateRoutingTool),\n    fork(watchGetRouteRequest),\n    fork(watchSetTargetLocation),\n  ]\n}\n```\n/store/configureStore.js\n``` javascript\nimport { applyMiddleware, createStore, compose } from 'redux';\nimport thunkMiddleware from 'redux-thunk';\nimport createSagaMiddleware from 'redux-saga'\nimport createLogger from 'redux-logger';\nimport rootReducer from '../reducers';\nimport rootSaga from '../sagas';\nimport Immutable from 'immutable';\nconst loggerMiddleware = createLogger({\n  // transform logged Immutable objects into regular JS, so it is human readable\n  transformer: (state) => {\n    const newState = {};\n    for (const i of Object.keys(state)) {\n      if (Immutable.Iterable.isIterable(state[i])) {\n        newState[i] = state[i].toJS();\n      } else {\n        newState[i] = state[i];\n      }\n    }\n    return newState;\n  }\n});\nconst sagaMiddleware = createSagaMiddleware(rootSaga);\n// array of middleware we want in all environments\nconst middleware = [thunkMiddleware, sagaMiddleware];\nlet createStoreWithMiddleware;\n// In production, we want to use just the middleware.\n// In development, we want to use some store enhancers from redux-devtools.\n// UglifyJS will eliminate the dead code depending on the build environment.\nif (process.env.NODE_ENV === 'production') {\n  createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);\n} else {\n  const { devTools, persistState } = require('redux-devtools');\n  createStoreWithMiddleware = compose(\n    applyMiddleware(...middleware, loggerMiddleware), // only log when not in production\n    devTools(),\n    persistState(\n      window.location.href.match(/[?&]debug_session=([^&]+)\\b/)\n    )\n  )(createStore);\n}\nexport default function configureStore(initialState) {\n  const store = createStoreWithMiddleware(rootReducer, initialState);\nif (module.hot) {\n    // Enable Webpack hot module replacement for reducers\n    module.hot.accept('../reducers', () => {\n      const nextRootReducer = require('../reducers');\n      store.replaceReducer(nextRootReducer);\n    });\n  }\nreturn store;\n}\n``\n. Here's the$$LogSagas()` output.\n\nI then decided to try using routingSaga as the root saga. It did log \"inside routingSaga!\" as expected, but it seems to \"short-circuit\" in the same way as the index.js root saga:\n\n. I'm using babel-core@5.8.22 with webpack@1.12.13, webpack-core@0.6.8, webpack-dev-server@1.10.1, and webpack-dev-middleware@1.2.0. I am building an Electron app, using electron-prebuilt@0.30.5. I have the babel polyfill set up and have been using other functionality that requires the polyfill. \nThe sagas were running fine in my dev environment, until I packaged a build of the Electron app, and launched the packaged build. I noticed that in the packaged app the generators weren't triggering, so I went back to my dev environment and launched that and it too had stopped triggering the sagas. I tried it on a separate Macbook with a newer OS and fresh node install, but it too wasn't triggering the sagas. So I'm pretty sure there's in issue with my combination of packages - it just strikes me as odd that the sagas had been working, and I hadn't changed a single package since then.\nThanks a lot for trying to help me with this. I greatly appreciate it.\n. Yes, I will give that a try. Thanks for the advice.\n. I've updated my project to babel 6, and the latest electron. Specifically, babel-core 6.3.26 and babel-polyfill 6.3.14, and electron 0.36.8 (which uses Node 5.1.1). I first upgraded just babel, but it didn't fix the saga issue, so I upgraded electron as well. I've rebuilt all of my node_modules in Node 5.1.1 (previously was using 0.12). The app runs normally except the sagas still aren't working.\n. I'm going to try setting up sagas in the boilerplate project that my project is based on, electron-react-boilerplate, to see if I can reproduce the problem there.\n. It's working! Thank you so much for your work on this awesome library. I was not looking forward to rewriting my sagas as thunks.\n. ",
    "manjeetwadi": "@tsemerad what solution had you adopted. @angemile09 never able to find a solution, moved to redux-thunk. ",
    "angemile09": "@tsemerad @manjeetwadi  hi, what is your solution???. @Andarist can you help me with this?. @yelouafi could you help me with this??. @Andarist could you help me with this??. @Fazt hola! sabes mi me puedes ayudar con este tema??. ",
    "joshwcomeau": "@slorber I did the following:\n``` js\n      console.log(\"Start new state\", performance.now())\n  const newState = state.updateIn([FUTURE, 'nodes'], nodes => {\n    return nodes.map( (node, index) => {\n      return nodeIndex === index\n      ? node.set( 'selected', true )\n      : node.set( 'rejected', true );\n    });\n  });\n\n  console.log(\"Finish new state\", performance.now())\n\n  return newState\n\n```\nAnd got the following:\nStart new state 5387.865000000001\nFinish new state 5388.795\nSo yeah, that part takes less than 1 millisecond. It isn't the problem.\nI did notice, when putting more logs in the reducer, that there is a lot of stuff happening and I'm not sure why:\n\nThis looks wrong for so many reasons. Things are being resolved before being triggered.\nHere's what the redux thunk version looks like:\n\nTo use it, I just changed the action to:\njs\nexport function selectArtist(node) {\n  return (dispatch, getState) => {\n    dispatch({\n      type: SELECT_ARTIST,\n      node\n    })\n    dispatch({\n      type: MARK_ARTIST_AS_SELECTED,\n      node\n    })\n  }\n}\n(EDIT: Added both actions so that it's a 100% fair comparison)\nAt a loss as to what could be wrong, I followed the intro tutorial pretty closely.. Appreciate any light anyone can shed!\n. Not sure what you mean by the execution time of the action inside the reducer, I believe I am doing that. I start the \"clock\" before the state mutation, and end it right before returning the new state. I believe if the reducer's operations was the problem, it would be consistently slow between Redux Saga and the Thunk alternative. I could be mistaken though.\nI am not using a saga monitor.\nI'm at work now so I can't edit it right now, but I will post what you've asked for this evening :) Thanks for your help!\nThe other thing I'm unclear about is if that sequence of events in the reducer is correct. Is there a bug in my saga code? Why are 3 effects being triggered, and why are they resolved before being triggered?\n. @slorber Thanks for the tip about redux-ignore!\n@yelouafi thanks so much for spending the time experimenting with this :) am I correct in assuming that development mode is disabled the same way as in production? By setting process.env.NODE_ENV?\nWill post an update later when I've had the chance to experiment with dev/prod mode.\n. Success! Switching to production mode lowers it to just 11ms :D\nSo glad I get to keep using redux saga. Thanks again @slorber and @yelouafi!\n\n. ",
    "eric-burel": "Hi,\nThis should not be closed, as it is not solved: switching to prod isn't a solution, I may not want my saga to lag on dev too.\nThere should be some way to disable those debug events by configuring redux-saga (or some doc about it, I may have missed something :) ).. Okay, actually redux-logger seemed to be the responsible of lag issues in my case, it was the first I investigated and it succeed, saga does not seem to create much troubles. Thanks for the very quick answer!. Hi, \nSince this issue is open, I'll try my luck.\nThe doc is not explicit about how to sequence a dynamic array of sagas.\njs\nyield race({\n      cancel: take('FOO'),\n      // TODO : should run in sequence ! not in parallel !\n      update: all(bars.map(bar => call(asyncFunc, bar)))\n    });\nI can't find a syntax that wait for asyncFunc to end before triggering the next call.. Hi, thanks for your answer, I managed to write this in the end :) I don't like the need to use a for loop though, maybe a sequence([array]) effect would be cool to provide coherence withe the all([array]) effect.. ",
    "rwieruch": "Redux Saga uses the all function in the recent version (0.15.3) where you can combine multiple sagas to one root saga for the Redux store.\nimport { takeEvery, all } from 'redux-saga/effects';\n\n...\n\nfunction *watchAll() {\n  yield all([\n    takeEvery(\"FRIEND_FETCH_REQUESTED\", fetchFriends),\n    takeEvery(\"CREATE_USER_REQUESTED\", createUser)\n  ]);\n}. Redux Saga has the `all` function in the recent version (0.15.3) to combine multiple sagas to one root saga for the Redux store.\n\nimport { takeEvery, all } from 'redux-saga/effects';\n\n...\n\nfunction *watchAll() {\n  yield all([\n    takeEvery(\"FRIEND_FETCH_REQUESTED\", fetchFriends),\n    takeEvery(\"CREATE_USER_REQUESTED\", createUser)\n  ]);\n}.\n",
    "andredp": "Is it ok to do this?\n```javascript\n// foo.js\nexport function *fooSagas() {\n  yield all([\n    takeEvery(\"FOO_A\", fooASaga),\n    takeEvery(\"FOO_B\", fooBSaga),\n  ]);\n}\n// bar.js\nexport function *barSagas() {\n  yield all([\n    takeEvery(\"BAR_A\", barASaga),\n    takeEvery(\"BAR_B\", barBSaga),\n  ]);\n}\n// index.js\nimport { fooSagas } from './foo';\nimport { barSagas } from './bar';\nexport default function* rootSaga() {\n  yield all([\n    fooSagas,\n    barSagas\n  ])\n}\n```\nIs there any downsides on doing that? I like to use takeEvery (I think it's more idiomatic than hand-writing the infinite loop, and it's faster to test the actual forked saga), but I don't know if I should compose them that way. \nI have a rootSaga now which spawns all the sagas with takeEvery, but I think it's more organized to have them in the respective files and it's easier to check which actions spawns the saga in that file.. @Andarist,\nThank you so much for the explanation, it all makes more sense now. \ud83d\udc4d. @granmoe is there any reason that can happen in a normal situation? \nI mean, if you test your sagas you expect your program to behave correctly... Thus, if a saga throws, there's something you're not testing (nor expecting) and the Application is left in an unstable state... So if one throws, not sure if you really want the other ones working.. ",
    "fend25": "@Andarist \nThank you!\nI've found correct import path right after I posted a question here.\nSorry for worrying you.. ",
    "jfconde": "@Andarist thank you very much. We will follow this pattern in our projects :). ",
    "eseQ": "@Andarist, i use like u say, but have warning:\n[...effects] has been deprecated in favor of all([...effects]), please update your code. ",
    "SmirnovW": "@Andarist could u answer please, what a difference between a\nexport default function* rootSaga() {\n    yield [\n        fork(fooSagas),\n        fork(booSagas),\n    ];\n}\nand\nexport default function* rootSaga() {\n  yield all([\n    fooSagas,\n    booSagas,\n  ])\n}\nWhat should I prefer to use?. @Andarist yes, this is the same things, and of course, the second example should be with called functions :) . @tomoyukim hurry dude, we can't live without it! :). @Andarist ok, I don't want to demand anything from anybody. I just wanted to say that this is very cool and really needed feature.\n@tomoyukim sorry if that was rude :(. ",
    "dfee": "I just saw this, and was reviewing this https://github.com/redux-saga/redux-saga/issues/160#issuecomment-308529293\n```javascript\n// index.js\nimport { fooSagas } from './foo';\nimport { barSagas } from './bar';\nexport default function* rootSaga() {\n  yield all([\n    fooSagas,\n    barSagas\n  ])\n}\n```\nIt seems to me that you actually have to call the function to get an awaitable (sorry, that's Python speak, maybe in the JS world that's actually a promise that's returned).\n```javascript\n// index.js -- correct\nimport { fooSagas } from './foo';\nimport { barSagas } from './bar';\nexport default function* rootSaga() {\n  yield all([\n    fooSagas(),\n    barSagas()\n  ])\n}\n```. ",
    "erikras": "I have not fully wrapped my head around redux-saga yet. What sort of API changes from redux-form would make integration with redux-saga easier? e.g. callbacks instead of promises?\n. ",
    "tokenvolt": "@rosendi \nI'm doing this way.\nIn the form component:\njs\nonSubmit: (values) => {\n  return new Promise((resolve, reject) => {\n    dispatch(someActionCreator({ values, resolve, reject }))\n  });\n}\nIn saga:\njs\nfunction* saga() {\n  while (true) {\n    const { payload: { values, resolve, reject } } = yield take(TYPE)\n    // use resolve() or reject() here\n  }\n}\n. @smashercosmo Thank you, I'll take a look into redial, seems like my problem is not a redux-saga concern. \n. ",
    "timothyallan": "A 'gotcha' for the solution via @tokenvolt is that connect must be first, (or last depending how you look at it!), in the chain if you are using it. i.e.\nexport default (connect(\n  mapStateToProps, mapDispatchToProps)(\n  reduxForm(\n    { form: 'loginForm', validate }\n  )(LoginPage)));\nworks great, whereas \nexport default reduxForm({ form: 'loginForm', validate })(\n    connect(mapStateToProps, mapDispatchToProps\n   ) ((LoginPage)));\nwill error on submit asking for a handleSubmit() function. \n. Ahh right, I see that the older version 5 exposes (or at least replicates connect()). Version 6 doesn't.\n. It's much nicer actually :) http://redux-form.com/6.0.0-alpha.15/docs/api/ReduxForm.md/\n. ",
    "igorbarbashin": "@tokenvolt Thanks, it kinda works. I see the STOP_SUBMIT action.\nBut how do I pass validation errors?\nI tried\njavascript\nreject({ username: 'Username doesn\\'t exist' });\nyield call(reject, 'Username doesn\\'t exist');\nNone of them worked. (I'm on redux-form 6 alpha)\nFor now my solution is to use stopSubmit action creator\njavascript\nimport { stopSubmit } from 'redux-form';\n. . . \nyield put(stopSubmit('Login', { username: 'Username doesn\\'t exist', password: 'And your password sucks' }));\nIs there a better solution?\n. Nevermind, I've figured it out.\nThis is the right way to do it:\n``` javascript\nimport { SubmissionError } from 'redux-form';\n. . .\nreject(new SubmissionError({ username: 'Username doesn\\'t exist', password: 'Please enter your password' }));\n// or yield for better testability\nyield call(reject, new SubmissionError({ username: 'Username doesn\\'t exist', password: 'Please enter your password' }));\n```\nThanks for your comment, it helped a lot!\n. ",
    "angelyordanov": "I've refined the solution of @tokenvolt with the help of a saga that would listen for success/failure actions and resolve/reject a promise returned to the redux-form. The idea being that one needs to just tell the form what action it should dispatch on submit and what actions it should wait for on success or failure.\nIt's used like that.\nexport const LoginForm = reduxForm({\n  form: 'loginForm',\n  fields: ['email', 'password'],\n  onSubmit: onSubmitActions(LOGINFORM_SUBMIT, LOGINFORM_SUCCESS, LOGINFORM_FAILURE),\n})(LoginFormComponent);\nfunction* loginSaga() {\n  const { payload: { email, password } } = yield take(LOGINFORM_SUBMIT);\n  // check if the user/pass are correct\n  // ....\n  if (success) {\n    yield put(LOGINFORM_SUCCESS);\n  } else {\n    yield put(LOGINFORM_FAILURE, { _error: 'Incorrect user/password' });\n  }\n}\nThe submit action's payload is the fields object and the payload for the failure action is the field errors object expected from redux-form.\nAnd here is the full onSubmitActions code.\n```\nimport { put, take, race } from 'redux-saga/effects';\nimport { takeEvery } from 'redux-saga';\nexport const FORM_SUBMIT = 'redux-form-submit-actions/FORM_SUBMIT';\nexport function formSubmit(submitAction, successAction, failureAction, values, resolve, reject) {\n  return {\n    type: FORM_SUBMIT,\n    payload: {\n      submitAction,\n      successAction,\n      failureAction,\n      values,\n      resolve,\n      reject,\n    },\n  };\n}\nexport function onSubmitActions(submitAction, successAction, failureAction) {\n  return (values, dispatch) =>\n    new Promise((resolve, reject) => {\n      dispatch(formSubmit(submitAction, successAction, failureAction, values, resolve, reject));\n    });\n}\nfunction* formSubmitSaga({\n  payload: {\n    submitAction,\n    successAction,\n    failureAction,\n    values,\n    resolve,\n    reject,\n  },\n}) {\n  yield put({ type: submitAction, payload: { ...values } });\nconst { success, failure } = yield race({\n    success: take(successAction),\n    failure: take(failureAction),\n  });\nif (success) {\n    resolve();\n  } else {\n    reject(failure.payload);\n  }\n}\nexport function watchFormSubmitSaga() {\n  yield takeEvery(FORM_SUBMIT, formSubmitSaga);\n}\n```\n. ",
    "bghveding": "@angelyordanov This works great, thanks :)\nDo note that V6 of redux-form expects an instance of SubmissionError for errors now (http://redux-form.com/6.0.0-alpha.15/docs/api/SubmissionError.md/)\ne.g. \nreject(new SubmissionError(failure.payload));\n. @angelyordanov This works great, thanks :)\nDo note that V6 of redux-form expects an instance of SubmissionError for errors now (http://redux-form.com/6.0.0-alpha.15/docs/api/SubmissionError.md/)\ne.g. \nreject(new SubmissionError(failure.payload));\n. ",
    "jcheroske": "Using redux-actions, I created this simple action creator to help with @tokenvolt's pattern:\n```\nimport { identity, noop } from 'lodash'\nimport { createAction } from 'redux-actions'\nconst payloadCreator = identity;\nconst metaCreator = (_, resolve = noop, reject = noop) => ({ resolve, reject });\nexport const promiseAction = (type) => createAction( type, payloadCreator, metaCreator );\n```\nThis allows actions to be fired with just a quick:\ndispatch(someActionCreator(payload, resolve, reject));\nThe saga signature then simply looks like:\nfunction* handleSomeAction({ payload, meta: {resolve, reject} }) {\nBecause there are noop resolve and reject default functions, two things get simpler:\n- The action creator can be used outside of a promise context.\n- The saga is free to blindly call the promise methods\nSo, calling the action creator without the promise still works:\n```\ndispatch(someActionCreator(payload));\nfunction* handleSomeAction({ payload, meta: {resolve, reject} }) {\n  try {\n    yield call(doTheThing);\n    yield call(resolve); \n  } catch (error) {\n    yield call(reject, error); \n  }\n}\n```\nThe last piece is a little function that that I called bindActionToPromise (which might be a really sucky name):\nexport const bindActionToPromise = (dispatch, actionCreator) => payload => {\n  return new Promise( (resolve, reject) => dispatch( actionCreator(payload, resolve, reject) ) );\n};\nThe complete pattern then looks like:\n```\nconst someActionCreator = promiseAction(SOME_ACTION_TYPE);\nconst mapDispatchToProps = (dispatch) => ({\n  onSubmit: bindActionToPromise(dispatch, someActionCreator)\n});\nfunction watchSomeAction() {\n  yield takeEvery(SOME_ACTION_TYPE, handleSomeAction);\n}\nfunction* handleSomeAction({ payload, meta: {resolve, reject} }) {\n  try {\n    yield call(doTheThing);\n    yield call(resolve); \n  } catch (error) {\n    yield call(reject, error); // Convert to SubmissionError here if needed\n  }\n}\n```\nHope this helps someone.\n. Using redux-actions, I created this simple action creator to help with @tokenvolt's pattern:\n```\nimport { identity, noop } from 'lodash'\nimport { createAction } from 'redux-actions'\nconst payloadCreator = identity;\nconst metaCreator = (_, resolve = noop, reject = noop) => ({ resolve, reject });\nexport const promiseAction = (type) => createAction( type, payloadCreator, metaCreator );\n```\nThis allows actions to be fired with just a quick:\ndispatch(someActionCreator(payload, resolve, reject));\nThe saga signature then simply looks like:\nfunction* handleSomeAction({ payload, meta: {resolve, reject} }) {\nBecause there are noop resolve and reject default functions, two things get simpler:\n- The action creator can be used outside of a promise context.\n- The saga is free to blindly call the promise methods\nSo, calling the action creator without the promise still works:\n```\ndispatch(someActionCreator(payload));\nfunction* handleSomeAction({ payload, meta: {resolve, reject} }) {\n  try {\n    yield call(doTheThing);\n    yield call(resolve); \n  } catch (error) {\n    yield call(reject, error); \n  }\n}\n```\nThe last piece is a little function that that I called bindActionToPromise (which might be a really sucky name):\nexport const bindActionToPromise = (dispatch, actionCreator) => payload => {\n  return new Promise( (resolve, reject) => dispatch( actionCreator(payload, resolve, reject) ) );\n};\nThe complete pattern then looks like:\n```\nconst someActionCreator = promiseAction(SOME_ACTION_TYPE);\nconst mapDispatchToProps = (dispatch) => ({\n  onSubmit: bindActionToPromise(dispatch, someActionCreator)\n});\nfunction watchSomeAction() {\n  yield takeEvery(SOME_ACTION_TYPE, handleSomeAction);\n}\nfunction* handleSomeAction({ payload, meta: {resolve, reject} }) {\n  try {\n    yield call(doTheThing);\n    yield call(resolve); \n  } catch (error) {\n    yield call(reject, error); // Convert to SubmissionError here if needed\n  }\n}\n```\nHope this helps someone.\n. @jschlieber, thank you for the detailed reply. Your solution seems similar to what I'm doing for small bites of Meteor data, like the current user or the server connection state. I was planning on using minimongo to hold the domain objects, but I'm starting to think that going pure redux would be better. A couple of thoughts and questions:\n- Have you looked at the observer api for Meteor client cursors? Here's a snippet of pre-saga code:\n```\nexport const syncCollection = (collection, dispatch) => {\n  const actions = getActions(collection);\n  collection.find().observe({\n    added(doc) {\n      dispatch(actions.added(doc));\n    },\nchanged(doc) {\n  dispatch(actions.changed(doc));\n},\n\nremoved(doc) {\n  dispatch(actions.removed(doc));\n}\n\n});\n};\n```\nMaybe using it vs. just grabbing the whole collection every time might be more efficient? Idk.\n- Can you say a little bit about your experiences with normalize vs. minimongo? What do you feel you lost and gained?\n- I was looking at immutable and backed away because lodash doesn't play totally nice with it. But now I'm thinking of making the switch. Do you have any pearls you'd like to share to an immutable newbie?\n. @jschlieber, thank you for the detailed reply. Your solution seems similar to what I'm doing for small bites of Meteor data, like the current user or the server connection state. I was planning on using minimongo to hold the domain objects, but I'm starting to think that going pure redux would be better. A couple of thoughts and questions:\n- Have you looked at the observer api for Meteor client cursors? Here's a snippet of pre-saga code:\n```\nexport const syncCollection = (collection, dispatch) => {\n  const actions = getActions(collection);\n  collection.find().observe({\n    added(doc) {\n      dispatch(actions.added(doc));\n    },\nchanged(doc) {\n  dispatch(actions.changed(doc));\n},\n\nremoved(doc) {\n  dispatch(actions.removed(doc));\n}\n\n});\n};\n```\nMaybe using it vs. just grabbing the whole collection every time might be more efficient? Idk.\n- Can you say a little bit about your experiences with normalize vs. minimongo? What do you feel you lost and gained?\n- I was looking at immutable and backed away because lodash doesn't play totally nice with it. But now I'm thinking of making the switch. Do you have any pearls you'd like to share to an immutable newbie?\n. @jschlieber Not a problem at all! I think you're correct in wanting to go straight from ddp into redux. Although all of this will be superseded by Apollo, I can't help but think there are others out there who would find such a bridge useful in the meantime.\nSince the whole thing is driven by subscriptions, I'm curious what pattern you're using to handle them with redux. Do you link subs to routes or component mounts? I was thinking about an HOC that would fire subscribe/unsubscribe actions when the component was mounted/unmounted/updated and maybe also when a route was entered/exited. Then a saga could do the actual subscription work, and a record of the subscriptions could be put in the store so that the app could be brought back to its previous state. \n. @jschlieber Not a problem at all! I think you're correct in wanting to go straight from ddp into redux. Although all of this will be superseded by Apollo, I can't help but think there are others out there who would find such a bridge useful in the meantime.\nSince the whole thing is driven by subscriptions, I'm curious what pattern you're using to handle them with redux. Do you link subs to routes or component mounts? I was thinking about an HOC that would fire subscribe/unsubscribe actions when the component was mounted/unmounted/updated and maybe also when a route was entered/exited. Then a saga could do the actual subscription work, and a record of the subscriptions could be put in the store so that the app could be brought back to its previous state. \n. ",
    "anykao": "@nktssh I have tried and worked pretty well.\n. ",
    "oanylund": "I do not know if these action creators are new or have some downside, but could we not just use the startSubmit and stopSubmit action creators and pass the form name with the submit action?\nExample:\njavascript\nfunction* createEntity(entity, apiFn, formId, newEntity) {\n  yield put( entity.request() )\n  yield put( startSubmit(formId) )\n  const {response, error} = yield call(apiFn, newEntity)\n  if(response) {\n    yield put( entity.success(response) )\n    yield put( reset(formId) )\n    yield put( stopSubmit(formId) )\n  }\n  else {\n    yield put( entity.failure(error) )\n    // handle and format errors from api\n    yield put( stopSubmit(formId, serverValidationErrors) )\n  }\n}\nQuite new to both redux-form and redux-saga, so there could be something i am missing here.\n. Agreed. I just came across this issue when i was facing the same challenge and thought i would share the solution i ended up with. \n. Seems like this is not the proper place to discuss this, but to answer shortly...\nAs i understand startSubmit, it only sets the submitting flag in the form reducer to true and nothing else. I only use it to disable the submit button and set the fields to readonly while submitting. The sync validation happens before this when you click your submit button as always. So if your sync validation is not passing, the action to fire the saga will never be dispatched.\nstopSubmit sets the submitting flag to false, and you can also pass a new error object with your server errors to the form.\n. I am having the exact same issue! Can't get race to return anything.\n. Inject the value in the second  call of next, in your case the one one the line before the console.log('NEXT IS', next);. Spent half an hour trying to inject it in the first one before i figured it out.. \n. ",
    "gustavohenke": "After giving a quick look around this issue, I think the solution by @oanylund is the cleanest possible.\nIt doesn't requires anything that looks as hacky as passing resolve and reject around.\nI already have my form name as a constant, therefore it's so easy to issue startSubmit and stopSubmit actions!\n. Where is END? I couldn't find it in the API docs.\n. ",
    "nktssh": "@oanylund but what about validation when clicking 'Submit'?\nSome forms could has complex validation flow, and part of this flow must be executed only when user hit 'Submit' button...\n. > i really think this line of code could be removed: erikras/redux-form@7e07256#diff-28d8f38ee02f29d2bc406450f6c0d870R27 or at least could be added some option to turn this automatic setSubmitSuccess() off...\n+1 for new option to not calling stopSubmit and setSubmitSuccess!\nMaybe, we can do this as plugin?. was this fixes in v0.14.0 ?. bug with wrong import doesn't affect  webpack 1 and webpack 2 users - use both of them on different project, all as expected.\nthe main problem is to have 2 entry points while all build systems expect only 1 main file.\nAt least two approaches coming to my mind:\n make 1 entry point\n split redux-saga package into two: redux-saga-core and redux-saga-effects (naming is just example). @zech it depends on webpack config. You can configure it to use jsnext:main or main.\nWith main webpack will use \"lib\" folder and with jsnext:main it will use \"es\" for main file and \"lib/effects\" for separate import.\nIt will just not throw error and silently use \"lib/effects\".\nSo, the problem is still exist but silently. Agree, it's not a solution rather that a cheap workaround.. Just fond thread about this topic in rollup repo, starting from this comment: https://github.com/rollup/rollup/issues/126#issuecomment-240038057\nAnd there is suggested solution:\nhttps://github.com/rollup/rollup/issues/126#issuecomment-240076414\n\nOnly real solution if you need to put modules in subfolders and have them work everywhere is probably to publish two separate packages from the same repo (which isn't as bad as it sounds, it's what Lodash does for example).. @zech what do you think, how it can be solved?\n\nFound a thread on npm repo about enhancing \"main\" field and pass directory there\nhttps://github.com/npm/npm/issues/10506\nResolution:\n\nThis would require changes to the Node module resolution algorithm. As was noted on nodejs/node#3953 when @evanlucas closed it, the Node module loader is basically sacred writ at this point, and won't be changed. . @zech actually, I with @Andarist get you wrong - my thoughts was about two packages: one is main and one for 'effects'. what about leave only one entry point and desctructure effects from there like an example from @Andarist \nimport { delay, effects } from 'redux-saga'\nconst { call } = effects\nThis is another possible solution.\n\nMoreover, some libs (like redux-form, for example) just have exported inner Action Creators on the top-level of lib API, near the components and helpers, e.g.\nimport { change, submit, arrayRemoveAll, Field, Form, reduxForm } from 'redux-form'\nWhat do you think about this approach?\nDo redux-saga really need this effects separate import?\nBesides, as I can see from v0.14.0 release notes, a lot of people are confused about two imports. @Andarist what do you think about this?. @Andarist I think we can close this issue?\nAlso, it can be useful for all who tired with destructuring of effects: I've created small package called redux-saga-effects, just for better development experience. Take a look\nhttps://github.com/nktssh/redux-saga-effects. @Andarist \n\nmore pressings matters at the moment\n\nsure, np! Just want to check if it still relevant.\n\ncouldnt you spread them? Would it break tree shaking?\n\nit's a first version, will try to move package in dynamic direction.\nI also don't like manual re-export - it means that I need to keep eye on the redux-saga releases.\nWill see how far I can get with dynamic exports - ES6 modules are non-dynamic by design.\nWhat can really solve this problem - extracting effects into separate package, all other things are workarounds (it was suggested earlier in this thread and discussed, I know). . @Andarist thanks for the feedback!\nAgree, naming is open question \ud83e\udd14. I was inspired by takeLatest/takeEvery.\nIf redux-saga-utils package will be planned/created - just ping me, I'll make a pull request with pleasure!. ",
    "kevinmichaelchen": "@nktssh if you want to do client-side validation before you put the submit action, you can mod the answer given by @angelyordanov by tweaking the onSubmitActions function to take a validation function as a parameter (e.g., validateFn), which you invoke before submitting the form. If there are any validation errors, you can call \njavascript\n// validateFn returns an empty object if no errors\n// otherwise, an object like { _error: 'errorMessage' }\n// where _error is the redux-form key for form-wide errors\nconst errors = validateFn(values);\nif (errors) reject(new SubmissionError(errors))\n. ",
    "andrewsuzuki": "Here's my variation on @oanylund's answer. I have a module with a utility called formSaga:\n```js\nimport { put, call } from 'redux-saga/effects'\nimport { startSubmit, stopSubmit, reset, SubmissionError } from 'redux-form'\nexport default function* formSaga(formId, apiSaga, ...apiSagaArgs) {\n  // Start form submit\n  yield put(startSubmit(formId))\ntry {\n    yield call(apiSaga, ...apiSagaArgs)\n// Success\n\nyield put(reset(formId))\nyield put(stopSubmit(formId))\n\n} catch (err) {\n    if (err instanceof SubmissionError) {\n      yield put(stopSubmit(formId, err.errors))\n    } else {\n      console.error(err) // eslint-disable-line no-console\n      yield put(stopSubmit(formId, { _error: err.message }))\n    }\n  }\n}\n```\nExample usage: for something like login, I want to be able to login either with an action directly (login/loginSaga), or through a form submission (submitLoginForm/submitLoginFormSaga).\n```js\n// Actions\nexport const login = createAction('Login', (email, password) => ({ email, password }))\nexport const submitLoginForm = createAction('Submit Login Form', (fields) => fields)\n// Sagas\nexport function* loginSaga({ payload: { email, password } }) {\n  // call api, etc...\n  try {\n    yield call(request, { endpoint: '/auth/login', method: 'post', data: { email, password } })\n  } catch (e) {\n    // could throw a redux-form/SubmissionError here and it'll show up in the view!\n    // etc...\n  }\n}\nexport function* submitLoginFormSaga({ payload: { email, password } }) {\n  // the ...apiSagaArgs in the util keep things pretty generic, but in this case\n  // (and most cases) we can just generate a \"fake\" action using the action creator\n  yield call(formSaga, 'login', loginSaga, login(email, password))\n}\nexport function* watcherSaga() {\n  yield [\n    takeLatest(login.getType(), loginSaga),\n    takeLatest(submitLoginForm.getType(), submitLoginFormSaga),\n  ]\n}\n```\n** Might not be idiomatic, this is my first day with redux-saga.. ",
    "babsonmatt": "@andrewsuzuki How are you passing values from your form to your saga?. ",
    "alpox": "I thought that maybe someone would be interested in my solution of this. I built it through the base pattern of @jcheroske - thanks for this!\nMy solution mainly consists of some helper functions. (I wrote it in Typescript, so you may have to read a bit around type declarations)\nI created the same metaCreator for the use with redux-actions:\nexport function metaCreator() {\n    const [resolve, reject] = [...arguments].slice(-2);\n    return { resolve, reject };\n}\nThen I could create the equivalent of createAction of redux-actions which makes use of createAction internally, but makes it return a promise and injects resolve and reject into the meta field of the FSA compilant action:\n```\nexport const createPromiseAction = (\n    actionType: string,\n    payloadCreator: (...args: any[]) => any = identity,\n) => {\n    const action = (...args: any[]) => (\n        dispatch: Dispatch,\n    ): Promise =>\n        new Promise((resolve, reject) => {\n            dispatch(\n                createAction(actionType, payloadCreator, metaCreator)(\n                    ...args,\n                    resolve,\n                    reject,\n                ),\n            );\n        });\n(action as any)[Symbol.toPrimitive] = () => actionType;\n(action as any).toString = () => actionType;\nreturn action;\n\n};\n``\nEdit: for this to work you needredux-thunkmiddleware to route the promise through thedispatch` call\nThis can be used simply instead of createAction:\nexport const login = createPromiseAction(AuthActionType.Login);\nIn addition, i created another helper - a function which wraps the original saga and catches errors from the original saga and rejects the error through the promise. It calls resolve, when the saga finished its work:\n```\nexport function formSaga(originalSaga: (...args: any[]) => any) {\n    function* newSaga({\n        meta: { resolve, reject },\n        ...action,\n    }: {\n        meta: {\n            resolve: () => any;\n            reject: (err: any) => any;\n        };\n    }) {\n        try {\n            yield call(originalSaga, action);\n            yield call(resolve);\n        } catch (error) {\n            yield call(reject, error);\n        }\n    }\nreturn newSaga;\n\n}\n```\nThis can be used like:\nexport function* authSaga() {\n    yield takeEvery(login.toString(), formSaga(loginRequest));\n}\nWhere login is the previously through createPromiseAction created action.\nIn loginRequest i can then just throw the submission error as i'm used to:\n```\ntry { ... }\ncatch (err) {\n        yield put(error(AuthActionType.Login, err));\n    throw new SubmissionError({\n        _error: err.response.data.error.fields || err.response.data.error,\n    });\n}\n\n```\nI hope this helps somebody :-) thanks for your help to create this!. ",
    "borteo": "Following your suggestions, we have created a simple helper:\nexport const bindActionToPromise = (dispatch, actionCreator) => payload => {\n  return new Promise((resolve, reject) =>\n    dispatch(actionCreator(payload, resolve, reject))\n  )\n}\nThen we import it with a simple import { bindActionToPromise } from '../../utils' and use it this way:\nconst submit = (closePortal, values, dispatch) => {\n  const submitUpdate = bindActionToPromise(dispatch, updateSomething.request)\n  return submitUpdate({ data: values })\n}\n. ",
    "superbiche": "In case someone's interested, here's A not-that-simple-but-fully-working-way of handling Redux Forms with Sagas.\n. ",
    "boyswan": "I've noticed if I do this instead, it works as expected:\n``` javascript\nfunction fetchAllJobs() {\n  yield takeEvery('FETCH_ALL_JOBS', () => getData('http://jsonplaceholder.typicode.com/posts'))\n}\nfunction* getData(url) {\n    try {\n        const user = yield call(fetchData, url)\n        yield console.log(user)\n    } catch (e) {\n        yield console.log(e)\n    }\n}\n```\n. ",
    "jonaskello": "Thanks! I like how redux-saga keeps the flow of a process in one place. The thing I have trouble with is just to reason about the order things happen in. I did some reading up onmicrotasks and I think I understand it better now :-). If I find some time I will try to make a rewrite of my above example and how it uses the microtask queue. I think an explainer like that might be useful for the docs.\n. Ok, I'll try using that hook. Will it catch all errors including async errors?\n. Ok, thanks!\n. ",
    "bolismauro": "I'm not sure if this is related to this issue but I've just started to work with sagas and I find almost impossible to debug saga code. The main issues I have are:\n- breakpoints basically don't work (either they are not triggered, or functions like 'next step' behave in a weird way\n- when there is an exception inside a saga (or a function invoked using call inside a saga) nor the stack trace or the error message is meaningful\nI'm using the latest version of Chrome but I've also tried Safari and Chrome.\nMost likely these issues are not directly related to redux-saga but I wonder if there is a way to support developers in the debugging process because right now I think it is really really hard \n. ",
    "yjcxy12": "I was more aware of the project structural similarities. I'd have \"reduces\" folder, contains different reducers, and in index.js it would be something like:\n``` javascript\nimport { combineReducers } from 'redux';\nimport firstReducer from './firstReducer';\nimport secondReducer from './secondReducer';\nimport thirdReducer from './thirdReducer';\nconst rootReducer = combineReducers({\n    firstReducer,\n    secondReducer,\n    thirdReducer\n});\nexport default rootReducer;\n```\nI've tried to find a way to sort of \"combine\" all different sagas into a single rootSaga, so that it can be passed into createSagaMiddleware. Couldn't find it on docs, but in examples it had a pattern. And the \"sagas\" folder is very similar to \"reducers\" - having different sagas, and an index.js that exports rootSaga.\n``` javascript\nimport { fork } from 'redux-saga/effects';\nimport firstSaga from './firstSaga';\nimport secondSaga from './secondSaga';\nimport thirdSaga from './thirdSaga';\nexport default function* rootSaga() {\n    yield [\n        fork(firstSaga),\n        fork(secondSaga),\n        fork(thirdSaga),\n    ];\n}\n```\nJust with weird syntax for someone just starting up with redux-saga like me. \nAgreed that it's only very little boilerplate, but at least a mention of creating rootSaga in docs would be great.\n. Saw the pattern in the most of examples. Not clear the differences / pros and cons of two ways.\n. ",
    "Darmikon": "Hi, I was just searching how to combine redux sagas\nand found this discussion useful.\nI didn't understand why I should fork for these combinations.\nI'd like to leave my helper functions here.\nI've just written them and hasn't been tested enough. \nCorrect me if I'm wrong. \nThanks.\n```\n//notesSagas.js\nimport foldersSaga from './folders'\nimport notesSaga from './notes'\nexport default [\n    foldersSaga,\n    notesSaga,\n]\n//or export default foldersSaga\n//rootSaga.js\nimport {sagas as notesSagas} from '~/notesSagas'\n/\n * @param {(generator|generator[])}\n /\nfunction combine(sagas){\n    yield Array.isArray(sagas)\n        ? sagas.map(saga=>saga())\n        : [sagas()]\n}\n/\n * @param {...generators}\n /\nfunction apply(...sagas){\n    yield Array.isArray(sagas)\n        ? sagas.map(saga=>combine(saga))\n        : [combine(sagas)]\n}\n/\n * @param {...generators}\n /\nfunction combineSagas(...sagas){\n    return function(){\n        yield apply(...sagas)\n    }\n}\nexport default combineSagas(\n    notesSagas\n)\n/\nexport default function rootSaga() {\n    // yield [\n    //  combine(notesSagas),\n    //  combine(otherSagas),\n    // ]\nyield apply(\n    notesSagas\n    ,otherSagas\n)\n\n}\n*/\n//configureStore.js\nimport sagas from '../rootSaga'\n...\nsagaMiddleware.run(sagas)\n...\n```. I didn't think about deep nesting. But maybe it could be achieved using such functions.\nIn short, I have a big module per url route with own sagas not related with other pages. \nI want to see which sagas take part in the lifecircle of particular module. \nI can add and remove sagas inside separated module without touching rootSaga. I only mount module bundle to rootSaga once.\nAnd entire bundle can be a simle saga as well. Not only arrays of sagas. But in general my bundles are arrays.. ",
    "alfonsodev": "I'm starting to use redux-saga, \nand decided to organize my sagas by topic in different files, \nI was looking also for a way to include all my sagas at once,\nI came up with this code, that seems to work just fine\n```\n// rootSaga.js\nimport * as groupOne from 'app/saga/groupOne'\nimport * as groupTwo from 'app/saga/groupTwo'\n// grupOne and Two are exporting several watcher sagas \nimport { map } from 'ramda'\nconst combinedSagas = {\n  ...groupOne,\n  ...groupTwo,\n}\nexport default function* rootSaga() {\n  yield map(key => combinedSagaskey, Object.keys(combinedSagas))\n}\nDo you see any downside to this approach ? \nwould I get any benefit from using `fork` ? \nThanks.\n. I'm starting to use redux-saga, \nand decided to organize my sagas by topic in different files, \nI was looking also for a way to include all my sagas at once,\nI came up with this code, that seems to work just fine\n// rootSaga.js\nimport * as groupOne from 'app/saga/groupOne'\nimport * as groupTwo from 'app/saga/groupTwo'\n// grupOne and Two are exporting several watcher sagas \nimport { map } from 'ramda'\nconst combinedSagas = {\n  ...groupOne,\n  ...groupTwo,\n}\nexport default function* rootSaga() {\n  yield map(key => combinedSagaskey, Object.keys(combinedSagas))\n}\n``\nDo you see any downside to this approach ? \nwould I get any benefit from usingfork` ? \nThanks.\n. Sorry for opening this, it is very clearly explained in the docs.\n\nIt's important to note that when an action is dispatched to the store, the middleware first forwards the action to the reducers and then notifies the Sagas. This means that when you query the Store's State, you get the State after the action has been applied\n. Sorry for opening this, it is very clearly explained in the docs.\nIt's important to note that when an action is dispatched to the store, the middleware first forwards the action to the reducers and then notifies the Sagas. This means that when you query the Store's State, you get the State after the action has been applied\n. \n",
    "joonhyublee": "+1 This would fit my use case too. Am using @mxdubois's implementation. How about 'takeSequentially' for the name? 'takeAndQueue' doesn't sound so bad either :)\n. @mxdubois anyway, do you reckon yield join(task) is necessary here? Wouldn't yield task work too?\n. Thanks for the clarification. I've been using a build from npmcdn. Using the minified build also solves the problem, for anyone else interested!\n. @ronanwize for reference, I have a page of about x10 custom-built graphs. Because each graph selectively fetches data from the server and automatically zooms to fit data on the fly when a user drags it, I have each of the mouse events handled as action to the redux store and various effects handled by redux saga. (without all these effects, I would just handle them as local component state updates)\nSo optimally, with proper throttling and all, I have ~x60 actions per second. Each scroll action may trigger 3~5 effects within the respective saga. So that is ~x300 actions per second. With x10 graphs on the page, each react-redux connect()ed to redux store, this leads to ~x3,000 connect() wrapper re-renders per second and more, leading to heavy jank (~5fps), even with all the shouldComponentUpdate optimizations. Granted, connect() wrappers are very efficient, but no user interaction should be firing x1,000's of function calls in the first place.\nAs you can see, things can get out of hand really easily when you handle mouse events through redux store / redux saga, but it was absolutely necessary in my case. To optimize, it is crucial to:\n- minimize actions passed to the store (all connect()ed wrappers will update for each action) &\n- minimize the number of connect()ed components at a given instance\n- make mapStateToProps functions as computation-free as possible\nThere is no trick here, but with aggressive effects batching, component restructuring, selective showing (rendering only the visible graphs using infinite-list-esque technique), I got the number of actions, number of connect()ed components and subsequent re-renders down to manageable level (back up to 60fps).\nOne useful technique is to implement a custom middleware similar to one shown above to filter out actions specific to redux-saga. These actions had the sole purpose of triggering a saga, and otherwise had no direct consequence on the store. Remember, even inconsequential actions will invalidate the store and trigger an update on all connect()ed components. This alone significantly cut down the number of actions. There are libraries that allow you to do this, like redux-ignore, but my use case was so simple that I just wrote my own.\n. Just to add, it can be difficult to use existing redux monitoring tools to see all the actions that are being passed to the store, simply because there are too many actions being fired per second and devtools designed to scrutinize individual actions can't keep up. So I wrote a simple aggregate analytics middleware to use in conjunction with react perf addon:\n\n``` javascript\nconst make_analytics = () => {\n    const perf = React.addons.Perf;\n    let stats = {};\n    let is_counting = false;\nconst count_action = action => {\n    if (is_counting) {\n        if (!stats[action.type]) stats[action.type] = 1;\n        else stats[action.type] = stats[action.type] + 1;\n    }\n};\n\nconst start = () => {\n    is_counting = true;\n    perf.start();\n};\n\nconst stop = () => {\n    is_counting = false;\n    perf.stop();\n    console.log(stats);\n    perf.printWasted();\n    stats = {};\n};\n\nconst get_stats = () => {\n    console.log(stats);\n};\n\nreturn {\n    count_action,\n    start,\n    stop,\n    get_stats\n};\n\n};\nwindow.analytics = make_analytics();\nconst analytics_middleware = store => next => action => {\n    window.analytics.count_action(action);\n    return next(action);\n};\n```\nand using it looks like:\njavascript\nstore  = createStore(\n    combined_reducer,\n    applyMiddleware(\n        analytics_middleware,\n        createSagaMiddleware(...combined_saga),\n        ignore_middleware\n    )\n);\nin case you are wondering what my ignore_middlware looks like:\njavascript\nconst ignore_middleware = store => next => action => {\n    if (action.type != 'REQUEST_NAVIGATION') return next(action);\n};\n@yelouafi sorry, this is not really redux-saga specific, but thought I'd share since somebody asked.. :)\n. @slorber food for thought. thanks!\n. @MichalBures  I'm surprised your second example didn't work, because it is such a basic use case. Did 0.10.1 release fix it?\n. @MichalBures Thanks for sharing!\n. @MichalBures @yelouafi So it seems, for now, that the only way to guarantee that all actions are caught is through using actionChannel (and I suggest you use it to see if you can get your test suite to work without hacky Promise.resolve()'s), as was in my case. While I have no problem making my app work with that, I don't think that is what users expect when they use an API named takeEvery..? ;) I'll have a more thorough read of https://github.com/yelouafi/redux-saga/issues/235 and source code, and see if I can come up with a suggestion for this.\n. @yelouafi You are super awesome! Thank you for your clarification, it really helped me understand why it isn't really a 'basic use case', and I also realize saga scheduling is a difficult problem and doesn't 'just work'.\n. @yelouafi Okay, I'll disregard your first comment, which I couldn't understand because if parent was resuming fast, it should still be logging \"starting a chain\" and \"loop returning\"..? Below is my use case, in which it is crucial that all actions are caught and no action is debounced:\nuninterruptable chained task\n               (joined the first time)     \u250c\u2500\u2500( repeated many times )\u2500\u2500\u2500\u2510       (left the last time)\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nusers saga \u2500\u252c\u2500\u2524 join --> join complete \u2502-->..\u2502 join+1 \u2502-->..\u2502 leave-1 \u2502-->..\u2502 leave --> leave complete \u2502\n            \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   forked   \u251c\u2500 ...\n  for each  \u2502\n    user    \u251c\u2500 ...\n            \u2502\n            :\n            :\nTo give you some context, I have multiple react components freely subscribing/unsubscribing to real-time user data backend built with websocket. Because subscribing to the same user more than once is redundant, I keep count of how many components are listening to the same user, so that I can start a new subscription when there is 1 listener, do nothing when there is 2, 3, 4, ... listeners, and unsubscribe when there is 0 listener again. For app-wide consistency, that count is stored in the redux store, with put effects from individual user saga forked and chained by users saga(plural).\nAs you can see, for resource management it is crucial that the count is accurate, and no join/leave action should go unhandled. So I need some guarantee all such actions are caught, which I think, the only way for now is using actionChannel. However, as I mentioned in https://github.com/yelouafi/redux-saga/issues/277, I think takeEvery can be a misnomer when, in certain cases, actions can go missing.\nI'll more thoroughly read https://github.com/yelouafi/redux-saga/issues/235 and the source code, to see if I can come up with a suggestion for this.\n. @yelouafi I can confirm that 0.10.2 now works with my use case too. Whatever you did, it worked! Thanks!!\n. ",
    "mxdubois": "My impression is that each call to yield fork(...) returns a new task\nobject. I haven't looked at whether or not that task object has any\nreferences to the other task objects or any bearing over whether or not\nthose tasks are cleaned up as they complete.\nOn Sun, Mar 6, 2016 at 9:45 PM, Joon Hyub Lee notifications@github.com\nwrote:\n\nSince compositeTask persists forever with the saga itself, (unlike the\npromise chain) it might not get garbage collected and eat up memory as\nchain gets long, even after all the effects are resolved..?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/174#issuecomment-193114069\n.\n. \n",
    "shaunpatterson": "Actually, I don't think this is my problem.  Closing. \n. ",
    "Ognian": "looks like when invoking with yield * instead of call \nconst res = yield *callAndIfUnauthorizedTryLogin ( fetchApi ,\n            () => fetch(getLimsApiRootAction() + 'getUserInfo', {\n                mode: 'cors',\n                cache: 'no-cache',\n                credentials: 'include'\n            })\n        );\nthe first error disappears.\n. The second error disappears if we do not use the .catch statement and instead use the error function in then and return the error via Promise.reject.\n. ",
    "eMerzh": "Yeah i use the same kind of things\nin my sagas.js\njs\nexport default function* root() {\n    yield [\n        fork(watchLogin),\n        fork(watchLogout)\n    ];\n}\n. Thanks for the reply :)\nmy initial question, was more about, is it normal to have \"a lot of sagas\" \nlike ... 1 per api call / endpoint or smth ?\nso if the application calls 20 distincts endpoints like (create / update / delete / list of object A, ....) i should have this much sagas?\nor is it a code smell? then what's the recommended way ?\n. Thanks @yelouafi for your reponse.\nso if i understand correctly, i still have to add a 3rd function that mostly\njs\nfunction *watchUserSaga() {\n  yield* takeEvery(\"USER_FETCH_REQUESTED\", fetchUser);\n}\nright? \nand i have to add the watchUserSaga + fetchUser for each of my endpoints? \n. ",
    "TeodorKolev": "I want to use redux-saga for API calls. Since I have many different url calls how can I achieve that? Basicaly I use this example, but I dnon't know how to multiply it. Is there any tutorials for that? Just to be sure: I have two different buttons in different components that make API calls.\n. @davidwparker Great thanks man. Appreciated! If you want add that links as answer of this. I will accept it, because it really helps me.\n. ",
    "davidwparker": "@TeodorKolev - I've modified your example to show using two different API calls. You should be able to expand upon that to make it work: http://www.webpackbin.com/VkdjuU02Z\n. @jrvidal - Yeah, I definitely saw that the getState was unused... I left mine in there (for no particular reason). \nI didn't realize that I needed to send generator.next(THE_EXPECTED_VALUE).\nHere's what I ended up with:\nsaga\njavascript\nexport function *quitTimer() {\n  const pomodoro = yield select(selectors.pomodoroSelector);\n  yield call(pomodoro.timer.quit)\n  yield put(actions.onPomodoroQuit(pomodoro));\n}\ntest:\n``` javascript\nit('quitTimer Saga test', function (done) {\n  const generator = sagas.quitTimer();\nlet next = generator.next();\n  expect(next.value).toEqual(select(selectors.pomodoroSelector));\nnext = generator.next(getState().pomodoro);\n  expect(next.value).toEqual(call(pomodoro.timer.quit));\nnext = generator.next();\n  expect(next.value).toEqual(put(actions.onPomodoroQuit(pomodoro)));\ndone();\n});\n```\nAnd it works. Thanks @jrvidal !\n. @aikoven - Yeah, I tried the promise route already, I should have mentioned that it needs to fire more than once.\n@Andarist - thanks, I'll try what you came up with and see if that works for me as well. Edit: I don't have time to get to it now, but I'll try back in a few hours. \n. @Andarist - works perfectly, thanks!\n@yelouafi - do you recommend @Andarist's suggestion as the preferred way? If so, is it worth it if (I or someone else) adds some documentation around handling callbacks like this? \nCheers!\n. @thieu75 \nsagas:\njavascript\nfunction *rootSaga() {\n  yield [\n    appSagas.watchConnectionStatus(),\n  ];\n}\nsagas/applications\n```javascript\nimport { channel } from 'redux-saga';\nimport { call, put, take } from 'redux-saga/effects';\nimport firebase from 'firebase';\nimport { firebaseCallbacks } from 'modules';\nexport function *connectionStatusChange(): Generator {\n  const connectionStatusChannel = channel();\n  const connectionStatus = firebaseCallbacks.connectionStatusWrapper(connectionStatusChannel);\n  const connectionRef = firebase.database().ref('.info/connected');\n  connectionRef.on('value', connectionStatus);\nwhile (true) {\n    const action = yield take(connectionStatusChannel);\n    yield put(action);\n  }\n}\n// @no-test-needed\nexport function *watchConnectionStatus(): Generator {\n  yield call(connectionStatusChange);\n}\n```\nfirebase\n```javascript\nimport actions from 'modules/actions';\nfunction connectionStatusWrapper(channel) {\n  function connectionStatus(snapshot) {\n    if (snapshot.val() === true) {\n      channel.put(actions.connected());\n    }\n    else {\n      channel.put(actions.disconnected());\n    }\n  }\nreturn connectionStatus;\n}\nexport default connectionStatusWrapper;\n```\nactions\n```javascript\n// firebase actions\nexport const connected = () => {\n  return {\n    type: types.FIREBASE_CONNECTED,\n  };\n};\nexport const disconnected = () => {\n  return {\n    type: types.FIREBASE_DISCONNECTED,\n  };\n};\n```\nreducer connectionStatus:\n```javascript\n// @flow\nimport { ActionTypes as types } from 'modules/constants';\nconst initialState = false;\nconst connectionStatus = (state: boolean = initialState, action: Object) => {\n  switch (action.type) {\n  case types.FIREBASE_CONNECTED:\n    return true;\n  case types.FIREBASE_DISCONNECTED:\n    return false;\n  default:\n    return state;\n  }\n};\nexport default connectionStatus;\n``. What does the API return / What doesapi.listUsers` look like?\n. ",
    "jamiesunderland": "I've experienced the same problem. My solution was to create a sagas.js file next to app.js that acts as the root saga and then maps over the imported sagas. so for example \nsagas.js\n``` js\nimport { fork } from 'redux-saga/effects';\nimport MySaga from './path/to/MySaga';\nimport MyOtherSaga from './path/to/MyOtherSaga';\nconst sagas = [\n  ...MySaga,\n ...MyOtherSaga\n];\nexport default function* root() {\n  yield sagas.map(saga => fork(saga)); \n}\n```\npath/to/MySaga.js\njs\nexport default [myWatchSagaForSomething, myWatchSagaForSomethingElse];\napp.js\njs\nimport Sagas from './sagas';\n/*\nlot of other stuff ...\n*/\nsagaMiddleware.run(Sagas);. ",
    "granmoe": "We've ended up doing the same thing as @jamiesunderland. We do it within a modified ducks pattern, where the saga code is all contained within our ducks. Each duck exports a sagas array, then we yield sagas.map(startSaga) in our rootSaga (startSaga spawns each saga and has some top level custom logic).. We've ended up doing the same thing as @jamiesunderland. We do it within a modified ducks pattern, where the saga code is all contained within our ducks. Each duck exports a sagas array, then we yield sagas.map(startSaga) in our rootSaga (startSaga spawns each saga and has some top level custom logic).. @rwieruch The only caveat of using all in the root saga to combine sagas is that (if I'm reading the docs correctly) if any of the sagas throws, all of the sagas in the all will be cancelled.. @rwieruch The only caveat of using all in the root saga to combine sagas is that (if I'm reading the docs correctly) if any of the sagas throws, all of the sagas in the all will be cancelled.. @andredp If you have any saga that makes any network request, and the network request throws for any reason, all of your other sagas would die. So if you want your app to keep working when the internet connection is intermittent or not have to handle every single type of error thrown explicitly and restart at each saga's level (which is not a bad option, either), then you will need some generic restart logic.. @andredp If you have any saga that makes any network request, and the network request throws for any reason, all of your other sagas would die. So if you want your app to keep working when the internet connection is intermittent or not have to handle every single type of error thrown explicitly and restart at each saga's level (which is not a bad option, either), then you will need some generic restart logic.. That said, there are alternative approaches, and they have been discussed at length in other issues.. That said, there are alternative approaches, and they have been discussed at length in other issues.. https://github.com/redux-saga/redux-saga/pull/644. https://github.com/redux-saga/redux-saga/pull/644. Is there anything that can be done to address @rclai 's concern? Many of my co-workers have asked about this as well.. Would something like this work for centralized error handling in all sagas in an app?\nfunction* rootSaga () {\n  yield sagas.map(saga =>\n    spawn(function* () {\n      while (true) {\n        try {\n          yield call(saga)\n        } catch (e) {\n          console.log(e)\n        }\n      }\n    })\n  )\n}\nOr would it possibly cause complex bugs due to scheduling issues internal to redux-saga? I'm wondering if something could get messed up going from the catch back to the try. Assuming this all happens synchronously, there should be no problem, right? Or wrong?\n. Would something like this work for centralized error handling in all sagas in an app?\nfunction* rootSaga () {\n  yield sagas.map(saga =>\n    spawn(function* () {\n      while (true) {\n        try {\n          yield call(saga)\n        } catch (e) {\n          console.log(e)\n        }\n      }\n    })\n  )\n}\nOr would it possibly cause complex bugs due to scheduling issues internal to redux-saga? I'm wondering if something could get messed up going from the catch back to the try. Assuming this all happens synchronously, there should be no problem, right? Or wrong?\n. @ajwhite How do you address the problem of distinguishing between synchronous and asynchronous exceptions in the \"restarter\"? If a saga threw a synchronous exception on startup for any reason, and you restarted it, it would keep failing and restarting forever.. I agree with @yelouafi 's comments. I've been teaching this out at work and one of the biggest points of confusion is that the helpers look like the effects but are not effects and are imported from a different location. Also agree with the point about testing.. Oh, OK, so put is meant to be give back control immediately in all cases?\nI can't do exactly what you suggest due to other requirements of the app, but this clears things up completely. I had assumed that if a put triggers other sagas, those sagas will be settled before control is returned to the saga that called put. (Apologies for the vague code...I can't copy my actual source due to legal reasons.)\n. Wow! Thank you for the detailed explanation :-) \ud83d\udc4d \ud83d\udc4d \ud83d\udc4d \nI decided to just yield put a success action at the end of sagaA and yield take it right after the put in mainSaga. I'm going to have to read your reply a few times to fully understand it.\nThanks again :-)\n. To kill the app and see this issue, put a debugger right before the call to reddit and replace the URL with something that will fail.\n. @Andarist @slorber Yes, I am handling all errors in the try/catch because the catch just swallows them and doesn't re-throw. I think to make the example more clear, I could handle certain types and then re-throw the rest. My intent here is to show some more nuanced error handling and clarify the fact that if you just fork all sagas, any unhandled exception will kill them all (this was a stumbling block for me in learning saga). I'm very very open to suggestions, but this example caused confusion for me when I was a newcomer to saga (which, granted, was only like two months ago).\n. Or maybe we should be using the task.done.catch feature in the root saga? Mainly, I just want this example to highlight a good, idiomatic pattern for the problem of top level exception handling / not killing all your sagas on an unhandled exception.\n. Would something like this work for centralized error handling in all sagas in an app?\nfunction* rootSaga () {\n  yield sagas.map(saga =>\n    spawn(function* () {\n      while (true) {\n        try {\n          yield call(saga)\n        } catch (e) {\n          console.log(e)\n        }\n      }\n    })\n  )\n}\nOr would it possibly cause complex bugs due to scheduling issues internal to redux-saga? I'm wondering if something could get messed up going from the catch back to the try. Assuming this all happens synchronously, there should be no problem, right? Or wrong?\n. Sorry, my console.log is just an example (a confusing one)! We will be sending uncaughts through an error monitoring service. What is 'runSaga' and 'reduxSagaIO' in your example?\n. Nevermind, I found runSaga in the docs\n. I would still be curious to see your reduxSagaIO. And does this approach kill a saga that throws an uncaught exception? Or do you handle that in reduxSagaIO? \n. OK, I pushed a new commit with my top level error handling solution. My only concern is if a situation happens, somehow, where calling the saga itself triggers an exception synchronously, how should that be handled? Maybe something like this to prevent infinite synchronous exceptions from a saga?\nyield sagas.map(saga =>\n    spawn(function* () {\n      let hasError = false\n      while (!hasError) {\n        try {\n          setTimeout(() => { hasError = false }, 0)\n          yield call(saga)\n        } catch (e) {\n          hasError = true\n          handleError(e)\n        }\n      }\n      throw new Error('Unrecoverable exception thrown while spawning saga', saga)\n    })\n  )\nIt just seems kinda ugly.\n. I'm kind of questioning this whole idea now. Maybe it would be better to rip out the while (true) that I have at the top here and instead just send the error to whatever logging/monitoring service you want to use and then re-throw. Handle network errors at the source and don't ever throw anything in a saga that you don't explicitly handle.\n. Sorry to be a pest, but I don't see this reflected in the docs :-/\nThanks in advance :-). Here's a wild and probably bad idea: should the middleware itself provide some mechanism for terminating a saga that immediately, synchronously throws an exception? This is probably too heavy-handed and would make the library too opinionated. Just spitballing here.. Doesn't anyone have any opinions or advice on this?. I'm really struggling to get any response from the community for this problem. I've tried reddit, gitter, here, reactiflux. Can anyone help?. Thanks for the feedback!\nThe reason I want to wrap the root saga itself is because 99% of the time, I don't want any of my sagas to die permanently if an unhandled exception occurs. This is the one important difference between mine and @aikoven 's approach.\n@Andarist No, I don't have any problems with my current solution. Yes, a global try/catch (with the option to restart sagas after non-sync errors) would be perfect. \nI know it's easy to accomplish with about 20 lines of code (like @aikoven and I have above, for example), but many co-workers have voiced concern about this chunk of code because it feels like too low-level of an abstraction, like something redux-saga should handle for you. Sure, this amounts to just hiding that little chunk of code in the library, but at least then we can have one standard way of doing it that everyone (and apparently a lot of people have need for this) can use.. @Andarist Sorry, the actual difference with @aikoven 's solution is that I take into account synchronous errors and I DO let the saga die in that case. Disregard my previous comment (I misread his code).\n\nWell, I feel that although many people would like it to see in redux-saga it would break other's assumptions (even if they are minority) and we should then provide a way of reaching present behaviour. So there is no win in this.\nHowever various strategies for error handling could be included in the docs as examples with explanations for everybody to see and chose between them. With the most basic one being using spawn in the rootSaga and fork in every spawned one.\n\nGood points. I think providing examples in the docs is a good compromise. Although, you mention creating a built-in helper using @aikoven 's solution, and I would prefer that. I would argue that the helper should use my check for synchronous errors, though, because otherwise it could continually restart a saga that throws on startup every time.\n\nCould you post example API with explanation what providing onError and what its absence would cause?\n\nExample API would be a helper that abstracts this code:\n```javascript\nexport default function* root() {\n  yield fork(startup)\n  const sagas = [nextRedditChange, invalidateReddit]\nyield sagas.map\n      let isSyncError = false\n      while (!isSyncError) {\n        isSyncError = true\n        try {\n          setTimeout(() => isSyncError = false)\n          yield call(saga)\n        } catch (e) {\n          if (isSyncError) {\n            throw new Error(saga.name + ' was terminated because it threw an exception on startup.')\n          }\n          yield put(actions.setError(e.message))\n        }\n      }\n})\n```\nSo then in my original example in this bug, I would do:\n```javascript\nexport default function* root() {\n  yield fork(startup)\n  const sagas = [nextRedditChange, invalidateReddit]\nyield sagas.map(restartOnAsyncError(customErrorHandler))\n```\nOr if you want to restart the saga(s) regardless of whether the error is synchronous or not, there could be another helper available:\n```javascript\nexport default function* root() {\n  yield fork(startup)\n  const sagas = [nextRedditChange, invalidateReddit]\nyield sagas.map(restartOnError(customErrorHandler))\n```\ncustomErrorHandler would be defined by the user, of course, and it would be nice if it could itself be a generator so that the user has an easy way to interact with the store while handling errors.\nThis would get my vote :-) And we could update the examples and docs accordingly. What do you think?. I'd also be willing to help out in getting the examples and docs up to date, and anything else I can help with.. > it can happen not only on a startup, and I feel like it should be applied on each sync step of the generator, which is rather a complex thing to do (not overly complex, but still)\nOh...good point. I guess this would be needed, too, if there are situations in which you could have an endless loop of sync errors at some other step in the saga.\n\nWouldnt like to use your code (both of you! @aikoven @granmoe) for such purpose without your blessing \n\nSure, you can use my code :-) Can you comment with a link to the post here when it's done?\n\neverybody looks to the docs (beside API reference) just once, at the beginning while learning.\n\nYep \ud83d\ude0f And most of us only read the 10% we need to start writing code (sometimes overly complex code because we missed some relevant feature(s) of the API within the remaining 90%).\n. @yelouafi \n\n@granmoe a drawback of using spawn is that it doesnt propgate cancellation down. not a prob. for top watchers but can be for watchers located in mid-hierarchy.\n\nSo if the error propogated up to the top, everything it bubbled through would get cancelled, right? But if it bubbled from a mid-layer to the top, anything BELOW would not get cancelled because cancellation would not propogate down from the top spawn? Is that correct? If so, maybe the best (albeit not perfect) approach is to rely ONLY on upward and not downward cancellation. Obviously, that is a big limitation, but I'm not sure of an alternative, especially given your last paragraph where you seem to have reached the same impasse.\n\nfor the auto retry behavior I assume we are referring here to watchers only. Because we can also fork non watchers and I dont think it makes sense to always restart a worker saga. in the latter case I guess this is what @aikoven meant when he said the restarting is a internal concern to the worker saga (possibly combined with a ui dialog)\n\nYes, I was speaking only of watchers. Agreed, it doesn't make sense to always restart a worker (should be the worker's own responsibility to restart itself if it needs to for some reason).\n\nAlso the setTimeout in the example could potentially have some race condition issues. It's unlikely that an async request could return before the timeout but not impossible if I'm not mistaken (cached response, sevice worker).\n\nHmmm...that would suck. I guess the penalty is that sometimes a watcher that you don't want to ever die would die in this narrow range of scenarios.. One more update to how this hypothetical global task restarter should work. A co-worker noticed today that his \"once only\" saga was running multiple times somehow. The reason is due to a kind of funny oversight in the code. \njavascript\nyield sagas.map(saga =>\n    spawn(function* () {\n      let isSyncError = false\n      while (!isSyncError) {\n        isSyncError = true\n        try {\n          setTimeout(() => isSyncError = false)\n          yield call(saga)\n          // After success, we loop again, too!\n        } catch (e) {\n          if (isSyncError) {\n            throw new Error(saga.name + ' was terminated because it threw an exception on startup.')\n          }\n          yield put(actions.setError(e.message))\n        }\n      }\n    })\n  )\nSo it should be updated to have a break after the saga finishes, like so:\njavascript\nyield sagas.map(saga =>\n    spawn(function* () {\n      let isSyncError = false\n      while (!isSyncError) {\n        isSyncError = true\n        try {\n          setTimeout(() => isSyncError = false)\n          yield call(saga)\n          break\n        } catch (e) {\n          if (isSyncError) {\n            throw new Error(saga.name + ' was terminated because it threw an exception on startup.')\n          }\n          yield put(actions.setError(e.message))\n        }\n      }\n    })\n  )\n@Andarist . Just commenting to revive this thread and see if anyone has had any further thoughts on it.. @ajwhite The API you have up there (the supervisor strategies) is awesome :D . Yeah there\u2019s a reactiflux channel, but I think this is a significant enough topic to deserve a dedicated channel. Should we create a slack channel and leave the link here, so anyone interested can join? Wdyt?. Gitter works for me :-) I'll open a tab for it now and leave it open perpetually :P . Is it really coupled to the render? I have a few apps where I grab some bootstrapped data from the server and process it (among others things) immediately after I create my store in my main js entry point (not even in a component yet). Just make it so you conditionally render something \"pre-load\" / before the tasks you mentioned (like show a spinner or something).. Currently, there is a section in the glossary that addresses this, but it isn't complete and it's kind of hidden away.. I'd be happy to :-) I'll open a PR for it probably some time this week. Closing per PR #693 . When you do this:\njavascript\n            const { logout, processedActions } = yield race({\n                logout: take(LOGOUT),\n                processedActions: call(translateActions, nextActions),\n            });\nIf LOGOUT is received, the call will automatically be cancelled. But that only cancels the current translateActions task. I think I would put the logic to manage the entire process in a \"parent\" saga:\njavascript\nfunction* namingThingsIsHard () {\n  const processServerActionsTask = yield fork(processServerActions)\n  take(LOGOUT)\n  yield cancel(processServerActionsTask)\n  // now the task is dead forever\n}\nYou could even make this saga use something like while (yield take(START_DOING_STUFF) { } so you can start it again at a later time (I think you mentioned that requirement). Hope that makes sense!. @mtwallet If you want to just skip to the next loop iteration, use continue instead of break. break breaks the whole loop, continue goes immediately to the next loop iteration.. \n. OK, updated per your comments. I'm not sure what, if anything, to say for select and actionChannel. Should those be included? And what should they say?. Uggghhh...I needed to change my commit email, and I think I messed up my branch. Once we finalize the changes, I can create a clean branch and open a new PR. Sorry. No I cloned a bare repo of my forked repo, then rewrote commit history with a script, then force pushed it. So actually my whole fork is bad :-(\nHmmm...the diff looks correct and there are no conflicts. Could we potentially just keep this branch? I think I just have an extraneous merge commit in here, but my actual diff is good--it only has the stuff that I changed.\nI'll add select and actionChannel. Thanks @Andarist! Your git fu is strong :-)\nBranch looks clean now. This looks awesome!. After looking at it for longer, the green lines kind of looks like a smiley face. Should we care? Maybe do something different with the upper green line? I'm horrible at design, just throwing ideas out there :-). @karland I dig it! Great work :-). @fzaninotto Also related: https://github.com/redux-saga/redux-saga/pull/644. @slorber Why a 1 second delay specifically instead of just clearing the stack with setTimeout? And how would you handle sagas that throw synchronously?. @slorber If a saga throws synchronously, your approach restarts it forever: http://www.webpackbin.com/41eSzkUwM\nIs that why you mentioned that a more robust \"backoff strategy\" would be needed? I'm just nitpicking because I'd like to use the best solution here in my own apps. I know this is something that should only ever be able to happen during development (like if you make a typo). . @slorber Oh, I see. Yep, I'm aware of that problem :P I had the same issue in our app, but ended up with another (not ideal) solution:\njavascript\nyield sagas.map(saga =>\n    spawn(function* () {\n      let isSyncError = false\n      while (!isSyncError) {\n        isSyncError = true\n        try {\n          setTimeout(() => isSyncError = false)\n          yield call(saga)\n          break\n        } catch (e) {\n          if (isSyncError) {\n            throw new Error(saga.name + ' was terminated because it threw an exception on startup.' + e.stack)\n          }\n          yield put(actions.setError(e.message))\n        }\n      }\n    })\n  ). I think this should be a higher order saga with a signature like \nyield autorestart(saga, { restartHandler, abortHandler })\nWhere restartHandler will be called in the catch of the HO saga before restarting and receive (error, saga) as arguments, and abortHandler will also be called in the catch but only when the saga is aborted (due to throwing synchronously) and also receive (error, saga) as arguments. This would allow users to easily hook into error monitoring services / analytics at a top level (a common need).\nOr it could be used like this\nyield sagas.map(saga => autorestart(saga, { restartHandler, abortHandler })). Can't we just make every invocation of sagaMiddleware.run kill the existing root saga before it starts the new one? Then each split module can run rootSaga again. Or do the already running sagas need to keep their current state? I'm lacking a huge amount of context here, so apologies if this is way too simplistic. In our production app, we just import all of our sagas in the index duck and spread them into one array that we start in the root saga. You could conditionally build the sagas array by page.\n```\nimport { sagas as paymentSagas } from 'ducks/payment'\nimport { sagas as fulfillmentSagas } from 'ducks/fulfillment'\nexport function* rootSaga () {\n  // check the route or whatever and then combine sagas accordingly\n  let sagas\n  if (paymentPage) {\n    sagas = [...paymentSagas, ...someOtherSagas]\n  }\n  yield sagas.map(spawn) // or however you prefer to start your sagas\n}\n```\nThen invoke sagaMiddleware.run(rootSaga) again.\nJust my initial reactions to what's been said here so far.. That makes sense. So what's needed is something more like loadMoreSagas and killSomeSagas. I think you need to build up the actions you are currently receiving via takeEvery into an unlimited buffer. Then when you get \"ACCESS_TOKEN_RECEIVED\", do your logic for each of these buffered actions.\nCheck this out:\nhttps://redux-saga.github.io/redux-saga/docs/api/index.html#actionchannelpattern-buffer\nThen look at the flush example below it:\n```\nfunction* saga() {\n  const chan = yield actionChannel('ACTION')\ntry {\n    while (true) {\n      const action = yield take(chan)\n      // ...\n    }\n  } finally {\n    const actions = yield flush(chan)\n    // ...\n  }\n}\n```\nSeems like what you want is to take all actions from your channel until a token is received, then process all the actions (like the finally block up there) via flush.\nSo your code might end up looking something like:\n```\nfunction* saga() {\n  const chan = yield actionChannel('ACTION')\n  let token\ntry {\n    token = yield take('TOKEN_RECEIVED')    \n  } finally {\n    const actions = yield flush(chan)\n    // do stuff with the actions and latest token\n  }\n}\n```\n. I'm not sure what the default buffer given to actionChannel is, though. You might have to specify an expanding one:\nhttps://redux-saga.github.io/redux-saga/docs/api/index.html#buffers. @epikhighs Here's one I have saved to use for sharing saga examples.\nhttp://www.webpackbin.com/N1vffI2WM\nYou have to import babel-polyfill before anything else. Have you heard of the ducks pattern? What you're describing sounds very similar to it: everything in one place, but divided up by domain: https://github.com/erikras/ducks-modular-redux.\nI just use this and put my saga code for each duck into the duck itself. Just a slight modification on the ducks pattern. Then within each duck, I do export sagas = [saga1, saga2], and wherever I create my rootReducer I import them via import { sagas as paymentSagas } from 'ducks/payment'. Then I just spread these into one array and map that in the root reducer.. Also, some of this is dependent on your use case, and some of it is bikeshedding. I don't think it's necessarily a good idea to prescribe one \"silver bullet\" structure for all redux/redux-saga apps :-/\nHowever, there are many, many good options. You may want to check out the many relevant redux articles and FAQs from Mark Erikson: https://github.com/markerikson/react-redux-links. Any advantage to using classes instead of just plain functions (like in the ducks pattern)?. This is worrying. Does this still happen if we use yield call(foo) instead of yield* foo()?. This is getting at a very big and general question. This discussion may be relevant: https://github.com/reactjs/redux/issues/1528. Wow, that was actually a great comments section! Thanks :-) @eclifford I had read that post when it came out, but never read the comments.. @EdmundMai It would be nice if you could get the result of peerConnection like\nconst event = yield call(peerConnectionPromiseMethod)\nBut I'm not sure if you have a way to force this into something that returns a promise. This is easiest, but it looks like it probably won't work for your case here. So I think you might end up needing to use the event channel described here to connect these external events to redux-saga:\nhttps://redux-saga.github.io/redux-saga/docs/api/index.html#external-api. @anthonychung14  I think you could easily do this via a custom middleware. You'd probably want to add thunk middleware to your project (if you haven't already) so that you can easily dispatch further actions if necessary in the middleware. Then create your permissions middleware and if the user does not have permission to do something, do not feed the action to the next middleware (don't call next(action)), but instead fire some actions to notify the user (or whatever you want to do) and just return the store (or state...can't remember what middleware is supposed to ultimately return). Obviously, the real security for your app will live on backend, so this is all probably just to customize the UI based on the kind of user.. Hey @Andarist :-) \nI read an article on this very topic recently: https://decembersoft.com/posts/file-upload-progress-with-redux-saga/\nPerhaps the author would be willing to donate his code to the cause? I don't know who wrote it, but I think they are on discord because I remember originally opening the article from a link shared in the redux-saga channel IIRC.. Maybe dropbox?. I've had better luck with this source map setting. or maybe \"has been\". Could change to: this issue. This is a great idea. Much more helpful than \"WIP,\" of course!. @jfairbank \"I have come to recognize that integration testing is probably a better approach which is why redux-saga-test-plan now offers it with a simple, declarative API.\" \nI can't agree more. In fact, at my work we've come to the firm conclusion that unit testing sagas offers no benefit. The tests are tautological. And aside from that, you have to put in the substantial time investment of writing them and maintaining them (anytime any effects in the tested sagas change, you have to update its unit tests). We're going to delete our saga unit tests and search for something closer to an integration testing solution.. > If the default behavior were more forgiving, that is, effects were simply recorded and all things were assumed to yield undefined, then perhaps the testing could be less tautological and more focused on what you want to test.\n@aaronjensen That's what redux-saga-test-plan appears to do :-). ",
    "mattzuba": "@waclock - it works exactly as @jamiesunderland posted if running the code under anything that supports array spreading (or if your code has been transpiled in which case it's probably converted into array concats).. ",
    "ofirgeller": "Might help someone, this setup gives my flexibility of changing how I import and export.\n```\nconst flatMap = (arr, func) => {\nreturn [].concat(arr.map((i) => {\n    if (Array.isArray(i)) {\n        return i.map(func);\n    } else if (typeof i === 'object') {\n        return Object.keys(i).map(k => func(i[k]));\n    } else {\n        return func(i);\n    }\n}));\n\n};\nexport default function* rootSaga() {\n    yield flatMap([\n        login,\n        courses\n    ], fork);\n}\n```. ",
    "viadrew": "Here's my approach to this:\nrootSaga.js\n```javascript\nimport saga1 from './path/to/1/sagas';\nimport saga2 from './path/to/2/sagas';\nexport default [\n    saga1,\n    saga2\n];\n```\npath/to/1/sagas.js\n```javascript\nfunction watcher1 (){...}\nfunction watcher2 (){...}\nexport default function* root {\n    yield fork(watcher1);\n    yield fork(watcher2);\n}\n```\nindex.js\njavascript\nimport createSagaMiddleware from 'redux-saga';\nimport createStore from './store';\nimport rootSaga from './rootSaga';\n/*\n...\n*/\nconst sagaMiddleware = createSagaMiddleware();\nrootSaga.map(saga => sagaMiddleware.run(saga))  // Register all sagas. ",
    "fasterthanlime": "Nevermind, I fixed it in my fork: https://github.com/fasterthanlime/redux-electron-enhancer\n. Thanks a lot! Sorry for opening an issue on a sunday :star2: \n. Awesome, thanks!\n. Playing with it in a branch but not getting a lot of luck so far:\n```\nnpm info lifecycle redux-saga@0.9.4~postinstall: redux-saga@0.9.4\n\nredux-saga@0.9.4 postinstall /Users/amos/Dev/itch/node_modules/redux-saga\npostinstall-build lib 'npm -s run compile'\n\n{ [Error: stderr maxBuffer exceeded] cmd: 'npm install --only=dev' }\nnpm verb lifecycle redux-saga@0.9.4~postinstall: unsafe-perm in lifecycle true\nnpm verb lifecycle redux-saga@0.9.4~postinstall: PATH: /usr/local/lib/node_modules/npm/bin/node-gyp-bin:/Users/amos/Dev/itch/node_modules/redux-saga/node_modules/.bin:/Us\ners/amos/Dev/itch/node_modules/.bin:/usr/local/heroku/bin:/Users/amos/Dev/google-cloud-sdk/bin:/Users/amos/.gem/ruby/2.1.5/bin:/Users/amos/.rubies/ruby-2.1.5/lib/ruby/gem\ns/2.1.0/bin:/Users/amos/.rubies/ruby-2.1.5/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/sbin:/usr/local/heroku/bin:/Users/amos/Dev/google-clou\nd-sdk/bin:/Users/amos/bin:/Users/amos/Dev/ooc/rock/bin:/Users/amos/Dev/ooc/cork:/Users/amos/Dev/ooc/sam:/Users/amos/Dev/go/bin:/usr/local/protobuf:/Users/amos/bin:/Users/\namos/Dev/ooc/rock/bin:/Users/amos/Dev/ooc/cork:/Users/amos/Dev/ooc/sam:/Users/amos/bin:/Users/amos/Dev/go/bin:/usr/local/protobuf\nnpm verb lifecycle redux-saga@0.9.4~postinstall: CWD: /Users/amos/Dev/itch/node_modules/redux-saga\nnpm info lifecycle redux-saga@0.9.4~postinstall: Failed to exec postinstall script\nnpm verb unlock done using /Users/amos/.npm/_locks/staging-1b5df25180247a8b.lock for /Users/amos/Dev/itch/node_modules/.staging\nnpm verb stack Error: redux-saga@0.9.4 postinstall: postinstall-build lib 'npm -s run compile'\n```\n. I don't really have a good solution for that, short of forking postinstall-build and making it disable npm3's progress indicator (which I suspect is why it's running out of buffer, but I'm not even sure), so closing for now.\n. ",
    "jackgeek": "I'm trying to put a JSBin together that illustrates this better.  In my debugging of the test I have found some odd things happening which make me think I'm missing something fundamental.\n. ",
    "magestican": "You can do something like this to mock your API responses during integration testing : \njavascript\njest.mock('redux-saga/effects',  () => {\n  function mockFunctions() {\n  const original = require.requireActual('redux-saga/effects');\n  let getStaffServicesAndMoreAPI_RESPONSE = require('./datasets').getStaffServicesAndMoreAPI_RESPONSE;\n  let getStaffServicesAndMoreApi = require('../actions/sagas/appointmentStep').getStaffServicesAndMoreApi;\n  return {\n    ...original,\n    call : (functionSignature) =>{\n      if(JSON.stringify(functionSignature) == JSON.stringify(getStaffServicesAndMoreApi)){\n        return getStaffServicesAndMoreAPI_RESPONSE;\n      }\n    }\n  }\n  }\n  return mockFunctions();\n});. ",
    "tomauty": "If it helps at all, it works as expected when I use my parseResponseLegacy function, which is as follows:\njavascript\nconst parseResponseLegacy = (response, emptyResponseExpected) => {\n    if (response && response.status) {\n        if (response.status < 200 || response.status > 399) {\n            if (response._bodyText && response._bodyText.length\n                && response._bodyText.indexOf('<!DOCTYPE') === -1) {\n                return Promise.reject(response._bodyText);\n            }\n            return Promise.reject(response.status);\n        }\n        if (response._bodyText && response._bodyText.length) {\n            return Promise.resolve(JSON.parse(response._bodyText));\n        }\n        return Promise.resolve(response.status);\n    }\n    if (!response && !emptyResponseExpected) { return Promise.reject(response); }\n    if (response && emptyResponseExpected) { return Promise.reject(response); }\n    return Promise.resolve(response);\n};\n. Haven't seen any in the wild. There are TypeScript definitions here though, so it shouldn't be too hard to convert. I'm interested as well.\n. Do you have a branch open? I deal w/ redux-saga + flow \"errors\" daily and would be happy to start adding basic definitions.\n. Any update on this?\n. ",
    "tarjei": "I also note in the API docs that you write: \"A saga should preferably depend only on its own internal control state when possible.\"\nIsn't this a bit against the credo of Redux? I.e. keeping and modifying state outside of the Store. \nIt seems to me that the only way to achieve what I want is to maintain a hash of queries that my getFromServer method checks. \nAm I right?\nRegards,\nTarjei\n. Thank you for this long and thoughtfull answer! Much appreciated. \nYou write:\n\nit's not clear from your first question if you need to\n1. memoize xhr call results for queries to the same resource all the time\n2. prevent requests for the same result to run concurrently ie you don't want to memoize results for all queries but just for those running concurrently at a given time\n\nI think this is a bit of both as I both need to prevent multiple requests if a resource is being requested and if it has already been fetched. Also the UI needs to know it a resource is being loaded. \nI was hoping to use a simple PUT call to tell the store that the request is being fetched, but that didn't work out too well due to PUT not being synchronous. I ended up solving it by listening to the action triggering the saga instead and updating the state there.\nI like your example of the click having to happen twice to execute the request, but in I found in inapplicable to my use case.\nAnyhow, thanks for your time and answer and thanks for redux-saga.\n. ",
    "kfrajtak": "Thanks, @slorber, that worked like a charm!\n. Thanks, @jhewlett, I'll have a look at your lib!\n. It does not work for me. \nThis is my saga \nexport function* loadNodesSaga() {\n    const watcher = yield takeLatest(constants.NODES_LOAD, getNodes);\n    yield take(LOCATION_CHANGE);\n    yield put({type: 'location changed'});\n    yield cancel(watcher);\n    yield put({type: 'canceled'});\n}\nand the put method is not invoked .... ",
    "jhewlett": "@kfrajtak I had the same need and wrote this lib: redux-saga-combine-latest\nIt takes @slorber 's first approach of aggregating actions in local state, and only fires the handler when all action types have come in. e.g.\njavascript\ncombineLatest(['type1', 'type2'], handleActions)\nAs soon as an action of type type1 and type2 have been received, it fires the handleActions saga, passing an array of actions. As new actions of each type come in, it fires again with the latest action of each type:\n``` javascript\nstore.dispatch({ type: 'type1', some: 'payload' }) \n//handleActions not called\nstore.dispatch({ type: 'type2', some: 'payload' })\n//handleActions called with [{ type: 'type1', some: 'payload' }, { type: 'type2', some: 'payload' }]\nstore.dispatch({ type: 'type2', other: 'payload' })\n//handleActions called with [{ type: 'type1', some: 'payload' }, { type: 'type2', other: 'payload' }]\n```\n. ",
    "amelon": "Hi,\nI think the problem is on unterminated task which is already in catch and it results in a uncaught error in promise.\nThat's the case in your JS Bin, if you have a bad authentification.\nIn you JS Bin, if you enter a bad username (adminx for exemple) you can see in console log the uncaught error.\nIs it normal ?\n. Yes, so nice, your solution is perfect.\nI can confirm it is very confusing and I spent many time to figure out what's wrong.\nI didn't know that take return a full action. \nGood news.\nthanks for your reply and saga project ;)\n. ",
    "ooflorent": "That would be a great addition! Maybe you should submit a pull request. \n. I see something like this:\n``` js\nexport function* delay(ms, result = ms) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(result), ms)\n  })\n}\nexport function wait(ms, result) {\n  return call(delay, ms, result)\n}\n``\n-delayis a _task_\n-waitis an _effect_ which under the hood calls thedelay` task\nThen you could use these helpers this way:\n``` js\nimport {call, wait} from \"redux-saga/effects\"\nimport {delay} from \"redux-saga/utils\"\nfunction* saga() {\n  yield call(delay, 500)\n  yield wait(500)\nyield call(delay, 500, true)\n  yield wait(500, true)\n}\n```\nFirst 2 calls yield a call effect with arguments ms=500, result=500.\nLast 2 calls yield  a call effect with arguments ms=500, result=true.\n. ",
    "burakcan": "i'm using something like following. it's simple but it does the work for me:\nfunction *sleep(time) {\n  yield new Promise(resolve => setTimeout(resolve, time));\n}\n. i'm using something like following. it's simple but it does the work for me:\nfunction *sleep(time) {\n  yield new Promise(resolve => setTimeout(resolve, time));\n}\n. In my current project; there's around 80-90 sagas(some of them are really complex full flows like login flow) and i didn't experience any performance issue; but didn't do an in depth analysis.\n. In my current project; there's around 80-90 sagas(some of them are really complex full flows like login flow) and i didn't experience any performance issue; but didn't do an in depth analysis.\n. aha great idea @coderitual thank you \ud83d\udc4d \n. aha great idea @coderitual thank you \ud83d\udc4d \n. ",
    "Anahkiasen": "@yelouafi I don't see delay being exported here and when I do import {delay} from 'redux-saga/utils' I get undefined. Should I import from somewhere else?\n. That worked, thanks!\n. I see, makes a lot more sense now! Thanks a lot\n. Just wanted to mention this is still an issue and it took me quite some time to figure out the error thrown wasn't the right one and that the real issue was something dumb (I was passing a nullable string as one of the args when my function required a string). Is there nothing that can be done with newest versions of Typescript to avoid it picking up on the wrong call signature here?. ",
    "chenxsan": "@Anahkiasen I think it's import {delay} from 'redux-saga'.\n. I just made some tests with real world example, changed the line to:\nresponse => Promise.reject(response),\nthen I got a same error in console:\n\nThis result might be expected since there's no one to catch the error in https://github.com/yelouafi/redux-saga/blob/6c6ad42c7b53fa8ce419bfdccab78d508e862e99/examples/real-world/sagas/index.js#L41\n. A workaround here is to return a plain error object instead of rejecting or rethrowing the error:\n// fetch data from reddit\nfunction fetchApi () {\n  return fetch('https://www.reddit.com/new.json')\n    .then(\n      (response) => {\n        return {error: 'haha'}\n        // return response.json()\n      }\n    )\n    .catch(\n      (error) => ({error})\n    )\n}\n. Since the loser in the race would be cancelled automatically so that code I copied from https://github.com/yelouafi/redux-saga/issues/183 is kinda a workaround to get the loser's eventual result (I might misunderstand something here).\nIn my case I just wanna throw the errors out, letting it bubble up, then I can handle the errors in their own scope.\n. I'm using redux-saga in our react-native project, since react-native would show a frightening red error page when there're any uncaught errors, so it's a little annoying :).\n. @yelouafi Thank for your hard work and the suggestion. :+1: \n. @yelouafi Sorry, I read the whole conversation again, and found I'm a little confused with this now:\n\nSo we can keep the error logging only for forked tasks (because there is actually no way to catch errors from forks).\n\nDoes it mean I should never throw errors inside the forked function? If the answer is yes, that could be a tough restraint.\n. So if you fork something, you won't be able to catch the error inside where you forked them since they are in different context now.\nI'm running the api call in fork since I want to get the result later even it's not winner in the race.\n1. Run a race between a timeout and the api fork\n2. If timeout wins, put up a loading indicator on the screen\n3. Once the api fork resolve/reject, return the result to whoever called it and hide the loading indicator.\nexport function * callWithLoadingEffect (fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('callWithLoadingEffect only accept function as its argument')\n  }\n  try {\n    const task = yield fork(fn)\n    let {timeout, result} = yield race({\n      timeout: call(delay, 20),\n      result: join(task)\n    })\n    if (timeout) {\n      yield put(loadingShow())\n      result = yield join(task)\n    }\n    yield put(loadingHide())\n    return result\n  } catch (err) {\n    yield put(loadingHide())\n    throw err\n  }\n}\nIf any errors throwed inside the api fork, I want to catch it - I think this is a valid use case :).\n. Thanks, I think it makes sense to separate those errors in my code. \n. I would do the access-token fetching in another generator like:\nfunction * fetchToken () {\n  let token = [call api to fetch access-token]\n  if (token) {\n    // dispatch action to store the access-token\n    dispatch(...)\n    // then return it to whoever called it\n    return token\n  }\n}\nThen the pseudo code would be written:\naccess-token = [select access token from store]\nif [there isn't an access-token] then yield * fetchToken\n[call api with access-token]\nAlthough the access-token is not selected from store, i'm ok with this. But any api called would need the access-token check, so there will be a lot boilerplate. \nWe could improve it with a custom selector generator function:\nfunction * giveMeToken () {\n  access-token = [select access token from store]\n  if [there isn't an access-token] then access-token = yield * fetchToken\n  return access-token\n}\nAnd the function to call api:\naccess-token = yield * giveMeToken\n[call api with access-token]\nAgain, we will still have a lot boilerplate code since we need to select the access-token every time we call api, and of course we can make it better.\n. I think Storage.saveUser should return something like promise. Since AsyncStorage.multiGet is a function accepting a callback, it will return undefined, that's why yield call finish executing before the request finish.\nYou might change your code like:\n```\nexport const connect = () => {\n  return AsyncStorage.multiGet(['profile', 'token']).then (err, stores) => {\n})\n}\n```\n. Check the release note here https://github.com/redux-saga/redux-saga/releases/tag/v0.10.0\n. ",
    "Julio-Assis": "just a note on the docs because it's related to this. On the page https://redux-saga.js.org/docs/advanced/ForkModel.html the delay import is coming from 'redux-saga/effects' when it should be as you mentioned here 'redux-saga'. ",
    "MichalBures": "I'm having the same issue running the latest Electron (0.37.2), though I also get this error:\n(0 , _reduxSaga.takeEvery)(...)[Symbol.iterator] is not a function\nI'm guessing it's related to the removal of Symbol in 0.9.2 since using the same configuration but with 0.9.1 works fine.\n. > I'm also curious electron is throwing this kind of error, since electron (besides react native) was one of the platforms having issues with Symbols prior to 0.9.2\nWell, I've been using redux-saga since something like 0.4.0 with Electron 0.36.x (I've updated to 0.37.x today as part of an update day) and so far I've had no issues.\n. 0.9.5 fixes this issue for me. Thanks!\n. Okay, I've found the situation that causes this problem.\n``` javascript\nexport default function RootSaga()\n{\n    yield takeEvery('TEST', takeTest);\n}\nlet wasTest = false;\nfunction* takeTest(action) {\n    if (wasTest) {\n        console.log('Received TEST for second time')\n    } else {\n        console.log('Received TEST for first time')\n        wasTest = true;\n//      yield delay(0)\n        yield put({type: 'TEST'})\n//      yield delay(5000)\n    }\n}\n```\nThe put in takeTest function isn't caught by the takeEvery without the delay(0). It looks like the takeEvery ignores the action dispatched from its forked saga.\nAlthough If you uncomment the second delay and dispatch TEST from somewhere else during those 5 seconds it works correctly.\n. While I was writing down the explanation for my use case I realized I've simplified the example too much and that's why it doesn't make much sense.\nThis is closer to what is actually happening:\n``` javascript\nexport default function* RootSaga()\n{\n    yield [fork(takeEvery1), fork(takeEvery2)]\n}\nfunction takeEvery1()\n{\n    yield takeEvery('TEST', takeTest1);\n}\nfunction takeEvery2()\n{\n    yield takeEvery('TEST2', takeTest2);\n}\nlet wasTest = false;\nfunction* takeTest1(action) {\n    if (wasTest) {\n        console.log('Received TEST for second time')\n    } else {\n        console.log('Received TEST for first time')\n        wasTest = true;\n//      yield Promise.resolve()\n        yield put({type: 'TEST2'})\n    }\n}\nfunction* takeTest2(action)\n{\n//  yield Promise.resolve()\n    yield put({type: 'TEST'})\n}\n```\nIn this example uncommenting either of those Promise.resolve() will make it work.\nWhat I have in my library is a Global Action that carries another action as its payload and it's used to send actions between Electron windows. All you need to do is to create a Global Action, give it a target (name of the target window) and dispatch it to the store. The Global Action Handler saga then simply based on the action's target dispatches the carried action either locally with put or sends it to another window via ipc.\nWhat happens is that sometimes an action received from another window will get an immediate response and another Global Action is dispatched back to that window. But the Global Action Handler is as you explained already busy waiting for that put to end and thus ignores that Global Action.\nSimple schema of the chain:\nIPC -> STORE -> GLOBAL ACTION HANDLER -> PUT -> ANOTHER SAGA -> PUT -> GLOBAL ACTION HANDLER -> IPC\nPS: Thanks for that Promise.resolve() tip!\n. @joonhyublee Yes, 0.10.1 did fix this issue.\nAlthough 0.10.1 did help with the previous example it's still not the same behavior as in 0.9. I've managed to isolate another one that doesn't work.\n``` javascript\nexport default function* RootSaga()\n{\n    yield [fork(takeEvery1), fork(takeEvery2)]\n}\nfunction takeEvery1()\n{\n    yield takeEvery('TEST', takeTest1);\n}\nfunction takeEvery2()\n{\n    yield takeEvery('TEST2', takeTest2);\n}\nlet testCounter = 0;\nfunction* takeTest1(action) {\n    if (testCounter === 0){\n        console.log('Received TEST for 1. time')\n        testCounter++;\n    yield put({type: 'TEST2'})\n} else {\n    console.log('Received TEST for ' + ++testCounter + '. time')\n}\n\n}\nfunction* takeTest2(action)\n{\n//  yield Promise.resolve()\n    yield [fork(forkedPut1), fork(forkedPut2)]\n}\nfunction* forkedPut1()\n{\n//  yield Promise.resolve()\n    yield put({type: 'TEST'})\n}\nfunction* forkedPut2()\n{\n//  yield Promise.resolve()\n    yield put({type: 'TEST'})\n}\n```\nThis should receive TEST three times, but without either of those resolves it will receive it only two times.\nI'm guessing it's related to the #291 that the two puts fire too fast and the takeEvery doesn't catch them.\n. @joonhyublee @yelouafi I can confirm that using actionChannel solves all the problems I had in both 0.10.0 and 0.10.1.\nI would suggest adding support for channels in takeEvery so that when you have a complex use case that basic takeEvery can't handle you can simply add an actionChannel to it.\n. @yelouafi Yay, it works! Good job, takeEvery in 0.10.2 handles all my use cases again.\n. ",
    "baabgai": "Indeed success and failure will work as expected.\nIn this case I tried to navigate to a different page and showing a loading spinner directly after the interaction happened and wait on the new page for the actual response.\nFor the correct navigation I need a key which is provided by an additional meta tag in the pending action. I updated the initial post to more precisely match the actual problem.\n. Thanks for the suggestions, but this won't work because I need a key which is included in the meta tag of the action to get the navigation correct. I forgot to include these requirements in the original post (now its updated). I'm sure there might be other ways to work around the problem, but I was also curious to know if this is somehow expected behavior or if I been missing something, especially since I've got the impression that after v0.6 this might work.\n. Thanks a lot for the fast and detailed explanation. I had a similar issue already earlier with a thunk dispatching actions I missed, but I could work around that in a different way. Guess that was caused by the same behavior. Now it makes much more sense.\nIf this issue can't be considered a bug, maybe your explanations would fit somewhere in the docs (troubleshooting section?) to prevent people from running into that issue.\nthanks again. saved me a lot of time getting my head around this issue.\n. @panki that might be correct, but the reason for writing the saga as described was mainly driven by the fact that the custom api middleware (including various transformations on the requests) was already in place and I tried to fit a few sagas in our existing code base. If I had the time do more refactoring I guess this specific problem might not have manifested because you might implement it in a similar way you described.\n. ",
    "panki": "@baabgai it seems like a not too good decision. Why you need to yield put(loadUserData) instead of call api function that loads user details or returns already exists?\nIn this case, you split user loading logic into 2 sagas, while it should be in one place?\nI think it might look like this:\njavascript\n...\nconst { id } = yield take(SHOW_PROFILE)\nif (typeof id !== 'undefined') {\n    yield put(loadingUserData()) // Fires USERDATA_PENDING action\n    const {userId} = yield call(api.loadUserData)\n    history.push(`/app/someurl/${userId}`)\n} else {\n    yield put(<someOtherAction>)\n}\n...\n. ",
    "voy": "Fixed a couple of typos in the docs, feel free to merge if you like.\n. ",
    "slestang": "Thanks @yelouafi , with production files me task is always below 200ms of execution time. Much better.\n. ",
    "mahmoudHosny": "Thank you\nI'm using browserify\nSo I installed the module with no-optional flag\n. Thank it's Works\nBut it's not mentioned at docs\n. ",
    "aams": "See https://github.com/npm/npm/issues/11632\n. ",
    "1ambda": "I realized that I should have used continue statement instead of return. Thanks for making the great library :+1: \n. ",
    "timothyjlaurent": "Thanks so much for clarifying -- super helpful. I somehow missed the createMockTests. \n. ",
    "sospedra": "Would be nice maybe to put things like createMockTests ins the Docs glossary? I've been looking for something like this and I end up here (and solved my issue, btw) tho I think is not the ideal discovery flow :D. Would be nice maybe to put things like createMockTests ins the Docs glossary? I've been looking for something like this and I end up here (and solved my issue, btw) tho I think is not the ideal discovery flow :D. Awesome @Andarist ! This is exactly what I was looking for. I've just read the documentation and found the note about don't relying on the Store state. The saga being autonomous. However, there are excepctions. I think that requesting a token is something which fulfill to break this rule. Maybe could be an example. How do you feel about this? Maybe I'm completely wrong :)\n. It sounds good. But I'm facing another issue because take is bloquer. Therefore, FETCH_SOMETHING will be called only after SET_TOKEN. The requested flow is like:\n```\n\n\nFETCH_SOMETHING >> SET_TOKEN >> FETCH_SOMETHING\n```\n\n\nWhich means that FETCH_SOMETHING is a watcher which can has or not the token.\nI tried with takeEvery but it didn't worked. Any suggestion?\nMany thanks, again.\n. It sounds good. But I'm facing another issue because take is bloquer. Therefore, FETCH_SOMETHING will be called only after SET_TOKEN. The requested flow is like:\n```\n\n\nFETCH_SOMETHING >> SET_TOKEN >> FETCH_SOMETHING\n```\n\n\nWhich means that FETCH_SOMETHING is a watcher which can has or not the token.\nI tried with takeEvery but it didn't worked. Any suggestion?\nMany thanks, again.\n. Many many thanks @Andarist !\nLast step I solved with takeEvery and now everything is working nice and clean!\nI'm closing the issue, tho, I think an example (or receipt) with a flow like this one would be super cool ;)\n. Many many thanks @Andarist !\nLast step I solved with takeEvery and now everything is working nice and clean!\nI'm closing the issue, tho, I think an example (or receipt) with a flow like this one would be super cool ;)\n. I tried what you mentioned @Andarist and also this approach: https://github.com/yelouafi/redux-saga/issues/212\nAnd none of those worked :( It just stays bloqued forever.\n. I tried what you mentioned @Andarist and also this approach: https://github.com/yelouafi/redux-saga/issues/212\nAnd none of those worked :( It just stays bloqued forever.\n. Here it goes @Andarist \nI hope the code and logs are self explanatory ;)\nhttp://www.webpackbin.com/VJjnG8FbG\n. Here it goes @Andarist \nI hope the code and logs are self explanatory ;)\nhttp://www.webpackbin.com/VJjnG8FbG\n. You're right @Andarist . Thanks for the help. This was one of the troubles I had. The other one was... Well, I need to keep in mind that the spread operator for composing actions is dangerous... Specially if the payload contains a type attribute, if you know what I mean >.<. You're right @Andarist . Thanks for the help. This was one of the troubles I had. The other one was... Well, I need to keep in mind that the spread operator for composing actions is dangerous... Specially if the payload contains a type attribute, if you know what I mean >.<. Yish! This was exactly what I was looking for. Many many thanks ;) I've never thought in use race like that. . Yish! This was exactly what I was looking for. Many many thanks ;) I've never thought in use race like that. . I resolve it with join. Dunno if super correct.. I resolve it with join. Dunno if super correct.. ",
    "artursgirons": "Ok, I see, thanks!\n. ",
    "gnoff": "i have a simpler need (just wanting multiple takes in a saga and the following simplification works as you would expect)\n``` js\nfunction* parallelTake(pattern) {\n  return yield take(pattern);\n}\n// then inside any saga function...|\nconst actions = yield [\n  parallelTake('A'),\n  parallelTake('B')\n];\n/* multiple grabs first take of each type so action can be very stale \nfor instance\ndispatch({type: 'A', value: 1});\ndispatch({type: 'A', value: 2});\ndispatch({type: 'A', value: 3});\ndispatch({type: 'A', value: 4});\ndispatch({type: 'A', value: 5});\ndispatch({type: 'B', value: 6});\ndispatch({type: 'B', value: 7});\nwill result in the above actions array looking like:\n[{type: 'A', value: 1}, {type: 'B', value: 6}]\n*/\n```\n. Nice! Thanks.\n. ",
    "metrue": "@zalmoxisus \n@yelouafi \nSo what is the best solution to handle  the SagaCancellationException , \nif I have watcher and worker like this:\n```\nimport types from './types';\nimport { takeLatest } from 'redux-saga';\nimport { put } from 'redux-saga/effects';\nimport api from '../../../api';\nconst {\n  FETCH,\n  FETCH_SUCCESS,\n  FETCH_FAILED,\n} = types.GAMES;\nfunction* fetcher(action) {\n  const { query } = action;\n  const resp = yield api.listGames(query);\n  if (resp.status === 200) {\n    const { games } = yield resp.json();\n    yield put({ type: FETCH_SUCCESS, list: games });\n  } else {\n    yield put({ type: FETCH_FAILED });\n  }\n}\nfunction fetchSaga() {\n  yield takeLatest(FETCH, fetcher);\n}\nexport default [fetchSaga];\n```\n SagaCancellationException  will happen when a FETCH happened, but  api.listGames not done yet.  do I need to take care this exception, and where I should to do the try-catch if I want to catch it.\nUPDATE:\nActually, I can ignore this exception, but if we want catch it, we can put try-catch into worker part. like this based on above code blocks.\nfunction* fetcher(action) {\n  try {\n    const { query } = action;\n    const resp = yield api.listGames(query);\n    if (resp.status === 200) {\n      const { games } = yield resp.json();\n      yield put({ type: FETCH_SUCCESS, list: games });\n    } else {\n      yield put({ type: FETCH_FAILED });\n    }\n  } catch (e) {\n    // ignore manual canceling\n    if (! e.name === 'SagaCancellationException') {\n      console.warn(e);\n    }\n  }\n}\n. @npbee \nquick question here, mybe this is dumb one.\nbut what's the deference between \nyield* takeEvery\nand \nyield call(takeEvery, ...)\ndo I need always use  call  to make testing work ?\n. @npbee \nwhat a great explanation here, I totally understand it now.  and thanks for you great example. \n. ",
    "neurosnap": "I ended up going with @yelouafi suggestion, thanks!\n. You make a good point, @3LOK the order of selectors shouldn't change the outcome of the test.  It seems more accurate to say that the conventional approach to unit testing sagas is actually to unit test the saga effects, rather each iteration of the generator.  Basically with your library, you prepare a mock state, mock reducers, and dispatching a series of actions to determine if the saga dispatches the correct actions, is that correct?\n. It is possible to do forking but I have found that forking a generator for testing purposes creates an unwieldy mess that is difficult to maintain.  We created a utility to make those arduous duplicated tests easier to deal with by making testing sagas virtually painless with https://github.com/jimbol/expect-gen\nUsing this utility we have reduced saga testing to be as easy as testing reducers.\n```js\nfunction* myGen({ userId }) {\n  const users = yield select(getUsers);\n  const user = users[userId];\n  yield put(registerUser(user));\nif (user.isAdmin) {\n    yield put(showAdminPanel());\n  }\n}\n```\n```js\n// it should not trigger admin panel\nconst user = { id: 5, isAdmin: false };\nexpectGen(myGen, { userId: 5 })\n  .yields(select(getUsers), { 5: user }) // asserts the select as first arg and provides the dummy data as second\n  .yields(put(registerUser(user)) // assert\n  .finishes() // generator.next().done = true\n  .run();\n// it should trigger admin panel, not bothering to assert what we already asserted\nconst user = { id: 5, isAdmin: true };\nexpectGen(myGen, { userId: 5 })\n  .next({ 5: user }) // doesn't assert just goes to the next step with dummy data\n  .next() // doesn't assert\n  .yields(put(showAdminPanel()))\n  .finishes()\n  .run();\n```\nIf our action creators return JSON serializable objects we can make this even easier with snapshot testing.  We don't need to worry about asserting that the correct actions are being dispatched if we create a snapshot.\n```js\nconst user = { id: 5, isAdmin: false };\nconst snapshot = expectGen(myGen, { userId: 5 })\n  .next({ 5: user })\n  .next()\n  .finishes()\n  .toJSON(); // converts results from generator to JSON serializable format\nexpect(snapshot).toMatchSnapshot();\nconst user = { id: 5, isAdmin: true };\nconst snapshot = expectGen(myGen, { userId: 5 })\n  .next({ 5: user })\n  .next()\n  .next()\n  .finishes()\n  .toJSON();\nexpect(snapshot).toMatchSnapshot();\n``. You don't have arootSagayou are callingSagamiddleware.run` on every single saga you created.\n``` js\n/*\n * Inject an asynchronously loaded saga\n /\nexport function injectAsyncSagas(store, isValid) {\n  return function injectSagas(sagas) {\n    if (!isValid) checkStore(store);\ninvariant(\n  Array.isArray(sagas),\n  '(app/utils...) injectAsyncSagas: Expected `sagas` to be an array of generator functions'\n);\n\nwarning(\n  !isEmpty(sagas),\n  '(app/utils...) injectAsyncSagas: Received an empty `sagas` array'\n);\n\nsagas.map(store.runSaga);\n\n};\n}\n```\nInstead of:\njs\nsagas.map(store.runSaga);\nTry this:\njs\nexport default function*  rootSaga() {\n  yield [\n    watchFetchUsers(),\n    watchSubmitLike(),\n  ]\n};\njs\nstore.runSaga(sagas);\n. instead of dispatching an action for data source A, why not simply yield to the generator for it? composing sagas should be able to solve chaining data sources.\n. ``` js\nfunction* dataSourceA() {\n  const req = yield call(fetch, 'http://...');\n  const data = yield req.json();\n// ...\nyield put({ type: 'ADD_MY_DOCUMENTS', payload: documents });\n  return data;\n}\nfunction dataSourceSaga() {\n  while (true) {\n    const action = yield take('LOAD_DOCUMENTS');\n    const sourceAData = yield dataSourceA(action);\n    // this wont trigger until all of the async calls from dataSourceA have finished\n    yield put({ type: 'LOAD_DATA_SOURCE_B' });\n  }\n}\n``\n. Do the actions you dispatch run sagas?  If so then they aren't all inside one function.  It's up to you how you want to organize your application, but one of the big benefits to sagas are their composability.\n. You want to watch for actions being dispatched, not your state.  The only way your statecalendarcan be changed is by dispatching an action, something likeUPDATE_CALENDAR` which then goes through your reducer to return the next state.\njs\nwhile (true) {\n  const action = yield take('UPDATE_CALENDAR');\n  const entry = action.payload; // or whatever your action data looks like to update your calendar\n  // ...\n. You need to return the fetch:\njs\nconst authApi = {\n  register (userData) {\n    return fetch(`http://localhost/api/auth/local/register`, {\n. takeEvery and takeLatest are not effects, you want to import them from the primary module  redux-saga\njs\nimport { takeEvery, takeLatest } from 'redux-saga';. Notion \nWe built the desktop and web email app using redux-saga.\n\n. It sounds like the primary issue is that we are suggesting people use spawn for all sagas that are run by runSaga that way when one saga fails the entire app doesn't fail, but at the same time we need a way for people to dynamically cancel an entire tree of sagas even when they use spawn.\nAll of this is in an effort to be able to split saga trees up based on application logic or code splitting.\nIn this scenario it sounds like we need to come up with an API that will allow us to create a rootSaga beyond simply the runSaga implementation.\nIn my large redux application we simply pool all of our disparate sagas together into the runSaga.  Is there a way currently to pool together multiple root sagas?. I'm running into a lot of issues with the flow-typed definitions as well, primarily with using the effects.\njs\nyield fork(processThreadResponses, {\n    responses: responses.filter((r) => r),\n    replace,\n    replaceFolder,\n});\nFlow error: function call Function cannot be called on any member of intersection type intersection\nThis error in particular has plagued my codebase with seemingly no solution.  I would love any feedback on how to get rid if of this nefarious error.\n. The results of the reducers are always calculated before the saga gets activated: https://github.com/redux-saga/redux-saga/blob/master/src/internal/middleware.js#L78\nThe only way I know to block or intercept an action is to create a custom middleware.\nThere is another callback you can hook into which is the sagaMiddleware.emitter option (https://github.com/redux-saga/redux-saga/blob/master/src/internal/middleware.js#L59, https://redux-saga.github.io/redux-saga/docs/api/index.html#createsagamiddlewareoptions) but that's not going to help you intercept an action because that function gets called after the reducers as well.\nI've never needed the ability to intercept an action before it hits the reducer within a saga before, what use case are you thinking about?. ```js\nfunction *createTag(name) {\n    yield call(Api.create, {name}); \n    // then fetch all\n    const tags = yield call(Api.listTags);\n    // store in redux state\n    yield put(setTagData({tags}));\n}\nfunction *createTagAndDoSomething({ name }) {\n   yield call(createTag, name)\n  // do something, Tag already created\n}\nfunction* createTagAndDoSomethingSaga() {\n  yield takeEvery(CREATE_TAG_AND_DO_SOMETHING, createTagAndDoSomething);\n}\n``. Ok socall(createTag)` cannot be called in parallel?  Have you looked into creating a channel with a buffer?. This will allow you to buffer the actions and only allow one request at a time.\nFrom the docs: https://redux-saga.github.io/redux-saga/docs/advanced/Channels.html\n```js\nimport { take, actionChannel, call, ... } from 'redux-saga/effects'\nfunction* watchRequests() {\n  // 1- Create a channel for request actions\n  const requestChan = yield actionChannel('REQUEST')\n  while (true) {\n    // 2- take from the channel\n    const {payload} = yield take(requestChan)\n    // 3- Note that we're using a blocking call\n    yield call(handleRequest, payload)\n  }\n}\nfunction* handleRequest(payload) { ... }\n``.mainwill wait for thecall(delay, 1000)` before finishing.. According to: https://redux-saga.js.org/docs/api/#putresolveaction\nIt looks like you need to add some middleware to make the redux dispatch return a promise.\nHere's the code: https://github.com/redux-saga/redux-saga/blob/master/src/internal/proc.js#L448. Thanks for the input!  I didn't know about the snapshot serializer, this could be really helpful in making the snapshots more readable.\nI agree with you when it comes to TDD, snapshots are not as useful.  From my point of view, snapshot testing allows us to quickly cover saga testing without much effort and should probably be used in tandem with normal assertion testing.\nSerializing functions were something we struggled with and ultimately learned that Jest explicitly doesn't store the function name:\nhttps://github.com/facebook/jest/issues/2580#issuecomment-272405197\nhttp://facebook.github.io/jest/blog/2016/10/03/jest-16.html#snapshot-updates. Greetings!\nIf you have middleware that makes the redux.dispatch function return a promise then you can use put.resolve\nOn the project I'm working on we do not so what we do is we turn the put(submit()) into another saga:\n```js\n// saga\nfunction* onSubmit() {\n  // do some async stuff here\n}\nfunction* applicationFlow(action) {\n  // get to the point where put(submit()) is called\n  yield call(onSubmit); // this blocks flow until onSubmit is done\n}\n```\nIs there any reason in particular why you need to wait until submit is finished?  Are you doing async stuff inside that action creator or do you just want to make sure it has hit your reducer?. A couple of comments.\nI don't think having multiple takeLatest in one generator is going to work the way you are expecting.  Generally take* need to be inside their own generators in a 1:1 mapping.\nwhile (looping) { it looks like you're missing a variable not in your snippet.. Fine w me!  Thanks for taking a look at it. Code snippet is hard to read, could you try formatting and distilling it a little bit?\nThis should work\njs\nconst urls = ['http://google.com', 'http://bing.com']; \nyield all(urls.map((url) => call(url)));. You need to add a return statement in your map\njs\nyield all(folders.map(folder => {\n  return call(syncCanvasesByFolder, folder.id, lastSyncedAt, access_token)  \n}));. Use call inside your map\njs\nexport function* normalizeFileData(files) {\n  return yield all(files.map(file => call(loop(file.id))));\n}. Hmm, I'm not exactly sure what you are trying to accomplish.  Generally speaking when we only want to take one action out of many actions of the same type, we use debouncing (cancel all previous actions of the same type until 2 seconds of no action being dispatched), throttle (only allow 1 action every 2 seconds to be processed), or a buffer (only process one action at a time).  \nWhat it looks like you are doing here is taking all actions of the same type, slapping a 2 second delay on the first one that was dispatched and then using the action payload of the latest action that was dispatched for validation.\nThis seems pretty dangerous in the sense that there is a disconnect between the action that triggered the first timerStart and the actual action payload that you are validating.\nThe code smell that you are detecting is correct, there are too many variables being mutated as well as sharing state between multiple async operations.\nHere's what a debounce would look like:\n```js\nfunction* validateSignupForm() {\n  let task;\nwhile (true) {\n    const action = yield take('landingPage:setSignupForm');\nif (task) {\n  yield cancel(task);\n}\n\ntask = yield fork(validateSignupFormAsync, updatedForm);\n\n}\n}\nfunction* validateSignupFormAsync(form) {\n  yield delay(2000);\n  console.log(\"validating\")\n  console.log(form)\n  yield put('landingPage:validatedSignupForm', form)\n}\n```\nUsing takeLatest helper we can make this even simpler\n```js\nfunction* validateSignupForm() {\n  yield takeLatest('landingPage:setSignupForm', validateSignupFormAsync);\n}\nfunction* validateSignupFormAsync(form) {\n  yield delay(2000);\n  console.log(\"validating\")\n  console.log(form)\n  yield put('landingPage:validatedSignupForm', form)\n}\n``. There shouldn't be any conflicts between usingredux-thunkin conjunction withredux-saga`.. Hi, we are going to need to see how you are calling those apis at once.  \nIf the UI has latency issues that generally means you are blocking the thread with heavy processing.  Are you doing anything that could be considered \"heavy\" in terms of CPU?. I don't see anything obviously wrong with the code you pasted, but it doesn't show the entire picture here for us.\nCould you show us the actual watch task you are using to activate submit?. This might be an issue with using multiple versions of react.\nTry entering this in terminal:\nbash\nnpm ls react. This would be a great addition.  Often times our error stack traces from redux-saga are not helpful.  . ",
    "ctrlplusb": "Perhaps not helpful in this context, or may already be extremely obvious, but hopefully of interest to some:\nIn terms of issues with synchronous execution of startup sagas my technique is to fire an action (e.g. \"APP_INIT\") directly after my redux store has been configured.  My run once saga picks it up no problem and the app state is as expected before any component mounting occurs.\ni.e.\nconst store = configureStore(initialState)\nstore.dispatch(initAction())\n. ",
    "codinronan": "I'll throw in my 2 cents: Go ahead and do it asynchronously (all our code already assumes that anyway, to make the sagas easier to reason about), and make the breaking change to satisfy the need to run actions at startup. We initialize our middleware in one place so it would be a very minor change.\n. @joonhyublee curious, what kind of performance are you seeing? We're in development of something similar and I'm curious what the throughput of the sagas is.\n. Thanks for the response @yelouafi - I was suspecting the answer was along those lines. \nWe actually have alot of sagas that are more or less boilerplate to execute all of our API activities so we're working on refactoring them into a saga \"generator\". We're planning on open-sourcing most of this once it's in a more or less stable, working state because we want to help others solve the same problems. Should be interesting.\nThanks for the advice about keeping concurrent sagas to a minimum - I'll make sure this gets into our architectural recommendations too.\n. @axelson We are using an approach where our saga dispatch error actions to the redux store. We then have the option to use middleware to log errors, or to use other sagas to catch that and send the errors to an error monitoring service (we use sentry).\nA dead simple example is like:\n```\nfunction watchDoSomethingRequested() {\n  yield takeEvery('DO_SOMETHING_REQUESTED', doSomething);\n}\nfunction* doSomething({payload}) {\n  const output = yield call(myLongRunningFunction, payload);\nif(output.error) {\n    yield put({type: 'DO_SOMETHING_FAILED', payload: output.error });\n  }\n  ...\n}\nfunction watchDoSomethingFailed() {\n  yield takeEvery('DO_SOMETHING_FAILED', myFuncThatPostsToSentry);\n}\n```\nWe export all the watcher* functions and load them into redux-saga. Everything else, like the doSomething function, are started from within sagas that watch for specific actions. The result is that all of our sagas are very short and very declarative. \nNaturally our code is alot more complex than that but that's the basic idea. We actually have two layers that do this, one that runs within our sagas and another that is redux middleware but that is because we have specific business requirements to log these in different places.\n. Hi @axelson sorry I forgot to bring things back to catching errors - we actually decided to push that down a layer so anything running in a saga will return an error object we can test for, instead of throwing exceptions. The advantage is that we've been able to standardize our error handling but I know that approach isn't for everyone, it'll be heavily dependent on the other frameworks you're using and what you're trying to accomplish.\nYou saw that above, but our actual code looks more along the lines of:\n```\nconst {output, error} = yield call(myLongRunningFunction, payload);\nerror && (handle the error);\noutput && (handle the output);\n```\nWe didn't want to put try/catch everywhere. Since in most of our cases myLongRunningFunction is something that's handling promises, we squash the errors into a resolved promise that contains an error property:\nfunction apiCall(etc) {\n  return fetch(....).then(....)\n    .then((output) => { return Promise.resolve({output}); }, \n             (error) => { return Promise.resolve({error}); });\n}\nIn the above scenario, only output or error will ever exist so we get the exclusivity of the check for free.\nThis is what we need, but I know not everyone will want to handle errors this way. You don't really have to. You can also do as @yelouafi mentioned, which is what we originally did but wanted to reduce boilerplate and code paths requiring testing.\n. @jshthornton this is what we do. In our completion sagas, we simply emit the appropriate redirect via react-router.\n. ",
    "darrhiggs": "You have your setTimeout arguments backwards in your comment.\nIs it the same in your code?\n. I'm not sure exactly what you are asking. In your first comment you state:\n\nI want to run saga actions within unit tests (nodejs environment) and cannot find how\n\nIf this is what you want then the docs give you some examples of how to test sagas.\n. Could you link to a gist of your unit test (maybe with some explanatory comments) of what you are trying to achieve.\n. files.map(file => yield call(uploadImageApi , file)) should work if uploadImageApi is either a generator function or returns a promise. \n. ",
    "aksonov": "I'm just doing 'sleep' using setTimeout and done but probably it is not enough:\nstore.dispatch({type: actions.LOGIN_REQUEST, username: users[3], password: passwords[3]});\n        setTimeout(done, 5000);\nstore is created as written in docs. The same store used by Provider within react native and LOGIN_REQUEST is processed correctly.\n. Yes, i didn't write correctly arguments in first comment, but code arguments should be ok and it still doesn't work...\n. But I don't want to test sagas, i want to run them...\n. @fhelwanger Thanks, but i want to run it inside redux environment (but nodejs not react native). \n. I've just used this for thunk: http://redux.js.org/docs/recipes/WritingTests.html\nLooks like it is the same for saga, i've just thought that maybe there is some easier way to run saga actions.\n. ",
    "foobahh": "Going to close & follow up with either the redux repo itself or redux-logger, this behavior seems to be prevalent with all async implementations (if you were to console.log in App.js within the redux async example, same thing occurs).  Just weird.  Thanks though! This is a great repo, nice work\n. ",
    "adamyonk": "@foobahh do you have any follow-up issues elsewhere on GH? I'm interested in this as well.\n. ",
    "danwad": "Sorry for the delay. I've figured out the cause but I'm not sure if this is supported usage.\n```\nfunction* error() {\n  throw new Error('this error is not logged correctly')\n}\nfunction saga() {\n  yield [\n    error()\n  ]\n}\n```\n. @slorber Oops - thanks. This also hides the exception.\n``` JavaScript\nfunction* error() {\n  throw new Error('this error is not logged correctly')\n}\nfunction saga() {\n  yield [\n    call(error)\n  ]\n}\n```\nError:\nproc.js:123 saga: uncaught TypeError: Cannot read property 'call' of undefined\n    at tryCatch (webpack:///./~/babel-regenerator-runtime/runtime.js?:61:39)\n    at GeneratorFunctionPrototype.invoke [as _invoke] (webpack:///./~/babel-regenerator-runtime/runtime.js?:268:24)\n    at GeneratorFunctionPrototype.prototype.forEach.prototype.(anonymous function) [as throw] (webpack:///./~/babel-regenerator-runtime/runtime.js?:94:21)\n    at next (webpack:///./~/redux-saga/lib/internal/proc.js?:139:42)\n    at currCb (webpack:///./~/redux-saga/lib/internal/proc.js?:194:7)\n    at eval (webpack:///./~/redux-saga/lib/internal/proc.js?:254:14)\n    at run (webpack:///./~/babel-polyfill/~/core-js/modules/es6.promise.js?:89:22)\n    at eval (webpack:///./~/babel-polyfill/~/core-js/modules/es6.promise.js?:102:28)\n    at MutationObserver.flush (webpack:///./~/babel-polyfill/~/core-js/modules/_microtask.js?:14:5)\n. yield* is used to yield to an iterable object. An array is iterable and so yield* [] is valid.\nYes, redux-saga's call is imported.\n. This issue is fixed in master.\n. ",
    "jscinoz": "Seems to still be an issue when pattern is an array of symbols; the following line throws with TypeError: Cannot convert a Symbol value to a string:\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/sagaHelpers.js#L64\n. No problem. I noticed another issue when providing a single symbol to takeEvery. I'll open a separate PR for that\n. ",
    "bvalosek": "(highly related question to this thread)\nWhen using a action creator function with a toString property, currently that is preventing take from working (very similar to this issue).\neg\n```\nconst login = credentials => {type: 'LOGIN', payload: credentials};\nlogin.toString = () => 'LOGIN';\n...\ndispatch(login(creds));\n...\ntake(login)\n```\nOr more specifically: https://github.com/acdlite/redux-actions\nIs ensuring that take(pattern) calls String(pattern) like the above fixes something we could have as well?\n. I realized that this can't be implemented without breaking BC with your API.\nI was asking if, when passing in a function that overrides toString that it could be cast to a string when running the matcher... but that would break the current expectations when calling take(fn) (as it serves as a predicate filter in this case).\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L17\nWhat I am doing now is that i've made a utility const takes = p => take(String(p)) to use in all the places where i have an action creator function that returns the action type when cast to a string. If you're open to having this be a built-in Effect then I can open a PR.\n. ",
    "thezanke": "I found my way here looking to see if there's a way to automatically call .toString() on a redux-actions actionCreator. If this was possible I could completely drop my action type constants file (since I don't need them for reducers with redux-actions).\nI opened a new issue here with a suggested solution.. I found my way here looking to see if there's a way to automatically call .toString() on a redux-actions actionCreator. If this was possible I could completely drop my action type constants file (since I don't need them for reducers with redux-actions).\nI opened a new issue here with a suggested solution.. Hey @Andarist, I'm just checking in to see if there's any movement on this so I can stop using my fork in my projects :D. Hey @Andarist, I'm just checking in to see if there's any movement on this so I can stop using my fork in my projects :D. \"Good Monday Morning\", @Andarist \ud83d\ude02 . \"Good Monday Morning\", @Andarist \ud83d\ude02 . Hello @Andarist! Thank you for taking the time to review this for me!\nI have the other changes in place but I am confused by what you mean here. Are you saying it would choke if someone defined a custom hasOwnProperty() method on the input pattern and that we should store hasOwnProperty() as a util?. I went ahead and just added this to utils as an export so it can be reused if needed down the road. If you think this unnecessary I can change it.\nIt annoys me that I am using is.notUndef before the object is gets defined in the file. If I put the helper below the definition of is, it would be calling hasProperty above where hasProperty gets defined in the file. I hate moments like this.. Oh shoot, thanks, sorry about that!. Hmmm, I don't know of any. Would this be something someone would pass to take() do you think? That wouldn't be a valid pattern for matchers.default() either way, would it?. ",
    "iMoses": "Was this issue solved?\nI'm new to redux-saga and I couldn't make it work until I figured that the problem was my types were Symbols. I get no errors, no warnings, but the middleware doesn't catch any of my actions as long as the type is a Symbol.\nAre Symbols not supported or is this a bug?\nThe problem seems to originate in the proc.js file at the default matcher, in which the following comparison takes place:\ninput.type === String(pattern)\nThis could be easily fixed by checking if the type is a symbol and if so we shouldn't turn it into a string.\ninput.type === (typeof input.type === 'symbol' ? pattern : String(pattern)). Sure, my mistake for not thinking about it myself :). I don't fully understand your question.\nIf you're talking about a case in which Symbol isn't supported at the browser, or even at Node, then typeof would never return a \"symbol\" string and behavior will continue as it does today.\nThe only place which may fail due to a lack of Symbol support is the test itself, in which case I'm not sure how important it is, you tell me.. @Andarist If you're worried that pattern may contain a value other than a string or a Symbol, I could change the condition to check if pattern is a Symbol instead of input.type, that way we can be sure that it's either a Symbol or a string, and it could never be anything else.. Aren't you missing the type comparison?\nIt should be:\ndefault : pattern => input => input.type === (typeof pattern === 'symbol' ? pattern : String(pattern))\nAnyhow, I'll change it. It certainly makes more sense to validate against the pattern rather than the input.. @Andarist Can you please increase the package version to include this fix in the latest npm version?. ",
    "evgenyt1": "@fhelwanger Thanks for reply.\nyield take('LOCATION_CHANGE') won't allow me to return value from callback (to prevent or allow browser navigation).\nDoes it mean that this kind of \"side effect\" couldn't be handled in sagas at all?\n. @zalmoxisus \"return true\" will just return from mySaga, and won't be handled by listenBefore\nThanks for channels reference.\n. @yelouafi I spent few days trying and debugging a bunch of ways, including generating and handling promises, using callbacks, etc. However all of this complicated my code much and was unreliable (as I want different sagas handle different routes and depend on each other result). \nMy workaround is not to use sagas in this case. Just a special list or routing handlers, that are called synchronously in predictable order by some general entry point (events of router), get state/dispatch and routing stuff as parameters, with final \"fallback\" handler that just approves user navigation (it wasn't handled by routing handlers).\nIn my case I have a routing directory in src with handleAuth.js, handlePage1.js, handlePage2.js etc.\nSo the order is also important, and event handlers can depend on other handler result. As auth goes first, than page handlers that can fetch some data from store, redirect (using dispatch), etc etc\n. ",
    "jk2K": "refer to http://stackoverflow.com/a/35288877/2227031\nso far the best way is create a generic channel with put and take methods?\n. After many many google and carefully read the redux-saga docs\nI found that we can use eventChannel of redux-saga\nSee my SO answer\n. ",
    "thekogmo": "Hi everyone, just a question related to this. If I pass down the store instance from where I configure the store to the root saga, and down to my saga where I need to dispatch an action inside an event callback, is there anything wrong with doing this?\n```\nfunction* saga(store) {\n  const notification = new Notification(\"title\")\nnotification.onclick = e => {\n    store.dispatch(someAction())\n  }\n}\n````. ",
    "tommedema": "@ronanwize re \"we actually decided to push that down a layer so anything running in a saga will return an error object we can test for\": how did you create a lower level layer in which you can catch all sagas' exceptions?\n. ",
    "timeu": "Support for channels/events would be great. \nI have been using the channel approach of your StackOverflow answer (the one you linked) for reacting to websocket events and so far it works really good. As far as I understand the proposal, it tries to generalize the solution of the stackoverflow answer ?\nFor Websockets I think some kind of buffering would be really handy. Would it be possible to implement a  buffered channel manually/by the user with your eventChannel proposal ?\n. @yelouafi: Ah I think I understand now. Yeah I think this is an elegant solution . \nRegarding buffering: \nCurrently I fork a saga to watch websockets events and based on the contents I dispatch actions to update the store : \njavascript\nfunction* monitorWebSocketEvents(channel) {\n  while (true) {\n    const message = yield call(channel.take);\n    var body = JSON.parse(message.body);\n    switch (body.state) {\n      case 'FINISHED':\n        yield put(analysisFinished(body,body.id));\n        break;\n      case 'ERROR':\n        yield put(analysisFailed(body,body.id));\n      default:\n        yield put(messageReceived(body,body.id));\n    }\n  }\n}\nSo I guess without buffering I would fork another saga task that actually dispatches the action ? \n``` javascript\nfunction* monitorWebSocketEvents(channel) {\n  while (true) {\n    const message = yield call(channel.take);\n     fork(handleWebSocketEvent,message);\n  }\n}\nfunction* handleWebSocketEvent(message) {\n   var body = JSON.parse(message.body);\n   switch (body.state) {\n      .... # see above\n  }\n}\n```\nI guess I won't miss any events with the take-and-fork pattern but is the order of handling the events guaranteed with that approach ? \n. ",
    "imranismail": "I've been using the above as well, in fact I've went ahead and written a library for it\nhttps://github.com/127labs/fawkes.js\nPlease proceed with this.\n. ",
    "MarcoThePoro": "A simple mechanism to fire data fetching without rendering could be to define a static hook on your React components that returns an action requesting sagas to fetch data.\n``` javascript\nimport { loadCat } from './api';\nclass CatProfile extends React.Component {\n  static fetchInitialData(params, getState) {\n    return loadCat({ id: params.catId })\n  }\n  componentDidMount() {\n    const { dispatch, cat, params } = this.props\n    if (!cat.isLoaded) {\n      dispatch(CatProfile.fetchInitialData(params))\n    }\n  }\n  render() {\n    const { cat } = this.props\n    if (!cat.isLoaded) {\n      return Fetching cat...\n    }\n    return (\n      \n{cat.name}\nFur color: {cat.color}\n\n    )\n  }\n}\nexport default connect(state => {cat: state.cat})(CatProfile);\n```\nThe server could then inspect which components are due to be rendered on renderProps.components and ask them what to dispatch.\n``` javascript\nmatch({routes, location: req.url}, (error, redirectLocation, renderProps) => {\n  if (error) { ... }\n  else if (redirectLocation) { ... }\n  else if (renderProps && renderProps.components) {\n      const rootTask = sagaMiddleware.run(rootSaga)\n  // this will cause the universal Saga tasks to trigger\n  for (let component of renderProps.components) {\n    store.dispatch(component.fetchInitialData(renderProps.params, store.getState.bind(store)))\n  }\n  // notify Saga that there will be no more dispatches\n  // this will break the while loop of watchers\n  store.dispatch(END)\n  rootTask.done.then(() => {\n    res.status(200).send(\n      Layout(\n        renderToString(\n          <Root store={store} renderProps={renderProps} type=\"server\"/>\n        ),\n        JSON.stringify(store.getState())\n      )\n    )\n  }).catch(...)\n\n} else {\n  res.status(404).send('Not found')\n}\n\n})\n})\n```\nAs far as I can tell this doesn't have any big problems, but then again I've never worked on a production app before, so forgive me if there is a glaring issue staring me right in the face.\n. I actually think the double rendering is really elegant since you don't need to make modifications to your components to make them universal, plus a static data fetching hook doesn't have access to props so you can't fetch data based on props. \nI also think automatic end handling would be easiest.\n. ",
    "ojkelly": "I think the cost of double rendering on the server will probably be negligent, and the proposal seems straightforward enough.\nAutomatic handling of END by default would likely be easiest, with another function say takeManual where END needs to be handled manually?\nI'm not sure how having both would work.\n@MarcoThePoro I'm not sure if that would work in all cases. For example I have a component that fetches data dependent on the location passed into state via react router.\n. @yelouafi yeah I think you're correct, I think I had a bug somewhere else that caused me to swap it. Works coming after now, so I think you're right.\n. ",
    "ericclemmons": "Just found this, and want to say \ud83d\udc4f .  The double-render thing works very well (same method here: https://github.com/ericclemmons/react-resolver), and it's great that this project can solve SSR + Redux.\n. ",
    "Nosherwan": "Hi guys, ( @yelouafi, @Andarist )\nAfter reading this thread I am slightly confused about actually checking for END in takes or in watchers, after dispatching END from the server side.\nSo do we need to do this now:\n1.\njavascript\nfunction* taker() {\n  let action = yield take(TEST_ACTION);\n  while (action !== END) { //do we have to check for END?\n    action = yield take(TEST_ACTION);\n  }\n}\n2.\n```javascript\nfunction watcher() {\n  let action = yield take('');\n  while (action !== END) { //do we have to check for END?\n  const action = yield take('*');\n  const state = yield select();\nconsole.log('action', action);\n  console.log('state after', state);\n    }\n}\n```\nor this will work:\n1.\njavascript\nfunction* taker() {\n//no need for END check\nwhile(true){\n  let action = yield take(TEST_ACTION);\n  console.log('action:',action);\n  }\n}\n2.\n```javascript\nfunction watcher() {\n//no need for END check\n  while (true) {\n  const action = yield take('');\n  const state = yield select();\nconsole.log('action', action);\n  console.log('state after', state);\n    }\n}\n```\n. Thanks @aikoven  that is exactly what I needed :). ",
    "chiel": "I've been researching whether or not we can use redux-saga at work but the server rendering is an issue for us. The majority of our time is spent on server rendering at the moment (though we're looking at other non-blocking methods). On our home page a single render takes 260ms (50th percentile, 310ms/325ms for 90th/95th percentile respectively). Having to do this twice will definitely not work for us because it will almost double our response times.\nIs there no other way to do server rendering with redux saga? At the moment we indeed use react-router's match in order to figure out which components we're rendering, and checking if they have a static fetchData method. This makes it trivial to implement server rendering.\nHoping there's another way, since redux-saga looks like a solid way to handle side effects!. @Andarist at the moment I'm using a custom middleware which is very similar to redux-thunk, but I needed to do some additional things that were not possible with that one.\nSo I have an approach that looks like this:\napp/components/App.jsx\n```jsx\nimport React from 'react';\nimport { connect } from 'react-redux';\n// getStuff returns a function that returns a promise, just like redux-thunk\nimport { getStuff } from 'app/actions/stuff';\nexport class App extends React.PureComponent {\n    static fetchData(dispatch) {\n        return dispatch(getStuff());\n    }\ncomponentDidMount() {\n    this.props.dispatch(getStuff());\n}\n\nrender() {\n    // ...\n}\n\n}\n```\napp/routes.js\n```jsx\nimport App from 'app/components/App';\nexport default [\n    {\n        path: '/',\n        component: App,\n    },\n];\n```\nserver/index.js\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport { match, RouterContext } from 'react-router';\nimport { createStore } from 'redux';\n// reducer is not relevant here\nimport reducer from 'app/reducers';\nimport routes from 'app/routes';\n// middleware is not relevant either, except that it lets us return functions\n// from action creators, which in turn return promises when called.\nimport middleware from 'app/utils/middleware';\nconst app = express();\napp.get('*', (req, res, next) => {\n    const store = createStore(reducer, middleware);\nmatch({ location: req.url, routes }, (err, redirect, props) => {\n    // handle err, redirect or no props\n\n    const render = () => {\n        res.send(renderToString(\n            <Provider store={store}>\n                <RouterContext {...props} />\n            </Provider>\n        ));\n    };\n\n    // this is the important part: since react router exposes which components it will render\n    // I am able to go through them and find the ones that have a data dependency\n    const promises = props.components\n        .filter(component => !!component.fetchData)\n        .map(component => component.fetchData(store.dispatch, props));\n\n    if (!promises.length) {\n        return render();\n    }\n\n    Promise.all(promises)\n        .then(render)\n        .catch(next);\n});\n\n});\napp.listen(3000);\n```\nAnd that is basically how I avoid having to render twice. If I need to explain more, please let me know. :). Hmm that's kinda the thing, I am not too familiar with saga so that's why I'm exploring a bit. I thought saga's were only triggered by other actions. Is there any documentation I can find about the stuff you mentioned?. Ah okay, that looks pretty good. And actually in the componentDidMount the sagaMiddleware is actually not needed at all, since there I could just dispatch a getStuff action, and then have a watcher which will trigger the side effect. I'll have a play around with this - thanks for your patience!. @edisch I hwven't had a chance to look more into it I'm afraid, been busy with other stuff. I will be getting back to this soon, however.. ",
    "Auspicus": "@chielkunkels how did you go with this? Any luck implementing an elegant solution? I'm looking at getting this working for my server-side side effects.. ",
    "keithnorm": "Am I doing this entirely wrong? Still trying to get the hang of sagas. I have a universal app and I want one saga to put an effect that another saga is listening for after the initial END dispatch on the server. So, something like:\n```js\n// saga1.js\nfunction *doFetch() {\n  yield [do some async stuff...]\n  yield put({type: 'fetchSuccess'})\n}\nfunction* saga1() {\n  yield takeEvery('fetch', doFetch)\n}\n// saga2.js\nfunction* doFetchSuccess() {\n  console.log('never got here?')\n}\nfunction* saga2() {\n  yield takeEvery('fetchSuccess', doFetchSuccess)\n}\n// server.js\nsagaMiddleware.run(function* () {\n  yield [\n      fork(saga1),\n      fork(saga2),\n  ]\n).done.then(() => {\n  console.log('done');\n})\nstore.dispatch({type: 'fetch'});\nstore.dispatch(END);\n``\nFrom what I understand from this thread about forks this should be possible but I'm not sure how to set it up. Thanks for any help!. @Andarist so same goes for sagas paused ontakeEveryor no? So in my example,saga2is paused ontakeEverywhenEND` is dispatched, so it is released at that point. Are you verifying that that is correct behavior?\nIf so my more general question is, is there a way to set it up such that I can put an event from one saga and listen for that event from another saga after END? This seems like a common scenario to enable a saga to listen for something like a success event that is dispatched by a different saga, right?. @bmealhouse No I didn't. I solved what I was doing differently without needing that ability. I intend to dig into the code and see if I can figure out a way to make this work though because it would make my implementation cleaner and it just feels like it should work, but I'm not yet that familiar with how sagas work under the hood. Let me know if you make any progress on it. . ",
    "bmealhouse": "@keithnorm - Did you end up solving your problem with server-side rendering?  What was the solution?\n\nHow do you enable a server-side saga to listen for something like a success event that is dispatched from a different saga?\n\nI'm still learning redux-saga and I'm not finding a clear solution to this problem.  In my debugging, I have verified (using SagaMonitor) that END is terminating my second saga, so I am getting results like this:\n```js\n// 1. start: rootSaga\n// 2. fork: saga1\n// 3. fork: saga2\n// 4. dispatch: FETCH_DATA_FROM_SAGA_1\n// 5. dispatch: END\n// 6. saga2: END - terminates since there is no pending work being done\n// 7. saga1: fetches async data\n// 8. saga1: put FETCH_DATA_FROM_SAGA_2 (nothing happens since this saga2 has already ended)\n// 9. saga1: END - terminates since work is complete\n```\nI see there was some suggestion to use channels or take.maybe, but I have not been able to figure out how to get this working.\n/cc @Andarist . @keithnorm - Did you end up solving your problem with server-side rendering?  What was the solution?\n\nHow do you enable a server-side saga to listen for something like a success event that is dispatched from a different saga?\n\nI'm still learning redux-saga and I'm not finding a clear solution to this problem.  In my debugging, I have verified (using SagaMonitor) that END is terminating my second saga, so I am getting results like this:\n```js\n// 1. start: rootSaga\n// 2. fork: saga1\n// 3. fork: saga2\n// 4. dispatch: FETCH_DATA_FROM_SAGA_1\n// 5. dispatch: END\n// 6. saga2: END - terminates since there is no pending work being done\n// 7. saga1: fetches async data\n// 8. saga1: put FETCH_DATA_FROM_SAGA_2 (nothing happens since this saga2 has already ended)\n// 9. saga1: END - terminates since work is complete\n```\nI see there was some suggestion to use channels or take.maybe, but I have not been able to figure out how to get this working.\n/cc @Andarist . @keithnorm @rosendi - I did find a solution to this problem using channels, however, I'm not sure it is the recommended approach.  It would be nice to get some feedback from the community, @yelouafi, and @Andarist.\nHere is a simple weather example.  To kick things off, FETCH_LOCATIONS_REQUEST needs to be dispatched, which will put locations-saga.js and weather-saga.js in a running state.  When END is dispatched it will terminate all sagas that aren't in the middle of doing work.  Since locations-saga.js and weather-saga.js are still running, they will not be terminated until their work is complete.\n\nmain.js\n```js\nimport {END} from 'redux-saga'\nimport store from './store'\nstore.dispatch({\n  type: 'FETCH_LOCATIONS_REQUEST'\n})\nstore.dispatch(END)\n```\nroot-saga.js\n```js\nimport {all, fork} from 'redux-saga/effects'\nimport locationsSaga from './locations-saga'\nimport weatherSaga from './weather-saga'\nfunction* rootSaga() {\n  yield all([\n    fork(locationsSaga),\n    fork(weatherSaga)\n  ])\n}\nexport default rootSaga\n```\nlocations-saga.js\n```js\nimport {channel} from 'redux-saga'\nimport {call, fork, put, take} from 'redux-saga/effects'\nimport {weatherChannelHandler} from './weather-saga'\nimport * as api from './utils/api'\nfunction* fetchLocations() {\n  const locations = yield call(api.fetchLocations)\nyield put({\n    type: 'FETCH_LOCATIONS_SUCCESS',\n    locations\n  })\nreturn locations\n}\nfunction* locationsSaga() {\n  const weatherChannel = yield call(channel)\n  yield fork(weatherChannelHandler, weatherChannel)\nwhile(true) {\n    yield take('FETCH_LOCATIONS_REQUEST')\n    const locations = yield call(fetchLocations)\n    yield put(weatherChannel, locations)\n  }\n}\nexport default locationsSaga\n```\nweather-saga.js\n```js\nfunction* fetchWeather(action) {\n  // fetch weather data from api...\n  // action.locations available here\n}\nexport function* weatherChannelHandler(channel) {\n  const action = yield take(channel)\n  yield call(fetchWeather, action) // blocking\n}\nfunction* weatherSaga() {\n  // listen for other actions...\n  yield takeEvery('SELECT_LOCATION', fetchWeather)\n}\nexport default weatherSaga\n```. @keithnorm @rosendi - I did find a solution to this problem using channels, however, I'm not sure it is the recommended approach.  It would be nice to get some feedback from the community, @yelouafi, and @Andarist.\nHere is a simple weather example.  To kick things off, FETCH_LOCATIONS_REQUEST needs to be dispatched, which will put locations-saga.js and weather-saga.js in a running state.  When END is dispatched it will terminate all sagas that aren't in the middle of doing work.  Since locations-saga.js and weather-saga.js are still running, they will not be terminated until their work is complete.\n\nmain.js\n```js\nimport {END} from 'redux-saga'\nimport store from './store'\nstore.dispatch({\n  type: 'FETCH_LOCATIONS_REQUEST'\n})\nstore.dispatch(END)\n```\nroot-saga.js\n```js\nimport {all, fork} from 'redux-saga/effects'\nimport locationsSaga from './locations-saga'\nimport weatherSaga from './weather-saga'\nfunction* rootSaga() {\n  yield all([\n    fork(locationsSaga),\n    fork(weatherSaga)\n  ])\n}\nexport default rootSaga\n```\nlocations-saga.js\n```js\nimport {channel} from 'redux-saga'\nimport {call, fork, put, take} from 'redux-saga/effects'\nimport {weatherChannelHandler} from './weather-saga'\nimport * as api from './utils/api'\nfunction* fetchLocations() {\n  const locations = yield call(api.fetchLocations)\nyield put({\n    type: 'FETCH_LOCATIONS_SUCCESS',\n    locations\n  })\nreturn locations\n}\nfunction* locationsSaga() {\n  const weatherChannel = yield call(channel)\n  yield fork(weatherChannelHandler, weatherChannel)\nwhile(true) {\n    yield take('FETCH_LOCATIONS_REQUEST')\n    const locations = yield call(fetchLocations)\n    yield put(weatherChannel, locations)\n  }\n}\nexport default locationsSaga\n```\nweather-saga.js\n```js\nfunction* fetchWeather(action) {\n  // fetch weather data from api...\n  // action.locations available here\n}\nexport function* weatherChannelHandler(channel) {\n  const action = yield take(channel)\n  yield call(fetchWeather, action) // blocking\n}\nfunction* weatherSaga() {\n  // listen for other actions...\n  yield takeEvery('SELECT_LOCATION', fetchWeather)\n}\nexport default weatherSaga\n```. @suciuvlad - Thank's for sharing, however, I don't believe your example is showcasing the problem being discussed. Please correct me if I missed something.\nIn your example, all the asynchronous work is happening inside a single saga. This doesn't cause any issues for server-side rendering, since the server will wait until the saga has completed it's work before sending a response to the client.\nThe problem being discussed, is dealing with two sagas, with one being dependent on the other.\n. @suciuvlad - Thank's for sharing, however, I don't believe your example is showcasing the problem being discussed. Please correct me if I missed something.\nIn your example, all the asynchronous work is happening inside a single saga. This doesn't cause any issues for server-side rendering, since the server will wait until the saga has completed it's work before sending a response to the client.\nThe problem being discussed, is dealing with two sagas, with one being dependent on the other.\n. @suciuvlad - No problem, thanks again for sharing.. @suciuvlad - No problem, thanks again for sharing.. @craigtaub - The example does use data from the 1st async response for the 2nd async request.  You can pass any sort of action or raw data into your channel.  I hope this helps.\n```js\nfunction* fetchLocations(weatherChannel) {\n  const locations = yield call(api.fetchLocations)\nyield put({\n    type: 'FETCH_LOCATIONS_SUCCESS',\n    locations\n  })\nreturn locations\n}\nfunction* locationsSaga() {\n  const weatherChannel = yield call(channel)\n  yield fork(weatherChannelHandler, weatherChannel)\nwhile(true) {\n    yield take('FETCH_LOCATIONS_REQUEST')\n    const locations = yield call(fetchLocations)\n// trigger second async request with different action\nyield put(weatherChannel, {\n  type: 'DIFFERENT_ACTION',\n  locations\n})\n\n}\n}\n```\n. @craigtaub - The example does use data from the 1st async response for the 2nd async request.  You can pass any sort of action or raw data into your channel.  I hope this helps.\n```js\nfunction* fetchLocations(weatherChannel) {\n  const locations = yield call(api.fetchLocations)\nyield put({\n    type: 'FETCH_LOCATIONS_SUCCESS',\n    locations\n  })\nreturn locations\n}\nfunction* locationsSaga() {\n  const weatherChannel = yield call(channel)\n  yield fork(weatherChannelHandler, weatherChannel)\nwhile(true) {\n    yield take('FETCH_LOCATIONS_REQUEST')\n    const locations = yield call(fetchLocations)\n// trigger second async request with different action\nyield put(weatherChannel, {\n  type: 'DIFFERENT_ACTION',\n  locations\n})\n\n}\n}\n```\n. ",
    "suciuvlad": "I did it with static methods: https://github.com/suciuvlad/react-universal-starter. @bmealhouse Sorry, my bad.. ",
    "craigtaub": "@bmealhouse any idea how to approach using 1st async response data for 2nd async (via seperate actions), both before rootTask.done is resolved? \ne.g. Auth token (e.g. fetchToken -> fetchRealData -> render now). Great thanks @bmealhouse . \nAn update to above, I wrapped my while loop in a try catch block so we close and unsubscribe from the channel when END is triggered.\n```js\ntry {\n  while(true) {\n    yield take('FETCH_LOCATIONS_REQUEST')\n    const locations = yield call(fetchLocations)\nyield put(weatherChannel, {\n  type: 'DIFFERENT_ACTION',\n  locations\n})\n\n}\n} finally { // END triggered\n  weatherChannel.close(); // close + unsubscribe from channel\n}\n```. ",
    "garpur": "Thank you that did the trick :)\n. ",
    "leimonio": "@yelouafi @garpur Trying the same test case with Jest doesn't work the same for the select saga effect. \nconst gen = saga()\nexpect(gen.next().value).toEqual(select(mySelector));\nJest returns the following explanation:\nExpected value to equal:\n  {\"@@redux-saga/IO\": true, \"SELECT\": {\"args\": Array [], \"selector\": [Function stateSelector]}}\nReceived:\n  {\"@@redux-saga/IO\": true, \"SELECT\": {\"args\": Array [], \"selector\": [Function stateSelector]}}\nDifference:\nCompared values have no visual difference.. @Andarist mySelector is nothing more that an anonymous function that returns the current redux state, so it's something like const state = yield select(state => state). Is this not a proper way?\nI should better have a common reference as reducer for the selector and import it from that file?. Yeap so the above approach made it work! So as you described @Andarist the reference is the same in that way. Is it common to place sagas selectors (relative to state) in reducers file/folder?. There are some cases I conditionally yield on saga effects, and so I want to test both cases. This leads to repetition of unit tests, in order to reach that specific generator step where you handle this condition. Is it possible to write your unit tests by removing this repeated steps?. @neurosnap I really like the above example, it seems to make testing sagas extremely concise. I will try to integrate your library in my tests and let you know. Testing against snapshots is really nice as a feature, is it also available in intermediate steps other than the last one? Or does the .toJSON() keeps a tree of all the steps until the saga is completed?. ",
    "secobarbital": "In order to keep the navigation logic inside the component, I send a onSuccess callback in the action, which the saga can call upon completion. This pattern does pollute the action with a non-serializable function.\n. @jshthornton Indeed, that is what we do!\nWe haven't actually had to serialize actions yet so we haven't thought about serializability of payload vs meta, but I will certainly keep your comment in mind when we need to.\nIn this case the callbacks definitely belong in meta as they are not part of the form inputs being submitted.\n. Thanks! Sorry for the delay, can only work on this on the weekends ;)\n. That will fix the issue I was having, which was passing 2 arguments without a matcher. However, I believe it is idiomatic to test arguments for undefined instead of testing number of arguments.\nWith the introduction of default arguments, there is now a reason to intentionally pass undefined arguments in order to use default values and still pass an argument after the defaulted one. This particular function is a great example: it has a default argument in the middle position, which means I have to intentionally pass in undefined as buffer if I wanted to take advantage of the default and still pass in a matcher.\nBTW the matcher argument is not documented so we should probably fix the doc as well, but I don't know enough about it to fix the doc for you.\n. Got it. I will make the change so that we fix the documented behavior (2 arguments), but IMO it is the function caller/callee contract that undefined is the same as not passing an argument in that position.\nI think one of the uses of undefined is to indicate no argument, which is why it is used to determine whether to use the default value or not. In fact for this particular function I would make the identity function the default matcher, and not perform any checks at all: eventChannel(subscribe, buffer = buffers.none(), matcher = x => x)\nThe mistake of passing in an undefined variable could be made in any argument position, so if I did that for the second argument, I would unintentionally get your default buffer type and that could also lead to very subtle bugs in my application. Without a default for the third argument we would be handling the two arguments inconsistently.\n. Ok I will move it down. Do we need to check for instanceof Error in there as well then? What other kinds of result can we expect here?\n. ",
    "jshthornton": "@secobarbital I think in regards to the non-serializable part FSA is to the rescue. Use payload for the actual serializable data, and then the meta for anything which just surrounds it.\nSo:\n{\n  type: 'ACTION',\n  payload: {\n    id: 1\n  },\n  meta: {\n    updateUI: function() ...\n  }\n}\n. I really like the signals and messages approach. It is something that I am already doing in my applications, but everything is still labelled under actions. The clear separation makes it more obvious to the developers which actions should be listened to, and which ones should alter the state.\nI think this could play well nicely in with other modules like redux-ui, so that you would have a signal which says 'hey, the user clicked the close button' which then produces a couple of messages such as 'well close the window, oh and whilst you are at it, send an analytics update message'.\nUpdate:\nOn the topic of signals and messages. I wonder if it would be better to keep actions instead of signals. As action still perfectly describes what it is doing, and it is also backwards compatible. I.e. any external library not using redux-saga (and letting your handle your business logic) will use actions.\nUpdate 2:\nIf we are proposing to keep a separation of user actions and reducer actions (signals and messages) what do people think the best naming convention would be? In the attached article they choose to go with prefixing U_ for signals, and R_ for messages.\n. ",
    "floriangosse": "I started with common saga like a login flow and implemented custom actions and sagas for specific containers.\nThese UI sagas trigger the common action and take the success/failure actions for redirect to the correct url. With this solution we can split the BL from UIL (UI-Logic).\n. I started with common saga like a login flow and implemented custom actions and sagas for specific containers.\nThese UI sagas trigger the common action and take the success/failure actions for redirect to the correct url. With this solution we can split the BL from UIL (UI-Logic).\n. ",
    "alex-shamshurin": "Under certain circumstances redirect might be done in Sagas on server via promises(rendering wait unlil saga's functions finished), because onEnter hooks in routes happens before match() and before sagas. So in OnEnter callback it is very easy to redirect but we are at \"before\" state and away from all sagas and all system logic. whereas in sagas all our BL lives.. ",
    "mmcc": "I know this is an old issue, but we started to go down the path of this thread (callback functions in the meta key), but ended up going a slightly different direction.\nIn order to be able to serialize our action in its entirety, instead of a callback function, we ended up going with a callback action that we dispatch at success.  This has been particularly handy in how we do things like delete confirmation. Here's an example:\n```typescript\nfunction *deleteThing (action: Action<'ThingDeleteRequested'>) {\n  const { payload: { id }, meta: { callbackAction } } = action;\nyield put({ type: 'ConfirmAction', payload: { actionType: action.type } });\n  const { canceled } = yield race({\n    confirmed: take('ActionConfirmed'),\n    canceled: take('ActionCanceled'),\n  });\nif (canceled) {\n    yield cancel();\n  }\ntry {\n    yield call(Api.Things.deleteThing, id);\n    yield put({\n      type: 'ThingDeleted',\n      payload: { id },\n    });\n    yield put(callbackAction);\n  } catch (error) {\n    yield put({ type: 'APIRequestFailed', payload: { error } });\n  }\n}\n```\nThen, let's say we want to use this from our ThingShowContainer, we can have a dispatch function that looks like this (omitting the fact that there's an action creator for brevity):\ntypescript\nonDeleteThing: id =>\n  dispatch({ \n    type: 'ThingDeleteRequested',\n    payload: { id },\n    meta: {\n      callbackAction: push(thingPathHelper())\n    }\n  }),\nThis is nice because it allows us to have that action live at the caller, which is required if we want to redirect different places (or not at all) based on where the action is dispatched from.. ",
    "dsblv": "I could just rebase this one ontop of master, does it sound good?\n. ",
    "netfishx": "+1\n. ",
    "elliottsj": "With this new behaviour, how would we go about sending a cancellation into a saga in unit tests? With 0.9.5, I'm able to do generator.throw(new SagaCancellationException()) to simulate a saga cancellation:\njs\nit('should ping with `fetch`, then immediately dispatch PING_FAILURE upon cancellation', () => {\n  const generator = handlePing({ type: PING, payload: 'http://example.com/ping' });\n  expect(generator.next().value).toEqual(put(pingPending()));\n  expect(generator.next().value).toEqual(fork(delay, 1000));\n  const delayTask = createMockTask();\n  expect(generator.next(delayTask).value).toEqual(call(fetch, 'http://example.com/ping'));\n  // Cancel the saga:\n  expect(generator.throw(new SagaCancellationException()).value).toEqual(put(pingFailure()));\n  expect(generator.next().done).toBe(true);\n});\n. With this new behaviour, how would we go about sending a cancellation into a saga in unit tests? With 0.9.5, I'm able to do generator.throw(new SagaCancellationException()) to simulate a saga cancellation:\njs\nit('should ping with `fetch`, then immediately dispatch PING_FAILURE upon cancellation', () => {\n  const generator = handlePing({ type: PING, payload: 'http://example.com/ping' });\n  expect(generator.next().value).toEqual(put(pingPending()));\n  expect(generator.next().value).toEqual(fork(delay, 1000));\n  const delayTask = createMockTask();\n  expect(generator.next(delayTask).value).toEqual(call(fetch, 'http://example.com/ping'));\n  // Cancel the saga:\n  expect(generator.throw(new SagaCancellationException()).value).toEqual(put(pingFailure()));\n  expect(generator.next().done).toBe(true);\n});\n. ",
    "smastous": "It looks pretty good to me.  The only thing you might want to do is add a FETCH_GRID_PENDING action so that you can easily show a loading indicator or something like that.\n``` javascript\nexport function* fetchGrids(action) {\n  try {\n    yield put(actions.fetchGridPending())\nconst grids = yield call(api.GET, 'grids')\nyield put(actions.fetchGridsSuccess(grids))\n\n} catch (error) {\n    yield put(actions.fetchGridsFail(error))\n  }\n}\n```\nYou can also abstract these api calls out into a helper that might look something like:\n``` javascript\nexport function* callApi(apiCall, pendingAction, successAction, rejectedAction, onSuccess=()=>{}, onRejected=()=>{}) {\n  try {\n    yield put(pendingAction)\nconst result = yield call(apiCall)\nyield call(onSuccess, result)\nyield put(successAction(result)\n\n} catch (error) {\n    yield call(onRejected, error)\n    yield put(rejectedAction)\n  }\n}\n```\nThen, create would become something like:\njavascript\n  export function* createGrid(action) {\n    yield fork(callApi, callToYourApi, actions.createGridPending, actions.createGridSuccess, actions.createGridFail, \nfunction*(grid){yield put(actions.closeSubview()) })\n}\nHonestly though, in your case the code is so nice and straightforward already that I don't feel like the added abstraction is really worth it.  I can look at your gist and immediately understand what its doing, which is more valuable than saving a few lines of code.\n. ",
    "chapati23": "Thanks for the feedback, I set \"loading\" as a state in my reducer as soon as an async action gets dispatched so I don't think I need an extra LOADING action. Glad to hear I did it right, so closing this :)\n. ",
    "3LOK": "Thanks, I might have been unclear:\nThere's no API to fetch the access token - it is calculated by the reducer based on results from FB's SDK's callback or Google's SDK's callback (an 'onLogin' callback). Basically you can't 'pull' the access-token if it doesn't exist, the access-token is pushed to the reducer, so I still need somehow to 'wait for the reducer'.\nSo the situation is:\n** LoginSaga\n- [ Do some login things to show FB's login box. ]\n- [ Wait for user to approve login ]\n- [ Put FB_LOGIN_SUCCESS with access-token ]\n** LoginReducer\n- [ Listen to FB_LOGIN_SUCCESS, GOOGLE_LOGIN_SUCCESS, TWITTER_LOGIN_SUCCESS, etc.. ]\n- [ When one of them arrives take the specific server access-token, convert to generic access-token ]\n- [ Store in state. ]\n* My Very Cool Saga:\n- [ Get the generic access-token from the store. ]\n- [ No access-token? Wait for store to have one (** How to do this? ) ]\n- [ Call my-very-cool-api-that-requires-accesstoken-to-do-cool-things with the generic access token, ]\nI hope that was clear enough, let me know if not.\n. @yelouafi Thanks! It could, but I was hoping there might be a cleaner solution: \nThe thing about waiting for the different _LOGIN_SUCCESS is that every time I now add another _LOGIN_SUCCESS (lets say tomorrow I'll add Twitter login), I'll need to remember to update this file as well. I think it somewhat 'harms' the encapsulation (doesn't seem right that some of my sagas will know what are the different login types...). \nThe other option would be to 'put' a generic LOGIN_SUCCESS after each specific *_LOGIN_SUCCESS, and wait for it, but perhaps the concept of waiting for a state change is a valid design pattern to consider in redux-sagas.\nThanks!\n. Thanks!\nI don't 100% love this idea (of going by action string, as it means my other sagas need to know about the actions of the login saga). \nFor the meanwhile, i simply have:\njavascript\nlet accessToken = yield select(state => state.login.access);\nwhile (accessToken === null) {\n    yield take();\n    let accessToken = yield select(state => state.login.access);\n}\nNot pretty at all, but works.\n. I'll make sure to open-source our redux-saga testing infrastructure soon. \nBasically what we wrote is a component that you construct with full initial \"state\", an optional list of reducers (for more complex tests), and the sagas you need (including the tested one). Then our tests look like:\njavascript\nconst tester = new SagaIntegrationTester({state, reducers, sagas}).\ntester.put(someAction());\nreturn tester.waitForAction(types.FINAL.ACTION).then(action => {\n   expect(action.params).to.deep.equal(...);\n   expect(tester.state).to.deep.equal(finalState);\n})\n. @neurosnap I disagree - 'testing that you wrote specific lines of codes' is not unit-test. (by the way, I think that's also what @slorber meant, @slorber correct me if I'm mistaken).\nHere's an example: Lets say I have a function:\njavascript\nfunction foo(params) {\n    var a = params.a;\n    var b = params.b;\n    return a + b;\n}\nNow I have excellent unit test for this function. One day, I decide to change the order of the two 'var' lines - you'll agree with me that the unit test should not break - the function still does exactly what you'd expect it to do, right?\nBut if we see this as a saga:\njavascript\nvar a = yield select(aSelector);\nvar b = yield select(bSelector);\nyield put(actions.Result(a+b));\nIf I were to unit test your way, and now change the order of the two vars, the unit test will fail although the unit still does exactly what it's supposed to be doing (!). That's a clear sign of a bad unit test. This means that the unit test is specific for my specific implementation (implementation = line of codes) - that's not a good unit test. In your case - you might as well just write the same code twice, and use 'diff' - it is effectively the goal you are attempting to accomplish.\nFor redux-saga, the store and the actions are the inputs and outputs of the saga. To unit-test the saga is to give it different inputs (different stores), and to see its outputs (different actions). It's not the end-to-end test at all (eg. I'm not giving it a real store, or real reducers - just the ones that simulate the test).\nMy type of unit test allow me to refactor the code and still know it does exactly what it's supposed to do, without needing to rewrite the tests.\n. @neurosnap yup, exactly.\n. @yelouafi call effects are executed (since our testing infrastructure uses redux-saga to execute the saga), however we never call the 'real functions' in our unit-testing. All our sagas are initialized with the libraries they use, we never directly 'require' (or 'import') the libraries from the saga (as a rule for TDD):\nHere's an example of our Feedback saga: \n``` javascript\n    export default function* feedbackRootSage(libraries) {\n        yield [\n            fork(waitForFeedback.bind(null, libraries))\n        ];\n    }\nfunction* waitForFeedback(libraries) {\n    yield* takeEvery(types.FEEDBACK, handleFeedback.bind(null, libraries));\n}\n\nfunction* handleFeedback(libraries, action) {\n    const {WixRestaurantsApi} = libraries;\n    const {payload} = action;\n\n    try {\n        yield call(WixRestaurantsApi.sendFeedback, {\n            accessToken:payload.accessToken,\n            feedback:payload.feedbackRequest\n         });\n         yield put(actions.feedbackSent());\n    } catch (e) {\n         yield put(actions.feedbackError(e));\n    }\n}\n\n```\nAs you can see, during testing we can simply initialize the saga with mock libraries (for example a mock WixRestaurantsApi) and simulate different results.\n. @jfairbank @axelson @AsaAyers \nFor me, tests are relevant in the long run if I don't need to change them as long as I don't completely change the logic of the code. As long as the code should perform the same logic, as long as I fix bugs, refactor, and add new logic - the existing tests shouldn't change (just add new tests). Why? Because changing tests increases drastically the chances of introducing bugs in the tests which increases drastically the chances of introducing bugs in the code, and that beats the entire purpose for which I am writing tests (to make sure my code works the same in the long run).\nTesting as described in the documentation simply doesn't follow that rule. Basically any change I do in the original code requires changing tests (since they are so binded together), and I think that's simply wrong in a continuous changing live code. \nIn the very very very rare cases where ordering of yields is important to you, that can be tested as well using our redux-saga-tester.\nIn regards to testing call effects, I do think our solution works best. \nHere's an example of a small test (at the bottom you can see the partial saga I've tested - please disregard me not using selectors. I can share the entire saga and test if requested). See the test of api.sendDeleteRequest for an example of a call effect test (including testing the correct parameters were called):\nThe Test\n``` javascript\ndescribe('DeleteSaga', () => {\nlet sagaTester = null;\nlet apiMock = null;\n\nbeforeEach(() => {\n\n    apiMock = {\n        sendDeleteRequest: sinon.promise()\n    }\n\n    const initialState = {\n        session:{\n            screen:'list'\n        },\n        list: {\n            data:[\n                'mydata1',\n                'mydata2',\n                'mydata3'\n            ]\n        }\n    };\n\n    sagaTester = new SagaTester({\n        initialState,\n    });\n\n    sagaTester.start(DeleteSaga.bind(null, {api: apiMock}));\n});\n\nit('should return delete list index and return to main screen when users selects \"yes\" in the yes/no screen', () => {\n    // User pressed delete\n    sagaTester.dispatch(DeleteActions.actions.request({itemIdx:1}));\n\n    // screen should be 'yes/no'\n    expect(sagaTester.getLastActionCalled()).to.deep.equal([SessionActions.actions.screenAreYouSure()]);\n\n    // user presses 'yes'\n    sagaTester.dispatch(DeleteActions.actions.areYouSureYes());\n\n    // screen should be thinking\n    expect(sagaTester.getLastActionCalled()).to.deep.equal([SessionActions.actions.screenThinking()]);\n\n    // server returns success\n    expect(apiMock.sendDeleteRequest.args[0][0]).to.deep.equal({itemIdx:1});\n    apiMock.sendDeleteRequest.resolve();\n\n    // list should be updated, and screen should go back to the main screen\n    expect(sagaTester.getLastActionCalled(2)).to.deep.equal([\n        ListActions.actions.update({data:['mydata1', 'mydata3']}),\n        SessionActions.actions.screenList()\n    ]);\n});\n\n});\n```\nThe Saga\n``` javascript\nfunction* onDelete(clients, action) {\nconst {itemIdx} = action.payload;\n\nyield put(SessionActions.actions.screenAreYouSure());\n\nconst answer = yield take([\n    DeleteActions.types.ARE_YOU_SURE_NO, \n    DeleteActions.types.ARE_YOU_SURE_YES\n]);\n\nif (answer.type === DeleteActions.types.ARE_YOU_SURE_NO) {\n    yield put(SessionActions.actions.screenList());\n    return;\n}\n\nyield put(SessionActions.actions.screenThinking());\n\ntry {\n    yield call(clients.api.sendDeleteRequest, {itemIdx});\n} catch(e) {\n    yield put(SessionActions.actions.screenError({error:e.toString()}));\n    return;\n}\n\nconst list = _.cloneDeep(yield select(state => state.list.data));\nlist.splice(itemIdx, 1);\n\nyield put(ListActions.actions.update({data:list}));\nyield put(SessionActions.actions.screenList());\n\n}\n``\n. @yelouafi Indeed, I give this specifically as an example foe acall` effect testing. Indeed since in this example every line is an output effect, order (flow) matters, and is tested. (and thank you for the improvement suggestion).\nBut also in this example, if you note, I can change the position of my select effect and the logic that comes with it, without needing to change my test at all. (i don't see a reason to do so, but I can :))\nWe have many 'logic sagas' (compared to this 'UX flow saga') that interact mainly interact with third party services and with the store, without importance to the order of the services (it gets X from Service1, Y from Service2, Z from the Store, does some calculation, and puts an action with f(X,Y,Z)). In these saga tests, the theories I've discussed come strongly into play and are very easily tested with the framework.\n. @slorber - Thanks for your very detailed answer. \nMost of apps contain different business logic flows. For example: 'When a user wants to checkout, show him a contact form, wait for him to click next, then show him a delivery form, ...', or for example: 'when a user wants to delete an item, show him a are-you-sure popup, wait for him to click yes or no, if he/she clicked no, close the popup. if they clicked yes, show a thinker, send the server request, and return back'. Sagas lets us write these flows very explicitly clear:\njavascript\n    function* handleOnDelete(dep, action) {\n        yield put(actions.showAreYouSurePopup());\n        const result = yield take([types.DELETE_POPUP.YES, types.DELETE_POPUP.NO]);\n        yield put(actions.hideAreYouSurePopup());\n        if (result.type === types.DELETE_POPUP.YES) {\n            yield put(actions.showThinking());\n            yield call(dep.server.deleteItem, action.itemId);\n            yield put(actions.stopThinking());\n        }\n    }\nUp until here, I believe we both agree in the usage of sagas as a descriptive way to write your business logic. It's a very powerful tool, that can easily be read and tested. (correct me if I'm mistaken and you disagree). \nHowever, here's where I personally am willing to \"pay\" in all the advantages you've mentioned, in order to achieve something else: readability. Instead of throwing actions that change the state using reducers (even the generic reducer you suggested), I want to change the state in the saga. And furthermore, in some sagas i DO want to access the state (which tightly couples the saga to Redux state). \nWhy? Because I feel that the advantage of having your entire business logic flow concentrated in one place makes development, debugging, and refactoring of business logic ten times easier. To be honest, I believe the 'payment' in complexity I'm paying navigating between different files and flows due to logic split between reducers and sagas accumulates to much more (in terms of developer hours) than the payment I would pay if I ever want to refactor my code from Redux to Backbone (I'll probably do that once every 2-3 years, compared to debugging I do all the time).\nSo to comment specifically on things you said:\n1. Saga not accessing other storage - I agree, but I view it differently. For me there's the constant pairing of , and I feel that each pair should have a single 'database' (the specific path in the store). I don't believe pairs should access other pairs 'storage', but I think in the pair it should be perfectly valid and logical to have the saga access the store it manipulates.\n1. Coupling sagas and redux states - again, I'm willing to pay in this coupling to have clearer and easier code to follow and debug. I don't really think we will move away from redux without also changing the sagas on one hand, and at the same time I'm willing to let \"Yoav of 2018\" pay the price for this decision so \"Yoav of 2016\" will have an easier time following the flow of the system.\n2. Events for other sagas/plugins - I agree - I'll be honest that this point is making me reconsider my solution. Let me think about this :) I might design a special structure of events that you can explicitly define how they need to change the state.\n3. Hot reloading - I think when you move to redux-saga you generally release any hot-reloading of your business logic, and focus your hot reloading only on your React layer. I don't think my structure makes hot reloading less feasible on the \"Flux\" level then it is right now.\nAgain, thanks for your comments.\n. ",
    "stantoncbradley": "thanks @chenxsan you were right!  I see because of this I can yield multiple calls that would otherwise be async and wait for them in the saga, something like:\nfunction* httpConnect(action) {\n  try {\n    const store = yield call(Storage.getUser);  // async call 1\n    const profile = JSON.parse(store[0][1]);\n    const token = JSON.parse(store[1][1]);\n    const status = yield call(Api.connect, profile, token);  // async call 2\n    yield put({type: \"HTTP_CONNECT_SUCCEEDED\", status: status});\n  } catch (e) {\n    yield put({type: \"HTTP_CONNECT_FAILED\", message: e.message});\n    console.log(e.message)\n  }\n}\nvery useful!\n. ",
    "anyong": "Yeah that's pretty much what I'm doing, I just dont understand when I should use fork or run\n. Ok that's clear. Thanks!\n. ",
    "silvenon": "@anyong this issue is resolved then?\n. I'm doing something similar, but in that approach I don't like that I'm using synonyms to differentiate user actions from reducer actions. E. g. the UI triggers the NEW_ITEM, which triggers the CREATE_ITEM in the sagas (REQUEST and SUCCESS/FAILURE). I wish there was a pattern to avoid this awkwardness.\n. Do you have action creators for that? How do you call them? The problem I had is that I can't have both fetchUser() and fetchUser.request(). And using { type: actions.FETCH_USER_REQUESTED } is more redundant and less flexible if I decide to change underlying action style.\n. ",
    "purezen": "Hey, I was initialising sagas in my app first using \nconst sagaMiddleware = createSagaMiddleware(rootSaga)\nconst store = createStore(\n  reducer,\n  applyMiddleware(sagaMiddleware)\n)\nand was encountering error saying Error:\n  createSagaMiddleware can only be called on Generator functions\n  Argument undefined at position 0 is not function!\nwhile setting up tests. This was working fine in the app though. On looking further, when I did an explicit import of store in the test file, the test worked.\nThen, I initialised the store with sagas as is mentioned here, using sagaMiddleware.run(rootSaga) and the test worked without explicitly importing the store in the test which is already being used in the sagas.\nCan you tell me why this happened? Thx!\n. ",
    "dfcarpenter": "I found out that I had to include it in my webpack config like so \nentry: {\n    js: ['babel-polyfill', './index.js'],\n    vendor: ['react']\n  },\n. ",
    "vinogradov": "For those who don't want to use babel-polyfill. Put this BEFORE ALL IMPORTS (at the top of the file):\njavascript\nimport \"regenerator-runtime/runtime\";\nand that's it! No need to add any dependencies because babel-runtime depends on regenerator-runtime already.. thanks @jasontenbrink! It is very important point. I edited my original post according to your comment.. ",
    "protoEvangelion": "@vinogradov I stuck that in my saga file and it worked great! Thanks \ud83e\udd47 . ",
    "jasontenbrink": "@vinogradov thanks!  Quick note to those who come after.  It didn't work until I put it at the top of the file.\nthis worked:\nimport 'regenerator-runtime/runtime'\nimport { applyMiddleware, createStore, compose, combineReducers } from \"redux\"\nimport {createLogger} from \"redux-logger\"\nimport createSagaMiddleware from 'redux-saga'\nimport { helloSaga } from './sagas'\nimport tenants from './tenantsReducer'\nthis didn't:\nimport { applyMiddleware, createStore, compose, combineReducers } from \"redux\"\nimport {createLogger} from \"redux-logger\"\nimport createSagaMiddleware from 'redux-saga'\nimport { helloSaga } from './sagas'\nimport tenants from './tenantsReducer'\nimport 'regenerator-runtime/runtime'. ",
    "borrascador": "The following does not work for me:\nimport 'regenerator-runtime/runtime'\nHowever, the following solution works:\nimport regeneratorRuntime from 'regenerator-runtime'\nAny idea why I am getting different results from the rest of the thread?. ",
    "babeal": "Could you point me to an explanation on how to do that?  It looks like I would need to create my own effect?  Is this correct or is there an easier way.  I figured it would be nice to have the call abstraction understand whether I am using a promise or an observable whether its an Rx version or an ES7 version.  It seems weird that call wouldn't support an ES7 proposed interface.\nI found it - https://github.com/yelouafi/redux-saga/blob/master/docs/basics/UsingSagaHelpers.md\n. @slorber - of course the behavior of an observable can be different than a promise.  In this case for this operator I would expect that the semantics would remain the same and only the first value of the observable would be used.  This may or may not be acceptable.\n. ",
    "lovio": "@davesnx createSagaMiddleware() no longer receive sagas as parameters.\n. You can make a convention in your app.\nLOAD_XXX is a set of actions to trigger api.fetch\nAnd\nXXX is object contains of three states of an api request: REQUEST, SUCCESS and FAILURE just like the example of real-world.\n```\nimport createAction from 'redux-actions';\nexport const loadProducts = createActions('LOAD_PRODUCTS');\nexport const products = {\n  request: createAction('PRODUCT_REQUEST'),\n  success: createAction('PRODUCT_SUCCESS'),\n  failure: createAction('PRODUCT_FAILURE'),\n}\n```\nHere are some gists for your information. ",
    "davesnx": "Thanks, can we specify it on the docs? @yelouafi \n. Thanks, can we specify it on the docs? @yelouafi \n. ",
    "gullitmiranda": "you intend to add a CHANGELOG?\n. you intend to add a CHANGELOG?\n. ",
    "luisherranz": "Ok, I finally got the problem.\nThis is doesn't throw an error inside the generator:\njavascript\nreturn new Promise((r, reject) => reject());\nbut this does:\njavascript\nreturn new Promise((r, reject) => reject({}));\nIt looks like the async/await version throwing the error even with an argumentless reject():\nhttps://tonicdev.com/luisherranz/redux-saga-problem-with-async-await\nSo, is this expected? Is this a bug on how call is managing promise rejects?\n. Thanks @yelouafi.\nRedux-saga is genius, by the way. Many thanks for your awesome work.\n. My bad for not checking that first. Sorry! I'm glad it's already implemented and we missed anyway, makes a lot of sense :). ",
    "danpantry": "@fhelwanger Thanks. That is actually what I had, but I was reconstructing my original example after modifying it a bit (to experiment with takeEvery). I should be more careful :)\n. ",
    "bricejlin": "@fhelwanger ah I see. I was following the docs, which I guess is outdated. Thanks for the pointer!\n. ",
    "WaiSiuKei": "I am using v0.10.0 and noted the improvement of error printing which helps a lot to trace exceptions in sagas.\nThe problem I meet is that my code work like below \njs\nclass Chart extends Component{\n  componentDidMount(){this.doSomething()}\n  doSomething(){\n   let a = undefined.getFullyear()\n  }\n  render(){...}\n}\nBut I get an error report like this\n\nThen I change the code like this\njs\nclass Chart extends Component{\n  componentDidMount(){\n  let a = undefined.getFullyear()\n }\n render(){...}\n}\nThis time I get rignt error report\n\nI want to know how is this wired problem caused?\n. sorry for my bad screenshot, the trace of the first one will help nothing\n\n. I reproduce the bug in the jsfiddle by changing https://github.com/yelouafi/redux-saga/blob/master/examples/shopping-cart/src/components/Product.js to be \n``` js\nimport React, { Component, PropTypes } from 'react'\nexport default class Product extends Component {\n  componentDidMount(){\n    this.doSomething()\n  }\n  doSomething(){\n    let a = undefined.getFullyear()\n  }\n  render() {\n    const { price, quantity, title, action } = this.props\n    return (\n      \n        {title} - ${price} {quantity ? x ${quantity} : null}\n        {' '}\n        {action}\n      \n    )\n  }\n}\nProduct.propTypes = {\n  price: PropTypes.number,\n  quantity: PropTypes.number,\n  title: PropTypes.string,\n  action: React.PropTypes.node\n}\n```\nyou can find the console output similar to the the attached above.\n. That sounds like to have something to do with the length limit of stack trace, but when I change the location of the wrong line a little, as I mention above,  this bug is gone. And one more thingis that, aftet hot replacement by webpack ,the bug will also gone.\n. ",
    "npbee": "I think I've been experiencing this issue recently.  I've been digging into it a bit and I haven't quite figured it out but thought I'd pass along some info.  \nIt seems like there are two issues that may or may not be related.  First is the fact that redux-saga is seemingly throwing errors initially thrown by React components.  @yelouafi, like you said, I traced this to a put effect updating my state, which caused react-redux to render components that had errors.  However, one strange thing I noticed was that the behavior seems to change when using promises.  Here's a fiddle to demonstrate:  \nhttps://jsfiddle.net/npbee/d5dt0fmw/4/\nIf you comment out the promise call at line 35, the error is thrown by React and not redux-saga.  \nThe second issue I think is what this issue was originally about.  When redux-saga does throw, the full stack traces aren't there.  The best I could do was trace it back to this line:\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L237\njavascript\nif(result instanceof Error)\n    result.sagaStack = `at ${name} \\n ${result.sagaStack || result.message}`\nIt seems like it's just building up a new stack from the message of the given error and throwing away any stack trace info that may already be there. \nLet me know if any other info would be helpful!\n. I think I've been experiencing this issue recently.  I've been digging into it a bit and I haven't quite figured it out but thought I'd pass along some info.  \nIt seems like there are two issues that may or may not be related.  First is the fact that redux-saga is seemingly throwing errors initially thrown by React components.  @yelouafi, like you said, I traced this to a put effect updating my state, which caused react-redux to render components that had errors.  However, one strange thing I noticed was that the behavior seems to change when using promises.  Here's a fiddle to demonstrate:  \nhttps://jsfiddle.net/npbee/d5dt0fmw/4/\nIf you comment out the promise call at line 35, the error is thrown by React and not redux-saga.  \nThe second issue I think is what this issue was originally about.  When redux-saga does throw, the full stack traces aren't there.  The best I could do was trace it back to this line:\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L237\njavascript\nif(result instanceof Error)\n    result.sagaStack = `at ${name} \\n ${result.sagaStack || result.message}`\nIt seems like it's just building up a new stack from the message of the given error and throwing away any stack trace info that may already be there. \nLet me know if any other info would be helpful!\n. I think what @yelouafi is saying is that instead of \nyield* takeEvery(...)\n...you can do\nyield call(takeEvery, ...)\nSo if you're testing that the saga yields a call, you'll need to update your watchGetDataSaga to actually yield a call effect.  Here's a fiddle:  https://jsfiddle.net/npbee/jksq12gg/1/.\nAlso, in your snippet above you're testing a call of takeEvery when your code has takeLatest.  It's not the root of the problem but might be causing more confusion for you.\n. I think what @yelouafi is saying is that instead of \nyield* takeEvery(...)\n...you can do\nyield call(takeEvery, ...)\nSo if you're testing that the saga yields a call, you'll need to update your watchGetDataSaga to actually yield a call effect.  Here's a fiddle:  https://jsfiddle.net/npbee/jksq12gg/1/.\nAlso, in your snippet above you're testing a call of takeEvery when your code has takeLatest.  It's not the root of the problem but might be causing more confusion for you.\n. Not dumb!  I'm no expert myself, but I'll explain as I understand it.  \nBoth of these basically have the same functional outcome.  You can test both in the way we discussed above but the return values are different, so the tests would change.  \nThe yield* expression is just a plain JS feature, and it essentially just allows to you to yield to nested iterables.  In this context, doing yield* takeEvery would mean that you're yielding to the every value that the takeEvery iterable itself yields.  So to test yield* takeEvery, you'd be testing for what values takeEvery itself yields back to you, which means you need to know the internals of takeEvery.  \nWhen using yield call(takeEvery, ..), that's a declarative effect from redux-saga and it will only ever yield one value and that is a CALL effect.  You can easily test that the correct effect was yielded.  \nSo long story short:  functionally they are basically the same but testing call effects are easier.\nI made another fiddle that might be more clear:  https://jsfiddle.net/npbee/Lqreq12b/2/.  \nHope that helps!\n. Not dumb!  I'm no expert myself, but I'll explain as I understand it.  \nBoth of these basically have the same functional outcome.  You can test both in the way we discussed above but the return values are different, so the tests would change.  \nThe yield* expression is just a plain JS feature, and it essentially just allows to you to yield to nested iterables.  In this context, doing yield* takeEvery would mean that you're yielding to the every value that the takeEvery iterable itself yields.  So to test yield* takeEvery, you'd be testing for what values takeEvery itself yields back to you, which means you need to know the internals of takeEvery.  \nWhen using yield call(takeEvery, ..), that's a declarative effect from redux-saga and it will only ever yield one value and that is a CALL effect.  You can easily test that the correct effect was yielded.  \nSo long story short:  functionally they are basically the same but testing call effects are easier.\nI made another fiddle that might be more clear:  https://jsfiddle.net/npbee/Lqreq12b/2/.  \nHope that helps!\n. @adjohu, I use reselect and redux-saga together in this way and it seems to work ok, so perhaps there's an error elsewhere?  Here's a quick fiddle:  https://jsfiddle.net/npbee/bsvh7mgw/\n. @adjohu, I use reselect and redux-saga together in this way and it seems to work ok, so perhaps there's an error elsewhere?  Here's a quick fiddle:  https://jsfiddle.net/npbee/bsvh7mgw/\n. ",
    "brabeji": "@npbee your second point is what I've debugged today, too. I think the problem is that result.stack (where the precious stack is) is not passed into successive log call.\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L243\nif(result instanceof Error) {\n    result.sagaStack = `at ${name} \\n ${result.sagaStack || result.message}`\n}\nif(!task.cont) {\n    log('error', `uncaught`, result.sagaStack || result.message)\n}\n. @npbee your second point is what I've debugged today, too. I think the problem is that result.stack (where the precious stack is) is not passed into successive log call.\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L243\nif(result instanceof Error) {\n    result.sagaStack = `at ${name} \\n ${result.sagaStack || result.message}`\n}\nif(!task.cont) {\n    log('error', `uncaught`, result.sagaStack || result.message)\n}\n. I see, that's right! \nI've tried to replace result.message in previous code with result.stack and got:\n\nwhich is fine for me. Is that a good fix for this?\n. I see, that's right! \nI've tried to replace result.message in previous code with result.stack and got:\n\nwhich is fine for me. Is that a good fix for this?\n. ",
    "yarcub": "\nIn the fiddle, the error is thrown while the Saga is executing a put Effect. Seems the dispatching is causing react-redux's Connect to re-render the React Component. the Error is thrown from the Saga (because it was thrown in the same stack frame of yield put)\n\nLike mentioned on #250, i'm also trying to send all uncaught exceptions to a monitoring system. The problem is when it happens on the same frame as a put effect. It would simply be logged by redux-saga and not reach the window.onerror handler. \n@yelouafi, is there an option to disable this behavior and rethrow the exception? Does it makes sense?\n. @yelouafi, is that the correct API? \nsagaMiddleware.run(...).catch is not a function\n. ",
    "cusxio": "@yelouafi Yup ! I got it working now. It has nothing to do with redux-saga, but my server. \nI have a question, is this a valid usage of redux-saga? \nTo dispatch actions on the fly, rather than waiting for a dispatch action using take or takeEvery that the examples seems to promote.\n. Just faced this issue, however I realised that my sagas were being instantiated twice instead of being called twice by LOCATION_CHANGE.\nTurns out, it's a bug from react-router-redux, leaving it here so that someone finds it.. ",
    "hoanguyen311": "@yelouafi how did you get it work?\nI can't make it work even on server side\njavascript\n//sagas is an array of saga\nstore.runSaga = sagaMiddleware.run;\nconst promises = sagas.map(saga => store.runSaga(saga).done);\nPromise.all(promises)\n        .then(() => console.log('DONE'));. ",
    "aaesis": "thanks problem is solve.\n. ",
    "sanfilippopablo": "Oh, exactly what I was looking for. Thanks.\n. ",
    "solcik": "Redux-devtools + Redux-devtools-inspector\nOn May 3, 2016 9:47 AM, \"Yassine Elouafi\" notifications@github.com wrote:\n\nAre you logging the actions from reducers or some middleware like\nredux-loggger?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/296#issuecomment-216460639\n. Sorry, I forgot to mention, that actions with suffix \"#BASE\" have \"api\" property, so as You can see, these are dispatched from the component correctly in botch cases, but in the first one \"watchApiCalls\" saga will not start \"apiCall\" saga for last 2 - will start only for the first one, which results into #START and #SUCCESS actions.\n. \n",
    "Sinistralis": "Well this is embarrassing. Looks like when I converted over I misplaced a paren. Good catch, I was completely blind to that.\nThanks for the help, apologies for wasting time with something unrelated to your work.\n. ",
    "Undistraction": "@yelouafi Was wondering the same thing myself. I need to repeat the same set of actions multiple times with error handling for each action. The equivalent of the following (which won't work because of the yield within the forEach loop):\nfunction* example {\n  items.forEach((item) => {\n    const task = yield call(someSaga, item);\n    const action = yield take([SUCCESS, FAILURE]);\n    if(action === FAILURE) {\n      yield cancel(task)\n    }\n  });\n}. @Andarist Thanks for replying. I oversimplified my example. I'm actually looking for a way to loop over items, but treat each one as part of a sequence rather than have all running concurrently as in your answer above. A dynamic way to do the equivalent of the following (all that changes between the duplicated elements is the item):\n```\nfunction* exampleSaga(items) {\n// First Item\n  const task = yield fork(someSaga, items[2]);\nconst { error } = yield race({\n    success: take(SUCCESS),\n    error: take(FAILURE),\n  })\nif(error) {\n    yield cancel(task)\n  }\n// Second Item\n  const task = yield fork(someSaga, items[2]);\nconst { error } = yield race({\n    success: take(SUCCESS),\n    error: take(FAILURE),\n  })\nif(error) {\n    yield cancel(task)\n  }\n// Third Item\n  const task = yield fork(someSaga, items[2]);\nconst { error } = yield race({\n    success: take(SUCCESS),\n    error: take(FAILURE),\n  })\nif(error) {\n    yield cancel(task)\n  }\n}\n```. Of course! The trusty for-of loop. Thanks again. This was really helpful.. ",
    "idangozlan": "Improving @yelouafi answer:\nfunction* mySaga() {\n  yield all([...[1,2,3].map(x => call(foo, bar))]);\n}\nall is the new way while yielding an array is deprecated and you'll get:\nredux-saga warn: [...effects] has been deprecated in favor of all([...effects]), please update your code. I can do so, but it's make coupling, think about that, for example, lets assume that I want to show only to logged in users \"recent posts\" or whatever, but only on 5 specific pages. that mean that I have to make requests for the \"recent posts\" from all of those specific pages, since the \"recent posts\" component is not rendered if user info is under loading (then it considered as guests, and the recent posts not loaded for guests).. Finally I've created a request of user data on the \"recent posts\" loading generator, then performing the second call of getting the recent posts only if it's a user, and render it according to that. . i have loading state, but then how I can tell the Profile component fetch to be wait till loading is changing to false?. If I understand you right, you mean that in App component im dispatching FETCH_USER, and in Profile component im dispatching FETCH_USER and FETCH_PROFILE (or whatever second fetch is), but it's still not solving the problem, when FETCH_PROFILE is dispatching, the user still not loaded (under loading).. Thanks. there is no way to cancel request across watchers, right?. ",
    "realtebo": "@Andarist : your follwing snippet saved my night of work\njavascript\nfunction* example {\n    yield items.map(item => call(safeSomeSaga, item))\n}. How can we use buffer.expanding ? I can't see any example. @Andarist \nI changed my code into the 3rd version:\nconst tasks = yield all([\n            yield fork(delay3),\n            yield fork(delay5)\n        ]);\nNow I can succesfully cancel using the spread operator.\nyield cancel(...tasks);\n\nthanks !\nAlso, thanks for the note: \n\nYou need to understand that cancellation happens from the outside of the effect and you need to have access to some task descriptor to call cancel on it + knowing the difference between blocking (call here) and nonblocking (fork here) is useful.\n. \n",
    "abelta": "How am I the only one getting an error with this?\nuncaught at check call: argument [object Object] is not a function\nThis is what my code looks like.\njavascript\nfunction * removeCreated() {\n  const points = yield select(state => state.pointsCreated);\n  try {\n    yield all(points.map(point => call(rsf.firestore.deleteDocument, `points/${point}`)));\n    yield call(removeCreatedSucceeded());\n  } catch (error) {\n    yield put(removeCreatedFailed(error.message));\n  }\n}. @GaelS My mistake. That a call to an action generator so correct command would be yield put(removeCreateSucceeded()). Thank you very much.. ",
    "GaelS": "I guess your issue is here : yield call(removeCreatedSucceeded());\ncall expects a function as first argument followed by the arguments used to execute this function with (just like it's done here: call(rsf.firestore.deleteDocument, 'points/${point}'))))\nI guess yield call(removeCreatedSucceeded); should fix your issue.. Is doSomething declared before your saga in your actual code ?\nThe reason could be that function expressions are not hoisted so if your saga uses it before it's declared, it would indeed be undefined.. I don't know if one gets notified with a \"thumbs up\" on a comment but it's rebased ! :) . I guess the race effect will fit your needs : https://redux-saga.js.org/docs/advanced/RacingEffects.html. ",
    "liesislukas": "Just for other googlers, I've just had the same error on React, not native. And it was actually because of undefined.\nWould love to see such explanation in error message itself for the next release. Thanks for your great job \ud83d\udc4d . ",
    "ChadEubanks": "We are getting this issue as well.  Anyone know anything else than the above?\n. ",
    "rpedroni": "Such a simple bug but took me about an hour to find out the cause.\nSince I create constants for all actions, I was passing in an undefined without knowing it.\nBe wary \ud83d\udc4d . ",
    "drewandrew": "@Andarist would it be possible to include the function/saga that this error is being thrown from within the error message? My bundler (webpack) is setup in such a way that makes these errors particularly difficult to track down because the errors . ",
    "codering": "I see.  but redux-saga use the getter  that may break in IE8 ? \n\n\n\n. OK, understand. \n. ",
    "bpmckee": "Ok, so I'm still having trouble.  Assuming my same saga definitions from above, here's the test I have that's failing.\n``` js\nit('should trigger on GET_DATA', () => {\n  // arrange\n  const iterator = watchGetDataSaga();\n  const expectedYield = call(takeEvery, GET_DATA, getDataSaga);\n// act\n  const actualYield = iterator.next().value;\n// assert\n  expect(actualYield).to.deep.equal(expectedYield);\n});\n```\nThis threw some nasty errors\nAssertionError: expected { Object (@@redux-saga/IO, TAKE) } to deeply equal { Object (@@redux-saga/IO, CALL) }\n{\n  -  \"TAKE\": {\n  -    \"channel\": [null]\n  -    \"pattern\": \"GET_DATA\"\n  +  \"CALL\": {\n  +    \"args\": [\n  +      \"GET_DATA\"\n  +      {}\n  +    ]\n  +    \"context\": [null]\n  +    \"fn\": [Function]\n     }\n}\nAdditionally, if I replace call with take in my expectedYield line, I get a much much nastier error.\nError: take(channel, pattern): argument function takeEvery(pattern, worker) {\n... looks like it's takeEvery's internals ...\n} is not a valid channel (channel argument must have a take method)\n. Hey that worked!  Thank you guys.  I'll close this issue now since the question is resolved.\n. ",
    "hwangar": "Not sure if this is working... yeah, the test is passing but code does not work:\n```\nconst { createStore, applyMiddleware } = require('redux');\nconst { default: createSagaMiddleware } = require('redux-saga');\nconst { takeEvery, call } = require('redux-saga/effects');\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore((state = {}) => state, undefined, applyMiddleware(sagaMiddleware));\nconst helloWorld = function() {\n    console.log('Hello world');\n}\nconst watchHello = function* () {\n    //yield takeEvery('hello', helloWorld);\n    yield call(takeEvery, 'hello', helloWorld);\n}\nsagaMiddleware.run(watchHello);\nstore.dispatch({ type: 'hello' });\n```\nCommented code will show greeting, but uncommented does not :(. Figured out myself :)\nThe correct/current way should be:\nyield fork(takeEvery, 'hello', helloWorld);\nSo testing with just:\nassert.deepEqual(\n    gen.next().value, \n    fork(takeEvery, 'hello', helloWorld)\n);. See previous comment: const { takeEvery, call } = require('redux-saga/effects');\nYeah, I know, this way is intended to test watchers sagas. Not sure Andarist, TBH my aim was to write a test for my first comment's code following the indications of this thread... (there's even a gist out there), but instead of launching takeEvery with call I found it works with fork:\n\nSaga is performed on action as intended\nTest works good deep equaling. Of course man!\n\nhttps://codesandbox.io/s/vlvMJqJ5\nI don't think it's a bad import, I checked twice. It works like a charm, thank you @Andarist . ",
    "kencckw": "I got Typescript error when I call(takeEvery, ...)\nThe only way I can do is  takeEvery:any\nPlease help.\nArgument of type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...' is not assignable to parameter of type 'CallEffectNamedFn<{ [x: string]: Func2<string, (action: any) => IterableIterator<any>>; }, string>'.\n  Type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...' is not assignable to type '{ context: { [x: string]: Func2<string, (action: any) => IterableIterator<any>>; }; fn: string; }'.\n    Property 'context' is missing in type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...'.\n. ",
    "xufei": "In the code above, selector cardDisplayedSelector is just an inner function, it maybe used only in this dispatchNewCard  effect, and we export it just for the use of testing, does this seem strange?. @Andarist OK, thanks a lot. ",
    "laat": "After reading a bit more of the code, I have come to the conclusion that this is a bit silly. We should perhaps instead let the log method be as it is, and use the setTimeout trick to rethrow unrecoverable exceptions whenever we encounter them. That should work on both node and in the browser.\n. ",
    "totallymike": "For the record, I advocate for treating chain like call, at least for the time being, the way it looks in the first example.  This would be simplest to implement at the moment.\nThis RFC comes in the form of a pull request because I figure I'd throw up a spike for that behavior as we discussed it.\n. @jbuck79 that's what I've got going on now.  It works pretty well, but I had been wondering about how to make this declarative and integrate it into the saga ecosystem holistically. \n@yelouafi I like that concept.  It's simple, and a direct extension of the current semantics.\nI don't have much time to experiment with this PR anymore, so it may not get much attention from me at the moment.  Would you like me to close it for the time being, or keep it open for discussion?\n. ",
    "jbuck79": "I am very interested in this because I think it's a cool idea. But can I play devil's advocate for a second? Why don't you just create a function that calls the api and returns the json or an error object if it fails? That's what I did in my small app and it seems to be working well. The only drawback I can see is if you had some functions that needed json and some others that needed another type. But there aren't that many different types. You could easily further abstract it out into multiple fetch functions.\n. The Nesting Sagas example here is pretty much what I did.\nhttp://wecodetheweb.com/2016/01/23/handling-async-in-redux-with-sagas/\n. +1 on this issue. I'm using the redux-oidc middleware, which throws a USER_EXPIRED or USER_FOUND action right when it loads and I'm not able to catch it in a saga. I'm about to resort to having a reducer catch it and then set a property on the state and then have my app's main component dispatch an action when that property is set and then catch that action in a saga. I really don't want to do that though.. ",
    "flipjs": "Have a look at this blog/article:\nUsing React (-Native) with Redux and Redux-Saga. A new proposal?\nI really like the idea. I just started a new project and will be implementing this. Just like you said, sync or async, it will be handled by Saga. I'll split my actions into two and probably call it signals and messages. All signals, which are invoked from UI or lifecycle methods, will be captured by Saga and processed there. Saga will produce the messages, which then go to the reducers.\n. What I do is, I add suffixes, like for example:\nFor (async) API request, my ui action is FETCH_USER\nThen in reducer, I have:\nFETCH_USER_REQUESTED\nFETCH_USER_RESOLVED\nFETCH_USER_REJECTED\nFor UI state, like for example showing notification, my action would be: SHOW_NOTIFICATION.\nIn reducer, it would be SHOW_NOTIFICATION_CALLED\nI reserved _REQUESTED, _RESOLVED, and _REJECTED for api requests.\n. You only need fetchUser() as your action which is called somewhere in your component. That will be captured and processed by Saga. Saga will emit FETCH_USER_REQUESTED (this could be optional like for example if you want to load spinner). Once you received the data or failed, you either emit RESOLVED or REJECTED.\nHere have a look at this working example I created for you.\nhttps://gist.github.com/flipjs/b8bf9ba0197e0ea65518d0dcfddd5f51\nYou dont even need to use suffixes. You can just add the status in your payload. Have a look at redux docs where it shows 2 examples on how you might create your async action creators.\nhttp://redux.js.org/docs/advanced/AsyncActions.html\n. ",
    "jbrodriguez": "I'm currently doing this right now.\nMy actionCreators and reducers have shrunk to \"mostly\" one-liners.\nI think the most important take away is that business logic (and orchestration) live in only one place in my code: the sagas.\nOh, I like the idea of signals vs messages.\n. ",
    "tugorez": "Hi guys, it is a really nice discussion here. \nDo you have any project which implements this pattern ? \nHave you seen any cons (ex performance issues, duplicated code etc... ) ?\nFor example what would normally requires one call ( dispatch({ type: 'SET_USERNAME', ...} )\nto be preserved now, with this signals-messages approach, will take a sagaWatcher to handle the signal and a message to be preserved by the reducer.\nThank you very much for your time and sorry for my bad english.\n. If any of you guys are interested redux-batcher is shipped with  the emitter (ready to play well with sagas). \n``` javascript\nimport { emitter } from 'redux-batcher';\ncreateSagaMiddleware({ emitter });\n```\n. Hi guys, thank you very much for your responses. \nI'm currently developing a chat app and I need to be very carefully for api calls because the order of creation matters. \nwhat do you think about this approach for composing-syncing sagas\n```javascript\nimport uuid from 'uuid/v4'; \nfunction* sender1() {\n   for (;;) {\n       yield take('SENDER1');\n       const pid = uuid();\n       yield put({ type: 'RECEIVER',  payload: {...payload, pid } });\n       yield take(pid);\n       //... do something else\n   }\n}\nfunction* sender2() {\n   for (;;) {\n       yield take('SENDER2');\n       const pid = uuid();\n       yield put({ type: 'RECEIVER',  payload: {...payload, pid } });\n       yield take(pid);\n       //... do something else\n   }\n}\nfunction* receiver() {\n   for (;;) {\n      const { payload } = take('RECEIVER');\n      const { pid } = payload;\n      try {\n          const result = yield call(api.login, payload);\n          yield put({ type: pid, payload: { result  } });\n       } catch(error) {\n          yield put({ type: pid, payload: { error } });\n       }\n    }\n}\nexport default function*() {\n  yield [call(receiver), call(sender1), call(sender2)];\n}\n. Thank you for your response Andarist.\nWhat you mean by happen to close each other? \nreceiver1 and receiver2 are supposed to wait for an action, do something and then wait for the same action again. Excellent answer Andarist :) , I think I will use the actionChannel in order to warranty the order creation in the server. . @Andarist is there any difference betweenjavascript\nconst chan = yield actionChannel('RECEIVER', buffers.expanding());\n```\nand \njavascript\nconst chan = yield actionChannel('RECEIVER');. perhaps related to https://github.com/redux-saga/redux-saga/issues/886 and https://github.com/redux-saga/redux-saga/issues/891. ",
    "phdog": "I've also came close to this signals-messagaes separation, though still labeling both as actions,  but keeping in separate files. ",
    "NickFranceschina": "pure happiness is when I'm struggling with a question, have a gut instinct as to what should be done but have no one to confirm my feelings, and then stumble upon the exact question being answered in the way my instincts were telling me \ud83d\ude04  thank you so much!. ",
    "dixitc": "Yup , should've seen that one . Thank you .\n. Yea I ended up using yield files.map(file => call uploadImageApi)\n. ",
    "davidjbradshaw": "Yep, it's passed to http://github.com/agraboso/redux-api-middleware\nShould I be using something other than put now?\n. This is the action.\n``` js\nimport { CALL_API, Schemas } from '../middleware/api';\nimport * as types from 'actionTypes/searchResultsTypes';\nimport { serialize } from 'utils/utils';\nimport config from 'config/global';\nexport const fetchSearchResults = (endpoint) => ({\ntypes: [types.SEARCH_RESULTS_REQUEST, types.SEARCH_RESULTS_SUCCESS, types.SEARCH_RESULTS_FAILURE],\nrootUrl: '/bridge',\nschema: Schemas.SEARCH_RESULTS,\nendpoint,\n\n},\n});\nexport const loadSearchResults = (params) => {\n  const defaultParams = {\n    page: 1,\n    state: '',\n    url: '/holidays/',\n    pageStart: 0,\n    results: 10,\n    noNav: 1,\n  };\nreturn fetchSearchResults(/?${serialize(Object.assign(defaultParams, params))});\n};\n``\n. From my point of view it would be nice to haveputandputSync` options as I think having 'put' waiting is not a behavior I would expect.\nI will give the fork idea a go this afternoon, when I have a bit more free time. If it works I have to change it in a lot of places.\nThanks.\n. Just wondering when your going to released this patch.\nThanks\n. Thank you\n. ",
    "adjohu": "Agreed, this is making my logic much harder to debug.\n. No luck.\nMy hack for now is:\nconst dogSelector = (state, props) => {\n  return dogsSelector(state).get(props.params.dogId)\n}\n. So it seems to be an issue specifically with createSelector in reselect.\n. Selectors have the signature (state, props) => stateSlice where props is\na plain object (usually an @connected component's props).\nI thought that calling yield select(selector, {...props}) would pass\nprops into the selector.\n\nAdam Hutchinson\nSent with Airmail\nOn 8 June 2016 at 14:55:26, Andy Kenward (notifications@github.com) wrote:\n@adjohu https://github.com/adjohu Reselect doesn't support arguments\nhttps://github.com/reactjs/reselect#q-how-do-i-create-a-selector-that-takes-an-argument\nbeing passed to them by default.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/377#issuecomment-224596250,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAoB8bbbhrSPNa_WmPdpHytrFQ3FflDlks5qJsnGgaJpZM4Iv70L\n.\n. Based on that link, maybe I need to rethink my implementation.\n\nAdam Hutchinson\nSent with Airmail\nOn 8 June 2016 at 14:55:26, Andy Kenward (notifications@github.com) wrote:\n@adjohu https://github.com/adjohu Reselect doesn't support arguments\nhttps://github.com/reactjs/reselect#q-how-do-i-create-a-selector-that-takes-an-argument\nbeing passed to them by default.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/yelouafi/redux-saga/issues/377#issuecomment-224596250,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAoB8bbbhrSPNa_WmPdpHytrFQ3FflDlks5qJsnGgaJpZM4Iv70L\n.\n. ",
    "SpainTrain": "nit: this would have perhaps been better behind a minor version bump given that this breaks code that relies on the 0.10.0-0.10.4 behavior\n. \nReviewed 7 of 7 files at r1.\nReview status: all files reviewed at latest revision, all discussions resolved.\n\nComments from Reviewable\n Sent from Reviewable.io \n. ping a doodle doo :-). ",
    "pavanpodila": "Thanks @yelouafi for giving a simpler form of the saga. I've created a runnable gist here: https://gist.github.com/anonymous/4a0ec7bde66323effd9224fecc0e5305 \nYou can see that the yield cancelled() is still not called. However I do see a slow action cancelled message on the console. I would ideally like my code in finally getting executed.\n. Awesome! Really is subtle. So lesson for me is to run all effects inside the try/catch/finally block\n. Just to finish off, I do see the console logs correctly and the yield cancelled() is getting called:\n\"@@redux/INIT\"\n\"NO_ACTION\"\n\"SLOW_ACTION\"\n\"CANCEL_SLOW_ACTION\"\n\"SLOW_ACTION_CANCELED\"\n\"slowAction has been cancelled\"\n\"\"\n\"NO_ACTION\"\n. ",
    "jonboiser": "Sounds good! I'm working on it now.\n. Sounds good! I'm working on it now.\n. Made the change. Not sure were I got that pattern from, might have been a blog post.\n. Made the change. Not sure were I got that pattern from, might have been a blog post.\n. No problem! I'll see if I can tackle the 'real-world' example soon.\n. No problem! I'll see if I can tackle the 'real-world' example soon.\n. ",
    "DEllement": "Thanks @slorber for sharing your code, very apreciated :+1: \n. So here was the solution for AltJs\n```\nimport alt from './alt';\nimport { runSaga }  from 'redux-saga';\nimport rootSaga from './app/sagas';\nvar AppStore = require('./app/stores/AppStore');\nconst reduxSagaIO = {\n    dispatch: events => alt.dispatch(events),\n    subscribe: listener => {\n        const callback = (events) => {\n            //console.log(events.type, events);\n            listener(events);\n        }\n        const callbackId = alt.dispatcher.register(callback);\n        return () => alt.dispatcher.unregister(callbackId )\n    },\n    getState: () => AppStore.getState //AppStore is my main AltJs Store instance\n}\nrunSaga(rootSaga(), reduxSagaIO);\n```\n. ",
    "StevenLangbroek": "Thanks for the quick reply. Would this be correct then?\njs\nfunction* checkOrderSaga() {\n  for(let i = 1; i <= 5; i++) {\n    try {\n      const order = yield call(orderApi);\n      return order;\n    } catch(err) {\n      if(i < 5) {\n        yield call(delay, 2000);\n      }\n    }\n  }\n  // attempts failed after 5x2secs\n  return new Error('Order not fulfilled. Giving up.');\n}\nthen in the containing saga:\n``` js\nexport default function* tryOrderStatus() {\n  while (true) { // eslint-disable-line no-constant-condition\n    yield take('CHECK_ORDER_STATUS');\n    try {\n      const order = yield call(checkOrderStatus);\n      yield put({\n        type: 'ORDER_STATUS_SUCCESS',\n        payload: order,\n      });\n    } catch (error) {\n      yield put({\n        type: 'ORDER_STATUS_ERROR',\n        error,\n      });\n    }\n  }\n}\n```\nEdit: ok sorry I should draft before I submit!\nEdit: sorry again! :P\n. And I call this \"subsaga\" with call effect?\n. ",
    "BenDiuguid": "I made that change, and the test still fails. I should also say that the code works when I run it, but the test will fail with the strange error.\n. https://redux-saga.github.io/redux-saga/docs/basics/UsingSagaHelpers.html has yield* with takeEvery also, is this correct?\nAlso good catch, I need to do call(delay, 2000) \nThis fixed my issue, along with some simple test fixes!\n``` javascript\ndescribe('SignUpSubmission SAGA', () => {\n  it('Should delay for 2 seconds, then dispatch SIGN_UP_SUCCEEDED', () => {\n    const mockAction = {payload:{}};\n    const generator = submitSignUp(mockAction);\nexpect( generator.next().value ).to.deep.equal( call(delay, 2000) );\n\nexpect( generator.next().value ).to.deep.equal( put({ type: 'SIGN_UP_SUCCEEDED', payload: mockAction.payload }) );\n\nexpect( generator.next() ).to.deep.equal( {done: true, value: undefined} );\n\n});\n});\n```\n. ",
    "oreqizer": "OK I found a solution - see startSubmit and stopSubmit. I'll use that in the Sagas themselves to replicate the behavior.\nFunny that I was figuring this out for two days - combining so many different APIs is not as obvious at times. \ud83d\ude2d \n. we use server side rendering in production at kiwi.com and rendering has never been an issue. it's the fetchComponentData stuff that's the bottleneck.\nanyway, I have a universal react, router, redux saga etc. boilerplate here, the component's being rendered only once. I don't see a reason to render it twice. The rendering takes place here.\nEDIT:\nnow that I think about it, if you mean that I first renderToString, insert it to the component root, then renderToStaticMarkup the whole thing - I don't really think it renders the innards a second time, since they already are rendered with all React's fancy stuff, and it's just a string prop anyway.\n. ",
    "sai-nagarjuna-t": "When u have server-side rendered markup already in place, use the following to avoid rending twice.\n```\nconst rootEle = document.getElementById('root');\nif (rootEle.hasChildNodes()) {\n  ReactDOM.hydrate(, rootEle);\n} else {\n  ReactDOM.render(, rootEle);\n}\n```. ",
    "caesarsol": "Hello, thanks for the response and for the documentation link (have to admit I missed that one).\nCould you elaborate on the reason why it's not recommended to do such calls inside a Reducer?\nSeems that it's the approach used in in redux-elm by @salsita, am I wrong?\nIf you are not familiar, it binds every reducer with its relative saga, but actually it makes sure that there are no double-triggers with its way of propagating actions. Is that the main concern?\nthanks!\n. ",
    "Beingbook": "Is this in progress?\n. ",
    "pgherveou": "@ryyppy \nDo you think there is a way to define return type of yield statement in this typical redux-saga code? \n``` js\n/ @flow /\ndeclare var getFoo: () => Promise\ndeclare var call: (fn: () => Promise) => any\nfunction * mySaga(): Generator<, , *> {\n  // I am expecting a string \n  // but yield type can't really be type checked, since they are dynamic\n  // other issue are that return type of yield are maybe type \n  const foo: ?string = yield call(getFoo)\n// only workaround that works for me for now is to force cast and add all this extra parentheses\n  const foo: string = ((yield call(getFoo)): any)\n}\n```\n. thks for the explanations @ryyppy \n. ",
    "tychota": "@ryyppy can I help you ?\n. ",
    "jschlieber": "Take a look here: Channels.\nYou can use eventChannel to subscribe to Tracker.autorun(() => { ... }).\n. Here is my personal approach to sync Meteor Collections with the Redux store. The meteorDataSaga generator function* takes an Array of Mongo.Collection as its first parameter:\n``` javascript\nimport {Tracker} from 'meteor/tracker';\nimport {eventChannel} from 'redux-saga';\nimport {\n  take,\n  call,\n  put,\n} from 'redux-saga/effects';\nexport const METEOR_FETCH_DATA = 'METEOR_FETCH_DATA';\nfunction fetchData(Collection) {\n  const entityName = Collection._name;\n  return eventChannel(dispatch => {\n    const computation = Tracker.autorun(() => {\n      const data = Collection.find().fetch();\n      setTimeout(() => dispatch({data, entityName}), 0);\n    });\n    return () => {\n      computation.stop();\n    }\n  });\n}\nfunction* observe(channel) {\n  while (true) {\n    const event = yield take(channel);\n    yield put({type: METEOR_FETCH_DATA, ...event});\n  }\n}\nexport default function* meteorDataSaga(Collections) {\n  const channels = [];\n  for (let Collection of Collections) {\n    channels.push(yield call(fetchData, Collection));\n  }\n  const observers = channels.map(channel => observe(channel));\n  yield observers;\n}\n```\nThe meteorDataSaga dispatches an action of type METEOR_FETCH_DATA with data and entityType properties whenever the reactive computation for a Collection reruns. It's then up to the  reducer to handle these actions.\nI normalize the data into an Immutable data structure with an entities reducer:\n``` javascript\nimport Immutable from 'immutable';\nimport {\n  normalize,\n  Schema,\n  arrayOf,\n} from 'normalizr';\nimport {METEOR_FETCH_DATA} from '../sagas/meteor_data';\nfunction normalizeEntities(data, entityName) {\n  const schema = new Schema(entityName, {idAttribute: '_id'});\n  return Immutable.fromJS(normalize(data, arrayOf(schema)).entities[entityName]);\n}\nexport default function entities(state = Immutable.Map(), action) {\n  if (action.type === METEOR_FETCH_DATA) {\n    return state.set(action.entityName, normalizeEntities(action.data, action.entityName));\n  }\n  return state;\n}\n```\nThis way my Redux store is always in sync with all the local MiniMongo Collections i provide to the Saga.\nHope this helps and please let me know if there is a better and more elegant way to do this...\n. I'm also reflecting about a similar approach at the moment. In my opinion, when using the redux store as the single source of truth, we should probably completely bypass MiniMongo and directly use DDP to avoid data duplication and possible performance bottlenecks. I found some projects utilizing this approach (here and here) but they don't use redux-saga to manage side effects. I'm going to try to do a similar thing with redux-saga tomorrow and share my results here...\nExcuse me for not being able to address all your questions at the moment.\n. @jcheroske You're absolutely right. To be honest, I didn't realize how mature the Apollo project and similar efforts already are (or at least they seem to be at first glance). That happens when you're immersed in your own work for months. Thanks for helping me to take a step back and looking at the big picture again. I need to do some research before spending to much time into building a ddp-redux bridge. If Apollo with GraphQL solves all these problems and will be production ready soon, then it's probably not worth all the effort.\n\nSince the whole thing is driven by subscriptions, I'm curious what pattern you're using to handle them with redux. Do you link subs to routes or component mounts? I was thinking about an HOC that would fire subscribe/unsubscribe actions when the component was mounted/unmounted/updated and maybe also when a route was entered/exited. Then a saga could do the actual subscription work, and a record of the subscriptions could be put in the store so that the app could be brought back to its previous state.\n\nFor that purpose I created a special React component called SideEffect. It takes a side effect function or a thunk as prop. That function then gets called in every life cycle method of the SideEffect component provided with a life cycle hook constant as parameter.\n``` javascript\nconst sideEffectThunk = (dispatch) => {\n  let subId;\n  return (hook) => {\n    switch (hook) {\n      case WILL_MOUNT:\n        dispatch(meteorSubscribe('orders', [], id => subId = id));\n        return;\n      case WILL_UNMOUNT:\n        return dispatch(meteorUnsubscribe(subId));\n      default:\n        return;\n    }\n  }\n};\nconst Container = ({dispatch, ...passDownProps}) => (\n  <SideEffect\n    thunk={sideEffectThunk.bind(this, dispatch)}\n\n<Component {...passDownProps}/>\n\n\n);\n```\n\nThe subscription work is then done by a saga.\n. That pretty much depends on your requirements. The simple fetch works well as long as you don't have to deal with really large data sets. But also of course if you want a more fine grained tracking of data changes then observe or even observeChanges is the preferred path.... 1. Your \"function\" RequestPayment doesn't look like a function (there is no function body).\n2. The Redux Saga middleware is in control of running your Sagas, i.e. generator functions. Thus, you never call next yourself. Doing so is a clear indication your doing something wrong. In your case, by calling sendSuccessPayment().next(transactionCode) your just creating an iterator the middleware is not aware of and running your generator function until it reaches the first yield. That's it. By the way: the argument transactionCode will be thrown away, because it is the first next call on that iterator.\n3. You can only yield call your RequestPayment function if it returns a Promise or is a generator function itself.\n4. For Node style functions use yield cps.\n5. For everything else you'd have to either wrap it to return a promise or work with eventChannel\nHope I could help somehow...\n. If you take a look at the API Reference your function call should look like this: \njavascript\nyield cps(RequestPayment, payment.code);\nThe API Reference about the cps effect creator function states clearly: \n\nCreates an Effect description that instructs the middleware to invoke fn as a Node style function\n\nAs you see, you must not call the function yourself. Instead, the Redux Middleware is instructed to do it for you by yielding the effect description. It has nothing to do with the function returning true (I don't really see the point of doing so anyway). The middleware doesn't care about what your Node style function returns...\nThe error message this.callback.abort is not a function is a clear indication that your \"callback\" is in fact not a Node style callback and thus your function is not a Node style function...\nIt seems your \"callback\" is not even a callback but an object with callback properties. One of them being abort. If I guess correctly from your first post, the second one is success. So you could wrap the initLightbox function into a function returning a promise like this:\njavascript\nfunction requestPayment(token) {\n  return new Promise((resolve, reject) => {\n    initLightbox(token, {\n      abort() {\n        reject();\n      },\n      success(transactionCode) {\n        resolve(transactionCode);\n      }\n    });\n  };\n}\nThen your createPayment Saga would look something like this:\njavascript\nexport function* createPayment() {\n  while (true) {\n    const action = yield take(START_PAYMENT);\n    const payment = yield call(paymentApi, action.payload)\n    if (payment.ok) {\n      yield put(successPayment(payment));\n      const gateway = yield call(requestPayment, payment.code);\n      ...\n    } else {\n      yield put(failPayment(payment));\n    }\n  }\n}\nReally try wrapping your head around promises and generator functions first... Cheers!\n. ",
    "minhyeong-kim": "@kuy Your 'task' mean, each request-response sessions? So there is 3 task in those examples?\n```\nREQUEST\n0--------------1--------------2--------------3--------------4--------------5\n[/file/A]  [/file/B]  [/file/A]\n Task1       Task2       Task3\nRESPONSE\n0--------------1--------------2--------------3--------------4--------------5\n               [/file/A]        [/file/A]                          [/file/B]\n                Task1             Task3                              Task2\n``\n. @kuy No need to response validation logic (as i mentioned) or request-response(task, saga) matcher before yieldingput({type: FETCH_OBJECT_SUCCESS})`?\nI'll prototyping this feature. and comment result to this issue. Thank you very much @kuy.\nIf i can solving this problem without any implementation. (meaning creating plugin or extension to redux-saga) i'll use redux-saga and remove all response validation logic in reducers. (i think this increase code complexity)\n. @kuy I got it. your comments are good to understand problems. i appreciate for your effort.\n. @kuy Sure :)\n. ",
    "mskims": "those mentions helped me to understand saga alot! thanks. ",
    "luandro": "Thanks for the awesome response. I've tried creating a promise from the function, and also calling it with cps, but it doesn't work since the first thing it returns is a true. But I think cps might be what I'm looking for, since it logged this.callback.abort is not a function as a callback, which is a good sign already. This is how I tried calling it:\nyield cps(RequestPayment(payment.code, (err, res) => {\n        console.log(err);\n        console.log(res);\n}));\nThis is what the RequestPayment function looks like: \nfunction (token,callback) {\n      try {\n        initLightbox(token,callback);\n        return true;\n      }\n      catch(e) {\n        _logErrors(e,\"initLightbox\");\n        throw e;\n      }\n    }\nThanks for the help, cheers!\n. I'll have a look, thanks for the patience. For now I'm giving up because of time (and knowledge) constraints, and just call the gateway function from the React component where it can access the actions from these weird try and catch functions it creates. But I'll have a closer look at promises and generators for sure.\nCheers!\n. So I guess I was just missing a return statement in the end. I don't fully understand why, but it solved.\n. ",
    "AidanNichol": "I was going to make a PR for a couple of other minor things in the documentation so I'll make this change at the same time if that is OK with you.\n. ",
    "tonyxiao": "In redux-thunk you can do\njavascript\nfunction fetchRequest(id) {\n  return dispatch => {\n    dispatch({ type: FETCH_OBJECTS_REQUEST });\n    return callAPI(id).then(data => {\n      dispatch({ type: FETCH_OBJECTS_SUCCESS, data });\n      return data;\n    }).catch(error => {\n      dispatch({ type: FETCH_OBJECTS_FAIL, error });\n      throw error;\n    });\n  };\n}\nAnd in the calling function\nthis.props.dispach(fetchRequest()).then((data) => {\n  // Do something upon success\n}, (err) => {\n  // Do something upon failure\n})\nStrictly speaking this isn't going through the store, but sometimes it's really convenient to be able to do stuff like this when interacting with other APIs that are imperative rather than declarative.\n. Oh interesting, did not know sagaMiddleware.run has a return value. What about the following scenario?\njavascript\ndescribe('redux thunk', () => {\n  it('increments async by 1', async () => {\n    const store = configureStore({counter: 1})\n    await store.dispatch(incrementAsync(1))\n    const counter = selectCounter(store.getState())\n    expect(counter).toBe(2)\n    await store.dispatch(incrementAsync(1))\n    const counter = selectCounter(store.getState())\n    expect(counter).toBe(3)\n  })\n})\nWould you need to tear down the store and set it up each time? Or re-call sagaMiddleware.run?\n. Read a bit more docs, maybe something like this?\n``` js\nit('increments counter via saga', async () => {\nconst promise1 = sagaMiddleware.run(rootSaga).done\n  store.dispatch(incrementAsyncViaSaga(1))\n  store.dispatch(END)\n  await promise1\n  expect(counter).toBe(2)\nconst promise2 = sagaMiddleware.run(rootSaga).done\n  store.dispatch(incrementAsyncViaSaga(1))\n  store.dispatch(END)\n  await promise2\n  expect(counter).toBe(3)\n})\n```\n. ",
    "messense": "I think this didn't resolve the problem it's not always convenient to report error via state change (think react native alerts)?\nHow can I do that?\n. ",
    "itinance": "https://github.com/itinance/redux-saga-rn-alert. ",
    "oshalygin": "Just looking at this and I like the solution provided by @kuy .  That said, you can still use thunks alongside sagas when you need to.. ",
    "benturner": "This is node 4.4.5 (LTS)\n. Wouldn't it work to use generator.throw(new Error(...)) instead if generator.return() isn't supported? That looks to be supported on Node v4.\n. Ok. I'd suggest adding that to the docs somewhere, but since Node v6 is entering LTS soon I don't think it's worth worrying about on your end. Thanks!\n. ",
    "lieut-data": "I believe I'm running into a similar problem (or misunderstanding) where yield cancel( task ) with task = yield fork( ... ) doesn't cancel the task at all, but task.cancel() does.\n. ",
    "andykenward": "@adjohu Reselect doesn't support arguments being passed to them by default.\n. ",
    "cal0610": "@adjohu  are you using immutable js here?. ",
    "bakatrouble": "Is store.runSaga().done correct solution for this problem?. I could provide example later, but I'll try to explain it now shortly\nI was trying to wire redux-saga together with redux-connect in order to delay router redraw until asynchronous data is fetched, so I needed to get an action promise. I ended up using Task.done promise, getting the Task via store.runSaga(). Is it appropriate way to do it or there are better ones?. ",
    "morgs32": "@bakatrouble I'm with you. Having a ton of flags all over my code for every POST or PUT seems ridiculous. @Andarist, every form that you want to monitor (isDirty? isPristine?) you want to update the \"initialValues\" (to use a redux-form term) when the POST or PUT is complete. I have to have a flag, flip it with the saga, then what, flip it back after the component sees the flag and resets the form?\n\"Natural way of doing this\" seems like a misnomer. Ahhh @musbaig thanks for that issue ref. Thank god for redux-form. . ",
    "TomMahle": "For people coming here significantly after @musbaig's comment I believe this is the one he is referring to: https://github.com/redux-saga/redux-saga/issues/161#issuecomment-229350795 (please correct me if I'm wrong, @musbaig). ",
    "janhartmann": "Migrated to StackOverflow: http://stackoverflow.com/questions/37724377/using-put-inside-anonymous-function-callback as of #378\n. Fixed as of: http://stackoverflow.com/questions/37771746/dispatch-action-every-x-second-using-redux-saga/37786082#37786082\n. They do the same thing, but with an action creator you can define your action one place and use it several places. So e.g if the type signature change, you only have to fix it one place. \nIn the example the selectReddit(reddit) simple does this:\nexport function selectReddit(reddit) {\n  return {\n    type: SELECT_REDDIT, // actually a constant\n    reddit\n  }\n}\nWhich would be the equivalent of doing:\nthis.props.dispatch({type: \"SELECT_REDDIT\", reddit: {reddit} });'\nI would recommend you doing action creators and constants for the defining the type, it is less prone to small typo errors and a general good pattern in my opinion.\n. Okay. I can possible dispatch an action - but I need to do something every time a calendar entry is about to begin. Should I then dispatch an action e.g. every minute? Or is there any better approach? Thank you. :-)\n. Ah, maybe I can do something like\n``` js\nexport function * watchCalendar(action) {\n    while (true) {\n         const { stopped } = yield race({\n            wait: call(delay, 60000),\n            stopped: take(\"STOP_LOOKING_FOR_CALENDAR_ENTRIES\")\n        });\n    if (!stopped) {\n         yield put(actions.lookForUpdates());\n    }\n}\n\n}\nexport default function * calendar() {\n    yield * takeLatest(\"START_LOOKING_FOR_CALENDAR_ENTRIES\", watchCalendar);\n}\n```\nAnd then having a separate saga for the \"lookForUpdates()\" action. Any other suggestions is appreciated. I really need to be near \"realtime\" update. :-)\n. ",
    "coderitual": "What about adding something like that next after saga middleware (not my idea and seems to be working). Ofc only for dev.\nconst sagaFailMiddleware = ({ dispatch }) => next => action => {\n   try {\n      next(action);\n   } catch (e) {\n      setTimeout(() => {\n         throw e;\n      });\n   }\n};\n. @yelouafi what do you think about adding it to the sagas core? Is there a better way to handle such cases?\n. Right. We just use it during development as errors occured in react components are shown as those generated by the put effect and they are really hard to read atm. It also confuses people tbh but yeah, perhabs there is a better solution.\n. ",
    "mistre83": "Yes, this is what i have implemented. I have created two separate folow (watchLogin and watchLogout) where both start forking and with an indefinite while (while (true) ) i listen for actions and when this is fired, i fork again to call the API. In this way, i dont have problems.\nNow, i have to read better the documentation and understand what redux-saga offeer (i think right now i have used just 10% of saga :) )\n. Thanks a lot!!! I'm looking it :)\n. I'm trying to write some test with this flow, and my login watchers is this:\nexport function* watchLogin() {\n    while (true) {\n        const user = yield take(actions.LOGIN_USER);\n        const { username, password } = user.payload;\n        yield fork(loginCall, username, password);\n    }\n}\nRight now i've wrote this test but.... it fail :(\nit('watchLogin Saga', (done) => {\n        const generator = watchLogin();\n        expect(generator.next().value).toEqual(take(actions.LOGIN_USER));\n        generator.next({'payload': {'username': 'admin', 'password': 'admin'}});\n        expect(generator.next({'payload': {'username': 'admin', 'password': 'admin'}}).value)\n            .toEqual(fork(loginCall, 'admin', 'admin'));\n        expect(generator.next().value).toEqual(take(actions.LOGIN_USER));\n        done();\n    });\nThe first expect works (sure, is simple :D) the second works too.. but now... i have problems with third and fourth step:\n- Third step: should fork with username and password provided in the previous step\n- Fourth step: should go back to the first (no warried about if login is fine or not, in loginCall i catch the exception and dispatch action for LOGIN_OK and LOGIN_FAIL).\nCan you help me to write this simple test? I'm trying to understand how to write it looking on examples but is a little difficult... i'm new to all.. :D Redux, React, Saga, Generator... :)\n. Yes... sorry for this i think we can close this.\n. ",
    "mistre833": "Thanks!! tomorrow i will test it again :)\n. ",
    "yachaka": "It is guaranteed, the reducers are called before the yield take(actions.RESORT_CUSTOMER) is resumed.\nSee https://github.com/yelouafi/redux-saga/blob/master/src/internal/middleware.js#L46.\n. ",
    "richierob62": "Thanks, much.\n. Thanks @eirslett and @baldwmic\n\nRe: are you asking how you can easily test whether the fetchProducts generator was called when the PRODUCTS_REQUESTED action is dispatched?\nYes, I was speaking of that.\n\nLearned a lot from the mini discussion.. ",
    "sam-jay": "\nyou can create your own buffer and pass it to eventChannel\n\nthat's not a bad way to go.\nare you interested in a pull request for buffer.clear(), channel.clearBuffer(), or channel.clear()?\n. ",
    "DarrylD": "@slorber funny, that answer is what led me to considering sagas thus asking this question. Very good answer by the way.\nBut my question still stands since the example in this repo conflict with the answer. \n. Interesting. I'm not using thunks at the moment but, I think I'll play around some some options. I have to say, at this moment, AC's seems pretty redundant for my use case. Maybe maintainability would be a factor but, it seems like the additional boilerplate/overhead offsets a bit.\nAlso gonna implement ducks, that should also help a bit.\n. ",
    "Baisang": "thanks - that gets me a little further along, but I still get the same \"uncaught\" error, but this time in authorize it seems after the console.log. I'll try to keep looking into it.\n. thanks for your help! the issue ended up being unrelated to the saga middleware. It was just a more generic exception that managed to bubble up all the way.\n. @denizs , unfortunately I don't remember the specific issue, but I do remember that it was specific to my implementation.\nI think one of the current issues with redux-saga is that, as rclai stated, no matter what kind of exception is raised each error will look exactly like that. Sometimes if you look carefully at the console output (i.e. on your xcode or whatever) you can find the actual Javascript exception that caused the red screen of death. Hope this can help in some way.\n. Could have the saga dispatch a different action after it handles the actions. This action would invoke a testSaga for example that would then examine the state.\n. Can you show the code you use to start the saga middleware etc.? Might be more helpful\n. Err, I tried committing the changes after I did npm install to add the build output, but it seems to have changed things a lot more differently than I expected. Sorry about that; please just consider my changes to buffer.js by themselves.\n. Thanks for looking at my PR, I implemented the changes you mentioned.\nRegarding the potential memory leaks in the shifting case, arr[pushIndex] = it replaces the reference to the removed data, unless I am missing something else. I modified the take call to set the cell to null.\n% can be expensive at times so I think it is best to use the length variable, but of course in practice this could be different.\n. ",
    "rclai": "Is there any way to make these exception errors more helpful? It doesn't matter what kind of exception is raised, but every kind of error looks exactly like OPs screenshot. There is no way to see where the error originates from. I'm using redux-saga in a React Native context.\n. Yes, currently all the errors incurred are completely unhelpful, not even the exception stack object is helpful on the try/catch, at least on a React Native app.\n. I can confirm that using the code shared above does cancel mid-flight (axios-based or XMLHttpRequest) requests when raceing or canceling, which is nice.. I can confirm that using the code shared above does cancel mid-flight requests when raceing or canceling, which is nice.. ",
    "denizs": "@Baisang : \nDo you remember what caused the issue?\nI'm facing the same problem\nBest,\nD\n. @Baisang thanks for your quick answer! After fiddling around I also found that the exception raised was specific to my implementation. I was trying to add an authorization header to my xhr calls by api.headers[\"authorization] = token in my apiAuth saga. \nHowever, I instantiated api as a const :-D\nBasically a banal mistake caused by fatigue, I spent like 20 minutes before I noticed what was wrong.\n. ",
    "simlmx": "For lack of a better solution, I simply wrap all my sagas in a try/catch block and console.log the error before re-throwing it in the catch clause.. Sure! So basically anytime there is a mistake in my code (for example using an undeclared variable), my (React Native) app will fail with the 'uncaught', 'at rootSaga \\n at mySaga... message others have posted a screenshot of.  As far as I can tell, that error message doesn't say much about what the actual problem is, but if I put a big try/catch around everything inside my failing saga (here \"mySaga\"), then I can print some helpful error message like ReferenceError: Can't find variable: x.. ",
    "saademou": "My dispatched actions are loginSuccess and loginFailure.\nI put them in a separate file : loginActions.js\nimport * as types from './actionTypes';\nexport function loginSuccess({token, user}) {\n  return {\n    type: types.LOGIN.SUCCESS,\n    token,\n    user,\n  }\n}\nexport function loginFailure(err) {\n  return {\n    type: types.LOGIN.FAILURE,\n    err,\n  }\n}\nMy Saga Code is :\n```\nimport React from 'react';\nimport { take, put, call, fork, select } from 'redux-saga/effects'\nimport * as types from '../actions/actionTypes';\nimport { loginSuccess, loginFailure } from '../actions/loginActions'\nfunction loginCall({email, password}) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const loginEntry = {\n        token: 'secret token',\n        user: {\n          name: 'hhh',\n          email: 'user@gmail.com',\n        },\n      };\n  if (email == 'user@gmail.com') {\n    resolve(loginEntry);\n  } else {\n    reject({status: 'wrong email or password'});\n  }\n}, 1000); // 1 second\n\n})\n}\nfunction *watchLoginRequest() {\n  while(true) {\n    const { email, password } = yield take(types.LOGIN.REQUEST);\ntry {\n  const payload = {\n    email,\n    password,\n  }\n  const response = yield call(loginCall, payload);\n  console.log( loginSuccess(response) );\n\n\n  yield put(loginSuccess(response));\n\n  console.log('SAGA LOGIN SUCCESS: ', response);\n} catch (err) {\n  console.log('SAGA LOGIN ERR: ', err);\n  yield put(loginFailure(err.status));\n}\n\n}\n}\nexport default function* root() {\n  yield fork(watchLoginRequest);\n}\nthe console below returns :\nconsole.log( loginSuccess(response) );\n\n{ type: 'LOGIN_SUCCESS',\n03-29 10:21:31.028 14886 15744 I ReactNativeJS:   token: 'secret token',\n03-29 10:21:31.028 14886 15744 I ReactNativeJS:   user: { name: 'hhh', email: 'user@gmail.com' } }\n```\nBut when i do the command below, it returns an error : \nyield put(loginSuccess(response));\n03-29 10:21:31.071 14886 15744 I ReactNativeJS: 'SAGA LOGIN ERR: ', { [ReferenceError: Can't find variable: accessible]\n03-29 10:21:31.071 14886 15744 I ReactNativeJS:   line: 91812,\n03-29 10:21:31.071 14886 15744 I ReactNativeJS:   column: 22,\n03-29 10:21:31.071 14886 15744 I ReactNativeJS:   sourceURL: 'http://10.0.2.2:8081/index.android.bundle?platform=android&dev=true&hot=false&minify=false' }\n03-29 10:21:31.074 14886 15744 I ReactNativeJS: 'watchReduxLoadFromDisk has been cancelled', ''\n03-29 10:21:31.074 14886 15744 I ReactNativeJS: 'root has been cancelled', ''\nAny help please ?. ",
    "AlastairTaft": "Is there any reason why errors are being caught internally instead of just failing and throwing?. Based off @simlmx's comment, I basically did the same thing but rather than forking I wrote a little script to monkey patch the code automatically every time you run yarn install or npm install.\nIf anyone wants to do the same thing, you need to add a postinstall script to your package.json like so\njs\n\"scripts\": {\n  \"postinstall\": \"node monkeyPatchReduxSaga.js\"\n}\nAnd then add the following code to a new file namedmonkeyPatchReduxSaga.js to your project root folder.\n```js\nvar fs = require('fs')\nvar filepath = 'node_modules/redux-saga/lib/internal/proc.js',\n  contents = fs.readFileSync(filepath, {encoding: 'utf8'})\nvar newCodeStr = addMonkeyPatchCode(contents)\nfs.writeFileSync(filepath, newCodeStr)\nfunction addMonkeyPatchCode(codeStr){\nvar monkeyPatchCode = `/*\n   * Redux Saga has been monkey patched here, see issue\n   * https://github.com/redux-saga/redux-saga/issues/389\n   /\nthrow err\n`\nif (codeStr.indexOf(monkeyPatchCode) !== -1){\n    // Code is already monkey patched, don't do anything\n    return codeStr\n  }\nvar index = codeStr.indexOf(log('error', 'uncaught at ' + name, message || err.message || err);)\n  if (index == -1)\n    throw new Error(Unable to monkey patch redux saga code, perhaps a new version of\n      the package has been used. At the time of writing this monkey patch redux\n      saga was at version 0.16.0..replace(/\\s+/gi, ' '))\nreturn codeStr.slice(0, index) + monkeyPatchCode + codeStr.slice(index)\n}\n```\nNow I can see the actual errors.\n. ",
    "ahmad2smile": "For me it was not putting https:// before my host url.. ",
    "tadas-subonis": "@yelouafi this should be in the docs :-) :\nconst rootTask = sagaMiddleware.run(rootSaga);\nrootTask.done.catch(function (err) {\n    console.log(\"Error in Sagas\", err);\n});\n. ",
    "madebyherzblut": "@slorber is there already a gist/example where I can see this isolation in action?\n. Ah, thank you! I didn't know that I can run runSaga more than once.\n. ",
    "lukaszszymanski": "That will do it, thanks!\n. ",
    "pwharff": "The link above reports a 404. Here is a link to the official Redux Saga docs for take(pattern). ",
    "peter-perot": "I have been digging deeper into the discussion, and I found my question answered here: https://github.com/yelouafi/redux-saga/issues/160#issuecomment-190307098\nAnyway it would be nice to put this clarification into the tutorial/docs since it's confusing for a beginner if the code in the tutorial uses another technique as the code in the sample projects.\n. ",
    "ms88privat": "What about this? Sometimes my App runs into issues, which is leading into a complete App crash because all my sagas will be canceled when I start them with fork.\njs\nexport default function* root() {\n  yield [\n    spawn(getAllProducts),\n    spawn(watchGetProducts),\n    spawn(watchCheckout)\n  ]\n}\n@yelouafi which affect performance more? spawn or fork? Which ist better for the performance / memory of the App?\n. @darkalor I wrote a related article about this https://medium.com/@marcelschulze/using-react-native-with-redux-and-redux-saga-a-new-proposal-ba71f151546f#.mp66tk62d\n. @3LOK sounds awesome, please keep us informed!\n. I used to fire an action \"APP_STARTED\" in the componentDidMount of my RootComponent. . Well done. Was waiting for this :) What about the documentation? hehe.\nThanks a lot guys!. @neurosnap https://medium.com/@marcelschulze/using-react-native-with-redux-and-redux-saga-a-new-proposal-ba71f151546f\nThats the way I did it so far. It's working great but a little bit of boilerplate.. ",
    "Moeriki": "On second thought. The channels should feed back a result much like an action creator does.\nTurning the code into emit({ user }) makes perfect sense then.\n. ",
    "stipsan": "cool! I hope so too \ud83d\ude04 \n. ",
    "rybon": "It would just ignore them. Basically I want to keep the sagas running, but just no-op the processing. I'm fine with only replaying the store dispatches. The replayed dispatches would still flow through the sagas, but the effects would never actually be executed.\nMy goal is to introduce an if guard in just one place (middleware) to no-op all side effects in the entire app. This would complicate hot reloading and time travelling the sagas themselves, but I'm fine with that for now until #5 and #22 resolve to a better way forward.\n. Sure, that could work.\nI was actually looking into using the monitor option and adding a method to act as a hook in runEffect. In there, the very first thing we could do is call this monitor method to verify whether we should proceed with running the effect. Basically similar to monitor && monitor.effectTriggered, but wrapped in an if with a return; to act as a guard. Thoughts?\n. True, if the application is in an 'unstable' state (in the middle of doing something) then this will not work properly. I haven't yet seen a solution that mitigates this problem though. I'd rather start with something less than ideal and work towards a better solution.\n. You're right, that would lead to strange situations. I'm not sure how to solve this really. I guess a full page reload would be required to reset all sagas to their initial state. I'm ok with that for now, until we have a way to restore the internal state of the sagas using the Redux log. Replaying the Redux log does that job for the store, but not for the sagas just yet.\nDo you have any ideas for solving this problem? This PR is also meant as a starting point for a discussion.\n. Could not reproduce it in a CodeSandbox: https://codesandbox.io/s/ypkryr9m6v\nI'm guessing something else might be the cause, such as circular imports. In that case this issue would be a red herring. I'll see if I can track down the real issue.. Sorry, was a mistake in my code. My bad.. By the way, I'm also seeing browser freezes (Chrome) after upgrading to 1.0.0 where the entire browser becomes unresponsive. No code changes other than the version bump. I'll try to create a sample, but this one is hard to extract to a CodeSandbox.\nDoes this have to do with changes to delay and possibly CANCEL?. Yes, that fixed it, thanks! I've updated the 1.0.0 CodeSandbox to reflect this.\nI'll continue to investigate the browser freezing problem. Perhaps the same cure does the trick there as well.. The browser freezing problem is still there. I'll close this ticket and open another one.. OK I will, thanks for the tip!. https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/proc.js#L165\nThis function gets called in what seems like an infinite loop. Both arguments are undefined. This is what caused the freeze. Any ideas?. OK I found the issue.\nWhen you call Promise.resolve() or Promise.reject() the resulting value is undefined. This triggers the infinite loop. Changing the value to anything else resolves the issue.. Apparently this breaks the test suite.\n@Andarist could you have a look at this issue? I really want to prevent this issue from popping up again. Browser freezes should never ever happen.. Sure, I can do that.. https://codesandbox.io/s/o95y24znnz\nyield () => Promise.resolve() works, takeLatest(SOME_TYPE, () => Promise.resolve()) does not. However, takeLatest(SOME_TYPE, () => Promise.resolve(true)) or takeLatest(SOME_TYPE, () => Promise.resolve(null)) does.. I've confirmed this is fixed in 1.0.1 and updated the CodeSandbox to reflect this.\nThanks everyone!. ",
    "sergej-s": "@kuy Thank you for reply. I've recreated question on StackOverflow\nI tried to replace delay to call(delay, 1000), but it doesn't help. Still stuck after console.log(2). It seems that control isn't returned to rootSaga.\n. @yelouafi Thanks a lot for explanation!\nIs it possible to run saga engine without setup a subscribe function? I'd like to use serveral sagas with eventChannels and channel communication between them. So there is no need to subscribe some main event source.\n. Hello,\nYou have couple of errors in your code:\n1. At first you should yield put effect not just execute \"put\" function. \n2. But you cannot yield inside callback, so you have to wrap api invocation into a promise or rewrote api function as a Node style function (in this case use cps effect).\nHere some code:\n```\nconst fishingPromise = (river) => {\n  return new Promise((resolve, reject) => {\n    try {\n      fishingApi(river, (fish) => {\n        resolve(fish);\n      })\n    } catch (err) {\n      reject(err)\n    }\n  });\n};\nfunction fishingFlow() {\n  yield takeLatest('FISHING_START', function* (action) {\n     let {river} = action.payload;\n     try {\n      const fish = yield call(fishingPromise, river);\n      yield put({type:\"FOUND_NEW_FISH\", payload:fish});\n      yield put(fishingFinished());\n    } catch(error) {\n      yield put(fishingFinished(error));\n    }\n  });\n}\n```\n. I think you can if I understood you correctly.\nYou can use delay and re-ask server for new fish every predefined period of time:\nfunction* fishingFlow() {\n  yield* takeLatest('FISHING_START', function* (action) {\n     let {river} = action.payload;\n     while(true) {\n       try {\n         const fish = yield call(fishingPromise, river);\n         yield put({type:\"FOUND_NEW_FISH\", payload:fish});\n       } catch(error) {\n         yield put(fishingFinished(error));\n         return; // exit saga.\n       }\n       yield call(delay, 1000); // wait 1 second and then request server again.\n     }\n  });\n}\nOr better you can use event source (like web-sockets for example) to get data from server:\n```\nfunction fishingFlow(socket) {\n  yield takeLatest('FISHING_START', function* (action) {\n    let {river} = action.payload;\nconst takeChannel = eventChannel((listener) => {\n  socket.on('fish_catched', (fish) => {\n    listener({type: 'FOUND_NEW_FISH', payload: fish});\n  });\n  socket.on('disconnect', () => {\n    listener({type: 'ERROR_SERVER_DISCONNECTED'});\n    listener(END);\n  });\n});\n\ntry {\n  while (true) {\n    const action = yield take(takeChannel, 'FOUND_NEW_FISH');\n    yield put(action);\n  }\n} finally {\n  yield put(fishingFinished('server disconnected'));\n}\n\n});\n}\n```\nNotice that I didn't get how you prefer to cancel fishing saga by user or by notification from server... \n. @38Slava Maybe I am wrong but here const data = yield R.map(api, payload) you should yield array of effects but you yield array of API invocation results. Also it seems here yield R.map(dispatchAllPosts, data) array of undefined are being yielded (if as dispatchAllPosts you mean dispachAll) instead of array of effects. \nSimple loop should look something like this:\nfor (let item of payload) {\n  const data = yield call(api, item);\n  yield call(dispatchAll, data);\n}\nor\n```\nconst data = yield R.map(item => (call(api, item)), payload);\nyield R.map(item => (call(dispatchAllPosts, item)), data);\n``\n. I have tested both of your code with action dispatched once like thissetTimeout(() => (store.dispatch({type: 'SIGN_IN'})), 1000);`\nand everything is fine. Can you give more info?\n. Hello,\nfirst what I see that you have to return promise from getYears otherwise yield call(getYears) will not wait for promise resolving. \njs\nconst getYears = () => {\n    return request.then(response => response.text())\n      .then(text => convertXML(text))\n      .then(json => {\n        resolve(GetYears.response(json).payload); //? is it possible to resolve in such way?\n      });\n  };\n. Michael, can you provide more info (trace with console logs) because i ran the next code with mockuped fetch and everything works fine:\n``` js\nconst fetch = (url) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve('years'), 2000);\n  });\n};\nfunction* fetchYears(getState) {\n  const getYears = () => {\n    return fetch('http://api.openweathermap.org/data/2.5/weather');\n  };\ntry {\n    yield put({type: 'GET_YEARS_PENDING'});\n    const years = yield call(getYears);\n    yield put({type: 'GET_YEARS_FULFILLED', payload: years});\n  } catch(e) {\n    yield put({type: 'SET_PAGE_ERROR', payload: e});\n  }\n}\nfunction* watchForFetchYears() {\n  while(true) {\n    yield take('GET_YEARS');\n    yield fork(fetchYears);\n  }\n}\n```\nDo not forget to return promise :)\njs\nconst getYears = () => {\n    **return** fetch(GetYears.url, GetYears.request(kbbToken)).then(response => response.text())\n      .then(text => convertXML(text))\n      .then(json => GetYears.response(json).payload);\n  };\n. @Andarist Yes, I am thinking the same way, but hope @yelouafi confirm that saga engine supports this.\n. +1 flushing everything from channel is useful feature. \n. @Andarist Thank you very much for the response. It's hard to not use take(chan, pattern) because we extensively use eventChannels with sockets, simple channels to communicate between sagas and I usually write sequential code like this:\nconst action1 = yield take(channel, 'SOME_ACTION1');\n    do something with action1\n    const action2 = yield take(channel, 'SOME_ACTION2');\n    do something with action2\n    etc\nI think with pattern channels become much more flexible.\nSo only solution is to put everything from channel to std broadcast channel and then yield take(pattern)?\nMaybe provide buffer with matcher, that we can write custom buffer? Something like this:\nfunction take(cb, matcher) {\n  ...\n  if(closed && buffer.isEmpty()) {\n    cb(END);\n    return;\n  } else if(!buffer.isEmpty()) {\n    const action = buffer.take(matcher);\n    if (action) {\n      cb(action);\n      return;\n    }    \n  } \n  takers.push(cb)\n  cb.cancel = () => remove(takers, cb)\n}\n. @Andarist Thx for notification. I don't get how api of runSaga will be changed? Will I need to change my code in some way? . ",
    "git-blame": "Looking through the saga code, it looks like you can force put to wait on a Promise if you call put.sync instead. But I don't know how official this is:\nhttps://github.com/yelouafi/redux-saga/blob/master/src/internal/io.js\njavascript\nput.sync = (...args) => {\n  const eff = put(...args)\n  eff[PUT].sync = true\n  return eff\n}\n. Great.\n. For completeness, if you are waiting on a Promise returned by an action that has been dispatch (like my someAsyncStuff example) and the Promise fails, you will get back a redux-action like what a reducer sees with its error property set. So if you are waiting to catch a rejected Promise, it won't happen. You need something like:\njavascript\nfunction* waitOnAction(action, ...args) {\n  const result = yield put.sync(action(...args));\n  // if it is from a redux-action, we get an object with error set not a thrown error\n  if (result !== undefined) {\n    const { error } = result;\n    if (error) {\n      throw result;\n    }\n  }\n  return result;\n}\n. Thanks for the link. I'm well-aware of these options. I use race and take in other places. They do not apply here. For one thing, take cannot be used with a Promise. Forking a saga means you still need some mechanism within that saga to wait until that Promise is done.\nThe simplest way is to use put.sync as mentioned (and possibly the await operator).. actionChannel dispatches action through the store. If I want to limit it just within sagas, I assume the same functionality can be done with \"directly created\" channels?\n. Is there a blocking effect that does nothing and is only meant to yield execution to other generators, or in this case let emitter finish? For example, in python's Tornado framework, it would be yield gen.moment.\nI suppose I can simply issue a very short delay such as yield call(delay, 10)?\n. ",
    "gustavms": "https://redux-saga.github.io/redux-saga/docs/advanced/RacingEffects.html Read it carefully and in 10 hours you will have clear concepts. In your example you are missing Take and fork to handle it elegantly. ",
    "lesnitsky": "PR name is quite self-descriptive \ud83d\ude3c \n. No, it's not like takeFirstInSequence, but take -> spawn task -> ignore all incoming actions while task in progress -> take -> ...\n\nit is not a standard throttle with delay parameter\n\nyeah, but you are able to use yield call(delay, duration); inside spawned task and this will throttle your task.\n. well, yeah. I'm not saying my helper is direct implementation of throttling, but it could be used for it\n``` js\nfunction rootSaga() {\n    yield takeSequence(USER_INPUT, logUserInput);\n}\nfunction* logUserInput(action) {\n    yield call(delay, 500);\n    yield call(log, action.payload);\n}\n```\nThe main purpose of this helper is to provide an ability to ignore incoming actions, while previously spawned task not completed yet. Keep in mind that spawned task could delegate execution to more complex logic like races etc., so this helper is applicable not only for throttling, but a set of problems.\n. ",
    "mydearxym": "@kuy thinks and sorry \ud83d\udc4d \n. ",
    "totaldis": "I have a similar issue, from what I can tell, with the put and take logic. I have tracked it back to the jump from 0.10.0 -> 0.10.1. I've checked 0.10.1 - 0.11.0 which all exhibit the same unexpected behavior that was otherwise working in 0.10.0. I only recently found out because I rebuilt my local repo and upgraded some packages. \nI've setup my saga communication based entirely on actions. \nWatchers are built with this little helper function:\njs\nconst createWatcher = function(action, fn) {\n  return function* () {\n    while(true) {\n      const { data } = yield take(action);\n      yield fork(fn, data);\n    }\n  }\n}\nstore setup\njs\n  const sagaMiddleware = createSagaMiddleware();\n  const store = createStore(reducer, initialState, applyMiddleware(sagaMiddleware));\n  sagaMiddleware.run(sagas);\nsagas\n``` js\nfunction* s1() {\n    console.log('s1 start');\n    yield put({ type: 'S2_REQ' });\n    console.log('after S2 put');\n    yield take('S2_SUCCESS');\n    console.log('after S2 success')\n    yield put({ type: 'S1_SUCCESS'});\n    console.log('s1 end');\n}\nfunction* s2() {\n    console.log('s2 start');\n    yield put({ type: 'S2_SUCCESS'});\n    console.log('s2 end');\n}\nconst watchS1 = createWatcher({ type: 'S1_REQ' }, s1);\nconst watchS2 = createWatcher({ type: 'S2_REQ' }, s2);\nconst sagas = [\n  fork(watchS1),\n  fork(watchS2),\n];\n```\n0.10.0 produces:\n(index) s1 start\n(index) s2 start\n(index) after s2 put\n(index) after s2 success\n(index) s1 end\n(index) s2 end\n0.11.0\n(index) s1 start\n(index) s2 start\n(index) s2 end\n(index) after s2 put\n0.11.0 using fork(()=>put) trick in https://github.com/yelouafi/redux-saga/issues/336#issuecomment-220283929\n(index): s1 start\n(index): after s2 put\n(index): s2 start\n(index): after s2 success\n(index): s1 end\n(index): s2 end\nIs this the expected behavior and I should migrate my code to using actionChannel per the comment above? It's hard to tell if this fits the same pattern as the other 3 issues on similar topics. \nI understand that async logic is not easy (especially in a single threaded language) so I'm happy with a response of \"you just shouldn't do it that way.\"\n. I think after re-reading https://github.com/yelouafi/redux-saga/issues/277#issuecomment-216083937 I understand the stack problem, and can get around it by adding a blocking call to the s2 function:\njs\nfunction* s2() {\n    console.log('s2 start');\n    yield call(()=>{});\n    yield put({ type: 'S2_SUCCESS'});\n    console.log('s2 end');\n}\nI'm still investigating if actionChannels will fit into my master plan, but at least I know now that the issue is aligned with @axelson's above\n. ",
    "MattKunze": "I had similar thoughts a while back, but I haven't been able to come up with any concrete use cases for it yet. It seems like it might be useful as a dependency injection mechanism to isolate sagas from runtime instances that aren't necessarily available through the store.\nBut I have [yet] come up with a scenario that isn't handled through call, it would be interesting to hear what others have come across.\n. ",
    "christian-schulze": "Thank you for your responses @MattKunze and @yelouafi.\nFor our specific use case, we have a function called followLink, which given a url, will expect a well defined JSON document in return. The JSON document has an embedded status, which followLink will use to retry (with exponential back-off and max retries) until either error or ready is returned.\nWe use followLink extensively in most of our Saga's hence why we were enquiring about custom effects. I guess in this scenario, followLink is a more specialised form of call.\n. This is excellent advice, and a very simple refactor to existing code. Will take this idea for a spin tomorrow, but please consider this issue solved \ud83d\udc4d\n. ",
    "s-panferov": "This will not help anyway, because TypeScript types all var a = yield x expressions as any. https://github.com/Microsoft/TypeScript/issues/2873\n. ",
    "kamleshchandnani": "When doing code splitting how would you handle this? I am already facing issue. before code splitting everything was running smooth the code \n```\nsagasManager.addSagaToRoot(function *watcher() {\n  yield [\n    takeEvery(FETCH, fetchAuthSaga),\n    takeEvery(LOGOUT, logoutSaga),\n    takeEvery(LOGIN, loginSaga),\n  ];\n});\nruns fine but as soon I created split bundles this doesn't registers watcher. Any clue?. @Andarist\nBut if I do\nsagaMiddleware.run(function *watcher() {\n  yield all([\n    takeEvery(FETCH, fetchAuthSaga),\n    takeEvery(LOGOUT, logoutSaga),\n    takeEvery(LOGIN, loginSaga),\n  ]);\n})\n```\nThen I have to export each and everything from all the bundles and import it where I am running this root saga this isn't it? So the ducks pattern goes for a toss? Imagine I am having 20 connected components. \n@Andarist\nI just tweaked sagas manager as you mentioned. Rest everything remains same as per @LopatkinEvgeniy  pattern. @Andarist\nBut why we have to write this tweaked code? And what is this channel all about? twitter DM?. ",
    "stoyandamov": "So if you're really really stuck:\n```js\n// globals.js\nlet cachedStore\nexport const setStore = store => cachedStore = store\nexport const getStore = () => cachedStore\n```\nWherever you're creating the store:\n```js\nconst store = createStore(\n  combineReducers({...}),\n  applyMiddleware(middleware, sagaMiddleware, logger)\n)\nsetStore(store) // <--- this\n```\nWherever you need dispatch:\njs\nimport {getStore} from '../globals'\nconst { dispatch } = getStore() // <--- this. ",
    "nhjk": "My dispatches do not use promises, I am only using redux-saga for async middleware.\nI have an action fetch a resource, for example a note. This action is { type: 'REQUEST_NOTE', id }. I also have a form to edit notes. To populate the form with initial data I call an action creator with the signature initialize(formName, initialData).\nWith redux-thunk I'd be able to chain these actions together like this dispatch({ type: 'REQUEST_NOTE', id }).then(() => dispatch(initialize(noteForm, noteData)). I don't have to create any new actions, I can compose the existing ones I have.\nBecause redux-saga does not return promises from dispatches the only solution I have been able to come up with is to create a new action, POPULATE_NOTE_FORM, with a new saga that contains this logic. I'm wondering if there is a more idiomatic way to do this.\n. That was an error on my part, I should be dispatching an actionCreator not a plain action object. So it should be dispatch(fetchNote(id)).then(() => dispatch(initialize(noteForm, noteData)). With redux-saga, how do I combine these two actions together? Do I need to create a new action and corresponding saga every time I want to combine two or more actions?\n. ",
    "nbkhope": "Could you guys elaborate how to convert the following from redux-thunk to redux-saga?\nGiven a component that calls bound action creators like so:\n```\ncomponentDidMount() {\n  this.props.fetchSomeData()\n    .then(() => {\n      const necessaryParameter = this.props.fetchedData; // this is defined after fetchSomeData() succeeds\n  return this.props.fetchMoreInfo(necessaryParameter);\n});\n\n}\n```\nIn the example above, the bound action creator fetchSomeData() eventually dispatches a success action after making an http request, setting the fetchedData prop to a certain value. That value, in turn, is necessary for the call to the bound action creator fetchMoreInfo().\nI understand that we can do the above with redux-saga if we create a custom saga that performs both operations in sequence. My issue is, like the OP of this issue, how can we write it in a way that we don't need to create that custom saga? So it's like we already have two sagas that we may reuse and somehow combine FROM the component level, instead of the implementation of the sagas itself. Something like:\ncomponentDidMount() {\n  this.props.dispatchSomeActionThatCallsSagaA()\n    .then(() => { // if successful\n      this.props.dispatchAnotherActionThatCallsSagaBWithParameter(this.props.fetchedData);\n    })\n}\n   . ",
    "apfelfabrik": "Any feedback on this? If this is the recommended way to do retries, it should probably be in the recipes, if this is not the recommended way some suggestions for improvement would be great.\n. ",
    "aghreed": "Anything come of this yet? I'm also looking to have a reusable \"retry\", and it would be pretty neat if it were baked into the library as a helper. Happy to help contribute if you'd like as well.. ",
    "Zacqary": "Aha, I see. So that would replicate the behavior of getState in 0.9.x.\nI guess that works, but I'd prefer to use the new pattern of select effects. The problem, as I see it, is that it's difficult to override where select gets its state from at any level below the root saga. I don't know whether that's a problem with Redux-Saga, or if I've just been following an anti-pattern this whole time.\n. Instead of const ACTION_TYPE = \"ACTION_TYPE\" our convention is to do const ACTION_TYPE = Symbol(\"LocalNamespace ACTION_TYPE\"). Turns out this was fixed in #246, so takeEvery should be safe for us to use now and I need to get back in that habit.\nChanging takeEvery/takeLatest to effects would be a great help. But furthermore, I guess the reason I see confusion is because they're called take[Something] but their behavior is actually much closer to fork than to take.\nI do recognize that the way the docs are structured is to introduce takeEvery first and then consider take to be an advanced concept, so again, maybe it's my fault for teaching people Saga in the opposite direction. Although I do think it's valuable to understand what's actually going on under the hood in a saga \u2014 seeing an infinite loop of takes is a very good way to communicate the concept of why Saga uses generators.\nIn fact, to me that's the power of Saga over something with a huge library like RxJS \u2014 the fact that you can express complex patterns with these simple building blocks. I agree, I'm not sure off the top of my head how to do it better, but I would like it if the higher-level helpers were more in harmony with the lower-level building blocks that they're named after.. ",
    "HansDP": "Sorry, I should have read the documentation more thoroughly.\nIn the documentation about Channels, there is a nice code sample explaining how to close a channel. And that solves my question.\n``` javascript\nfunction* runTimer() {\n    const channel = yield actionChannel('START')\n    try {\n        while(yield take(channel)) {\n            while(true) {\n                const winner = yield race({\n                    stopped: take('STOP'),\n                    tick: call(wait, 1000)\n                })\n            if (!winner.stopped) {\n                yield put({ type: 'TICK'})\n            } else {\n                break\n            }\n        }\n    }\n\n} finally {\n    if (yield cancelled()) {\n        channel.close()\n    }\n}\n\n}\n```\n. Hello\nIn the real-world example, the action creator updateRouterState is bound to the dispatch method.when connecting the component to redux (https://github.com/yelouafi/redux-saga/blob/master/examples/real-world/containers/App.js#L88). \nIn the async example, there is no mapDispatchToProps set, which indicates that only the dispatch method will be passed as property to your connected component.\nThis is related to how react-redux works\nIf you pass in an object in mapDispatchToProps, all methods will get bound to the dispatch method\nFrom the documentation:\n\n[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): If an object is passed, each function inside it will be assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component\u2019s props. If a function is passed, it will be given dispatch. It\u2019s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.) If you omit it, the default implementation just injects dispatch into your component\u2019s props. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapDispatchToProps will be re-invoked whenever the component receives new props.\n\nSee connect(...) documentation\n. I'm working on something similar, but in React.\nSome of my container components are loaded dynamically (as in: the main app does not know they exist). And these container components need to run a saga.\nCurrently, I'm exposing the run method from the saga middleware to those dynamic container components. So, I have some module similar to:\n```javascript\nimport createSagaMiddleware from 'redux-saga'\nconst sagaMiddleware = createSagaMiddleware()\nexport const runSaga = sagaMiddleware.run\nexport default sagaMiddleware\n```\nThis runSaga method is then passed to the container components, which can use it whenever they need it. This is a typical implementation of its usage:\n```javascript\nimport React from 'react'\nimport myContainerSaga from './saga'\nexport default class MyContainer extends React.Component {\n  componentWillMount() {\n    const { runSaga } = this.props\n    this.saga = runSaga(myContainerSaga())\n  }\n  componentWillUnmount() {\n    if (this.saga) {\n      this.saga.cancel()\n    }\n  }\n}\n```\n. I did some basic smoke testing on the code snippet. It runs and everything seems fine.\nPS: this is the first time I created a pull request on github. If I did anything wrong, just let me know. I agree about the spawn vs fork comment.\nBut I'm not sure how to handle cancellation in onArchive when the main saga gets cancelled.\nJust 'ignore' this (to keep the example clear) is an option, but in production code, i guess there must be some flags to know whether or not the undo ui should be hidden and whether or not the optimistic update should be reverted.\nSomething like\n```javascript\nimport { take, put, call, fork, race } from 'redux-saga/effects'\nimport { delay } from 'redux-saga'\nimport { updateThreadApi, actions } from 'somewhere'\nfunction* onArchive(action) {\nlet needsHideUndo = false\n  let needsRevertOptimisticUpdate = false\nconst { threadId } = action\n  const undoId = UNDO_ARCHIVE_${threadId}\nconst thread = { id: threadId, archived: true }\ntry {\n// show undo UI element, and provide a key to communicate\nyield put(actions.showUndo(undoId))\nneedsHideUndo = true\n\n// optimistically mark the thread as `archived`\nyield put(actions.updateThread(thread))\nneedsRevertOptimisticUpdate = true\n\n// allow the user 5 seconds to perform undo.\n// after 5 seconds, 'archive' will be the winner of the race-condition\nconst { undo, archive } = yield race({\n  undo: take(action => action.type === 'UNDO' && action.undoId === undoId),\n  archive: call(delay, 5000)\n})\n\n// hide undo UI element, the race condition has an answer\nneedsHideUndo = false\nyield put(actions.hideUndo(undoId))\n\nif (archive) {\n  // make the API call to apply the changes remotely\n  needsRevertOptimisticUpdate = false\n  yield call(updateThreadApi, thread)\n}\n\n} finally {\n    // no need to check for cancellation, just execute this code when the \n    // try-block has finished (it will include cancellation as well. but also\n    // the actual undo, error handling, ...)\nif (needsHideUndo) {\n  yield put(actions.hideUndo(undoId))\n}\n\nif (needsRevertOptimisticUpdate) {\n  // revert thread to previous state\n  yield put(actions.updateThread({ id: threadId, archived: false }))\n}\n\n}\n}\nfunction* main() {\n  while (true) {\n    // wait for an ARCHIVE_THREAD to happen\n    const action = yield take(ARCHIVE_THREAD)\n    // use spawn to execute onArchive in a non-blocking fashion (which also\n    // prevents cancelation when main saga gets cancelled.\n    // This helps us in keeping state in sync between server and client\n    yield fork(onArchive, action)\n  }\n}\n```\nBut I'm not sure this is a proper solution. And it is harder to understand.\nAnyway, I will update the code sample with your comments. Did I updated this pull request correctly? (because i see 3 commits instead of one)\nIf so, what should I do? I'm not used to using github (sorry for the trouble). ",
    "vctormb": "\n```js\nimport createSagaMiddleware, { END } from 'redux-saga'\nimport { createStore, applyMiddleware } from 'redux'\nimport rootSaga from '...'\nimport rootReducer from '...'\nconst sagaMiddleware = createSagaMiddleware()\nconst store = createStore(\n  rootReducer, \n  applyMiddleware(sagaMiddleware)\n)\nsagaMiddleware.run(rootSaga).done.then(() => { \n  / put tests here /\n})\n//... dispatch test actions\n// then signal that no action will be dispatched further\n// this will stop all action watchers and wait for any pending requests to finish\n// after that the 'done' prop above will be resolved \n// (or rejected if an uncaught error is detected)\nstore.dispatch(END)\n```\n\nWhen I try to do sagaMiddleware.run(rootSaga).done.then(() => { \n  /* put tests here */\n}) I receive the following message: Cannot read then of undefined. How can I do it?. ",
    "smashercosmo": "createStore.js\n``` javascript\nimport {createStore, applyMiddleware, compose} from 'redux';\nimport createSagaMiddleware, {END} from 'redux-saga';\nimport reducer from './reducers';\nexport default function(state) {\n  const sagaMiddleware = createSagaMiddleware();\nconst middleware = [\n    sagaMiddleware\n  ];\nconst storeEnhancers = applyMiddleware(...middleware);\n  const store = createStore(reducer, state, storeEnhancers);\n  store.runSaga = sagaMiddleware.run;\n  store.close = () => store.dispatch(END);\nreturn store;\n}\n```\nserverRender.js\n``` javascript\nconst matchRoute = (req, res, next, routes, location, store, history) => {\n  match({history, routes, location}, (error, redirectLocation, renderProps) => {\n    /* some serever rendering code /\nconst saga = store.runSaga(rootSaga);\n    fetchComponentData(store, renderProps, saga)\n      .then(() => sendHtml(req, res, store, renderProps))\n      .catch(next);\n    store.close();\n  });\n};\n```\nfetchComponentData.js\njavascript\nexport default function fetchComponentData(store, renderProps, saga) {\n  const promises = renderProps.components\n    .filter(component => component && component.fetchData)\n    .map(component => component.fetchData)\n    .map(fetchData => fetchData(store, renderProps));\n  return Promise.all([...promises, saga.done]);\nsomething like this\n. Ok, further research shows that if you don't wrap takeLatest-saga in fork, then it starts working. Could somebody explain why?\n. @yelouafi ok, I'll publish repo with complete example\n. @yelouafi Ok, here is an example repo. To reproduce the issue, just remove babel-plugin-transform-regenerator from .babelrc in real-world example. And run it on node 6 (which has native support for generators).\n. @yelouafi did you have a chance to look at the issue? (not pushing :))\n. But that's been fixed, no? @yelouafi issue could be closed, am I right?\n. Couldn't this somehow be related to https://github.com/yelouafi/redux-saga/issues/429 ? Are you using node 6 without babel-plugin-transform-regenerator?\n. If you want to dispatch 2 actions in 1 yield, you can just use redux-batched-actions package.\n. @tokenvolt check the last example here https://github.com/markdalgleish/redial\nP. S. stackoverflow.com is more appropriate place for that kind of questions\n. Here is my related question on stackoverflow: https://stackoverflow.com/questions/39438005/what-is-the-idiomatic-way-of-starting-rootsaga/47623129. @Wenqer That's less performant\n. Probably, \"so they can be\"\n. I mean the word order. I could be wrong, cause I'm not a native speaker) but I thought that verb should go after subject.\n. ",
    "northerneyes": "We found the issue. The reason was that we was using node 6 with native generator implementation. With simple yield everything works fine, but for yield* with takeLatest it is not. Our babelrc file https://gist.github.com/northerneyes/382aeafce1cc94ca7bb0cba4ca83a60a\n. ",
    "jrvidal": "This is most likely a V8 bug. The offending line points to a return method of a generator object returning undefined, which should never happen.\n``` javascript\nfunction foo() {\n    yield bar();\n}\nfunction bar() {\n    let it = {\n        next() {\n            return { done: false, value: 1 };\n        },\n        Symbol.iterator {\n            return it;\n        }\n    };\n    return it;\n}\nvar gen = foo();\nconsole.log(gen.next());\nconsole.log(gen.return());\n```\nThe above sample code prints:\n```\n// Node v6.3.0\n{ done: false, value: 1 }\nundefined\n// Chrome 51.0.2704.106\n{ done: false, value: 1 }\n{ done: false, value: undefined }\n```\n. I imagine that it is already solved for good, since Node 6.3.0 has V8 version 5.0.71.52, while the Chrome version above uses V8 5.1.281.65. Here is some discussion about future V8 versions in Node.\n. Effects are purely declarative, so there is not way for them to have \"effect\" if you don't run a saga connecting it to a store. In this kind of test, you need to manually mock the returned values. Try:\n`` javascript\n  it('quitTimer Saga test', function (done) {\n    // ThisgetState` does not seem to serve any purpose\n    const generator = sagas.quitTimer(getState);\nlet next = generator.next();\nexpect(next.value).toEqual(select(selectors.pomodoroSelector));\n\nnext = generator.next(yourExpectedResponseForTheSelectEffect);\n// ...\n\n```\nI'm wondering if you got confused by this example that also uses an ignored getState argument.\n. If you fire several DELETE_BOOKMARK in succession, won't a single DELETE_BOOKMARK_ERROR cancel all your races? Also, shouldn't deleteBookmark take an action parameter instead of an id?\n. > should both only cancel the race in one of the forked tasks\nI don't think that is the case. All your concurrent races are blocked on a take effect that will \"win\" on a DELETE_BOOKMARK_ERROR action. This action is \"global\": every take blocked on it will resume after receiving it. takeEvery does not play any role here.\n. You're right the DELETE_BOOKMARK_ERROR action is not the issue. I noticed it first for that action for some reason, but the case is the same for CANCEL_DELETE_BOOKMARK.\nWhat you probably need is something like:\njavascript\nconst { response, cancelDeleting } = yield race({\n  delete: call(performDelete, id),\n  cancelDeleting: take(action => (\n    (action.type === types.DELETE_BOOKMARK_ERROR || action.type === types.CANCEL_DELETE_BOOKMARK) &&\n    action.id === id\n  ))\n});\nOtherwise CANCEL_DELETE_BOOKMARK affects all your races. There is nothing in your take referring to the particular bookmark you are dealing with.\n. I think the flow is something similar to:\nput -> dispatch -> your reducer -> listener function created by connect -> setState on the connected component -> (Rendering happens to occur synchronously [not always the case]) -> componentWillReceiveProps\n. ",
    "johannestroeger": "has this already been reported at https://bugs.chromium.org/p/v8/issues/list ?\n. could i help here somehow? we would really like to use yield*ed sagas :(\n. yes, this has been merged, but not yet released.\n. ",
    "aaronjensen": "erg, this is a nasty one. A release would be great, especially since we can't just depend on the github version w/o building the release ourselves.\n. erg, this is a nasty one. A release would be great, especially since we can't just depend on the github version w/o building the release ourselves.\n. > In fact, at my work we've come to the firm conclusion that unit testing sagas offers no benefit. The tests are tautological.\nI think this is usually true, though it's helpful to test sagas that have branches. That said, I wonder if reducing the tautology would help. \nIf we think about unit testing regular functions that have dependencies, you have spies and stubs available to you. You use spies for testing side effects and stubs for testing reads from external dependencies. \nThe redux-saga test frameworks force a strictness upon you that normal unit tests with spies and stubs do not have. You must be exact in your ordering and explicit in every spy expectation and stub response. \nIf the default behavior were more forgiving, that is, effects were simply recorded and all things were assumed to yield undefined, then perhaps the testing could be less tautological and more focused on what you want to test. For example, you could have a test that asserted that when a response was successful an action was put. Nevermind the fact that 3 other things may have happened, your test just tests that one thing, so you set up your \"stubs\" (yield results) and you assert on your \"spies\" (expect(saga.put).toHaveBeenCalledWith(...)).. @granmoe awesome, I'll have to check it out, thanks.. ",
    "monochrome-yeh": "maybe I got the cause,\nin my case:\n``` javascript\nconst mapStateToProps = ( store ) => {\n    // console.log( store.router.pathname.substring( 1 ) )\n    // const { language } = store.router.params\n    const { language } = store\nreturn {\n    language,\n}\n\n}\nconst mapDispatchToProps = ( dispatch ) => {\n    return {\n        dispatch,\n        navigate,\n        updateRouterState,\n        resetErrorMessage,\n        setUiLanguage\n    }\n}\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)( Main )\n```\nin real-world:\n``` javascript\nfunction mapStateToProps(state) {\n  return {\n    errorMessage: state.errorMessage,\n    inputValue: state.router.pathname.substring(1)\n  }\n}\nexport default connect(mapStateToProps, {\n  navigate,\n  updateRouterState,\n  resetErrorMessage\n})(App)\n```\nI should't have used function to do mapDispatchToProps\nHahahaha, I'm so stupid, this problem confuse me whole the week...\nhowever I'm so happy, cause of you reminded me about that... lol\nthanks bro\n. Got an answer\nrelated react-redux connect method.\n. ",
    "JesterXL": "Thanks for the awesome library and wonderful documentation!\n. What does your main saga.run look like, and what does your .dispatch action that starts the whole thing look like?\n. Figured it out based on your unit test example (thanks for that!), specifically line 22.\njavascript\n// products is your mock, w00t!\nnext = generator.next(products)\n  t.deepEqual(next.value, put(actions.receiveProducts(products)),\n    \"must yield actions.receiveProducts(products)\"\n  )\nI forgot I can pass in values to next(), so once I passed the mock in like you did, GOOD TO GO FUNKY COMADEENA!\nYou can close this.\n. Temporary workaround to get it compiling:\ntypescript\nconst myThing:any = rootSaga;\nconst rootSagaResult = sagaMiddleware.run(myThing);\n. Yup:\ntypescript\nexport class AppModule\n{\n    constructor(ngRedux:NgRedux<IAppState>)\n    {\n        ngRedux.configureStore(rootReducer, {}, [ createLogger(), sagaMiddleware]);\n        const myThing:any = rootSaga;\n        const rootSagaResult = sagaMiddleware.run(myThing); \n        rootSagaResult.done.catch((err)=>\n        {\n            console.log(\"Error in Sagas\", err);\n        });\n    }\n}\nIt's mad at the sagaMiddleware.run.\n. Nice! I'll try that, and once I get her 100% compiling without any's scattered all over the place, I'll update this thread.\n. Another problem is you can't use Enum's for Actions:\n``` typescript\nenum Actions\n{\n    PING,\n    PING_ERROR,\n    PINGED,\nLOGIN,\nLOGGED_IN,\nLOGOUT,\nLOGIN_ERROR\n\n}\n```\nAs soon as you attempt to register those with takeLatest, it's expecting basically a String. You could use Actions[Actions.PING], but sadly, while that evals to a string, all your switch statements in your reducers are actually numbers at runtime. You CAN set them to string values in TypeScript playground, but that's against the documentation, and it makes it look like it's an error. Generated JavaScript works, though. :: shrugs ::\n. Update on this:\n\nManually install TypeScript 2.1 or higher.\nEnsure the tsconfig.json has target of \"ES6\".\n\nWhile I still get the compilation errors of \"can't find Promise\" ect., ng test it works. All tests pass including my Redux Saga generator functions. ng serve continues to work as normal.. ",
    "jzaefferer": "Not really, since it also uses a lot of vocabulary that I'm not familiar with. While I've read plenty of FP articles trying to explain monads, it never \"clicked\", so using that to explain redux-saga isn't helping. Same for \"thunk\", except that I only heard this term for the first time a few days ago.\nI'm coming from an application that uses React, react-router and Ampersand models and collections. I have some problems in managing data in that architecture, and redux-saga was recommended to me to solve some of those problems. I still can't tell if it does.\n. > It is not the typical library that beginners should start with\nThen who is it for? The current introduction doesn't tell.\n\nDon't use a library if you don't yet understand the problem it tries to solve.\n\nThat was the point of this ticket. The current explanation is inaccessible to me (and I guess anyone else not already deeply familiar with related concepts). It doesn't have to be.\n\nA thunk is not something complicated, and it's well-explained on the page I gave you\n\nThat's not helping. If you tell me something is easy or not complicated and I don't understand, it makes me feel stupid. That's not the goal, right?\n\nIt is just a syntactic sugar that is equivalent to:\n\n\"just\" is a toxic word in the context of documentation, same as \"easy\", \"simple\" or \"straightforward\".\n. > What do you think about this? Specifically @jzaefferer, does this explain the idea better maybe? [...]\n\nThis first introduces the solution and the problem, explains the mental model, explains the assumed technical familiarity and then compares it to redux-thunk for those who have used it, but doesn't necessitate the understanding of thunks or anything.\n\nYes, that sounds/reads a lot better to me. \n. ",
    "YouYII": "Thank you for your answer.\nBut I want to put once FISHING_START, and get one or moreFOUND_NEW_FISH,It can use the sagas implementation?\nThank you again for your help\n. Thanks , You're right. \nSaga Channels can do this.\n. ",
    "dieppe": "Thanks for this very complete answer.\nI have some questions though. I do understand that when we call fork, the parent task continues its execution. That's why in our case, we have one indirection: root (forks) launcher (forks) all-long-running-sagas, so we can do the following and (that's where I'd like to know if we assume right -- well, if the sync fork bug did not exist) catch all errors:\njs\nfunction* root () {\n  const task = yield fork(launcher);\n  try {\n    yield task.done; // this will throw if an error bubbles (?)\n  }\n  catch (error) { }\n}\nAnother question is, right now, the fork must be itself in the try..catch as presented in scenarii 3 and 5, but it should not be, right (that's what you referred by sync forks?)?\nAnyway, for now, that's what we have in place, and it seems to catch all errors, even if we sometimes see the \"uncaught at root\" log (I'm putting that here as it might interest someone):\njs\nfunction* root () {\n  let launchTask;\n  let errorAlreadyHandled = false;\n  try {\n    launchTask = yield fork(launchSagas); // launch all long-running sagas\n    yield launchTask.done; // wait for the task, so that if the done promise rejects, we can catch the error \n  }\n  catch (error) {\n    errorAlreadyHandled = true;\n    yield call(handleUncaughtError, error);\n  }\n  finally {\n    if (!errorAlreadyHandled && launchTask.error()) {\n      yield call(handleUncaughtError, launchTask.error());\n    }\n  }\n}\n. OK, disregard my last comment (seems I didn't understand your answer fully \ud83d\ude05  ).\nI'll probably repeat what you said in your comment, but I want to be sure I'm not mistaken:\nWhen an error is thrown (and not caught) inside a task T, the whole execution subtree starting at T is aborted. If T is itself part of an execution tree, the error is bubbled up to the parent task P of T. Now, I'd like to know for sure: can P handle the error and stop the cancellation from bubbling?\n. All right, I get what you mean. I'll try to be more specific in my question, because I feel there is some part of it still unanswered (in light of your last comment though, I think it's more theoretical than practical, since I now see how to handle errors properly in our codebase).\nThe doc says that a fork effect does return a task to the calling generator (which is not always true in case of synchronous error, but that seems to be a bug):\njs\nfunction* main () {\n  const task = yield fork(...);\n}\nMy understanding of it was that this task object represents the fork, and can be used to \"wait\" on the fork by doing the following:\njs\nfunction* main () {\n  const task = yield fork(...);\n  yield task.done;\n}\nMy impression was that with this bit of code one could \"emulate\" a call effect while using a fork. I now see that it's useless since using a call does the exact thing I was looking for, but this is what has been bugging me and why I started this issue, because right now this code does not work the same depending on what happens in the fork.\nTo summarize, I do understand forked tasks run in parallel and there is no way to \"wait\" for them implicitly, but I thought redux-saga provided a mechanism to explicitly wait on the task object representing the fork execution, and also that this provided us with the opportunity for the parent task to handle the error of its forked task before the parent itself is canceled.\nHence, I would expect the following to be true:\n``` js\nfunction* main () {\n  yield fork(t1);\n  yield fork(t2);\n  // if t1 or t2 throws, the whole execution tree should be aborted, and redux-saga should warn about uncaught error\n}\nfunction* main () {\n  yield fork(t1);\n  const task = fork(t2);\n  try {\n    yield task.done;\n  }\n  catch (error) {\n    // if t2 throws, then t1 still runs and main can recover\n    // if t1 throws, then the whole tree is aborted and redux-saga warns\n  }\n}\n``\n. You are totally right in the fact that we should usecall` (in fact I already made the change). And we do handle the errors as you proposed at the end of your comment. \nIn fact, this all started because we wanted to implement that and catch unhandled errors (crashes) in the top saga. I read about using task.done.catch for forked task here.\nI did choose the wrong way of implementing the 'catch-all-crashes-top-saga' using fork and thetask.done.catch technique instead of call. It did not work, hence the issue being opened. \nNow, all that is very clear to me, but since I'm curious (and like when things are consistent) and want to know a bit more how redux-saga works, I wanted to know if it could have been done  (not if it should be done) using\njs\nconst task = yield fork(launcher);\ntry { yield task.done; }\ncatch { // report crash }\nand it does not work simply due to a bug, or if I'm mistaken and that could have never worked anyway.\nSorry if I was not clear before (text-only communication is hard): \n- I'm not interested in a solution anymore (since you provided that already -- and by the way, thanks a lot for that \ud83d\ude09 ), \n- I did understand the solution and the execution model of fork,\n- but I just wanted to know if in principle the above code should have worked.\n. ",
    "bmueller-sykes": "I'm late to the party here, but I'm having trouble getting this to work. If I have an array of actions, like: \nconst actions = [\n{action: 'ACTION1', payload: {x: 1}},\n{action: 'ACTION2', payload: {y: 2}}\n]\n...how can I iterate over that array to put each of those actions? I've tried this:\nyield actions.map ( (current) => {\n          put(current)\n          return true;\n        })\n...but the put doesn't trigger. If I put yield put([some action]) in the exact same place in my code, that triggers just fine.\nIf I try this:\nactions.map ( (current) => {\n          yield put(current)\n          return true;\n        })\n...then I get a JS error saying yield is a reserved word.\nI've experimented a bit with all, but I haven't seen any examples where there is a put inside of an all (only call functions, which makes some sense, I think).\nSo, is it possible to do what I'm after here? Am I just not understanding something fundamental about how Redux Saga works?. answering my own question. It appears this does the trick:\nyield actions.map ( (current) => {\n          return put(current)\n        })\nYou have to explicitly return the put. I don't think I saw that in any examples or docs, though perhaps I just missed it.. ",
    "ArtBIT": "Or simply: yield actions.map(put). @Andarist I stand corrected.. ",
    "eliperelman": "In my view I have a button that is bound to a signIn function via:\njs\nconst signIn = () => dispatch({ type: 'SIGN_IN' });\nAdding a console.log to this method only logs a single time, so the event/dispatch isn't happening multiple times:\njs\nconst signIn = () => {\n  console.log('Signing in...'); // this only logs once\n  dispatch({ type: 'SIGN_IN' });\n};\nFor what it's worth I am also using redux-elm but I don't see anything specific there that would be causing this issue since this seems more on the level of redux-saga. My reducer syntax is obviously specific to redux-elm but should still execute sagas the same way. If this seems like an issue in redux-elm, I'll move my bug there.\nReducer, for clarity:\n``` js\nimport { Updater } from 'redux-elm';\nimport { takeEvery, delay } from 'redux-saga';\nimport { take, fork, call, put } from 'redux-saga/effects';\nconst SIGN_IN = 'SIGN_IN';\nfunction* signIn() {\n  while (true) {\n    yield take(SIGN_IN);\n    yield call(() => console.log('take some action...'));\n  }\n}\nfunction* listen() {\n  yield [\n    fork(signIn)\n  ];\n}\nexport default new Updater({}, listen).toReducer();\n```\nAny other information I could provide that would be helpful?\ncc: @tomkis1\n. I am using Node.js v6.3.0 with Webpack, Babel, and the following in my babel config:\njs\nmodule.exports = {\n  plugins: [\n    require.resolve('babel-plugin-transform-runtime')\n  ],\n  presets: [\n    require.resolve('babel-preset-es2015'),\n    require.resolve('babel-preset-stage-0'),\n    require.resolve('babel-preset-react')\n  ]\n};\n. Moved to redux-elm/37.\n. ",
    "michael-iglesias": "@sergej-s \nHey,\nSo there was an issue with the way that promise was being resolved. That was a copy+paste blunder :) I went ahead and fixed that, but I'm still having the same issue. The fetchYears() generator is still not being invoked.\njs\nconst getYears = () => {\n    fetch(GetYears.url, GetYears.request(kbbToken)).then(response => response.text())\n      .then(text => convertXML(text))\n      .then(json => GetYears.response(json).payload);\n  };\nAny other suggestions?\nThanks for your help,\nMichael\n. ",
    "somghosh": "+1\n. ",
    "chaintng": "@Andarist Hi, thanks for your help.\nI just update the code, please review it.\nthank you!\n. @Andarist  sorry for my poor example. I just fix the inconsistency.\nI add LOCATION_CHANGE in the later code snippet because it's my fix to this issue.\nI mean, i thought the first snippet should work properly enough, but after i revisit the page from back/forward navigation, the sagas get duplicated request.\nI wonder shouldn't it cancel the saga normally without my LOCATION_CHANGE watcher?\n. @Andarist it's my root saga.\nI inject it in my routes.js\n``` js\n      path: '/hotel/:hotelId',\n      name: 'hotel',\n      getComponent(nextState, cb) {\n        const importModules = Promise.all([\n          System.import('containers/Hotel/reducer'),\n          System.import('containers/Hotel/sagas'),\n          System.import('containers/Hotel'),\n        ]);\n    const renderRoute = loadModule(cb);\n\n    importModules.then(([reducer, sagas, component]) => {\n      injectReducer('hotel', reducer.default);\n      injectSagas(sagas.default);\n      renderRoute(component);\n    });\n\n    importModules.catch(errorLoading);\n  },\n\n```\n. Thanks! i think i understand better. will take a look to what you lead more and find the better solution.\nThanks again!\n. ",
    "Gyvastis": "@chaintng did you solve this eventually?. ",
    "justinhp": "@chaintng Did you ever figure this out?. @Andarist Ah, ok.  I have the same setup in my routes.js file as @chaintng.  However, rather I'm doing yield takeLatest(LOCATION_CHANGE, fetchSearchResults);, so I want to dispatch an action whenever LOCATION_CHANGE is dispatched.  The problem is that when I run my code it runs an additional fetchSearchResults every time.. @kai23 Merci!  That worked. . ",
    "kai23": "@justinhp here what worked for me : \njs\nexport function* getSessionOnLocationChange() {\n  const watcher = yield fork(requestSession);\n  yield take(LOCATION_CHANGE);\n  yield cancel(watcher);\n}. ",
    "salzhrani": "I think you mean npmjs.com not nmpjs.com\n. ",
    "arbaaz": "https://github.com/yelouafi/redux-saga-beginner-tutorial/blob/master/package.json#L7\n. @yelouafi I was wondering why a simple spelling mistake pull request is taking more than 7 days to merge. \n. ",
    "zatziky": "@slorber It worked. I used it this way:\nyield [\n            SagaEffects.put(actions.saveItemsOk()),\n            SagaEffects.put(actionsButton.savingEnded())\n        ]\n. ",
    "kyle-ssg": "This post ranks high in google for this question, so thought I'd mention the above is deprecated and that you now want to do: \nyield SagaEffects.all([\n            SagaEffects.put(actions.saveItemsOk()),\n            SagaEffects.put(actionsButton.savingEnded())\n        ]). ",
    "anjunatl": "@yelouafi This is unrelated to this bug, but you mentioned redux-saga/utils and I'm having trouble finding that for another bug I'm working on. Is that some exported package that was moved or removed at some point recently? https://github.com/clarketm/saga-monitor/issues/3. Found the answer - https://github.com/redux-saga/redux-saga/pull/1655. ",
    "jessepollak": "Hm, I guess one could do that, but our actions conform to flux-standard-action which specifies that Error objects should be passed in the payload.\nCurrently, we've created a assertErrorActionEqual function, but it feels pretty fragile.\njavascript\nfunction assertErrorActionEqual (action1, action2) {\n  let asserted = false\n  for (const k in action1) {\n    if (action1[k].action) {\n      assert.equal(action1[k].action.error, action2[k].action.error)\n      assert.equal(action1[k].action.payload.message, action2[k].action.payload.message)\n      assert.equal(action1[k].action.payload.name, action2[k].action.payload.name)\n      asserted = true\n    }\n  }\n  assert(asserted)\n}\n. ",
    "romeovs": "Oh cool! It's even easier that I thought :+1:\nIs this documented somewhere?\n. To better illustrate what I mean I created a webpackbin.\nThe outcome is\nACTION A started\nREQUESTED TOKEN\nACTION B started\nGOT TOKEN 1\nACTION A continued with TOKEN 1\nACTION B continued with TOKEN 1\nACTION C started\nREQUESTED TOKEN\nACTION D started\nGOT TOKEN 2\nACTION C continued with TOKEN 2\nACTION D continued with TOKEN 2\nACTION E started\nWhile I need it to more like:\nACTION A started\nREQUESTED TOKEN\nACTION B started\nGOT TOKEN 1\nACTION A continued with TOKEN 1\nACTION B continued with TOKEN 1\nACTION C started\nACTION C continued with TOKEN 1\nREQUESTED TOKEN\nACTION D started\nACTION D continued with TOKEN 1\nGOT TOKEN 2\nACTION E started\nACTION E continued with TOKEN 2. @granmoe I see what you mean, but doing it like that makes it hard for me to add new actions that depend on the token, since I would need to DD them all through this actionChannel, which makes the code harder to evolve.\nBut your talk about Channels gave me an idea though. I can implement a LastChannel that is a special Channel that holds only the last action that was put to it:\n```js\nimport { END } from 'redux-saga'\nexport default class LastChannel {\n  constructor () {\n    this.callbacks = []\n  }\n// put notifies all takers\n  put (message) {\n    this.message = message\n    for (const callback of this.callbacks) {\n      callback(this.message)\n    }\n    this.callbacks = []\n  }\n// take registers a new taker\n  // if there was already a message, just use that one.\n  // If not, wait for the first on to arrive\n  take (callback) {\n    if (this.message) {\n      callback(this.message)\n    } else {\n      this.callbacks.push(callback)\n    }\n  }\n// close notifies waiting takers with END\n  close () {\n     for (const callback of this.callbacks) {\n      callback(END)\n    }\n    this.callbacks = []\n  }\n// flush flushes all the remaining messages (of which \n  // there are none, because only the last one is saved).\n  flush () {}\n}\n```\nIf I use this in the webpackbin, I get the correct output.\nI'm not sure if there are any tradeoffs here though... It feels sneaky to store the token in this channel, and having the channel around as a global will definitely break testability. It is pretty backwards-compatible with existing code though.\n. No, this has been helpful. Thanks!. ",
    "adipascu": "This feature is working in redux-saga 0.16.0, I can't seem to find anything about it in the documentation.. @Andarist\nI think it is saner to have a fixed buffer by default and catch any errors early instead of causing other secondary issues (slowdowns, low responsiveness or out of memory crashes).\n\ud83d\udc4d  for adding documentation either way.. I'd prefer if the error would bubble up and crash the app. I can create a fork of the sagas and catch errors in those if I want to.. ",
    "shinima": "@adipascu Added to the todo list in #1478. @Slapbox In redux-Saga@1.0.0-beta.1, if you import delay from 'redux-saga/utils', then delay is an async function which returns a Promise when called.  If you import delay from 'redux-saga/effects', then delay is an effect creator which returns a call-effect when called, and that means you should always call delay directly.\nI find these two delay very confusing since they have the same name but with different behavior.. @alaPing It seems to me that your code should work fine. Could you describe what's your expected behavior and what's the actual behavior?. > if generator finishes with effect descriptor, like return call(..) we will receive {done: true, value: call(...) }. should we interpret it?\nWe need not interpret returned values from generators. Since if the users want effect descriptors to be interpreted, users could simply add a yield as follows:\ndiff\nfunction* gen() {\n- return call(fetch, 'some-url')\n+ return yield call(fetch, 'some-url')\n}\n\nI think the existing behaviors of fork/call are fine. We could add suggestions in docs to prevent the users from using fork and call at the same time.. Should we extract them into multiple modules like @redux-saga/delay, @redux-saga/channel, @redux-saga/is, or should we just extract them all into one extra module @redux-saga/utils?\nIf we extract them into multiple modules, then putting all symbols in @redux-saga/symbols seems good to me.. @jeffvandyke I think this modular packages separation should be internal. Users only need to add redux-saga as the dependency.\nBy the way, I'm also curious about how we extract modular packages in the end, but at the moment we still have some space to improvement the modularity.. @restrry  I think we could make effectTypes public. Further more, I'd like to remove asEffect and expose the structure of effects(though it breaks encapsulation), which results in much simpler usages like this. I will make a PR to see if it makes a good difference.. I don't quite follow this issue (It has too much English for me...).   So I just list my understandings, correct me if I'm wrong:\n\nI believe that mainTask._isRunning tracks the running status of the iterator. If we really want to allow users to determine whether a task is actually done executing, we may expose mainTask as a public API.\nCustomized effects seems a more general solution. However, customized effects would introduce a lot of complexity and we need to consider which internal objects should be exposed to customized effect-runners.  (#1488 is a try to customized effects)\nIn my own opinion, asynchronous cancellation logic is not a good idea. We should keep code in finally-block as simple as possible. For example, beforeunload can be thought as a cancellation logic for a web page. Asynchronous codes (e.g. ajax requests) in beforeunload handler won't get executed. Similarly, it is a good idea to only use synchronous and exception-free codes in finally-block.. Could we wrap the actual channel payload into an object, and unwrap the object when we want to use payload?\n\nThat means we change our wrapSagaDispatch as follows:\n```diff\n- export const wrapSagaDispatch = dispatch => action =>\n-  dispatch(Object.defineProperty(action, SAGA_ACTION, { value: true }))\n\nexport const wrapSagaDispatch = dispatch => action => dispatch({ [SAGA_ACTION]: true, action })\n```\n\nstdChannel also needs changed:\ndiff\nexport function stdChannel() {\n  const chan = multicastChannel()\n  const { put } = chan\n  chan.put = input => {\n    if (input[SAGA_ACTION]) {\n-      put(input)\n+     put(input.action)\n      return\n    }\n-    asap(() => put(input))\n+ // I'm not sure at the moment that `input.action` or `input` should be used here.\n+    asap(() => put(input.action))\n  }\n  return chan\n}\nThis approach seems to work and has less magic than  WeakSet/WeakMap.\nHow do you think about it ? @Andarist @restrry    \nEDIT: I find that changing the payload structure may have a big impact to the stdChannel, especially we allow the users to enhance/lift the channel.put by means of sagaMiddlewareFactory#options.emitter. Need further investigations.... @Andarist This is interesting, it would be great if we can remove all the SAGA_ACTION stuff. I'll take some time on digging it.. This is a configuration error in your tslint.json. You are setting --noEmitHelpers to true in compiler options but you compile your tsx files into javascript files that require the __generator helper.. 1. I have made a PR \ud83d\ude04 \n2. Let's just leave it alone.\nAnd... Question 3:\nHere we are using properties of iterator to track the parent-task status, but actually the parent task is the  aggregation of the main tasks + all its forked tasks. \nSo, in current implementation, there are confusing situations if we run the following code:\nJavaScript\nfunction* genFn() {\n  yield fork(backgroundTask)\n  // mainTask.isRunning is set to false here\n  // But since the backgroundTask is still running, so the parent-task is still running\n  // We are using iterator._isRunning to track parent-task so iterator._isRunning is true.\n  // It's confusing that:\n  //    mainTask.isRunning === false && iterator._isRunnig === true\n}\nI think its better to use task._isRunning / task._isCancelled ... to track the status of parent-task. I will make another PR for this.\nPoint out the mistakes if I am wrong. And if it is necessary, I apologize for my poor English.. @restrry Thanks for answering my questions.\nWhat I mean is that there are confusing situations when mainTask.isRunning === false && iterator._isRunnig === true holds. (mainTask is an implementation detail in redux-saga.)\nIn my opinion, it is better to refactor these codes and use task._isRunning / task._isCancelled ... to track the status. \nHowever, it is a refinement with low-priority, and I found that my proposal(#1404) is not a good one. I will investigate better options.. @Andarist Yes, I spent several hours figuring out this confusing names.\nMaybe using iterator._isTaskRunning / iterator._isTaskCancelled / iterator._taskResult ... is a better option. This makes the meaning of these properties explicit. How do you think?\nI am glad to make a PR.. One solution for this is that wrapping this function with Promise, and then yield this promise in saga. Another way may be using cps effects, but I'm not sure about it.. @OriAmir Have a try with the following code:\n```JavaScript\n// new Fingerprint2().get(function(result, components) {\n//  console.log(result);\n//  console.log(components);\n// })\nfunction* rootSaga(){\n  // Wrapping you function into a promise\n  const promise = new Promise((resolve, reject) => {\n    new Fingerprint2().get((result, components) => {\n      resolve({ result, components })\n    })\n  })\n// Yield the promise\n  // And redux-saga will return the resolved value when the promise resolves\n  const { result, components } = yield promise\n  // do some stuff about  result and components ...\n}\n```. Seem that the issue is resolved. Closing it.. I came up with several options:\nOption-1\nLike in this PR now, rename _isRunning to _isTaskRunning (same for _isCancelled and _isAborted)\nrename _result to _taskResult; rename _error to _taskError.\n\npros: make the names more explicit.\ncons: keeping those on iterator is somewhat leaky\n\n\n\nOption-2\nConvert task.isRunning / task.isCancelled ... from methods to properties, and use these properties to track the running status of the task. I have tried this option in my little-saga, and it works pretty well (passes all of the redux-saga test cases that should pass).\n pros: It is simple, intuitive and explicit.\n cons: It introduces breaking changes since that the API doc already says task.isRunning ... are methods.\nOption-3\nLike in #1404 , using properties and methods at the same time. Using properties task._isRunning / task_.isCancelled ... to track running status, while still provides task.isRunning() / task.isCancelled().\n\npros: get rid of iterator._xxx\ncons: having methods and properties at the same time seems unnecessary\n\nMy opinion\nI think Task.isRunning() / Task.isCancelled()... are not popular APIs and we are toward version 1.0, so option-2 is the best option. How do you think ?. little-saga is a slim version of redux-saga. I made some breaking change (including using task.isRunning / task.isCancelled ... to track running status) to keep little-saga as simple as possible. And I wrote an article in Chinese to help people understand the internals of redux-saga/little-saga.\n\nproperties might imply that they can be changed and those should really be read-only outside of redux-saga code\n\nWe can document that task.isRunning / task.isCancelled is read-only and add readonly modifier in typescript declaration file. On the other hand, I think most users will use join/cancel/cancelled effects \nrather than using these APIs to inspect the running status. These APIs could be think as advanced APIs and maybe we can trust these advanced APIs users \ud83d\ude06 .\n@Andarist If you think option-2 is okay, I am glad to make a PR. Or if you think option-3 is better, I can reopen #1404.. So let's pick option-3.   mainTask._isRunning is very reasonable though mainTask is private in proc(). I will add commits in #1475.. I'm interested in working on this.. Thank you to invite me to become a collaborator!\nI am glad to help make redux-saga better. I will read the source code again and find what I could do. I am a master student from China, so I have plenty of free time until my graduation. My English is a bit poor, so sometimes I may not be able to explain logic/code/situations clearly. \ud83d\ude03 . I've reported this issue to the GitBook's  here.\nThe same problems appear in redux docs too. It seems that we may wait some time before gitbook fixing this issue. . It seems that gitbook won't fix the inconsistency in the near future, so I'm closing this issue.. This is a good solution to reducing boilerplate. However, the concept action-creators is from redux, so it is more suitable to add this API in redux rather than in redux-saga, because when we use redux (without redux-saga) we still need action-creators. \nIMO, it is better to create a package named like redux-create-actions that exports this API.. Rebased.  @Andarist . @restrry  I have changed  mainTask.isRunning  to mainTask._isRunning. How do you think?. The code that handles this style of invocation is here. I think the documentation is missing this style of invocation. Welcome to make a PR.\nThe typescript declaration file already contains type definitions for this style of invocation. And as you can see this repository has no flow typings, those live in flow-typed repo and you should report/fix it there.. We may export IO symbol so that user could directly use obj && obj[IO] && obj.type === 'FORK' to test if an object is a fork-effect. I think exposing the structure of effects make effects easier to understand.\nMaybe I should keep asEffect with a deprecate warning now.. @restrry I agree that we shouldn't break encapsulation. I need to do more investigation before refactoring asEffect. I'll reverting deleting asEffect.. I've updated the code. \n\nI removed calling asEffect in proc(), and use if (type === effectTypes.TAKE) ... to test if an effect is of specific type.\nI do not delete asEffect since sagaMonitor example is still using asEffect. When we figure out a better way to let user inspect the type&payload of effects, we can make another PR replacing asEffect.\nI rename effect to makeEffect.. I've removed the unnecessary return keywords and turned off no-extra-semi eslint rule.. @SeregaSE   Of course.. How do you think renaming env.stdChannel to env.defaultChannel ?  stdChannel is already a function defined in src/internal/channel.js, and I am confused why it is a standard channel.. I've updated the code, please have a look when you are free @Andarist .. I think it is because TypeScript has not implemented variadic functions. So typescript cannot infer types correctly on meeting ...rest. You may find this issue helpful. There are lots of similar issue references from other libraries like immer#129.\n\nSadly I have no idea how to write the right type declaration for this case. Maybe you could cast call to any before using it:\ntypescript\nyield race({\n  loginTask: (call as any)(worker, result, ...args), // no error, but the type is not sound\n  logout: take(TypeKeys.USER_LOGGED_OUT)\n});. > Don't quite think this is a blocker for anyone if they need this lower level API.\nYes, you are right. I've made mistakes. I was thinking that dispatch / getState introduces much challenge for connecting external I/O ( emitter, Observable). But after a second thinking, it is fine that using dispatch / getState actually.\n\nWhat is more interesting to me is to see how exactly have you separated various effect categories in your little-saga. I will have to take a look into that in the following week.\n\nI can make a trial PR in the next few days.. This looks good to me. But I would like to let @Andarist or @restrry check this PR since I'm not very good at English.. Please describe the steps to reproduce this issue in detail. A repository with an example or using Code Sandbox would be helpful.. @pandaCure This repo uses lerna to manage multiple packages. You need to run npm run bootstrap instead of npm install.. Rebased.. The biggest disadvantage of this PR is that it introduces complexity. This PR shows how user-defined effect types could be implemented. But if we do not plan to support user-defined effects, I think keeping the current implementation is not bad.. Yes, I agree that the middleware is too complicated for effect-runners. I switch a simpler mechanism using an effect-runner map. See #1524.. Closing this PR. See #1524.. Thanks!. I come up with a better idea. I'll make another PR in a few days.. Great works \ud83d\udc4d . Changes looks good to me. But I'm worrying about the cases when we place takeMaybe in race/all.\njs\nfunction* gen() {\n   const allResult = yield all([\n    takeMaybe('some-action'), // will take an END\n    somePromise,\n  ])\n  expect.deepEqual(allResult, [END, resolvedValueOfPromise])\n}\nWhen takeMay take an END from the channel, END is passed to all and then all terminates the task. So we could never take an END using takeMay if takeMay is placed in all/race.\nI think maybe we should treat END as a normal result in all/race. How do you think ? Point out my mistakes if I'm wrong.\n. I may not explain myself clearly... Actually I'm talking about takeMaybe in all. In current implementation, users could not use takeMaybe to take an END if takeMaybe is in all.\nIt is my fault that takeMaybe is not related to this PR. I'll make another PR when this PR gets merged. This PR itself is very good that it makes all and race more consistent when dealing with END.. This is an open problem already discussed in #907.  There are some working solutions (but maybe not ideal) in that PR.. It seems that 'checking-after' not being logged is caused by connectSaga being cancelled.\nWhen connectSaga yield put(enable()), take(ENABLE) in onlineWatcher wins the race. Other two effects \u2014\u2014 call(connectSaga) and take(DISABLE) \u2014\u2014 will be automatically cancelled by race.\nYou could add some inspection code to log the cancellation status of connectSaga and the result of race in onlineWatcher, it should better explain what is happening.\n```diff\nexport function connectSaga() {\n+ // wrap the original code with try-finally\n+  try {\n    / ... */\n+  } finally {\n+    console.log('connectSaga isCancelled:', yield cancelled())\n+  }\n}\nexport function* onlineWatcher() {\n  while (yield take(CONNECT)) {\n    const raceResult = yield race([\n      call(connectSaga),\n      take(ENABLE), // removing this makes the yield resolve\n      take(DISABLE),\n    ]);\n+    console.log(raceResult) // Inspect the race result\n  }\n}\n``. Not much resources/examples...  I found we were monkey-patching stdChannel.put somehow, so I just came up withlift` as a unified way to monkey-patch stdChannel.put.\nHere lift is just a simple mechanism like reducer-enhancer in redux, accepts the old put and returns the new put.  By lifting the stdChannel, we can move some logic/complexity into the env.channel, which makes sagaMiddlewareFactory more consistent with runSaga.. lift in ramda (a popular javascript functional programming library) is much like lifting in Haskell.   lift in RxJS also has a similar meaning too.\nIn this PR, lift has different meaning and may not be a good name. What about change it to enhance or enhancePut?  I'm quite insensitive between lift and enhance, they have the same meaning when translated to Chinese.. See #1528.. I think the actual results are expected behaviors. If we look at the call stack carefully, we could find that in this example all code are synchronous.   yield put(actionToggleVisibile(true)) is the caller of Hellow#render() and the error thrown by callee should bubble back to the caller (saga).\n\n. render() method is supposed to be pure of its props&state, so ideally you should not throw any error inside render().   But if the error is inevitable, you could add an error boundary above <Hellow />.. @stefanfrede This seems really strange. eventChannel should be widely used in community and your code is totally good for me.\nWhich version of redux-saga do you use?  Could you provide a minimum reproduction with runnable code to let me investigate this issue?. I try to run your redux-saga-socket, but sadly nothing happens in http://localhost:8080 and no error appears.  Without a running example, it is hard for me to solve this issue.. This is a limitation of TypeScript on inferring types of yield expression.  You could see Microsoft/TypeScript#10509 for more detail.\nIMHO, inferring types of yield expression accurately (infer every yield with correct type) is very difficult for TypeScript, and this feature has limited usages (only coroutine drivers need this feature).  Annotating types manually seems the only working approach for now.. One possible case is that loadProfile is cancelled by its parents. You can log the cancellation status of loadProfile. Have a try, the following code may be helpful.\n```js\nimport { cancelled } from 'redux-saga/effects'\nexport function loadProfile() {\n  try {\n    / your code */\n  } finally {\n    console.log('loadProfile is cancelled', yield cancelled())\n  }\n}\n```. Could you provide a running environment about your code?  That would make it much easier for me to find out the reason.  There is a template on sacodesandbox you can use.\nThere are many possibilities of loadProfile being cancelled.  One possible case is that put({ type: CHANGE_LOCALE,  locale: 'zh' }); triggers (directly or indirectly) another LOAD_PROFILE action, which will be taken by takeLatest(constants.LOAD_PROFILE, loadProfile); in defaultSaga.  Once takeLatest takes a LOAD_PROFILE, it will cancel the running loadProfile instance and fork a new instance.\nIt may also be that CHANGE_LOCALE awakes another take in another saga (saga-2), but code after that take throws exception and the exception propagates to the parents/ancestors of saga-2. Your defaultSaga is one of the children of the those parents/ancestors, so defaultSaga gets cancelled and loadProfile gets cancelled too. However if this is the case, you could see the exception logged into the console or you could catch the exception if you use try-catch in those parents/ancestors. \nThese are just possibilities why loadProfile gets cancelled, the actual reason may differ. A running reproduction would be best to let me find out the actual reason.. Closing this as it is inactive. Feel free to comment or open a new issue.. You can use createSagaMiddleware#options.onError as an error handler for saga-middleware. \nEdit: I suspect that Error: Cannot read property 'nickname' of null in your code should be caught by catch. I'll spend some time investigating this.. I've made a test on codesandbox:   https://codesandbox.io/s/m79rn28z9y?expanddevtools=1&view=editor\nHave a look.. @ovaldi  This seems like a bug of v0.16.0, but I'm not sure about it since it is an old version for me.\nOne workaround for v0.16.0 is using put.resolve instead of put in such cases. On the other hand, reducers are supposed to be pure functions and it is not a good idea to have reducers throw exceptions.. @Slapbox \n```js\n// LINE-1:\nconst action = yield take(throttleChannel); // THIS IS THE LAST LINE EXECUTED\n// LINE-2:\nyield takeLatest(pattern, flushableThrottle, params, ...args );\n```\nI think the problem in your code is that when LINE-1 get executed (that means at least one action matching the pattern gets dispatched),  takeLatest on LINE-2 can take the same action. takeLatest will cancel the existing flushableThrottle instance so the iterator jumps out after LINE-1 gets executed.\n\nBasically what I'm trying to have a background sync operation like in the example where you laid out the code for the throttle with a flushable buffer, but I also want to wait until a user has stopped adding input to their local document before syncing it to the cloud for the sake of not overloading the server with a new updates.\n\nI suspect what you need is  debounce rather than throttle (though they are very similar).  debounce helper is implemented in master branch now, however it is not available in 1.0.0-beta.1, so you need to implement it manually.\nThe code of debounce is as follows, you can edit the code according to your requirements.\njs\nexport function debounce(ms, channelOrPattern, worker, ...args) {\n  return fork(function*() {\n    while (true) {\n      let action = yield take(channelOrPattern)\n      while (true) {\n        const { nextAction, timeout } = yield race({\n          nextAction: take(channelOrPattern),\n          timeout: delay(ms),\n        })\n        if (timeout) {\n          yield fork(worker, ...args, action)\n          break\n        } else {\n          action = nextAction\n        }\n      }\n    }\n  })\n}. I'm thinking that yield all([ fork(saga1), fork(saga2), fork(saga3) ]) is not a good pattern to implement sagas.  It may mislead people to think that the fork-effects are managed by the call-effect, and call-effect will be resolved after all the forked tasks completes. \nBut actually, the fork-effects are always managed by the current task through the underlying forkQueue. Call-effect will be resolved immediately since all fork-effects are non-blocking. Errors from the forked tasks bubble to the current task rather than to the call-effect.\nSo it is better to design root saga as follows:\n```diff\n- yield all([ fork(saga1), fork(saga2) ])\n// using multiple fork-effects\n+ yield fork(saga1)\n+ yield fork(saga2)\n// or ...\n+ yield all([ call(saga1), call(saga2)])\n```\nBy the way, fork-effects in race-effect is  most likely a bug since fork-effects are non-blocking and they will always win the race immediately.\njavascript\n// DO NOT DO THIS. The fork-effect always win the race immediately.\nyield race([\n  fork(saga1), \n  take('ACTION-1'),\n  somePromise,\n])\nThe rule of thumb is that use fork-effect directly in your saga, do not nest it in other effects.. I'm inclining to single array argument.\nThe problem with variadic arguments I found is that join(singleTask) matches both join(...tasks) and join(task), and it is unclear that yield join(singleTask) should return taskResult or [ taskResult ].\nIt is clearer to use array argument: If you pass a single task object, then the result is a single result object; if you pass an array of tasks, then the result is an array too. Like in all or race effects, the result type (array or object) is determined by the argument type.\nBy the way, this issue had got some discussion in #1248.. OK. I'll get it done in a few days.. Done in #1527 . @restrry  test added.. Sadly, ESLint does not support extends in overrides now (eslint/eslint#8813).  It will be supported but we may need wait some time.\n\n@restrry  How about just keeping \"extends\": [\"eslint:recommended\", \"plugin:react/recommended\"] globally?   Rules from plugin:react/recommended only influences react-related code.. Rebased this upon master.. Agree. I've moved the config to a separate file.. I don't know why tests with babel6 and options: { presets: ['env'] } starts to fail.  Babel6 adds 'use strict' as babel7 does when { presets: ['env'] } is present.  \nIs it a desired behavior? Can you help me to fix this? @restrry . The babel's doc says:\n\nWe recommend to use the babel.config.js format. Babel itself is using it.\n\nI personally prefer babel.config.js as it aligns with webpack.config.js and rollup.config.js.  Another minor advantage is that ESLint will check babel.config.js now ( ESLint does not check .babelrc.js before ).\n\n\nI suppose failing tests are just a matter of updating the fixtures, but you should run tests locally and check each one individually - if diff looks OK then just accept new one.\n\nI am using Windows and tests of babel-plugin-redux-saga always fails due to path separators ( Windows uses \\ instead of / ) .  So I skip the tests in babel-plugin-redux-saga \ud83d\ude02.   I'll switch to a mac and see the diffs carefully.. I've updated babel-plugin-annotate-pure-calls to ^0.3.0, edited fixtures and passed the tests. @Andarist . I have removed @babel/preset-stage-2 and added @babel/proposal-object-rest-spread instead.   babel.config.js got updated too.   @Andarist. I am merging this PR now since I have other PRs depending on this.  Do not forget to run npm install and lerna bootstrap after this PR.. If we do not plan to support custom effects in v1 but want to separate implementations of core effect runners, I can remove the coreEffectRunnerMap part and just keep the coreEffectRunnerMap part.. I'll try to rebase this in the following days.. Close in favor of #1659.. It's always a good idea to cancel the sagas if you don't need it anymore.  Cancelling sagas will release resources and prevent memory leaks.\nOnce upon a time, I've run into troubles because of forking too many sagas and forgetting to cancel them. When the number of running sagas reach around 10k, my app became unresponsive. In that case, a single action would awake 10,000 sagas.\nWhen a saga is blocking at yield take('SOME_ACTION_TYPE'), a taker is inserted into the taker array of the stdChannel (just like an event listener is added). If you have too much running sagas (and most saga block at a take effect), the taker array will be really long. When an action is dispatched into the store, the action will go through the stdChannel, redux-saga traverses the whole array and that is time-consuming.. I've added lerna bootstrap to postinstall. No longer need to run lerna bootstrap manually.. @restrry  Updated the code according to your reviews.. @Andarist Do you want to have a review?. Rebased upon master. Rebased on master, and add some tests to show how a stdChannel connects to external IO with enhancePut.. @Andarist You proposed changes seems very nice.  I was thinking that enhance-able channels are somewhat overlap with the functionality of dispatch. To enhance a stdChannel, one could use the enhancePut method , or put the logic inside the dispatch option. Exposing two options with overlapped functionality makes things complex.\nI'll change a new PR that only includes 1. removing the emitter option from sagaMiddlewareFactory,  2. adding a channel option.. Close this in favor of #1654.. In your modules/store.js, edit it as follows:\n```diff\nconst createStoreWithMiddleware = (rootReducer) => {\n  // other code\n  return {\n    createStore: () => {\n      return createStore(rootReducer, Map({}), enhancers)\n    },\n-    runSaga: middlewareSaga.run,\n+    runSaga: (...args) => middlewareSaga.run(...args),\n  }\n}\nexport default createStoreWithMiddleware\n```\nThis is because sagaMiddleware.run will be changed when sagaMiddleware gets mounted.\nBy the way, yield [ ... ] should be changed to yield all([ ... ]).    And I recommend you to use v1.0.0-beta.1 \ud83d\ude04   . Channels have a close method, I think in your case you could call close in the finally block. Hope this can solve your issue.\njavascript\nfunction* watchChannel(eventName) {\n  // ...\n  try {\n    // ...\n    const channel = yield call(subscribe, socket, eventName);\n    // ...\n  } catch (error) {\n    yield put({ type: RECEIVE_ITEMS_FAILED, error });\n  } finally {\n    channel.close() // <- close the channel explicitly\n  }\n}. Your issue is very clear and detailed.\nIn redux-saga, you can handle external input via a eventChannel. Or if you are using redux-saga with redux, you can manually call store.dispatch to trigger saga effects from an external function.\nI've made another sandbox here illustrating these two methods, have a look \ud83d\ude04.  EventChannel is more preferable.. @restrry   I think deviceInfo is a generator function, and yield deviceInfo() is fine since we allow yielding iterators.  In most situations, yield deviceInfo() has the same effect as yield call(deviceInfo) except for test-ability.\n@anwarhamr  the error is thrown inside deviceInfo(), you need to check that function carefully.. Hey @anwarhamr , I can not tell why the error appears. The error invalid pattern: undefined is thrown from src/internal/matcher.js#L21-L23, you could add a breakpoint here and it should become much easier to debug. \nYou may need to add the breakpoint in the corresponding redux-saga distributions files. Find internal\\matcher.js in node_modules/redux-saga/es or in node_modules/redux-saga/lib.\n\n. Here is a reproduction.\nyield actionChannel([undefined]) is in saga2, but the error only mentions about saga1.. @restrry this seems a nice solution. how do you think? @Andarist . I agree to remove one of them.  But I'm inclining to remove delay from 'redux-saga/effects'.\nBecause we can use delay-function to create delay-effects, but we can not use delay-effect-creator to create a delay-Promise. In other word, delay function is more general.\nAnd effect-creators from 'redux-saga/effects' often create effect with corresponding type -- call() creates call-effect, all() creates all-effects, fork() creates fork-effects, etc.. But delay() create call-effects, which is not consistent with other effect-creators.. > You don't have to worry about it, I'm going to move this delay util to separate package (@redux-saga/delay-promise or something) or move it out of this repository entirely and just make it a dependency of redux-saga.\nIt seems that @Andarist will move one delay apart from redux-saga. That's good for me.. @olga193580  Oa ha, thank you for your approval, but I need 1 approving review from redux-saga collaborators.. I think what you need is call effect.  You can use yield call(waitForSocketConnection) in your rootSaga.\nBy the way, using fork or takeEvery inside all does not make much sense. It is better to do as follows:\ndiff\n-yield all([\n-  fork(initChannelDelta),\n-  fork(initChannelFull),\n-  takeEvery(REQUEST_ITEMS, requestItems),\n-]);\n+yield fork(initChannelDelta)\n+yield fork(initChannelFull)\n+yield takeEvery(REQUEST_ITEMS, requestItems). I think this is a babel-related issue. See https://github.com/babel/babel/issues/5085#issuecomment-277544677 for more detail.. Actually, the error message is rather straightforward, you should first create a store and then run your saga. You could do as follows:\n```diff\nimport { applyMiddleware, createStore } from 'redux'\nimport rootReducer from '../reducers'\nimport { composeWithDevTools } from 'redux-devtools-extension'\nimport createSagaMiddleware from 'redux-saga'\n-import mySaga from '../sagas'\n-const sagaMiddleware = createSagaMiddleware()\nconst configureStore = (preloadedState = {}) => {\n+ const sagaMiddleware = createSagaMiddleware()\n\nreturn createStore(rootReducer, preloadedState,\nconst store = createStore(rootReducer, preloadedState,\n    composeWithDevTools(\n      applyMiddleware(sagaMiddleware)\n    )\n  )\nstore.runSaga = (...args) => sagaMiddleware.run(...args)\nreturn store\n}\n\n-sagaMiddleware.run(mySaga)\nexport default configureStore\n```\n```js\n// In your store.js...\nimport configureStore from './configureStore'\nimport mySaga from '../sagas'\nconst store = configureStore(options) // first create a store\nstore.runSaga(mySaga) // run your saga here\nexport default store\n``\n. The updated version ofconfigureStoreincludes thepreloadedStateparameter. And we setupstore.runSagainconfigureStore()so we can callstore.runSaga(mySaga)` later in client.js.\njs\nconst configureStore = (preloadedState = {}) => {\n  const sagaMiddleware = createSagaMiddleware()\n  const store = createStore(rootReducer, preloadedState,\n    composeWithDevTools(\n      applyMiddleware(sagaMiddleware)\n    )\n  )\n  // NOTE we set `store.runSaga` here so later we can call `store.runSaga` to run our saga.\n  store.runSaga = (...args) => sagaMiddleware.run(...args)\n  return store\n}\n. emmmm, I'm thinking it is indeed a function...   I've made an online demo, see https://codesandbox.io/s/7y23247rq1. Code updated. \ud83d\ude03 . @Andarist I think this PR is ready to be merged.. PRs are welcome. I would like to see how you implement the typecheck for takeEvery. It is complex since takeEvery has several overloading.. Overall, it's good change and the error-demo performs well on my PC. One thing I'm not sure is changing the behaviors of env.logError, because I have never used it before. How do you think? @Andarist . Yes, of course.. You can get the return-value simply as follows:\n```javascript\nfunction* foo() {\n  return 'return-value-of-foo'\n}\nfunction* bar() {\n  const value = yield call(foo)\n  console.assert(value === 'return-value-of-foo')\n}\n``. Yielding aputeffect returns the return-value ofstore.dispatch(action). In most situations,store.dispatch` simply returns the action back and you don't need to care about it.\nThere are some edge cases that you are using redux-saga with other redux middlewares, and the return-value of store.dispatch may be changed by other middlewares.. If some other redux middleware returns a Promise, you can use put.resolve to wait for its resolution. \nSay we have a reduxFecthMiddleware that returns a Promise for FETCH as follows, then we can use put.resolve to wait for the Promise's resolution.\n```javascript\nconst reduxFecthMiddleware = ({ dispatch }) => next => action => {\n  if (action.type === \"FETCH\") {\n    return fetch(action.url);\n  }\n  return next(action);\n};\nfunction* gen() {\n  try {\n    const response = yield put.resolve({ type: \"FETCH\", url: \"bilibili.com\" });\n  } catch (error) {\n    // handle error\n  }\n}\n```\nHowever in my opinion, put.resolve is somewhat complicated and we can avoid using it if we change our middleware from returning a Promise to dispatching another action when some asynchronous task is done. . I do not quite understand the problem.\nIt is totally fine that ajaxMainfestJson runs twice. Since you yield takeEvery(AJAX_REQUESTED, ajaxMainfestJson) in the mySaga so that if you dispatch two AJAX_REQUESTED then ajaxMainfestJson will run twice.. That's really strange, but I cannot tell why this happens from you code. Could you provide a running environment for me to investigate this?  A sandbox would be great.. Resolved in leeseean/react-redux-todolist#1.  This is an error from the user code.. I add delay(1000) to ensure loader lasts for at least 1 second in the following code. Can this solve your problem?\n```javascript\nfunction* loginSaga() {\n  try {\n    const timeout = delay(1000);\n    yield put(Actions.LoginStarted());\n// ensure the next yield-statement spends at least 1 second\nyield all([timeout, call(somVerifyAPI)]);\n\nyield put(Actions.LoginSuccess());\n\n} catch {\n    yield timeout; // If somVerifyAPI fails within 1 second, we need to wait the remaining time\n    yield put(Actions.LoginError());\n  }\n}\n```. > Is something like this possible? is something like this even worth the work in your opinion?\nYes, it is possible. I've written a atLeastOneSecondCall that encapsulates the logic of waiting at one second.   I suppose that it works but I have not tested it by myself.   And you may change atLeastOneSecondCall to a better name.\n```javascript\nfunction* atLeastOneSecondCall(fn, ...args) {\n  const timeout = delay(1000);\n  try {\n    const { result } = yield all({\n      timeout,\n      result: call(fn, ...args)\n    });\n    return result;\n  } catch (e) {\n    yield timeout;\n    throw e;\n  }\n}\nfunction* gen() {\n  // yield call(someAPI, arg1, arg2);\n  // replace your call with atLeastOneSecondCall\n  yield atLeastOneSecondCall(someAPI, arg1, arg2);\n}\n```. Yielding iterators will lose the test-abilities of sagas. So we need to yield call-effects instead of iterators, that means:\n```diff\n- yield applyWithDelay(api, 'post', 'api/1/login', ...)\n+ yield call(applyWithDelay, api, 'post', 'api/1/login', ...) \n\nexpect(someValue).toEqual(applyWithDelay(api, 'post', ...))\nexpect(someValue).toEqual(call(applyWithDelay, api, 'post', ...)) \n```\n\nHope this works for you.. Oh, I see the problem. It is my fault. When apply(context, fn, [...args]) fails, saga will cancel the pending timeout  (this auto cancellation behavior is documented here) so this timeout will never be resolved. We can switch to a delay that does not support cancellation. This seems a little weird, but it should work:\n```javascript\n// delay2 is copied from delay\nfunction delay2(ms, val = true) {\n  let timeoutId\n  const promise = new Promise(resolve => {\n    timeoutId = setTimeout(() => resolve(val), ms)\n  })\n// comment this line to disable support for cancellation\n  // promise[CANCEL] = () => clearTimeout(timeoutId)\nreturn promise\n}\nexport function* applyWithDelay(context, fn, ...args) {\n  // this timeout will not be cancelled, and will always resolve after defaultDelay\n  const timeout = delay2(defaultDelay); // <-- using dealy2 instead of delay\n  try {\n    const { response } = yield all({\n      timeout,\n      response: apply(context, fn, [...args]),\n    });\nreturn response;\n\n} catch (e) {\n    yield timeout;\n    throw e;\n  }\n}\n```\nThis method seems a little strange, maybe using another method that saves the start time is better, since you only need to save a start time in applyWithDelay. Anyway it is up to you. \ud83d\ude04 . Actually we have discussed this problem recently in #1515, and it has been merged in #1527 . It will be available when redux-saga v1.0 gets published.\njoin(...tasks) is removed and we need to use join(task[]) to join multiple tasks, and there will be no ambiguity any more.. By the way, saga-monitor remains the same style of logging output.\n\n. Thanks for reviewing. ~~And I'm currently thinking about add another package @redux-saga/inpection that exports some utils to allow users to inspect the internals of effects.  @redux-saga/inpection is for debugging purposes and @redux-saga/core does not need to depend on it.~~\n~~I'll update this PR after implementing the @redux-saga/inpection.~~. > I'm wondering if we need more inspection utils - they will only abstract simple object property access. I would be good with providing only is.effect + effectTypes. WDYT?\nActually I think only is.effect + effectTypes is fine. And as the effect payload shape is stable, I'm inclining to let people inspect the payload directly for (and only for) debugging purposes (we may add some tips into our docs about what an effect looks like).. Rebased on master. And add manager.childIdsMap for bookkeeping a map from parent-id to child-id-array, also removes ROOT from effectTypes.js.. > it's better to hoist this to the top level scope to avoid recreating this function inside each detach call\ndone.. rootSagaStarted hook added. You can view 69742b5...f1cdcd2. How about keep a simple/slimmed README on npm that includes a link to the full README on github/redux-saga.js.org? Babel is using the similar readmes on npm.\n. Should we name our es-modules as *.mjs?  .mjs seems a better extension for me. Node supports ECMAScript Modules as *.mjs files, and webpack supports *.mjs out of box too.. I have trouble in installing deps with npm (using yarn is okay), and I fails to run build script on my Windows \ud83d\ude02. However tests are passing in CI, maybe I need to switch to a Mac.. node version: v10.7.0\nnpm version: 6.1.0\nOS version: win 10\nLogs when I run npm install:\n```log\n$ npm i\n\nundefined postinstall D:\\workspace\\redux-saga\nnpm run bootstrap\n@ bootstrap D:\\workspace\\redux-saga\nlerna bootstrap --ignore-scripts\n\nlerna info version 3.0.6\nlerna info Bootstrapping 14 packages\nlerna info Installing external dependencies\nlerna info hoist Installing hoisted dependencies into root\nlerna info hoist Pruning hoisted dependencies\nlerna info hoist Finished pruning hoisted dependencies\nlerna ERR! npm install exited 4294963238 in 'redux-saga'\nlerna ERR! npm install stderr:\nnpm WARN redux-devtools@3.4.1 requires a peer of redux@^3.5.2 but none was installed.\nnpm ERR! path D:\\workspace\\redux-saga\\node_modules\\npm\\node_modules\\update-notifier\nnpm ERR! code ENOENT\nnpm ERR! errno -4058\nnpm ERR! syscall rename\nnpm ERR! enoent ENOENT: no such file or directory, rename 'D:\\workspace\\redux-saga\\node_modules\\npm\\node_modules\\update-notifier' -> 'D:\\workspace\\redux-saga\\node_modules\\npm\\node_modul\nes.update-notifier.DELETE'\nnpm ERR! enoent This is related to npm not being able to find a file.\nnpm ERR! enoent\n```\nIf I set npmClient to 'yarn' in lerna.json and use yarn to install deps, then the installation is okay. But yarn does not respect --ignore-scripts and postbootstrap script will be executed.\n\nLogs when I run npm run build in the core package:\n```log\n$ npm run build\n\nredux-saga@1.0.0-beta.1 prebuild D:\\workspace\\redux-saga\\packages\\core\nnpm run clean\nredux-saga@1.0.0-beta.1 clean D:\\workspace\\redux-saga\\packages\\core\nrimraf dist\nredux-saga@1.0.0-beta.1 build D:\\workspace\\redux-saga\\packages\\core\nrollup -c\n\nsrc/index.js, src/effects.js, src/utils.js \u2192 dist...\n[!] (babel plugin) SyntaxError: D:\\workspace\\redux-saga\\packages\\core\\src\\internal\\middleware.js: Support for the experimental syntax 'objectRestSpread' isn't currently enabled (7:63):\n5 | import { runSaga } from './runSaga'\n   6 | \n\n7 | export default function sagaMiddlewareFactory({ context = {}, ...options } = {}) {\n     |                                                               ^\n   8 |   const { sagaMonitor, logger, onError, effectMiddlewares } = options\n   9 |   let boundRunSaga\n  10 | \n\nAdd @babel/plugin-proposal-object-rest-spread (https://git.io/vb4Ss) to the 'plugins' section of your Babel config to enable transformation.\nsrc\\internal\\middleware.js (7:62)\nSyntaxError: D:\\workspace\\redux-saga\\packages\\core\\src\\internal\\middleware.js: Support for the experimental syntax 'objectRestSpread' isn't currently enabled (7:63):\n5 | import { runSaga } from './runSaga'\n   6 |\n\n7 | export default function sagaMiddlewareFactory({ context = {}, ...options } = {}) {\n     |                                                               ^\n   8 |   const { sagaMonitor, logger, onError, effectMiddlewares } = options\n   9 |   let boundRunSaga\n  10 |\n\nAdd @babel/plugin-proposal-object-rest-spread (https://git.io/vb4Ss) to the 'plugins' section of your Babel config to enable transformation.\n    at Parser.raise (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:3893:15)\n    at Parser.expectPlugin (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:5227:18)\n    at Parser.parseObj (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:6632:14)\n    at Parser.parseBindingAtom (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:5479:21)\n    at Parser.parseMaybeDefault (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:5542:25)\n    at Parser.parseAssignableListItem (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:5524:21)\n    at Parser.parseBindingList (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:5516:24)\n    at Parser.parseFunctionParams (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:7803:24)\n    at Parser.parseFunction (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:7790:10)\n    at Parser.parseExportDefaultExpression (D:\\workspace\\redux-saga\\packages\\core\\node_modules\\@babel\\parser\\lib\\index.js:8165:19)\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! redux-saga@1.0.0-beta.1 build: rollup -c\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the redux-saga@1.0.0-beta.1 build script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\n```\nThis seems like an incorrect setup of babel/rollup for the core package.. Symbols seems to bring some inconvenience and lead to some subtle bugs (I believe that #1562 is caused by symbols). Though symbols are more suitable in theory, it is good and practical to using strings.. The simplest way to handle this is to add yield delay(0) at the beginning of fetchData. That means executing the body of fetchData asynchronously, so the cancellation of previous invocation will always be executed before the next execution of fetchData.\ndiff\nfunction* fetchData(action) {\n+  yield delay(0)\n  const timelineId = action.timeline.id;\n  // other code...\n}\nI just come up with this simple solution at the moment, but I think there should be some better ways.. Redux-saga itself is somewhat complicated so the code is convoluted too. Things get more complicated that we do not use modern JavaScript (e.g. createTaskIterator) to make redux-saga run in old browsers.\nI've write little-saga that simplifies redux-saga a lot, you can read the source code of little-saga and it should be much easier to understand. Hope this will help you understand the saga internals. There are some differences between little-saga and redux-saga, and I list them in the doc (but sadly, all the documentation is in Chinese \ud83d\ude02).. Redux-saga uses an internal Symbol IO to mark an object as effect. I think this issue is caused by incorrect setup of redux-saga so that there are two different symbols \u2014\u2014 the saga middleware uses different symbol from take so it does not recognize the take-effects.\nIs there multiple copies of redux-saga installed (maybe caused by symbolic link of directory)? Or is it the reason that hot-reload runs redux-saga multiple times and create multiple IO symbols?. Really strange behaviors. The take-effects are handled here, would you mind add a breakpoint and see what's going on?\n\nprivate repo, can provide example repo if required.\n\nan example would be helpful.. You need to add a return statement in every case in your DashboardReducer as follows:\njavascript\nexport default function DashboardReducer( state = initialState, action ) {\n  console.log( 'IN REDUCER' );\n  console.log( action );\n  switch ( action.type ) {\n    case actionTypes.GET_DATA_FOR_DASHBOARD:\n      console.log( 'in the call for dashboard' );\n      return getDataForDashboard( state ); // add the return keyword\n    case actionTypes.GET_DASHBOARD_DATA_SUCCESS:\n      console.log( 'in the success call initator' );\n      return getDashboardSuccess( state, action );\n    case actionTypes.GET_DASHBOARD_DATA_ERROR:\n      return getDashboardError( state, action );\n    default:\n      return state;\n  }\n}. I could not find why your saga not being called from the code. Could you provide an example in codesandbox?. LGTM, except the order of value and done as @Andarist says:\n\nalso probably better to reorder value and done, value should comes first, because its the order used by v8. I think we can add some warning if users are trying to return effects in forked functions like yield io.fork(() => io.select()). But it is of low priority though.. I think localStorage is for keeping something when the web pages close, and localStorage can only store strings, so IMHO localStorage may not be good solution in this cases.\n\nsetContext/getContext is okay, however I suspect that you can pass the parameters from parent saga to children saga and avoid using context. For example: \n```js\nfunction child(foo, bar) { / ... */ }\nfunction* parent() {\n  // foo gets arg1, and bar gets arg2\n  yield call(child, arg1, arg2)\n  // yield fork(child, arg1, arg2)\n}\n``. I changed theobject.assigna bit and make it more align with the nativeObject.assign. However the bundle size gets 36B larger \ud83d\ude13 . ~~Should I revertobject.assign`?~~. > this could be just const payload = { ...eff.payload, detached: true }\nDone.. Just one minor thing. we can remove --ignore-scripts here. Currently, we can create a customized effect creator to satisfy such cases:\n```javascript\nfunction enhancedPut(channel, creator, ...args) {\n  if (is.channel(channel)) {\n    if (is.func(creator)) {\n      // form: enhancedPut(channel, actionCreator, ...args)\n      return put(channel, creator(...args))\n    } else {\n      // form: enhancedPut(channel, action)\n      return put(channel, creator)\n    }\n  } else if (is.func(channel)) {\n    // form: enhancedPut(actionCreator, ...args)\n    args = [creator, ...args]\n    creator = channel\n    return put(creator(...args))\n  } else {\n    // form: enhancedPut(action)\n    return put(channel)\n  }\n}\n// enhancedPut can be used in one of the following forms:\n// enhancedPut(action)\n// enhancedPut(actionCreator, ...args)\n// enhancedPut(channel, action)\n// enhancedPut(channel, actionCreator, ...args)\n```\nHowever, it seems really complicated \ud83d\ude13 . This issue is caused by the yield statement here. Remove the yield and you'll get the expected results.\nIf you look at the call stack when processBigLoop is running, you can see that every yield will add up 3 layer to the call stack. A stack overflow exception will be thrown because we have too many yield here, but it seems the exceptions is somehow swallowed.\n\n. I've done a few tests against branch flatten-stack-experiment. Sadly I found that due to the internal scheduling, all put/take are async -- isSync flag is false when these effects are resolved. I pushed up my tests into branch print-is-sync, you can checkout it and run the following command under packages/core/ folder.\nbash\n`yarn bin`/jest  --testPathPattern='interpreter/takeSync.js' --testNamePattern='deeply nested forks/puts'\nAs put/take are most used effects in applications, it's a pity that only a few effects (select/fork/cancel/channel etc.) can benefit from stack reduction.. > If the staticData is resolved during the select, the take would not finish ever, unless it has a timeout.\nfetching staticData is asynchronous, and execution of select effect is synchronous, so select is always executed before staticData is resolved.\n. > If the staticData is resolved during the select, the take would not finish ever, unless it has a timeout.\nfetching staticData is asynchronous, and execution of select effect is synchronous, so select is always executed before staticData is resolved.\n. I translate your figures into the following code, and there is just one possible case in your scenario if I understand correctly:\njavascript\nfunction* gen() {\n  yield fork(fetch, '/staticData')\n  yield fork(fetch, 'sections/profile')\n  // at this point, /staticData is NOT resolved\n  const questionTypes = yield select(staticData.questionTypes)\n  // at this point, /staticData is NOT resolved\n  yield take(STATIC_DATA_SUCC) // staticData may be resolved during waiting STATIC_DATA_SUCC\n  return map(section, questionTypes)\n}. I translate your figures into the following code, and there is just one possible case in your scenario if I understand correctly:\njavascript\nfunction* gen() {\n  yield fork(fetch, '/staticData')\n  yield fork(fetch, 'sections/profile')\n  // at this point, /staticData is NOT resolved\n  const questionTypes = yield select(staticData.questionTypes)\n  // at this point, /staticData is NOT resolved\n  yield take(STATIC_DATA_SUCC) // staticData may be resolved during waiting STATIC_DATA_SUCC\n  return map(section, questionTypes)\n}. @NormanPerrin this seems good me.. @NormanPerrin this seems good me.. Replace all process.env.NODE_ENV === 'development' to process.env.NODE_ENV !== 'production'. Now tests run under checks, we can add some more tests for common errors.. Replace all process.env.NODE_ENV === 'development' to process.env.NODE_ENV !== 'production'. Now tests run under checks, we can add some more tests for common errors.. Nice catch. The problem is related to the following code: https://github.com/redux-saga/redux-saga/blob/63dfb94ebfaadf1b59a3e4029a1fa71c574307a4/packages/core/src/internal/proc.js#L638-L652\nSince we never dispatch END into env.stdChannel, env.stdChannel.take(taker, match) always gets executed even when the actionChannel is closed, so channel.put is still called after the channel being closed.\nIf I'm understanding correctly, we need to call taker.cancel when the actionChannel is closed.\njavascript\nconst originalClose = chan.close\nchan.close = () => {\n  originalClose()\n  if (taker.cancel) {\n    taker.cancel()\n  }\n}. Nice catch. The problem is related to the following code: https://github.com/redux-saga/redux-saga/blob/63dfb94ebfaadf1b59a3e4029a1fa71c574307a4/packages/core/src/internal/proc.js#L638-L652\nSince we never dispatch END into env.stdChannel, env.stdChannel.take(taker, match) always gets executed even when the actionChannel is closed, so channel.put is still called after the channel being closed.\nIf I'm understanding correctly, we need to call taker.cancel when the actionChannel is closed.\njavascript\nconst originalClose = chan.close\nchan.close = () => {\n  originalClose()\n  if (taker.cancel) {\n    taker.cancel()\n  }\n}. Not sure whether we should close the channels automatically \ud83d\ude15 . Users could close the channels manually in the finally-block if they want to ensure the channels being closed when exiting task.\nThe current issue I found is that even if we call channel.close() explicitly, the memory leak still occurs. See this codesandbox. Not sure whether we should close the channels automatically \ud83d\ude15 . Users could close the channels manually in the finally-block if they want to ensure the channels being closed when exiting task.\nThe current issue I found is that even if we call channel.close() explicitly, the memory leak still occurs. See this codesandbox. I found that auto closing is undesirable when we use spawn effects. The detached children may still use a channel from the parent while the parent task is complete.. Seems quite reasonable. But not sure whether it is worthwhile to add such overloading to take effects. How do you think? @Andarist @restrry . You are using async generator which is not supported by redux-saga. You need to use normal generator instead:\ndiff\n-export async function* fetchUser(action) {\n+export function* fetchUser(action) {\n  /* ... */\n}. You are using async generator which is not supported by redux-saga. You need to use normal generator instead:\ndiff\n-export async function* fetchUser(action) {\n+export function* fetchUser(action) {\n  /* ... */\n}. Add a setTimeOut into fetchSaga is quite straightforward:\n```javascript\nimport delay from '@redux-saga/delay-p'\nfunction* fetchSagaPeriodically() {\n  while (true) {\n    yield call(fetchSaga);\n    yield delay(2000);\n  }\n}\n```\n\n\nbut not sending the data to the component.\n\nYou need to add a payload in you FETCH action so you can save the fetch result in your store, and then your <Table /> can read the result from the store via connect.\ndiff\n-export function fetch() {\n+export function fetch(result) {\n  return {\n    type: FETCH,\n+    result,\n  };\n}\njavascript\n// your reducer\nfunction reducer(state, action) {\n  if (action.type === 'FETCH') {\n    return { ...state, data: action.result } // save the fetch result in your store\n  }\n  // ... other code\n}. Add a setTimeOut into fetchSaga is quite straightforward:\n```javascript\nimport delay from '@redux-saga/delay-p'\nfunction* fetchSagaPeriodically() {\n  while (true) {\n    yield call(fetchSaga);\n    yield delay(2000);\n  }\n}\n```\n\n\nbut not sending the data to the component.\n\nYou need to add a payload in you FETCH action so you can save the fetch result in your store, and then your <Table /> can read the result from the store via connect.\ndiff\n-export function fetch() {\n+export function fetch(result) {\n  return {\n    type: FETCH,\n+    result,\n  };\n}\njavascript\n// your reducer\nfunction reducer(state, action) {\n  if (action.type === 'FETCH') {\n    return { ...state, data: action.result } // save the fetch result in your store\n  }\n  // ... other code\n}. Not sure what you're going to achieve... If you want to skip the delay at the first time, since saga logic could be quite flexible, you could add a local variable skipAtFirstTime as follows: \njavascript\nexport function* fetchSaga() {\n  let skipAtFirstTime = true\n  while (true) {\n    const result = yield call(axios.get, 'http://api.timezonedb.com......')\n    if (!skipAtFirstTime) {\n      skipAtFirstTime = false\n      yield delay(10000)\n    }\n    yield put(actions.fetch(result.data.zones))\n  }\n} . Not sure what you're going to achieve... If you want to skip the delay at the first time, since saga logic could be quite flexible, you could add a local variable skipAtFirstTime as follows: \njavascript\nexport function* fetchSaga() {\n  let skipAtFirstTime = true\n  while (true) {\n    const result = yield call(axios.get, 'http://api.timezonedb.com......')\n    if (!skipAtFirstTime) {\n      skipAtFirstTime = false\n      yield delay(10000)\n    }\n    yield put(actions.fetch(result.data.zones))\n  }\n} . You can only use the yield keyword in a generator function. \nIt seems that what you are implementing is \"when user clicks some button, dispatches some actions\". In your views, where you could access the dispatch function, then you could call the dispatch function directly. However in sagas, where you cannot access the dispatch function, you need to create an eventChannel from the click events, and then take from the eventChannel to let the saga get the click event.\nyield \u53ea\u80fd\u5728\u751f\u6210\u5668\u51fd\u6570\u4e2d\u624d\u80fd\u4f7f\u7528\u3002\n\u770b\u8d77\u6765\u4f60\u60f3\u8981\u5b9e\u73b0\u201c\u7528\u6237\u70b9\u51fb\u67d0\u4e2a\u6309\u94ae\u7684\u65f6\u5019 dispatch \u7279\u5b9a\u7684 action\u201c\uff0c\u5728\u89c6\u56fe\u90a3\u8fb9\u7684\u8bdd\u4f60\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528 dispatch \u51fd\u6570\u3002\u4e0d\u8fc7\u5728 saga \u4e2d\uff0c\u4f60\u9700\u8981\u4ece\u70b9\u51fb\u4e8b\u4ef6\u4e2d\u521b\u5efa\u4e00\u4e2a eventChannel\uff0c\u7136\u540e\u5728 saga \u4e2d\u4ece\u8fd9\u4e2a eventChannel \u4e2d take \u5f97\u5230\u70b9\u51fb\u7684\u4e8b\u4ef6\uff0c\u8fd9\u6837\u4f60\u7684 saga \u624d\u4f1a\u77e5\u9053\u300c\u6309\u94ae\u88ab\u70b9\u51fb\u4e86\u300d\u3002. You can only use the yield keyword in a generator function. \nIt seems that what you are implementing is \"when user clicks some button, dispatches some actions\". In your views, where you could access the dispatch function, then you could call the dispatch function directly. However in sagas, where you cannot access the dispatch function, you need to create an eventChannel from the click events, and then take from the eventChannel to let the saga get the click event.\nyield \u53ea\u80fd\u5728\u751f\u6210\u5668\u51fd\u6570\u4e2d\u624d\u80fd\u4f7f\u7528\u3002\n\u770b\u8d77\u6765\u4f60\u60f3\u8981\u5b9e\u73b0\u201c\u7528\u6237\u70b9\u51fb\u67d0\u4e2a\u6309\u94ae\u7684\u65f6\u5019 dispatch \u7279\u5b9a\u7684 action\u201c\uff0c\u5728\u89c6\u56fe\u90a3\u8fb9\u7684\u8bdd\u4f60\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528 dispatch \u51fd\u6570\u3002\u4e0d\u8fc7\u5728 saga \u4e2d\uff0c\u4f60\u9700\u8981\u4ece\u70b9\u51fb\u4e8b\u4ef6\u4e2d\u521b\u5efa\u4e00\u4e2a eventChannel\uff0c\u7136\u540e\u5728 saga \u4e2d\u4ece\u8fd9\u4e2a eventChannel \u4e2d take \u5f97\u5230\u70b9\u51fb\u7684\u4e8b\u4ef6\uff0c\u8fd9\u6837\u4f60\u7684 saga \u624d\u4f1a\u77e5\u9053\u300c\u6309\u94ae\u88ab\u70b9\u51fb\u4e86\u300d\u3002. Using eventChannel may be a little overwhelming. In this case, let's use the cps effect:\n```javascript\nimport { cps } from 'redux-saga/effects'\nfunction* update() {\n  const result = yield cps(cb => {\n    Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb('user-press-confirm') }])\n  })\n  if (result === 'user-click-confirm') {\n    yield put(back('LoginPage'))\n  } // else ...\n}\n```\nIn this case, yield cps(...) will be blocked until the cb is called. When user presses the confirm button, cb('user-press-confirm') is executed, and 'user-press-confirm' is assigned to result.. Using eventChannel may be a little overwhelming. In this case, let's use the cps effect:\n```javascript\nimport { cps } from 'redux-saga/effects'\nfunction* update() {\n  const result = yield cps(cb => {\n    Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb('user-press-confirm') }])\n  })\n  if (result === 'user-click-confirm') {\n    yield put(back('LoginPage'))\n  } // else ...\n}\n```\nIn this case, yield cps(...) will be blocked until the cb is called. When user presses the confirm button, cb('user-press-confirm') is executed, and 'user-press-confirm' is assigned to result.. \u4e0d\u597d\u610f\u601d\uff0ccb('user-press-confirm') \u90a3\u8fb9\u6211\u5199\u9519\u4e86\u3002\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a null\uff1a\ndiff\nfunction* update() {\n  const result = yield cps(cb => {\n-   Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb('user-press-confirm') }])\n+   Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb(null, 'user-press-confirm') }])\n  })\n}. \u4e0d\u597d\u610f\u601d\uff0ccb('user-press-confirm') \u90a3\u8fb9\u6211\u5199\u9519\u4e86\u3002\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a null\uff1a\ndiff\nfunction* update() {\n  const result = yield cps(cb => {\n-   Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb('user-press-confirm') }])\n+   Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb(null, 'user-press-confirm') }])\n  })\n}. I found a simple case that can test whether the root is under scheduling. If root is under scheduling, then take('*') can get the action dispatched by put(action), and test will win the race. After adding restrry's code, this test can pass.\n```javascript\ntest('runSaga scheduling', async () => {\n  const action = { type: 'ACTION' }\n  let actual\nfunction root() {\n    const result = yield race({\n      // sentinel is used to avoid blocking at take('')\n      sentinel: Promise.resolve(true),\n      test: all([put(action), take('*')]),\n    })\n    actual = result.test\n  }\nawait runSaga(storeLike(() => null), root).toPromise()\nexpect(actual).toEqual([action, action])\n})\n``. I found a simple case that can test whether the root is under scheduling. If root is under scheduling, thentake('')can get the action dispatched byput(action)`, and test* will win the race. After adding restrry's code, this test can pass.\n```javascript\ntest('runSaga scheduling', async () => {\n  const action = { type: 'ACTION' }\n  let actual\nfunction root() {\n    const result = yield race({\n      // sentinel is used to avoid blocking at take('')\n      sentinel: Promise.resolve(true),\n      test: all([put(action), take('*')]),\n    })\n    actual = result.test\n  }\nawait runSaga(storeLike(() => null), root).toPromise()\nexpect(actual).toEqual([action, action])\n})\n```. ~~Okay, then add the following line for me, thanks \ud83d\ude09~~\n~~Shi Feichao 842351815@qq.com (https://github.com/shinima)~~\nI'll push a commit to update my info.. ~~Okay, then add the following line for me, thanks \ud83d\ude09~~\n~~Shi Feichao 842351815@qq.com (https://github.com/shinima)~~\nI'll push a commit to update my info.. I see. Moving suspend+flush into proc makes the fork a bit earlier to lose its lock, so put are executed before  the next sibling take.. I see. Moving suspend+flush into proc makes the fork a bit earlier to lose its lock, so put are executed before  the next sibling take.. Sorry for the late reply. \n\nIs there an interface for accessing all spawned tasks?\n\nSadly, the answer is NO. redux-saga internally does not track the detached tasks, all that redux-saga does when handling spawn effects is calling proc() (the function that consumes the iterator) and return a task descriptor back to the iterator.\nHowever in such cases I think a customized spawn effect creator can be helpful. In the following code, calling mySpawn will yield a spawn effect and it save the task descriptor in a global map, so we can get the task object later. We can even save the task with a name, so then we use the name to retrieve the corresponding task object.\n```javascript\n// a global map for storing all the detached tasks via mySpawn\n// this map can be placed in saga context or in redux store as well\nconst map = new Map()\nfunction* mySpawn(name, fn, ...args) {\n  const task = yield spawn(fn, ...args)\n  map.set(name, task)\n}\nfunction getAllMyTasks() {\n  return map\n}\nfunction* rootSaga() {\n  yield mySpawn('name-1', saga)\n  yield mySpawn('name-2', anotherSaga)\nconst taskMap = getAllMyTasks()\n  yield cancel(Array.from(taskMap.values()))\n}\n```. Sorry for the late reply. \n\nIs there an interface for accessing all spawned tasks?\n\nSadly, the answer is NO. redux-saga internally does not track the detached tasks, all that redux-saga does when handling spawn effects is calling proc() (the function that consumes the iterator) and return a task descriptor back to the iterator.\nHowever in such cases I think a customized spawn effect creator can be helpful. In the following code, calling mySpawn will yield a spawn effect and it save the task descriptor in a global map, so we can get the task object later. We can even save the task with a name, so then we use the name to retrieve the corresponding task object.\n```javascript\n// a global map for storing all the detached tasks via mySpawn\n// this map can be placed in saga context or in redux store as well\nconst map = new Map()\nfunction* mySpawn(name, fn, ...args) {\n  const task = yield spawn(fn, ...args)\n  map.set(name, task)\n}\nfunction getAllMyTasks() {\n  return map\n}\nfunction* rootSaga() {\n  yield mySpawn('name-1', saga)\n  yield mySpawn('name-2', anotherSaga)\nconst taskMap = getAllMyTasks()\n  yield cancel(Array.from(taskMap.values()))\n}\n``. Closing it. If you have further questions, just re-open it.. Closing it. If you have further questions, just re-open it..callshould be blocking, that means it will wait the inner saga to complete before resuming the outer generator. So basically I think if you refactor your design/code a little, you could usecall` to wait the inner saga to complete.\nIn your case, I'm not quite sure what's the relationship between addCircleAction and addCircle() \ud83d\ude15  But I think you could put a ADD_CIRCLE_COMPLETED action in the bottom of addCircle() and you can take(wait) this action in other sagas where you want to make sure that the addCircle() is finished.\n```diff\nexport function* addCircle(circleApi, { payload }) {\n// ... other code...\n+ yield put({ type: 'ADD_CIRCLE_COMPLETED'})\n}\nexport function* addTender(tenderApi, { payload }) {\n    try {\n       // NOTE: I want this to finish before continuing with making the API call below.\n       yield call(addCircleAction(payload.circlePayload));\n+    yield take('ADD_CIRCLE_COMPLETED')\n       // Rest of saga removed for brevity.\n    } catch (err) {\n        console.error(err);\n    }\n}\n``.callshould be blocking, that means it will wait the inner saga to complete before resuming the outer generator. So basically I think if you refactor your design/code a little, you could usecall` to wait the inner saga to complete.\nIn your case, I'm not quite sure what's the relationship between addCircleAction and addCircle() \ud83d\ude15  But I think you could put a ADD_CIRCLE_COMPLETED action in the bottom of addCircle() and you can take(wait) this action in other sagas where you want to make sure that the addCircle() is finished.\n```diff\nexport function* addCircle(circleApi, { payload }) {\n// ... other code...\n+ yield put({ type: 'ADD_CIRCLE_COMPLETED'})\n}\nexport function* addTender(tenderApi, { payload }) {\n    try {\n       // NOTE: I want this to finish before continuing with making the API call below.\n       yield call(addCircleAction(payload.circlePayload));\n+    yield take('ADD_CIRCLE_COMPLETED')\n       // Rest of saga removed for brevity.\n    } catch (err) {\n        console.error(err);\n    }\n}\n```. I've cloned your sample repo and it runs well , all buttons works as expected \ud83d\ude13 (seems that you forget adding index.html in your repo).. I've cloned your sample repo and it runs well , all buttons works as expected \ud83d\ude13 (seems that you forget adding index.html in your repo).. Still works fines in my PC. Maybe there's some other plugin/tool influences the webpage. Try to disable browser extensions and redux-devtool, and then have a try.\n\n. Still works fines in my PC. Maybe there's some other plugin/tool influences the webpage. Try to disable browser extensions and redux-devtool, and then have a try.\n\n. I think you may miss something but I could not say it clearly. I'll show you how takeEvery is implemented (so you can know the behavior of takeEvery) and then use a simpilied example to show how to code in such onPageChange scenarios.\ntakeEvery is implemented as follows:\njavascript\nexport function takeEvery(pattern, worker, ...args) {\n  return fork(function* watcher() {\n    while (true) {\n      const action = yield take(pattern)\n      yield fork(worker, ...args, action)\n    }\n  })\n}\nYielding takeEvery(...) will fork a watcher that has a while-true loop inside it, so after yielding takeEvery('FOO', worker), every 'FOO' action will have a worker to handle it. The watcher is a long-running task that never completes (because of the while-true loop). To stop the watcher, you need to cancel it manually at proper time (for example, when user navigates to another page).\nAnd below is a simplified example that shows how to cancel such watchers when user navigates to another page.\n```javascript\nfunction root*() {\n  // assume that every time user navigates to a new page, a PAGE_CHANGE action will be dispatched\n  yield takeEvery('PAGE_CHANGE', pageChange)\n}\n// This is wrong implementation of pageChange\n// every time the page changes, new watchers are added, but old watchers do not get removed\nfunction pageChange1*({ nextPage }) {\n  if (nextPage === 'page-a') {\n    // user navigates to page-a, so we need to add watchers for actions dispatched from page-a\n    yield takeEvery('FOO-IN-PAGE-A', handleFooInPageA)\n    yield takeEvery('BAR-IN-PAGE-A', handleBarInPageA)\n  } else if (nextPage === 'page-b') {\n    yield takeEvery('BUZZ-IN-PAGE-B', handleBuzzInPageB)\n  }\n}\n// This is correct (though ugly) implementation of pageChange\nlet tasks = [] // using a global variable to save the old tasks\nfunction pageChane2*({ nextPage }) {\n  // cancel all old tasks\n  for (const task of tasks) {\n    yield cancel(task)\n  }\n  tasks = []\n  if (nextPage === 'page-a') {\n    tasks.push(yield takeEvery('FOO-IN-PAGE-A', handleFooInPageA))\n    tasks.push(yield takeEvery('BAR-IN-PAGE-A', handleBarInPageA))\n  } else if (nextPage === 'page-b') {\n    tasks.push(yield takeEvery('BUZZ-IN-PAGE-B', handleBuzzInPageB))\n  }\n}\n```\nManually saving and then cancelling the tasks is cumbersome, we can utilize the takeLatest helper to get much more concise implementation as follows:\n```javascript\nfunction root2*() {\n  yield takeLatest('PAGE_CAHNGE', pageChange1)\n}\nfunction pageChange1*({ nextPage }) {\n  if (nextPage === 'page-a') {\n    // user navigates to page-a, so we need to add watchers for actions dispatched from page-a\n    yield takeEvery('FOO-IN-PAGE-A', handleFooInPageA)\n    yield takeEvery('BAR-IN-PAGE-A', handleBarInPageA)\n  } else if (nextPage === 'page-b') {\n    yield takeEvery('BUZZ-IN-PAGE-B', handleBuzzInPageB)\n  }\n}\n```\nWhen another PAGE_CHANGE action dispatches, the takeLatest helper will cancel the last pageChange1 watcher, and since the cancellation propagates downward so all sub-watchers (for example, handleFooInPageA and handleBarInPageA) will get cancelled, then the takeLatest will start a watcher using the newer action.  \ud83d\udc31 \n. I think you may miss something but I could not say it clearly. I'll show you how takeEvery is implemented (so you can know the behavior of takeEvery) and then use a simpilied example to show how to code in such onPageChange scenarios.\ntakeEvery is implemented as follows:\njavascript\nexport function takeEvery(pattern, worker, ...args) {\n  return fork(function* watcher() {\n    while (true) {\n      const action = yield take(pattern)\n      yield fork(worker, ...args, action)\n    }\n  })\n}\nYielding takeEvery(...) will fork a watcher that has a while-true loop inside it, so after yielding takeEvery('FOO', worker), every 'FOO' action will have a worker to handle it. The watcher is a long-running task that never completes (because of the while-true loop). To stop the watcher, you need to cancel it manually at proper time (for example, when user navigates to another page).\nAnd below is a simplified example that shows how to cancel such watchers when user navigates to another page.\n```javascript\nfunction root*() {\n  // assume that every time user navigates to a new page, a PAGE_CHANGE action will be dispatched\n  yield takeEvery('PAGE_CHANGE', pageChange)\n}\n// This is wrong implementation of pageChange\n// every time the page changes, new watchers are added, but old watchers do not get removed\nfunction pageChange1*({ nextPage }) {\n  if (nextPage === 'page-a') {\n    // user navigates to page-a, so we need to add watchers for actions dispatched from page-a\n    yield takeEvery('FOO-IN-PAGE-A', handleFooInPageA)\n    yield takeEvery('BAR-IN-PAGE-A', handleBarInPageA)\n  } else if (nextPage === 'page-b') {\n    yield takeEvery('BUZZ-IN-PAGE-B', handleBuzzInPageB)\n  }\n}\n// This is correct (though ugly) implementation of pageChange\nlet tasks = [] // using a global variable to save the old tasks\nfunction pageChane2*({ nextPage }) {\n  // cancel all old tasks\n  for (const task of tasks) {\n    yield cancel(task)\n  }\n  tasks = []\n  if (nextPage === 'page-a') {\n    tasks.push(yield takeEvery('FOO-IN-PAGE-A', handleFooInPageA))\n    tasks.push(yield takeEvery('BAR-IN-PAGE-A', handleBarInPageA))\n  } else if (nextPage === 'page-b') {\n    tasks.push(yield takeEvery('BUZZ-IN-PAGE-B', handleBuzzInPageB))\n  }\n}\n```\nManually saving and then cancelling the tasks is cumbersome, we can utilize the takeLatest helper to get much more concise implementation as follows:\n```javascript\nfunction root2*() {\n  yield takeLatest('PAGE_CAHNGE', pageChange1)\n}\nfunction pageChange1*({ nextPage }) {\n  if (nextPage === 'page-a') {\n    // user navigates to page-a, so we need to add watchers for actions dispatched from page-a\n    yield takeEvery('FOO-IN-PAGE-A', handleFooInPageA)\n    yield takeEvery('BAR-IN-PAGE-A', handleBarInPageA)\n  } else if (nextPage === 'page-b') {\n    yield takeEvery('BUZZ-IN-PAGE-B', handleBuzzInPageB)\n  }\n}\n```\nWhen another PAGE_CHANGE action dispatches, the takeLatest helper will cancel the last pageChange1 watcher, and since the cancellation propagates downward so all sub-watchers (for example, handleFooInPageA and handleBarInPageA) will get cancelled, then the takeLatest will start a watcher using the newer action.  \ud83d\udc31 \n. redux-saga.js.org reflects the latest version of redux-saga (currently it is v0.16.x, v1.0 is just in beta now), so the content will remain untouched before redux-saga v1 comes out. When we publish redux-saga v1.0, we will update the documentation site.. redux-saga.js.org reflects the latest version of redux-saga (currently it is v0.16.x, v1.0 is just in beta now), so the content will remain untouched before redux-saga v1 comes out. When we publish redux-saga v1.0, we will update the documentation site.. Closing it.  If you have further questions, just re-open it.. Closing it.  If you have further questions, just re-open it.. Your example code is based on dva, and it seems that there's big difference between dva and redux-saga about accessing effect creators. I am not very familiar with dva, maybe you should open an issue in dva repo.. Your example code is based on dva, and it seems that there's big difference between dva and redux-saga about accessing effect creators. I am not very familiar with dva, maybe you should open an issue in dva repo.. I think the main reason of disorder is the scheduler.\njavascript\nfunction sagaMiddleware({ getState, dispatch }) {\n// ... other code\nreturn next => action => {\n  // ... other code...\n  const result = next(action) // hit reducers\n  channel.put(action) // LINE-A\n  return result\n}\nNote that at LINE-A, the channel is an instance of stdChannel, and its put will be wrapped by asap, that means the actual action will not go through the underlying channel immediately when LINE-A executes. That's why the saga gets the action later than all other redux middlewares.\nSorry for using the implementation detail to explain this strange behavior, hope this could be understood by you guys.. I think the main reason of disorder is the scheduler.\njavascript\nfunction sagaMiddleware({ getState, dispatch }) {\n// ... other code\nreturn next => action => {\n  // ... other code...\n  const result = next(action) // hit reducers\n  channel.put(action) // LINE-A\n  return result\n}\nNote that at LINE-A, the channel is an instance of stdChannel, and its put will be wrapped by asap, that means the actual action will not go through the underlying channel immediately when LINE-A executes. That's why the saga gets the action later than all other redux middlewares.\nSorry for using the implementation detail to explain this strange behavior, hope this could be understood by you guys.. Seems current problem is with the following line of code.\njavascript\nconst env = {\n  channel: { ...channel, put: wrapSagaDispatch(dispatch || channel.put) },\n  // ...\n}\nLet me try to explain how it works. The following is the influenced code:\n```javascript\n// =============   previous code ================\n// in env setup\nenv.channel = channel\n// in runPutEffect\nfunction runPutEffect({ channel, action, resolve }, cb) {\n  asap(() => {\n    let result\n    try {\n      result = (channel ? channel.put : env.dispatch)(action)\n    } catch (error) {\n      cb(error, true)\n      return\n    }\n    // ......\n  })\n}\n// =============   current code ================\n// in env setup\nenv.channel = { ...channel, put: wrapSagaDispatch(dispatch || channel.put) }\n// in runPutEffect\nfunction runPutEffect({ channel = env.channel, action, resolve }, cb) {\n  asap(() => {\n    let result\n    try {\n      result = channel.put(action)\n    } catch (error) {\n      cb(error, true)\n      return\n    }\n    // ......\n  })\n}\n```\nImage what would happend in the following different cases...\n\n\nWhen we use yield put(ch, ac), the channel passed to runPutEffect() will be ch, both previous and current code will execute ch.put(ac)\n\n\nWhen we use yield put(ac)...\n\nIn previous code, channel passed to runPutEffect() is undefined, so the code will execute env.dispatch(ac).\n\nIn current code, it will execute as env.channel.put(ac), but since we have swapped the env.channel.put and it refers to dispatch, the actual executed code is the same as dispatch(ac).\n\n\nWhen we call channel.put(ac) outside the saga... In current code, env.channel = { ...channel, put: ... } does not mutate the channel inplace (it creates a new channel with a new put method), so channel.put(ac) will have the same behavior as in the previous code. In both code, ac will go through the channel, but it will NOT hit reducers.\n\n\nWhen we store.dispatch(ac)... after hitting reducers, ac will be captured by sagaMiddleware and it will be send to channel, so the case becomes case-3...\n\n\nHope this explanation is readily comprehensible.\n\nThe idea behind this change is that, by swapping the channel.put, we move our logic into the channel and keep the saga runtime simple.  Hope this can be understood and adopted by you. For me, it seems better than the old code, though actually I'm okay with the old code.. Seems current problem is with the following line of code.\njavascript\nconst env = {\n  channel: { ...channel, put: wrapSagaDispatch(dispatch || channel.put) },\n  // ...\n}\nLet me try to explain how it works. The following is the influenced code:\n```javascript\n// =============   previous code ================\n// in env setup\nenv.channel = channel\n// in runPutEffect\nfunction runPutEffect({ channel, action, resolve }, cb) {\n  asap(() => {\n    let result\n    try {\n      result = (channel ? channel.put : env.dispatch)(action)\n    } catch (error) {\n      cb(error, true)\n      return\n    }\n    // ......\n  })\n}\n// =============   current code ================\n// in env setup\nenv.channel = { ...channel, put: wrapSagaDispatch(dispatch || channel.put) }\n// in runPutEffect\nfunction runPutEffect({ channel = env.channel, action, resolve }, cb) {\n  asap(() => {\n    let result\n    try {\n      result = channel.put(action)\n    } catch (error) {\n      cb(error, true)\n      return\n    }\n    // ......\n  })\n}\n```\nImage what would happend in the following different cases...\n\n\nWhen we use yield put(ch, ac), the channel passed to runPutEffect() will be ch, both previous and current code will execute ch.put(ac)\n\n\nWhen we use yield put(ac)...\n\nIn previous code, channel passed to runPutEffect() is undefined, so the code will execute env.dispatch(ac).\n\nIn current code, it will execute as env.channel.put(ac), but since we have swapped the env.channel.put and it refers to dispatch, the actual executed code is the same as dispatch(ac).\n\n\nWhen we call channel.put(ac) outside the saga... In current code, env.channel = { ...channel, put: ... } does not mutate the channel inplace (it creates a new channel with a new put method), so channel.put(ac) will have the same behavior as in the previous code. In both code, ac will go through the channel, but it will NOT hit reducers.\n\n\nWhen we store.dispatch(ac)... after hitting reducers, ac will be captured by sagaMiddleware and it will be send to channel, so the case becomes case-3...\n\n\nHope this explanation is readily comprehensible.\n\nThe idea behind this change is that, by swapping the channel.put, we move our logic into the channel and keep the saga runtime simple.  Hope this can be understood and adopted by you. For me, it seems better than the old code, though actually I'm okay with the old code.. ~~@Andarist  any ideas?  If we are unsure about removing env.dispatch,  I could keep env.dispatch in this PR and then move the change into another PR.~~\nI've added env.dispatch back.. ~~@Andarist  any ideas?  If we are unsure about removing env.dispatch,  I could keep env.dispatch in this PR and then move the change into another PR.~~\nI've added env.dispatch back.. \nLet me think aloud the current behavior of exception during cancellation as far as I understand.\nIn the following code, the parent is going to cancel the child, and child would throw an exception during the cancellation.\njavascript\nfunction* parent() {\n  // ... other code ...\n  yield cancel(child); // child would throw during cancellation\n}\nThe behavior is that we will re-throw the exception in already-cancelled tasks, so exception will bubble to parent. When parent catches the exception, it will run ...\nhttps://github.com/redux-saga/redux-saga/blob/309d6be7507a22e2443e7843e61ef8555ea25eba/packages/core/src/internal/proc.js#L269-L270\n... so the parent will be aborted with the bubbled exception.\nMy concern is that whether it is the desired behavior of cancellation. Because cancelling a task means that we don't care that child anymore, exception from a cancelled task should NOT abort our parent task. However, if we want to have env.onError called with the exception, we must accept this behavior first. \ud83d\ude15\n. \nLet me think aloud the current behavior of exception during cancellation as far as I understand.\nIn the following code, the parent is going to cancel the child, and child would throw an exception during the cancellation.\njavascript\nfunction* parent() {\n  // ... other code ...\n  yield cancel(child); // child would throw during cancellation\n}\nThe behavior is that we will re-throw the exception in already-cancelled tasks, so exception will bubble to parent. When parent catches the exception, it will run ...\nhttps://github.com/redux-saga/redux-saga/blob/309d6be7507a22e2443e7843e61ef8555ea25eba/packages/core/src/internal/proc.js#L269-L270\n... so the parent will be aborted with the bubbled exception.\nMy concern is that whether it is the desired behavior of cancellation. Because cancelling a task means that we don't care that child anymore, exception from a cancelled task should NOT abort our parent task. However, if we want to have env.onError called with the exception, we must accept this behavior first. \ud83d\ude15\n. > but forces users to have safe finally block.\nI like this idea. By the way, if we adopt the re-throw approach, maybe we should warn users that an exception during cancellation occurs. Overall, I like this PR, it makes thing easier.  @Andarist what do you think?  If you like it, I will do a more thorough review.. This PR seems to be an great start to do internal refactor,  I will investigate further potential refinement that can be done based on this PR.. @Andarist Have a look at this PR?  It should be an PR that we would like to merge it.. As _isRunning / _isCancelled / _isAborted are defined under the scope of newTask, there is no need to have a underline as the name start, so I've change/simplify some field names of task/mainTask object in 7018761.. This PR is based on effectRunnerMap when I created it (so we can discuss earlier) . Now effectRunnerMap is merged, I'll resolve the conflicts and change the target to master.. Updated the commits and the description of this PR. @Andarist @restrry . Rebased.. I'll try using a single variable status to representing the status of a task and adding task.digestEffect() in other PRs.\nIs there anything actionable in this PR? or can I merge this PR now?. The semicolon is added by prettier. If you remove these semicolons and run prettier again, it will add for you.. https://www.zhihu.com/question/20298345   Hope this can help you.. Thanks for reporting. I've seen the code in your repository, it seems that you are using an old version of redux-saga (0.15.6).\nCan you upgrade it to a modern version (0.16.x or 1.0.0-beta.x) and test again?  I believe that the exception should be always caught by jest in modern versions.\nI run the tests against the master branch and the exception is caught both in fork and call.. @kabike You could use the following code to let your saga automatically restart when it encounters an error:\n```javascript\nfunction keepAlive(sagaFn) {\n  return function*() {\n    while (true) {\n      try {\n        const result = yield io.call(sagaFn)\n        console.log('saga completes with result:', result)\n        return result\n      } catch (e) {\n        console.error('saga aborted due to:', e)\n        console.log('restarting the saga...')\n      }\n    }\n  }\n}\n// And your code becomes like...\nyield takeEvery(actions.GET_ALL_PRODUCTS, keepAlive(getAllProducts))\n```\nYou can put keepAlive at a higher level (say, the rootSaga) to control the granularity of restarting behaviors.restart . You could use the actionChannel effect to buffer the actions and use a while-true loop to consums the actions.\njavascript\nfunction* saga() {\n  const chan = yield actionChannel('REPLACE_ELEMENT_DETAILS')\n  try {\n    while (true) {\n      const action = yield take(chan)\n      yield call(yourHandler, action)\n    }\n  } finally {\n    chan.close()\n  }\n}. thanks. Added some tests, please have a look @Andarist  @restrry . We still need to use task.mainTask.status in runCancelledEffect().  \nA task may have its iterator consumed up, but still wait for a long-running child task. In such cases, mainTask.status is DONE and task.status is CANCELLED, we need mainTask.status to determine that the saga is NOT cancelled in such cases.\njavascript\nfunction* saga() {\n  yield fork(longRunningSaga)\n  // mainTask.status is DONE here\n  // but if the task is cancelled at this point, the task.status will be CANCELLED\n}. 3. The refactor to task and mainTask should be internal only. I did not change the public interface of Task. so we don't need to document the changes.. mainTask.status should reflect the fact of running status of the iterator, so I think changing mainTask.status is not a good idea.\nOn the other hand, I think maybe using cb(task.isCancelled()) in runCancelledEffect() is enough. mainTask.status becoming DONE means the main body of the saga has finished, so the saga will never yield a cancelled effect to query the cancellation status. That means we can simply ignore the cases when mainTask.status is DONE, and we do not need to care the edge case that I just described.\nHowever, I do a quick test against using cb(task.isCancelled()) in runCancelledEffect() on my PC, two test cases are failing.. Thanks for clarifying the logic in https://github.com/redux-saga/redux-saga/pull/1700#issuecomment-446185315.\n\nI believe we should switch task to CANCELLED state in the end when receiving TASK_CANCEL, otherwise it will become DONE which is really confusing - after all the task received TASK_CANCEL and its mainTask is cancelled.\n\nAs far as I known, before receiving TASK_CANCEL the task should be already in CANCELLED status, because we have set it in cancel():\nhttps://github.com/redux-saga/redux-saga/blob/1b3ea61b41d322f28d288a32bc0eb931f430cb5e/packages/core/src/internal/newTask.js#L35-L44\nI do the following edit...\ndiff\n// newTask.js\n function end(result, isErr) {\n    if (!isErr) {\n      // The status here may be RUNNING or CANCELLED\n      // If the status is CANCELLED, then we do not need to change it here\n-     if (result === TASK_CANCEL) {\n-       status = CANCELLED\n-     } else if (status !== CANCELLED) {\n+     if (status !== CANCELLED) {\n        status = DONE\n      }\n      taskResult = result\n      deferredEnd && deferredEnd.resolve(result)\n    } else {\n... and tests are still passing.. If I am wrong, please point me out. It seems incorrect to me that we do task.isCancelled = () => status === CANCELLED || mainTask.status === CANCELLED. The mainTask/iterator gets cancelled does not mean that the task is cancelled:\n\nIn the figure above, circles mean iterators and squares mean tasks. It shows an error bubbling from a forked descendant to the root. When the error occurs (left-side in the figure), most of the iterators(mainTasks) are in running status (colored as blue). When the bubbling is done (right-side in the figure), all running iterators go into cancelled status (colored as gray) including the root iterator.\nSo in this figure, root.mainTask.status is CANCELLED, but root.task.status is ABORTED other than CANCELLED. If we use task.isCancelled = () => status === CANCELLED || mainTask.status === CANCELLED here, then both rootTask.isCancelled() and rootTask.isAborted() will return true.. You can run the following test which will lead to a strange behavior.\n```javascript\ntest('task status', () => {\n  const middleware = sagaMiddleware()\n  createStore(() => ({}), {}, applyMiddleware(middleware))\nfunction genFn() {\n    yield io.fork(function() {\n      yield io.delay(10)\n      throw new Error('error')\n    })\n    yield io.delay(10000)\n  }\nconst task = middleware.run(genFn)\n  return task.toPromise().catch(err => {\n    console.log(task.isCancelled()) // prints true\n    console.log(task.isAborted()) // prints true\n    // the task is both cancelled and aborted\n  })\n})\n``. \ud83e\udd14  The above figure make me believe that the implementation in the master branch (i.ecb(task.mainTask.status === CANCELLED)forrunCancelledEffect) is correct, because the cancellation status of mainTask and task is not related --  mainTask.status could be CANCELLED while task.status is ABORTED (as the above figure shows), and task.status could be CANCELLED while mainTask.status is DONE (as described in https://github.com/redux-saga/redux-saga/pull/1700#issuecomment-444439738).. > Ok, so it seems that a simple tweak to:task.isCancelled = () => status === CANCELLED || (status === RUNNING && mainTask.status === CANCELLED)` should do the trick, right?\nI think it is correct now, but it is so complicated \ud83d\ude13 .   \nHow about add a method (e.g. isMainCancelled()) on Task object? Then we can call task.isMainCancelled() in runCancelledEffect(), and then we can remove mainTask property from the Task object. It should be much more straightforward than hacking task.isCancelled().. You can use take with a predicate. For example, say the entity has a unique id property, you can do ...\njavascript\nconst result_payload = yield take(action => \n  action.type === 'LOAD_SUCCESS' && action.entity.id === 1000\n)\n... this take effect will be resolved only on LOAD_SUCCESS action with the specified id.. \ud83d\udc4d   +1 for this.   \nIf we do this, should we change how effects are imported? I think it would be too cumbersome to use import { put, take } from '@redux-saga/core/effects'. '@redux-saga/effects' seems more suitable.. This seems a problem with the dispatched action. You should check the code that dispatches actions, and inspect the action rather than using destructuring assignment.\njavascript\nconst action = yield take(ADD_PROMOTION_REQUESTED)\nconsole.log(action) // see what properties does the action have. You are catching errors in your createBlaBla, so the error does not bubble to the generator. Just replace you createBlaBla as follows:\njavascript\nexport const createBlaBla = (payload) => {\n  return axios.post('/some-url', payload)\n}. After changing...\njavascript\nexport function* process() {\n  yield all([\n    fork(takeEvery, Types.DO_INC, increment),\n    fork(takeEvery, Types.DO_DEC, decrement)\n  ]);\n}\nto\njavascript\nexport function* process() {\n  yield all([\n    takeEvery(Types.DO_INC, increment),\n    takeEvery(Types.DO_DEC, decrement)\n  ]);\n}\n... then everything works as expected.\nBecause takeEvery is already a wrapper of fork, fork(takeEvery, ...) is unneccessary. Just use takeEvery(...) \ud83d\ude38 . @GuillaumeCisco You should use yield all([...]) instead of yield [...] in the root saga, and this is why the code is not working in 1.0.1.  \nActually, if you view the logs in 0.16.x, there is a deprecation warning which tells you to update the code.. > My console.log(userUid) is undefined because it has not retrieve from the server yet.\nYou can use something like take(USER_UID_READY) to block the execution of syncOnSnapShotPromotionDocChanged() before the userUid is retrived from the server. Doing so requires you to dispatch a USER_UID_READY action when the userUid is ready.. > My console.log(userUid) is undefined because it has not retrieve from the server yet.\nYou can use something like take(USER_UID_READY) to block the execution of syncOnSnapShotPromotionDocChanged() before the userUid is retrived from the server. Doing so requires you to dispatch a USER_UID_READY action when the userUid is ready.. delay is blocking, for example, the generator will suspend at yeild delay(1000) for 1 second. You can view the source code of delay here, and I think it should be very much like how you define blockingDelay.\nIMHO, console.log('wanted this to print before exit'); not being executed is unrelated to delay or race. It seems that someSaga got cancelled before printing 'wanted this to print before exit', this may be caused by an exception while executing waitFor(channel, ['DESIRED_ACTION_TYPE']), or caused by cancellation from the anotherSaga.. delay is blocking, for example, the generator will suspend at yeild delay(1000) for 1 second. You can view the source code of delay here, and I think it should be very much like how you define blockingDelay.\nIMHO, console.log('wanted this to print before exit'); not being executed is unrelated to delay or race. It seems that someSaga got cancelled before printing 'wanted this to print before exit', this may be caused by an exception while executing waitFor(channel, ['DESIRED_ACTION_TYPE']), or caused by cancellation from the anotherSaga.. The different behavior between 0.16.x and 1.0 is due to https://github.com/redux-saga/redux-saga/commit/64c17f7fac6220a4dddb23a9413e9012ece83819#diff-56ae1a53433b6c6fbff8fe83311f4a94R46. In this commit, we accidentally changed the behavior from creating a stdChannel instances every time proc() is called to using a shared stdChannel instance for all subsequent sagas attached to the middleware. Once the shared stdChannel instance is ENDed, all subsequent put-effects on this channel would be noop.. The different behavior between 0.16.x and 1.0 is due to https://github.com/redux-saga/redux-saga/commit/64c17f7fac6220a4dddb23a9413e9012ece83819#diff-56ae1a53433b6c6fbff8fe83311f4a94R46. In this commit, we accidentally changed the behavior from creating a stdChannel instances every time proc() is called to using a shared stdChannel instance for all subsequent sagas attached to the middleware. Once the shared stdChannel instance is ENDed, all subsequent put-effects on this channel would be noop.. This should be a mistake in doc. Would you like make a PR to fix this?. This should be a mistake in doc. Would you like make a PR to fix this?. Thanks for report, I've confirmed this issue and I'll create a PR to fix it.. Thanks for report, I've confirmed this issue and I'll create a PR to fix it.. > When I trigger the reducer to remove the deleted agendaitem from the state, this will be run asynchronious or?\nWhen you put some action (fooAction), the following things will happen:\n1. the reducer got called synchronously, and the redux state gets updated\n2. After the state gets updated, saga/generator that blocks at yield take('FOO') resumes synchronously.  And the updated redux state is returned when the resumed saga uses select.\njavascript\nfunction* saga() {\n  const state1 = yield select() // state1 is the initial state\n  yield take('FOO') // before this yield statements resumes, the FOO action is dispatched to the redux\n  const state2 = yield select() // state2 is the updated state\n}\n\n\n...be sure, that sagas called after that are accessing the correct values from the state..\n\n~~This is hard to answer... \ud83d\ude13  select always gives you the latest redux state, yielding select effect at different time (e.g before/after take('FOO'), or before/after put({ type: 'FOO' )) may return different value. So the key point is yielding select at correct time~~\n. > When I trigger the reducer to remove the deleted agendaitem from the state, this will be run asynchronious or?\nWhen you put some action (fooAction), the following things will happen:\n1. the reducer got called synchronously, and the redux state gets updated\n2. After the state gets updated, saga/generator that blocks at yield take('FOO') resumes synchronously.  And the updated redux state is returned when the resumed saga uses select.\njavascript\nfunction* saga() {\n  const state1 = yield select() // state1 is the initial state\n  yield take('FOO') // before this yield statements resumes, the FOO action is dispatched to the redux\n  const state2 = yield select() // state2 is the updated state\n}\n\n\n...be sure, that sagas called after that are accessing the correct values from the state..\n\n~~This is hard to answer... \ud83d\ude13  select always gives you the latest redux state, yielding select effect at different time (e.g before/after take('FOO'), or before/after put({ type: 'FOO' )) may return different value. So the key point is yielding select at correct time~~\n. What does api.get(url) returns? The call has signature call(fn, ...args) or call({ context, fn }, ...args). It seems to me that you are passing wrong arguments to call.. What does api.get(url) returns? The call has signature call(fn, ...args) or call({ context, fn }, ...args). It seems to me that you are passing wrong arguments to call.. Thanks for reporting. In my option, I think we may simply avoid stringifying args[0]. Replacing the code to instead of writing yield call(delay, ...) where delay from ... should fix the issue. How you think?. Thanks for reporting. In my option, I think we may simply avoid stringifying args[0]. Replacing the code to instead of writing yield call(delay, ...) where delay from ... should fix the issue. How you think?. Take with an array of types should work.\njavascript\nyield take([ togglePauseDownload().type, networkStatusChanged().type])\nMore detail can be found at doc.. Take with an array of types should work.\njavascript\nyield take([ togglePauseDownload().type, networkStatusChanged().type])\nMore detail can be found at doc.. > My reasoning for this being a core piece of the API is that the event loops in general can be a bit confusing and this calls it out to show actually what behavior with and without the defer can be expected ......\nActually in both cases the action { type: 'TWO' } will NOT be ignored, @bradennapier you can check it in this codesandbox.\n\nFrom your implementation of defer, I guess that it is sufficient to add yield Promise.resolve() before what you want to defer. For example (follows your examples)...\n``javascript\nfunction* sagaOne() { // --> 4\n  // explicitly deferput({ type: 'TWO' })`\n  //   so we can make sure the action can be taken by parentSaga\n  yield Promise.resolve()\nyield put({ // --> 5\n    type: 'TWO',\n  });\n}\n// other code omitted...\n``. > My reasoning for this being a core piece of the API is that the event loops in general can be a bit confusing and this calls it out to show actually what behavior with and without thedefer` can be expected ......\nActually in both cases the action { type: 'TWO' } will NOT be ignored, @bradennapier you can check it in this codesandbox.\n\nFrom your implementation of defer, I guess that it is sufficient to add yield Promise.resolve() before what you want to defer. For example (follows your examples)...\n``javascript\nfunction* sagaOne() { // --> 4\n  // explicitly deferput({ type: 'TWO' })`\n  //   so we can make sure the action can be taken by parentSaga\n  yield Promise.resolve()\nyield put({ // --> 5\n    type: 'TWO',\n  });\n}\n// other code omitted...\n```. Failing checks is caused by babel@6 being updated. We need to update out test fixtures.. Failing checks is caused by babel@6 being updated. We need to update out test fixtures.. There are some points that may help you understand context:\n\nEvery task has its own context. When a new task is created, a new context object is created for this task.\nTask can only change its own context by yielding setContext effects.\nWhen saga middleware gets a getContext('foo'), it will first check whether 'foo' in the task context. If it is there, then returns it; else it will check whether 'foo' is in the context of the task's parent. If not, then check parent's parent's context... The check will be executed until to the root task.  If the root task's context does not has 'foo', then getContext('foo') returns undefined.\n\nThe last point is simply implemented by using Object.create(), which is alwayed referred as prototype chain. You can find the source code where we call Object.create in redux-saga here.\n. There are some points that may help you understand context:\n\nEvery task has its own context. When a new task is created, a new context object is created for this task.\nTask can only change its own context by yielding setContext effects.\nWhen saga middleware gets a getContext('foo'), it will first check whether 'foo' in the task context. If it is there, then returns it; else it will check whether 'foo' is in the context of the task's parent. If not, then check parent's parent's context... The check will be executed until to the root task.  If the root task's context does not has 'foo', then getContext('foo') returns undefined.\n\nThe last point is simply implemented by using Object.create(), which is alwayed referred as prototype chain. You can find the source code where we call Object.create in redux-saga here.\n. I'm cloing this issue. If you have any further questions, just ask.. I'm cloing this issue. If you have any further questions, just ask.. What you need may be...\n```javascript\nexport function* applyItemMovements(action) {\n  try {\n    // create an array of promises\n    const promises = ItemMoveRequests.map(ItemMoveRequest => callAPI(action.metadata.client, moveReq))\n    // pass promises to all\n    const result = yield all(promises)\n  } catch (error) {\n    //print error\n  }\n}\n```\n\n\n...remaining items call API even if one item in array fails...\n\nYou can use Promise#catch to avoid errors in one API-call propogating to all effect.\njavascript\nconst promises = ItemMoveRequests.map(ItemMoveRequest => {\n  const promise = callAPI(action.metadata.client, moveReq)\n  return promise\n    .then(result => ({ label: 'some label', ok: true, result })\n    .catch(err => ({ label: 'xxx', ok: false, err })),\n  )\n})\nconst result = yield all(promises). What you need may be...\n```javascript\nexport function* applyItemMovements(action) {\n  try {\n    // create an array of promises\n    const promises = ItemMoveRequests.map(ItemMoveRequest => callAPI(action.metadata.client, moveReq))\n    // pass promises to all\n    const result = yield all(promises)\n  } catch (error) {\n    //print error\n  }\n}\n```\n\n\n...remaining items call API even if one item in array fails...\n\nYou can use Promise#catch to avoid errors in one API-call propogating to all effect.\njavascript\nconst promises = ItemMoveRequests.map(ItemMoveRequest => {\n  const promise = callAPI(action.metadata.client, moveReq)\n  return promise\n    .then(result => ({ label: 'some label', ok: true, result })\n    .catch(err => ({ label: 'xxx', ok: false, err })),\n  )\n})\nconst result = yield all(promises). Yes, you can. Then the code will look like \njavascript\nyield all(\n  ItemMoveRequests.map(moveReq =>\n    call(callAPI, action.metadata.client, moveReq)\n  )\n)\nNote that you don't need write the square brackets [ ] manually. . Yes, you can. Then the code will look like \njavascript\nyield all(\n  ItemMoveRequests.map(moveReq =>\n    call(callAPI, action.metadata.client, moveReq)\n  )\n)\nNote that you don't need write the square brackets [ ] manually. . \ud83d\udc4d Installing dependencies are much faster than before.. \ud83d\udc4d Installing dependencies are much faster than before.. From your demo on Codesanbox, why tests are failing seems NOT related to redux-saga. It seems to be related to jest snapshot, however I'm not familiar with jest snapshot.\n\n\nCannot read property 'buildType' of undefined\n\nThis error is due to your bundler (e.g. webpack) in the local envoriment. You need to tweak the config to make module-style importing (import { buildType } from \"src/utils/buildType\") work. You may need this.\n. From your demo on Codesanbox, why tests are failing seems NOT related to redux-saga. It seems to be related to jest snapshot, however I'm not familiar with jest snapshot.\n\n\nCannot read property 'buildType' of undefined\n\nThis error is due to your bundler (e.g. webpack) in the local envoriment. You need to tweak the config to make module-style importing (import { buildType } from \"src/utils/buildType\") work. You may need this.\n. Yeah, you are right, we need to update our docs and typings for retry.. Yeah, you are right, we need to update our docs and typings for retry.. You can just call response.headers.get(headerName) to retrieve the header that you're interested in.\njavascript\nfunction* saga() {\n  const response = yield call(fetch, someUrl)\n  const header = response.headers.get('Last-Modified')\n  const body = yield call([response, response.json])\n  yield put({\n    type: 'save-body-with-header',\n    header: header,\n    body,\n  })\n}. You can just call response.headers.get(headerName) to retrieve the header that you're interested in.\njavascript\nfunction* saga() {\n  const response = yield call(fetch, someUrl)\n  const header = response.headers.get('Last-Modified')\n  const body = yield call([response, response.json])\n  yield put({\n    type: 'save-body-with-header',\n    header: header,\n    body,\n  })\n}. L446-L494  and L496-L544. Maybe we can remove asEffect, and place the logic in runEffect. So in proc.js it would look like:\njavascript\nfunction runEffect(effect, effectId, currCb) {\n  if(effect[IO] === true) {\n    const { type, payload } = effect\n    if (type === 'TAKE') {\n      runTakeEffect(payload, currCb)\n    } else if (type === 'PUT') {\n      runPutEffect(payload, currCb)\n    } // ......\n  }\n}\nHowever asEffect is exported by redux-saga/utils.  Maybe it is not a good idea to refactor asEffect. How do you think about it?. In .lintstagedrc we've configured that staged files will run through prettier and eslint --fix.\nIf we run prettier only,  it will add semicolons before [ and (.\n\nESlint will complaint about these semicolons, and these semicolons will be removed by eslint --fix.. asEffect seems like a inspection/test utils. (#1260)\nI will continue refactoring runEffect. If we refactor the effect structure, it would be more easier for users to do inspections/tests.. Yes, channel is too vague. How do you think naming this defaultChannel ?  \nstdChannel  is already a function defined in src/internal/channel.js, and I am confused why it is a standard channel.. I think moving env to first is a good idea. I do not have opinions for the order of other arguments. Any order of other arguments is okay to me.\nThough very important, proc() is only called in two other places: one in runForkEffect(), and one in runSaga(). I will move env to first now, and we can refactor the order later on if necessary.. I've add check for onError in runSaga, so it must be a function if pass if (onError) here.. Maybe enhancedRunEffect and env.enhanceRunEffect are better names. I don't like marking things as finalized, since we will change them again someday.. Maybe we can remove EFFECT_TYPES and just use string literals. The boilerplate code seems verbose. How do you think?. How do you think rename effect to makeEffect ?  It is actually a effect creator.. kThrow('runEffect(effect...) invalid effect type: ${type}') could be thought as a fallback runCustomEffect. \nOnce #1479 is merged, I think we may use env.runCustumEffect here, that will allow running user-defined effects.. It's just a matter of flavor. I prefer positional arguments for most cases. And for options, I prefer object/hash.. I think we can turn off no-extra-semi rule in ESLint. Using prettier to remove extra semicolons is enough. \ud83d\ude03 . Connecting to an emitter is more straightforward than before as all the connecting logic is here and we do not need dispatch.. env.dispatch is removed here. So running sagas do all the input/output via a channel.. IMHO, proc() is over complex now that all of the effect runners are implemented in proc. I think we could separate these effect types into three categories and make the whole implementation more clearer.\n\ncore category: fork / join / cancel / cancelled.  These effects implement the redux-saga fork model and need access task / forkQueue / mainTask objects to accomplish their work.\ncommon category: like all and race. They do not access task / forkQueue / mainTask and have less dependencies on saga internals. They could be implemented in a separate file like this PR.\nchannel-related category: including put / take / flush and could be implemented in another file too.\n\nFrom proc's point of view, all effect types except those from the core category could be treated customized, so I pick env.runCustomEffect as the name and use it to run race/all effects.\nAnyway, this is an experimental idea, we can discuss its pros&cons more thoroughly.. Lift the channel to be a connected-channel, so env.dispatch is no longer needed.\nCalling clone() here makes sure that lift does not affect the original channel.. It seems incorrect to do assignment in finally block. cancelled = true will always executes here regardless of the race result.. This is a trade-off between extensibility and complexity. Effect types that redux-saga provides are very sufficient, in my coding practice I could always use built-in effect types to achieve my goals.\nCurrently we are going to release v1, I think we could ignore this pull request first and come back later.. This shows how a customized emitter could be applied.. Only stdChannels have lift / _clone / _connect methods.  These methods are only used by stdChannel to monkey-patch its put and handle the scheduling of external IO.\nMulticast channels or normal channels do not need to do such monkey-patching or scheduling, so they do not have these methods.. I agree this is not obvious that only stdChannel could be passed to liftable.  But liftable is internal (only lift method on stdChannel instance is public), so I think it's just fine.. Sure, I'll add one.. Could you delete these comments?. Agree. There are no react code in packages folder.. No.   But if we don't pass { decoratorsLegacy: true } here,  babel will throw The new decorators proposal is not supported yet. You must pass the\"decoratorsLegacy\":.  This is used to avoid the upcoming break changes.. I've updated to use full package name of @babel/xxx.. Maybe sagaState is a better name over effectRunningContext.    #1263  uses sagaState.. I'm already using the specific checks below if options.channel is defined.. got it.. I think it is enough that we document env should never be mutated.  Custom effects are advanced usages of redux-saga (if we plan to support custom effects), and users must take care of their effect runners.. agree. Yes, the effect runner interface need further discussion and refinement. I'm not sure what's the best interface at the moment.. ok. Yes.   I just copied the old code.. Agree.  Though createAllStyleChildCallbacks is internal only, it makes sense to add such a check.. \ud83d\udc4d . object-rest-spread is still in stage-3, so we need to keep it in the plugin list.\nI'll add loose flag. And just out of curiosity, what's the benefits of this flag? . cancelled or aborted are two mutual-exclusive state for a task. So if we cancel a task (task's state becomes cancelled), all subsequent errors from the task iterator should not bubble to the parent (or else task's state becomes aborted).\nCode for handing error during cancellation is here as follows:\njs\n// function next(arg, isErr)\ntry {\n  // other code\n} catch (error) {\n  if (mainTask._isCancelled) {\n    env.logError(error) // currently, we simply log the error if the task is already cancelled\n  }\n  mainTask._isRunning = false\n  mainTask.cont(error, true) // if `mainTask._isCancelled` true, here `mainTask.cont` is noop\n}. \ud83d\udc4d . excludeFiles is only allowed in overrides sections.\n\nConfiguration Overrides files is required for each override, and may be a string or array of strings. excludeFiles may be optionally provided to exclude files for a given rule, and may also be a string or array of strings.. I think trailingComma: 'all' should be moved to the top level. ESLint starts to complains about some configuration files (e.g. rollup.config.js) after I use prettier to format these files.. We should remove this files after migrating to jest.. This is adapted from the old code... Let me find a screenshot for you.. The Formatter is a universal formatter which is adapted from the old code. And DescriptorFormatter is a special formatter that knows the structure of effect descriptors. So conceptually, DescriptorFormatter is a special kind of Formatter, so I use inheritance.. resetStyle will make subsequent texts use a default style (i.e. black color).  Below is a screenshot when I remove the resetStyle for the call effects.\n\n\n. Oh, I find that we could add a .prettierignore file\n\nTo exclude files from formatting, add entries to a .prettierignore file in the project root or set the --ignore-path CLI option.. path.resolve(__dirname, '../*') points to the packages/ folder. Is that the correct folder? \ud83d\ude15 . Should I rephrase this error message?. My mistake. It should be All effect.. Keys of object are always strings, and Object.keys(obj) returns an array of strings.\n\n. Yes. Keep an map from parent to children would enhance the performance.. isForkEffect is used only in development, so I move it inside the if-block to get better code elimination. \n\nHowever it turns out that even if isForkEffect is placed at top level, the code of isForkEffect would be removed when redux-saga builds. \ud83d\ude05 . From the perspective of the people who uses redux-saga, ROOT is a different and should be kept internal only; From the perspective of saga-monitor, ROOT is of no difference compared to ALL/RACE/CALL.\nIMO, ROOT is a valid effect type, but it does not need to be exported because users never yield a root effect directly. I'll remove it from effectTypes.js.. Actually users can not do import {root} from 'redux-saga/effects' as root is not re-exported in core/src/effects.js.\nI'm a little bit of confused about what to do now... Should we add ROOT as a normal effect like ALL/RACE? Or should we remove ROOT from effectTypes, and keep root as internal? Or do you have any nicer ideas?. How about adding a new method rootSagaStarted on monitor? Then we can call monitor.rootSagaStarted({ effectId, label, saga, args }) to tell the monitor a root saga is started by runSaga or sagaMiddleware.run. And then the concept root is used only in monitor, we can remove ROOT effect and the root effect creator.. ok, then I'll make some changes in another PR. Sure, I'd like to.. How about setting the default value of useESModules to false, or just use const useESModules = output.format !== 'cjs' in createConfig()?  Sometimes it is a little confusing to make a boolean option default to true.. Are we going to drop the support for { context, fn }?  I remember that some users are using this form in some issue.\nrelated issue: #1476. ok, then let's add a comment that the for-loop is intentional. How about moving this statement (closed = true) inside close()?  \nmulticastChannel() and channel() have this statement inside their close() too.. \ud83d\udc4d  returning early makes code clearer. seems reasonable, the CI will check for us. Could we move suspend() and flush() into proc as follows?\njavascript\nexport default function proc(env, iterator, ...otherArgs) {\n  suspend()\n  // other code...\n  flush()\n  return task\n}\nIf we do this, we just need write suspend() and flush() one time. Not sure this idea would work, but tests are passing in my PC.. Further more, if we do like this, we may export a function wrap (or some other better name) from packages/core/src/internal/scheduler.js and use it as a decorator on proc().\njavascript\nexport function wrap(fn) {\n  return (...args) => {\n    try {\n      suspend()\n      return fn(...args)\n    } finally {\n      flush()\n    }\n  }\n}\n. We can replace it with yield Promise.resolve() for faster execution.. if (env.logError){\nI think we need a space between ) and {  \ud83d\ude03 . okay, I'll add an inline comment here.\njavascript\nproc(env, iterator, taskContext, effectId, meta, /* isRoot */ false, cb). You need to return this promise here to let jest handle the promise.. I think the default value is fine. When we do not care the return value, we can omit the returnValue. And the default value (true) is useful when we use delayP in a race:\njavascript\nconst result= race({\n  timeout: call(delayP, 2000),\n  response: call(fetch, url),\n})\n// result.timeout is true if delayP resolves first\nif (result.timeout) { /* ... */ }\nelse { /* ... */ }. The behavior now is the same as in v0.16.1. I think there is a small mistake when separating internal modules. \nhttps://github.com/redux-saga/redux-saga/blob/600802fe2c91be57c6d0c659424b9844739b5379/src/internal/utils.js#L94-L103. Should we mention v0.x here? \ud83d\ude15 \nI think the target readers are who uses v1.0, because other parts of  documentation is reflecting the v1.0 version and does not mention v0.x at all.. let's remove the semicolons here \ud83d\ude03 . We've set semi: false in our prettier config.. Here we could add a link to the testing docs which contains a detailed example of effectMiddlewares.\nWe could add this line: See [this section](/docs/advanced/Testing.md#effectmiddlwares) for a detailed example.. Swap channel.put here so that runPutEffect just need to call channel.put (no need to know the dispatch any more).\ndispatch || channel.put means that we are making the dispatch optional, when uses do not supply a dispatch, users can still use put/take effects with the underlying env.channel for inter-saga communication.\n. I've moved destructuring of runSaga.options up.. here I'm using sagaMiddlewareFactory which will connect to a redux store. When calling runSaga, the dispatch option is from by redux store. Put effects in such cases can still hit reducers.. Let me describe it clearer:\nsagaMiddlewareFactory.options has now 6 fields (namely context, channel, sagaMonitor, logger, onError, effectMiddlewares), and all of them is optional. When connect to a redux store, sagaMiddlewareFactory can get getState and dispatch, and then pass them to runSaga along with the above 6 fields.\nIn cases that users are using sagaMiddlewareFactory, options.dispatch in runSaga is always not null, put effects will always hit reducers.\nrunSaga.options has now 8 fields, 2 fields more than sagaMiddlewareFactory.options, namely dispatch and getState.\nIn cases that users are directly using runSaga, options.dispatch behaves like a put-handler. In the past, users must pass the dispatch option, otherwise calls to the dispatch will throw an exception in runPutEffect. Now, dispatch || channel.put means that we are making the dispatch in runSaga.options optional, when uses do not supply a dispatch, put/take still works, and users can use it for inter-saga communication.. \ud83d\ude15  I think the expected result should be ['a', 'b', 'c', 'd', 'e'], because we are calling actual.push(ac.type) only when ac.type.length === 1.\nIf I change the saga into...\njavascript\nfunction* saga() {\n  yield takeEvery('*', ac => actual.push(ac.type))\n  yield takeEvery(ac => ac.type.length === 1, function*(ac) {\n    yield put({ type: `put_${ac.type}` })\n  })\n}\n..., then the expected result should be ['a', 'put_a', 'b', 'put_b', 'c', 'put_c', 'd', 'put_d', 'e', 'put_e'].. > I've pushed out a change to the test to showcase the problem\n\ud83d\ude15 Looks the expected result is wrong to me. Can you double check that?\n\n\nHaving them separate makes a nice distinction, although might be a little bit confusing.\n\nThe distinction makes sense, through dispatch and channel.put has very similar effect...\n\nHow about look channel: { ...channel, put: wrapSagaDispatch(dispatch || channel.put) } in another perspective:\nThe saga runtime is a little stupid, so the saga can only do it's input/output via a channel. When the saga runtime sees a put/take effect, it just calls channel.put/channel.take to run the effect. When the user yields a put/take effect without a channel, such as yield take('FOO') or yield put({ type: 'BAR' }), the saga runtime would use env.channel as the default channel.\nBut what if what we want to do is more than inter-saga communication? For example, every time we dispatch an action to redux store, we would like the action to go through the channel as well.  This line of code (channel: { ...channel, put: ... }) is the solution: we setup a very special channel at env.channel. When env.channel.put is called, the action will be handled by dispatch magically, and when action gets dispatched, the action will go back to channel eventually. In the meantime, the saga runtime only sees a normal channel with a specific interface (put / take), so the saga runtime just do as it used to do.\nThe idea is that, by swapping the channel.put, we move our logic into the channel and keep the saga runtime simple. We have swapped channel.put in stdChannel(), so I think it's okay to swap channel.put when setup env.channel.. Actually this promise will resolves to undefined, so the catch-callback does not run and the test passes.\nIf you change this to ...\njavascript\nconst promise = middleware.run(worker).toPromise()\nreturn expect(promise).rejects.toBe(expectedError)\n... then the test will fail.. This should not be removed, or else the error will be swallowed...\nIf you log mainTask.cont in this if-statement, it will print as noop, so the error object will be sent to noop.\nJFYI, mainTask.cont is set to noop by forkQueue when we cancel the task.. We do not need these if-else anymore, the branch logic is in this single statement: const effectRunner = effectRunnerMap[effect.type].. I think it is just fine. You can think of cb as required (every effect runner will use it), and think of the arguments after cb as optional (only a few runners will use them), and required argument comes before optional arguments.. We may refine the order if we have better alternatives \ud83d\ude04 .. I'm okay with both names. It seems that our convention is cont for task/mainTask, and cb for the rest  (runXXXEffect, digestEffect, etc.).. The interface of newTask() is very much like proc().\nproc(env, iterator, parentContext, parentEffectId, meta, isRoot, cont). what about effectRunner(env, task, effect.payload, currCb, digestEffect)? \ud83e\udd14 \nThe first argument is constant during the whole saga execution.\nThe second argument is constant during the executing of the task.\nThe third argument changes every time we yield a new effect.\nThe fourth is the callback, and the last is an argument we rarely use.. The problem is that \"Tasks can be Cancelled but still Running\", so it is impossible that we just use a variable \ud83d\ude1e \nFYI, line 155, 156:\nhttps://github.com/redux-saga/redux-saga/blob/a619f15cf46ea463528af86c18fb346e9f275985/packages/core/src/internal/proc.js#L153-L166\n. ~~Technically we can implement digestEffect as a method on Task object. But it is not a good idea to me.  digestEffect is about to consume an effect from the iterator, but a Task object should not be aware of the iterator (Task only knows that there is a forkQueue which consists of a mainTask and forked children).~~\n~~Maybe we can make the digestEffect a method on the mainTask. I'm thinking that extracting the code of mainTask into a new separated. And it could resolve the concern you posted below too.~~\n~~This is just a rough idea, I'll have a try in other PRs.~~\nTried with mainTask.digestEffect, but it was unfortunate.  And I see that we are already accessing the task object in digestEffect (setting task.crashedEffect when task aborts), so it may be viable that we make digestEffect as a method on Task object.. Yes... a little weird.  I refactored mainTask in 586c375c70a65e483861c35198c3249124737c6b, how do you think about it?. A task is running and cancelled when the task is performing the cleanup logic (code in the finally block).. Even though there's no async cleanups, a cancelled task can still yield put/select/cancelled effects in their finally block, I'm not sure whether it is okay we can just transit the status from running to cancelled, especially when the put effects in cleanup code maybe delayed due to saga scheduling. \nI'm not saying it is impossible, I just mean that I'm not sure about it. Using a single status variable is attractive, but I think I need more thought on it .. At present, If we call toPromise() before a task is cancelled, the promise will be resolved with TASK_CANCEL when the task is cancelled.    We need to edit the code at end() too.. Oh, I forgot that the task can be accessed by the users, adding too much fields/methods to the task is a bad idea.. To resolve with TASK_CANCEL is okay for me.  Because when we join a task inside a try-block, the code would not jump into the catch-block if the task is cancelled, while an error would let the iterator jump to catch-block.. This seems a little awkward now, isCancelled means the status is CANCELLING or CANCELLED. \nIf we merge the two enumeration values, it will become isCancelled: () => status === CANCELLED,.. There is a check which relies CANCELLING status...   At the moment, I start to think that  having both CANCELLING and CANCELLED is verbose.. I removed the CANCELLING status.. I removed this because we cannot tell whether the iterator is running or not here. When mainTask.status is CANCELLED, the iterator can be either finished or still executing the finally-block.. Seems that this statement is unnecessary, see https://github.com/redux-saga/redux-saga/pull/1704#issuecomment-446208451. Yeah, I have thought there may be some similar cases that task.end(TASK_CANCEL) is called without calling task.cancel(),  but I failed to write a test case to prove the idea. It will be best you can add tests. \ud83d\ude04 . This is expected to be false. Cancellation won't bubble from child to parent.  Uncaught errors bubbles from child to parent, and cancellation propagates from parent to children.. Should we change configureStore.dev.js as well?. Parameters is implemented in Microsoft/TypeScript#26243 and added in TS 3.1, but it is not listed in the doc.. If the promise resolves to be undefined, then next time next is called with the resolved value, the default argument result is used.. String(Object.create(null)) will throw an exception. So we could avoid stringifying args[0] here.. ",
    "adrispo": "Hi! I have one solution, maybe is not the best, but it works:\nIn your saga function\njavascript\nlet sql = 'YOUR_SQL'\n const sqlResults = yield call(() => executeSQL(sql));\nIn your saga, you can create a function like:\njavascript\nfunction executeSQL(sql) {\n    return new Promise((resolve) => {\n        SqliteHelper._db.transaction((tx) => {\n            tx.executeSql(sql, [], (results) => {\n                    resolve({\n                        results\n                    })\n                },\n                (error) => {\n                    resolve({\n                        error\n                    })\n                });\n        });\n    });\n}\n. ",
    "baldwmic": "Looks like we just need to disable the background property for token.operator selector\n.\nLooks like the CSS is coming from Prism.\n@Andarist it seems we need to also include the dark-theme css, as there is an override here that seems to fix the issue.. @Andarist yes i can do it, but can you point me to where this css is being added? i don't see it in the docs folder. good catch @juangl !\nanyways, there is better (in my opinion) tooling for redux with https://github.com/zalmoxisus/redux-devtools-extension.\ndo you think this is still an issue @juangl ?. @bradennapier it is definitely annoying. i started a pr here: redux-saga/redux-saga/pull/945\nunfortunately, i am not working on this at the moment. would you like to pick up where i left off?. @cellog and @lourd, these examples are definitely helpful! are either of you interested in submitting a pr so that these don't get buried in this issue?. @henrikra when it comes to testing sagas, many people appear to be using a black-box testing approach to assert things happening.\nyou may consider looking at https://github.com/jimbol/generator-test-runner as an example of how to test sagas in a more developer friendly fashion. @Andarist would you like a PR for these in the README ?. @Andarist here's a start: https://github.com/baldwmic/redux-saga/tree/whoUsesReduxSaga\nDo we have any design ideas? Ideally, it'd be nice to have logos all be the same width/height dimensions. @wub I'm not currently working on #944 right now, but you can add yourself there. Should be pretty simple . https://dns.js.org/. I'm seeing this problem on another machine of mine, but it appears to be a problem with node: https://github.com/nodejs/node/issues/9377\nhttps://github.com/GitbookIO/gitbook/issues/1774. @Andarist I rebased my fork to be up to date with latest fix and it worked! All good on my end :). @BingxingXu when it comes to using an eventChannel, i'm using a pattern like so:\n```\nconst createChannel = (externalEventSource) =>\n  eventChannel(emitter) => {\n    externalEventSource.eventHandler = (event) => {\n      emitter({ event });\n    });\n    return () => {\n      // cleanup\n    });\n  });\nexport function* subscribeChannel() {\n  const externalEventSource = new ExternalEventSource(options);\n  const channel = yield call(createChannel, externalEventSource);\n  while (true) {\n    const event = yield take(channel);\n    // do something with event\n  }\n}\n``\nwhereExternalEventSourceis some instance that has event handlers that we can listen on and then emit events to oursubscribeChannel` saga. Good examples of this are WebSocket or Notification, but you can surely use EventSource too.. looking at your provided code @BingxingXu , and using the above paradigm, something like this might work:\n``` \nexport function subSSE(eventSrc) {\n  const subs = emitter => {\n     eventSrc.onmessage = (msg) => {\n       emitter(msg);\n     };\n     eventSrc.onerror = () => {\n       emitter(END);\n     };\n    return () => {\n      eventSrc.close();\n    }\n  };\n  return eventChannel(subs);\n}\nexport function* sseSagas() {\n  ...\n  const eventSrc = new EventSource(url);\n  const chan = yield call(subSSE, eventSrc);\n  while (true) {\n    const msg = yield take(chan);\n    console.log(msg);\n  }\n}\n```\nyou may have already solved this, as you seemed to be onto the solution. the key thing is to pass in an already instantiated instance of the EventSource class to the event channel creator (subSSE). Then, inside of the eventChannel, you can attach functions to event handlers (like onmessage, which will emit some event to the subscriber saga (sseSagas). It's at this point that the take sees an event emitted and should log it.. I would like to provide a PR for this, though I may need some coaching since it will be my first \ud83d\ude04 . Awesome, I will submit a PR by the end of the day! Thanks for walking me through the approach.. I added 2 tests:\n- one to test that unsubscribe function gets called when channel is closed\n- another test to check that unsubscribe function gets called when END event is emitted\nHowever, I'm having a problem with this test.\nTypeError: unsubscribe is not a function\nI think it's because this code is when the function is defined, and it gets called here which is before the function is defined.\nLooking at the code, the subscribe function returns the unsubscribe function. And the unsubscribe function calls the close function, which tries to call the unsubscribe function. This doesn't seem possible as far as I understand about JavaScript. Perhaps we need to revamp this.. I tried the suggestion and changed this line to setTimeout(() => emitter(END), 0);, which meant the unsubscribe function was defined by that time. But this means the test itself needs to be wrapped in a setTimeout. Is that ok?. Ok @Andarist I've made the suggested changes. I even added a test case here for the eventChannel defined in the docs here.\nThe one odd part is that I'm using a setTimeout in the test since the eventChannel uses a setInterval. Is there a better way to do this in mocha?. @Andarist i still need to finish updating the tests according to your last review. i expect to finish by the end of today. thank you for all the help in explaining things! \ud83d\ude04 . @budarin if you're using XMLHttpRequest, you could use an eventChannel and abort the XHR from there if the large file upload is taking too long.\nLike @Andarist said though, it really depends on how you are implementing the file upload. If you are not using Fetch or XMLHttpRequest, can you explain what you mean by a \"real\" HTTP request? After all, any implementation of the protocol HTTP will send a request. I'm translating what @Andarist wrote in words into code. What do you think @PriyankBhatt ?\n```\n...\n// in eventchannel subscriber\nsocket.on('reconnection', () => {\n  emit({ type: 'reconnection' });\n})\n...\n...\n// in channel consumer\nconst channel = yield call(subscribe, socket);\nwhile (true) {\n  const event = yield take(channel);\n  if (event.type === 'reconnection') {\n    const latestUnreadMessage = yield select(getLatestUnreadMessage);\n    // do something\n  }\n}\n...\n```\nin interest of code brevity, i've left out some of the function definitions, but I think the gist is there. @ksjun is the runSaga enough to run sagas outside of Redux for your app? did you have something else in mind?. looking at the root saga, i haven't seen this syntax before:\nexport default function * StarterSagas() {\n    yield [\n        takeLatest(BreadcrumbActions.ADD_BREADCRUMB, switchView),\n        // Question: what other code is here? another \"takeLatest\"?\n    ]] // Question: why is there a second closing bracket here with no matching one above?\n}\n@forgo why are you yielding to an array of helpers? Based off the docs, I've really only seen the syntax: yield takeLatest(ADD_BREADCRUMB, switchView) and so I'm wondering if that could be an issue.\nBut as said before, it's difficult to know exactly where things could be going wrong without sharing the code on something like webpackbin.. Taking a simple example from the docs:\n```\nfunction* watchFetchProducts() {\n  yield takeEvery('PRODUCTS_REQUESTED', fetchProducts)\n}\nfunction* fetchProducts() {\n  const products = yield Api.fetch('/products')\n  console.log(products)\n}\n```\n@richierob62 are you asking how you can easily test whether the fetchProducts generator was called when the PRODUCTS_REQUESTED action is dispatched?\nIf so, you can spy on the fetchProducts generator using sinonjs and then test that when PRODUCTS_REQUESTED action is dispatched, the spied saga gets called. something like:\nvar spy = sinon.spy(fetchProducts);\nstore.dispatch({ type: 'PRODUCTS_REQUESTED' });\nassert(spy.called)\n@eirslett do you have an example in code of how you would test the above example? curious to see how you would approach it.\n. thanks @eirslett, it's helpful to see in code how others are doing things.\nyes, i agree that using sinon to test things can get tricky; the idea is very neat, but the implementation gets hairy.\nyour approach reminds me of how my colleague is looking at testing sagas: https://github.com/jimbol/generator-test-runner. that tool makes testing feel more declarative, but under the hood it's really doing something very similar to what you have.\nand as to white-box vs black-box tests, i know there's a big discussion here #518 ;). From the API docs, takeLatest Spawns a saga on each action dispatched to the Store that matches pattern. And automatically cancels any previous saga task started previous if it's still running.\nThe key thing to understand is that each time you dispatch the CREATE_PRODUCT action, your createProduct saga will be run. The only exception to this is if you dispatch a second CREATE_PRODUCT action before the first saga task is completed. However, since your createProduct saga is only logging to the console, it will probably finish very quickly. Meaning, if I understand correctly, that your CREATE_PRODUCT action is dispatched each time your React route changes.\nSo, just to clarify, it sounds like you are entering the route for your React container that dispatches CREATE_PRODUCT, and then the first createProduct saga task is run and completes. Then you go to another route, and then come back to the same route that dispatches CREATE_PRODUCT again, which causes a second new createProduct saga task to run and complete. If this is the case, then this is not a bug, but expected behavior. @christopherdiehl can you confirm that this is what is happening?. @christopherdiehl it would be most helpful if you could post a webpackbin of your problem in order to be able to debug what exactly is going on. could you do that?. Are you trying it now?\n\nI missed a final step here. Going to submit a PR to them, assuming so DNS will work.\n. @Andarist must be because we merged in #920 before js-org approved us! That was my mistake for not catching that final step \ud83d\ude2d .  @Andarist should we add back the CNAME since the redux-saga.js.org subdomain has been added?. it's working! \ud83c\udf88 \n@Andarist we should update the website link for the repo\ncurrently it's this: https://redux-saga.github.io/redux-saga/\nshould go to this: https://redux-saga.js.org/\nit re-directs right now, but just to make the complete switch\n. @dispix this looks very well thought out and it's awesome you shared with the rest of us! I haven't worked on Oauth2 personally, but as I understand, there are plenty of pitfalls to avoid so I'm sure this will be useful to others.\nOne musing, have you wondered whether something like this might make a good middleware that others using redux and redux-saga could install and use without needing to re-implement the difficult aspects of Oauth2 you already solved?. @kfrajtak can you post a webpackbin of your code? it's difficult to debug (at least for me) without knowing what else could be going on. Awesome work, thank you @trevorharwell ! \ud83d\ude04 . @adamgajzlerowicz it seems like your selector is looking for an object property that doesn't exist in the test state object, hence why the log prints undefined.\nChanging your selector to return the following should work\nreturn state.foo\nCalling next on a generator returns an object with two properties, value, and done which is why your test uses .value. @mskims that would be amazing! I'm sure other Korean speakers would be most grateful to you if you did. I'm not on the redux-saga team, but I'm sure @Andarist would approve as there's already some other translations. gonna close this since i'm not actively working on it. anyone is free to pick this up. closing in favor of #1054 . @juliocanares https://redux-saga.js.org/docs/introduction/SagaBackground.html. Awesome, looks similar to what @gajus and @bradennapier were thinking!\nThoughts @Andarist ?. - [x] change name to unsubscribed. - [x] split up tests. - [x] simplify asynchronous test. i can't get this test to pass without using setTimeout, any thoughts @Andarist ?. ahh, so we typically unsubscribe before closing the channel. thank you for the fix @Andarist \ud83d\udc4d . yeah, that makes sense to me. i think generally the argument for doing this would be you want to unsubscribe and allow the developer to clean up everything before officially closing the channel.. ",
    "michalczaplinski": "Yes you are right, the generator takes the action as the parameter, of course. That was just a copy-paste mistake and not part of the issue I have, however.\n\nIf you fire several DELETE_BOOKMARK in succession, won't a single DELETE_BOOKMARK_ERROR cancel all your races?\n\nNo, the DELETE_BOOKMARK_ERROR as well as CANCEL_DELETE_BOOKMARK (which is what I trigger from the UI) should both only cancel the race in one of the forked tasks. That is what I intended and how I understood takeEvery to work at least... \ud83d\ude15\n. Okay, I see. Could you explain \n\nAll your concurrent races are blocked on a take effect that will \"win\" on a DELETE_BOOKMARK_ERROR action\n\nin a bit more detail? It's not clear to me why all of the races are blocked. I was under the impression that in my example every DELETE_BOOKMARK action forks a new task (thanks to takeEvery) and then inside the deleteBookmark task there is a race, so that would mean there is a race for each forked task. Could you show an example that would explain this better for me?\nAlso, the DELETE_BOOKMARK_ERROR action is not the issue, because it is not triggered in the example I have. I mean, if I remove the catch clause in performDelete and remove types.DELETE_BOOKMARK_ERROR from the take call in deleteBookmark, I am left with the same error...\nDo you see what I mean?\n. That makes sense! Thanks a lot! I somehow had a completely wrong mental model and just assumed that each task only listens on actions that affect it. Only my 2nd day using the library, though :) \nPerhaps this could be made more clear in the docs.\n. ",
    "mpolci": "I made an error\n. ",
    "elitan": "So, right now there is no working version of redux saga?\n. @Andarist sounds very good. Finally I can start learning and using redux saga. Thank you so much.\n. (1) is ran on a specific react component constructor.\n(2) is runs every time document_actions.myDocumentsLoad() runs. document_actions.myDocumentsLoad() dispatches an action, which (2) has a takeEvery-watcher on.\nDoes this clear things up?\n. This works and looks alright.\nDoes actionChannel comes with any side effects after yield take(chan);? \nLike, do I need to delete the actionChannel (the chan variable) or something?\n. Ok, perfect. Thanks @Andarist! This answered my questions regarding this issue.\n. @neurosnap I am not sure what you mean. Could you maybe explain with an example?\n. I want to have the whole 'LOAD_DOCUMENTS' in a single function scope. I dont want to break out the fetches in different functions.\n. ",
    "yeerkkiller1": "That's true, sorry about that. Fixed with https://github.com/yelouafi/redux-saga/pull/512\n. ",
    "ronaldheft": "Thanks for confirming I'm not crazy, @jrvidal! The more I think about it, this makes complete sense. I was operating under an assumption that React's render would be async, but from what I've seen, yeah, that's not always the case.\n. ",
    "julienR2": "Thanks a lot for these information !\nIt is still quite new for me so I was surprise to discover these two ways of achieving this pattern.\nNo doubt in the power of sagas in handling more complex behaviors. But performances speaking I would have think the sagas would be greedier than a middleware.. Or not ? \nThanks again for theses details !\n. ",
    "bstro": "@yelouafi Did this get removed? I don't see any mention of createMockTask anywhere currently.\n. thanks!!!\n. @yelouafi Looks great. A little hard for me at first to understand the function signatures as written, particularly the meaning of execBuiltin and cb, hopefully they'd get some more descriptive names or at least adequate documentation (which given what I've seen from redux-saga so far, I'm definitely not worried. A+ docs :) )\n. Thanks for the reply @Andarist; for my use case, I just need to know if the channel is empty, but not actually empty it.\n. Perfect. Thanks!!\n. I'm also running into this. I've had to use take with while (true) loops instead of takeEvery/takeLatest to get around it. This isn't a long-term solution but it gets me moving for now.. needs more commas and a general pass on readability :). How about:\nThis approach involves mocking a Store, creating Spies, and focuses more on the effects of the Saga instead of its internals. - also note that you don't want the apostrophe for its :). valuable vs valueable. ",
    "kopax": "@yelouafi , Where did the doc go ?\n@countoren , would you mind sharing your work ?. @henrikra \njavascript\nimport { createMockTask } from 'redux-saga/lib/utils';\n// then later in your tests\n  it('should take LOCATION_CHANGE', () => {\n    const watcher = createMockTask();\n    const takeDescriptor = twitterFeedDataSaga.next(watcher).value;\n    expect(takeDescriptor).toEqual(take(LOCATION_CHANGE));\n  });. @Andarist if you still need a gist example after the example of @yelouafi I will create one.\n@yelouafi thanks for the temporary workaround, se we just disable the error and keep this open until we have more information ?. ",
    "henrikra": "I really want this function to be documented too :/. I have made PR on this https://github.com/yelouafi/redux-saga/pull/681 If someone can check it I would appreciate that :). @cellog Please make Pr about it :) And correct if I have other mistakes. The other logic does not matter. Endless loop is normal in generators. Just try any of your own sagas to move the yield take inside of while loop's condition and the tests won't work after that :D That is how you can reproduce it. @yelouafi This is the right answer and it makes perfect sense! So basically people should always put the take effect inside of while loop and NOT to it's condition. Because this will make testing easier. Do you guys agree? :D. Okay so what is your suggestion? :). Looks like I am going to use something else than redux-saga because it doesn't work with TS :/. ",
    "cellog": "the import is not documented:\njavascript\nimport { createMockTask } from 'redux-saga/lib/utils';. Pr is unnecessary. Just copy and paste the 1 line import statement into the code example in the docs for task cancelation. (sorry about multiple edits, I haven't done markdown in a while, couldn't get the code to look like code at first)\n. I'm working on an entire suite of redux-saga test helpers. I think that this will be more useful than the raw docs. Haven't massaged it into anything usable yet but I have a project waiting in the wings at https://github.com/cellog/redux-saga-test-helpers. The problem was isolated to PEBKAC\n~~one problem with this approach: the saga monitor does not return every effect as passed in.  If you yield call() a regular function, it just returns the result of calling the function, and not the effect itself.  This is inconsistent.  If you yield call() another saga, the call() effect is passed to the monitor.  This means trying to match something like yield call(delay, 1500) does not work.~~. got it working!\ntest helper code:\n```javascript\nimport createSagaMiddleware, { runSaga } from 'redux-saga'\nimport * as effects from 'redux-saga/effects'\nimport * as utils from 'redux-saga/utils'\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nexport const tests = Object.keys(utils.asEffect).reduce((effects, name) => ({\n  ...effects,\n  [name]: effect => utils.is.notUndef(utils.asEffectname)\n}), {\n  isPromise: effect => utils.is.promise(effect),\n  isHelper: effect => utils.is.helper(effect),\n  isIterator: effect => utils.is.iterator(effect),\n  takeEvery: effect => utils.is.helper(effect),\n  takeLatest: effect => utils.is.helper(effect),\n  throttle: effect => utils.is.helper(effect),\n  takem: effect => utils.is.notUndef(utils.asEffect.take(effect)) && effect.TAKE.maybe,\n  apply: () => false,\n  spawn: effect => utils.is.notUndef(utils.asEffect.fork(effect)) && effect.FORK.detached,\n})\nfunction sagaStore(state, reducers = { routing: reducer, week: fakeWeekReducer }) {\n  const log = []\n  const logger = store => next => action => { // eslint-disable-line\n    log.push(action)\n    return next(action)\n  }\n  const monitor = {\n  }\n  const sagaMiddleware = createSagaMiddleware({ sagaMonitor: monitor })\nconst store = createStore(combineReducers(reducers),\n    state, applyMiddleware(logger, sagaMiddleware))\n  return {\n    log, // this is used in the rendering tests, not relevant for testing sagas\n    store,\n    sagaMiddleware,\n    monitor,\n  }\n}\nexport const effectNames =\n  Object.keys(utils.asEffect).reduce((effects, name) => ({\n    ...effects,\n    [name]: name,\n  }), {\n    isPromise: 'promise',\n    isHelper: 'helper',\n    isIterator: 'iterator',\n    takeEvery: 'takeEvery',\n    takeLatest: 'takeLatest',\n    throttle: 'throttle',\n    takem: 'takem',\n    apply: 'apply',\n    spawn: 'spawn',\n  })\nexport const effectName = effect =>\n  effectNames[Object.keys(tests).map(test => teststest && test).filter(t => t)[0]]\nexport const toEffectAction = effect => ({\n  type: effectName(effect),\n  effect\n})\nexport const START = { type: '###@@@start' }\nexport function testSaga(state = undefined) {\n  const { sagaMiddleware, store, monitor } = sagaStore(state)\n  return (sagas, test) => {\n    sagaMiddleware.run(function*() {\n      yield effects.take('###@@@start')\n      yield sagas.map(args => effects.fork(...args))\n    })\n    runSaga(test(), {\n      subscribe: (callback) => {\n        monitor.effectTriggered = ({ effect }) => {\n          if (effect.length) {\n            effect.forEach((e) => {\n              callback(toEffectAction(e))\n            })\n          } else {\n            callback(toEffectAction(effect))\n          }\n        }\n        return () => null\n      },\n      dispatch: (output) => {\n        store.dispatch(output)\n      }\n    })\n  }\n}\n```\nto use in a test:\n```javascript\nimport * as effects from 'redux-saga/effects'\nimport { delay } from 'redux-saga'\nimport * as helpers from '../test_helper'\ndescribe('react-redux-saga-router integration tests: url changes', () => {\nfunction another() {\n    return 'hi'\n  }\nfunction *foo(d) {\n    while (true) {\n      yield effects.take('hi')\n      yield delay(d)\n      yield effects.call(another)\n      yield effects.put({ type: 'there', payload: 'wheee' })\n    }\n  }\nconst run = helpers.testSaga()\n  it('proof of concept', (done) => {\n    run([\n      [foo, 1500]\n    ], // external sagas we are testing, saga followed by arguments, if any\n    function *() { // the actual test\n      yield effects.put.resolve(helpers.START) // start the external sagas\n      yield effects.put({ type: 'hi', payload: 'there' }) // inject actions into the saga we're testing\n      let input = yield effects.take('take')\n  expect(input.effect).eqls(effects.take('hi'))\n\n  // yield effects.take('promise') // unnecessary, but can be in here if we want\n  input = yield effects.take('call')\n  expect(input.effect).eqls(effects.call(another))\n\n  input = yield effects.take('put')\n  expect(input.effect).eqls(effects.put({ type: 'there', payload: 'wheee' }))\n\n  yield effects.call(done)\n})\n\n})\n})\n```\nBasically the way it works is you tell the test helper which sagas to load, and pass any parameters in, which allows mocking things if necessary. The sagas are not run until you yield the START action. You can inject any redux action using put into the running sagas.  Then, to test the order of the effects, you use take with the name of the effect.  The yielded effect is packaged in a redux action with type equal to the effect name.  Since our test runs in its own context, there is zero chance of conflicting with the running sagas action types.\nThis took a LOT of work to figure out.  I erased and rewrote my code from scratch 3 times to get to here.\nAny feedback on improving this is appreciated.. ",
    "tengis": "@Andarist Thanks. That's exactly what was happened. \nSo i made some research found this solution https://github.com/mxstbr/react-boilerplate/pull/390\n. ",
    "ci5er": "@pke - it is the default key on redux-devtools. I'm not sure why, because both on Chrome and FF, Ctrl-W is not caught and closes the tab or, if last tab, the entire browser application. Also, Ctrl-H opens the browser history panel, unless the devtool panel has the focus. I'm not sure what the sense was in either choice, but it is the default...\n. Thanks. There's too much going on at the bottom of the file you changed for me to follow before I go find some coffee, but I can confirm that npm start in the real-world folder, with your change to webpack.config.js, works on the Ubuntu/FF|Chrome setup described top-of-thread..\n. ",
    "juangl": "@baldwmic It's closed.\ud83d\udc4d\ud83c\udffb. ",
    "paldepind": "Thanks for the great replies :smile:\n@slorber \n\nI've often compared redux-saga to an hybrid between imperative programming and free monad.\nThe flow of redux-saga, often using while looks and sequential operations look like imperative programming, but the effects you can yield that are run against an interpreter look like the free monad. The difference between IO and Free is that with Free being that Free uses data structures and can be tested / transformed / interpreted while IO is more like a thunk that can only be run.\nSee also: http://stackoverflow.com/a/34623840/82609\n\nI have seen that you've mentioned the Free monad in other threads. It's very interesting. I have been reading a bit about the Free monad. I don't really understand it yet but I partly understand the similarity with redux-saga. In Haskell a function with the type Integer -> IO (String) conceptually returns a description of an action that produces a String when executed. In this sense it is very similar to redux-saga. But as you mention, the difference is that IO is completely opaque unlike saga actions that can be inspected and tested. If I understand correctly then Free accounts for this since it can be used to build up transparent AST structures that can be interpreted in several ways. But in the special case where the AST is simply executed it is similar to the IO monad. That is my current understanding. Please correct me if I'm wrong.\n@yelouafi \n\nBut I'm not sure the IO monad models the effect as data concept (can be unit tested?). IO Seems like an opaque data type (although I don't know how IO is tested in Haskell).\n\nYou are indeed right that IO is opaque, but conceptually it's just data. I guess the reason for the opaqueness is so that it allows for IO-code to be compiled into efficient machine code where the IO construct doesn't exist at run-time.\nTesting IO code in Haskell is much like testing imperative JavaScript code: hard and messy :sob: It certainly doesn't have the advantages that redux-saga has.\n\nAnother thing is related to concurrency, In redux-saga you can fork tasks in parallel, join and cancel them. Monads by nature are sequential. I think Haskell has a forkIO function but not sure how much control it gives over concurrency.\n\nMonads are indeed sequential. But each line in a saga is also executed sequentially isn't it? Line number 2 in a saga is never run before line number 1? It seems to me like it matches monads. I actually think the asynchronous features in redux-saga are covered by concurrency in the IO monad. fork in saga is like forkIO, call in saga is like a blocking IO action, cancel in saga is like killThread.\n\nGenerators have one limitation though: they can't be started from an arbitrary point, this can cause weird problems when the monad calls the chain function multiple times (eg: Array monad), especially when chained blocks have visible side effects. Do Fantasy has a special multi mode to handle this.\n\nYes. That is a quite sad restriction. Especially because it breaks the abstraction in Fantasy Do. You can't use the same do-notation with all monads. To solve this and other issues I'm working on a fantasy land replacement, jabz. I'm planning to specify it so that each monad must declare if it is multi or not. Then do-notation can be implemented so that it works for all monads and without the awkwardness in Fantasy Do.\n. ",
    "danny-andrews-snap": "I've always gotten around the difficulty in testing IO code by using the Reader Monad. It's essentially the IO Monad that lets you pass config through your application. I use this as a lightweight dependency injection framework which allows me to pass a spy in my tests in place of the actual method (e.g. console.log) and make assertions on how it is called (e.g. it was called twice).\nExamples can be found here: https://github.com/danny-andrews/circleci-weigh-in/tree/master/src/effects/tests.\np.s. I believe QuickCheck is the goto way to test IO-using Haskell programs, although I have absolutely no idea how it works. \ud83d\ude1c. ",
    "thieu75": "Hi !\nI would appreciate to see part of your code on this topic in order to help me to ease the learning curve :). Hi !\nI would appreciate to see part of your code on this topic in order to help me to ease the learning curve :). ",
    "marsonmao": "@davidwparker I kinda not understand why Andarist said that this Promise will resolve just once, and what 's the difference between your final solution and aikoven's?\nIt looks that connectionStatusChange is executed 1 time, so that connectionRef.on('value', connectionStatus); is executed 1 time, then there would be either channel.put(actions.connected()); or channel.put(actions.disconnected()); executed 1 time, so finally yield put(action); in the while loop dispatches one of em?\nI think I am wrong, but I dont understand why. Hope that you could explain it!\n. I see...thanks for the instant reply!. Wait a minute, I think I have to ask for more detail, what is result in .then(result => saga.next(result)) in my case? Looks like it is position, but I don't understand why. Maybe this is beyond the scope of redux-saga and it's a javascript question.... Thanks for answering js question as well!\nYour new version of pos => resolve(pos) is totally easy to understand, I can get it now.\nSo it seems that getCurrentPosition(resolve) is equivalent to getCurrentPosition(pos => resolve(pos) but I'm still having some difficulties to understand it. \nIf you could explain this final mystery to me then I'll be all good!. Thanks Andarist.\nSo, when getCurrenPosition is completed, it executes something like successCb(pos), and the sucessCb directly maps to resolve or the anonymous just in place function; then, they result in executing resolve(pos) or (pos) => resolve(pos) (so the 2nd version has redundancy). Is the above correct?\n. Yaaaaaay!! I got it!! Thank you Andarist!. Hey Andarist thanks for the reply (again!)\nSo that it looks like the whole structure of an event channel watcher is fairly fixed; One has to 1. hand write the infinite while loop or provide a block effect like join to make try block work, then 2. provide the corresponding finally block to close the channel.\nIf the above assumptions are correct, then what do you think about writing a wrapper/creator function that assemble these things together? Like a setupSocket function that accepts a created channel, the body inside try block and the body inside finally block so that people won't bother with hand write the fixed structure, also won't make any mistake? Oh and I mean this wrapper will be written in my project, I don't think this should go into redux-saga.\nOr, option 2, any chance the design of channel could get some modification? The goal is to make writing channel codes more easily (or more free), e.g. people could choose to use while (true) or takeEvery without the burden to make the try block blocking. I'm not sure if this is possible, but I think if it's possible and reasonable, this could go into redux-saga.. @Andarist The answer is clear and reasonable, thanks! If there are any more ideas popping out of my head I would come back ;). ",
    "weishijun14": "Hi, I got some question about yield ..\n```\n*queryAppid({ payload },{ put, call }){\n     wx.ready(function(){\n        wx.getLocation({\n          type: 'wgs84', \n          success: function (res) {\n            let latitude = res.latitude; \n            let longitude = res.longitude; \n            let speed = res.speed; \n            let accuracy = res.accuracy; \n       //when get latitude and  longitude  then getLocation.\n\n        var myGeo = new BMap.Geocoder();\n        myGeo.getLocation(new BMap.Point(longitude, latitude), function(result){\n          if (result){\n            //when I get result ,I want to dispatch an Action \n            yield put({ type: 'someAction' , payload: { location: result.address} })\n          }\n        });\n      }\n    });\n\n}\n```\nWhen wx is ready then getLocation if success then callback ,I want use yield put in it, but I dont know how to do with it, can someone help me ~ appreciate !!. ",
    "darkalor": "\nwell, sagas are not for intercepting actions, just to handle side effects of them\n\nRight, however the state could influence the way that the side effect is processed (e.g condition based on select), and we're always going to hit the store after the reducer was executed.\nI've thought about doing multiple actions, as in your example, but this is not really viable if there's a lot of actions and only some of them can have additional \"before\" logic. I.e. this would kind of make your reducers aware of the additional processing in sagas, since some actions would have to be handled by original names, and some - by the new names.\n. ",
    "rpmonteiro": "Solved it by having the function containing the fetch be a non-generator function.\n\nWhy that is? Beats me...\nCan someone chime in as to why it doesn't work if you return a fetch inside a generator?\n. Thank you @slorber and @Andarist !! Great explanations there!\nHave a nice day both of you \ud83d\ude04 \n. @3LOK Patiently awaiting to hear back from you. I'm not pleased with the current way I have to test my sagas... :(\n. Haha looks so simple once you know it!\nThanks @Andarist !!\n. @Andarist what if the yield put is called with a TON of arguments? How do you test without passing all those args?\nnext = gen.next()\nexpect(next.value).toEqual(put(itemDeleteSuccess({\n  superComplexObject: {\n    thatNeverEnds: {...}\n  }\n})))\nIs my only option then to test like I did on the second screenshot? By going deep into the saga object and grabbing the type?\n. ",
    "tomrj": "I'm not sure this is the case. The value returned by selectFeatures is returning a copy of ImmutableJS Seq converted to a native array with toJS. Also, selectFeatures cannot return 'MORE' in any circumstance. The behaviour is somewhat surprising, unless you consider the generated code (Babel's take below), where the reference of features is declared outside the generator body.\nI haven't yet dug into how sagas step the generators here, but if there is a programming error on my part here, I cannot still determine what it is.\n```\nfunction startSomething() {\n  var features, needMore;\n  return regeneratorRuntime.wrap(function startSomething$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return select(selectFeatures);\n    case 2:\n      features = _context.sent;\n      _context.next = 5;\n      return select(selectAdditional);\n\n    case 5:\n      needMore = _context.sent;\n\n      if (!(needMore || features.length > 0)) {\n        _context.next = 10;\n        break;\n      }\n\n      if (needMore) {\n        features.push('MORE');\n      }\n      _context.next = 10;\n      return put(enableFeatures(features));\n\n    case 10:\n    case 'end':\n      return _context.stop();\n  }\n}\n\n}, _marked[0], this);\n}\n```\n. ",
    "chodorowicz": "Thanks! \nYeah, of course, the example I've linked doesn't help with testing, just shows a non promise function being argument of call. And exactly, as you've stated - using call with sync function  simplifies tests - when using call we don't to mock so much, it's enough to check yielded effects' descriptors.\nIf it's not bad of forbidden to use call with standard functions then maybe we could amend the docs @yelouafi?\n. @Andarist thanks a lot for confirmation and pointing to the place in the source code! \ud83d\ude47\n. ",
    "jfairbank": "I guess I'll be the voice of dissension :)\nWhile I admit that unit testing sagas necessarily ties the tests to the implementation, I can now make guarantees on the effects my saga deals with. I'm not only interested in the actions it dispatches. What if I care which API calls it makes? What if I care what arguments the call descriptor passes to my API functions?\nOf course I love dependency injection (i.e. passing in the libraries that my saga will use), but I want to know that it uses the libraries correctly. Sure, I could create spies/mocks and assert that they're called with certain arguments, but then why bother using sagas? I can use spies with thunks. I want to test with as few spies and mocks as possible.\nReusing this example:\n``` js\n    function* handleFeedback(libraries, action) {\n        const {WixRestaurantsApi} = libraries;\n        const {payload} = action;\n    try {\n        yield call(WixRestaurantsApi.sendFeedback, {\n            accessToken:payload.accessToken,\n            feedback:payload.feedbackRequest\n         });\n         yield put(actions.feedbackSent());\n    } catch (e) {\n         yield put(actions.feedbackError(e));\n    }\n}\n\n```\nMaybe it's personal preference or being overly anxious, but I would like to know that the sendFeedback function is called with the correct arguments. I also write some sagas intentionally such that ordering IS important. So for me, I want to test that ordering.\n(Aside: Even my react tests take a hybrid unit testing approach along with snapshots because I'm not convinced snapshots are enough. If my component uses certain props, then I'd like to see those represented in the rendered output. If I'm writing stateless components with functions, then passing in props should result in a certain type of output based on those props. How is that any different from a normal pure function? Should I snapshot all my normal functions then too and just hope the initial snapshot is producing the correct result?)\nI agree that refactoring a saga can be slightly annoying for unit testing, which is why I created redux-saga-test-plan. It has helped tremendously for testing and refactoring sagas, so fixing a test isn't that big of a deal for me personally.\nMaybe I'm reading too much into it, but if I think about sagas as something similar to IO monads (#505), then they are similar-ish to compositions of function calls. I'd more than likely test the individual composed functions, so why should a saga be any different for testing?\nSo far, I haven't been burnt by this testing strategy for the project I've been working on. I have found more value and produced fewer bugs by just unit testing react, redux, and redux saga on this project, so I'm not convinced that I need integration testing.\nRealistically, I think testing will be a subjective practice no matter how much we analyze it. Ultimately the testing strategy has to align with the goals of the business, the size of the team, and the pace of development of the product. For some teams, taking a more wholistic, integration testing approach might be better. For us, we've found unit testing more valuable. So maybe both testing approaches need to represented in the documentation along with the pros and cons and what each approach focuses on achieving.\n. Because there is a lot of interest in integration-type testing \u2014 and I do recognize some of the benefits too \u2014 I've started work on a new function in redux-saga-test-plan for allowing a more holistic testing approach. I'd appreciate ideas and comments over on the issue I'm using to track the feature: jfairbank/redux-saga-test-plan#37.\nEDIT: adding example code sample\nMinimal example:\n```js\n// ES2015\nimport { expectSaga } from 'redux-saga-test-plan';\nfunction identity(value) {\n  return value;\n}\nfunction* mainSaga(x, y) {\n  const action = yield take('HELLO');\nyield put({ type: 'ADD', payload: x + y });\n  yield call(identity, action);\n}\nconst saga = expectSaga(mainSaga, 40, 2);\nsaga\n  // assert that the saga will eventually yield put\n  // with the expected action\n  .put({ type: 'ADD', payload: 42 })\n// start Redux Saga up with the saga\n  .start()\n// dispatch any actions the saga will take\n  .dispatch({ type: 'HELLO' })\n// stop the saga\n  .stop();\n```. @kwnccc Of course I'm biased, but you can easily write this with redux-saga-test-plan with little duplication. Reusing the example saga that @neurosnap provided:\n```js\nimport { put, select } from 'redux-saga/effects';\nimport { expectSaga } from 'redux-saga-test-plan';\nfunction* myGen({ userId }) {\n  const users = yield select(getUsers);\n  const user = users[userId];\n  yield put(registerUser(user));\nif (user.isAdmin) {\n    yield put(showAdminPanel());\n  }\n}\nit('regular users cannot access admin panel', () => {\n  return expectSaga(myGen, { userId: 5 })\n    .provide([\n      [select(getUsers), { '5': { isAdmin: false } }]\n    ])\n    .not.put(showAdminPanel())\n    .run();\n});\nit('admins can access admin panel', () => {\n  return expectSaga(myGen, { userId: 5 })\n    .provide([\n      [select(getUsers), { '5': { isAdmin: true } }]\n    ])\n    .put(showAdminPanel())\n    .run();\n});\n```. Haha, no worries. Sorry for opening the issue so quickly! I should have waited. I just happened to be on GitHub when Greenkeeper alerted me. Thanks again!. While I would be flattered to have redux-saga-test-plan listed in the docs, I'm not sure it would be fair to some of the other redux-saga testing libraries out there. Only listing one or two would give the impression that redux-saga favors those over others. This is part of the reason why I've never even made a PR to add redux-saga-test-plan to the docs.\nI'm deeply interested in the redux-saga testing story and initially only embraced unit testing with redux-saga-test-plan. However, I have come to recognize that integration testing is probably a better approach which is why redux-saga-test-plan now offers it with a simple, declarative API.\nWhen redux-saga's API settles, I would love to be involved in the testing discussion further. For example, features like #586 could be useful for simplifying some of the hacks I need to use currently or for future features in redux-saga-test-plan.\nI'm still okay providing a description for this PR if you want, but it would only be fair to list other testing libraries like wix's too.. ",
    "AsaAyers": "I don't know if I even intend to continue the project on my own, but if anyone is interested here is my experiment: https://gitlab.com/AsaAyers/redux-saga-tester. I did also publish it on npm if you'd like to try it out.\nThe core concept is that it wraps around a specific saga and intercepts all calls. It has a real store like @3LOK 's redux-saga-tester, but it also gives you the ability to intercept calls like you do by examining the generator output. If you're testing the output of a generator, I think it's nice to be able to write your test as a generator.\n\n\n\nToy Example\n\n\n\nThis test is also available [in the repo](https://gitlab.com/AsaAyers/redux-saga-tester/blob/master/src/tests/add-saga.test.js#L37-65)\n\n``` js\nexport function* addSaga() {\n    const a = yield select(selectA)\n    const b = yield select(selectB)\n    const total = yield call(sum, a, b)\n    yield put({\n        type: \"RESULT\",\n        payload: total\n    })\n}\n\ntest(\"add-saga\", () => {\n    const tester = SagaTester({\n        initialState: {\n            a: 2,\n            b: 3,\n        },\n        reducer,\n    })\n    tester.testAgainst(addSaga, function* ({ getState }) {\n        let actual\n        // yield gives you the next effect from your saga that you want to test.\n        // This didn't care about the selectors, they execute normally.\n        actual = yield\n        expect(actual).toEqual(call(sum, 2, 3))\n        const callSumResult = 5\n        // You need to yield a result back to the saga to continue and pick up\n        // the next significant effect.\n        actual = yield callSumResult\n        // END is a special value automatically emitted when/if your saga ends\n        expect(actual).toBe(END)\n        // Instead of verifying the action was fired, now verify the state.\n        actual = selectResult(getState())\n        expect(actual).toBe(callSumResult)\n    })\n})\n```\n\n\nThe main problem I ran into was figuring out what to do with fork and call. Should I try to intercept fork / call effects, figure out if it's calling a generator and then also intercept that generator's calls? \n. ",
    "eloytoro": "The main problem with some of these solutions is that when running the sagas using the middleware there's no way to prevent call effects to actually execute external logic. If we somehow had a way to mock the evaluation of these effects in the sagaMiddleware I think testing would be really simple\nI don't think an external lib would be necessary. Right now redux-saga exposes a very useful runSaga function which allows you to monitor, but not alter, saga execution. If there were a middleware option for it that would allow us to return the resulting value of each effect (when needed) it should be possible\nExample\n``js\nfunction* mySaga() {\n  yield take(ACTION_TYPE);\n  const result = yield call(serverRequest);\n  returnThe server responded with ${result}`;\n}\nrunSaga(mySaga(), {\n  ...,\n  middleware: (effect) => {\n    // ideally check that the effect being yielded matches your criteria\n    if (isEqual(effect, call(serverRequest)) {\n      // when something is not an effect redux saga just returns whats yielded\n      return 'mocked value';\n    }\n    // return original effect\n    return effect;\n  }\n});\n``. @yelouafi I made some progress doing what youre asking usingcoand other fancy middleware composition stuff (inspired off koa like you said) but I realized that this would force an extra tick into every effect call becausecois always async. So the async middleware promise produced bycohas to be resolved on every call torunEffect` because we must check if the effect changed after the middleware went through, is that ok?. @yelouafi did some progress on this trying to stick to the API you proposed.\nI'm not sure what the cb in the middleware signature you propose means, so I'm leaving it out.\nYou can now chain middlewares if you do this\njs\neffectMiddleware: [middleware1, middleware2]\nHowever it seems that delaying effects from triggering will break the lib for an unknown reason\njs\neffectMiddleware: (next) => (effect) => {\n  // breaks task.done promise\n  setTimeout(() => next(effect), 100);\n}. It's actually my fault since I found that mocking depencies was a simpler\nfix for my needs of mocking effects.\nThanks for the review!\nOn Nov 2, 2017 6:07 AM, \"Mateusz Burzy\u0144ski\" notifications@github.com\nwrote:\n\n@eloytoro https://github.com/eloytoro the problem was that in your test\nby delaying the forkB effect it didnt get a chance to set up a listener\nfor ACTION-3 (with take('ACTION-3')) and it just missed it and couldn't\nproceed further because the action was dispatched too early\nI've merged your branch here #1246\nhttps://github.com/redux-saga/redux-saga/pull/1246 , need to review it\nand gonna just do some minor tweaks, so it can land on master soon. Sorry\nthat it took so long time to take this further.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/729#issuecomment-341401514,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADwSBSKUtEvprLsydnDZyeLW-J66X6WXks5sybCMgaJpZM4LXUPB\n.\n. agree. will do my best to move it outside. what do you mean? this function is now taking care of all the declarative effects, if the middleware returns the same it should still handle the same logic.\n\nThe reason im doing this here and separating the declarative effects from the rest is that i dont want to pass the middleware arrays of effects or pending promises or internal stuff. Also I was thinking of moving this to a third parameter, so passing a store and a middleware isnt as clunky\nright now\n```js\nconst store = createStore(...);\nconst effectMiddleware = () => {...};\nrunSaga(saga, { ...store, effectMiddleware });\n```\nmaybe better?\n```js\nconst store = createStore(...);\nconst effectMiddleware = () => {...};\nrunSaga(saga, store, { effectMiddleware });\n```. Oh wait nvm I think I get the point. In case the effect gets swaped by something thats not declarative.\nWill take care of this. ",
    "flushentitypacket": "What do you all think about a simplistic approach like this?\n```javascript\nimport deepEqual from 'deep-equal'\nconst nextUntil = (gen, untilValue, value) => {\n  let result = gen.next(value)\n  while (!result.done) {\n    if (deepEqual(result.value, untilValue)) return result\n    result = gen.next()\n  }\n  return null\n}\n```\nYou can use this to test generator functions directly, similar to how @neurosnap's lib does.\nHere's a practical example:\njavascript\nit('uses token from store to call someAuthenticatedRequest', () => {\n  const gen = mySaga(action)\n  expect(nextUntil(gen, select(getToken))).toBeTruthy()\n  const token = 'harrypotterandthesorcererstoken'\n  expect(nextUntil(gen, call(someAuthenticatedRequest, token), token)).toBeTruthy()\n}). I've run into this problem as well.\nThe best solution I could come up with is to basically imitate a mutex. (This approach only works because of the lack of threading in Javascript, otherwise we'd need a true mutex).\n```js\nfunction* sagaA() {\n  yield put(inFlightA())\n  // ... do A stuff\n  yield put({ type: IS_COMPLETE_A })\n  yield put(resetInFlightA())\n}\nfunction* sagaAandB() {\n  const inFlightA = yield select(selectInFlightA)\n  if (!inFlightA) {\n    yield put(actionSagaA())\n  }\n  yield take(IS_COMPLETE_A)\n  // Everything that happens after this is after saga A has completed.\n// ...do B stuff\n}\n```\n@Andarist I believe this strategy is what you were referring to in your first reply\n\ni guess u have to have completion event\n\n@neurosnap OP @frankandrobot is correct: Using call on a saga that can also be triggered from a dispatch action puts a risk on corrupting state. We want to have all control flowing through the usual takeLatest (or similar) functions.\nEDIT: Even simpler way to do this if you don't mind cancelling in-flight saga As:\n```js\nfunction* sagaA() {\n  // ... do A stuff\n  yield put({ type: IS_COMPLETE_A })\n}\nfunction* sagaAandB() {\n  yield put(actionSagaA()) // will cancel in-flight A if any exist if you're executing with takeLatest\n  yield take(IS_COMPLETE_A)\n  // Everything that happens after this is after saga A has completed.\n// ...do B stuff\n}\n``. @s123121 Maybe in that scenario, you can alsoyield put({ type: IS_COMPLETE_A })`. \nOr if sagaAandB has different handling in an error case, you can use race like\n``js\nfunction* sagaAandB() {\n  yield put(actionSagaA()) // will cancel in-flight A if any exist if you're executing with takeLatest\n  const result = yield race([\n    take(IS_COMPLETE_A),\n    take(ERROR_A),\n  ])\n  // I'm not exactly sure what the yield signature is forrace`, but see docs:\n  // https://redux-saga.js.org/docs/api/#raceeffects\n// Then branch on the value of result\n}\n```. Also somewhat troubling is that I can't just escape-hatch it with\ntakeLatest(ACTION_TYPE, workerFn, dependencies as any)\nSince it conflicts with the never type.. Ah, okay, I've found the issue.\ntype Dependencies = {foo: string}\nconst workerFn = (dependencies: Dependencies) => {}\ntakeLatest(ACTION_TYPE, workerFn, {foo: 'bar'})\nDoes NOT compile because workerFn does not include a second arg for the action being passed in.\nconst workerFn = (dependencies: Dependencies, action: ActionType) => {}\nThis works.. Add the Typescript error here in case it helps anyone searching for this problem:\nArgument of type '[FooType]' is not assignable to parameter of type 'never'.. ",
    "DzoQiEuoi": "I agree with those who say the testing recommended in the official documentation is pointless.\nTo make my tests implementation agnostic I'm using Jest's async/await capabilities along with a mock store which just keeps a log of actions. This might need some tweaking if your sagas trigger timers.\n```javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport api from '.path/to/api/service';\nimport saga from './path/to/sagas';\nfunction mockStore(rootSaga) {\n  const sagaMiddleware = createSagaMiddleware();\n  const actionReducer = (state, action) => \n    action.type === '@@redux/INIT' ? [] : [...state, action];\n  const store = applyMiddleware(sagaMiddleware)(createStore)(actionReducer);\n  sagaMiddleware.run(rootSaga);\n  return store;\n}\ndescribe('suite', () => {\n  it('test', async () => {\n    const store = mockStore(saga);\n    api.someCall = jest.fn(() => 'some response');\nstore.dispatch({\n  type: 'SOME_ACTION',\n  id: 123\n});\n\nawait Promise.resolve();\n\nconst actual = store.getState();\nconst expected = [\n  { type: 'SOME_ACTION', id: 123 },\n  { type: 'SOME_OTHER_ACTION', payload: 'some response' }\n];\n\nexpect(actual).toEqual(expected);\nexpect(api.someCall).toHaveBeenCalledWith(123);\n\n});\n});\n```. ",
    "iwinux": "A contrived mimic of the official testing example would be\n```javascript\nfunction calc(a, b) {\n    return a + b\n}\ntest('calc', () => {\n    const spy = mock('+') / suppose we can do this /\n    calc(1, 2)\n    expect(spy).toBeCalledWith(1, 2)\n})\n```\nwhile the actual test I want to perform is:\njavascript\ntest('calc', () => {\n    expect(calc(1, 1)).toEqual(2)\n    expect(calc(1, 2)).toEqual(3)\n})\nIMO the first way of testing is just duplicating the same logic in tests.. ",
    "SelaO": "@3LOK Do you have an example on how to properly test saga (if at all) without the silly overhead that was discussed here?. ",
    "swamikevala": "see my output of redux devtools\nredux-devtools-output.zip\nIf I handle the error in my Api code then it works: \n}).then(response => {\n        if (response.status >= 400) {\n            throw new Error(\"Bad response from server\");\n        }\n        return response.json();\n    })\n}\nEDIT: I'm also getting the same thing when the api call is successful (the yields in both the try and catch blocks are executing)\n. https://jsfiddle.net/o0ge38L3/21/\nI have taken the relevant parts of my app and put in jsfiddle... However, I'm not able to get it working due to some error with the generator functions\nHope this is of some help\n. https://jsfiddle.net/o0ge38L3/21/\n. ",
    "gavin-gmlab": "From the Monitor output, this is what is logged in the console.log\n09-03 15:48:03.326 5572-9443/? I/ReactNativeJS: Monitor {\"duration\":163,\"problem\":null,\"ok\":true,\"status\":200,\"headers\":{\"etag\":\"W/\\\"1ee-5EYE40mcgF46T9GFDuRS3w\\\"\",\"access-control-allow-origin\":\"*\",\"x-powered-by\":\"Express\",\"vary\":\"Accept-Encoding\",\"connection\":\"keep-alive\",\"transfer-encoding\":\"chunked\",\"content-type\":\"application/json; charset=utf-8\",\"access-control-allow-headers\":\"X-Requested-With\",\"date\":\"Sat, 03 Sep 2016 15:48:03 GMT\",\"server\":\"nginx\"},\"config\":{\"transformRequest\":[null],\"transformResponse\":[null],\"headers\":{\"Accept\":\"application/json, text/plain, */*\",\"Content-Type\":\"application/x-www-form-urlencoded\",\"Cache-Control\":\"no-cache\",\"Connection\":\"keep-alive\"},\"timeout\":1000,\"xsrfCookieName\":\"XSRF-TOKEN\",\"xsrfHeaderName\":\"X-XSRF-TOKEN\",\"maxContentLength\":-1,\"baseURL\":\"https://xxx.yyy.zz/api\",\"method\":\"post\",\"url\":\"https://xxx.yyy.zz/api/users/list\",\"data\":\"set%5B%5D=1&token=a\"},\"data\":[{\"id\":2,\"uuid\":\"K7yoxMHDf4V4g7ACx3y4t7B_wMYr\",\"short_name\":\"Support\",\"full_name\":\"Support\",\"status\":\"active\",\"user_type\":\"normal\",\"user_type_main_id\":\"mcr\",,\"employee_no\":\"\",\"department_code\":\"28\",\"department_name\":\"Support\",\"subdepartment_code\":\"-1\",\"subdepartment_name\":\"\",\"designation_code\":\"91\",\"designation_name\":\"Engineer\",\"mobile\":\"99999999\",\"email\":\"\",\"permissions\":[]}]}\nThe listUser function looks like:\nconst listUsers = (params) => {\n    console.log(\"params\"+JSON.stringify(params))\n    try {\n    api.post(\n    '/users/list',\n    params,\n      {\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      }\n    }\n    ) \n    console.log(\"post submit\")\n  }\n    catch (e) {\n      console.log (\"API error\"+e+JSON.stringify(e))\n    }\n  }\nOne thing I'd like to note is that I originally put the \nconst authObject = yield take(Types.LOGIN_SUCCESS)\ninside the attemptLoginWatcher() function block, but seemed like this didn't get called, so was forced to create another watcher function. Another thing to note is I am working on the Android emulator.\n. Update: I think there is some problem handling the particular request or the response that I am passing in. I tried with another API just modifying request params and the api call and it works\n. Ahh. Going through the code so much that the obvious doesn't stand out. \nThanks.\n. ",
    "surajsavita": "Here is the code: \nconfigureStore.js:\nexport default function configureStore(preloadedState) {\n  const sagaMiddleware = createSagaMiddleware()\n  sagaMiddleware.run(rootSaga)\n  return {\n    ...createStore(rootReducer, applyMiddleware(sagaMiddleware)),\n    runSaga: sagaMiddleware.run\n  }\n}\nsaga/Index.js\n```\nexport function FetchAPIActor(url = config.api_root, method = 'GET', payload = {}) {\n  let request_map = {\n    method: method,\n    mode: 'cors',\n    redirect: 'follow',\n    credentials: 'same-origin',\n    headers: new Headers({\n      'Content-Type': 'application/json',\n    }),\n  }\n  if (payload && ['PUT', 'POST'].indexOf(method) >= 0) {\n    request_map.body = JSON.stringify(payload)\n  }\n  var request = new Request(url, request_map);\n  console.log(\"REQUEST : \", request)\n  return fetch(request)\n    .then(response => response.json())\n    .then(json => {\n      console.log(json.data)\n      return json.data\n    })\n    .catch(error => console.log(\"Fetch Error \", url, method, payload, error))\n}\nfunction* patchTodo() {\n  while (true) {\n    const {id, text} = yield take(actionTypes.EDIT_TODO)\n    try {\n      //yield call(patchFetchApi, config.api_root + /mytodos/ + id, {todo: text})\n      yield call(FetchAPIActor, config.api_root + /mytodos/ + id, 'PATCH', {todo: text})\n      yield put(Actions.editTodo(id, text))\n    }\n    catch (error) {\n      console.log(\"PATCH TODO ERROR\", error)\n    }\n  }\n}\nexport default function* root() {\n  yield [\n//    startup(),\n    patchTodo(),\n  ]\n}\n```\nactionTypes.js\nexport function editTodo(id, text) {\n  console.log(\"PATCH_TODO\")\n  return {\n    type: types.EDIT_TODO,\n    id,\n    text\n  }\n}\nreducers/index.js\nconst initialState = []\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n    case EDIT_TODO:\n      return state.map(todo =>\n        todo.id === action.id ?\n          Object.assign({}, todo, {text: action.text}) :\n          todo\n      )\n    default:\n      return state\n  }\n}\napp.js\n```\nconst preloadedState = window.PRELOADED_STATE\nlet store = configureStore(preloadedState)\n```\nSo here I can see in console log \"PATCH_TODO\" is getting printed 2 times.\n. \nTo me middleware seems more of a decorators wrapping the actual code like an onion layers so that you can run code before and after actual action being performed by reducers.\nIs there any special effect which I need to use to make it intercept action or to make saga call reducer after action manipulation with api calls?\nRef: https://www.codementor.io/reactjs/tutorial/intro-to-react-redux-pros\n. Looks like I have to follow Database transaction like actions here: BEGIN --- Saga --- [COMMIT/ROLLBACK]\nThanks, It would do the job.\n. ",
    "km-tr": "Thank you!\nThe point is, does this mean I can not to be serial?\n. ",
    "avaragado": "If I have time later or over the weekend I'll try to set something up.\nThe issue here is that two independent channels had messages available to take at the same time, because of buffering. Two possible expected behaviours spring to mind:\n1. The result of the race is an object containing all properties with messages available to take. In my example, both handler and response would be set. It would be up to subsequent code to cope with that scenario (eg replacing if (request) {} else if (handler) {} else if (response) {} with three independent if clauses not strung together with else). Documentation would cover this case, eg \"When you're using race with multiple independent channels, more than one channel may have a message available, so there may be more than one winner\".\n2. Keep a single winner, and ensure that any other takes with messages available don't drop the messages. Assuming the race occurs in a loop, next time around the loop one of those other takes would win.\nI prefer the first option, as it doesn't assume the race is looping. It's an exception to the \"only one winner\" rule for races that's pretty easy to describe with an example like the above.\n. ",
    "athibaud": "ran into this too.\nthe second option seems more natural to me. race should only have one winner, agreed.\n. hum, interesting.. i had a quick go at trying to reproduce but the bug didn't appear..\nmy use case was essentially that except with more deeply nested puts (forks within forks)\nand i was seeing this in react-native.. i'll do my best to reproduce when i have time.\n. @Andarist this seems like exactly what was happening. (also, one of the channels was 'fed' by an external/async eventChannel so it makes it slightly more likely that the double message scenario could happen).\nunfortunately i have switched my implementation since running into that bug so i cannot confirm :(\n. ",
    "zentuit": "Ok so I've tracked it down. Naturally it had nothing to do with what I posted above. It had everything to do with webpack split points and sagaMiddleware.run.\nWe have our application split up into a few chunks. I'm using sagas in only one chunk (for now). So I copied what was done in the real-world example and did this after creating the store:\nstore.runSaga = sagaMiddleware.run\n  store.close = () => store.dispatch(END)\nThen where we define the split point, I was doing this:\n```\n    require.ensure([], (require) => {\n      \n      const reducer = require('./modules/authoring').default\n      const sagas = require('./sagas').default\n  /*  Add the reducer to the store on key 'authoring'  */\n  injectReducer(store, { key: 'authoring', reducer })\n\n  /* add sagas */\n  store.runSaga(sagas)\n\n\n    / Webpack named bundle   /\n    }, 'authoring')\n```\nWhat I didn't realize is that the require.ensure stuff is called multiple times - every time you change the route, this block would get called.  injectReducer is fine to run multiple times as it uses that key, so the same reducer is always under the same key.\nHowever runSaga (which is actually sagaMiddleware.run) doesn't replace, it concats. So with each route change, I was adding to the subscribers. Though I'm not sure why the subscriber count was doubling.\nWhat I'm trying now, is to just set a flag and skip calling store.runSaga on subsequent invocations. That seems to be working; the subscriber count is staying at the expected number of effects listening for emits.\n. ",
    "tauren": "@Andarist I ran into this issue as well. I have a saga that was running multiple times when the triggering action is only called once. The number of times it ran increased by one each time I visited the route that the saga is within. This route is a separate bundle. \nInstead of tracking subscriber count, you might be able to solve your problem by cancelling the saga watcher when your route changes. This is how react-boilerplate does it and it worked for me:\n```\nexport function* githubData() {\n  // Fork watcher so we can continue execution\n  const watcher = yield fork(getReposWatcher);\n// Suspend execution until location changes\n  yield take(LOCATION_CHANGE);\n  yield cancel(watcher);\n}\n// Bootstrap sagas\nexport default [\n  githubData,\n];\n```\nhttps://github.com/mxstbr/react-boilerplate/blob/master/app/containers/HomePage/sagas.js#L44-L48\n. By the way, the same thing happens if I use a for loop to sequence the yields:\nfor (let i = 0; i < cameras.length; i++) {\n  yield put(cameraSnapshotRequest(cameras[i].deviceId, cameras[i].id))\n}\n. I was able to solve this problem by using actionChannel:\nexport function * cameraSnapshotFlow () {\n  const chan = yield actionChannel(CAMERA_SNAPSHOT_REQUEST)\n  while (true) {\n    const request = yield take(chan)\n    console.log('GOT REQUEST', request)\n    yield put(cameraSnapshotReady('yo'))\n    console.log('DONE')\n  }\n}\nHowever, I'm unclear why this was necessary and if this is the correct way to solve the problem.\n. ",
    "jshumakerpruitt": "@Andarist \nstore.js\n```\n/*\n * Create the store with asynchronously loaded reducers\n /\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { fromJS } from 'immutable';\nimport { routerMiddleware } from 'react-router-redux';\nimport createSagaMiddleware from 'redux-saga';\nimport createReducer from './reducers';\nconst sagaMiddleware = createSagaMiddleware();\nconst devtools = window.devToolsExtension || (() => (noop) => noop);\nexport default function configureStore(initialState = {}, history) {\n  // Create the store with two middlewares\n  // 1. sagaMiddleware: Makes redux-sagas work\n  // 2. routerMiddleware: Syncs the location/URL path to the state\n  const middlewares = [\n    sagaMiddleware,\n    routerMiddleware(history),\n  ];\nconst enhancers = [\n    applyMiddleware(...middlewares),\n    devtools(),\n  ];\nconst store = createStore(\n    createReducer(),\n    fromJS(initialState),\n    compose(...enhancers)\n  );\n// Extensions\n  store.runSaga = sagaMiddleware.run;\n  store.asyncReducers = {}; // Async reducer registry\n// Make reducers hot reloadable, see http://mxs.is/googmo\n  / istanbul ignore next /\n  if (module.hot) {\n    module.hot.accept('./reducers', () => {\n      System.import('./reducers').then((reducerModule) => {\n        const createReducers = reducerModule.default;\n        const nextReducers = createReducers(store.asyncReducers);\n    store.replaceReducer(nextReducers);\n  });\n});\n\n}\nreturn store;\n}\n```\nasyncInjectors.js\n```\nimport { conformsTo, isEmpty, isFunction, isObject, isString } from 'lodash';\nimport invariant from 'invariant';\nimport warning from 'warning';\nimport createReducer from '../reducers';\n/*\n * Validate the shape of redux store\n /\nexport function checkStore(store) {\n  const shape = {\n    dispatch: isFunction,\n    subscribe: isFunction,\n    getState: isFunction,\n    replaceReducer: isFunction,\n    runSaga: isFunction,\n    asyncReducers: isObject,\n  };\n  invariant(\n    conformsTo(store, shape),\n    '(app/utils...) asyncInjectors: Expected a valid redux store'\n  );\n}\n/*\n * Inject an asynchronously loaded reducer\n /\nexport function injectAsyncReducer(store, isValid) {\n  return function injectReducer(name, asyncReducer) {\n    if (!isValid) checkStore(store);\ninvariant(\n  isString(name) && !isEmpty(name) && isFunction(asyncReducer),\n  '(app/utils...) injectAsyncReducer: Expected `asyncReducer` to be a reducer function'\n);\n\nstore.asyncReducers[name] = asyncReducer; // eslint-disable-line no-param-reassign\nstore.replaceReducer(createReducer(store.asyncReducers));\n\n};\n}\n/*\n * Inject an asynchronously loaded saga\n /\nexport function injectAsyncSagas(store, isValid) {\n  return function injectSagas(sagas) {\n    if (!isValid) checkStore(store);\ninvariant(\n  Array.isArray(sagas),\n  '(app/utils...) injectAsyncSagas: Expected `sagas` to be an array of generator functions'\n);\n\nwarning(\n  !isEmpty(sagas),\n  '(app/utils...) injectAsyncSagas: Received an empty `sagas` array'\n);\n\nsagas.map(store.runSaga);\n\n};\n}\n/*\n * Helper for creating injectors\n /\nexport function getAsyncInjectors(store) {\n  checkStore(store);\nreturn {\n    injectReducer: injectAsyncReducer(store, true),\n    injectSagas: injectAsyncSagas(store, true),\n  };\n}\n```\n. @neurosnap Thanks for the tip.  I got it to work by changing it to match the style of other sagas in react-boilerplate. Closing this since it was never an issue with redux-saga.\n``` javascript\nexport function watchSubmitLike() {\n  / eslint-disable no-constant-condition /\n  while (true) {\n    const action = yield take(SUBMIT_LIKE);\n    yield call(submitLikeSaga, action);\n  }\n  / eslint-enable no-constant-condition */\n}\nexport function* likeData() {\n  // Fork watcher so we can continue execution\n  const watcher = yield fork(watchSubmitLike);\n// Suspend execution until location changes\n  yield take(LOCATION_CHANGE);\n  yield cancel(watcher);\n}\n// All sagas to be loaded\nexport default [\n  watchFetchUsers,\n  likeData,\n];\n```\n. ",
    "yummyelin": "I solved the issue by cancel takelatest watcher.\nBefore:\nexport function* likeData() {\n  yield takelatest(watchSubmitLike);\n}\nAfter:\nexport function* likeData() {\n  const watcher = yield takelatest(watchSubmitLike);\n  yield take(LOCATION_CHANGE);\n  yield cancel(watcher);\n}. I solved the issue by cancel takelatest watcher.\nBefore:\nexport function* likeData() {\n  yield takelatest(watchSubmitLike);\n}\nAfter:\nexport function* likeData() {\n  const watcher = yield takelatest(watchSubmitLike);\n  yield take(LOCATION_CHANGE);\n  yield cancel(watcher);\n}. ",
    "michaelgilley": "@yelouafi Any thoughts on this?\n. I agree on both accounts. I have updated the PR.\nA few notes however:\n1. This behavior should be documented\n2. put.sync should be added to the documentation\n3. Logging is inconsistent and at times unhelpful (as you pointed out here). I vote we make error reporting more robust.\n. I've add error handling for put in the API docs and I'll raise the log reporting in another issue.\n. @yelouafi You're proposing that the takeEvery and takeLatest helpers be made available as effects only?\n. Closing in favor of #596 \n. Not sure if this applies but I've been a fan of Bluebird's longStackTraces. It'd be great if we could create something similar for debugging. Even so, perhaps some kind of error formatting that logs out a human-readable error would be nice.\n. In this specific case it does but in other sagas (with try/catch/finally) this would not be true. So in this case the test asserts that takeEvery is not wrapped in a finally block.\nOn another note, this is especially done to increase coverage. If you want to get even better coverage than this one would need to run a saga.throw(err) assertion as well. I left this off here though as a bit too verbose.\n. Yeah, this is the sort of thing that should be handled by the logger. For now I'll add a check though.\n. Am I missing something? I went in to update this and the tests are still passing. It looks like takeEvery is still returning an iterator. Do I have something wrong??\n. ",
    "sheerun": "Never mind, it turns out fast-async can handle only async await, not generators..\n. ",
    "ericelliott": "In JavaScript, a lot of FP types are implemented according to the Fantasyland spec, which essentially just gives us standard names for common operations and provides chainable APIs.\nConforming to Fantasyland would allow for interoperability with a whole bunch of JS libraries.\nSee the Fantasyland Monad spec.. ",
    "bruno-barbosa": "Yes I noticed the problem shortly after opening the issue, I will close this.\nThank you in any case!\nBruno\n. ",
    "SpencerCDixon": "Do I have to pass in an object to the call to gen.next({success: true}).value or something like that?\n. @oanylund issue fixed my issue... closing this.\n. Yeah so essentially I might have other sagas that use this one and they need to wait until the entity is deleted either successfully or fails to delete and respond accordingly.  For example, if deleted successfully then pop an alert saying everything went well or if failed ask user if they want to retry, etc.\nGlad that race is being used properly was skeptical since none of the examples I saw used it this way. Excellent, thank you for the direction!  I will tackle this tomorrow and see how it goes :-) \ud83d\udc4d . ",
    "iverberk": "It's fixed by wrapping the connection code in a Promise and yielding the generator function on resolve: https://github.com/iverberk/nomad-ui/blob/master/frontend/src/sagas/event.js#L129-L135\n. ",
    "rjdestigter": "Just another thought. You could also create a simple middleware to inject into redux before redux saga is is injected that queue's incoming actions until a flag on state changes to true. For example, within a large application where each route boots up it's own set of sagas, on location change you could set that state flag to false, start up your sagas, then set the the state flag to true.\nThe middleware would check if the flag is false and queue incoming incoming actions and flush them back to redux if the flag changes to true. Never mind, looks like this was resolved in the latest beta version.\nhttps://codesandbox.io/s/rprykrpp. ",
    "invibot": "You're right, it should. Closing PR as irrelevant.\n. You're right, it should. Closing PR as irrelevant.\n. ",
    "nibblesnbits": "Without completely understanding your issue (and guessing based on your title), I'd say the simplest way to defer rendering a component until a saga completes is to wrap the component in a {someProp && <MyChildComponent /> } from the parent component.\nExample (assuming use of redux, but the idea is the same):\n``` js\n// ParentComponent.js\nconst ParentComponent = ({ myData }) => (\n  { myData &&  / this component will only render if myData is not undefined / }\n)\nexport default connect(state => ({ myData: state.myData }))(ParentComponent)\n// sagas.js\nfunction* getData() {\n  var data = yield call(api.getData);\n  yield put({type: 'GET_DATA_SUCCESS', data}));\n}\nexport watchGetData() {\n  yield takeEvery('GET_DATA', getData);\n}\n// reducers.js\nfunction dataReducer(state, action) {\n  //...\n  case: 'GET_DATA_SUCCESS': \n    return {\n      ...state,\n      myData: action.data\n    };\n  //...\n}\n```\n. @ekeric13, do you have a final version of this function?  I imagine it wouldn't be too bad to do myself, but if you've got a tested version, I'd love to see it.\n. Yes, that's exactly what I needed.  Thanks!\n. ",
    "DominicTobias": "I have just two sagas so far which need to execute in sequence, but the component renders before either of them complete and fires an action before takeLatest has been hooked up.\nThis seems like a really common problem but the solution of yet another wrapper and manual prop checks to see if the saga is finished seems to take any of the benefits away of pure actions for me.. In summary am I doing this correctly?:\njs\nexport default function* rootSaga() {\n  yield all(allSagas.map(fork));\n}. ",
    "ajwhite": "I wanted to chime in with a few things we've been doing in regards to supervision and process monitoring in our application's sagas.\n\nKeeping forks alive\nSafely performing operations\nCapturing errors for reporting\n\nAnd recently we've been thinking about how to better manage fault tolerance from a top-down (guardian -> actor) approach.\nKeeping forks alive\njs\nyield keepAlive(safelyFork(saga))\n- safelyFork captures and prevents the exception from bubbling\n- keepAlive restarts the saga if it terminates (important to join your forks inside a fork so it doesn't endlessly restart)\nSafely performing operations\nIdeally sagas handle and trap their own exceptions. Sometimes we want an exception to be thrown. And sometimes there's unknown exceptions, where a guardian should decide how to handle. \nIn the interim while we figure out the best approach, we have \"safety\" wrappers \njs\nyield forkSafely(saga)\nyield callSafely(saga)\nThis is nothing more than a glorified saga instruction with a try/catch\nCapturing errors for reporting\nIn the above cases, we never know if it fails. It's important to detect this for stability improvements. We've added an \"interceptor\", which catches the sagas error, reports it, and rethrows it\n```js\nconst withFailureReporting = createFailureReporter(errorReportingInstance)\nyield callSafely(withFailureReporting(someSaga, 'optional message for the error'))\n```\n\nTo tie it all together, a saga that should remain alive, avoid app-wide takedowns, and report these errors looks like:\n```js\nconst errorReporter = new ErrorReporter('User Saga');\nconst withFailureReporting = createFailureReporter(errorReporter);\nfunction* sagaThatMayThrow () {\n  yield take('FOO');\n  if (Math.random() > 0.5) {\n    throw new Error('Mock exception');\n  }\n}\nfunction* saga() {\n  yield keepAlive(forkSafely(withErrorReporting(sagaThatMayThrow)))\n}\n```\n\nIdea Expansion\nAs next steps, we too have been thinking about a supervisor strategy that implements similar ideas as mentioned in the beginning of this thread.\nI've been experimenting with a pattern like so:\n```js\nconst supervisor = createSupervisor(\n  Strategy.retry(5), // retry up to 5 times\n  Strategy.fallbackExponentially(factor) // additional behavior for the retry\n  //.. strategies can be provided variadically\n);\nfunction* saga() {\n  yield supervisor.fork(actorA);\n}\nfunction* actorA (intent) {\n  // intent is information about the launch of the actor -- is it a retry? is it a first run? etc\n  // intent = {retryCount: number, previousError: ?Object, ...}\n}\n```. Nope - I've read your proposals in https://github.com/redux-saga/redux-saga/pull/644 though and I think it's important to integrate as a strategy. I'm going to further prepare my thoughts on the last part. This was somewhat of a rushed example from the thinking I've done over the past week.\nI'll put together a more detailed example and explanation of what the reconciliation process looks like. \nLikely won't have more to share until next week.. > Personally after many thoughts on the topic I dont want to recommend your pattern (restarting) for everyone\nI agree with this sentiment. A saga might die in a state that it needs to restore back into. For example:\n```js\nfunction* sagaThatMayCrash () {\n  // wait for something that happens during app startup\n  yield take(APP_INITIALIZED)\n// assume it dies here\n  yield call(doSomethingThatMayCrash)\n}\n```\nIf the sagaThatMayCrash is restarted, it will restart and wait for an action that only happens once when the application starts up. In this scenario, it restarts, but it never recovers.\nI've been thinking about this scenario too and have considered providing some meta to the saga. Think:\n```js\nfunction* sagaThatMayDie (supervisorState = {firstRun: true, restartCount: 0, ...}) {\n  // here we can see if we have restarted or not.\n  // when its restarted, this is no longer true, so we can skip that\n  if (supervisorState.firstRun) {\n    yield take(INITIALIZE)\n  }\nyield call(doSomethingThatMayCrash)\n}\n```\nThe caveat here is that this creates a coupling between the actor and the supervisor. Still brainstorming all the scenarios where we may want to restart, but recover in a certain state... @Andarist we've created a few \"supervisor\" strategies, but we also haven't come up with a great abstraction. It's a particularly challenging one. I'd be quite interested in looking at this problem with other folks that have also put some thought into it.\nWe are currently have a few compositional wrappers, like so:\n```js\n// Keep the fork alive if it crashes. Note - this just simply forks it again.\nyield keepAlive(fork(saga))\n// Calls the saga and swallows any errors\nyield call(safely(saga))\n// Tries a few times, then finally fails\nyield withRetry(RetryStrategy.attempts(5), RetryStrategy.exponential())(saga)\n// Compose rules together, safely call a saga, report any errors, and retry if it fails \nconst wrap = compose(\n  safely,\n  withErrorReporting,\n  withRetry(RetryStrategy.attempts(2))\n);\n// Safely wraps the saga and reports errors\nyield takeEvery(action, wrap(saga))\n```\nI think these are good ingredients to a larger abstraction.. So great to hear! We do have a repo in the works (currently this all lives within our product codebase), but I'm working on moving parts out to share with the community in spare time.\nI would love to work with you folks on introducing a set of tools for saga supervision and error boundaries. I've wanted to find some people to validate and bounce ideas off of.. redux-saga doesn't happen to have a slack organization, do we? Or do you folks have a saga channel in the ReactiFlux discord channel?. ",
    "srails": "404 Again... \nThanks. https://github.com/redux-saga/redux-saga-beginner-tutorial\n\"Companion Repo for Redux/Redux-saga beginner tutorial\"\nThis link is throwing a 404 also might want to update.\nThanks\n. ",
    "iTob191": "Damn, I should really read the release notes more carefully :x Was on v0.11.x. Thanks for pointing that out to me.\n. ",
    "DTwigs": "Ah ha! I figured it out.  I was thinking about generators all wrong.  The fix is this:\n```\ndescribe(\"watchDoSomething\", () => {\n  const generator = watchDoSomething();\n  const params = { foo: 'bar' };\n  const callback = () => {return true;}\nit('follows the steps', () => {\n    let next = generator.next();\n    expect(next.value).toEqual(take(GET_CALLBACK));\nnext = generator.next({callback});\nexpect(next.value).toEqual(take(GET_PARAMS));\n\nnext = generator.next({params});\nexpect(next.value).toEqual(call(callback, params));\n\n})\n});\n```\nFrom what my brain can make sense of this, is that the generator.next() stops at the right hand side of the equation (where the yield is).  So the next time we call generator.next we are saying resolve the right hand side of the equation with whatever value we pass into generator.next and move on to the next yield, which in this case is again on the right hand side of the equation.  So instead of thinking of next being the execution of the next yield it's actually a resolution of the current yield and stopping at the next yield.\n. ",
    "Alxandr": "https://jsbin.com/curoxayojo/edit?js,console\nBasically, what happens is that in race, the callback of effect 1 is called before effect 2 is \"subscribed\" to (thus, the cancel method is not set). It can be solved by either adding a delaying mechanism (preventing synchronous execution), or by adding if (!completed) to the loop at https://github.com/yelouafi/redux-saga/blob/master/src/internal/proc.js#L602. There are probably other ways too. I would suggest the second one, forcing async execution, but that's just my 2 cents.\n. Hehe. I was just about to fix it myself, but ran in to a bug in CPS when testing my fix (hence the PR) :P\n. Nope. This test seems really brittle to me, as it's using timing to \"work things out\", which should probably be improved upon.\n. Probably using something like this: http://sinonjs.org/docs/#clock\n. More googleing lead me to https://github.com/sinonjs/lolex which is extracted from sinon (in case you feel an entire mocking library is too much of a dependency).\n. Reading more from the lolex one, it seems it's extracted from sinonjs (and also under the sinon umbrella), so unless you need the rest of sinon that's probably the one to go with.\n. Don't really think so. Cause this is testing that without doing anything custom like that, throttle works as expected.\n. My main gripe with this is that sure, you can attach [CANCEL] to promises, but if you do any processing in async functions .then(...), you loose the cancelation ability. . Yeah, I know. Currently, instead of just attaching [CANCEL], I also override .then and .catch, so any resulting promises also get wrapped. It works reasonably well, but it's a bit annoying.. There is a Saga<T> type. If I understand you question correctly. Example:\n```js\nimport type { Saga } from 'redux-saga';\nimport { put } from 'redux-saga/effects';\nfunction* mySaga(): Saga* return type */ void {\n  yield put(myEffectCreator());\n}\n``. @mackbrowne just useSaga<...>` for both. Some examples:\n```js\nfunction* loginSaga(username: string, password: string): Saga {\n  const result = yield call(doTheActualLogin, username, password));\n  if (result.success) {\n    return result.user;\n  } else {\n    return null; // or error\n  }\n}\nfunction* handleLoginSaga(action: LoginAction): Saga {\n  const user = yield call(loginSaga, action.payload.username, action.payload.password);\n  if (user !== null) {\n    yield put(setUser(user.id));\n  } else {\n    yield put(setLoginFormError('Wrong username or password'));\n  }\n}\nfunction rootSaga(): Saga {\n  yield takeEvery(LOGIN, handleLoginSaga);\n}\n``. @Andarist I'm not entirely sure. It might be. But, it is **strongly recommended** that you always type sagas as being typeSaga<....>. It's very possible thatSaga<>would work just fine, I haven't tried that. But if you do not type the saga, flow has a tendency to do weird things with generators.. I see now that I misread this question initially. Unfortunately, anything to the left ofyieldwill be typed asany`. No good way around it for now (unless you want to only yield 1 thing in the saga).. If the action is extensible or have a meta property that is extensible, add it there. If not conclude that it can't be added, because it will break things?\nOr, instead of using Object.defineProperty, you could use Object.create(originalAction, { saga-props }). There should be an API that allows you to fork/spawn a child-saga with a different env. In my case, I would like to override the main channel (which would also allow for filtering/selecting events). Specifically, I currently do something like this:\n```js\nyield addHandler('someEventName', function*(returnPut) {\n  yield returnPut(1);\n  yield returnPut(2);\n});\n// somewhere else\nconst results = yield collect('someEventName');\n// 1, 2\n``. I didn't add typings for those cause it would have been really annoying to do so. String-based typing is always tricky. I think it's possible, but I'm not sure how you'd do it.. Yeah, I was thinking something like that. For now I just made atakeLatestMulticast`, but I would like to not have subtle differences that I don't know about between my implementation and the base one \ud83d\ude1b .. Well. It would likely only be a few lines of change; so I can probably look at it later today if I remember \ud83d\ude42 . ",
    "wafisher": "One other comment which may apply: the stack trace when running in JSC in iOS doesn't include the actual error, only the stack trace (without the top line). But when debugging in Chrome via React Native's remote debugging the error is logged. Happy to provide more details but it makes it almost impossible to debug without debugging remotely.\n. ",
    "tvedtorama": "It would also be  incredible cool if we could find a way to export saga and effect history to remote-redux-devtools - or some other log format.  Some kind of activity graph would be awesome, especially when something breaks somewhere inside something spawned.. I believe you are right, haven't tested it though.\n. I might be able to do a PR, I'll let you know.  Thank you.\n. ",
    "ksmithbaylor": "I like this! I've recently been working on a library for testing sagas using an approach similar to what @Andarist suggested above. Here's an example of what testing a saga might look like.\nGiven this saga:\n```\nfunction *complexHelper(arg) {\n  yield 123;\n}\nfunction *complexSaga() {\n  try {\n    const number = yield select(state => state.number);\n    yield put({ type: 'NUMBER_CHANGED', number: number + 1 });\nconst { fruit } = yield take('FRUIT_CHOSEN');\nyield call(complexHelper, fruit);\nyield fork(complexHelper, fruit),\nyield spawn(complexHelper, fruit)\n\nyield \"I don't care about this\";\n\n} catch (err) {\n    yield put({ type: 'UH_OH' });\n  }\n}\n```\nYou could test it this way:\ntest('Complex Saga: successful', t => {\n  const runner = new SagaRunner(complexSaga());\n  runner.expects(select(state => state.number)).returns(42);\n  runner.expects(put({ type: 'NUMBER_CHANGED', number: 43 }));\n  runner.expects(take('FRUIT_CHOSEN')).returns({ fruit: 'apple' });\n  runner.expects(fork(complexHelper, 'apple'));\n  runner.expects(spawn(complexHelper, 'apple'));\n  runner.expects(call(complexHelper, 'apple'));\n  runner.run(t);\n  t.end();\n});\nThe basic idea is to create a \"runner\" that wraps a generator instance. You set up expectations on that runner, and can optionally specify that when the runner is yielded a specific value, it will call next with another value. This would let you define the result of a call to an API, for example. Then, you tell the runner to run your saga, which does so and then asserts things about the expectations you set up.\nThe expectations are order-independent, and you only have to set up expectations for things you care about testing, instead of needing to add a bunch of generator.next() calls in the middle of your tests when the implementation changes. It also couples the \"return\" values for with the original call, instead of forcing you to pass them to the next step in the saga.\nThe library still has bugs and is missing most features, but I want to get some thoughts on the approach as I expand functionality so it will be useful to the community.\n. That's still an open question. I was considering either allowing you to specify how many steps you wanted to run the saga for, or specify a \"break point\" where it would stop calling next after seeing a particular effect.\n. ",
    "eliseumds": "Could it also be done in a per-saga basis? I'd like to bind some specific effects (take, put and select) to an instance ID for composition (e.g. CounterList uses Counter). Version 4 of the library redux-elm already solves it in a nice way for components, action creators and reducers, but we still need to inject these custom bound effects into our original sagas.. We do at ProductReview.com.au, Australia's first and most comprehensive consumer opinion site. We'll be releasing the new version of our public-facing app in a few months.\nSome of our use cases:\n\nAnalytics\nAuthentication\nA very flexible form builder to create specifications for our listings (ex: product model, color, weight, engine size). Great work from @danialk\nUser activity tracking\nFiles uploader (see demo GIF)\nA NodeJS WebSocket server built upon sagas, as well as its client\nNotifications\nRecently viewed items and searched terms\nForm state persistency (local storage + redux-form)\nAnd so on...\n\nWe'll release both user tracking utils and the files uploader as open source soon :)\nApart from simple autocomplete components and read queries (we use redux-thunk for them), all of our side-effects management was moved into sagas.\n// Cheers, @cheersjosh :)\n\n. I know what you mean, and we currently use redux-connect with the thunk middleware at ProductReview.com.au, so simple GET requests are still being done at the action creator because they return promises that redux-connect waits for before rendering. However, one could create something similar to that lib with an API that can listen to any arbitrary action (waitFor([FETCH_USER_REQUEST_SUCCESS])). Let's see.. Definitely a good use case for sagas. We do that at ProductReview.com.au because it becomes easy to:\n\nSend the event to multiple analytics platforms (Google, Mixpanel, our own API, etc)\nDebounce the requests or even group them into one if possible\nEnrich events with data from our Redux stores. For example, user ID\nCombine multiple sequential events into one. This is really powerful! Example: in order to know whether an user actually read the page content, we can use a stream of events: entered page P + scrolled to position Y + clicked on button \"Read more\" + stayed for at least 10s and only then fire an analytics event read_page_P\n\nThe options are endless and redux-saga makes them a breeze to implement.. Argh, sorry for the noise and forgetting to close the channels! They were actually running forever in my tests (because I had --watch). =X\nFor the curious ones, this is how it should be done:\njs\nchan1.take(() => {\n  order.push(1);\n  chan1.close();\n});\nchan2.take(() => {\n  order.push(2);\n  chan2.close();\n});\nchan3.take(() => {\n  assert.deepEqual(order, [1, 2]);\n  chan3.close();\n  done();\n});\nTIL that I must always close saga channels in my tests.. Thanks for the investigation. If I understood it correctly, it means that I have these two alternatives:\n\nHave access to sagaMiddleware in my @connectData\nStore the latest action in the Redux state and pass a modified subscribe function to runSaga:\n\njs\nrunSaga({\n  subscribe: cb => {\n    return store.subscribe(() => {\n      cb(store.getState().latestAction);\n    });\n  },\n  dispatch: store.dispatch,\n  getState: store.getState\n}, mySaga)\nDoes that make sense?. Sweet! I appreciate the hep, @Andarist.. Wow, that would be great :)\nI hope you're enjoying your time there, @Andarist!. The version that was published to NPM still includes the logic that checks whether error is an instance of Error. I extracted this from my node_modules with v1.0.0-beta.1:\n```js\n// es/internal/proc.js:372\nif (result instanceof Error && onError) {\n```\nIt feels like it wasn't rebuilt. . ",
    "frankandrobot": "This is awesome. I was pretty much doing this already but with a service proxy object. Instead of overriding the return type, I would override the actual function i.e., we should have the ability to call a completely different function (not just return a mocked value). This gives you a way, for example, of testing takeLatest. See https://github.com/redux-saga/redux-saga/issues/876 \nOr even more convincingly, testing error paths. . Any ETA on when this will be implemented? As stated in #876, my team needs state-based testing. And as a result, we are using a \"proxy\" service object to hold everything that makes external calls. It's a lot of boilerplate and this pattern is not tenable. \nI guess as a workaround, maybe we can override call in testing, but is that even possible because of how ES6 imports work? \nUpdate: there's this workaround https://github.com/sinonjs/sinon/issues/1358. Sure. Our code is starting to get cumbersome because of that proxy object. As long as there aren't any major breaking changes, i wouldn't mind being an alpha tester. . Well if it helps anyone else, I ended up creating a middleware that tracks dispatched actions and allows you to query the current state. Therefore, i'm able to do real state-based testing. Everything is \"real\" except function calls that make external calls, and these are behind a simple proxy so they can be mocked in tests. (Nothing out of the ordinary here. Standard testing style used, for example, in angular). Then to test takeLatest, dispatch the action but mock out one of its external calls to also dispatch another of the same action. Then the test just validates that the first action is dropped.\nThe advantage of this style, is well that the saga tests look like other tests. To be honest, the behavior-based testing style espoused here where you use generators to \"talk\" to the saga is well... clunky, non-intuitive, and brittel.. Just spoke to the team and we're open sourcing our mockStore (coming soon: https://github.com/rstudio/redux-mock-store-middleware) :-) \nA sample saga:\n```js\nfunction *saga(servicesProxy, {payload: msg}) {\n   const result = yield call(servicesProxy.externalCall, msg)\n   yield put(saveResult(result))\n   yield put(doSomethingElseWith(result))\n}\nexport default function *sagas(servicesProxy) {\n  yield [\n    takeLatest('SAGA1', saga, servicesProxy)\n  ]\n}\n```\nNotes:\n1.    because we're using takeLatest the saga is asynchronous (that's an important requirement, otherwise this approach won't work)\n2.  servicesProxy makes real calls in production but in tests is mocked out.\nSample test\n```js\ndescribe('a test', function() {\n   const sagaMiddleware = createSagaMiddleware();\n   const middlewares = [sagaMiddleware]; \nit('should work with takeLatest', function() {\n      const store = mockStore(reducers, middleware)\n      let called = false\n      const servicesProxy = {\n          // Mocked out to start another SAGA1 the first call\n          externalCall: () => {\n             if(!called) {\n                  store.dispatch({type: 'SAGA1'})\n                  called = true\n                  return 'invalid'\n             }\n             return 'valid result'\n          }\n      }\n      // start the saga as usual\n      sagaMiddleware.run(function *() {\n         yield sagas(serviceProxies);\n      }\n      // start the saga\n      store.dispatch({type: 'SAGA1'})\n      expect(store.getActions()) // ... there should be two SAGA1s\n      expect(store.getActions()) // ... the rejected SAGA should stop at some point\n   }\n});\n```\n. Note that the serviceProxy is equivalent to mocking only the calls as in the other discussions. So I'm all for that approach since using the serviceProxy is clunky, you don't use ES6 imports, and it's been an unfortunate compromise. \nAlso note that you'll probably still want to use our redux-mock-store-middleware since state-based testing on a read-only store isn't always that helpful. . > What does it event mean for an action to be completed or not? Its just an event which gets emitted. Nothing more.\nYes. If you read above, that doesn't sound right. Mainly because we support IE10 (yikes!) and angular (double yikes!!), and our app's performance decreases with more dispatched events. (Hence, we want to keep those to a minimum.)\nSo basically, you're saying that this is the only approach?\n```javascript\nfunction *createTag(action) {\n   const {name} = action.payload;\n// create tag\nyield call(Api.create, {name}); \n// then fetch all\nconst tags = yield call(Api.listTags);\n// store in redux state\nyield put(setTagData({tags}));\n\n// emit a DONE event\n    yield put(CREATE_TAG_DONE); \n}\nfunction *createTagAndDoSomething() {\n   fork put(CREATE_TAG) // something like this, more or less\n   take(CREATE_TAG_DONE) \n  // do something when createTag finishes \n}. @UchihaVeha , see the comment about calling createTag directly... you lose the ability to coordinate multiple calls, so it becomes like redux-thunk. . @neurosnap  come on guys!  If something dispatches CREATE_TAG and something else dispatches CREATE_TAG_AND_DO_SOMETHING, the two create tag calls compete with each other for the redux state. It gets corrupted eventually. @neurosnap  no, how would that approach look like?. Looks like I had a fat-finger typo in the real code and a bug the code responsible for displaying the error message. To confirm, issue 2 is a saga issue?. The context for Issue 2 is that we started seeing related issues in production---debug statements always point to the original source code, but thrown errors point sometimes point to the source and sometimes point to the bundle... and this is for non-saga code. So there's a chance that webpack is causing part of this issue. \nConfession time: I would have started contributing a long time ago but last time I looked at the source code, I couldn't make heads or tails of it... and I'm pretty experienced. One of the main problems I had with it is that it's OOP style but it seems to inject object properties dynamically. That makes it hard to understand what a single object is responsible for. As much as I'm not a fan of types, this style of coding is very amenable to types... the \"source of truth\" is the interface an object implements. \nI suppose I can try again and if I have code questions, maybe you guys are on gitter?. Hey I'm still seeing this issue in beta. For some reason, I thought beta had resolved this issue.. ",
    "billyshena": "Thanks for your quick answer @Andarist . Just figured out that I had a yield cancel when my route changes (using react-router) so that's why it stopped my messageCreatedWatcher.\nI just removed the yield cancel to make it work \ud83d\udc4d \n. ",
    "thebucknerlife": "@Andarist @ekeric13 any advice on how to test a custom helper like takeFirst? We've followed the same pattern as above. I've been trying to pattern our test off of https://github.com/yelouafi/redux-saga/blob/master/test/sagaHelpers/takeEvery.js.\n. @Andarist @ekeric13 any advice on how to test a custom helper like takeFirst? We've followed the same pattern as above. I've been trying to pattern our test off of https://github.com/yelouafi/redux-saga/blob/master/test/sagaHelpers/takeEvery.js.\n. ",
    "ekeric13": "@nibblesnbits \nThe code @Andarist has above is what you are looking for\nfunction* takeFirst(pattern, saga, ...args) {\n  const task = yield fork(function* () {\n    while(true) {\n      const action = yield take(pattern);\n      yield call(saga, ...args.concat(action));\n    }\n  });\n  return task;\n}\n\"Call\" blocks while \"fork\" does not block. So you can just take the takeEvery code (which is found in the api):\nfunction* takeEvery(pattern, saga, ...args) {\n  const task = yield fork(function* () {\n    while (true) {\n      const action = yield take(pattern)\n      yield fork(saga, ...args.concat(action))\n    }\n  })\n  return task\n}\nand replace fork with call.\nPersonally I don't use a helper for takeFirst but simply a vanilla saga pattern.\nfunction* watcher() {\n  while (true) {\n    const action = yield take(pattern);\n    yield call(saga, action);\n  }\n}\n. ",
    "tgevaert": "For anyone finding this pattern from a google search, be aware that the above takeFirst implementation matches the older style takeEvery helper functions from pre v0.14.0.  (See the changelog\nIf you're using the newer style\nimport {takeEvery} from 'redux-saga/effects';\n...\nyield takeEvery(...)\n...\nImplementing takeFirst as above does not get invoked the same way.  You need\nyield* takeFirst(..)\n(note the *) otherwise takeFirst will block.. ",
    "Amareis": "So, may be we need it in effects? I don't see why it cannot be included into library.. @Andarist your code in latest message doesn't run, seem to fork return not a function, but just effect in current redux-saga version.\n```js\nimport { fork, call, take } from 'redux-saga/effects'\nexport default fork(function* (pattern, saga, ...args) {\n    while(true) {\n        const action = yield take(pattern)\n        yield call(saga, ...args.concat(action))\n    }\n})\n```\n```js\nimport takeFirst from 'utils/takeFirst'\nexport default function* locationRootSaga() {\n    yield all([\n        takeFirst(LOCATION_CHANGE, onLocationChange),\n    ])\n}\n```\nuncaught at rootSaga \n TypeError: (0 , _takeFirst.default) is not a function. Yeah, I already did it in my code and this works perfect, TY. But is this helper will included into library?. How about takeEvery? Is it works as expected with channels?. ",
    "tkvw": "\ud83d\udc4d, what about takeEarliest?. I thought about it bit more and this does not work ofcourse. So please ignore. . ",
    "jacobbuck": "takeLeading?. Shameless plug: I've just published a module which gives you saga helpers for spawning unique sagas. Check it out: https://github.com/jacobbuck/redux-saga-uniq. ",
    "tomoyukim": "@Andarist Yes. I've almost finished on my local and greatly appreciated a little more wait. I'll rename the helper with takeLeading. Thank you.. @SmirnovW No problem! Thank you.. I've finally been able to create PR for takeLeading. Thank you very much for waiting long time. . Thank you for your positive and kind feedback.\n\nIf we can come up with a better name I would be glad to merge this addition.\n\nAnother idea comes to mind is takeExclusive or takeExclusively because I think it looks like somehow mutual exclusion. What about this?\nI've tried to write code with fsmIterator referring another take* helpers based on my above snippet but I feel your implementation is better than me. So, I'll try to rewrite it with your idea.\nBTW, I guess I need to include testing and maybe document when I create PR. It seems contribution guid is under discussion according to https://github.com/redux-saga/redux-saga/issues/1287. So, would you let me know what I should do for the PR?. OK. Thank you for your support. I'll prepare for the PR.. All right. Thank you for your update. I'll improve my local branch with it. . @Andarist I've created PR for takeLeading as following another discussion. Thank you very much for your great support and waiting.. @Andarist Thank you for your review and feedbacks. I've tried to improve them. Would you check them at your convenience?. ",
    "justgeek": "@SmirnovW You did not sound demanding. Some people just don't understand simple stuff properly :) (Even with a smiley). @SmirnovW You did not sound demanding. Some people just don't understand simple stuff properly :) (Even with a smiley). ",
    "thorlukasz": "Is the build with takeLeading released on the npm?. Thanks so much. Is there any scheduled release date for this release :) ?\nOn Thu, Jun 14, 2018 at 12:59 PM, Mikhail Shustov notifications@github.com\nwrote:\n\n@thorlukasz https://github.com/thorlukasz https://github.com/redux-saga/\nredux-saga/releases/tag/v1.0.0-beta.1\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/589#issuecomment-397255348,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/Al4c20kQdqlUZmPQAPMvZpn1CfWsOBVaks5t8kIDgaJpZM4KXc6y\n.\n. \n",
    "restrry": "@thorlukasz https://github.com/redux-saga/redux-saga/releases/tag/v1.0.0-beta.1. @thorlukasz https://github.com/redux-saga/redux-saga/releases/tag/v1.0.0-beta.1. any action point for that?\nis it official recommendation to use put.resolve if we want to handle such errors in saga?. any action point for that?\nis it official recommendation to use put.resolve if we want to handle such errors in saga?. >Error boundaries are a quite a topic, regarding the fact that even React itself is struggling with it and potentially Fiber might be the answer.\nTo be honest my concerns are not about react itself (since errors during rendering should be handled on react level), but about errors in domain logic.\nCorrect me if I'm wrong, but Saga by default doesn't separate action types. And actions that are dispatched by user isn't the same semantically that are dispatched by app logic. it means that communication process relays on put heavily. so during put another forked process could throw as well. valid. now error bubbles for both put() and put.resolve(). There are some similar questions on SO. for example, http://stackoverflow.com/questions/40685288/redux-saga-upload-file-progress-event/40718234. closed in favour of https://github.com/redux-saga/redux-saga/pull/1454 .  implemented in https://github.com/redux-saga/redux-saga/pull/1464. it should work. probably the problem is in gelococation plugin itself. for example https://github.com/transistorsoft/cordova-background-geolocation-lt/issues/267. @younesmln may I assign you to this issue? . what exactly could be tested here?\nif we don't run saga, but just make test as in  https://github.com/redux-saga/redux-saga/blob/master/docs/advanced/TaskCancellation.md\njs\nconst task = createMockTask()\nfunction* saga() {\n    yield cancel(task)\n}\n// the only test that we can do is \nassert.deepEqual(gen.next().value, cancel(task))\n// and probably add check that cancel(task) or join(task) don't throw errors\n. the open question is should we support the same behaviour for returned values? if generator finishes with effect descriptor, like return call(..)  we  will receive {done: true, value: call(...) }. should we interpret it (as for mentioned yield call / yield (() => call(..))) or should they get returned to the caller as is?. yes, that's easy to fix in user land, but there is undocumented inconsistency in yield and return behaviour. at least some ppl expect them to handle nested effects in common way https://github.com/redux-saga/redux-saga/issues/1012\nas for me - I'm not sure what's desired behaviour for such case and probably keep API without changing, just update docs. so the only action point here is add notice in the docs that we shouldn't use call / fork / take* at the same time. correct? that could be done in https://github.com/redux-saga/redux-saga/issues/1478. what's your idea behind that plugin?\nwhat kind of information it has to log?\n\nplace where effect was created?  that'll work for errors that occurs during calling effect creator, but won't work if error occurs in saga's body \n``js\nfunction* a(){\n    yield call(() => unitilisedVariable()); <- can be logged as error whencall` effect was created\n}\nfunction* b(){\n    unitilisedVariable() <- cannot be identified, since occurs not in effect creator. what should be included in error stack in that case?\n}\n\n```\n\n\nor place where saga function was created?\njs\nfunction* a(){\n     unitilisedVariable() <- now we can add in stack trace info where function a* was declared\n}\n\n\nboth ?. I started working on the plugin https://github.com/restrry/babel-plugin-transform-redux-saga-source\nbut still open for new ideas and need help to integrate it in redux-saga itself. extractable modules with dependencies on redux-saga\n\ndelay (moved from utils) - depends on CANCEL symbol from redux-saga\nis depends on TASK & MULTICAST symbols\nchannel depends on utils, symbols, scheduler, matchers\n\nsome modules could depend on symbols. so either we create circular dependency between modules or we extract symbols in a separate package as well\ncould be extracted without lots of changes\n- scheduler\n- buffers \n- matcher\n. @jeffvandyke  plus there was a request to make is public https://github.com/redux-saga/redux-saga/pull/1262\n@shinima I'd prefer to have small packages\nalso @shinima should we make effectTypes public? to simplify such cases. merged in https://github.com/redux-saga/redux-saga/pull/1557. moved under https://github.com/redux-saga/redux-saga/issues/1478. join(...task) and cancel(...task) were deprecated in https://github.com/redux-saga/redux-saga/pull/1527/files. join(...tasks) and cancel(...tasks) were deprecated in https://github.com/redux-saga/redux-saga/pull/1527/. @borovik96 custom effects topic is progress, but I suspect you can implement it right now  with emitter option https://github.com/redux-saga/redux-saga/blob/master/packages/core/test/middleware.js#L105-L113. @Andarist @shinima what could be possible action points for this issue? in this discussion were mentioned 2 possible solutions:\n- we can create custom effect for asyncCancellation (for instance cancel.resolve(), similarly to put.resolve()). that adds  more questions - should we have race that supports async cancellation, for  example.\n- it could be resolved in user land as long as we provide users custom effect api.. you are right about mainTask._isRunning, but exposing just mainTask won't solve problem completely, since toPromise reflects task.isRunning state.\nplus as I remember mainTask reflects status of iterator and you pointed out that sometimes we can have weird status for it https://github.com/redux-saga/redux-saga/issues/1399#issuecomment-381494908 \ntbh dunno what's the best option here. join(...tasks) was deprecated in https://github.com/redux-saga/redux-saga/pull/1527/files. I'm using next pattern in my projects, that's kinda 2nd version\njs\nfunction* safe(effect) {\n  try {\n    return { result: yield effect, error: null }\n  } catch (error) {\n    return { result: null, error }\n  }\n}. @shinima . makes sense, I added a note to CHANGELOG.md https://github.com/redux-saga/redux-saga/pull/1700/commits/473cabf70c8be46780a511fabe3eaf4640bf6fb8. is it a real problem? even if we assume that you generate 1000 effects/ms:\njs\nconst msPerYear = 31536000000\nconst effectsPerMs = 1000\nconst overflowIn = Number.MAX_SAFE_INTEGER / (msPerYear * effectsPerMs)\nconsole.log(overflowIn) // 285.616 years\nthe number will overflow in 285 years.\nplus such a simple approach helps to represent the sequence of effects in human-readable manner. @SeregaSE sorry for delay with review. is there any chance that you have time to update PR?\n. @SeregaSE yes, but as I can see your repo has outdated master. you need to do next:\n- rebase your repo master against redux-saga master\n- rebase your branch against your repo master\nnow all those saga helpers are living in a separate file https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/io-helpers.js. @SeregaSE I think that's a good idea. was removed in https://github.com/redux-saga/redux-saga/pull/1464/files. that instanceOf check should have been removed https://github.com/redux-saga/redux-saga/pull/1398\nand beta-v1 contains those changes https://github.com/redux-saga/redux-saga/blob/v1.0.0-beta.1/packages/core/src/internal/proc.js#L345-L346\nanyway I've just added test case for it https://github.com/redux-saga/redux-saga/pull/1517\n@ggarek thank you for such a good report, really appreciate it and wish we had such reports every time \ud83d\ude04 . 1. firstly, we need to decide what information we want to show for user. imho, that should be effect + task information in case of error, since exception could be thrown from effect creator and from task body.\ndeciding on content, we can format error as we want.\n2.\n\n\nis this technique useful for us?\nwould it be possible to hook into react-error-overlay with our errors?\n\n\nI'll check and get back when PoC is ready\nthanx for feedback!. @Andarist could you check the current version? I added example that you could run with npm run error-demo (could be deleted before merge, also clean up package.json)\noutput for the current version\n- sync error in put effect\n\n\nerror in call effect\n\n\nNotes:\n- if we don't show effects for the whole failed sagas stack it could be hard to understand which effect created the failed task (especially if we have conditions in the code or race. on the other hand, saga shouldn't be so huge to have such a problem)\n- we format failed saga stack and log it only when error bubbles to the root, probably we should just update sagaStack  while error is bubbling and let user decide what to do with error stack (imho, sagaStack should be provided to users, in our app we use it to report error in sagas)\n- I also prefer to simplify approach with naming & meta info and get rid of  getMetaInfo\nregarding:\n\n\nis this technique useful for us?\nwould it be possible to hook into react-error-overlay with our errors?\nAdditionally we could list sagas that got cancelled because of the error (siblings of the failed top most saga in the tree).\n\n\nstill working on it, could be done in follow up requests. > We should log it whenever detached or root saga fails - you could very well mean the same, just thought this needs clarification, so we are on the same page.\ncorrect\n\nIf it would bring more complexity than it is worth, \n\nthe cheapest way that I seen could be to use Symbol to extend error object with custom data and after formatting saga stack pass 2 values in userland - error object and formatted saga stack as string. other ideas that I thought about require significant changes in the proc.js, but I'm still not so comfortable with its source code. current implementation doesn't show location for effects created via fmsIterator, there are several possible solutions:\n- show place where effect was emitted (requires changing runForkEffect logic, since it doesn't receive original effect descriptor)\n- show just taskIterator name, but since runForkEffect is used for both iterators & generators, we have to change meta calculating process, something like \njs\nconst meta = taskIterator.name ? { name: taskIterator.name  } : getMetaInfo(fn);\n~not sure what is preferred option~\nimplemented 2nd option.\noutput without babel-plugin\n\nwith babel-plugin:\n\n. > Need to check out how React handles this without babel plugin and with it, and what benefits jsx-self gives to the error output.\nif I got correct jsx-source adds location information, jsx-self returns component descriptor itself, could be useful if we wanna get failed effect arguments, for example\n\nI'd like to re-check if we could somehow omit passing those meta objects around and maybe pass something else around that would already be tied to meta, like this __self or something.\n\nI don't like how we handle meta either, probably you have idea how to improve the code\n\nThis might not be possible though or would rely on babel plugin entirely and probably babel should only enhance our error messages and not be a requirement for them as the cost of having this in runtime seems to be negligible.\n\nPlugin should be used in dev mode only, so don't think that affects prod runtime a lot.\nI'd say that current feature state is MVP enough to test it, clean up a bit. I'm planning to write tests after code review\nnext PRs could be \n- improve DX with pause on exception\n- support react-error-overlay. @adipascu from comment above:\n\nThere is no way though for you to \"catch\" uncaught errors from saga - because they are thrown asynchronously - if you want to really handle them you need to put appropriate try/catches in your sagas.\n\nso you can catch errors with onError hook and do whatever you want - show error message, log error stack, send error stack to any error tracking service etc.. afaik the action shape is stable now, so you can use this property for checks\nprobably it makes sense to add is.sagaAction function as a part of @redux-saga/is? . usually in tests https://github.com/redux-saga/redux-saga/blob/master/packages/core/test/interpreter/effectMiddlewares.js\nand docs https://github.com/redux-saga/redux-saga/blob/master/docs/advanced/Testing.md#effectmiddlwares. I'll close the issue due to inactivity, feel free to reopen. having a reproducible case is highly appreciated. I'll close the issue due to inactivity, feel free to reopen. having a reproducible case is highly appreciated. nope. that's kinda template slot https://github.com/redux-saga/redux-saga/blob/master/packages/babel-plugin-redux-saga/test/index.js#L29. seems to be answered  . @Andarist  addressed + refactored. \ud83d\udea2 . folks, would you mind adding  runable case to reproduce the problem as the original issue author did? . not yet, requires additional investigation.\nto open them in editor we need server (or middleware)\nto open in devtool sources tab we need to map file path from message to file path from sources tab. that's bundler dependent part. for example, webpack, builds file path in the next way webpack://{filename}, also that part is configurable on bundler level, so we can't predict exact prefix/schema.\nanyway I'm continue working on that investigation, probably we can do that later. @akinnee did you resolve the original problem? . @shinima there is an example with similar setup https://codesandbox.io/s/7z8pl8jl11\n@Andarist  correct me if I'm wrong\nif backgroundTask is detached process  then genFn will have isRunning === false state \nif backgroundTask is non-detached then  genFn tracks backgroundTask and waits for it to finish. . as @Andarist noticed we have 2 different delay functions across code base & documentations. \nimho, delay from effects is part of api, delay from utils is internal thing. So probably that tutorial should be changed to use another function that returns a promise, since the whole tutorial explains how redux-saga can handle both effects and promises. @IvanJov for example, instead of importing delay from utils, we can define function\nconst delay = (ms) => new Promise (res => setTimeout(res, ms))\nnow referring to it, in context of the tutorial, makes sense. . \ud83d\udc4d  from me\n. 1 suggested approach works, but  actually it does the same thing as module: false. isn't it?\n2 webpack.config.js is used here. I'll close the issue due to inactivity, feel free to reopen. having a reproducible case is highly appreciated\n. @Andarist should we create an umbrella ticket to collect all cases of incompatibility in the docs? . how do you see that it's still running? there is an example https://codesandbox.io/s/0p4800k5wv\nif you run js file you will see in console that incrementAsync is logged only once and not cancelled not logged at all\nregarding your question\njs\nfunction* saga(){\n  const task = yield fork(....)\n  yield take('CANCEL_FORKED_TASK_ACTION')\n  yield cancel(task)\n}. what version of redux-saga do you use? it was removed from v1-beta. could you try to use call instead?. updated. @Andarist OTOH if you need to assign several props you can use. or we can provide such a helper\njs\n[\n  ['a', 1],\n  ['b', 2]\n].forEach(([key, value]) => setContext(key, value))\nbut then for parity we need to support getContext(['a', 'b]). @Andarist by default node v10.0.0-v10.2.x are shipped with npm 5.6 https://nodejs.org/en/download/releases/\nwe can add more sophisticated logic to run our test in different environments  or run all test only on node v10.3 with npm 6. whdyt?. I suspect Travis made the latest node release (10.3.0) available\nnode v10.2.1, npm 5.6.0  \u2705  https://travis-ci.org/redux-saga/redux-saga/jobs/383595522\nnode v10.3.0 npm 6.1.0  \ud83d\udd34 https://travis-ci.org/redux-saga/redux-saga/jobs/387408815\nas I can see the latter build was run with npm 6.1.0, so we need to figure out what causes the problem.\nlog with node v10.3.0, npm 6.1.0 (installed via n) \nnpm i\nnpm ERR! asyncWrite is not a function\nnpm ERR! asyncWrite is not a function\nnpm ERR! pna.nextTick is not a function\nfor now I'd just make master green. \ud83d\udc4d for option-3.\npros: no breaking changes. and if we need add some addition logic (in future) for getting/setting those flags, we already have isolation from external api.\nthe only remark - does it make sense to rename mainTask.isRunning -> mainTask._isRunning to have  make them more consistent? . regarding naming - my confusion was about having booleans with similar semantic task._isRunning and mainTask.isRunning , but task.isRunning() is a method at the same time.\nwe can leave everything as is, but I'd prefer to have any kind of unification for naming :). there are some external consumers of asEffect. it seems to be used more as is.effect.fork(..\nhttps://github.com/jfairbank/redux-saga-test-plan/blob/master/src/expectSaga/parseEffect.js\nhttps://github.com/jfairbank/redux-saga-test-plan/blob/master/src/expectSaga/provideValue.js\nso if we delete it, we need to provide an alternative solution. that breaks encapsulation, imho we should provide a helper that hides effect shape . @SeregaSE \nI faced the same problem https://github.com/redux-saga/redux-saga/pull/1546,\njest already merged a fix, lets wait for new version https://github.com/facebook/jest/pull/6792. closed as all points from PR title are done . \ud83d\udc4d overall. probably will be fixed in next version of TS. related PR https://github.com/Microsoft/TypeScript/pull/24897. should work with new typings (\"redux-saga\": \"^1.0.0-rc.0\" version)\nsignature does not match\n\nsignature matches\n\n. jfyi It can be, I did another example with it, but adding 2 templates it's too much :). @Andarist done. I'd say using takeMaybe is a special case and advanced concept, at least I haven't found any issues on  Github requiring that all compatibility. \nas I understand usually users don't expect END or other low level things to leak it their code. \n1 for all getting result as [END, resolvedValueOfPromise] would be surprising, because take itself never returns END as a result. so it means users have to filter results. \n2 the same for race. take an example with \njs\nconst {timer, action} = yield race({\n    timer: delay(..),\n    action: take(...)\n})\nnow to distinguish between the results we have to write something like\njs\nif(action is END) {\n     // actually other sagas finished on END, so not much to do here\n     return\n}\nif (action) {\n //   handle action\n}\nif (timer) {\n //   handle timer\n}. I only read about `lifting` concept from Haskell, but seems that's a bit different (unwrap value, apply function, wrap). \nhttps://stackoverflow.com/questions/2395697/what-is-lifting-in-haskell\nin js it similar to something tojs\nconst boxA = {value: 1}\nconst boxB = {value: 2}\nconst lift = (f, ...args) => ({\n   value: f(...args.map(i => i.value))\n})\nconst sum = (x, y) => x + y\nconst sumBox = lift (sum, boxA, boxB)\n``\n. \ud83d\udc4d forenhancePut`. resolved in https://github.com/redux-saga/redux-saga/pull/1503. agree. JFYI that behaviour was by design until v1. that's one of breaking changes for v1 https://github.com/redux-saga/redux-saga/releases/tag/v1.0.0-beta.0\n\nerrors thrown during put execution are no longer caught and swallowed, you need to catch them manually\n\ndiscussion is here https://github.com/redux-saga/redux-saga/issues/632. @shinima would you like to work on it?. delay is just a wrapper around setTimeout. https://github.com/redux-saga/redux-saga/blob/5702affdcd681e5aee1371ba68cc061af10078bc/packages/core/src/internal/utils.js#L99-L108\nare you sure that there are no page reloads or page is still in focus ?. ok. ok for me. btw I like the table in the PR header. should we add it as part of PR template?. what is deviceInfo ? why you call it as yield deviceInfo()? according to error message that's the error occurred during this call . the problem is that we don't check if array contains only valid patterns. so when user calls \nyield actionChannel([undefined])\nwe just add a taker with passed array https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/proc.js#L638-L652\nbut when use call put() channel throws trying to call taker https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/matcher.js#L4\nso actually error happens during the put.\nwe can fix the problem  if on top of @shinima changes add a check that array contains valid patterns\njs\n//@redux-saga/is\nexport function pattern (candidate) {\n  if(candidate){\n    if(string(candidate) || symbol(candidate) || func(candidate)) return true\n    if(array(candidate) && candidate.every(pattern)) return true\n  }\n  return false;\n}. imho we shouldn't export delay from utils to avoid confusing and implementing it in user land (if needed) shouldn't be a problem. helpers create not corresponding effects - takeLatest returns fork, for example.\nI think the main reason to introduce that change was a bit confusing nature of delay for newcomers. before you have import 2 different functions from saga and use them in right order, you need to understand that delay returns a promise, that saga can handle promise correctly etc.\n```js\nimport {delay} from 'redux-saga'\nimport {call} from 'redux-saga/effects'\nfunction* (){\n    yield call(delay, 2000)\n}\n```. @shinima @Andarist any actions points on this?\n. ok, then we need to add it as v1 as a part of breaking changes . @localjo there is a list of issues for v1 milestone \nI'd say that's doable in ~1-2 months.\nbtw that logging was removed in v0.16.0. I'll close as there are no possible actions points here. @Andarist @shinima ping. js\nexport const fetchVideoCategories = fetchEntity.bind(null, api.buildVideoCategoryRequest, categories);\nis bound, but it's a generator function, not ordinary function, in your case.\nmost likely you call it in another saga as\njs\nyield call(fetchVideoCategories, amount)\nyou need that return because otherwise call doesn't receive generator functions and cannot run it.\nI'd say that approach make sense and could work in your case, but pay attention to type of function that you work with. afaik you cannot unbind a function (for plain js bind method). why not use the original function instead of unbinding? . in my project I usually restart the whole app on logout to be sure that that are no stale state that could be not relevant anymore.\nregarding your question, you can adopt example from https://github.com/redux-saga/redux-saga/blob/master/docs/advanced/TaskCancellation.md\njs\nfunction* yourSaga() {\n  while (true) {\n    yield take('LOGIN')\n    const pollingTask = yield fork(pollingSaga);\n    yield take('LOGOUT')\n    yield cancel(pollingTask);\n  }\n}. what npm version do you use? cannot install deps in this branch. @shinima I had a problem as well. then I switched to node@10.1.0 and npm@5.6.0 and it resolved the problem. forgot to add a comment here and investigate - too busy on work now. switched back to node 10.8.0 and got this error https://github.com/npm/npm/issues/17444\nremoving package-lock.json and npm i fixed the problem. \n@shinima could you try to do the same?. I think we should add it to .gitignore file then. do we have .npmrc?. closed due to inactivity. fell free to reopen with a reproducible case. there are several leftovers for v1. https://github.com/redux-saga/redux-saga/issues?q=is%3Aopen+is%3Aissue+milestone%3Av1\nmean time probably we could release beta-v2. @Andarist ?. closed due to inactivity. seems that the intention was to cover a case when fork returns any kind of effect that we can interpret, especially a  promise and an iterator.\nhttps://github.com/redux-saga/redux-saga/blob/433c333053ba5b1a3187406b09078e9e4ee99e73/packages/core/src/internal/proc.js#L334-L336\nat least such a test for a promise was added here. https://github.com/redux-saga/redux-saga/commit/3c93f01b0ea1a866e01ca3e06fde15722fa3df7c#diff-aef8708b040ddfd27e50ad40d8b3e146R473\nregarding the code \njs\nreturn makeIterator(() => ({ done: true, value: result }))\nthe test failed because effect from return expression is not interpreted by proc.js. related issue https://github.com/redux-saga/redux-saga/issues/1012. @Andarist sounds legit.. @Andarist sure thing. @Andarist Unfortunately, no. And we didn't have tests for it. I'll add some integration tests. Where should we keep them? In core or babel-plugin package?\nright now I just get rid of Symbol usage in babel-plugin. any action point on it?. I checked our source code and it seems that saga catches an error here https://github.com/redux-saga/redux-saga/blob/63dfb94ebfaadf1b59a3e4029a1fa71c574307a4/packages/core/src/internal/proc.js#L262-L266\nbut because it handles an error in another function call https://github.com/redux-saga/redux-saga/blob/63dfb94ebfaadf1b59a3e4029a1fa71c574307a4/packages/core/src/internal/proc.js#L266 , browser engine (Chrome) ignores that expression, so error remains unhandled \nhow can we fix that?\n- make the whole process async - no, as it breaks current contract\n- TCO - no,  it is supported only is Safari\n- switch from recursion to an iteration - probably, but that could require significant code changes. > Alternative solution would be to use some kind of special completion value but that would force us to return each sync value (instead of passing it through completion callback) and probably would make handlers like runPutEffect more complicated\nI considered this option, but that approach\n-  complicates intrnals, as we need to use different approaches for sync and async effects\n- will be confusing for effect authors when we introduce custom effects\nregarding the problem with fork model. we have a failing test https://github.com/redux-saga/redux-saga/blob/master/packages/core/tests/interpreter/takeSync.js#L522\nhow fork model works without changes\nfinishes s3\nfinishes s1\nfinishes s2\nhow fork model works with changes\nfinishes s3\nfinishes s2\nfinishes s1\nand it even looks like more logical sequence, but I'm not sure we don't break any users code.\nas I understand test fails due to internal scheduling, but not entirely understand why - all steps are synchronous.  it's easy to fix test with running it as\njs\nfunction* root(){\n  yield fork(s1)\n}\nmiddleware.run(root)\ninstead of\njs\nmiddleware.run(s1). >  BTW does your queue ever becoming bigger than 1?\nno. that's was just easier for brains to consider it as a 'queue', actually it has 0 or 1 element inside. we should switch to ordinary variable later, that's a minor. @Andarist I updated the branch to get rid of an array.\nIndeed I was able to fix the failed test with adding in https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/runSaga.js\ndiff\n+ suspend()\nconst task = proc(env, iterator, context, effectId, getMetaInfo(saga), null)\n+ flush()\n. @Andarist I'm a bit confused, since it's absolutely the same fix as https://github.com/redux-saga/redux-saga/pull/1628. @Andarist completely agree from this point of view, will put on block until https://github.com/redux-saga/redux-saga/pull/1628 is merged. closed due to inactivity. feel free to reopen. @Andarist @shinima ping. try to update to the latest version v1.0.0-beta.2, that should be fixed\n\n. @lengzuo still reproducible after update? . actually what's left - update the docs, examples and review them, hope we finish with it soon \ud83d\ude03 there are no  major changes since beta.2, so you can start using it. draft of changelog https://github.com/redux-saga/redux-saga/pull/1613. discussion https://github.com/redux-saga/redux-saga/pull/1546#discussion_r222030376 . closed to have all related discussions in one place https://github.com/redux-saga/redux-saga/issues/1592. @Andarist I've added pre-commit check for my working project \njs\n\"scan-circular-refs\": \"madge --no-color --circular .\",\non the whole if rollup fails a build with circular refs - the package cannot be published, so probably we needn't another tool for such a check . > Obviously previous version (with finally) was swallowing errors\nnot sure that it does\n```js\nfunction broken () {\n  try {\n     throw new Error('oops')\n  } finally {\n    console.log('finally')\n  }\n}\ntry {\n  broken()\n} catch(e) {\n  console.log('gotcha', e)\n}\n// finally\n// gotcha Error: oops\n```\nrelated discussion https://github.com/redux-saga/redux-saga/pull/622#discussion_r87454393. I saw similar problem debugging https://github.com/redux-saga/redux-saga/issues/1592\nprobably it's not the same thing, but - when max error call stack... error bubbles to catch statement, it was caught, but if I called another function to handle an error sometimes it was ignored (depending on code sample).. addressed comments, pls have a look again\n. that's a bug. should return passed value. your use case looks like this?\n```js\nfunction* genA(){\n  try {\n    console.log(\"1\");\n    yield delay(500);\n    console.log(\"2\");\n  } catch (error) {\n    console.error(\"3\");\n  } finally {\n    if (yield cancelled()) {\n      console.log(\"CANCELLED\");\n    }\n  }\n}\nfunction* main() {\n    const task = yield fork(genA)\n    yield delay(100)\n    yield cancel(task)\n}\nwhat we can add to this doc?\nhttps://github.com/redux-saga/redux-saga/blob/master/docs/advanced/TaskCancellation.md. we already had some sporadic problems with specifying soft node/npm versions. could you pin the version to `11.0.0`?. this is an error in async function, so try/catch cannot help here. but you can provide a hook `onError` in [createSagaMiddleware](https://redux-saga.js.org/docs/api/#createsagamiddlewareoptions) for errors bubble to the root saga, where you can handle an exception. keep in mind that if error bubbles to the root - the whole saga tree is cancelled. closed as no actions points are possible. logic that could throw in during cancellation controls the resource management, so we can leave a system in unpredictable state. basically there are 2 options:\n- swallow an error and probably log it. using `onError` seems to be a bit awkward, as end user needs to distinguish between  error bubbling to the root and other 'not critical' errors.\n- re-throw an error. breaking changes, but forces users to have safe `finally` block.. I'm on vacation for next 3 weeks, so feel free to make any changes required for v1 release . closed as no actions points are possible. root saga restart will reset internal state of it and its child sagas\nanother alternative is to write your safe `call` wrapper, which also could do reporting\nhttps://github.com/redux-saga/redux-saga/issues/1250. closed as there are no action points here. @Fs00 you mean this code doesn't catch an error?js\ntry{\n  yield all([fork(a), fork(b)])\n} catch(e){\n```\n\nNote that though fork effects are nested in an all effect, they are always connected to the parent task through the underlying forkQueue. Uncaught errors from forked tasks bubble to the parent task and thus abort it (and all its child tasks) - they cannot be caught by the parent task.\n\nhttps://github.com/redux-saga/redux-saga/blob/master/docs/advanced/RootSaga.md#nesting-fork-effects-in-all-effect. ts doesn't support this and seems isn't going to add support. issue in ts repo https://github.com/Microsoft/TypeScript/issues/2983. is myFsFunc a GeneratorFunction ? it will handle select correctly in this case . take allows you specify a custom matcher, so it should be sufficient https://redux-saga.js.org/docs/api/#takepattern\njs\nyield takeLatest((action) => action.type === 'ACTION_NAME' && action.payload.id === 1). hard to say the reason without an example. for now -closed due to long time inactivity. feel free to reopen . @Andarist actually tests are correct. let's look at the next example:\n```js\nfunction* sagaA(){\n  yield call(sagaB);\n}\nfunction* sagaB(){\n  undefinedIsNotAFunction()\n}\n``\nhere error happens duringsagaBexecution, but current code says that error happens insagaBduring effect invocationcall(sagaB).\nso we should log info about crashed effect *only* for first error stack (*not* the first effect)\nhere we solved it with checking if error is already wrapped\nhttps://github.com/redux-saga/redux-saga/pull/1695/commits/be2e862bc0df84ccf3a05f689a8bf0fca866f7a0#diff-ecefd26543e2e37544ae6d726d23b588R179. @Andarist my only concern is singleton usage, as it's another source of state, which we have to control manually. but seems that approach simplifies code and does the trick, so go ahead \ud83d\udc4d . and keep in mind if error bubbles to root saga and you haveonErrorcalled --> the whole saga tree is terminated, so either yourdispatchis used only for changing redux store or your action handler should be run asspawneffect. Usually, I consideronErroras a fatal situation and don't use any redux semantic inside . seems that we should add it in docs, if we don't have such notices yet . All errors cannot be handled just by one error handler, as their context and nature are different.\nSay network error could be handled locally, but runtime exception shouldn't.\nhttps://blogs.msdn.microsoft.com/ericlippert/2008/09/10/vexing-exceptions/\nYes, we can add a wrapper that receives all exceptions from code (say, for reporting, not for handling), but this wrapper won't have runtime context information. And anyway, users will have to do them manually, which is not different from the situation we have today. Correct me if I'm wrong.. added some docs https://github.com/redux-saga/redux-saga/pull/1721 \ncan we add something else?. done. closed as there are no action points here. @edzillion let's clarify what kind of documentation could be useful here. recommended approach to handle async exceptions in saga?\nbecause as I can see the initial question was about handling error forcalleffect, that's blocking operation and usingtry/catchshould be sufficient.\nfor non-blocking operations it's a bit harder, as race there could be a race condition and try/catch is already passed when exceptions rose. thereforespawnedorforkedsaga should be safe. you can use the approach that  @tichaonax suggested above or implement your own.\nactually, we have a lot of questions about error handling, thus it's helpful for us to know what is unclear from the docs. are you sure that problem is in this snippet? \naction fromtake` test shows it should work as expected https://github.com/redux-saga/redux-saga/blob/master/packages/core/tests/interpreter/take.js#L5-L119 \nprobably you can add failing test case in your library, it would help us to debug. if you update package, it should work. the problem right now that saga cannot recognize that you yielded effect and returns object as is. https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/proc.js#L144-L149. imho even mentioning about mainTask is leakage, so I'd go with this sophisticated condition in cancel with comment why and what we check here.\neven if we need to provide access to mainTask in future (say, for custom effects) it's not a braking change. you mean an access to buffer? if someone needs one they can pass buffer as a parameter, so they already have an access to its isEmpty. agree, but isEmpty is not related to channel functionality directly + it's advanced functionality, probably you won't have problems with the setup. seems the comment solves the problem. Already forgot about this my branch \ud83d\ude04  Finished the work, need your review. would you mind to review again? now only real-world uses saga-monitor-example. also I had to add build step for saga-monitor. \nas saga-montor-example uses other packages I disabled parallel build (on my laptop build time increased from 9.6s to 14.4s, more or less is ok).\nwhen we switch to https://github.com/redux-saga/redux-saga-devtools we can get rid of saga-monitor-example. if you test sagaA that calls sagaB, approach and links to libraries are described in https://github.com/redux-saga/redux-saga/blob/master/docs/advanced/Testing.md\nWith this approach, you don't need to mock anything at all.\nIf you do want to mock something, you can use jest's functionality  jest.mock('../path/to/module', () => ({ sagaB: .... })), if I'm not mistaken.. > Unlike takeEvery, takeLatest allows only one fetchData task to run at any moment. And it will be the latest started task. If a previous task is still running when another fetchData task is started, the previous task will be automatically cancelled.\nthe difference is described here (from link above). @aikoven would you mind to have look? . should fix https://github.com/redux-saga/redux-saga/pull/1745 . > it doesn't seems to work on the current version (1.0.0)\nseems it does https://codesandbox.io/s/5kz46zny7n\nSo you can use the same approach if it's working for you with the current version\n\nCan be used to run Sagas only after the applyMiddleware phase.\n\nit means that sagaMiddleware.run cannot be called before the saga registers its middleware via applyMiddleware(sagaMiddleware)\n\nMaybe this is a bad practice to END a saga in order to wait for it to be resolved?\n\nEND is useful when you have saga that is suspended with take and you want it to finish immediately.\nif you just want to wait until a task finishes - use task.toPromise()\n. @szb512 actually we aim to support both babel v6 and v7. later we will remove v6 when most projects drop its support\n@Andarist, @shinima would you mind to review again?. @Andarist let's release it. related discussion https://github.com/redux-saga/redux-saga/pull/1718#discussion_r250313519. would you mind to add a repository with the issue? I had a hard time bootstrapping React Native project from scratches.. Sorry, that's mistake in docs. Right now it works only with pattern. Need to support a channel as well\nhttps://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/sagaHelpers/throttle.js. would be great to try to implement it. ideally all effects should work in the same way . NOTE: we can add symbol no to extend saga effect descriptor. the most simple first step is add global symbol. agree, I've even checked how lodash-webpack-plugin  does it. but haven't tried to apply that technique.. On the one hand, we don't use name as independent property, but part of meta (code consistency). On the other hand, I'm not sure whether we need to create meta descriptor for mainTask (what's location in that case?). I looked through the proc code and not sure that's possible without refactoring, so I'd prefer keep that out of scope of that PR. didn't find that it was used somewhere, so renamed. had to wrap in meta  in sake of consistency, probably it's better to flatten meta completely (switch back to name & location properties). imho fixtures could be excluded completely\n1 we don't care about styles there, those are for machine, not for people\n2 I'd prefer don't touch them if we decide to change code style once. good catch. I wanted to support old node engines so avoided using es6+ syntax (redux-saga package.json doesn't contain any requirements for node version). make sense, but imho wrapping with Object.defineProperty makes code a bit more readable (for debugging, for example), so I'd stick to IIFE.. if it's less readable for other maintainers, I'll change the structure \ud83d\udc4d  . yes, that was done intentionally to unify approach. done. I forgot that wanted to add FunctionExpression. Done.\nfrom error-demo example\nbefore:\n\nafter:\n. I did it in earlier implementation, but found several places in our code base when people used expressions, like\njs\nfunction*() {\n  const result = yield call(foo) || {}\n  return result\n}\n// or\nfunction* () {\n  yield (foo? bar() : baz())\n}\nI don't think that's good approach, but seems that some people use it\nof course, we can try to get rid of expression support, that should simplify code. actually yes, if we're using Symbol. but in case of using fallback to string key is not so 'safe'. probably, that's a minor concern and we can return to the initial implementation and wrap only yielded values. unfortunately, using template mechanism leads to cryptic error if we process yieldExpression and use regenerator package at the same time\nbabel Expected type \"Expression\" with option {}. totally agree, changed. to do the trick just redefine createLocationExtender body to\n``js\n  function createLocationExtender(node, useSymbol, fileName, lineNumber, sourceCode){\n    const extendExpressionWithLocationTemplate = template(\n      Object.defineProperty(TARGET, SYMBOL_NAME, {\n          value: {\n            fileName: FILENAME,\n            lineNumber: LINE_NUMBER\n          }\n        });\n    `);\n    const extendExpressionWithLocation = extendExpressionWithLocationTemplate({\n        TARGET: node,\n        SYMBOL_NAME: getSymbol(useSymbol),\n        FILENAME: t.stringLiteral(fileName),\n        LINE_NUMBER: t.numericLiteral(lineNumber),\n      })\nreturn extendExpressionWithLocation;\n\n}\nand run any existing test containingjs\n    options: { presets: ['env'] },\n``. great explanation, I wish I could find that information before \ud83d\udc4d \n. the whole text explains how saga can be tested against promises, so I put link to utils. well, that's not bottle neck definitely, so will do  . if user throws null or undefined, why we can't just pass it toonErroras is?. is it compatible with version <3.5.1? I don't know why it was selected before. ok, got it. point was to have ability to use version frommaster`, but I see your concerns, so  I'll revert changes.\nnow there are 3 local dependencies:\n- redux-saga\n- babel-plugin-redux-saga (not published yet)\n- saga-monitor-example (not published yet). server.js and its dependencies are not handled with webpack.\nso other options are either CJS modules for those files or use node --experimental-modules (but require use .mjs file extension)\nwdyt?. ok. we could refactor it to object to simplify signature. yeah, I forgot to remove it :). \ud83d\udc4d { nextState, errorState, effect, stateUpdater } \ncould we do it as a separate PR?. Done!. I saw that comment https://github.com/redux-saga/redux-saga/pull/688#pullrequestreview-12891349 but haven't checked yet. I'll check the source code later and we can remove those checks from all helpers once. I added test for both pattern and channel finished with END, seems that it can be removed across the code base. \nwould you mind checking added tests are correct?. that's iterator's flag showing whether the iterator is finished or not. so no needs for changes. do we really need it? browser devtools can show Symbol correctly. any custom solution could achieve it with String(symbol). 1 @Andarist that was done intentionally, since if you use Symbol, you have Object.assign defined in your browser. and I didn't want to add additional check for Object.getOwnPropertySymbols existence\n2 implementation was borrowed from babel https://github.com/babel/babel/blob/2abd7839e16e3fa63fc381e3ec6ddd83efdf703e/packages/babel-helpers/src/helpers.js#L359 . should we delete the construction in this case?. it is case for kick off\nhttps://github.com/redux-saga/redux-saga/blob/2aa77c0856c6531392cb05d5dc939dc1a067426f/packages/core/src/internal/proc.js#L257. in normal flow isTerminate is being used in next callback, which receives the result of digestEffect. but when we kick off generator for the very first time we call next() without passing any result.\nso at the initial step arg, isErr are undefined ==> isTerminate will be called with undefined as well. well, actually we just received request to terminate, so probably you are right and it should be called should.... checked, also didn't find any cases, updated. why not to use hash to imitate named arguments (instead of working with positional ones as we do now)?. so we need to change our setup? otherwise we have to add that comment manually for all cases. stdChannel from src/internal/channel.js is channel factory. isn't it? dunno worth renaming it or not. what's the benefit of  changing  implementation to middleware ?\nas I can see only custom middleware should be implemented in this way . oops. forgot to remove promise. but I'll return original test back to avoid ambiguity. . I aligned the test with happy path version to  emphasise the difference between them\nhttps://github.com/redux-saga/redux-saga/blob/af4b1b41f6f336bb4668fe2be569819a5ca3ee62/packages/core/test/interpreter/race.js#L8 . I do like idea to extract effects from proc. just not sure that we should implement all effects via middleware api, as you noticed that adds complexity. \nif we want to provide examples how to write custom effects we can provide them as a part of documentation.. why using clone assume that we're using multicast channel / std channel? if lift expect only them to be passed as argument then we need to add such a guard check. don't we?. I see. but the current implementation doesn't tell us the only stdChannel could be passed in.. we have other channels defined in this file. probably we can just rename method to makeLiftableStdChannel. btw I didn't manage to find a test for such a case, should we add one?. oops. I should delete the whole file. it was used for testing purposes. should we add \"plugin:react/recommended\" only for examples folder?. didn't notice \ud83d\udc4d \nchanged test case . minor thing. should we use is.channel instead? and below we have some similar checks, when we could use more specific guards . unnecessary check, the second check covers that case. if we declare cancel as \njs\nfunction cancel(taskOrTasks = SELF_CANCELLATION) {\nthe comment is unnecessary . createAllStyleChildCallbacks won't work on empty array or object. should we add such a check there?. you can keep that one\njs\n// typings:expect-error\nyield join(task, task);\nand the same for cancel. no needs to cast to Boolean, it always Boolean https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/proc.js#L169. it still can be changed in user land, since effectRunnerMap is available via env. should we freeze object? or even the whole env. should we unify signatures across effects? sometimes we destructure it, sometimes use as is - it could be not obvious for newcomers that all of them have almost the same signature (except payload) eventually\n. have gut feeling that we need to change the order. callback is the last argument across the whole codebase. it cannot be undefined, since there is a default parameter for taskOrTasks. should we extract a function into another build-helper file?. should we create appropriate issue?. ok. let's then move the helper in one place. later we can migrate to other builder. why we need to call resetStyle manually for all the cases except addLabel?. are we going to reuse Formatter? imho implementation with inheritance a bit confusing. . after tomorrow's babel stable release we can start supporting only 7 version. Please use join(tasks)? \nthe same for cancel below. that's not a big deal. we can keep it as is. I meant, probably it could be confusing - for example, why we require to make a copy of array before passing to effect?. could be moved to symbol library if we decide that the current solution is ok. sure, should be deleted. that's an old hack to fix tests locally. case with iterator is covered here https://github.com/redux-saga/redux-saga/pull/1573/files#diff-ecefd26543e2e37544ae6d726d23b588R120 \nno needs to wrap in another iterator. only in babel plugin, ok I can change to test in sake of consistency. imho not clear how call is related to fork here. you mean that ppl could think that all effect behaves as call?. to try --> to try to. in sake of readability\njs\nconst SECOND = 1000\nconst response = yield retry(3, 10 * SECOND, request, data). result or --> result of\nthen --> than. as result, --> as a result. probably nitpick - from the first look is not clear that effect try to call fn again if the previous call threw an error. we could simplify a bit\nCreates an Effect description that instructs the middleware to call the function `fn` with `args` as arguments.\nIn case of failure will try to make another call after `delay` milliseconds, if number of attempts < `maxTries`\nWDYT?. imho that's not an effect per se, as it  has other lifecycle for end user (import - call - processing - return a result) and more over, users don't know about it, as it internal detail.. +1. imho message  call/apply/cps/fork/spawn: argument fn is undefined seems confusing as user calls a method, not all of them. note: that's actually a change in api. . I'we added one integration test for babel-plugin integration into core. probably that should be in core itself, requires some work for defining several babel configs (with and without plugin). we can. but then I'd switch all the examples to jest, I've added tap only for consistency . actually use case for them a bit different (at least now) \n1 onError - called once, when error bubbles to the root, provides info about error source. usually it's used in user land to get source of error and report them (logger is just another target!).\n2 logError - can be called several times, called for an error bubbling to the root saga + internal inconsistency errors (when try to cancel already cancelled task).\nprobably we should add a note about their different nature or remove one of them, but on the whole it seems that they have different use cases\nupdated:  there is another problem with onError we build saga error stack only when error bubbles to the root, so if user handles errors on their own (say try/catch on the upper layer), they don't have normalized saga error stack. what about such case, where we use use proc internally for iterable\n```js\nfunction root() {\n    yield all([\n      put({ type: 'FIRST' }),\n      function() {\n        yield take('FIRST')\n        yield put({ type: 'SECOND' })\n      },\n    ])\n  }\n. there is no `takeEvery`, if you add this test you will see that it fails, but this one works:js\nfunction root() {\n    yield all([\n      put({ type: 'FIRST' }),\n      fork(function() {\n        yield take('FIRST')\n        yield put({ type: 'SECOND' })\n      }),\n    ])\n  }\n. sounds legit. imho already hard to read. could we extract in a separate variable?js\nconst isRoot = false\nproc(env, iterator, taskContext, effectId, meta, isRoot, cb)\n``. imho shouldn't have default value. sounds legit. @Andarist ok, what about saga internal inconsistency errors? don't log them? . should I remove the whole description howretryis implemented under-the-hood? imho it's quite useful for understanding the saga principles on the examples . \ud83d\ude80 will experiment with it. I's suggest to make in another PR.\nI made it work with [changes](https://github.com/redux-saga/redux-saga/compare/update-docs...add-codesanbox-examples), just need to resolve some problems:\n1 codesanbox doesn't installdevDependencieshttps://github.com/CompuIves/codesandbox-client/issues/924 so I had to move all deps underdependenciesfield. \n2sagaMonitor` package is not published. we can switch to https://github.com/redux-saga/redux-saga-devtools or publish one from the example folder\nlink https://codesandbox.io/s/github/redux-saga/redux-saga/tree/add-codesanbox-examples/examples/async. react throws errors with https://github.com/facebook/react/blob/master/packages/shared/invariant.js\nexample with usage error:\nhttps://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOMTextarea.js#L44-L47\nexample with internal error:\nhttps://github.com/facebook/react/blob/master/packages/shared/ReactErrorUtils.js#L120-L124\nI'd also switch to check for internal inconsistency errors, as it's easy to miss error logs, especially in prod. but exception will force to prevent such errors in the app. this is  a nice feature, but most likely linter or build system will let you know that you try to import delay which is not exported by effect module. there at least 2 kinds of errors in React\n- in user component. can be handled by componentDidCatch. user can recover from error, report etc.\n- internal inconsistency in React. thrown as exception. user cannot handle it.\nfor me redux-saga onError hook is similar to componentDidCatch. not quite sure we should mix approaches. I'd throw an exception in case of internal saga error\n. ok, let's continue discussion in the related  issue. I'd merge PR. probably we can remove them. it's weird if someone passes not a function here. jfyi was added https://github.com/redux-saga/redux-saga/commit/2e53f31d40d79eed2d776c17a1a1a4b53be0fe7d. yes, I was going to throw here, but forgot as tests 'passed'. so we don't need this logic branch. do we?. the same question: is it okay to have a cb as not last argument? . we continue keeping tests in the core package?. should we update docs as well? \njs\nimport { cloneableGenerator } from '@redux-saga/testing-utils' . should we rename it to something like callback or continue? cont sounds not super obvious.\nwe pass cb inside https://github.com/redux-saga/redux-saga/pull/1660/commits/5cf3e27fe770c9a36576e4d4bc3c88cfce1adc72#diff-ecefd26543e2e37544ae6d726d23b588R210. seems new can be deleted :). ok for me. should we cover isCancelled/isAborted in those tests as well? . should mainTask have status filed as well for consistency?. cleanup should be done in the same test when you setup a  fake timer (as it was done before). yes, I must add the comment about it. \nright now there are 2 source of errors for next\n1 an exception passed as an argument. we will throw it into iterator and will catch it again. to remain stack trace we should reuse arg.\n2 an exception raised while resuming iterator, so we wrap it. is it used somewhere? . ok, will fix after https://github.com/redux-saga/redux-saga/pull/1703 merged. shouldn't it be a devDependency? . to test use add-codesanbox-examples branch name: https://codesandbox.io/s/github/redux-saga/redux-saga/tree/add-codesanbox-examples/examples/shopping-cart. for sure, it should.\nnow when I add it I can see that saga-monitor-example is not compiled and not ready to be consumed. need to figure out how to fix it (seems that there is no build step. should we add one?) . shouldn't we switch to https://github.com/redux-saga/redux-saga-devtools package?. probably we should remove error message assertion below . shouldn't it be a separate test? doesn't look like saga onError is optional:). \ud83d\udc4d . unfortunately it doesn't work as expected. for errors raised in helpers we don't have location, as effect is hidden in library code. for example, one of such cases:\njs\n  yield retry(3, 10, function() {\n    undefinedIsNotAFunction()\n  })\nas an alternative solution we can use\njs\nsagaStack.some(s => s.meta.location)\nwhich is a bit better, but still could lead to false positives.. I suppose so. when I added  a build step for  saga-monitor-example running npm run build started failing. from lerna docs\n--parallel\n...\nSimilar to --stream, but completely disregards concurrency and topological sorting,\nbut in this case we should build redux-saga before, as it's a dependency for example. we can actually, don't see a lot of value tho. most likely ppl want to use something more advanced, like redux-saga-devtools . @Andarist do you want me to finish work on this branch? . by whatever reason async/await after being processed by regenerator has path.node.generator === true.\nat the same time with env preset both async/await and function* methods are replaced by regenerator and don't have locations demo. @Andarist updated my comment. to test the case reference the original issue  . 1 we should add sandbox.config.json with template: \"parcel\" (it's a default for vanilla js). otherwise react template ignores babel config\njson\n{\n  \"infiniteLoopProtection\": true,\n  \"hardReloadOnChange\": false,\n  \"view\": \"browser\",\n  \"template\": \"parcel\"\n}\n2 we should switch from babel.config.js to static .babelrc, because condesandbox can work only with it. \nworking demo:\nhttps://codesandbox.io/s/oqq0w6kz76\nI can switch only error-demo example to static .babelrc, OTOH I don't want to introduce inconsistency . ",
    "rendomnet": "@Andarist will it get in release build?. @Andarist yeah I'm using it this way. And wonder will it move to release?. ",
    "crobinson42": "Hi there, I'm in the camp of \"still wrapping my head around sagas :-)\"\nBoth of these solutions seem to solve this need of \"take first/leading\", what's the difference in yielding fork and not here?\n```\nfunction takeFirst(pattern, saga, ...args) {\n  yield fork(function() {\n    while (true) {\n      const action = yield take(pattern);\n      yield call(saga, ...args.concat(action));\n    }\n  });\n}\nfunction* takeLeader(pattern, saga, ...args) {\n  while (true) {\n    const action = yield take(pattern);\n    yield call(saga, ...args.concat(action));\n  }\n}\nexport default function* rootSaga() {\n  yield all([\n    takeFirst(\"INCREMENT_ASYNC\", incrementAsync), \n    takeLeader(\"INCREMENT_ASYNC\", incrementAsync),\n  ]);\n}\n```\nThanks! . ",
    "aindong": "@Andarist getSessionAPI should return the data I got from the server so I return the response.json(). I'm sending the promise to getSession using handleAppEnter with the onEnter event of react-router.  and this one is working\n`` javascript\nexport const postSessionApi = (credentials) => (\n    fetch(${API_HOST}/admin/auth`, fetchOpts('POST',credentials)).then(\n        (res) => {\n            // eslint-disable-next-line\n            if(res.status == 200){\n                // sessionStorage.setItem('session', JSON.stringify(res.json()));\n            return res.json();\n        }\n        throw res;\n    }\n)\n\n);\n```\n. oops I got it. Sorry for not understanding your first statement @Andarist \n. @Andarist I accidentally put curly brackets instead of parenthesis >_< that's why it is not returning anything. LOL\n. ",
    "jawb": "I'm wondering what's the best way to test sagas.\nI agree with @Andarist, iterating through the generator doesn't seem like a good testing  mechanism. For example I wrote this saga and I'm still not sure how to test it.\n. ",
    "simonbuchan": "channel() has implementation, so even if take(channel()) only returns a description of the effect I feel a bit weird using it as a mock. Worse, you can't distinguish instances in failures, so I prefer meeting the minimal (read-only) API of channels:\njs\nfunction createMockChannel(name = 'channel') {\n  return { name, take: jest.fn(), close: jest.fn() };\n}. ",
    "arashd": "Also a total rookie here, but if you're trying to listen for two types of action, you can do: \nconst action = yield take(['ACTION_TYPE_1', 'ACTION_TYPE_2'])\nthen check the action type:\nif (action.type === 'ACTION_TYPE_1')\nSee the second to last example in this section of the docs\n. I'm not sure if I'm understanding correctly. Maybe I'm missing what you're trying to achieve since this is a barebones example. put simply dispatches and then immediately gives back control. So api.thirdCall gets called right away. You should be able to achieve the same by simply doing: \n```\nfunction mainSaga () {\n  yield takeLatest('some-action', function () {\n    yield call(anotherSaga)\n    yield call(api.thirdCall)\n  })\n}\nfunction* anotherSaga () {\n    yield call(sagaA)\n}\nfunction* sagaA () {\n    yield call(api.firstCall)\n    yield call(api.secondCall)\n}\n```\nYou could also use yield* but it would make testing less pleasant. In this case, if you cancel mainSaga, the cancellation propagates downward and all the sagas get cancelled.\n. ",
    "ImJoeHs": "Thank you! I should read the docs carefully.\n. ",
    "IlyaSemenov": "@Andarist Sure, this came from a real project. I just reduced it to the simplest form possible to demonstrate the problem.\nMoreover I believe the endless loop over the events channel is the only way to process events produced by an external API, isn't it? And I don't see nothing unusual in that API queueing a few thousands events. If you're interested, the event source was https://github.com/legastero/stanza.io which pushes quite a lot of events in the initial phase (e.g. message archive) which takes some time to process.\n. Yes, yielding a delay in the loop \"fixes\" it indeed. Thanks. But personally I think that a workaround for that better be added inside take() implementation (e.g. monitor recursion depth and ease it with an async delay every 100 nested calls or so), or at least that edge case must be documented in the Event channel documentation.\nRight now it's a leaky abstraction in its wild form.\n. ",
    "jacklol13": "The previous command there was npm install, but strangely deleting node_modules and reinstalling solved this.\n. ",
    "vanhtuan0409": "I agree that could be 1 solution\nBut it feel a little bit un-natural to come up with a new Action only for redux-saga to listen to\nAn api call flow should normally consist of 3 action\n- REQUEST (fired by client side)\n- SUCCESS (fired after received the respose)\n- FAILURE (fired after api call error)\n. I got it \ud83d\udc4d \nIt end up i modified my solution a little bit to fit the situattion\n. ",
    "dimapaloskin": "@Andarist thank you, it's help. But I added few changes.\nFor now it's looks like:\n``` js\nfunction asyncTask(callback) {\nif (callback) {\n    setTimeout(() => {\n      callback('progress');\n    }, 300);\n  }\nreturn new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('finish');\n    }, 500);\n  });\n}\nfunction createAsyncTaskRunner(data) {\nlet emit;\n  const chan = eventChannel(emitter => {\n      emit = emitter\n      return () => {}\n  });\nconst promise = asyncTask((data) => {\n    emit('PROGRESS');\n    /\n       stop if 100% uploaded (using inside project) \n       if (data && data.progress === 1) {\n        emit(END);\n      }\n    /\n  });\nreturn [ promise, chan ];\n}\nfunction* watchOnProgress(chan) {\n  while (true) {\n      const data = yield take(chan);\n      yield put({ type: 'PROGRESS', payload: data });\n  }\n}\nfunction* uploadSource(action) {\n  const [ promise, chan ] = createAsyncTaskRunner('test');\n  yield fork(watchOnProgress, chan);\n  try {\n    const result = yield call(() => promise);\n    put({ type: 'SUCCESS', result });\n  } catch (err) {\n    put({ type: 'ERROR' });\n  }\n}\n```\nThanks a lot!\n. ",
    "ASHISH932": "I tried using above mentioned approach but it is not working. I am using ReadableStream of fetch body, and is unable to create eventChannel from there. Is there any other approach in redux-saga or custom middleware would be a better option?. ",
    "williamgranli": "@Andarist I understand that, but I think there should be an option to not log cancellations, since it's a common practice as @aikoven suggests. Especially since the biggest(?) react boilerplate project (https://github.com/mxstbr/react-boilerplate) uses saga injections which means that sagas have to be cancelled on every route change. \nWouldn't it be better to f.e. send in an extra param to the cancel like so:\n\nyield cancel(sagaName, {log: true});\n. \n",
    "3plusalpha": "I agree, that printing out should be optional. Would love to see my console less polluted :). ",
    "codepunkt": "Same here. When developing, i have the browser devtools open most of the time. When switching from one route in my app to another, i tend to see a few hundred cancelled logs of websocket/firebase subscriptions, which really slows navigation down.. Thanks for everyone's opinions! I'm going to close this.\nIf anyone manages this in a different way, feel free to continue the discussion \ud83d\udc4d . ",
    "ian4hu": "Yes, after start this issue, I explore the cdnjs, and start a Add Request issue, it's ok to close this now.\n. ",
    "nicmesan": "@Andarist Thanks for the answer, I was suspecting something like this.\nThe way I managed to get it working now is to create a second function called wacther that will permit this loop. Here is what I got so far:\n```\nfunction * example () {\n  while (true) {\n    yield take('start')\n    const someAction = yield call(apiClient.someClientAction, parameter)\n    yield put({ type: initialAction' })\n  }\n}\nfunction * watcher () {\n    while(true){\n    const actions = yield take('initialAction')\n    yield put({type: 'start'})\n  }\n}\n```\nThis is working, but I do not know if it is the most elegant way to solve the issue.\n. Sure, I will try to maintain things simple:\nMy main generator is a function that will process some actions that the server sends, things like play videos, show messages, etc. The payload for this will be in an array with object similar to: {actionType: PLAY_VIDEO, videoUrl: 'http....'}\nThe problem is that one of this actions will request a new call to the server endpoint requesting new actions. Something like this: {actionType: REQUEST_ACTIONS}.\nSo, ones I get these new actions, I should call the generator again and procces them.\nThe code would look something like this:\n```\nfunction * processServerActions () {\nwhile(true) {\n    const nextActions = yield take('start')\n    for (let action of nextActions.payload) {\n\n        switch(action.actionType) {\n\n            case REQUEST_ACTIONS:\n                const nextAcitons = yield call(apiClient.requestActions)\n                yiel put({actionType: 'start', payload: nextActions})\n                break;\n\n            case PLAY_ACTION:\n                yield put({ type: PLAY_AUDIO, payload: action.url })\n                break;\n\n            case MESSAGE_ACTION:\n                yield put({ type: ADD_MESSAGE, payload: action.payload })\n                break;\n\n            case CLEAR_MESSAGES_ACTION:\n                yield put({ type: CLEAR_MESSAGES })\n                break;\n        }\n    }\n}\n\n}\n```\nSo, my problem lays in the REQUEST_ACTIONS case, where I would to call the generator again, but I cannot make to take this 'start' action, unless I use a second function like I show in my previous comment.\nLet me know if it is clear or if I should add further details.\nThanks in advance! \n. Great, it's working, thanks a lot for your help!\n. Hi, thanks for your help. Yes, I notice the problem you mentioned and solved it the way you recommended. Regarding the original issue, the take was not taking actions dispatched by the redux devTools. So, once I tested it in the normal app flow it worked. \nThanks again!. Alright, I managed to get it working throwing an error in case the LOGOUT action is received (see code below): \n```\nfunction * processServerActions () {\n    // Take all PROCESS_ACTIONS dispatched actions,\n    // in case one is already running, it will queue the next\nconst queuedActions = yield actionChannel(PROCESS_ACTIONS)\n\nwhile (true) {\n    const nextActions = yield take(queuedActions)\n    // Iterate through all the actions array\n    // and build the generator function that will\n    // execute the actions\n\n    try {\n        console.log('enter the race')\n        const { logout, processedActions } = yield race({\n            logout: take(LOGOUT),\n            processedActions: call(translateActions, nextActions),\n        });\n        console.log('logouuuuuuuut', processedActions, logout)\n        if (logout) {\n            console.log('error entered')\n            throw new Error('User has logged out')\n        }\n\n\n    }\n\n    // In case an error is catched, reset the function \n    // and start listening to new 'queuedActions' actions\n\n    catch (error) {\n        yield processServerActions()\n        return error\n    }\n\n}\n\n}\n```\nNevertheless, I don't like the idea of throwing an exception inside the try. Also, I believe there has to be a better way to solve this issue using the cancel effect from the library. \nWhat do you think?\nThanks !. @Andarist @granmoe Thank you guys, I ended up doing what @Andarist recommended and is working fine now!  . Closing, thanks!. @yelouafi yes, that seems to be a much simpler option. I will implement it, thanks!. You are right, I didn't though about that. Since I need to pass some arguments to this function, I will follow the type-check path. \nThanks!. ",
    "pvnr0082t": "@Andarist Thanks. :tada: \n. ",
    "carlos-peru": "Hi @Andarist,\nI'm trying to understand the change in your fiddle because it made it worked (Thanks!). Webpack is a new thing to me, and I would highly appreciate a short clarification.\nIn the top module exports change, did you just set a loader instead of an array of loaders and explicitly set the presets as query parameters as opposed to waiting for babel to pull the presets from .babelrc? Why?\nIn the bottom module exports change, did you include the redux saga and saga monitor modules dynamically in the babel loader instead of just adding them to the arrays of loaders (that was replaced by a single loader at the top)? Why?\nThanks again!\n. ",
    "banderror": "@datenreisender put is definitely non-blocking, and put.sync is blocking :)\n. ",
    "xcarpentier": "Why it's not possible to use redux-persist with redux-saga ?\n. Thank you.\nI see it's possible to persist state using saga, but how do you rehydrate state when you reload the app ?\nredux-persist must adapt his code I think to persist also with redux-sagas.\nBut why it's not a problem with redux-thunk and it is with saga ? \nIs there a solution to provide a compatibility between both (ie. redux-persist & redux-saga, both are pretty much standard for  now) ?\n. @Andarist is it possible know how you configure your store with redux-saga and redux-persist ?\nBecause of this issue : https://github.com/mxstbr/react-boilerplate/issues/396\n. Ok so, I code a solution. I share it with you. (source cf. https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage#/tab-transcript)\nIt's for react-native (ie. AsyncStorage).\n- store.js\n``` javascript\n/*\n * @providesModule Store\n * @flow\n /\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport middleware from 'Middlewares';\nimport reducers from 'Reducers';\nimport sagas from 'Sagas';\nimport { loadState, persistStore } from 'PersistState';\nconst sagaMiddleware = createSagaMiddleware();\nconst createStoreWithMiddleware = applyMiddleware(...middleware, sagaMiddleware)(createStore);\nconst configureStore = async () => {\n  const store = createStoreWithMiddleware(reducers, await loadState());\n  persistStore(store);\n  sagaMiddleware.run(sagas);\n  return store;\n};\nexport default configureStore;\n``\n-persist.js`\n``` javascript\n/*\n * @providesModule PersistState\n * @flow\n /\nimport AsyncStorage from 'AsyncStorage';\nimport throttle from 'lodash/throttle';\nexport const loadState = async () => {\n  try {\n    const serializedState = await AsyncStorage.getItem('state');\n    if (serializedState === null) {\n      return undefined;\n    }\n    return JSON.parse(serializedState);\n  } catch (err) {\n    return undefined;\n  }\n};\nconst saveState = (state) => {\n  try {\n    const serializedState = JSON.stringify(state);\n    AsyncStorage.setItem('state', serializedState);\n  } catch (err) {\n    // Ignore write errors.\n  }\n};\nexport const persistStore = store =>\n  store.subscribe(throttle(() => saveState(store.getState()), 777));\n```\n. ",
    "eiriklv": "Made a mistake when creating the PR. Disregard.\n. The only way I seem to be able to get this to bubble the error up entirely is\njs\nconst sagaMiddleware = createSagaMiddleware({\n  onError(error) {\n    setImmediate(() => {\n      throw error;\n    });\n  }\n});\n. @Andarist I understand that. It's a tough thing to solve \u270c\ufe0f It's the same thing with then().catch() vs. then(onSuccess, onError) as well.\nThe biggest issue is the whole put thing where redux-saga \"catches\" errors that are triggered as a result of a reducer throwing (as an example). When redux-saga logs the error the source mapping for some reason doesn't work, but if you re-throw it you at least get the correct references.. Will give it a try \ud83d\udc4d. ",
    "hilkeheremans": "Hi @Andarist, we have a fairly complex saga structure in one of our apps, and I believe we are also bumping into this. It's rather difficult to track down where exactly it is coming from, but at least your explanation above helps us look in the right direction.\nExplaining this in the docs, including some of the cases shown above, would be an excellent idea, IMO. Adding some common patterns to circumvent the issue (eg action channels) would be a great addition as well.. ",
    "lourd": "Hear hear, thanks @cellog. Here's a form of that using promises and async/await in a snippet from a test I just figured out.\njs\ndescribe('firebaseChannel', () => {\n  it('should subscribe to firebase, emit the values into the channel that firebase ' +\n  'emits, and unsubscribe when the channel is closed', async () => {\n    const firebase = new MockFirebaseInstance()\n    const channel = firebaseChannel(firebase)\n    // the callback is the promise resolver function\n    const taken = new Promise(resolve => channel.take(resolve))\n    const snapshot = new MockSnapshot()\n    firebase.emit({ type: 'value', snapshot })\n    const value = await taken\n    expect(value).toEqual({ value: snapshot.val() })\n    // Closing time\n    const spy = jest.spyOn(firebase, 'off')\n    channel.close()\n    expect(spy).toHaveBeenCalledWith('value', 1)\n  })\n})\nBe sure to get the promise, emit, then await, I was tripped up for a while because I was awaiting before I was emitting.\nAnd you get to write await taken in your tests, how great is that! \ud83e\udd23\nLonger source is in this gist. Here's another example of writing and testing a channel for a generic emitter. You're trying to test the emitterFn function in your example, correct? If that is the case, you should do that outside of a saga. You'll need to fake the instance that you pass into emitterFn, something like this FakeEmitter class that allows you to control when events are emitted and the emit function from the eventChannel is called. Looks like you're mock instance might be slightly more involved with properly mocking the behavior of the changes method, but pretty similar. \nWhen you go to test the channel's closing behavior, create a spy on the cancel method of the instance you passed it, and assert that its called. i.e.\njs\nconst cancel = jest.spyOn(emitter, 'cancel')\nchannel.close()\nexpect(cancel).toHaveBeenCalledWith(/*whatever arguments it should have been called with*/)\nWhen you go to write a test for a saga that uses the channel creator function, you don't need to mess with channels, you just call next on the iterator with whatever you need. When you need to pass in a fake channel, you can do it with a couple of simple no-op functions.\nHere's an example from one of my project's tests (using redux-saga-test-plan , which I heartily recommend). ",
    "sebinsua": "My approach to part of this problem was to avoid handling all errors with a gigantic try-catch.\nSee: https://github.com/sebinsua/redux-saga-helpers\nI'll read through this later on.... ",
    "markspolakovs": "Thanks for the put.resolve trick. However, if there's an exception inside the saga, the reported stack trace on React Native is completely useless. In this case, the exception is on a line that isn't a saga effect.\n\n. Context: in React Native, if there's an exception inside the saga, the error log it spits out is completely useless and makes me wade through lines after lines of redux-saga internals.\n\n. ",
    "nshoes": "@Andarist this was catching errors for me fine with on redux-saga@0.11.0.\n```javascript\nexport function* updateCalculator(action) {\n  try {\n    const { value, id, key, fromMap } = action\n    yield put(updateCameraAction(key, value, id))\n    yield put(updateCurrentCameraAction(id))\n    yield put(updatePresentationValuesAction(key, value, fromMap))\n  } catch (err) {\n    yield put(messageAction(action.key, err.message))\n  }\n}\nexport function* watchUpdateCalculator() {\n  yield takeEvery(UPDATE_CALCULATOR, updateCalculator)\n}\n```\nBut on 0.14.3, it is uncaught and gets plastered onto window. But using put.resolve changes it back to the previous behavior. I asked you in Gitter about why put was changed to non-blocking, and then you said it was always non-blocking, so I am confused on how it works honestly. A few questions (pardon me if these are obvious):\n1.) Why does passing everything to put.resolve catch the error properly? To give you more a little more context, our app has a validator when receiving user input:\n\nWe throw actual errors and then rely on the saga to catch them and halt itself, not letting any other actions get dispatched.\n2.) Why is put non-blocking? It dispatches an action to the reducer, which is synchronous, so why doesn't it wait until the reducer has finished it's task before moving on?\n. > My comment was about its general behavior, not the error handling itself. I strongly believe that put was always resolved (giving back running context to your generator) once it finally managed to dispatch your action. By finally I mean that it could not be immediate due to internal scheduling, but for sure within the same synchronous call stack.\nAlright, that makes sense. Thanks.\n\nYou are right though that silent error swallowing was added, because at the moment it felt weird that error in your reducer or component can crash your saga. However after this got into the library the questions were raised about this behaviour and we are not 100% sure which behaviour is desired and which one should we keep. We will for sure settle our minds on it before geting v1 to you, which im pushing forward the best I can due to limited time I can spend on the code now.\n\nI think that it felt natural that it halted the generator, and I would assume more people feel the same.\n\nIn addition - there are not really that many blocking effects in the library, most are non-blocking.\nMore about this can be found here:\n\nI see, thanks. After thinking about it more it makes sense it's non-blocking. Obviously the reducer has to finish whatever it's working on before taking the next action. The mental model I had was that the saga followed the async/sync behavior of what it was doing; meaning a put would be blocking, a call could be blocking or non-blocking depending on what the function is actually doing.\nThe source for runPutEffect makes a lot more sense, thanks. \nI would like to stress that it felt natural that an error would halt the saga with put. Would love to hear some feedback from others. Thanks for the feedback @Andarist.. ",
    "abrkn": "I've been having this issue as well when converting a project to redux-saga. If a reducer throws an error, the program is in an unknown state and must terminate.. I've tried both and neither seem to be working. I'm on latest from npm. Ideas?. ",
    "kyriiherman": "@Andarist so is this description invalid for now? https://redux-saga.js.org/docs/api/index.html#putresolveaction. @restrry sorry I missclicked, in API docs for put action said:\nhttps://redux-saga.js.org/docs/api/index.html#putaction\n\nThis effect is non-blocking and any errors that are thrown downstream (e.g. in a reducer) will not bubble back into the saga.\n\nBut you said that errors bubbles for put().. ",
    "msikma": "Thanks a lot, sorry for taking some time to reply to this. You've given me something good to think about, and I did a couple of different tests to try and work out what would be best for my case. In the end I also decided that I wanted to call an action rather than simply put() the success action. So I decided to split that particular saga off into its own function.\nStill, this is very helpful, it's good to get a perspective from someone knowledgable on how to work with sagas. Thanks a lot for your thoughts \ud83d\udc4d \n. ",
    "Ayyagaries": "I am in the same situation, here I have two sagas one is login that gives me the token, and other one is user profile that gives me the profile with the token. \nI used  take(\"GET_USER_TOKEN\") in the user profile saga to get the token but I noticed that the action is called twice in the \"Login saga\" and the 'user profile saga'. I want to action to happen only once. How is that possible? . ",
    "BenLorantfy": "@Andarist Why is that solution better than just selecting from the state? It seems like you're just creating a local state inside your saga (which you need to keep synced to the redux store state). Isn't redux meant to consolidate state in one spot?. @vipulrawat I think it's fine. You have to store the client side token somewhere, and the redux store isn't too much different than localStorage or cookies. The only concern I'd have is making sure you don't accidentally send the token to an analytics or logging service. \nYou may also be interested in actionSanitizer and stateSanitizer to remove the token from the devTools: https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md#actionsanitizer--statesanitizer. This is something I'd be willing to open a PR for if wanted.. I took a quick look but it looks pretty complicated and I\u2019m not sure where to start. In theory it\u2019s possible (using generics) but I\u2019m not sure how to fit it into the existing typings. I think this would be a useful type check though, so I don\u2019t think this should be closed.. ",
    "iorrah": "For those who are wondering where the select comes from:\n```jsx\nimport { select } from 'redux-saga/effects';    //    <- here it is\nconst getToken = (state) => state.token;\n// ...\nconst token = yield select(getToken);\n```. ",
    "PabloDinella": "\nFor those who are wondering where the select comes from:\n```js-jsx\nimport { select } from 'redux-saga/effects';    //    <- here it is\nconst getToken = (state) => state.token;\n// ...\nconst token = yield select(getToken);\n```\n\nand here is the doc section about it :)\nhttps://redux-saga.js.org/docs/api/#selectselector-args. ",
    "vipulrawat": "Ok, one thing: is that a good practice to store authentication token to the client side store?. @ufon Wouldn't that be a security concern in storing the authentication token in the client side?\nHonestly, don't know much about security.. ",
    "ufon": "@vipulrawat why not. ",
    "ajihyf": "Thank you for your help!\n. fetch API doesn't expose a method to abort. To abort request when cancelling promise in saga, use some alternative libraries(like axios which supports cancellation) instead.\n```javascript\nfunction getURL(url) {\n  let cancel;\nconst promise = axios.get(url, {\n    cancelToken: new axios.CancelToken(function executor(c) {\n      // An executor function receives a cancel function as a parameter\n      cancel = c;\n    })\n  });\n// cancel the request\n  promise[CANCEL] = cancel;\n  return promise;\n}\n```\nUnfortunately, cancelable promises proposal has been withdrawn. :-(\u00a0Not sure how long will axios support this feature.. ",
    "psdao-lw": "I see that this got dropped off last year. Has any progress on this subject been made?. ",
    "sepo-one": "thanks. ",
    "funkjunky": "Couldn't you reject a promise?\nThe use case is cancelling fetch calls when the generator caller has been cancelled.\nBasically if I spam a button that makes an ajax call, I want to cancel all but the last ajax call.. Ok I see, the cancel token I'd give to call() could be used to cancel in the finally if(cancelled()) branch.\nCool beans. Thanks!. woah, clever idea... have you tested this out yet? I'll try it out and let you know how it goes.. ",
    "L-Jovi": "@Andarist  thanks for your example, it's useful to me :)\nregards.. @AJIh  thanks for your example :)\n@Andarist  thanks for your reply.. ok, I figure out it by restart the Remotely JS Debugging, maybe it's react native issue.\nsorry to trouble.\nregards.. @shinima Thanks for your reply, it helps me :). ",
    "spaceemotion": "Here's a version that we're using for all possible HTTP methods (not just GET), based on the version by @Andarist:\n```js\nimport axios, { CancelToken } from 'axios';\nimport { CANCEL } from 'redux-saga';\nexport default function api(method, url, data = {}, options = {}) {\n  const httpMethod = method.toLowerCase();\nconst hasData = ['post', 'put', 'patch'].indexOf(httpMethod) >= 0;\n  const settings = hasData ? options : data;\nconst source = CancelToken.source();\n  settings.cancelToken = source.token;\nconst request = hasData\n    ? axioshttpMethod\n    : axioshttpMethod;\nrequest[CANCEL] = () => source.cancel();\nreturn request;\n}\n```. I think what he means is that the d.ts files are not up to date (channels are not present). (e.g. PHPStorm tells me that it can't find them). ",
    "Kitanotori": "Awesome. Really starting to like Saga the more I get to know it. Keep up the good work!. ",
    "esseb": "Note: I haven't investigated this very thoroughly yet, so I just realised it's possible redux saga rethrows the error further up and my issue is elsewhere.... Thanks, I'm subscribing to that issue now.. ",
    "Proberts": "Thanks for the replies. I found my problem while preparing a minimal saga to post, and it was so simple I'm embarrassed to post it.\nMy problem was I was doing a call() to the action which just returns an event object. Switching to using put() solved my issue. It was showing the modal after the saga exited because at one point I had tried stacking two dispatch() calls, one to show the spinner, and one to my saga.\n. ",
    "eirslett": "I guess this issue is somewhat related to #555 as well? @janhartmann. I ended up using this middleware: https://github.com/Chion82/redux-wait-for-action. It looks like it works quite well combined with redux-saga.\n```javascript\nconst actionCreators = {\n  requestArticle: id => ({\n    type: 'REQUEST_ARTICLE',\n    id,\n    WAIT_FOR_ACTION: 'ARTICLE_REQUEST_SUCCESS',\n    ERROR_ACTION: 'ARTICLE_REQUEST_FAILED'\n  })\n};\nstore.dispatch(actionCreators.requestArticle(123))\n  .then(() => console.log('success'))\n  .catch(() => console.error('error'));\n```\n. Here is an example of redux-saga combined with redux-wait-for-action, interacting with legacy code. It's pseudocode, I haven't actually tried it.\n``javascript\n// saga code\nfunction* requestArticleSaga({ id }) {\n  try {\n    const response = yield call(fetch,https://api.example.com/${id}`);\n    const data = yield call(response.json);\n    yield put({ type: 'ARTICLE_REQUEST_SUCCESS', id, data });\n  } catch (error) {\n    yield put({ type: 'ARTICLE_REQUEST_FAILED', id, error });\n  }\n}\nfunction* root() {\n  yield fork(takeEvery, 'REQUEST_ARTICLE', requestArticleSaga);\n}\nsagaMiddleware.run(root);\n// reducer\nswitch (action.type) {\n  case 'REQUEST_ARTICLE':\n    return { ...state, [action.id]: { loading: true } };\n  case 'ARTICLE_REQUEST_SUCCESS':\n    return { ...state, [action.id]: action.data };\n  case 'ARTICLE_REQUEST_FAILED':\n    return { ...state, [action.id]: { error: action.error } };\n}\n// action creators\nfunction requestArticle(id) {\n  return {\n    type: 'REQUEST_ARTICLE',\n    id,\n    WAIT_FOR_ACTION: 'ARTICLE_REQUEST_SUCCESS',\n    ERROR_ACTION: 'ARTICLE_REQUEST_FAILED'\n  };\n}\n// legacy code\nconst id = parseInt(params.id);\nview.renderLoadingSpinner();\nstore.dispatch(requestArticle(id))\n  .then(() => view.renderArticleView(store.getState()[id]))\n  .catch(view.showErrorPage(store.getState()[id].error));\n```\nI have one concern though; if you dispatch multiple REQUEST_ARTICLE in parallel, and they return responses out of order, the wrong promise might be resolved.. The requirement is: this is a gradual legacy code base migration; no \"stop the line and rewrite the whole app to redux and redux-saga\", all at once.\nCalling view.xxx cannot happen inside the saga, because the requestArticle function is exported as a form of public API (you could think of it as an ArticleService). And the state management code shouldn't know about the UI code, architecture wise, the UI should know about the state management (directly or indirectly). The thought is that redux-saga will know about redux, the \"facade api\" will know about redux (and redux-saga), while the rest of the app (the UI) will only know about the facade.\nThen, gradually, views can be shifted from using the promise APIs to reading directly from Redux instead.\n. Yes, that would work!\nThe only thing that is a little ugly (in some sense) is the userland handling of Promise resolve/reject inside the saga. Would it be possible to do it as an effect somehow?\n``\n// saga code\nfunction* requestArticleSaga({ id }) {\n  try {\n    const response = yield call(fetch,https://api.example.com/${id}`);\nconst data = yield call([response, response.json]);\nyield put({ type: 'ARTICLE_REQUEST_SUCCESS', id, data });\nyield resolve(data);\n\n} catch (error) {\n    yield put({ type: 'ARTICLE_REQUEST_FAILED', id, error });\n    yield reject(error);\n  }\n}\n```\nThe effects resolve and reject would then resolve/reject the promise to be returned from store.dispatch(getArticle(123)). (And could be unit tested easily, one wouldn't need to mock a Promise)\nOr maybe this all boils down to needing to pass an explicit promise reference, so that the correct promise is resolved.... We use redux-wait-for-action as a compromise when we need do do hacks like this. it makes store.dispatch(...) return a Promise which you can .then() or .catch() on.. loading state as true/false is maybe a bad example, since it's widely considered correct practice to store that in Redux: http://redux.js.org/docs/advanced/AsyncActions.html. This is how we do it with redux-wait-for-action, give it a try:\n```javascript\n// action creators\nconst getData = (payload) => ({\n  type: 'GET_DATA',\n});\nconst getDataSuccess = payload => ({\n  type: 'GET_DATA_SUCCESS',\n  payload\n)};\nconst getDataFail = error => ({\n  type: 'GET_DATA_FAIL',\n  error\n});\n// saga\nfunction * handleGetData (action) {\n  try {\n    const data = fetchDataFromSomewhere();\n    yield put(getDataSuccess(data)); // assume there's an action creator\n  } catch (error) {\n    yield put(getDataFail(error)); // assume there's an action creator\n  }\n}\n// Inside your UI component (I think setState() returns Promises, they are async, I can't remember)\nawait this.setState({ loading: true });\nconst result = await this.props.getData() // <-- will be mapped to store.dispatch(getData())\nawait this.setState({ loading: false });. You could unit test the root saga, where you use takeEvery and delegate actions to the saga, at least that's what I do.. javascript\nfunction* rootSaga () {\n  yield fork(takeEvery, 'PRODUCTS_REQUESTED', fetchProducts);\n}\njavascript\nit('The root saga should react to actions', () => {\n  const generator = rootSaga();\n  expect(generator.next().value).to.eql(fork(takeEvery, 'PRODUCTS_REQUESTED', fetchProducts));\n  expect(generator.next().done).to.eql(true);\n});\nTests like this one end up looking a lot like the implementation. That's fine. I like to think of it as double-entry bookkeeping.\nIf you want black-box testing of side effects, I think they are better written as integration tests - using sinon everywhere can be cumbersome.. ",
    "samsch": "From a technical standpoint, you can run any saga you want from sagaMiddleware.run(). So when you call that from your main.js (or whatever bootstrap file), the saga can do whatever you want.. ",
    "mmahalwy": "What about with server-side rendering/ . What about with server-side rendering/ . ",
    "lysoff": "@Andarist thank you for your reply\nSure, i'll give it a try, but unfortunately i have too few experience in TS typings. @aikoven awesome, thanks!). ",
    "tomenden": "This approach actually does not work either.. If the second call is made after 300 ms and before the response comes back, I am facing the same situation of sending the server the wrong key.. What is the right way to make sure that the second request will happen only after the first response has returned and the key has been updated in the store?. @Andarist \nThanks for your help, but unfortunately this approach does not seem to work either.\nPerhaps I did not clarify my use-case well enough. If I attempt to make two requests at the same time one of them will necessarily fail. I must wait for the response to come back before dispatching the second request, in order for the key that I send to be correct.\nHere is the scenario in which this fails:\nUser changes data - debounced wins the race, and thus the task is forked. All is well and nice.\nAfter some time (>300ms) the user changes the data again. debounced wins the race, yet again, and the second request is sent. However, the server did not yet respond to the first request, the key is not updated in the store, and thus the second request fails.\nHope this makes sense now. Currently my thought is perhaps to change the logic a bit to also rely on the response action to have occurred (i.e - in case a request is made while another request is in progress, the second request will wait for the saved action before sending itself.\nI am also checking a way of making the solution more generic, but without much luck in the meanwhile.\nWhat do you think?\nThanks in advance!. @Andarist \nFirst of all, I'd like to thank you a lot for your assistance, and for recommending channels. It got me to read about this pattern which is extremely powerful, and very suitable for the issue I am facing.\nI created a generic solution to create a 'debounce channel', I will be very happy to get your feedback on it. You can see the gist here.\nI want to ask specifically regarding this line. The reason I am spawning here is because the debouncedChannel is being consumed by using call (in order to take from the channel inside the main saga). I was surprised to see that when using fork in debouncedChannel, the original saga (watchChangeAction) does not immediately resolve. Is this the expected behavior? I understand that calling a saga will block until the saga has completed, but was unaware that this is also true for the sagas' non-blocking effects. Is this the expected?\nOnce again, huge thanks!. ",
    "jck2": "I did some more debugging last night, it appears that the problem is that constant rerendering of the UI is the problem and not sagas. You can close this issue. ",
    "Rajat421": "I am facing the same issue . In my case i have stop constant redenring of ui still face  this issue ... ",
    "pbadenski": "@Andarist sure I'll take a shot\n@yelouafi sorry I don't understand, is there anything you want me to change?. @Andarist I added information in API docs, let me know what you think. I like narrowing it down to only providing \"emit\" option instead of replacing the whole \"emitter\". The other solution did seem a bit clunky. Should I wait for @yelouafi's response or just go ahead and change it?. @yelouafi yeah, using batched actions seem to require small tweaks in other middleware. We just barely started using it so still learning about them.\n@Andarist I should have enough time for these changes :) I'll try pushing it today.. @Andarist I decided to take a slightly different approach, let me know what you think. I started off with a solution allowing to override only \"emit\" function, but all my attempts felt clunky. I think this new solution better embraces @yelouafi comment on finding \"a more appropriate name since the option can have other uses\".\n*) emit requires access to private field \"subscribers\", if \"emit\" override is provided it needs to accommodate that. @yelouafi @Andarist what do you suggest is the next step? I can take another shot at the implementation based on suggestions?. ",
    "steven10172": "Thanks. I will try it out later today. I only had the yield statements like that due to how the data was being passed to them, but that was probably due to the store constructing issue.. Thanks. I was able to play around after your suggestion and it seems that there was an issue with the window.__REDUX_DEVTOOLS_EXTENSION_ initialization.\nAfter using your line to initialize redux dev tools everything was working as expected: https://github.com/steven10172/todo-list/commit/c949601bb239f3674bff94af05bad7554f777647. ",
    "schuchowsky": "Thanks guys @restrry and @Andarist! That worked like a charm. \nHere's a gif of the result (it's an application/octet-stream, you may open with browser if you like):\nhttp://hnordt.d.pr/RYlP+. @kuy Oh I see... so in the example above, the while(true) could be replaced by while (yield take (FETCH_POSTS), because the function yielded from take effect is not being used in that case, right?\nOverkill? Hm... What would be the correct use for takeEvery then? \nI feel like it's more readable using takeEvery because in one function I declare all my watchers.. Ok guys! Now it's much clearer for me. I liked the term drop actions btw.\nThank you very much @Andarist @kuy.. ",
    "mtwallet": "@Andarist Thanks for the reply, I appreciate it.  I did manage to figure out a solution myself that is very similar, here's where I have got so far:\n```\n   // Background task\n    function* bgSync() {\n      const state = yield select();\n  // Check if orders are present\n  if (state.pickingList.ordersToSync.length > 0) {\n    try {\n      while (true) {\n        for (const order of state.pickingList.ordersToSync) {\n          for (const item of order.itemsPicked) {\n\n            // 2. Update pick qty\n            yield fork(\n              updatePickQtyStart,\n              item.PickingListDetailId,\n              item.PickedQuantity,\n              state.auth.token\n            );\n            yield call(delay, 1000);\n          }\n\n          // 3. Confirm pick\n          yield fork(confirmPickStart, order.pickingListId, state.auth.token);\n          yield call(delay, 1000);\n        }\n\n        // 5. Sync complete\n        yield console.log('Sync queue complete!');\n        break;\n      }\n    } finally {\n      if (yield cancelled()) {\n        // 5. Sync cancelled\n        yield console.log('Sync cancelled');\n      }\n    }\n  } else {\n    console.log('Sync queue empty!');\n  }\n}\n\n// 2. Update pick qty\nfunction* updatePickQtyStart(pickingDetailId, quantity, token) {\n  try {\n    const config = {\n      method: 'post',\n      url: 'http://XYZ',\n      params: {\n        pickingDetailId,\n        quantity\n      },\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    };\n    const response = yield call(axios, config);\n    yield console.log(response);\n\n  } catch (error) {\n    // 5. Sync cancelled\n    yield put({\n      type: STOP_BACKGROUND_SYNC\n    });\n  }\n}\n\n\n// 3. Confirm pick\nfunction* confirmPickStart(pickingListId, token) {\n  try {\n    const config = {\n      method: 'post',\n      url: 'http://XYZ',\n      params: {\n        pickingListId\n      },\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    };\n    const response = yield call(axios, config);\n    yield console.log(response);\n\n    // 4. Remove order once synced\n    yield fork(removeSyncedOrder);\n    yield call(delay, 1000);\n\n  } catch (error) {\n    // 5. Sync cancelled\n    yield put({\n      type: STOP_BACKGROUND_SYNC\n    });\n  }\n}\n\n\n// 4. Remove order once synced\nfunction* removeSyncedOrder(order) {\n  yield put({\n    type: REMOVE_SYNCED_ORDER,\n    payload: order\n  });\n}\n\n\n// 1. Start BG sync\nexport default function* startBgSync() {\n  while (yield take(SYNC_PICKED_ORDERS_START)) {\n\n    // Start the task in bg\n    const bgSyncTask = yield fork(bgSync);\n\n    // Wait for task to be stopped\n    yield take(STOP_BACKGROUND_SYNC);\n\n    // If error cancel the task\n    yield cancel(bgSyncTask);\n  }\n}\n\n```\nSeeing as I'm using Fork() all the calls should be run in the background if I have understood everything correctly.. @Andarist I've just noticed a problem that I am struggling to solve. If you look at bgSync() you will see I have added a break statement to stop the loop. I have noticed the sync now works perfectly one time only, if I remove the break statement the process gets stuck in a endless loop syncing the order over and over. Do you know of a way to overcome this?\nI have followed the Task Cancellation example for my solution.. @Andarist I have moved on a little now and I'm polling the bg sync I think the changes I have made will address that issue, I'm not completely sure. Please see my solution below:\n```\n    // Handle background sync saga\n    function* backgroundSync() {\n      const state = yield select();\n  if (state.connectivity.connectionType !== 'WIFI') {\n    yield put({\n      type: NOT_CONNECTED\n    });\n    console.log('Not connected');\n  } else if (state.pickingList.syncQueue.length === 0) {\n    yield put({\n      type: SYNC_QUEUE_EMPTY\n    });\n    console.log('Sync queue empty');\n  } else {\n    for (const order of state.pickingList.syncQueue) {\n      if (order.syncType === 'PICK_QTY') {\n        // Update pick qty\n        yield fork(\n          updatePickQtyAsync,\n          order.pickedItem.PickingListDetailId,\n          order.pickedItem.PickedQuantity,\n          state.auth.token\n        );\n      } else if (order.syncType === 'CONFIRM_PICK') {\n        //Confirm pick\n        yield fork(confirmPickAsync, order.Id, state.auth.token);\n      }\n    }\n  }\n}\n\n\n// Update picking list qty saga\nfunction* updatePickQtyAsync(PickingListDetailId, PickedQuantity, token) {\n  try {\n    const config = {\n      method: 'post',\n      url: 'http://XYZ',\n      params: {\n        pickingDetailId: PickingListDetailId,\n        quantity: PickedQuantity\n      },\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    };\n    const response = yield call(axios, config);\n    console.log(`Success in update pick qty: ${response}`);\n\n    // Remove order once synced\n    yield put({\n      type: REMOVE_SYNCED_ORDER\n    });\n    // Restart sync queue\n    yield put({\n      type: SYNC_PICKED_ORDERS_SUCCESS\n    });\n  } catch (error) {\n    // Restart sync queue\n    // Log the error type somewhere where it can be acted on if need be\n    yield put({\n      type: SYNC_PICKED_ORDERS_FAIL\n    });\n    console.log(`Error in update pick qty ${error}`);\n  }\n}\n\n\n// Confirm pick saga\nfunction* confirmPickAsync(Id, token) {\n  try {\n    const config = {\n      method: 'post',\n      url: 'http://XYZ',\n      params: {\n        pickingListId: Id\n      },\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    };\n    const response = yield call(axios, config);\n    console.log(`Success in confirm pick: ${response}`);\n    // Remove order once synced\n    yield put({\n      type: REMOVE_SYNCED_ORDER\n    });\n    // Restart sync queue\n    yield put({\n      type: SYNC_CONFIRM_PICK_SUCCESS\n    });\n  } catch (error) {\n    // Restart sync queue\n    // Log the error type somewhere where it can be acted on if need be\n    yield put({\n      type: SYNC_CONFIRM_PICK_FAIL\n    });\n    console.log(`Error in confirm pick ${JSON.stringify(error.response)}`);\n  }\n}\n\n\n// Watcher saga\nexport default function* watchBackgroundSync() {\n  yield takeEvery(BACKGROUND_SYNC_START, backgroundSync);\n}\n\n//////////////////////////////////////////\n   Poll bg sync\n   //////////////////////////////////////////\n// Fetch data every XX seconds\nfunction* pollData() {\n  try {\n    yield call(delay, 10000);\n    yield put(backgroundSyncStartAction());\n  } catch (error) {\n    console.log(error);\n  }\n}\n\n\n// Watcher saga\nexport default function* watchBgSync() {\n  while (true) {\n    yield take([\n      // I know a single action could trigger the restart but this gives me\n      // Opportunity to see what causes it. \n      SYNC_PICKED_ORDERS_SUCCESS,\n      SYNC_PICKED_ORDERS_FAIL,\n      SYNC_CONFIRM_PICK_SUCCESS,\n      SYNC_CONFIRM_PICK_FAIL,\n      SYNC_QUEUE_EMPTY,\n      NOT_CONNECTED\n    ]);\n    yield race([\n      call(pollData),\n      take(SIGNOUT_USER) // Should cancel the sync?\n    ]);\n  }\n}\n\n//////////////////////////////////////////\n   Root saga\n   //////////////////////////////////////////    \nexport default function* rootSaga() {\n  yield [\n    watchBackgroundSync(),  // Called once when the app is started\n    fork(watchBgSync),\n  ];\n}\n\n```\nThis seems to work just fine but as I said before I'm very new to Sagas so I'd appreciate your feedback. Many thanks.. @Andarist Thanks a lot for the feedback I really do appreciate it, it's helped me a lot. If anything in the code looks weird its probably to do with my lack of understanding as this is my first React/Redux/React Native project with no prior experience. I have put this code together by reading various tutorials I have found on the net.\nWhat I am wanting to achieve is to have a background process that syncs my data back to the server every XX seconds. The reason for having a background process is because I must account for the app losing connectivity. The flow would be:\n\nUser authenticates and moves to the home screen. This starts the background sync.\nIf there is not connection restart process\nIf the sync queue is empty restart the process\nIf there are orders to sync back check which method I should call. This is a warehouse picking app so the as the user picks an item I need to update the quantity. Once they've picked the order I should confirm.\nIf successful restart the process\nIf unsuccessful restart the process and log the error (I may freeze the process and inform the user how to manually complete the pick on the main system if the error persists).\n\nThe signout process flow:\n\nCheck if there orders to sync if so keep the sync process going\nIf orders have been synced stop the sync process\nClear async storage\nNavigate to sign in page\n\nWhat I have done so far seems to work but I am concerned about your comment that I could have hundreds of requests running. I think adding a delay after each success or fail would account for that?\nAnyway what you have provided should get me on the right path so thanks again for the help.\n. @Andarist My understanding is when my background sync fires the request it will stop at the point it succeeds or fails. So in order to keep the background sync running I must restart it at this point.\nAs you mentioned earlier all I want to is perform a background sync every 10 seconds with the caveat that there are 2 separate api methods that can be called and the orders must cleared from the sync queue before the user signs out.. @Andarist I have taken on board your points above. I am now making correct use of state by colocating in my reducers and importing. I have also used call instead of fork within the for loop. My code now looks like this:\n```JS\n////////////////////////////////////////////////////////////////////////\nMy root saga (separate file used by the middleware)\n////////////////////////////////////////////////////////////////////////\nexport default function* rootSaga() {\n  yield [\n    ...\n    fork(bgSync)\n  ];\n}\n\n////////////////////////////////////////////////////////////////////////\nMy root saga (separate file used by the middleware)\n////////////////////////////////////////////////////////////////////////\n// Fetch data every XX seconds\nfunction* pollData() {\n  try {\n    yield call(delay, 5000);\n    console.log('delay');\n    yield call(backgroundSync); // In separate file. This is no longer dispatches actions in success/fail\n    console.log('called bg sync');\n    yield put({\n      type: BACKGROUND_SYNC_END\n    });\n    console.log('Dispatch BACKGROUND_SYNC_END');\n  } catch (error) {\n    console.log(error);\n  }\n}\n\n\n// bgSync\nexport default function* bgSync() {\n  while (true) {\n    console.log('Entered loop');\n    yield take([\n      BACKGROUND_SYNC_END,\n      SYNC_QUEUE_EMPTY,\n      NOT_CONNECTED\n    ]);\n    console.log('Take actions');\n    yield race([\n      call(pollData),\n      take(SIGNOUT_USER_SUCCESS)\n    ]);\n  }\n}\n\n```\nI have added console.log to highlight what is going in the code. This is what is returned:\n\nEntered loop\nTake actions\ndelay\nSync queue empty\ncalled bg sync\nDispatch BACKGROUND_SYNC_END\nEntered loop\n\nAs you can see the bgSync happens once and then stops, it does not restart. I can see in my Redux Remote Dev Tools that BACKGROUND_SYNC_END is dispatched twice. What am I doing wrong?. @Andarist I just read this issue which prompted me to add the following additional piece of code:\n``` JS\n    // Restart bg sync\n    function* restartBgSync() {\n      yield put({\n        type: BACKGROUND_SYNC_END\n      });\n    }\n// Watch for bg to be triggered again\nexport function* watchBgSync() {\n  yield takeEvery(BACKGROUND_SYNC_START, restartBgSync);\n}\n\n```\nI now call BACKGROUND_SYNC_START here:\n```JS\n    // Fetch data every XX seconds\n    function* pollData() {\n      try {\n        yield call(delay, 5000);\n        yield call(backgroundSync);\n        yield put({\n          type: BACKGROUND_SYNC_START\n        });\n      } catch (error) {\n        console.log(error);\n      }\n    }\n// bgSync\nexport default function* pollBgSync() {\n  while (true) {\n    yield take(BACKGROUND_SYNC_END);\n    yield race([\n      call(pollData),\n      take(SIGNOUT_USER_SUCCESS)\n    ]);\n  }\n}\n\n```\nThis works perfectly and hopefully addresses your earlier concerns with my first attempt.. @Andarist  All I can do is test it and see how it goes. Thanks for all your help over the last few days, I appreciate it.. ",
    "ralphstodomingo": "There's also https://github.com/jfairbank/redux-saga-test-plan.. ",
    "erikvold": "@Andarist this seems like a dup of #518. @wanbinkimoon how are you running the loadHome saga?  . @Andarist I think this issue can be closed now.. @synchr0n123r have you been able to resolve the issue?. https://github.com/gajus/gajus.com-blog/blob/master/posts/the-definitive-guide-to-the-javascript-generators/index.md ?. I think this is really left up to the developer using redux-saga and it's best not to offer a one solution fits all approach.  This is almost a coding style issue, it could be handled with abstractions, or action type namespacing, adding data to the redux state, and mixture of these, and more options.  \nLike @Andarist pointed out the best solution likely depends on the application.. @Andarist can we close this?. This proposal is to mutate the store object, and I think we shouldn't do it for that reason, we should try to favor immutability where possible.  Also it would just be extra code to maintain and by implementing this proposal we might implicitly suggest that this is a recommended use case, and I don't think we should do that, especially now that so much documentation is out there explaining the current setup method (which I think is better for the immutability reason stated above).. > It doesn't mutate the store object, though. It returns an enhanced store.\nah good point, I see that now.. const newDispatch = action => {\n      const result = dispatch(action);\n      sagaEmitter.emit(action);\n      return result;\n    };\nI think this might be a step backwards in http://redux.js.org/docs/advanced/Middleware.html to attempt 3 since dispatch is being money patched, although I guess that is not required for what you are suggesting.. > const store = createStore(reducer, enhancer);\nAlso I'm not sure how this is intended to work with other middleware.. > Why the 2 -> two change?\nIt's easier to read imho, also that appears to be the style used on must pages (not all though).\nhttps://github.com/redux-saga/redux-saga/blob/master/docs/api/README.md\nhttps://github.com/redux-saga/redux-saga/blob/master/docs/introduction/BeginnerTutorial.md. @Andarist I updated my example, how should it be changed based on your comment?. ah it looks like takeLatest is not meant to do what I want it to do, it's a non-blocking call effect, I was expected it to be a blocking effect when used with a channel.  . seems like takeLatest should be called forkLatest to me.. > so more details would be appreciated.\nThis issue is more about adding examples to the documentation so that people can figure out how to test channels for themselves, so I'd like to keep this issue more generalized if that's ok.. @Andarist how would one test the throttle example on https://redux-saga.js.org/docs/api/index.html ?\n```javascript\nconst mySaga = function*() {\n  const chan = yield actionChannel(pattern)\nwhile (true) {\n    const action = yield take(chan)\n    yield fork(task, ...args, action)\n    yield call(delay, ms)\n  }\n}\n```\nWhen I test this I did something like you suggested first, then the next step fails:\n```javascript\n    let chan = actionChannel(pattern);\n    assert.deepEqual(\n      gen.next().value,\n      chan\n    );\nassert.deepEqual(\n  gen.next().value,\n  {} // bit confused what to test against here\n);\n\n```\nAnd the second test gives me:\n\nError: take(patternOrChannel): patternOrChannel is undefined\n      at check (node_modules/redux-saga/lib/internal/utils.js:45:11)\n      at take (node_modules/redux-saga/lib/internal/io.js:59:22)\n\nand it's failing on this line const action = yield take(chan). @camflan thanks for setting up travis!  /cc @Andarist \nI fixed the tests that were failing in #1079 and I think we should upgrade the version of node used in travis so I created #1078 as well.. after landing #1079 we can close this issue I think!. This is because your test code is calling requestReviews() which causes the error.  I think you want to replace requestReviews() with requestReviews in your test code.. @Andarist landing both this pull request and #1078 should resolve the travis errors.. > Oh, I see what u meant! I think buffers.sliding(1) is exactly what you need. :)\nafter looking in to it some more that, buffers.dropping(1) looks like what I want (I just need to know if there was a new action buffered), but now when I use it, my tests fail when I compare:\nassert.deepEqual(gen.next().value, actionChannel(TYPE, buffers.dropping(1)));\n\nWhen I log the two values I get this:\n{ '@@redux-saga/IO': true,\n  ACTION_CHANNEL: \n   { pattern: 'TYPE',\n     buffer: \n      { isEmpty: [Function: isEmpty],\n        put: [Function: put],\n        take: [Function: take],\n        flush: [Function: flush] } } }\n{ '@@redux-saga/IO': true,\n  ACTION_CHANNEL: \n   { pattern: 'TYPE',\n     buffer: \n      { isEmpty: [Function: isEmpty],\n        put: [Function: put],\n        take: [Function: take],\n        flush: [Function: flush] } } }\nSo I guess that the functions are being compared and they are not equal.. @Andarist I recreated my test in #1085 to show what is failing.. Seems like the only way to fix this would be to rewrite the buffers implementation to avoid using functions, maybe so that it is just an array and a type, but also we should support the old buffers implementation still.... > With buffers the story is simple - they are primitive objects which does not create any side effects and return synchronously, so packaging them as effect would be quite odd I think.\nI'm still not understanding why we can't or shouldn't implement buffers as effects.  Why would this  be considered odd?  \nIt seemed odd to me the way that it is currently implemented, seeing as how I can't test the recommended way to test.. > The problem is much broader here as you wont be able to test anything that contain local references to functions. This would only help with testing the buffers.\nThat's a fair point.. @Andarist ok I reverted the removal of the check script now.. ",
    "HARINANDHAN": "guys I have question, how do I make multiple sagas watch for same action ?. ",
    "zech": "Thank you. The fix in your PR works as intended.\nAside from this i've got an issue importing effects as stated in the documentation when using the jsnext flag.\nI had to change this:\nimport { call, put } from \"redux-saga/effects\";\nto this:\nimport { call, put } from \"redux-saga/es/effects\";\nAt least i did not find this in documentation but is this the way it should be?\n. In short rollups node-resolve jsnext:true flag looks for the \"jsnext:main\" property in package.json to start from instead of the \"main\" property. Maybe that's a rollup problem not respecting the \"working folder\"\n{\n  [...]\n  \"license\": \"MIT\",\n  \"jsnext:main\": \"es/index.js\",\n  \"main\": \"lib/index.js\",\n  [...]\n}\ni'll try to find another package and compare the behavior as soon as i can.. I've had a look around my currently used packages and I cannot find another usecase like this. But the more i think about this i think this is more or less related to the node-resolve plugin.\nYou cannot put both files (es5 & 6) within the same folder therefore the bundler plugin should respect the subfolder defined in the \"jsnext:main\" node. But it currently does not as you can see here:\nhttps://github.com/rollup/rollup-plugin-node-resolve/blob/master/src/index.js#L47\nI do not know if it is a common practice to have submodules like the effects in the same folder or re-export it as a named export. But if it is then this should be handled by the bundler.\nMaybe I should open an issue over there.\n. Does this one help?\nhttps://github.com/zech/rollup-redux-saga\nOh. I forgot...\nTo reproduce just change this line here:\nhttps://github.com/zech/rollup-redux-saga/blob/master/src/index.js#L11\nIf you want to toggle the mentioned jsnext flag just edit this line here:\nhttps://github.com/zech/rollup-redux-saga/blob/master/rollup.config.js#L14\nAnd use npm run build to bundle with RollupJS & Babel. Thanks,\ncurrently i'm using\nimport { effects } from \"redux-saga/es/effects\";\nI don't know if this is better or not. At least it works.. Regarding CHANNEL_END after the update i've still got the same issue but now in another file:\n'CHANNEL_END' is not exported by '$PATH_TO_PROJECT$\\rollup-redux-saga\\node_modules\\redux-saga\\es\\internal\\channel.js' (imported by '$PATH_TO_PROJECT$\\rollup-redux-saga\\node_modules\\redux-saga\\es\\utils.js')\nAs stated internal\\channel.js has no export for CHANNEL_END.\nImporting the 'right' redux-saga/effects by defining a new environment variable like JSNEXT=true looks clumsy to me to be honest but may work i think.\nI think documenting the right import path for ES6 users will be sufficient. Unfortunately i don't know if this is limited to rollup. I've never used Webpack before.\nMaybe it's an option for future releases (where you can break the api) to reorganize the redux-saga module structure or go all JSNEXT ;-). @nktssh Which entrypoint is webpack 1 or 2 using? I guess it uses the normal main node in package.json as an entry point for node modules.\nWith RollupJS you can configure jsnext:main or main as an entry point. It defaults to the main entrypoint as you can see here: https://github.com/rollup/rollup-plugin-node-resolve\nConfiguring it with jsnext: false works of course but this forces rollup to use the es5 standard for all other node modules as well.. @Andarist Yes thank you. I'm following this topic as well.\n@nktssh This is indeed a cheap workaround as it will mix up ES6 and ES5 code during build. But at least it works.\nHopefully all these legacy and jsnext workarounds go away soon :-). @Andarist I was referring to the webpack workaround. @nktssh explained it here https://github.com/redux-saga/redux-saga/issues/689#issuecomment-269120552\nIt looks like seperate packages would be the best solution. In the meanwhile documenting the issue will help.. Then I got the lodash approach wrong. To be honest I did not look into it.\nBut I don't like the lodash way for redux-saga because the effects are more coupled to redux-saga. lodash on the other side has more distinct modules.. I'm fine with this approach as well. That's what I meant with the \n\nBTW. when you already re-export effects within the main module JS.  Why not change the documentation to use it this way in general and leave the effects.js just for historic reasons to not break code for others?\n\npart. Would be the easiest way around i think.. @Andarist Yes it would require a forked repo as i cannot build. But for now i've done a manual change within the file omitting the CHANNEL_END export waiting for a new release.. Don't rush it. But thank you for your efforts.. It builds and works. Thank you.. ",
    "hmillison": "Thank you for the prompt feedback! I updated my change with your suggestion.. ",
    "anthonychung14": "you are correct in detailing the requirements. I did not think of using a helper to select by id, but this definitely works better than my solution. \nI thought of using an action channel to process requests serially, but definitely prefer being able to use takeLatest, since I'd like to cancel an unfinished request if another for the same component fires.\nThank you! This was very instructive. From my understanding: this helper will create a buffer channel per id given, the yield passes the action to the proper channel, and thus concurrent doAsync1 actions can be dispatched/processed for unique components.\nI will close this once I implement and finish. I have a question about how propsVal works, but I think I have enough to go on and answer my own question in the process.\n. Mid-implementation, I have one question about channelsMap:\nUpon completion of task at channelsMap['a'], does channelsMap['a'] clear or will I have to take care of that garbage collection?\nSince this was a custom-helper function you created, I am going to assume yes (for now)\nDoes this mean I just have to add this line after the yielding put?\n` \nyield put(channelsMap[propsValue], action) \nyield flush(channelsMap[propsValue])\n`\n. Closed. I believe this works, but I am opening a separate issue for how your takeLatest unit test works. I am using it as a template for generating my own unit tests for takeLatestByProps. #50 seems to address my issue, namely this quote \n\nThe problem is that the then callback will not execute right away, instead the underlying promise runtime will schedule the goAndFetchNextTakeEffect in a microtask queue. It simply means, the then will wait for the current flow (for example the current event handler, or componentDidMount or whatever fired the action) to terminate and then execute goAndFetchNextTakeEffect. Meantime your code continues and executes dispatch(action2). But at this time, the Saga hasn't yet fetched the next effect (e.g. take or fork) so it is not ready yet to take the action.\n\nHowever, since this issue was closed, I'm not sure what the resolution was if there was a fix implemented to allow this use-case. version ^0.13.0\nI didn't think it would add much, but here is the simplified version\n```\nexport const createOrUpdateNode = (payload) => (dispatch, getState) => {\n   dispatch(addContent(...args);\n   dispatch(updateNode(...args);\n\n};\n```. @Andarist I was mistaken while debugging. My second dispatched action was using an actionChannel to process requests serially (which was not working). \nDesired specs I'm trying to meet:\n1. Process queued actions serially through actionChannel (yield call api )\n2. When all actions are processed through channel, dispatch final action (dispatch FinalAction)\n3. FinalAction merges all previous api calls into one map as a payload\nI've attached the code below. \nMy use of takeEvery is incorrect since each dispatched action effectively forks a new channel. Derp. Here's my original code + my second attempt at writing a watcher for the actionChannel\n```\nfunction* transactionChannel(action) {\n    const buffer = buffers.expanding(5);\n    const channel = yield actionChannel('UPDATE_COMPONENT_CONTENT', buffer);\nlet transactionsPending = true;\n\nwhile (transactionsPending) {\n    const { payload } = yield take(channel);\n    let accumulator = {}\n\n    try {\n       // added delay to let calls accumulate in queue if they are dispatched in quick succession \n       yield call(delay, 200);\n        const { results } = yield call(putResource, options = {});\n        accumulator = results.reduce(reducingFunction, accumulator);\n\n        if (buffer.isEmpty()) {\n            // if buffer is empty, we can do one UPDATE to UI with accumulated results from API calls \n            yield put({ type: 'COMPLETE_TRANSACTIONS', payload: accumulator });\n            transactionsPending = false;\n        }\n    } catch (e) {\n        yield put({ type: 'PUT_FAILED', payload: e, error: true });\n    }\n}\n\n}\nconst actionUpdatesComponentContent = (action => action.type === 'UPDATE')\n// Is this causing X number of channels to be forked rather than taking from one? this does not work\nexport default function* componentContentSaga(action) {\n    yield takeEvery(actionUpdatesComponentContent, transactionChannel);\n}\n// My second attempt at filtering actions so only UPDATE enters the channel.\n// I do not think this works, but I do need one forked Channel per grouping of API calls\nexport default function* componentContentSaga(action) {\n    while (yield take(actionUpdatesComponentContent)) {\n        yield fork(transactionChannel(action))\n    }\n}\n// Third idea. More simple\nexport default function* componentContentSaga(action){\n    while (true) {\n        const finalResult  = yield take(actionUpdatesComponentContent)\n        // dispatch action to store with accumulated result\n    }\n}\n```\n. got it working pretty well. channels are schweet. We are hoping to use Redux-Saga in production. I've got a PR pending with our company, but still some final bugs to squash!\n. any workarounds for this? we use a middleware for rpc calls and I'd like to catch actions dispatched by them. The webpack bin link looks deprecated.\nWould the queuing occur within the createStore function? \nWould I just need to write an additional middleware to catch and re-emit those actions?\nSorry I\u2019m not clear on how to \n\nSubscribe to all actions emitted by middleware\nQueue them\nRe-dispatch then into a saga. @slorber great example and recommendation to use spawn at the top-level. It's nice to see real use-cases for spawn.\n\nCan you explain this statement?\n\nRestarting synchronously can, in my experience, lead to infinite loops (if the saga fails everytime you try to restart it) so I added a hacky delay for now to prevent this issue.\n\n\nHow does delay prevent this issue if a saga fails each time on restart?\nRather than yield a delay, can we just yield PUT{ error: true } to an error-reducer? (or yield to an error-catching saga). @slorber I tried using the restart strategy you mentioned for sagas, but found that it didn't make them anymore resilient.\n\nA saga failing crashes from a forked saga that failed an api call.\nI found that none of my sagas restarted :\\ \nAny idea as to why?\nAdditionally, is the 1 second truly necessary?\nwould yield call(delay, 0) work just as well? I'm assuming you're calling the delay just to get another \"tick\" in the event loop. I will try it out. Just to clarify:\nI want handleRequest to BLOCK until the call completes, then and only then take another request from the channel.\nOnce handleRequest puts \"DONE\", the watchRequest Saga does not continue.\nRedux dev tools shows that DONE was logged, but watch request does not continue.\nI would expect that upon receiving 'DONE', watchRequest would take another item from the channel\n\nThus what I'm learning from what you said, yielding an iterator does not allow watchRequest to continue (even if handleRequest completes). yup! you are right. \ud83c\udf8a  we're saga-official now. Thank you for the clarification! I think I follow now.\nBad\nwatchRequest -> handleRequest -> yield put(DONE)  -> watchRequest on take(DONE)\nw/fork\nwatchRequest, fork(handleRequest) -> watchRequest on take(DONE), handleRequest forked and running.\nbeen a lot of fun learning this library. closing!. I've seen autocomplete with observables, so very interested in a \"pull-based\" system with generators/sagas. (it will be an upcoming feature for us as well). 1. Only one polling job exists at a time\n2. User opens tab (takeLatest starts task)\n3. Polling begins (while loop is in first iteration)\n.....5 seconds elapse (while loop is in second iteration. race starts again)\n\nUser switches tabs (a new action for takeLatest)\n\nNew polling job begins (yay takeLatest. previous task is dropped)\n\n\nUser closes all tabs (the event that is being missed by race)\n\nPolling stops. I replaced the api call with a delay and found that race is working as expected\n\nMy api call is a simple fetch.\nShould I call a worker with a try/catch block?\n. being blocked on yield call delay makes sense\nI'm going to extract the api call into another worker so it goes\ntry {\nyield call(api)\n} catch {\n} finally {\nyield call(delay). THAT WAS IT.\nThank you @Andarist \nI embedded my delay in my api call and it correctly takes now. Seems as though this is expected via here\nhttp://stackoverflow.com/questions/40043644/redux-saga-how-to-create-multiple-calls-side-effects-programmatically-for-yield\nthus, how can we take that array of effects and actually instruct middleware to execute?. const results = yield postOptionsCollection.map(option => call(parallelPost, option))\nthat was my code copy pasted. The for-loop + fork + join is working for me, so I'll try it again next time the opportunity arises. if the above pattern is correct, I can conclude it must be my parallelPost call that was wrong.\n. code below\ndeleteResource returns a promise\nI would expect packet.length requests to be made in parallel and instead, nothing happens\nyield splitNodes.map(packet => call(deleteResource, {\n            firstId: packet.getIn([0, 'id']),\n            nodes: packet,\n            resource: 'content'\n        }));. great question! I'd suggest searching the issues section. there's a similar discussion here\nhttps://github.com/redux-saga/redux-saga/issues/760\ndocs also say that the \"watch/fork\" method allows for more powerful code patterns while takeEvery will guarantee that you fork a new task in response to a particular action\nas for the diff btwn yielding generators directly vs the use of fork, the only difference I can see right now is that if fork returns a task descriptor, it lends you the ability to cancel it directly.. You are correct. I did not read the source code/issue correctly in the above issue. any updates or tips on these?\nshould we look into adding Task descriptors?. This makes sense. Some examples\n\nA lengthy 100 line thunk that talks with multiple APIs\nLogic in thunks that mutate data before sending it to the reducer\n\nI ended up moving them over piecemeal\nAlso. I totally missed PUT.RESOLVE. I didn't know you could plug thunks into sagas.\nGreat API (provided I read the docs right haha, but great api either way)\n. we're handling in-app permissioning, so while there can be a valid login, certain types will have access to certain views/actions.\nI didn't use a higher-order-component + routing solution since this mostly works as a SPA, which makes certain actions (not routes) permissioned. sweet thank you @jimbol . it's a lengthy piece of code. I did end up figuring it out using the aforementioned strategy. shucks. I settled copying data from the channel and maintaining a separate counter for the items that pass through the channel.\nthank you for the quick reply!. makes sense. I took a look at the changelog and PR, but since it stemmed from someone asking about connect to non-Redux sources, it's not as apparent to me how I can apply these effects towards setting actionChannels/buffers as a type of context\ncould you give a really brief example of a use case for\n\nmake actionChannelContext\npass to child task?. WHOOOAOAOAOAOAO\n\nsuper stoked to try this out\nsidenote: verbiage around sagas seem very similar to Go. \u26a1\ufe0f  late to that realization but wanted to highlight it. PS. once I get this working (and work with it a bit more), more than happy to start on some docs for context. @Andarist the pattern I'm looking for is in having multiple sagas respond to the same actionChannel item that is taken from the queue. I buffer the items since I need to enforce serial completion of multiple api calls. When you say \"pure\", I'm interpreting that as \"no side-effects\". This is puzzling to me.\nRedux-Saga is a library for managing and creating side-effects (like async processes, timeouts, etc.). Even though it adopts the \"side-effects as data\" paradigm, I don't think they need to necessarily be \"pure\" in the Redux sense (like how a reducer always outputs a new state tree).\nSo no. Sagas don't need to be pure, which is why it's not mentioned in the docs.. ",
    "andraaspar": "Arrived here some time later via Google. Had to fix a couple of things to make takeLatestPerProps work:\n```JS\nfunction takeLatestPerProps(propsOrSelector, pattern, worker, ...args) { // Not a generator\n  return fork(function* () { // Fork a generator here to make it work like takeLatest\n    const channelsMap = {}\nwhile (true) {\n  const action = yield take(pattern) // yield necessary here\n  const propsValue = (typeof propsOrSelector === 'function' ? propsOrSelector(action) : action[propsOrSelector]) + ''\n  if (!channelsMap[propsValue]) {\n    channelsMap[propsValue] = channel()\n    yield takeLatest(channelsMap[propsValue], worker, ...args)\n    console.log(`channelsMap: ${Object.keys(channelsMap).join(`, `)}`) // List buildup of channels\n  }\n  yield put(channelsMap[propsValue], action)\n}\n\n})\n}\n```\nI have one major issue with this though. When used with a large number of different propsValues, it builds up an equal number of channels and forked tasks, and those are never removed. I added a log call to list them.\nMy use case is, I am loading items by ID and would like to cancel earlier requests to the same ID. Any suggestions?. ",
    "sublimeye": "@Andarist Thanks for the update. Yeah, I was wondering myself why those helpers were out of effects at all ... I'm new to redux-saga and spend like half a day on trying to figure out what's wrong (the error was really weird and didn't imply anyhow that a module or object wasn't imported or undefined). ",
    "webberwang": "Couldn't you just use\nyield take ('MY_ACTION') \nIt will block on take until that action is dispatched. ",
    "artemjackson": "Follow-up to https://github.com/redux-saga/redux-saga/issues/697#issuecomment-269497247\nTake a look at https://github.com/diegohaz/redux-saga-thunk. Follow-up to https://github.com/redux-saga/redux-saga/issues/697#issuecomment-269497247\nTake a look at https://github.com/diegohaz/redux-saga-thunk. ",
    "jessepinho": "A solution I'm using: create a super-simple middleware that listens for Redux actions that indicate \"done-ness,\" and then calls a provided callback that renders/sends the page to the client:\n```TypeScript\n// store.ts\nexport const getNewStore = (done: () => void): Store => {\n  const doneMiddleware: Middleware = store => next => action => {\n    const result = next(action)\nif (action.type === FOO_LOADED || FOO_NOT_FOUND) {\n  done()\n}\n\nreturn result\n\n}\nreturn createStore(\n    rootReducer,\n    initialState,\n    applyMiddleware(doneMiddleware),\n  )\n}\n```\n```TypeScript\n// server.ts\nexport default function(req: Request, res: Response, next: NextFunction) {\n  let store: Store\nconst done = () => {\n    const state = store.getState()\nif (state.Foo.isLoading === false) {\n  if (state.Foo.notFound) {\n    res.status(404)\n  }\n\n  res.send(someHTML)\n} else {\n  res.status(500)\n}\n\n}\nstore = getNewStore(done)\n// Dispatch the async action. The middleware will call done() once the async action has succeeded or failed.\n  store.dispatch(loadFoo())\n}\n```. ",
    "mrdulin": "@neurosnap I enter the breakpoint find this. Thanks! The example of README.md is wrong?. ",
    "aaroncraig10e": "Over a month after the last comment here, the docs are still out of date.  Any idea when the docs and code will be aligned?  For newcomers to this library it's already a steep learning curve, and frustrating when you follow the docs and things don't work.\nI'm happy to update the docs and open a PR if it looks like this will not get updated soon.. So, upon further toying around, I have it working like this: \njs\nimport { call, put, takeLatest } from 'redux-saga';\nimport { take } from 'redux-saga/effects';. Confirmed -- I was on an older version.. ",
    "adel-tahir": "@Andarist debug console snippet added\nhttps://i.imgur.com/hWAMF4D.png\n. @Andarist it turned out that there was an error in the api side.. ",
    "CarsonF": "Yes I can. But I'm not sure the definition for it. Are there parameters given to the method? returns void, right?. @aikoven better now?. I'm curious what the difference is there?. @aikoven Can you add emitter to the Monitor interface?. ",
    "awaw00": "@Andarist thanks for your reply.. ",
    "shawngustaw": "I'm not sure if this changed recently but the examples in the README don't match the examples in the documentation. . ",
    "ummahusla": "@Andarist Hey, yeah I will think what we can do with that Beginner tutorial and will try to take care of it. Moreover, I've seen that there are issues in the repository for that tutorial. I will evaluate the errors and find anything else we might need to add here. . @Andarist Hi, can you please review my work. I guess it's ready to be merged :rocket:  . @Andarist Thanks \ud83d\udc4d . ",
    "orourkedd": "Take a look at this: https://github.com/orourkedd/effects-as-data\nWe're using this at Pluralsight and have built key parts of the learning experience with it (front and back end).  effects-as-data solves the side effect problem but is designed to be used anywhere javascript runs.  Disclaimer: I wrote it.. ",
    "mcrawshaw": "PR awaiting review, same return type as fork.. ",
    "gabrielhpugliese": "We are using in production: https://www.shore.com/de/ (not this page, only on the real webapp)\n. I am having this issue too. I upgraded from 0.14.3 to 0.14.6 today.\nUsing webpack@2.2.1. Just tried to update webpack (2.3.3) but got the problem. Any ideas how to debug this?. Sorry, I am using the beta indirectly via this package: https://github.com/JeffreyWay/laravel-elixir-webpack-official\nAnd webpack was also in the package.json so I was confused.. Forgot to say: that package is also using webpack beta. When getting out of beta it works.. ",
    "mltucker": "Hey.  We use redux-saga in Wonderling.  It's a questions app for iPhone and Android (for getting closer to friends, family, and S.O.) built with react-native.  So happy with redux-saga -- thank you!\nLogos here, e.g. this one: .. ",
    "RoyLiou": "Kdan Mobile\n\nHi, everyone\nWe use Redux-saga in our shop page. ",
    "wub": "We use RS here at StarNow.\n. ",
    "Rohithzr": "We use it in production on CXIHUB\n. I am having this same issue on react-native\n```\n//rootSaga.js\nimport { takeEvery } from \"redux-saga/effects\";\nexport function* rootSaga() {\n    yield takeEvery(LoginSagaConstants.LOGIN, userLogin)\n}\n//loginSaga.js\nexport function* userLogin(action) {\n   console.log(\"userLogin not getting called\");\n   const response = yield call(LoginAPI.login, action.user);\n   console.log(response);\n   ...\n}\n//loginScreen.js\nconsole.log(\"start dispatching\");\ndispatch({\n    type: sagaConstants.LOGIN,\n    user: {\n        username: \"username\",\n        password: \"password\",\n        robottest : \"robottest\"\n    }\n});\n//store.js\nimport {createStore, applyMiddleware, compose} from \"redux\";\nimport {createLogger} from 'redux-logger'\nimport createSagaMiddleware from 'redux-saga'\nconst initialState = {};\n// import all Reducers\nimport {reducers} from \"./reducers\";\n// import all Sagas\nimport { rootSaga } from \"./sagas\";\n// define middlewares\nlet middlewares = [];\n// create and add the saga middleware\nconst sagaMiddleware = createSagaMiddleware();\nmiddlewares.push(sagaMiddleware);\n//add the freeze and logger dev middleware\nif (process.env.NODE_ENV !== 'production') {\n    middlewares.push(createLogger());\n}\n// apply the middleware\nlet middleware = applyMiddleware(...middlewares);\nconst enhancer = compose(\n    middleware\n)\nexport default function configureStore() {\n    const store = createStore(reducers, initialState, enhancer);\n    // run saga middleware\n    sagaMiddleware.run(rootSaga);\n    return store;\n}\n```\nApp.js\n...\nimport configureStore from './store'\nconst store = configureStore();\n...\nrender() {\n     return (\n            <Provider store={store}>\n                <RootStack/>\n            </Provider>\n        );\n    }\nmy console only prints start dispatching and nothing else happens.. My issue was resolved, it was some error on my part (as far as i can remember) if someone needs a working code example, let me know (i am not pasting the codes at the moment as I did not find any real issues with the library itself)\nFor me this issue can be closed.. ",
    "karland": "@Andarist I have played around a little and thought I'll make an attempt. How do you like this one? Feel free to make any suggestions....\n\n. @granmoe Thanks for the feedback. I made a new version, which I think is better... What do you think?\n\n. @Andarist Glad you like it. Feel free to use it, whenever and however you please. It would be CC0 of course.. ",
    "nihaux": "was looking for a logo for a presentation \ud83d\udc4d . I added documentation, refactored the tests to be closer to the real use case and squashed the commits.. switched testing doc to tape style and fixed typo. . According to the MDN,\n\nThe function* declaration (function keyword followed by an asterisk) defines a generator function, which returns a Generator object.\nThe Generator object is returned by a generator function and it conforms to both the iterable protocol and the iterator protocol.\nvar gen = idMaker(); // \"Generator { }\"\n\nSo it's kind of both :)\nIn my original code, it was called iterator but looking at MDN, I renamed it generator.\nI you still think its best calling it iterator, i will, i just wanted to share the reason why I called it gen in the first place.\nEdit: it's actually confusing as in some other place in MDN you can find\n\nA generator is a special type of function that works as a factory for iterators.\n. So I did a little digging to understand what is what.\nAccording to the ECMA 2015 spec (just started to read it from scratch, very interesting stuff :) )\nThe correct naming would be:\n\nfunction* helloWorld() {...}\n=> helloWorld is a generator function, it is an instance of (GeneratorFunction) constructor and it extends the (Generator) prototype.\nconst helloGen = helloWorld();\n=> helloGen is an instance of the helloWorld constructor, it extends helloGen.prototype which extends (Generator).prototype which extends (IteratorPrototype).\nhelloGen is a kind of Generator, which is a kind of Iterator.\nSo I think it would be more accurate to name it gen for generator. Even if it seems confusing at first, I think it's better to stick as close as possible to the spec.\nI find that this schema makes it more understandable.\nLet me know if you think I missed/missunderstood sth :). I don't really understand what you mean, should I remove the comment or format it differently ?. ",
    "brunolemos": "My bad, the lib I'm using was calling response.json() on an empty body and it was throwing an exception, making the task being rejected.. Hi @Andarist, thanks.\nI'll close this because after some hours losing my mind with it it just started working. Not sure what happened but it's probably not something in redux-saga's end.\nI'll come back at this to see if I'm able to find the root cause.. ",
    "fzaninotto": "@Andarist If I understand correctly, this advice only applies to yielding helpers from Sagas. What about composing several sagas from different domains?. My 2 cents about this: the current code and documentation isn't consistent on how to start several sagas in parallel from a root saga. This brings a lot of confusion about The Right Way To Do It.\nIn Beginner Tutorial, yield [childSaga()]: \njs\n// single entry point to start all Sagas at once\nexport default function* rootSaga() {\n  yield [\n    helloSaga(),\n    watchIncrementAsync()\n  ]\n}\nIn Shopping cart example, yield [fork(childSaga)]:\njs\nexport default function* root() {\n  yield [\n    fork(getAllProducts),\n    fork(watchGetProducts),\n    fork(watchCheckout)\n  ]\n}\nIn async example, yield fork(childSaga):\njs\nexport default function* root() {\n  yield fork(startup)\n  yield fork(nextRedditChange)\n  yield fork(invalidateReddit)\n}\nWhat's the advised way and why?. Found #178 on the same subject. Actually, advice spread across issue comments don't help. Is it possible to make the code and documentation consistent on that matter?. Well, I'm confused even more.\n\nyou say you can't make redux-saga doc and code consistent, but I don't understand why\nyou say in example 1) the root saga blocks, but since most of the underlying watches use takeEvery, which implicitly fork in 0.14 if I'm not mistaken, then it's not blocking. \nexample 1 seems to have serious drawbacks because of the blocking risk, yet it's what used in the first tutorial in the documentation - the one developers like me will refer to when composing sagas. \nexample 4 uses spawn, which is not the default way to make non-blocking calls according to the documentation (it's fork). I tried to understand the difference between spawn and fork by reading the related doc, and my brain melted.\nexamples 5 and 6 add to the confusion: are they better than the others? Should we forget about all the previous examples and use these? I'm really looking for a simple answer.\nthinking that users will understand the intricacies of these choices makes redux a bit too elitist IMO. I'm a long time ES6 developer, and I still don't understand what I'm supposed to use in my use case. You'd better choose the best method, and use it all around the doc and say \"that's the only way you should do\", without explaining how it works under the hood. Much better Developer Experience!\n\nSorry to take your time on this, but I'm developing an open-source based on saga (admin-on-rest), and I struggle to explain to my users how they should compose their sagas and why.. Thanks for taking the time to explain, I appreciate.\n\nI'm not either officially from redux-saga team\n\nThen maybe @yelouafi or @Andarist could provide insight, too?\n\neverybody can contribute to the doc if something is not clear enough\n\nI'd love to, I just don't know what to write because I don't understand the rationale behind these gazillion choices.\n\nThe root saga blocks if any subtask blocks\n\nSo I understand that example 1) should be discouraged, because if a subsaga isn't forked, then the developer exposes themselves to problems. Should we update the tutorial accordingly?\n\nspawned sagas are a bit like new root sagas\n\nMy understanding is that they are for advanced usage, so this shouldn't be the main recommendation, right ? \nAll in all, am I right to think that example 3 is safe to use in most cases, simple to explain, and should be the syntax to encourage?\n\nRedux-saga is probably not yet mature enough and the doc could certainly be better.\n\nI think the code is great but the documentation is clearly lagging in behind. And documentation is at least as important as code for open-source projects. Again, I'd love to help if there was a Definitive Way to do things. \n. ",
    "nbostrom": "These typing doesn't actually allow the iterator to use delay since it returns a Promise in place of an Effect. I think that we need to update the SagaIterator definition to something like:\nexport type SagaIterator = IterableIterator<Effect|Effect[]|Promise<any>>;\nOr update the Effect def if redux-saga counts Promises as Effecs.\nI'm not very good at typescript yet, so there's probably a better way. ;). @aikoven Oh, I see. That makes a lot of sense. Thanks!. ",
    "dcolthorp": "+\ud83d\udcaf Many of the current definitions are close to useless, as they provide no safety.\nAny news as to whether this will be merged and/or released? It would be nice to at least pin to a commit in the redux-saga instead of a fork.. @Andarist Yeah, they're exactly what I was hoping for. One of the main reasons to use TypeScript to begin with is safety, and the currently released type definitions are useless there, because any invalid arguments to e.g. call fall back on an alternate definition that completely gives up type safety.\nThe currently released type definitions are problematic enough that I was questioning the viability of using sagas in my TypeScript project at all until I found this PR. I suspect getting this merged would be of high priority to anyone using sagas in typescript.. Excellent, thank you @Andarist and @aikoven for your work!. Oh, thanks! Looks like my searching was too narrowly focused on call.. That's about as good as it gets, AFAIK. I'm pretty sure yield always returns any, as it's fundamentally dynamic and in the control of whoever's calling next. So you definitely need to explicitly type stateData to my knowledge.\nYou could get a little more help by wrapping select with something like \nts\nexport function selectState<T>(selector: (s:State) => T): SelectEffect {\n  return select(selector);\n}\nto at least enforce that you're using a function that selects on the right thing. This also gives you the option of explicitly annotating the return type, such as:\nts\nconst stateData: SubType = yield selectState<SubType>(getSubType);\nThis is a little repetitive, but is easy to visually verify that the variable type and expected return type are the same, and doing so will let TypeScript enforce that getSubType returns the right thing, aiding refactoring.\nGranted, the type argument is optional \u2013\u00a0you could simply yield selectState(getSubType) and rely on tests or runtime exceptions to identify a return type incompatibility, as with select. In this case, the type system will at least verify that getSubType takes an argument compatible with State, even if you aren't constraining the return type for compatibility with the type of stateData.. That's about as good as it gets, AFAIK. I'm pretty sure yield always returns any, as it's fundamentally dynamic and in the control of whoever's calling next. So you definitely need to explicitly type stateData to my knowledge.\nYou could get a little more help by wrapping select with something like \nts\nexport function selectState<T>(selector: (s:State) => T): SelectEffect {\n  return select(selector);\n}\nto at least enforce that you're using a function that selects on the right thing. This also gives you the option of explicitly annotating the return type, such as:\nts\nconst stateData: SubType = yield selectState<SubType>(getSubType);\nThis is a little repetitive, but is easy to visually verify that the variable type and expected return type are the same, and doing so will let TypeScript enforce that getSubType returns the right thing, aiding refactoring.\nGranted, the type argument is optional \u2013\u00a0you could simply yield selectState(getSubType) and rely on tests or runtime exceptions to identify a return type incompatibility, as with select. In this case, the type system will at least verify that getSubType takes an argument compatible with State, even if you aren't constraining the return type for compatibility with the type of stateData.. ",
    "yenshih": "I've seen his PR, it's definitely better than mine. A great job :). ",
    "clouddra": "@Andarist thanks for the clarification. *first() actually does a lot more things (forking and cancelling other sagas) but I have omitted them to keep the discussion simple. \nSo am I right to say that there is no way to synchronously dispatch an action and wait for the completion of the saga chain before transiting to the next state? I thought that such a use case would be pretty common.. Cool. Totally forgot about matching on FINISH_FIRST.\nJust to point out that the fork example does not work if we have something like this:\njavascript\nfunction* first() {\n  yield takeLatest('START_FIRST', firstAsync)\n}\nfork(firstAsync, action) will bypass takeLatest.\nThanks for the help.\n. Yup using nested takeLatest is definitely not a good idea. Just wanted to use it to point out that it might not work for the fork case if we want takeLatest semantics.\nIn my case I did organized things manually (complex saga dependencies) in my code. . yup single ones work fine with fork.\nThe actual code looks something like (with variable names changed to keep things simple):\n```javascript\nfunction* first() {\n  let firstRunning;\n  let someOtherSagaRunning = yield fork(someOtherSaga);\nwhile (true) { // eslint-disable-line no-constant-condition\n    const actionPayload = yield take(START_FIRST);\n    if (firstRunning) {\n      yield cancel(firstRunning);\n    }\n    yield cancel(anotherSaga);\n    someOtherSagaRunning = yield fork(someOtherSaga);\n    firstRunning = yield fork(firstAsync, actionPayload);\n  }\n}\n```\nIt is similar to a takelatest with additional logic inside. I always want to run firstAsync with the newest actionPayload and drop any someOtherSaga that is currently running.\n\nsomeOtherSagahas it own logic which matches other actions.\n*first() and *firstThenSecond() can be triggered independent of each other (hence the two different constants).\n\nIn this case, yield take(FINISH_FIRST) would work fine but I think it can be difficult to make fork(firstAsync, action) work (I could be wrong though...).. ",
    "CyrilQuandalle": "Thank you for your quick answer, I'll restructure my loop and let you know when I  have an acceptable structure. ",
    "pcgilday": "\nso its basically a parallelEffect (yielding array of effects) but each effect is wrapped in a pair of { result, isError }?\n\nSomewhat, the major benefit is making sure all the effects running in parallel complete, whereas with parallelEffect, if one effect throws an error, the rest are cancelled. For example, if I have the below call (taken from docs, but we have something similar), and one of those effects throws an error, any of the effects still pending will be cancelled, when using parallelEffect. When we call something like fetchCustomers, a complete action is dispatched after the data is fetched so that the data is reduced into state. If fetchProducts throws an error, then fetchCustomers is cancelled and the customers are never reduced into state, so instead of missing one chunk of data, we are now missing two. \njs\nconst [customers, products] = yield [\n    call(fetchCustomers),\n    call(fetchProducts),\n]\nIf I use this settle effect combinator, I can still handle an error that may occur, but the rest of the effects are able to complete first, leaving state in a better place. This is just one example, but I believe having a way to run effects in parallel without having a single error cancel the rest of the effects running would be desirable. \nI think this is a useful effect combinator to have in this lib, promise libraries like q use something similar (not that someone else doing it makes it right, just a note). As far as settle not telling much about the behavior, I would be open to name suggestions, but that seemed the best choice as it is a known term used when dealing with promises, and seems to be used for internal variables representing the same concept within redux-saga here\n\ncustom effects - would be really cool if we support those, any ideas for the API?\n\nAgree, we have used the approach mentioned here, but having an API for custom effects would be nice. As far as a suggestion for that, I would have to think on it some.\n\nerror handling, cancellation - what do you feel is lacking and what could be done better? should behaviours be more configurable somehow?\n\nI believe this was covered by my response above, but if not I can expand.. That was an option @SpainTrain and I discussed before I opened this PR. We thought it would be more elegant to use an effect combinator like settle, instead of having to wrap each call with a new effect. With the safeCall approach, if you used an effect other than call, you would need safePut, safeCps, etc.\nBut I think that is the decision to be made, the safeCall approach or the settle approach, unless there is a better way to accomplish this that we're missing. . Just wanted to ping and see what the current thoughts or status for this PR are. I'll still need to add documentation if we think it will be merged, so if that would help further the discussion I would be happy to get that done in the next couple days.. ",
    "jedrichards": "I must admit I'm really struggling to feel confident about my redux-saga architecture at the moment too.\nIt feels like redux-saga is providing some extremely powerful but also very low-level tools at the moment. Something like a set of primitives for composing these async side effect descriptions. Is it fair to say there could be a role for helper libraries to sit on top of redux-saga and provide \"blessed\" ways to perform the most idiomatic approaches to common use cases?\nIn any case, is the following a fair description of the most common use-case for redux-saga (at least for developers that are new to it):\n\nA need to compose a set of \"watchers\" within a file into one saga for exporting\nThen compose those exported watcher sagas into one final root saga\nEach watcher mainly just watches for one redux action, and then executes a corresponding worker saga\nAll watchers should run in parallel and not block each other\nUncaught errors in sagas below the root should not explode the whole app\n\nI'm sure there's a world of more possibilities than that, but it seems like the first step for many? Basically copying the functionality of redux-thunk but with the great testability that comes with sagas?. @dcolthorp @subvertallchris How about this. Use the return type of the selector itself:\nconst foo: ReturnType<typeof getFoo> = yield select(getFoo). Aha thanks! Good to know - I could have just checked the docs more carefully. My b.. ",
    "lydell": "As of 2018-01-25 the beginner tutorial says:\njs\nexport default function* rootSaga() {\n  yield all([\n    helloSaga(),\n    watchIncrementAsync()\n  ])\n}\nAs a beginner, I\u2019m going to go with that until I run into problems.\nIt would be awesome if there was a section in the docs discussing different ways of implementing the root saga, mentioning pros and cons of each. Also mention what multiple calls to sagaMiddleware.run would mean.. As of 2018-01-25 the beginner tutorial says:\njs\nexport default function* rootSaga() {\n  yield all([\n    helloSaga(),\n    watchIncrementAsync()\n  ])\n}\nAs a beginner, I\u2019m going to go with that until I run into problems.\nIt would be awesome if there was a section in the docs discussing different ways of implementing the root saga, mentioning pros and cons of each. Also mention what multiple calls to sagaMiddleware.run would mean.. ",
    "henninghall": "@slorber Im trying out your example number 6 but I aonly get it to work by adding all like this>\nexport default function* root() {\n  yield all(rootSagas.map(saga => call(saga)));\n}\nI guess it has to do with changes in a newer version of saga. Is this the proper way to do it? . ",
    "richardszalay": "\nif there's an exception inside the saga\n\nWorse, because yielding put calls the reducers, errors throws in any reducers also get the message-less RedScreen.. Absolutely, though coming from React Native it would be nice if the error was formatted the same. \nIn fact, is there any reason the error object itself can't be logged? That would allow the platform to handle its display in the console.. ",
    "karl-freeman": "The error.stack property is implemented inconsistently across browsers. Most notably, it includes the error message in Chrome, but not in Firefox. This makes debugging in Firefox a tad harder.\nSince the stack property is non-standard, I would be in favour of dropping it completely, but as a quick fix, I would also welcome adding the error.message to the log, even if this would duplicate it in Chrome.. ",
    "danstepanov": "@Andarist @richardszalay What is blocking merging that simple change (adding error.message to the log)?. @Andarist Based on the above, I'm not sure where the issue is occurring in my code. Perhaps yield allSagas?\n\n. ",
    "jmn8718": "Yes, thank you for your answer, it worked. I saw that in the warning but i did not change it in the right place. ",
    "wanbinkimoon": "Same problem here but I'm using yield and NOT yield* . Same problem here but I'm using yield and NOT yield* . here is how I compose the (damn) call \n```javascript\nfunction* loadHomeData(action) {\n...\n\nyield put(homeIsLoading(action.entity_id))\n\ntry {\n  const data = yield call(request, requestURL, requestOpt);\n  yield put(homeLoaded(data));\n}\n\ncatch (e) {\n  console.warn(e);\n}\n\n}\n}\nfunction* loadHome() {\n  yield takeLatest(HOME_DO_LOAD, loadHomeData);\n}\n```. here is how I compose the (damn) call \n```javascript\nfunction* loadHomeData(action) {\n...\n\nyield put(homeIsLoading(action.entity_id))\n\ntry {\n  const data = yield call(request, requestURL, requestOpt);\n  yield put(homeLoaded(data));\n}\n\ncatch (e) {\n  console.warn(e);\n}\n\n}\n}\nfunction* loadHome() {\n  yield takeLatest(HOME_DO_LOAD, loadHomeData);\n}\n``. Multiple calls on the same action which isHOME_DO_LOAD. Multiple calls on the same action which isHOME_DO_LOAD. @erikvoldloadHomeis called on home container mount. \n@Andarist Nope I'm not injecting sagas depending on routes ... . @erikvoldloadHome` is called on home container mount. \n@Andarist Nope I'm not injecting sagas depending on routes ... . I'll do that asap :)\nOn Sun, Jul 23, 2017 at 2:50 PM Mateusz Burzy\u0144ski notifications@github.com\nwrote:\n\n@wanbinkimoon https://github.com/wanbinkimoon could u share a\nreproduced issue on smth like codesandbox or share ur repository? I would\nlove to help u with this\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/769#issuecomment-317250864,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJns19VScsJEkuNh7RocBoPdZ8EKntj1ks5sQ0GvgaJpZM4Lkyvn\n.\n-- \nNicola Bertelloni // +39 328 4559247\n. I'll do that asap :)\n\nOn Sun, Jul 23, 2017 at 2:50 PM Mateusz Burzy\u0144ski notifications@github.com\nwrote:\n\n@wanbinkimoon https://github.com/wanbinkimoon could u share a\nreproduced issue on smth like codesandbox or share ur repository? I would\nlove to help u with this\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/769#issuecomment-317250864,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJns19VScsJEkuNh7RocBoPdZ8EKntj1ks5sQ0GvgaJpZM4Lkyvn\n.\n-- \nNicola Bertelloni // +39 328 4559247\n. Are you using my same boilerplate?. Are you using my same boilerplate?. \n",
    "asling": "@Andarist excuse me.  takeLastest doe not work  in my project too. I confused that u said  'injecting async sagas on the routes' and 'multiple active watchers'. So how can i cancel  watcher when actived others sagas?. ",
    "wellyal": "I am having the exact same problem. Any reason why this issue was closed?\nrootSaga.js\n```js\nimport { all, fork } from 'redux-saga/effects'\nimport watchCustody from './modules/custody'\nexport default function *rootSaga() {\n  yield all([(watchCustody())])\n}\n```\ncustody.js\n```js\nimport { put, call, takeLatest } from 'redux-saga/effects'\nimport { ACTION_TYPES } from 'store/reducers/custody'\nimport { getCustody as getCustodyService } from 'services'\nconst { CUSTODY_REQUEST, CUSTODY_SUCCESS, CUSTODY_ERROR } = ACTION_TYPES\nexport function *getCustody(payload) {\n  try {\n    const response = yield call(getCustodyService, payload)\n    yield put({ type: CUSTODY_SUCCESS, payload: response })\n  } catch (err) {\n    yield put({ type: CUSTODY_ERROR, payload: err })\n  }\n}\nexport default function *watchCustody() {\n  yield takeLatest(CUSTODY_REQUEST, getCustody)\n}\n```\nI dipatch the action from componentDidMount. The takeLatest function is triggering as many requests as I mount the component, and is not cancelling my older pending requests to the same action.. I will try later. But thats the entire code related to the issue. I just call an actionCreator from my component like\njs\ncomponentDidMount() {\n      this.props.getCustodyConnect()\n    }\nand my index.js is like\n```js\nimport dotenv from 'dotenv'\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { ThemeProvider } from 'styled-components'\nimport createSagaMiddleware from 'redux-saga'\nimport rootSaga from 'sagas'\nimport configureStore from 'store/configureStore'\nimport Routes from 'routes'\nimport theme from 'config/themes'\nimport registerServiceWorker from 'registerServiceWorker'\ndotenv.config()\nconst sagaMiddleware = createSagaMiddleware()\nconst store = configureStore(sagaMiddleware)\nsagaMiddleware.run(rootSaga)\nrender(\n  \n\n\n\n,\n  document.getElementById('app')\n)\nregisterServiceWorker()\n```\nI don't see what else could wrong.. @Andarist Just so you know the function not being called was getUserExpenses. I've replaced both function calls from rootSaga with the fork calls. Like this.\njs\nyield all([\n    fork(watchAuthenticate),\n    fork(watchGetUserExpenses)\n  ])\nAnd it didn't worked. I've also tried to refactor the takeEvey as you said but it didn't worked (I got an compile error).. Here is the source code. I realise that when I call the first saga (watchAuthenticate) and right after execute the other, both execute as expected. But when I try to dispatch only getUserExpenses it doen't work.. @Andarist No way. I can't believe it was that simple. Thanks man. I've spent hours trying to figure that out. \nCould you please answer me one more question? Should I use fork on every watcher I am declaring? I saw that fork makes saga perform a non blocking call to a specific function. Can you explain me why this refactor its better than my old solution? Or just send some link so I can understand better. Again thanks, you just saved my live.. ",
    "dxiao": "cause if it's a type alias, the recursion doesn't work. something subtle about how the typescript caches types.\nI get that you should always yield effects if possible (for testing purposes) but seems weird to limit typings based on what's suggested, instead of what's possible.. Thank you!\nMateusz Burzy\u0144ski notifications@github.com\u4e8e2017\u5e742\u67089\u65e5 \u5468\u56db23:45\u5199\u9053\uff1a\n\nClosed #770 https://github.com/redux-saga/redux-saga/pull/770.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/770#event-956878791, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAlj8AA42ZY7kMXtb9M7aGMxxOH_hIikks5rbBWOgaJpZM4LmGB8\n.\n. \n",
    "al-zah": "@Andarist Thats what sentry is recommends when using redux: https://blog.sentry.io/2016/08/24/redux-middleware-error-logging.html\n@slorber You right, it's better to call getState directly, going to close this PR, sorry for wasted time :sweat_smile:. ",
    "matttti": "Thanks for your reply. Yes, leveraging type inference by extracting the return type is my intention. I think this is what makes type systems so powerful in detecting the hidden bugs. I'll try to give more explanation, also to make some thoughts clear for myself. \nAnd it would be really really great if ppl from the flow community could help here.\nThe problem with generator typing in general, is the fact that it is completely up to the application (here: redux-saga middleware) what data and type to pass back in iterator.next(...) calls.\nOr in other words: the decision what type the LHS of a yield statement has, is determined by the caller of the generator, and not solely the RHS. Only the latter can be easily inferred by a type system.\nSo the only reasonable and safe return type here is any. Flow allows, however, to specify a global yield return type Y in Generator<*, *, Y>. No idea where this could be of any use...\nI don't think it is possible to \"connect\" effect's objects to yield atm. One speculative way I could imagine would be to allow a RHS->LHS mapping dictionary in the place of Y. Or to give each effect a second annotation how it should behave when situated in a yield context. But my gut feeling is pessimistic that these are realistic approaches for flow.\nRegarding your questions for other examples besides select. The pattern should stay the same for all kind of effects. All return types change from Object to Generator<*, R, *>. Maybe it could be generalized like this:\n```javascript\nfunction * IOEffectGenerator(effect, ...args) {\n  return yield effect(...args)\n}\nexport select = IOEffectGenerator.bind(IOEffects.select)\nexport call = IOEffectGenerator.bind(IOEffects.call)\n```\nHowever, I'm no expert of the Saga-API, and don't know all possible contexts.\nEdit: hmm, const action = yield take(MY_ACTION) is tricky.. Thanks @Andarist for finding the two threads. Especially the second one deals with the same problem.\nI created a gist containing implementations of the effects I need (call, fork, cps, cancelled, select). Works quite reliable for me. Hope this will be helpful for someone out there.\nHowever, the takeeffect family still gives me a headache, and I would be glad to get some input from the community here. I thought about using \"action prototypes\" instead of \"actiontype constants\" as first paramter, but I'm not very convinced.. I'm using the solution described above. It's not complete, but I'm happy for now.. ",
    "garmjs": "I dont think it need to be in library . ",
    "notgiorgi": "Yep, there are ways to achieve this, but you can also manually do any of the supported patterns using your own predicate.\nI think regex would be convenient. Checking for suffixes is common thing. This is the way mentioned in the specification for getting the class of object.\nhttp://stackoverflow.com/a/4339385/5341953. ",
    "rvlewerissa": "@Andarist OMG, thanks so much dude. Really clear this up!! I'll close this ya.. Thanks again!. ",
    "forest": "I have an app built with Aurelia CLI + TypeScript. It uses RequireJS as the loader. I load the main file lib/index.js and that loads internal\\utils.js. This file includes the reference to process which is not defined in the browser context.\nMaybe I'm doing something wrong.. I have an app built with Aurelia CLI + TypeScript. It uses RequireJS as the loader. I load the main file lib/index.js and that loads internal\\utils.js. This file includes the reference to process which is not defined in the browser context.\nMaybe I'm doing something wrong.. I believe it uses its own system. I'm guessing there is a bug in Aurelia CLI since this is not an issue for others. Let's close this for now.\nIs this code excluded when bundling with webpack, for instance?. I believe it uses its own system. I'm guessing there is a bug in Aurelia CLI since this is not an issue for others. Let's close this for now.\nIs this code excluded when bundling with webpack, for instance?. Ahh. I didn't know they were replaced. That makes much more sense. I'll find out if they support that.\nI have found redux to be a really nice way to manage state in an Aurelia project. redux-thunk has been working fine but is hard to test, as you mention in the saga docs. I also like how you can create flows with saga that are pretty easy to read. I originally found saga when I was looking for a way to have one redux state change trigger another change. This isn't how redux works, but saga flow makes this possible and very clean.\n. Ahh. I didn't know they were replaced. That makes much more sense. I'll find out if they support that.\nI have found redux to be a really nice way to manage state in an Aurelia project. redux-thunk has been working fine but is hard to test, as you mention in the saga docs. I also like how you can create flows with saga that are pretty easy to read. I originally found saga when I was looking for a way to have one redux state change trigger another change. This isn't how redux works, but saga flow makes this possible and very clean.\n. So there is a babel plugin to do this, but I'm using typescript as my transpiler. I ended up just adding something to my gulp pipeline at the end to replace process.env.NODE_ENV.. So there is a babel plugin to do this, but I'm using typescript as my transpiler. I ended up just adding something to my gulp pipeline at the end to replace process.env.NODE_ENV.. The Aurelia project has this code to be defensive about using environment variables.\n```javascript\nvar hasEnvVariables = typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\";\nfunction env(key) {\n    return hasEnvVariables ? process.env[key] : undefined;\n}\n```\nNot sure there is a better solution than being defensive.. The Aurelia project has this code to be defensive about using environment variables.\n```javascript\nvar hasEnvVariables = typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\";\nfunction env(key) {\n    return hasEnvVariables ? process.env[key] : undefined;\n}\n```\nNot sure there is a better solution than being defensive.. Sorry. This is actually bluebird code. Aurelia doesn't use process in any of its code since it is expected to run in the browser and not a node environment.\nhttps://github.com/petkaantonov/bluebird/blob/ac381051cd26a6d1b735d9f8a239710f68a899c4/src/util.js#L321. Sorry. This is actually bluebird code. Aurelia doesn't use process in any of its code since it is expected to run in the browser and not a node environment.\nhttps://github.com/petkaantonov/bluebird/blob/ac381051cd26a6d1b735d9f8a239710f68a899c4/src/util.js#L321. Sounds good.\nOn Thu, Feb 9, 2017 at 5:28 AM Mateusz Burzy\u0144ski notifications@github.com\nwrote:\n\nDifferentiating between envs is not only made for node vs browser, but\nalso for differentiating your dev and production builds - both targeting\nbrowser.\nAnyway - I'll look later into the PR and we gonna go full defensive, it\nwont hurt the project after all and it'' help you\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/778#issuecomment-278640377,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAelaAcoSbXP6b8vCaOG1_vc7IgXivlks5raxSEgaJpZM4LpsrV\n.\n. Sounds good.\nOn Thu, Feb 9, 2017 at 5:28 AM Mateusz Burzy\u0144ski notifications@github.com\nwrote:\nDifferentiating between envs is not only made for node vs browser, but\nalso for differentiating your dev and production builds - both targeting\nbrowser.\nAnyway - I'll look later into the PR and we gonna go full defensive, it\nwont hurt the project after all and it'' help you\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/778#issuecomment-278640377,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAelaAcoSbXP6b8vCaOG1_vc7IgXivlks5raxSEgaJpZM4LpsrV\n.\n. @Andarist I can wait. Thanks.. \ud83d\udc4d . @Andarist I understand now.\n\nCan you change this https://github.com/redux-saga/redux-saga/blob/master/webpack.config.dev.js#L10 to \nPRODUCTION: JSON.stringify(false)\nand this https://github.com/redux-saga/redux-saga/blob/master/webpack.config.prod.js#L10 to \nPRODUCTION: JSON.stringify(true)\nI think that will create a global constant that is just for your purposes and doesn't conflict with something existing.\nThen in code you do if(!PRODUCTION) {}.. @Andarist I understand now.\nCan you change this https://github.com/redux-saga/redux-saga/blob/master/webpack.config.dev.js#L10 to \nPRODUCTION: JSON.stringify(false)\nand this https://github.com/redux-saga/redux-saga/blob/master/webpack.config.prod.js#L10 to \nPRODUCTION: JSON.stringify(true)\nI think that will create a global constant that is just for your purposes and doesn't conflict with something existing.\nThen in code you do if(!PRODUCTION) {}.. The docs of DefinePlugin give this as an example.\nhttps://webpack.github.io/docs/list-of-plugins.html#defineplugin. The docs of DefinePlugin give this as an example.\nhttps://webpack.github.io/docs/list-of-plugins.html#defineplugin. @Andarist yes. I could use envify. I already did something similar to work around this issue. I opened this issue because it didn't seem like my responsibility to handle that, but if there isn't a good solution then other users will need to deal with this too. . @Andarist yes. I could use envify. I already did something similar to work around this issue. I opened this issue because it didn't seem like my responsibility to handle that, but if there isn't a good solution then other users will need to deal with this too. . Go for it. Thanks.. ",
    "epikhighs": "@slorber hi, could you clarify - how I might be confusing takeEvery and takeLatest?\ninitSaga is only run once so far in my project, but in the future there could be a use case where it might run multiple times.\nmy implementation of takeEverySync basically uses take directly. I could change it so that it doesn't use the actionChannel, but I still have the same problem where the put.resolve() is not blocking so that code that relies on the state to be updated from the put.resolve breaks.\nexport function* initSaga (action) {\n    while (true) {\n        yield take(INIT_SAGA);\n        yield put.resolve(INIT1, 1)); \n        yield put.resolve(INIT2, 2));\n        yield put.resolve(INIT3, 3));\n    }\n}. @slorber you are correct that put.resolve only takes one argument.  I was copy pasting from my project code and forgot that I was using helper functions in my project.  Anyways, this is a more complete code sample of what I'm doing. \n```\nexport function* initSaga (action) {\n    yield put.resolve({type: 'INIT1', payload: 1,});\n    yield put.resolve({type: 'INIT2', payload: 2,});\n    yield put.resolve({type: 'INIT3', payload: 3,});\n}\nfunction* takeEverySync(pattern, saga, ...args) {\n    const requestChan = yield actionChannel(pattern);\n    while (true) {\n        const action = yield take(requestChan);\n        yield call(saga, ...args.concat(action));\n    }\n}\nexport default function* rootSaga () {\n    yield takeEverySync('INIT', initSaga);\n}\n// in some other saga in response to URL change\nyield put.resolve({type: 'INIT'});\n// at this point state should have been initialized but it isn't \nconst state = (yield select());\n// if i use call instead, then the initSaga and all the put.resolves execute synchronously\nyield call(initSaga);\n// at this point state is initialized successfully\nconst state = (yield select());\n. This is how I'm creating the store @Andarist\n        rootStore = createStore(rootReducer, rootState, compose(\n            applyMiddleware(thunk),\n            applyMiddleware(sagaMiddleware),\n            ReduxTool.instrument()\n        ));\n        if (module.hot) {\n            module.hot.accept('src/main/rootReducer', () =>\n                rootStore.replaceReducer(require('src/main/rootReducer')/.default if you use Babel 6+ /)\n            );\n        }\n```. @Andarist the INIT action that gets dispatched isn't handled by a thunk.  It just simply goes to the reducer.  I have redux-thunk as a middleware b/c of older code that started off using it, but we've been migrating most new code to sagas exclusively.\nI tried removing the redux-thunk middleware and it does not change the behavior.\nShould I be using redux-thunk to handle the INIT action?. @Andarist I can prepare a webpackbin.  I haven't used it before, however. I'm not sure how to include redux saga and other middleware. Webpackbin only seems to have redux support out of the box.. Hmm. I'm going to http://www.webpackbin.com/ and it has a boilerplates dropdown, but the list of options seems to be fixed.  I can't type in there to add other libs.  I only see redux in there.. Ohhh, i didn't see that option b/c my browser window width was too small!  I see it now. I'll try to setup something.  Thanks.. Im getting a \"regeneratorRuntime is not defined\" error when I try to include a generator function.  I tried including 'babel-polyfill', but webpackbin is throwing errors when trying to download that package.  Do you have a webpackbin that already has this boilerplate setup?. http://www.webpackbin.com/VJoneYkwz\nA bare bones project with only 1 generator function.  Can't seem to get it to work.. @granmoe thanks for the boilerplate. \n@Andarist http://www.webpackbin.com/Eyni351Dz  refer to the saga.js comments I put in to test the two use cases.\nMy example dispatches the URL_CHANGE action twice to verify that there is a race condition and that put.resolve does not work as I thought it should.\nThanks for all your help guys.. so is there another way to make the INIT action dispatch either synchronous or have it wait until the state tree is updated and then the rest of the onUrlChange saga executes?\nThe only way to update state is through PUTs and if PUTs are always async, then I'm not sure how I can sequence the kind of logic I'm trying to do in the onUrlChange saga.. Thanks @Andarist. \nIn general, my sagas always have PUT as the very last line.  So I never ran into this issue. But when trying to sequence this initialization logic, I'm running into this issue.  I also anticipate the more my saga flows start to interleave and depend on each other, I'll have more situations like this.. @Andarist thank you so much! Such a simple solution :) \nAnd thank you to everyone else at the redux saga team.\nBtw, is there an example of how to use put.resolve correctly with thunks?. An updated example of the solution: http://www.webpackbin.com/VygyT4Mwf. I remember a while ago, that if I tried to import from redux-saga/effects that I could not get the takeLatest/takeEvery import to work.  But now that I try again using the latest redux-saga, it seems to import from redux-saga/effects just fine.  So I\"ll use that from now on.  Thanks.. Just a random guy making an observation.\nIt seems that testing the call effect for your helperIsExported function is in line with the saga philosophy of only invoking effects through the saga effects helpers (e.g. put, call, fork etc).  So I'm not sure if there would be a \"better way\" to accomplish your testing effort.  I feel that is the way you're guided towards given the saga API.\nOn a related note, I didn't include test coverage for sagas much b/c of needing to test each effect in sequence.  However, redux-saga-test-plan allows for sequenced tests and non-sequenced tests (https://redux-saga-test-plan.jeremyfairbank.com/).  So instead of testing effects got called in a certain sequence, I'm testing that given a starting state, that the ending state is achieved  (https://redux-saga-test-plan.jeremyfairbank.com/integration-testing/state.html).  Might be worth a consideration. \nVerifying beginning and end state isn't the only option for adding test coverage to sagas via redux-saga-test-plan, but it's a strategy I'm inclined to.  Maybe it'll suit your needs as well.. Thanks for the clarification.\nThe problem I'm trying to solve is to be notified of uncaught exceptions in sagas so that I can properly handle the exception.  I do not have to recover from them.  So I will try adding the onError function to the middleware.\nAs for the ideal solution, I would think this is problem outside of redux-saga.  In other words, as you pointed out, it's a general problem with error handling async code.  As long as we have a means to be notified of all uncaught exceptions via the middleware onError function, then it feels to me that's the best thing redux-saga can do so that ultimately, the developer can add the proper error handling where needed.\nHaving said all of this, I would assume most developers (especially those new to redux-saga and async programming) do not fully consider how to properly implement error handling.  So more examples, conventions and recommendations would help everyone in this regard.. I had to eventually make a similar distinction in my code base.  Vuex (vue.js's version of redux) seems to make a distinction via Mutations (https://vuex.vuejs.org/en/mutations.html) vs. Actions (https://vuex.vuejs.org/en/actions.html).  But it doesn't seem to offer guidance on naming conventions for actions.\nI ended up with a convention of suffixing _INIT or _UPDATE for actions that directly invoked the reducer to update state.  _INIT simply replaces state and _UPDATE merges in pieces of the state.  This approach has a limitation where sometimes you need to dispatch an action to the reducer that does a very custom update to the state, where _INIT or _UPDATE isn't suited for, but those types of actions are the exception fortunately.\nI'm curious what other people have done?. I'd either use select to inspect the store for the desired data or in the reducer, when the list changes, you can update a isLoading property in the state based on list length.  I'd probably prefer to dispatch an explicit LOADING action to make updates explicit, but it depends on your preference and the situation.. what does your test look like?. in my root saga, if I use the implemntation of takeLatest or takeEvery that uses fork, then it blocks the other yield statements.\n```\nexport default function* rootSaga () {\n    // these takeLatest() uses the implementation found in the docs\n    yield takeLatest();\n    yield takeLatest();// this line will not execute unless spawn() is used\n}\nfunction takeLatest(pattern, saga, ...args) {\n  const task = yield fork(function () {\n    let lastTask\n    while (true) {\n      const action = yield take(pattern)\n      if (lastTask)\n        yield cancel(lastTask) // cancel is no-op if the task has already terminated\n  lastTask = yield fork(saga, ...args.concat(action))\n}\n\n})\n  return task\n}\n```. my import statement is:\nimport {takeEvery, takeLatest} from 'redux-saga';\nI've had this problem on \n    \"redux-saga\": \"0.14.6\",\nand\n    \"redux-saga\": \"0.14.2\",\n. sorry, I think I may have confused you.  the takeLatest() used in the sample code I put above was referencing the takeLatest implementation from the documentation found here (https://redux-saga.github.io/redux-saga/docs/advanced/Concurrency.html).  If I use the official redux-saga's takeLatest() or takeEvery(), then it works fine.. ohhh you took out the yield... i guess that makes sense why it blocked haha.\nI'll close this PR and let you handle all the cases where the sample codes need to be adjusted.\nThanks for the help.. ",
    "just4fun": "Thanks @iMoses , I'm working with 0.14.3 and using Symbol as action type since I don't want to declare so many variables as action names. However, take is still suspended even I dispatched action.\nAfter dug into source code, I found it has been fixed by this PR.\n@Andarist I found latest version is still 0.14.3, could you please update package version? Thank you!. @Andarist if I put link like \"redux-saga\": \"git://github.com/redux-saga/redux-saga.git#5858a7c\" in package.json, I will get Unable to resolve module redux-saga from..... ",
    "alexgalin": "@Andarist Any update on this? we're really stuck due to this issue since we've started using sagas.. ",
    "alanwei0": "thanks for your answer. \nwe have discussed your approach some days ago, but i may be confused to me about what does \"action\" mean. if actions are interfaces exposed by reducer, then is an action without a reducer still an action? On the other, if an action has no reducer, then saga is not just handling effects but changes to a controller like thunk.. so, you mean that action is not defined by reducer, and reducer just handle action. am i right?. @slorber i think action has some differences with events. if an action be handled by more than one reducer, then the program procedure may be confused\uff0cbecause i don't know how many reducer will handle this action. so in my team, we have a rule that \"an action can only be handled by an reducer, if the action is complex, we trigger actions flow in saga or thunk\". \nIn addition, we split store into parts(ex: domain data, ui data).  reducers that handle domain data are just like model in MVC in my mind and the actions are more like the methods of model.. @slorber thank you so much. @Andarist i'm more confused now.............. i map the redux architecture to traditional MVC arch to help me understand the actions/reducers/saga/components in react/redux. \ncomponents => view\nsaga/thunks => controller\nreducer/store => model\nin my deep mind, i regard saga/thunk as controller, so when i trigger an action, i can be find all process flow in saga/thunk. i think it makes the program more understandable and readable. if an action has many reducers, i must to find all reducers in different files. \nthat's all.. @slorber your answer in stackoverflow is so helpful for me. ok\uff0ci will keep learning. thank you again. still has two question\n1. why you say that 1 action - 1 reducer is an anti-pattern\n2. if 1 action - >1 reducer, how to make the action flow clearly and readable?. i understand. ",
    "sethreidnz": "Would you be against updating other snippets? I found this one confusing:\nlang-javascript\nfunction render() {\n  ReactDOM.render(\n    <Counter\n      value={store.getState()}\n      onIncrementAsync={() => action('INCREMENT_ASYNC')}\n    />,\n    document.getElementById('root')\n  )\n}\nBecause in reality my final render should look like this:\nlang-javascript\nfunction render() {\n  ReactDOM.render(\n    <Counter\n      value={store.getState()}\n      onIncrement={() => action('INCREMENT')}\n      onDecrement={() => action('DECREMENT')} \n      onIncrementAsync={() => action('INCREMENT_ASYNC')} />,\n    document.getElementById('root')\n  )\n}\nI think that is small enough function that there is no need to remove the other functions... Especially since they are still props in the Counter.js snippet right above.. ",
    "arist0tl3": "@bradennapier \nJust wanted to say thanks for this pattern, works great!. ",
    "Odinsama": "@bradennapier @Andarist  this did not work for me :( \nThe path variable does not work in runtime because by that time everything is just in bundle.js and the path means nothing. The only way I could make it work is to hard code a path and take no arguments (like so: import('../../actualHardCodedPath')), that way it got transpiled properly by webpack. \nAnybody else had this issue and/or know a way around it?. ",
    "marcselman": "What's the status of this pull-request? @mistadikay have you had time to take a look at it?. ",
    "mistadikay": "@marcselman the project I need this PR for was down-prioritized, so I'm working on other stuff at the moment. ",
    "wilsaj": "Hi everybody. I opened a follow-up PR to try to finish this up: https://github.com/redux-saga/redux-saga/pull/923. I started looking into this.\nHere's a webpackbin that reproduces the issue: https://www.webpackbin.com/bins/-Ki6juosjlVKWfyw7-_O\n(note: it's better to use browser devtools than the webpackbin console log because it's so noisy)\nThings I noticed:\n- It does not seem to be a problem when using a branch with the scheduler fix for #888  (tested locally)\n- The workaround suggested for #605 with adding a trivial noop delay seems to work, though I don't know why. Looks like it's fixed for this specific test case at least.:\nredux-saga 0.14.6(broken) : https://www.webpackbin.com/bins/-Ki6juosjlVKWfyw7-_O\nredux-saga 0.14.7(fixed) : https://www.webpackbin.com/bins/-KiB89zk_PXidxlFEIfg. Hi @Andarist - I've got some time to work on this now. Logistically, how should that work - open a new PR?. ",
    "kelsonic": "@slorber Great, thanks! :). ",
    "m1m6": "@Andarist \n`function* getAddresses(action){\nlet url = ADDRESSES_ENDPOINT ;\n  try {\n      const response = yield call(API.fetchAddress,url);\n      let options= [];\n        response.data.map(function (option) {\n          options.push(option);\n        });\n  let data = {\n    options: options\n  };\n\n  yield put({type:types.FINISH_LOCATION_SEARCH,payload:response.data});\n\n} catch (err) {\n  yield put({\n    type: types.LOCATION_SEARCH_FAILURE,\n    payload: {\n      _error: err.message\n    }\n  });\n}\n\n}`. ",
    "rezadhah": "how about you handle it in input onChange? so if the length of input is match with your desire, you dispatch the action to saga?. ",
    "ehtb": "OK, writing up your problems actually helps \u2026 Anyone encountering the same problem, by removing store.close(), or store.dispatch(END) the Promise will simply wait for the entire root task to finish, instead of terminating it early.. ",
    "ydomenjoud": "sorry, cats ... you can delete / close this thread. ",
    "eks1985": "Yes, i try. ",
    "aight8": "I don't saw this repository with the proposal, but thank for the input. I must read through it.\nThe classes are sugar to bundle the different parts together. Otherwise you just export several functions, but how the core knows which export is what. Additionally a base class could provide a good basic functionality. I really ask here: There are classes now, when it make it things cleaner why not use them. Wasn't that the basic thought of classes? Even React uses classes for components with different predefined lifecycle methods and (static) property names which can be implemented.\nI am already created a common saga generator which handle unhandled exception and uses takeLatest. Additionally provide callback methods etc.\nBut this really just solves a small part.\nI definitely don't want to prescribe a silver bullet. But I want to simplify very common patterns, and improve readability.\nPS: Theoretically it could be possible to just pass the dispatcher or store to the class instance however and that's it. Just save the bindActionCreators call in every smart comp. file.. ",
    "kairome": "Regarding this \n\naction types are generated and could be not reused in specific uses cases when the action name must be known outside of the app\n\na little update, you can now get the type by using getType() method on the action itself.\nhttps://github.com/pauldijou/redux-act#action-creator\nSo, if you did\njs\nconst someAction = createAction('SOME_ACTION');\nLater on somewhere in the code, you now can\n```js\nimport { someAction } from 'actions/someAction';\nconsole.log(someAction.getType()); // logs SOME_ACTION. ",
    "wisn": "Have you take a look on Ignite RN boilerplate?. Check this one.. It sounds great. So, should we collecting a common error first?. I mean common mistakes that user would creates. Like Error! You're calling takeLatest but there is no Saga in parameter.. That without need for publishing new version of the library and without people downloading it was difficult.. The simplest one is something like coala/coala. You may see github/choosealicense.com. The main content is should be the steps to starting contributing and some rules.. For addition, infinitered/ignite contributing guideline was perfect I think.. ",
    "milieu": "re: @granmoe class components vs function components\n\nYou may not use the ref attribute on function components because they don\u2019t have instances\n-- Refs and the DOM\n\nthis turned out relevant for me while using react-window for performance improvements, and needing to allow the library to forward refs for scroll control. ",
    "saboya": "@milieu This is not true anymore since react-16.3 with createRef/forwardRef and now, react-16.8 with the React.useRef hook.. Most of the issues I see are created because a lot of implementations rely on implicit design decisions / state.\nIf you have a SubApp, that implicitly says that there's something bigger that controls all of that, and you should be able to receive events / signals from it. If you can't do it from redux-saga or some connected component, I believe the cleanest approach would be to explicitly design some inter-app communication channel, possibly through a redux middleware, which would make the most sense for me.\nI can't see how connecting a saga directly to a component would solve your issue.. You should handle it through the props passed to each SubApp then. Having the outermost component compare props changed and fire events accordingly.. The pattern itself is not recommended for scenarios that share data between Apps:\nThis pattern is not recommended for parts of the same app that share data. However, it can be useful when the bigger app has zero access to the smaller apps' internals, and we'd like to keep the fact that they are implemented with Redux as an implementation detail. Each component instance will have its own store, so they won't \u201cknow\u201d about each other.\nSo yeah, it's up to you to implement some middleware to share actions between stores.. > You could possibly handle your handleContextMiddleware in a slightly easier, but arguably more hacky, way - you could create a dummy task with fork which would attach itself to the parent in regular fashion and call createdFork.getContext instead wrapping this in a call(handleContextCalls) and using channel to get the result back.\nYes, this would make it a bit less obfuscated. However, Task doesn't seem to expose getContext, only setContext, or am I missing something?\n\nI have a strong feeling that having this implemented and released would let you achieve your goal in a more straightforward way.\n\nMy comprehension of redux-saga's internals are not too strong, I'm gonna have to take a closer look to see what exactly that could enable :)\n\nOr maybe it would even require creating a single custom effect of fork (used in the wrapper), which could create a task with custom stdChannel.\n\nThis seems to be exactly what I want, and seems like the simpler solution.\n\nIt's quite hard to say though at this point, your use case is quite specific and also quite interesting.\n\nI think it's useful to be able to add functionality through higher-order function composition in general. I can't say this is a very common practice (with redux-saga at least), but I think it could be useful in many situations. In this particular case I'm filtering actions based on refcounting actions, and I wanted to have this logic isolated because I use this in more than one place.\nThis could also be used to run a saga in a Web Worker / server-side in a agnostic way (although there are a lot of limitations in this case, especially with context, since there are no guarantees they are plain javascript objects).\n\nAlso it's really nice to see that you are using v1-beta already :tada:\n\n\\o/ The new mutiCast channel is very nice, I'm already using it for some stuff.. @jrnail23 It is possible. however there are caveats if your sagas are not pure.\nThe reason that context makes everything messier is because context variables are essentially implicit arguments to sagas. In strictly pure functions, you wouldn't use context at all, instead passing them explicitly when running your sagas.\nAlso, for my use case I needed to filter the actions that the  wrapped saga receives. If you have no such requirement, a simple fork would be enough to spawn the wrapped saga, which would handle the context issue since forked sagas inherit context.. This is how I see it:\nSagas and reducers are implementation details of your architecture. Thus, your actions should not be aware of their existence. When you dispatch an action like 'GET_USER_REQUEST', you want that to be fulfilled, regardless of how that's going to happen.\nSo, the fact that your entities are being retrieved from an API it's not something a component that dispatch actions should be concerned about. Of course that's completely open for discussion because it's subject to architecture design, but that's usually the right thing to do, in my opinion.. Should this be closed?. To complement @Andarist 's answer, the call effect literally invokes the function you pass to it. So should pass the function itself and the arguments you want it to be called with, not invoke the function yourself.\nSo, in practice, what you did was this:\njavascript\napi.get(`/${action.payload.siteName}/images/${action.payload.groupName}/${action.payload.currentPage}`).call(undefined);\nBut what you actually wanted is this:\njavascript\napi.get.call(undefined,`/${action.payload.siteName}/images/${action.payload.groupName}/${action.payload.currentPage}`). There are endless possibilities for an error, most of which have nothing to do with redux-saga.. ",
    "nda2221": "Thanks, buddy!\nCan you elaborate more how my component gets notified and rerenders or call smth in your\nlifecycle hooks? Shall it happen in shouldComponentUpdate(), or I check a prop in the render() and depending on the state - exec ref.callFunc? . Thanks again.\nIt works now. I was struggling where to initiate async actions with DOM. componentDidUpdate is the right place.. ",
    "roman-g": "PS. I understand that yield* 'embeds' the nested generator into the parent, and yield just returns the iterator which actually will be executed by redux-saga somehow, but it doesn't explain the encountered behavior to me :). ",
    "jolyonruss": "@granmoe who's the best person to ping to get this merged?. Anyone have any thoughts on my latest commit to this?. Good spot \ud83d\udc4d . It might not be the most ideal solution - but given that there's still an open discussion (in the issue I linked to) about the best approach to testing sagas, I think this is at least an improvement on the previous version of this page in the docs, which I found to be insulting and unhelpful.\nI think if there was a agreement on the best way to test sagas, this page of the docs would describe that approach in enough detail for someone to implement tests for their sagas. Even if it described the approach used in the examples that would be better than what's currently there.\nIn the meantime this adds just a little bit of help to developers who are hoping to get some information on how to test their sagas.\nAs for the including a snippet of the README, again it's about being helpful to developers - if redux-saga-test had a more detailed README I would have used it. The README snippet gives the developer some minimal context before investigating either of the repos, again it's about having something nicer than just a page with a few links on.. I've had another crack at making the testing page a little better\nWDYT?. ",
    "tsimons": "I think it would be worth including an example of testing error handling using iterator.throw as mentioned in #28 . ",
    "chrisHchen": "ok~. @Andarist  Yes, all 139 passed.. ",
    "aryzing": "New PR with suggested changes in #811.. @aikoven thanks, I think you're on to something :) Indeed, it did make the error message clearer: Property 'payload' is missing in type 'Action'.\nThe thing is, I just changed this file's extension from .js to .ts. I was under the impression I'd be able to adopt TS gradually without any errors... any final thoughts before closing the the issue? Any compiler settings I should look in to?\nEDIT: Also, I've noticed that if instead of using object destructuring syntax I simply use fetchExampleSaga(action) the error goes away. Suggestions?. ",
    "und3fined": "@aikoven: Thank for your solution.\nCurrently, I'm using override code with:\n```\n/*\n * Redux Saga\n * redux-saga.d.ts\n /\nimport {SagaMiddleware, Monitor, Emit} from \"redux-saga\";\ndeclare module 'redux-saga' {\n    export default function sagaMiddlewareFactory(options?: {\n        sagaMonitor?: Monitor;\n        emitter?: (emit: Emit) => Emit;\n    }): SagaMiddleware;\n}\n```. ",
    "EdmundMai": "It seems to be working again... I'll close this issue and reopen it if I notice it happening again.. ",
    "Judahmeek": "@Andarist: Much appreciated. Once things settle down, I'll review this issue again. Coming from redux-thunk, my biggest obstacles (other than a minimal understanding of how redux middleware works) was:\n1. That there is no documentation that sagas receive action implicitly from takeEvery, and\n2. That there was no warning that yield put triggers all the middleware again, creating the possibility for infinite loops.\nIn my case, I naively tried replacing dispatch with yield put and resolving the resulting infinite loops required asking questions on Reactiflux's discord server and examining Redux documentation regarding middleware and store.dispatch vs next.\nGranted, these are things any redux dev should know, but I would love to see pointers to them in redux-saga documentation. In fact, since it's likely? that many of the devs adopting redux-saga are porting over from redux-thunk, ya'll might want to consider a section listing common obstacles and concepts (not in detail, but with links) specific to a redux-thunk migration.. I'm certainly willing to explore the idea. Here's hoping it doesn't take me forever and a day to get around to it.. ",
    "bzbetty": "believe I figured it out by diving into the source - need to open up multiple channels and use emitters to support subscribers.  example is the eventChannel.. ",
    "estefanojctimoteo": "Thanks @Andarist because now I know \"export function* doSignIn(action) // action parameter is available here thanks to takeLatest running your 'doSignIn' with it\".. ",
    "MuhammadSulman": "```/\n\n * DeleteConfirmationModal\n \n */\nimport React from 'react';\nimport saga from './saga';\nimport { compose} from 'redux';\nimport reducer from './reducer';\nimport { connect } from 'react-redux';\nimport injectSaga from \"../../utils/injectSaga\";\nimport { createStructuredSelector } from 'reselect';\nimport injectReducer from \"../../utils/injectReducer\";\nimport {submitDeleteConfirmationModalForm, toggleDeleteConfirmationModal} from \"./actions\";\nimport {\n    deleteConfirmationRecordId,\n    deleteConfirmationRecordIndex,\n    makeSelectDeleteConfirmationModalShow\n} from './selectors';\nimport DeleteConfirmationForm from \"./form\";\n/ eslint-disable react/prefer-stateless-function /\nclass DeleteConfirmationModal extends React.PureComponent {\nconstructor(props) {\n      super(props);\n      this.toggleModal = this.toggleModal.bind(this);\n  }\ntoggleModal() {\n      const {toggleModal} = this.props;\n      toggleModal();\n  }\nrender() {\n      const {show, itemName, onModalFormSubmit, id, index} = this.props;\n      return (\n          \n\n\n\n\u00d7\nDelete {itemName}\n\n                  <div className=\"modal-body\">\n                      <p>You have selected to delete this {itemName}</p>\n                      <p>If this was the action that you wanted to do, please confirm your choice, or cancel and return to the\n                          page</p>\n                      <br/>\n                      <DeleteConfirmationForm\n                        id={id}\n                        index={index}\n                        onModalFormSubmit={onModalFormSubmit}\n                      />\n                  </div>\n                  <div className=\"modal-footer\">\n                  </div>\n              </div>\n          </div>\n      </div>\n  );\n\n}\n}\nconst mapStateToProps = createStructuredSelector({\n    id: deleteConfirmationRecordId(),\n    index: deleteConfirmationRecordIndex(),\n    show: makeSelectDeleteConfirmationModalShow(),\n});\nfunction mapDispatchToProps(dispatch) {\n  return {\n      toggleModal: () => dispatch(toggleDeleteConfirmationModal()),\n      onModalFormSubmit:(data) => dispatch(submitDeleteConfirmationModalForm(data)),\n  };\n}\nconst withConnect = connect(\n  mapStateToProps,\n  mapDispatchToProps\n);\nconst withReducer = injectReducer({ key: 'deleteConfirmationModal', reducer });\nconst withSaga = injectSaga({ key: 'deleteConfirmationModal', saga });\nexport default compose(\n  withReducer,\n  withSaga,\n  withConnect,\n)(DeleteConfirmationModal);\n\n/\n\n * DeleteConfirmationModal actions\n \n/\nimport {\n    SETUP_DELETE_CONFIRMATION_MODAL,\n    TOGGLE_DELETE_CONFIRMATION_MODAL,\n    SUBMIT_DELETE_CONFIRMATION_MODAL_FORM,\n} from './constants';\nexport function toggleDeleteConfirmationModal(forceAction = null) {\n    return {\n        type: TOGGLE_DELETE_CONFIRMATION_MODAL,\n        forceAction,\n    }\n}\nexport function setupDeleteConfirmationModal(payload) {\n    return {\n        type: SETUP_DELETE_CONFIRMATION_MODAL,\n        payload,\n    }\n}\nexport function submitDeleteConfirmationModalForm(params) {\n    return {\n        type: SUBMIT_DELETE_CONFIRMATION_MODAL_FORM,\n        params,\n    }\n}\n```\n```\nimport {\n    SUBMIT_DELETE_CONFIRMATION_MODAL_FORM,\n} from \"./constants\";\nimport LocationsApi from \"../../api/LocationsApi\";\nimport {put, all, takeLatest,} from 'redux-saga/effects';\nimport {submitDeleteConfirmationModalFormSuccess} from \"../Location/actions\";\nfunction* submitDeleteConfirmationModalForm(action) {\ntry {\n    const id = action.params.id;\n    const index = action.params.index;\n    const response = yield LocationsApi.delete(id);\n    if (response.status && response.status === 'ok') {\n        localStorage.removeItem('location' + index);\n        localStorage.setItem('locations_length', parseInt(localStorage.getItem('locations_length')) - 1);\n        yield put($('#modal_default').modal('hide'));\n        yield put(submitDeleteConfirmationModalFormSuccess(id));\n    }\n}catch (error) {\n\n}\n\n}\nfunction* watchAll() {\n    yield all([takeLatest(SUBMIT_DELETE_CONFIRMATION_MODAL_FORM, submitDeleteConfirmationModalForm)]);\n}\nexport default watchAll;\n```\nI am getting this error since yesterday, trying to resolve it but still failed.\nutils.js?56bd:225 uncaught at submitDeleteConfirmationModalForm Error: Actions must be plain objects. Use custom middleware for async actions.\n    at Object.performAction (<anonymous>:1:42634)\n    at liftAction (<anonymous>:1:36073)\n    at dispatch (<anonymous>:1:40184)\n    at eval (webpack-internal:///823:22:18)\n    at eval (webpack-internal:///1041:70:22)\n    at dispatch (webpack-internal:///41:619:28)\n    at eval (webpack-internal:///42:282:12)\n    at eval (webpack-internal:///491:498:52)\n    at exec (webpack-internal:///420:22:5)\n    at flush (webpack-internal:///420:63:5). ",
    "CallMeXYZ": "Stupid in    yield put(REQUESTING);. ",
    "kimochg": "@Andarist \nThanks for replying.\nI attempt this saga way, but i fail since some specified in request.\nfor exmaple, I want to fetch todo list, I got three todo list, 'all' 'active' 'completed',\nthey are specified in action.filter when dispatch ({type: 'FETCH_TODO_REQUEST, filter})\nWhen i use takeOneAndBlock, I can just take one request specified with filter.\nbut, what i want is take each request once, and block duplicate request when is fetching each request specified with 'all' 'active' 'completed'.\nI think a lot from your code.\nfunction* customTake(pattern, worker, ...args) {\n  const task = yield fork(function* () {\n    let currentTask = {};\n    while (true) {\n      const action = yield take(pattern)\n      const { filter } = action;\n      if ( !currentTask[filter] ) {\n           currentTask[filter] = yield fork(worker, ...args, action)  // ** 1 **\n           currentTaks[filter] = null;  // ** 2 **\n      }\n    }\n  })\n  return task\n}\n```\nfunction* fetchRequest() {\n  try {\n    yield put({type: 'FETCH_START'});\n    const res = yield call(api.fetch);\n    yield put({type: 'FETCH_SUCCESS'});\n  } catch (err) {\n    yield put({type: 'FETCH_FAILURE'});\n  }\n}\nyield customTake('FETCH_REQUEST', fetchRequest)\n```\ncode line  1  \nif use call will pause the whole saga, which is not i want. so currentTask[filter] is used to manage each request.\ncode line  2 \nWhen i use fork, i can not block the function generator, and reset my currentTask[filter] to null, after one request forked\nIt is a large conflict in my design if the recommend saga way is used... \nSo, I try to control my request out of saga, write the business logic directly in container component.\nWith isFetching as a prop of component, I can control request now.\nI wonder there is a better practice to implement what i want in Saga way?\nSince I start to treat Saga as a brilliant way to control side-effects of actions, and this kind of things is not strong point of Saga.. Thanks for replying\nTo @UchihaVeha \nI tried these way to get state from my store, but i notice the logic trick here, if 'FETCH_REQUEST' is dispatched, 'isFetching' is always true, since reducer set isFetching as soon as this action dispatched.\nSo, i must use another action.type such as 'LOAD_PRODUCT' @lovio pointed.\nTo @lovio \nIt will work, but it changes the design if i transform my thunk design to saga design. which is not elegant.... @Andarist Thanks a lot! The solustions are impressive. which gives me a way to control the entry of worker saga. instead of control the most first request like 'FETCH_REQUEST' in redux-thunk way.. ",
    "neighborhood999": "@Andarist @baldwmic I'm happy we can solved this issue! \ud83d\ude04 . I just find v0.14.x flow-typed from here.. Yes, I think this is necessary.\nFor our docs index page, you can reference my fork repo:\nhttps://neighborhood999.github.io/redux-saga/. ",
    "ipluser": "@Andarist \nalready add \"All pending takers\".. ",
    "brunobelotti": "Thank you @anthonychung14, I did search a little in the issues, but I completely missed #760: looks like I'm not the only one with doubts (I'm relieved)! :)\nI'll surely dig into it, thanks! <3. Actually, I'm going to close this issue: the discussion in #760 is exactly what I was looking for. Thanks again!. ",
    "eclifford": "Thank you @granmoe . I have been keeping up with that discussion. Another pertinent discussion is happening in the comments of this blog post.\nOf particular interest to me at this point is how we can make the best of our current ecosystem around modeling effects at scale. I'm particularly interested in any ways members of the community have overcome redux's shortcomings in composability even if perhaps they are not theoretically pure to the origins of redux's design (elm) etc. . ",
    "TrevorHinesley": "Confirmed. I tried doing attributes: customer.toJS() (because it's an ImmutableJS Map), and it's undefined. But again, if I put a debugger after options has been defined, customer is a full object by the time the debugger has triggered, and toJS() works fine.. As the code above shows, the issue is visible before that call you referred to ever happens.. I'm not sure what regenerator-runtime is but I'm not using it. This saga is dispatched via another saga that is watching for an action. The action is dispatched after a redux-form is submitted, but all of that is fairly irrelevant since this seems to just be some sort of sync issue.. Ah got it. I think you're right, seems to be working fine now. Thanks!. tada :)\n```\nexport function* watchLoadInfiniteListObjects () {\n  // 1. Create a channel to watch for INFINITE_LIST_LOAD_OBJECTS actions and queue them\n  const requestChan = yield actionChannel(INFINITE_LIST_LOAD_OBJECTS, buffers.expanding(10))\nwhile (true) {\n    // 2. Pop request from the channel\n    const action = yield take(requestChan)\nconst { task, cancel } = yield race({\n  task: call(loadInfiniteListObjects, action),\n  cancel: take(INFINITE_LIST_CANCEL_LOAD_OBJECTS)\n})\n\nif(cancel !== undefined) {\n  const actions = yield flush(requestChan)\n  // Don't need these actions, do nothing.\n}\n\n}\n}\n```. ",
    "Andruschenko": "@neurosnap Did you find any solution to your problem so far?. ",
    "fengerzh": "@gajus I think you need to define a Iterable<any> in your functions as below:\n```\nexport function getActivities(api: any) {\n  function * worker(): Iterable {\n    const response = yield call(api.getActivities);\nif (typeof response === 'undefined') {\n  throw new Error('`response` should be an object.');\n}\nif (response.ok) {\n  const activities = path(['data'], response);\n  yield put(Actions.activitiesSuccess(activities));\n} else {\n  yield put(Actions.activitiesFailure());\n}\n\n}\nfunction * watcher(): Iterable {\n    while (true) {\n      yield take(Types.ACTIVITIES_REQUEST);\n      yield call(worker);\n    }\n  }\nreturn {\n    watcher,\n    worker\n  };\n};\n```\nOr, just simply give it an any can suppress this error too:\nfunction * worker(): any {. ",
    "mackbrowne": "@Andarist  any working examples of this?  I'm using Iterable for my watcher, but I can't figure out how to properly type my worker?  Using 'any' right now, which i'd like to avoid.\n@gajus you seem to know what your talking about, any advice?\n. @Alxandr thanks so much for the quick reply.  You were correct and helped me remove the only 'any' from my typings.\nHere's what I have now \n```\nexport function* initializeAsyncStateWorker(action: Action): Saga {\n  try {\n    yield put(initAppSuccess());\n  } catch (err) {\n    yield put(initAppError(err));\n  }\n}\n// Watcher\nexport function* initWatcher(): Iterable {\n  yield takeEvery(INIT, initializeAsyncStateWorker);\n}\n```\nI'm using Saga for the worker.  However is Iterable anywhere close to what I should be using for the watcher?  I kinda figured it out by trial and error, I have no idea if it's correct\nEDIT: Also, i ran flow-coverage and it's still saying my try/catch block is untyped.  I read somewhere there catch statements weren't supported yet, is this still the case?. @Alxandr wow i feel dumb now!  Thanks so much dude!. ",
    "yfr": "Have the same issue. Update to the newest typing (Thanks @Alxandr!) but I dont't get it to work properly. An example would be great! . Ah did not know about the thing with the background tab. Makes sense now.\nThank you!. ",
    "rolandhordos": "I like how this cues you to shape the output of your generators (i.e. User | null is a discrete contract).. ",
    "EugeneZ": "@Andarist \n\n@Alxandr is result's type in your loginSaga inferable from doTheActualLogin?\n\nNo, unfortunately. It's type any, which you can see by using flow type-at-pos or simply by changing result. success in the next line to something that would obviously cause an NPE like result.sucess.garbage.that.causes.exceptions and flow won't utter a peep.\nThe easiest way to get around this is to explicitly type the LHS:\nconst result: ActualLoginRV = yield call(doTheActualLogin, username, password));\nSince it's any already, flow won't complain that you are narrowing it. However, if you make a mistake doing this (like, say, doTheActualLogin is later changed to return a different type), flow will not complain.\nIf you want more soundness and are willing to go through the effort, you can create use-specific generators and use yield * to \"proxy\" them, which preserves the type information:\n```\nfunction* callPromise, T>(\n  fn: (...args: Args) => Promise,\n  ...args: Args\n): Saga<?T> {\n    return yield call(fn, ...args);\n}\nfunction loginSaga(username: string, password: string): Saga {\n  const result = yield callPromise(doTheActualLogin, username, password));\n  if (result.success) {\n    return result.user;\n  } else {\n    return null; // or error\n  }\n}\n```\nNow, since you are splaying the effects, and callPromise is explicitly describing the mechanism that redux-saga uses to resolve Promises, flow will actually strictly enforce the LHS/RHS relationship. But fi you mess with callPromise you can introduce silent errors again. And if you forget to use it. And this only works for Promises so you have to make custom versions of these for anything else you want that redux-saga handles.\nI would love to figure out a better way of doing it. Maybe the key is in adding another generic type to Saga<...> that relates the third arg (Next) with the effect.\nEdit: Basically this is probably impossible until https://github.com/facebook/flow/issues/2613 is fixed in some way.. ",
    "SidneyXu": "Sorry, I finally found it not a sagas's issue. It only occurs on ReactNative and works perfectly on React.js, and when I use for i in children instead of children.map() on ReactNative it also works. Maybe it is ReactNative or babel's problem. . ",
    "campbellwmorgan": "@Andarist No, I'm afraid i hadn't thought about it in much more detail and yes, I agree that putEvent is far from a clear name ;)\nI guess what I think would be important is, for simplicity's sake, not bringing the whole channel concept into the api for this as the existing channel api already serves that purpose (very well). Also, I think there is quite a lot of intellectual overhead getting ones head around the channel concept and a helper function like this could lighten the load for developers getting started with this library who need to interact with events.\nPerhaps something like bindEventDispatcher( (emitter) => { ... })?\n. ",
    "visweshs": "Yes:\nit('pass action to doSomething', () => {\n    /* Import initial state, saga and doSomething */\n    const state = initialState \n    const generator = saga(state) \n    const action = () => ({ type: 'ACTION' })\n    let next = generator.next(action()).value\n    expect(next).toEqual(takeLatest('ACTION', doSomething)) \n  })\nYou can keep going, by moving through the generator:\nit ('doSomething makes API call to something', () => {\n    const action = () => ({ type: 'ACTION' })\n    const generator = doSomething(action())\n    let next = generator.next().value\n    expect(next).toEqual(call(API.something))\n  })\n  it ('doSomething handles API success', () => {\n    const action = () => ({ type: 'ACTION' })\n    const generator = doSomething(action())\n    const apiResponse = { data: [0, 1, 2] }\n    let next = generator.next().value\n    next = generator.next(apiResponse).value\n    expect(next).toEqual(put(doSomethingResult(apiResponse))\n  })\n  it ('doSomething handles API error', () => {\n    const action = () => ({ type: 'ACTION' })\n    const generator = doSomething(action())\n    const apiResponse = { error: 'Network failure.' }\n    let next = generator.next().value\n    next = generator.throw(apiResponse).value\n    expect(next).toEqual(put(doSomethingError(apiResponse))\n  })\nHave you seen this?. EDIT: I was incorrect - apologies.. I think you're looking for takeEvery.\n```\nfunction* taker(action) {\n   try { \n       const response = yield call(API.makeCall, action.payload)\n       yield put(actions.result(response))\n   } catch(e) { \n       yield put(actions.error(e))\n   }\n}\nfunction* sender() {\n   yield takeEvery('SOME_RANDOM_TYPE', taker)\n}\n```\n. I would like to pause all currently running sagas whenever a next animation frame is requested, and resume all sagas after the frame is delivered. \nTo clarify my motivation: I have read some compelling evidence that a lot of so-called \"non blocking\" calls are in fact blocking, because they interface with the DOM; i.e JSON.stringify.. ",
    "andresmijares": "@Andarist Almost, It still throws the take channelOrPattern is not valid, I checked a little and notice the emitter is undefined when running the tests, however, it works fine one the code:\nfunction* something () {\n const emitter = yield call(emitterFn)\n   try {\n    while (true) {\n       let payload = yield take(emitter) // <--- this is undefined\n       /* code omitted */\n      }\n   }\n}\nThat is causing the error when testing I guess, so I tried adding the emitter to the previous next() to make it available, but I guess the same result.\nIf it helps, my event channel is the same as #631 . @bradennapier awesome! I will take a look! thank you!. ",
    "danscotton": "Thanks @Andarist, that worked perfectly!\nI ended up importing _.isEqual from lodash/fp to refactor the takes to be:\nes6\nconst { dismissed } = yield race({\n    dismissed: take(isEqual(dismiss({ id }))),\n    resumed: take(isEqual(resume({ id }))),\n});\nAppreciate the help \ud83d\udc4d . ",
    "eruca": "javascript\nclass Admin extend Component {\n    constructor(props){\n          ...\n         props.dispatch(request(FETCH_CREATED_USERS, {account: props.account}))\n         props.dispatch(request(FETCH_DEPARTMENTS, {}))\n    }\n}\nthe react-router from \"/\" to \"/admin\"\nshell\n// console will print\nsaga.js:28 watchRequest Object {type: \"FETCH_CREATED_USERS\", payload: Object}\nsaga.js:28 watchRequest Object {type: \"FETCH_DEPARTMENTS\", payload: Object}\nif the router from \"/admin/register/1\" to \"/admin\"\nthe Admin instance will construct, and should dispatch both actions.\nbut log will only receive the first action, the second is missed;\nI have swap the position of the actions, first will receive and second not;. my version is 0.14.3, my code above I think is all about, I'm sorry not trace the issue anymore, I change my code to One dispatch not two, and it works well.. ",
    "aubreywahl": "dang this issue really caused me a lot of headache :/\n+1 for making that more obvious in the docs. ",
    "ssynix": "I believe this is a Typescript limitation, so I filed an issue on their end: https://github.com/Microsoft/TypeScript/issues/14883.. @raduflp There's no workaround since it's lacking support at the language level. There are several threads mentioned in the issue above that discuss this feature, saying that it was blocked on boolean literal types and default template parameters (both now implemented), but generator yield type propagation still hasn't seen any traction in the past year.\nThe closest thing to a workaround is still what I wrote in the code sample above: you can manually assert the type yourself to make sure the rest of the code is typesafe, but there's nothing you can do to automatically detect if that original type-assertion is wrong.. I found redux-saga-test-plan super useful in testing sagas.\nUnlike redux-saga docs, it focuses on testing what goes into and out of your sagas, instead of a specific chain of effects.. ",
    "raduflp": "facing the same issue now that I'm trying to adopt Typescript. \n@ssynix  did you find a workaround/pattern to have type safety for the saga's return values?. ",
    "allenylzhou": "^0.11.0. ",
    "s123121": "@flushentitypacket  1 thing to notice is if inside sagaA, you throw an error like \nyield put({ type: ERROR_A }) there are no way for sagaAandB to know that. ",
    "tkow": "I faced this problem and my answer is that to keep loosely coupled with each other state, I decided to make seperate directory in my project for pipeline need mixed state. Then, I conlude for this, use channels and every async functions we want to pipe are wrapped by eventChannel and export  to the dir like,\n```example.ts\n// state1/saga.ts\nfunction createPipe1 () {\n  return eventChannel(emit =>  {\n     someAsync().then(\n        result=> {\n          return result.error? emit (result.error): emit(actionCreator(result))\n        }\n     )\n     return () => END\n  )\n}\n// state2/saga.ts\nfunction createPipe2 () {\n  return eventChannel(emit =>  {\n     someAsync().then(\n        result=> {\n           return result.error? emit (result.error): emit(actionCreator(result)) \n        }\n     )\n     return () => END\n  )\n}\n//pipe/someSaga.ts\nfunction* someSaga() {\n     while(true) {\n        take(RUN_SOME_SAGA)\n        const ch1 = createPipe1()\n        let action1 = yield take(ch1)\n        !getErrors(action1) && yield put(action1)\n        const ch2 = createPipe2()\n        let action2 = yield take(ch2)\n        !getErrors(action2) && yield put(action2)\n        ch1.close()\n        ch2.close()\n     }\n  }\n```\nAs long as we follow the format, we can compose async actions arbitrary keeping loosely-coupled and it is enough for me but  I wonder if this combination process  are available at component, we are happier because the logic are determined that as it is like react-redux connect method inject actions.. ",
    "infalse": "Struggled with this problem. Find out that there is relatively new Redux-saga effect putResolve\nTo sequence saga's you can now simply,\njavascript\nexport function* logOut({}, { meta }) {\n  const { thunk } = meta\n  try {\n    // dispatch first Action\n    yield putResolve(actions.setTokenRequest())\n    // Blocked until setTokenRequest is finished\n    yield putResolve(cartActions.createNewCartRequest())\n    // Blocked until createNewCartRequest is finished\n    yield put(actions.logOutSuccess(thunk))\n  } catch (error) {\n    // if there is any errors on any of putResolves, they will bubble up there\n    yield put(actions.logOutFailure(error, thunk))\n  }\n}\nfrom docs:\n\nJust like put but the effect is blocking (if promise is returned from dispatch it will wait for its resolution) and will bubble up errors from downstream.\n\n. ",
    "eyn": "Reflected on original approach and have simplified and tidied up a bit.\nHave exported new API:\n- effect(type, payload) which returns an effect (effect[IO] is true)\n- payload(type, effect) which returns the effect's payload\n- customEffectRunner added as an option to runSaga/middleware - function should return an effect to run\nCode in test case feels much tidier from original spike.\n. ",
    "unam3": ":s/yield result/return result. $ yarn info redux-saga|grep version:\nversion: '0.15.3',\nimport { put, call, all } from 'redux-saga/effects'. No warnings. I've renamed node_modules, run yarn install and diff node_modules/dist/redux-saga.js with old one \u2014 they're identical.\nTried yarn install --force after \u2014 same error.\nAbout code sharing \u2014 I will try after run code with debugger.. hm.\ngrep -nr version node_modules/redux-saga/\nnode_modules/redux-saga/package.json:3:  \"version\": \"0.14.3\",\nSeems like this isn't redux-saga problem. Close it.. ",
    "Ephys": "If by current situation you mean without the alias fix, the undesired effect is having two versions of redux-saga in the same bundle (the contents of redux-saga/lib and redux-saga/es).\nHere's the contents of my bundle without the alias:\n\nAnd with the alias:\n\nSo while the fix does indeed allow webpack2 to perform tree shaking, the bigger benefit is not having two different redux-sagas.. Actually if you want I can just make a PR with a fix that should make rollup/webpack2 always bundle /es and node/browserify/others always use /lib :)\nIt's a really minor change https://github.com/Ephys/redux-saga/commit/1ab5bb537279bfb3f1c4e3ecdd065f770d21bccc\nDon't worry it doesn't break anything :)\n. ",
    "florimm": "How does this work with auto cancel when used with takeLatest (or how should i do it)?. ",
    "pizza-r0b": "@Andarist just confirmed that the latest version of webpack fixes the issue. I am working on a branch that is using webpack 2.1.0-beta.25. Seems like it doesn't play nicely together. . One thing I just thought of is to create a promise that returns a new instance.. @Andarist are we out of luck until redux-saga@1? This isn't just in FF and Safari - seeing this in Chrome as well and basically leads to debugging in the dark as all([]) basically swallows the stack trace of the original error making debugging difficult. . @Andarist is there a branch for the 0.x line ? . ",
    "mysticmana": "OK, based from @Andarist comment, I can extract the predicate function to matchFetch, then use it in both saga and test code. Thanks @Andarist \n```\nexport function matchFetch(action) {\n  return /^FETCH_/.test(action.type);\n}\nexport function* watchFetchRequest() {\n  while(true) {\n    const action = yield take(matchFetch)\n    console.log('watchFetchRequest ', action)\n  }\n}\nTest code\nimport { watchFetchRequest, matchFetch } from '../saga/api';\ntest('watchFetchRequest', t => {\n  const generator = watchFetchRequest();\n  t.deepEqual(\n    generator.next().value,\n    take(matchFetch)\n  );\n})\n```. ",
    "jeffkhull": "Thanks @Andarist, this did in fact resolve the compilation error.  I'm running into other issues related to the fact that Webpack won't compile generators down to es5, and of course to use Redux Saga I need generators.  But regardless, I'm going to close this issue for now given it appears to have solved the types problem.  Thanks!. Sorry meant to say that typescript (version 2.2 in my case) won't transpile generators down to ES5... it throws an error and forces you to change your target to ES6.  But I have seen cases where people put typescript in a chain before babel, which takes the ES6 output down to ES5 finally.  I might give that a try.. ",
    "sglocastic": "It worked flawlessly before a couple of days. I can't pinpoint exactly when this started to happen. I did not change any versions or upgrade.\nI tried to find a method or a way to dispatch an action from chrome console but with no success. I couldn't find anything useful in those properties that Redux devTools attaches to window.. Yeah, it is imported as a store enhancer. I will implement it as a custom composer tomorrow and let you know if it solves the problem. \nEDIT:\nYeah actions now trigger sagas. Thank you on your help @zalmoxisus !\nIt could be helpful for other people if this was put somewhere in the docs.. ",
    "stjepangolemac": "@zalmoxisus  It is done. Here is the pull request. It's sglocastic, but from other account.\nYou can close this one. Thank you again!. ",
    "bristoljon": "I'm gonna post my question here as it's the most relevant thread I've found for it:\nI have an apiRequest saga that eventually yields a server response or throws an error and I need to use it inside another saga like so:\ntry {\n  const response = yield call(apiRequest, { meta: { endpoint } })\n  console.log('response', response)\n}\ncatch (error) {\n console.log('error', error)\n}\nHowever when I do this, apiRequest never returns i.e. neither console log gets hit and it just hangs.\nIf I try yield* call(apiRequest, { meta: { endpoint } }), I get response undefined\nIf I call apiRequest directly like: yield* apiRequest({ meta: { endpoint } }) (which is not ideal for testing), I get the desired result of the server response (or an error on server error).\nI understand that yield* passes control to the yielded iterator until no more values are returned but shouldn't yield* call() do the same?\nSimplified apiRequest in case my problem is here (although as mentioned this code works as expected when called directly).. Essentially this is a wrapper around apiFetch which returns a promise\nfunction* apiRequest({ meta, payload = {} }) {\n    const { endpoint, params } = meta\n    const config = endpoints[endpoint]\n    const url = formatUrl(config.url, params)\n    yield put(requestFetching(endpoint, params))\n    let response\n    let error\n    try {\n      response = yield call(apiFetch, url, config.method, payload)\n      yield put(requestFetched(endpoint, params, response))\n    }\n    catch (e) {\n      error = e\n      yield put(requestFailed(endpoint, params, e))\n    }\n    if (!error) return response\n    throw error\n  }\nTL;DR: What is the difference between yield* <saga> and yield* call(<saga>) (And if you're feeling generous, yield call(<saga>)\n. Hi, thanks for your quick reply (and the sidenote - not sure why I structured it like that now!)\nI see what you mean now about yield* call() and that explains the object is not a generator type error I got at one point.\nI will try and replicate the problem on sandbox and let you know when it's done. Cheers. @dagadbm @Andarist  I'm back :-) Sorry never got round to providing that sandbox and certainly haven't come across the issue since so probably safe to say this was pilot error. ",
    "dagadbm": "and he was never seen again . ",
    "santiago": "@bristoljon how did you solve this issue? i'm experiencing very same behavior where the middleware is not returning back to the saga and just hangs there.\nI've got a very simple workflow where UI triggers a saga, this saga does a call on another saga and then within the latter I make a call to an async function. The async function is called and executed successfully but the middleware just does not come back.\nIs it wrong practice to have a saga that calls another saga that in turn performs another call to a function returning a Promise, like say axios.post?\nIn general,\n```\nfunction * root () {\n  yield takeLeading(ActionTypes.CONFIRM, confirm)\n}\nfunction * confirm() {\n  yield put(Actions.willConfirm())\n  const result = yield call(getObject, \"1\")\n  // --> won't get here\n}\nfunction * getObject(id) {\n  yield put(Actions.getObjectLoading())\n  const myObject = yield call(apiCall, '/objects')\n  // --> won't get here\n}\nfunction apiCall() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      console.log(\"IT DOES GET HERE\") // <--- DOES GET HERE\n      resolve(\"Hola :)\")\n    }, 2000)\n  })\n}\n```. ",
    "brettstack": "I haven't been able to find any discussion on this, but conceivably, I could do this:\njs\nhandleFormSubmit() {\n  this.setState({ isSaving: true })\n  this.props.dispatchSaveForm({\n    formData: this.props.formData,\n    callback: () => this.setState({ isSaving: false })\n  })\n}\nAny issues with this? Is there a better way?. Willing to lose serializability for simplicity here. In this example, I want the form to become disabled and show a spinning icon. Of course I can achieve this by storing state in the store, but it requires a ridiculous number of steps for something that should be so simple.. Right. The redux-wait-for-action approach still has a lot of extra code. This is what I'm currently doing:\njs\n// promise-dispatch.js\nexport default ({ dispatch, actionCreator, payload }) => new Promise((resolve, reject) => dispatch(actionCreator({ ...payload, resolve, reject })))\njs\n// In a React component\nconst response = await promiseDispatch({\n  dispatch,\n  actionCreator: widgetsPageLoad,\n  payload: { foo: 'bar' }\n})\nthis.setState({ loading: false })\nIdeally this would just be\njs\nconst response = await dispatch(widgetsPageLoad({ foo: 'bar' }))\nthis.setState({ loading: false }). ",
    "raarts": "I think the state does belong in the store, but if there's a way to address this:\n\nbut it requires a ridiculous number of steps for something that should be so simple.\n\nthat would be great.. I think the state does belong in the store, but if there's a way to address this:\n\nbut it requires a ridiculous number of steps for something that should be so simple.\n\nthat would be great.. ",
    "norbertpy": "Any update on this? Some of the transient states do not really belong to redux store. Is there an easy way to do:\n```javascript\nclass App extends Component {\n  state = {\n    loading: false,\n  }\nhandleGetData = () => {\n    this.setState({ loading: true });\n    const data = this.props.getData(); // SAGA\n    this.setState({ loading: false });\n  }\nrender () {\n    const { loading } = this.state;\n    return (\n        \n          { loading &&  loading...  }\n           fetch \n\n    );\n  }\n}\n```. A form getting submitted has nothing to do with redux store. I wanna show a popup before the request and close it after it's done. There is no point writing reducer, action creator, ... for that tiny thing. The [Prophet][1] himself seems to agree.\n[1]: https://github.com/reactjs/redux/issues/1287#issuecomment-175351978. Thanks. But that's the same thing as writing redux ceremonial stuff. \n\nNow I have two problems.. \n",
    "sam-rad": "@brettstack, @norbertpy If you want generators with ease and not coupled to redux store, you can use co or simply async/await. It'll be like:\n```javascript\n// logic.js\nimport co from 'co';\nexport const getData = () => \n  new Promise(res => setTimeout(() => res(), 2000));\nexport const getRestOfTheData = () => \n  new Promise(res => setTimeout(() => res(), 3000));\nexport const getAll = co.wrap(function* () {\n  const d = yield getData();\n  const r = yield getRestOfTheData();\n  return { d, r };\n});\n```\nAnd then in your component:\n```javascript\nimport { getAll } from './logic';\nclass App extends Component {\n  state = { loading: false }\n  handleGetData = () {\n    this.setState({ loading: true });\n    getAll()\n      .then(data => this.setState({ loading: false, data: data }))\n      .catch(e => this.setState({ loading: false, error: 'error' }));\n  }\n  render () {\n        return (...);\n  }\n}\n```",
    "th0rv": "hey there! any updates on this point? . ",
    "salterok": "@brettstack @norbertpy I use helper function in one of my work projects. Seems like it solves your case.\nThere is middleware.run(saga, ...args) method described in docs which supposed to run dynamic saga.\nSo i do something like this:\n```javascript\n// middleware.js\nimport createSagaMiddleware from \"redux-saga\";\nconst sagaMiddleware = createSagaMiddleware();\n// 'sagaMiddleware' should be registered as middleware in 'createStore'\n// otherwise you have no access to store \nexport function execute(saga, ...args) {\n    return sagaMiddleware.run(saga, ...args).done;\n}\nAnd in my component use exported **execute** function:javascript\nimport * as React from \"react\";\nimport { execute } from \"./middleware\";\nclass ExampleComponent extends React.Component {\n    async onLoadClicked() {\n        this.setState({\n            loading: true,\n        });\n        const result = await execute(mySagaHandler);\n        this.setState({\n            loading: false,\n            result\n        });\n    }\n    render() {\n        return (...);\n    }\n}\n``\nNote thatmySagaHandler` can read/write to store and use other effects.\n. @jochakovsky  I've posted some solution earlier in this thread, which can be integrated with component even further.\n```javascript\n// declared somewhere near store creation\nfunction bindToSaga(fn) {\n  return (...args) => sagaMiddleware.run(fn, ...args).done;\n}\nclass Foo extends React.Component {\n  constructor(props) {\n    super(props);\nthis.initialize = bindToSaga(this.initialize.bind(this));\n\n}\n*initialize(param1, param2) {\n    yield put({\n      type: \"MAKE_STORE_HAPPY\",\n      payload: param1 + \" \" + param2,\n    });\n// call function passed from parent\nconst readyResult = yield call(this.props.ready);\n\nthis.setState({\n  title: \"I'm ready!!!\",\n  verySpecialValue: readyResult,\n});\n\n// if someone is interested in result\nreturn {\n  meow: true,\n}\n\n}\nrender() {\n    return (\n       this.initialize(\"Hello\", \"world\")}>\n    )\n  }\n}\n```\nSo this way you can use components state & props inside your saga.. ",
    "mingca": "I am much interested in this topic but it's fruitless.  redux-saga is designed for side effects. it can track each event but can't track every event.. ",
    "a-type": "I did some exploration into this problem with redux-facet. Specifically, a kind of hack which wraps / intercepts saga generator effects: https://github.com/Bandwidth/redux-facet/blob/master/src/facetSaga.js\nThe idea in this library is that every action gets tagged with a meta.facetName value so that it can be traced back to the component which dispatched it.\nThe facetSaga wrapper intercepts all put effects and references the original action which triggered the saga, copying its meta.facetName value onto the outgoing actions.\nThis makes it (kind of) easy to keep track of the thread from the REQUEST action to the COMPLETE (or FAILED) action.\nThe same technique might be useful in resolving a promise on the original action.\nFor instance, a generator wrapper could be written like so...\n```js\nconst smartActionCreator = (data) => {\n  let resolve;\n  let reject;\n  // there's probably a way cleaner way to do this:\n  const promise = new Promise((res, rej) => { resolve = res; reject = rej; });\n  return {\n    type: 'SOME_ACTION',\n    payload: data,\n    meta: { resolve, reject, promise },\n  };\n};\nfunction trackCompletion(saga) {\n  return function(action) {\n    // ignore 'dumb' actions without promises\n    if (!action.meta.promise) {\n      yield saga(action);\n      return;\n    }\nconst { resolve, reject } = action.meta;\n\nconst iterator = saga(action);\nlet lastResult;\n\nwhile (true) {\n  let next;\n  if (lastResult instanceof Error) {\n    // an error was thrown, reject the action promise\n    reject(lastResult);\n    next = iterator.throw(lastResult);\n  } else {\n    next = iterator.next(lastResult);\n  }\n\n  if (next.done) {\n    // the saga has completed!\n    resolve(next.value);\n    return next.value;\n  }\n\n  // keep generating values\n  lastResult = yield next.value;\n}\n\n};\n}\n// usage\n// using the saga wrapper\nfunction handleAction(action) { / ... / }\nfunction () {\n  yield takeEvery('SOME_ACTION', trackCompletion(handleAction));\n}\n// dispatching the action and awaiting saga completion\nconst { meta: { promise } } = dispatch(smartActionCreator(data));\nawait promise;\n// saga is complete.\n```\nCode has not been tested, just spitballing\nThis could probably be streamlined by doing the async action stuff in middleware; there are many solutions for that.\nI'm thinking of ways that the redux-saga library could more directly support the kind of pattern seen above without having to do a generator-wrapper (though I don't think the wrapper is too complex by itself).\nPerhaps a way to add middleware to the redux-saga library itself? Some place we could put the code above so that it would be applied to every saga? Of course, not every saga has an action as a parameter, so that might not make much sense. Perhaps this wrapper function is good enough.. I agree, I don't think it's a good idea to make this a built-in behavior.\nI've been doing some more thinking on this problem. I think the approach may be flawed from the start. I'm starting to believe that a combination of 1) more case-specific sagas and 2) more usage of saga composition may provide a cleaner answer.\nConsider the original form-submit use case. As boilerplate-y as it is to store loading state in Redux, if we consent to do so, we can write a pretty readable saga to achieve our aims...\n```js\n// generic state reducer for 'raw' profile data. Can be combined in selectors\n// to provide data to any view which deals with profiles\nconst defaultProfileState = null;\nconst profileReducer = (state = defaultProfileState, { type, payload }) => {\n  switch (type) {\n    case 'PROFILE/NEW_DATA': return payload.data;\n    default: return state;\n  }\n};\n// view state reducer for any state related to the profile edit form\nconst defaultProfileEditState = { loading: false, error: null };\nconst profileEditFormReducer = (state = defaultProfileEditState, { type, payload }) => {\n  switch (type) {\n    case 'PROFILE_EDIT_FORM/SUBMIT': return { ...state, loading: true };\n    case 'PROFILE_EDIT_FORM/RESET': return defaultProfileEditState;\n    case 'PROFILE_EDIT_FORM/SHOW_ERROR': return { ...state, error: payload.message };\n    default: return state;\n  }\n};\n// generic, reusable data saga which encapsulates updating a profile,\n// including dispatching data-related actions to update the raw data in the store.\n// returns the updated profile.\n// this saga isn't directly connected to any take effects. It is only called\n// by view-related sagas.\nfunction* profileUpdateSaga(profileData) {\n  // let's assume this throws an error on 4xx/5xx\n  const apiResponse = yield call(sdk.updateProfile, profileData);\n  // put a data-centric action to update the raw data in the store\n  yield put(profileActions.newData(apiResponse.body);\n  return apiResponse.body;\n}\n// view-specific saga which delegates profile update to the general saga,\n// but also adds effects which relate directly to the profile edit form view.\nfunction* profileEditFormSaga({ payload }) {\n  try {\n    const profile = yield call(profileUpdateSaga, payload.data);\n    // we can freely include view-specific concerns here in a readable way\n    yield put(profileEditFormActions.reset());\n    // even other side-effects like routing, since this saga will only ever represent\n    // the experience on the profile edit form view\n    yield call(navigation.goTo, '/home'); // mock / generic navigation service\n  } catch (err) {\n    yield put(profileEditFormActions.showError(err.message));\n  }\n}; \nfunction* watchProfileEditFormSubmit() {\n  yield takeLatest('PROFILE_EDIT_FORM/SUBMIT', profileEditFormSaga);\n}\n```\nThis may seem like redux-saga 101... cause it is... but I know I've personally gone really far down the rabbit hole in search of a way to effectively achieve this kind of pattern where we can have generic, reusable logic for common data and still have very specific and easy-to-follow logic for views. I think the desire to manage loading state within the component itself is coming from the same need which this pattern addresses: we want to have a place which can plainly manage highly specialized user flows which come from specific views without polluting our generic logic with edge-cases. Saga composition, based on my explorations, still seems like the best way to do this (even if it means we must move some state to Redux like loading or error alerts). It just seems like once you use redux-saga, it needs to be the exclusive way that you handle asynchronous operations. As a middleware which has no concept of the view, it can't easily be sewn together with view-based logic like other approaches (thunks, etc) can. Personally, I'm cool with that.. ",
    "ovaldi": "Mark!\n. Hi @GuyMichael  I have the same question, how do you handle this case?. Hi @shinima in this case, the error throw from reducer, it cannot caught by catch and onError, so I created this issue, :). @shinima Oh, I see it works on redux-saga@v1.0.0-beta.1, cool!\nBUT, it does not work on v0.16.0 :(\nhttps://codesandbox.io/s/pk563kzw70. Yeah, it might be a bug of v0.16.0, anyway, thank you @shinima \nLooking forward to v1.0.0 released asap!. Got it, thank you @restrry @Andarist  :). ",
    "klis87": "Also I am creator of library https://github.com/klis87/redux-saga-requests for simplification of AJAX requests - promises like those with Redux-thunk are built-in there. Disadvantage is that promisification is just for AJAX request, but usually this is what most people need anyway :). Actually I have just found a solution:\njavascript\nfunction* articlesSaga() {\n  yield put.resolve(fetchArticles());  // axios middleware actions return promises, so this blocks saga until it is resolved\n}\nI will leave this issue opened, as I am still wondering whether it is still possible to block on take to receive an action other than END. I tried:\njavascript\nwhile(true) {\n  const action = yield take.maybe('SOME_ACTION');\n  if (action.type !== END.type) {\n    break;\n  }\n}\nbut this just leads to an infinitive loop, so I guess you cannot receive any action other than END after END is dispatched.. Ok, thanks for confirmation. In my case articlesSaga is actually independent on FETCH_ARTICLES_SUCCESS - only a  reducer cares about this action. The problem is, that articlesSaga needs to be blocked until FETCH_ARTICLES_SUCCESS (this action is sent by Axios middleware after AJAX call promise is resolved) for SSR purposes. If saga is destroyed by END before FETCH_ARTICLES_SUCCESS, I will start SSR before reducer picksFETCH_ARTICLES_SUCCESS, so my HTML won't include article list. Fortunately the trick with put.resolve works for me.\nThanks for the tip with stdChannel, custom channels for inter saga communications might come in handy as well for some cases \ud83d\udc4d . @Andarist OK, I see. My main problem is, that I would like to use axios interceptors, so I will need to create axios instance for each request so each axios instance would have acess to a separate store. The problem is, how my sagas could get access to this instance? I thought about passing it as saga.run param, but I use duck structure for my stores - I have many modules with separate actions, reducers, sagas and I connect those with combineReducers and my rootSaga - but then my rootSaga would need to pass axios to all children sagas and it would get a little messy. I was thinking also about createSagaMiddleware.emitter, so I could inject axios there and it would be available as part of payload of each action, what do you think about this solution?. ohhh great! that's exactly what I needed! Maybe I will even write a library like redux-saga-axios using this feature :) or... maybe this would be an overkill, as it is so easy to integrate redux-saga with just anything anyway :). Yes, it looks really similar, the problem is, that I wanted to have something like nested assert (assert.test) in it block, so I could test generator branches in a readable way within one it block. I guess this is not possible and it is just better to test 1 branch per each it block. I guess we could close this issue :). Yes, I think this is the best way to go about this. Thanks \ud83d\udc4d . @Hauuguu My initial idea was to use this syntax only when actually I don't need to know the winner:\njavascript\nyield race([\n  call(someFunction),\n  take('ACTION_WHICH_SHOULD_STOP_EXECUTING_SOME_FUNCTION')\n]);\nI could do it for example when I would like someFunction task to be cancelled automatically when ACTION_WHICH_SHOULD_STOP_EXECUTING_SOME_FUNCTION is the winner. \nAnd yes, PR was already submitted, but it is waiting for review #1167 \nAfter PR is merged, it will be possible like this:\n```javascript\nconst [someFunction, cancelAction] = yield race([\n  call(someFunction),\n  take('ACTION_WHICH_SHOULD_STOP_EXECUTING_SOME_FUNCTION')\n]);\nif (someFunction){\n  [...do something here...]\n}\n``. No problem, and thank you for you help and time with this PR. Regarding sparse array potential problem, I also don't think this would cause any issue in the future :). I think not because when I imported your types in my index.d.ts file, typescript complained about it. Thank you, I will check out lib option. Sry for the noise, I just don't use typescript on the daily basis.. It seems so, as aftertaskis cancelled, this saga will hang untiltake(actionType)` is fired. I will create a demo soon, I hope I will manage it tomorrow.. I prepared demo: https://codesandbox.io/s/73qo3w8096\nIt looks like we have 2 problems, when join is used in race, when task finishes normally, it will win, but winner object won't contain winner's key. 2nd problem, when task is cancelled somewhere else, this saga will still run, demo shows 2 cases:\n- 1st case - just click Start new worker.\n- 2nd case - click Start new worker and then within 5s Stop all workers. re 1) My bad :)\nre 2) When I raised this issue, when task is cancelled, I expected taskFinished to be the winner. I thought this is more logical, because as mentioned in docs : \n\nCancellation propagates downward\n\nBut after more thinking, when you yield call(saga) and saga will be cancelled, then caller would be cancelled too.  In the contrary to  yield fork(task). And because join is like converting fork to call, I think that joining a task which gets aborted should abort the joiner - and we could always use try finally and yield cancelled() when necessery, so I think this is the best approach. Although maybe wrapping join inside race should \"protect\" saga yielding race? :) I think it shouldn't, but thats a tough one :). @Andarist I see, now it makes sense :) so actually does it make any difference then? I just wonder why it is excluded, for build performance reasons?\nBtw, sry for a little off-topic but this is why my initial question arised, would u advise to use babel-runtime in saga library addons? Recently I got an issue in my addon https://github.com/klis87/redux-saga-requests/issues/157 about regeneratorRuntime is not defined\nI recommended there to use babel polyfill, but I am not sure whether I shouldnt just use babel-runtime there. Because I didnt exlude transform-regenerator to support older browsers, in practice I force to use generator polyfill even for modern browsers due to generator transpilation, which is huge disadvantage of my current solution.\n. @Andarist ok, thx, I will probably go with  transform-runtime, the lesser evil.. @restrry I am sure, because I don't do anything fancy at https://github.com/klis87/redux-saga-requests/blob/master/packages/redux-saga-requests/src/sagas.js#L239, just take an action, plus everything works in redux-saga 0.16. Unfortunately I cannot do unit tests because I use redux-saga-test-plan which doesnt support redux saga 1.0.0-beta.3 yet. \nIf thats not problem for you re debugging, you can add console.log to check returned action by take, then build everything with yarn build in project root, then you can go to examples, like https://github.com/klis87/redux-saga-requests/tree/master/examples/advanced. @Andarist what do you mean, effects were moved to a separate package? Do we have any migration guide?. @Andarist Ahhh sry for this, I updated it locally, I just gave you a reference to it so you could see the whole codebase, officially I support only 0.16. Do you want me to prepare a 1.0 branch so you could clone it to reproduce it locally?. @restrry @Andarist probably this was my mistake, sry for that. I assumed that I needed to update only dep in my examples, because redux-saga is peer dep of redux-saga-requests. However, I had redux-saga as dev dependency pinned which I didn't think about.\nAll in all, the only change I need to make is delay import, other stuff work! Thanks and apologies again for taking your time. No problem, indeed returning Array would be more consistent :) I could try to fix it myself, but I find it hard to understand how to return Array not Object in this function, this is not a pure function and no object is returned here, so I guess I need to follow this project's convention, but I need a small hint.\nBtw, wouldn't Array.from({ ...response, length: keys.length })be more legible than [].slice.call(result)? . Ok thx. I did it but I have a small problem. In below test\n```javascript\ntest('processor race between array of effects handling', assert => {\n  assert.plan(1)\nlet actual = []\n  const timeout = deferred()\n  const input = cb => {\n    Promise.resolve(1).then(() => timeout.resolve(1)).then(() => cb({ type: 'action' }))\n    return () => {}\n  }\nfunction* genFn() {\n    actual.push(\n      yield io.race([\n        io.take('action'),\n        timeout.promise,\n      ]),\n    )\n  }\nproc(genFn(), input).done.catch(err => assert.fail(err))\nconst expected = [[, 1]]\nsetTimeout(() => {\n    assert.deepEqual(actual, expected, 'processor must fullfill race between array of effects')\n    assert.end()\n  })\n})\n``\nI have problem withconst expected = [[, 1]]. It is not the same as[[undefined, 1]and it breakseslintrule:error  Unexpected comma in middle of array  no-sparse-arrays. Could we block this rule for this test or you have some alternative?. @Andarist Any news on this? Btw, we can solve our our issue with[...[, 1]], which will be converted to[[undefined, 1]]`. ",
    "HunderlineK": "There are multiple ways to achieve what you want (adding a middleware to creating and saving the promises as symbols in your store, etc.) but I'd argue you should only need to either dispatch actions or handle the asynchronous operation internally, and not both.\nThe essence of what you are trying to achieve is making your React component become aware of the asynchronous nature of the action you are dispatching, and, concretely, introducing promises (or observables, async/await, generators, etc.) into your component. If you are okay with introducing asynchronous operations into your component, then why not just postpone submitting the redux action until the action is resolved?\nhandleSubmit = (data) => {\n fetch(uri, { method: 'POST', body: JSON.stringify(data) })\n  .then(payload => { this.props.action(payload); this.handle(payload) })\n  .catch(error => { this.props.action(new Error(error)); this.handle(new Error(error)) })\n}\nThe point is that if your store does not already contain the information that an asynchronous action has started and is pending and you do not want to add that information to the store because it is not needed at a global level then, by definition, there is no need to dispatch the action until the asynchronous operation has already been resolved/rejected.\n. ",
    "jochakovsky": "Here\u2019s a scenario where Saga -> Component communication is required that I haven\u2019t seen in this thread so far (though I may have missed it):\nWe are following the Redux SubApp pattern - in our case, I help maintain a \u201cSubApp\u201d that exists in a large SPA consisting of both React and non-React components. The props passed into the root SubApp component are the primary way that the SubApp communicates with the larger application. Unfortunately, the Redux SubApp example linked above has no examples where the SubApp accepts any callback props (or any props at all).\nWe need to call some callbacks passed to the root SubApp component after asynchronous activities are completed (eg. calling something like this.props.ready() after everything is loaded). Here are some approaches we\u2019ve considered:\n\nPut the prop into Redux Saga context (if the prop is a function) at load using an undocumented createSagaMiddleware API, eg. createSagaMiddleware({context: {ready: this.props.ready}}). Works well enough if you can assume that the prop never changes. If it does change, then you have to update the Redux Saga context every time it changes, which is cumbersome.\nPut a reference to the root SubApp react component into the Redux Saga context, eg createSagaMiddleware({context: {rootComponent: this}}). It will always have the latest props, I think, but this seems incredibly hacky.\n(not Redux Saga specific) Update some state when we want the callback to be called - basically the top-voted answer to this StackOverflow question. The comparison between this.props and nextProps doesn\u2019t seem ideal, it seems to be a React anti-pattern that should be avoided in React except in specific scenarios like animations. Plus, react-redux doesn\u2019t guarantee that every state change results in a re-render, which may result in the app not calling the callback when expected - not an issue with this particular this.props.ready() example, but could be an issue with other examples.\n(not Redux Saga specific) Put the callback in the action, as suggested here, but then the action isn\u2019t serializable, and if the root SubApp component is passed a new callback in the meantime, the action will still reference the old callback.\n(not Redux Saga specific) Put the callback in the Redux store, but then the Redux store isn\u2019t serializable, and it has to be kept in sync with the latest props passed into the SubApp root component.\n\nI\u2019m at a bit of a loss of what the best approach is when following the SubApp pattern, any tips would be appreciated!. @saboya Yes, there is a BigApp, to use Redux's terminology, that controls all of that. We do already have an inter-app communication channel - the BigApp passes state and callbacks as props to each SubApp. If you're suggesting adding a second inter-app communication channel, maybe something using events, this seems to add a lot of complexity just to get around some redux/redux-saga limitations. From the SubApps perspective, calling a callback passed from the BigApp seems like a regular side-effect to me, but I don't see a clean way for Redux Saga to interact with the props passed in from the BigApp.. @saboya that kinda works for BigApp -> SubApp communication, although it suffers from the same issues described in the third point of my first comment. I'm more concerned about SubApp -> BigApp communication, for which neither Redux nor Redux Saga seem to have any solutions for.. ",
    "littlehome-eugene": "Is the following practice worth considering? \nhttps://stackoverflow.com/a/42590347/433570 . \nI spent all day dinking around with this stuff, switching from thunk to redux-saga\nI too have a lot of code that looks like this\nthis.props.actions.login(credentials)\n.then((success)=>redirectToHomePage)\n.catch((error)=>alertError);\n\nits possible to use thunk + saga\nfunction login(params) {\n  return (dispatch) => {\n    return new Promise((resolve, reject) => {\n      dispatch({\n        type: ACTION_TYPES.LOGIN_REQUEST,\n        params,\n        resolve, \n        reject\n      })\n    }\n  }\n}\n\nthen over in saga land you can just do something like\nfunction* login(action) {\n  let response = yourApi.request('http://www.urthing.com/login')\n  if (response.success) {\n    action.resolve(response.success) // or whatever\n  } else { action.reject() }\n}.\n",
    "schraj": "Thanks for the quick response.\nWhen doing the following:\n1) a clean clone of the repo\n2) then running NPM Install\n3) the node-modules directory is created and appears to be complete\n4) the \"npm\" package for \"npm\" itself is installed in the local node-modules directory and its version is 2.14.8.\n   a)  the following warning appears in the install process as the node modules are being installed\nnpm WARN prefer global npm@2.14.8 should be installed with -g\n   b) this local \"npm\" module is being required by \"gitbook-cli\" \nI tried upgrading that local version to the current version but I still get the same failure(Below).\nC:\\gitOpenSource\\redux-saga\\test\\middleware.js:5\nvar _tape2 = babelHelpers.interopRequireDefault(_tape);\n             ^\nReferenceError: babelHelpers is not defined\n    at Object. (C:\\gitOpenSource\\redux-saga\\test\\middleware.js:5:14)\n    at Module._compile (module.js:571:32)\n    at loader (C:\\gitOpenSource\\redux-saga\\node_modules\\babel-register\\lib\\node.js:144:5)\n    at Object.require.extensions.(anonymous function) [as .js] (C:\\gitOpenSource\\redux-saga\\node_modules\\babel-regis\nter\\lib\\node.js:154:7)\n    at Module.load (module.js:488:32)\n    at tryModuleLoad (module.js:447:12)\n    at Function.Module._load (module.js:439:3)\n    at Module.require (module.js:498:17)\n    at require (internal/module.js:20:19)\n    at Object. (C:/gitOpenSource/redux-saga/test/index.js:2:1)\nnpm ERR! Windows_NT 10.0.10240\nnpm ERR! argv \"C:\\Program Files\\nodejs\\node.exe\" \"C:\\gitOpenSource\\redux-saga\\node_modules\\npm\\bin\\npm-cli.\njs\" \"run\" \"test\"\nnpm ERR! node v7.9.0\nnpm ERR! npm  v4.2.0\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! redux-saga@0.14.3 test: cross-env BABEL_ENV=cjs babel-node test/index.js | tap-spec\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the redux-saga@0.14.3 test script 'cross-env BABEL_ENV=cjs babel-node test/index.js | tap-spec'.\nRunning lint alone is is successful:\nnpm run lint \nRunning test alone is not and gives the error above as well:\nnpm run test\n. That did it.  Thanks for taking the time to help with this!. ",
    "ahmed3eraqi": "\n. when i install  angular new project\nng new appname. ",
    "guswnsxodlf": "Thanks :)\nIs it same process on the fork fork delay(call) example, not only [call, call, call]?. Ok Thanks!\n```\nimport { delay } from 'redux-saga'\nimport { fork, call, put } from 'redux-saga/effects'\nimport api from './somewhere/api' // app specific\nimport { receiveData } from './somewhere/actions' // app specific\nfunction* fetchAll() {\n  const task1 = yield fork(fetchResource, 'users')\n  const task2 = yield fork(fetchResource, 'comments')\n  yield call(delay, 1000)\n}\nfunction* fetchResource(resource) {\n  const {data} = yield call(api.fetch, resource)\n  yield put(receiveData(data))\n}\nfunction* main() {\n  yield call(fetchAll)\n}\n```\nI'm curious about how 'fetchAll' can detects whether the tasks end..\n. But fetchAll doesn't yield before 2 tasks end even if delay ends.. Ahha! Thank you so much :). ",
    "schuma7": "Ok, that answers my question, thank you!. ",
    "forgo": "Something interesting to note that I just discovered:\nIf I simply do nothing in my reducer by a return state, the saga gets executed. If I modify the state in the reducer action switch and return that state, then the saga no longer gets executed...\nAny ideas why that would happen?\nThe state is being modified elsewhere where the same action is being executed, and the saga has no issues with that.. I found a workaround, but I'm still not sure why it wasn't working to begin with (hopefully somebody out there might have an idea).\nWhat I ended up doing was, instead of passing the \"addBreadcrumb\" action down from a higher level parent component (e.g. - <Parent action={addBreadcrumbs}> <Map action={addBreadcrumb} /> </Parent>), I connected the lowest level  component to a NEW action (via mapDispatchToProps) called \"addBreadcrumbFromMap\".\nFrom that new action reducer for \"addBreadcrumbFromMap\", I intermediately stored the breadcrumb the map should be adding in my reducer's state -- as opposed to re-using the same \"switchView\" saga to unpack the \"last\" breadcrumb on my stack (which I thought should always correspond to the last pushed breadcrumb item (apparently not?).\nSo now I have a new saga \"switchViewFromMap\" triggered by the new action which deconstructs my breadcrumb, applies the action the same way as \"switchView\" did, except now I am additionally calling yield put at the end to trigger the \"addBreadcrumb\" action and, consequently, the normal \"switchView\" saga.\nTo me, there seems to be an unnecessary duplication of logic here. It appears I need to effectively trigger the same action twice, unless I am fundamentally misunderstanding something...\nIf anybody has insight into how I can reduce this into a single saga and action again, I'm all ears.. ",
    "christopherdiehl": "Hello all, I'm only calling CREATE_PRODUCT on a button press. In my testing, I am also making sure that the createProduct saga has finished before pressing the button once again. \n@Andarist is correct, I am starting watchCreateProduct() when the route loads. I believe that the previously injected saga is discarded. If it helps any, I'm using react-boilerplate. \n. Here is a sample route in my routes.js file. @Andarist  how would you suggest discarding the sagas on route change?\n```\n  }, {\n  path: '/foo',\n  name: 'Foo',\n  getComponent(nextState, cb) {\n    const importModules = Promise.all([\n      System.import('containers/Foo/reducer'),\n      System.import('containers/Foo/sagas'),\n      System.import('containers/Foo'),\n    ]);\nconst renderRoute = loadModule(cb);\n\nimportModules.then(([reducer, sagas, component]) => {\n  injectReducer('resetPassword', reducer.default);\n  injectSagas(sagas.default);\n  renderRoute(component);\n});\n\nimportModules.catch(errorLoading);\n\n},\n}, {\n```. I needed to cancel the saga on location change.\nLike so:\n/*default saga*/\nexport function * watchCreateProduct() {\n  const watcher = yield takeLatest(CREATE_PRODUCT,createProduct);\n  yield take(LOCATION_CHANGE);\n  yield cancel(watcher);\n}\n/*saga that does stuff*/\nexport function* createProduct() {\n  console.log('CREATING PRODUCT');\n}. ",
    "jinalskothari": "https://redux-saga.github.io/redux-saga/ redirects there!. ",
    "indus": "Sorry for the mess. When I wrote the 4 steps for a subdomain request GiHub pages didn\u00b4t made an automatic redirect after adding a CNAME. Now it does, so I also accept requests without a CNAME and add them to JS.ORGs zonefile first, but merge the request after the CNAME is setup by the owner.\nNevertheless it is on it way but you may face DNS caching if you tied to open the URL before.. Sorry for the mess. When I wrote the 4 steps for a subdomain request GiHub pages didn\u00b4t made an automatic redirect after adding a CNAME. Now it does, so I also accept requests without a CNAME and add them to JS.ORGs zonefile first, but merge the request after the CNAME is setup by the owner.\nNevertheless it is on it way but you may face DNS caching if you tied to open the URL before.. ",
    "dispix": "Nice @alvelig ! Will try to look at them cause they seem pretty interesting libs and I may give you a hand if you plan on maintaining them :). ",
    "trevorharwell": "I just ran into this exact issue.  It appears that react-boilerplate is blinding calling store.runSaga every time you load a dynamic page https://github.com/react-boilerplate/react-boilerplate/blob/master/app/routes.js#L34.  I, like @kfrajtak, assumed that the default saga would be loaded once on first page load, and then never again.  It appears this assumption is incorrect.  I will be submitting a PR to the react-boilerplate to fix this issue as soon as a get a chance.. Here is my PR that allows loaded components to not get re-processed and thus cause this issue.\nhttps://github.com/react-boilerplate/react-boilerplate/pull/1734. ",
    "lxcid": "Thanks @Andarist! Both example are awesome! I couldn't have asked for more!. ",
    "Slapbox": "@Andarist in your second example I need to use wait delay(ms) instead of wait: call(delay, ms) which resolves immediately. Is this correct behavior, or a bug in Redux-Saga@1.0.0-beta.1?. Great explanation. Thanks very much @shinima. If you have any ideas about this related question on flushable buffers in throttling (with the addition of canceling tasks) I could really use some guidance on what I'm misunderstanding here: https://github.com/redux-saga/redux-saga/issues/1511\nThanks again for your explanation of delay. Makes perfect sense, though the existence of the two methods in the first place makes less sense.. @klis87, awesome!. What's the best way to get started with this now? Redux Saga is the best thing sliced bread, but the error tracing is no fun.. Just to add some context on what @Andarist is referring to: https://github.com/redux-saga/redux-saga/pull/1310\n\n@AriaMinaei thanks for sharing, this is an interesting technique but imho it seems more old-fashioned and heavy than a \"simple\" babel plugin. Note that we will show \"nicer\" (than today) errors even without babel plugin.. Yes I suppose not. It occurred to me later that day that I could put all the generator functions into files and import those into the saga starting files/functions.. I should note I have something like 20 conditional effects for this case. The only solution I've seen is to set up an individual watcher for every effect. Surely there's something better?. Thanks for your reply. So I tried something like this:\n\nexport default function* rootSaga() {\n  while (true) {\n    const task = yield take();\n    const userIsLoggedIn = yield select(getUserStatus);\n    if (userIsLoggedIn) {\n      yield all([\n        fork(syncNotesSaga),\n        fork(firebaseFileIndex),\n        fork(firebaseUserParams),\n        takeLatest(types.NOTE_TEXT_UPDATE, handleUpdateNoteText),\n        takeEvery(types.NOTE_ADD, updateNoteFirebase),\n      ]);\n    }\n  }\n}\nUnfortunately this led to repeat runs of sagas and still did not allow for dynamically changing whether or not these should be run. Even when userIsLoggedIn was false and it showed it was the case, the sagas referenced under the yield all still ran.\nI understand I could use take and create a watcher and runner for each task, but in reality there are more like 20 tasks in the yield all, not just the 5 shown here, which seems like it would quickly get very unwieldy. Is there some better option available? Sorry to clutter up the issues section with this. Someone could make good money offering a comprehensive tutorial on Redux-Saga. That is some beautiful code that not only works wonderfully, but has helped me to better understand the fundamentals of flow control with redux-saga.\nI know you get a lot of questions and I see you take the time to respond to them all. Thanks very much! I can't tell you how much I appreciate it.. Is there an ETA for stable v1.0? A month? 6 months?\nSome rough estimate, however rough, would be really helpful. Sorry, I know a little off topic, but I don't want to clutter the issues.\nThanks to everyone who works on this incredible project.. Thanks very much for the update. I'm very excited for 1.0, but I'll hold off until at least the next beta with this is mind.\nYou're all doing excellent work. Redux-saga is just incredible.. Mysteriously after stepping away from my code for several minutes, I saw it was then making it to updateValues(), but never hitting log.warn(\"Flushing buffer\");\nI have since been unable to reproduce this behavior, which makes it even more baffling to me.. Yeah sure. Thanks @Andarist!\nBasically what I'm trying to have a background sync operation like in the example where you laid out the code for the throttle with a flushable buffer, but I also want to wait until a user has stopped adding input to their local document before syncing it to the cloud for the sake of not overloading the server with a new updates.\nFor example, if someone types for 30 seconds straight, I'd like to wait until their is a lull in the input to allow the task to proceed and make just 1 update, rather than making one update every 5 seconds, for a total of 6 updates. What I tried to do above was to add a leading delay to the task so that it would have a chance to be canceled if newer input occurred.\nI'd also like to keep the throttle for flexibility, as there might be times that it makes sense to have both, although in most cases the throttle is not strictly necessary here. It might make sense with a different throttle and leadingDelay value than shown above though.\nDoes that make sense?. Sounds good to me. @shinima and @Andarist thank you both very much for your help. I'm going to play with this.\nNot that it's required given the code above, but is there a timeline for a redux-saga release with debounce?\nThanks again to you both.. Thanks for your reply @Andarist. I was able to work around this, but I'm still a bit confused.\nIn this particular case I'm not changing any state. I use re-reselect to cache the response to this particular select statement, and while that's usually no problem, I guess I found a case where the response wasn't fast enough and I got back an array full of pending select's instead of an array of the objects I expected.\nCan you elaborate on the concept of a \"releasing trigger\" a tiny bit? The trigger is not, as I understand it, necessarily tied to state, but to the status of the command itself. For example, take blocks until it's fulfilled. Couldn't select block a saga until it's fulfilled/wouldn't this be desirable in some circumstances?. It's synchronous, but the overall code execution of a saga containing select isn't necessarily. What's the right way to handle rare cases where select takes long enough that it's not ready in time for the following lines of code that depend on it. For example, when using reselect to get some derived state which is computationally intensive?. Wow I was very unclear. Sorry about that.\nI should have documented what I was experiencing at the time a bit better to make this easier to discuss. I'm going to close this for now since it's not actively causing me trouble, but if I run into this again I'll come back with a better explanation with code/pictures.\nThanks as always for all your help @Andarist!. Hey @Andarist. Thanks so much for taking the time to do that!\nUnfortunately, trying to put an action still doesn't work with this setup. put effects are just not recognized in general. I should have just put my original code up, but it was ~200 lines as opposed to ~60. In any event, your new example should work as far as I can tell, but it doesn't.\nMy initial suspicion was that there's something wrong with my higher level setup of runSaga and/or the createSagaIO function which is causing dispatched events to either not fire, or not be recognized. I don't know where else to look.\nI also spotted a problem in my example code. This bit should have been:\njs\n  const { response, timeout } = yield race({\n    response: take('*'),\n    timeout: delay(5000)\n  });\n  if (response) console.log(\"CAN'T GET HERE\");\nEven in your corrected example, the only way I make it out of the race effect is via a timeout. It never returns a value for response even in your example. I can't figure out for the life of me why I can't get a response here.\nAny ideas what the root cause could be? Thanks again Andarist!\n. Agh. I just realized I did not mention I'm using beta.2. I don't know if that changes anything in the example besides the delay pieces. With your new code, which clearly works on Code Sandbox, I get the below.\n```\nredux-saga error: Error: call: argument fn is undefined\nredux-saga error: The above error occurred in task putReceipt\n    created by someSaga\nTasks cancelled due to error:\nsomeSaga\n```\nIf I import delay from redux-saga\\effects, it fails silently. If I import it directly from redux-saga as shown, or from @redux-saga/delay-p as mentioned in the release notes, it throws the error above.\nIf I gut the putReceipt function to make it completely empty, at that point I get, TypeError: (0 , _delayP.delay) is not a function, thrown from the race effect.\nSame outcome on beta.1 as well.\nThanks for taking the time to help with this @Andarist. I appreciate it a lot!\n. Thank you so much! This works beautifully!\nIs stdChannel something that should be in the docs? I see it's only mentioned in passing in the docs. I see in the release notes that stdChannel seems to have been mostly for internal operations prior to beta.0.. Thanks again for all the help @Andarist, and for the explanation. It was tough to find solid info on runSaga, but it's really helpful for working with sockets.. So it turns out this works, but I don't understand why:\njs\n  const PromiseFileReader = require('promise-file-reader');\n  const readContent = yield PromiseFileReader.readAsText(blobData);\n  console.log(readContent);\nCan anyone explain why? Will I run into some unforeseen issue with this approach?. @Andarist thank you so much as always for your generosity in helping people with this amazing library!\nBesides being better for testing, are there other benefits to wrapping the promise in a function and using call like that?. Thanks again @Andarist!. Thanks for your response @restrry.\nIt is a generator function. If that's the case, I guess I have something going wrong somewhere else in my lerna setup.\nCan you possibly elucidate why select should work properly in this case though? I don't understand how it gets access to the Redux store's state.. I can't say what exactly fixed this, but it was definitely a build environment issue. Thanks again for your help @restrry . ",
    "VictorQueiroz": "Solved my problem. Nice feature, thank you. ",
    "nico1510": "I got it working using this code:\njavascript\nexport default function* authSaga() {\n    const authChannel = eventChannel(emit => {\n        const unsubscribe = firebase.auth().onAuthStateChanged(\n            user => emit({ user }),\n            error => emit({ error })\n        )\n        return unsubscribe;\n    });\n    try {\n        yield takeLatest(authChannel, handleSyncTask);\n    } finally {\n        if (yield cancelled()) authChannel.close();\n    }\n}\nSo I'm blocking due to the cancelled effect in the finally block. I didn't think this was necessary because I thought the finally block would only be executed once all forked tasks from the saga terminate which is never since I'm using takeLatest which internally uses a while(true) loop. So basically I only have a problem understanding the library which is why I will close the issue now. Maybe you could still try to clear up my misunderstanding here ? \ud83d\ude00\n. Yes the second snippet was fine. I didn't want to use it since it looks like it's reimplementing takeLatest so I tried to use takeLatest instead.\nHowever it seems like it immediately hits the finally block even though the saga still has an unterminated task (the one returned from takeLatest). That's what's surprising to me.. yes something like race but for taking actions instead of calling effects.... aahh that's how it can be done :) Thank you very much ;). ",
    "James-E-Adams": "Apologies to revive a closed issue but I was having a similar issue. The channel in previous function calls wasn't getting closed since takeLatest was stopping the channel.close() from being called.\nI solved it using @nico1510 's second code block, but I was wondering how you would do it using join?\nAlso, would it be possible to handle these kinds of situations within the takeLatest implementation? Seems to be an issue that would occur quite frequently and cause memory leaks etc because you're potentially cancelling a task before clean up.\nUnless it is implied that you should be doing cleanup within a finally block if you plan on using takeLatest. \n. ",
    "younesmln": "interested in working on this issue if possible. we are using file upload to firebase with progress using channel in production I would like to contribute to this issue . @restrry yes thank you . @Andarist I was thinking about an example with firebase storage maybe . @Andarist interested in working on this enhancement. I'm wondering about the status of this issue because I saw the a related PR has been merged but it still open\nI'm interested in helping out if its still an issue . ",
    "sithmel": "I have tried shortly to reproduce the problem in isolation but I couldn't.\nBut if you open the folder node-modules/redux-saga/es/internal/proc.js you can notice very easily that there are 2 \"array\" in the same namespace. One in the import statement and the other added by babel in the name of the function matcher.array.\nAlso the change is pretty straightforward ;-). The error was happening running webpack, but I could not reproduce it with a simpler config.\nFor now we reverted to redux-saga 0.10 and everything is working fine.. are you sure it is necessary ? you can clearly see that the transpiled script is incorrect.\nI'll be happy to try reproducing the issue as soon as I have time.. That's weird I would have bet it was not valid.\nThanks for double checking it!\nApologies I didn't have time to go in depth yet, but I'll have a look as soon as I can. I have noticed that it works if I instruct babel to transpile inside node_modules:\n{\n        test: /\\.jsx?$/,\n        // exclude: /node_modules/,\n        loader: 'babel-loader',\n        query: {\n          presets: [['es2015', { modules: false }], 'es2017', 'react'],\n          plugins: ['transform-runtime', 'transform-decorators-legacy', 'transform-class-properties'],\n        },\n      },\nThat in my project, I have tried to reproduce in isolation but it does not make any difference.\nI am still very confused .... I pinned to acorn 4.0.11 and it worked. Thanks @gunters63 . https://github.com/ternjs/acorn/issues/527#issuecomment-291266872. we can close I think. Thanks a lot @gunters63 and @Andarist . ",
    "gunters63": "Hi,\nWe have the same problem, but only in the production build.\nCould it be a webpack config problem? The only significant difference between development and production config of webpack is this:\n  new webpack.optimize.DedupePlugin(),\n  new webpack.optimize.UglifyJsPlugin({\n     compress: {\n        warnings: false\n     }\n  }),\n\nBabel config is the same for development and production.. No, dedupePlugin is obsolete now, and the uglifier was also not responsible for this.\nAt the moment it seems our problem is some discrepancy in the local and the CI server packaging process.. I think I found a solution. A weird one however.\nA co-worker had the same problem. We compared our outputs of npm list and found this:\nI had:\n+-- webpack@2.5.1\n| +-- acorn@5.0.3\n| +-- acorn-dynamic-import@2.0.2\n| | `-- acorn@4.0.11\nHe had:\n+-- webpack@2.5.1\n| +-- acorn@5.0.3\n| +-- acorn-dynamic-import@2.0.2\n| | `-- acorn@4.0.12\nFunny, there is no known version 4.0.12 of acorn\nacorn-dynamic-import@2.0.2 has a dependency of acorn@^4.0.3\nWhen my coworker pinned his acorn version like this in his package.json:\nacorn: \"4.0.11\"\nit suddenly worked!\nWeird, there is some dependency confusion here, or the npm registry has corrupt modules cached.\n. Good to hear!\nBtw, my coworker and me both have exactly the same version of npm and node (and OS), and we both deleted node_modules and did a fresh npm install.. ",
    "ismay": "I understand, but what I mean is that the warning-message example is missing the brackets, which would mean that it is a default export.\nWarning message:\nimport takeLatest from 'redux-saga/effects'\nShould be:\nimport { takeLatest } from 'redux-saga/effects'\nSeems like a typo because it's not a default export according to the docs. ",
    "pak11273": "I'm getting this warning too.. ",
    "hurrtz": "You where very much correct, thank you. Your answer pointed me in the right direction:\nhttps://github.com/redux-saga/redux-saga/tree/master/docs/api#alleffects---parallel-effects. ",
    "imamatory": "So all([...effects]) is deprecated? Maybe it should be in docs?. ",
    "oliversisson": "For me, I only used it on the rootsaga:\nexport default function* rootSaga() {\n  yield all([\n(import all: import {all} from 'redux-saga/effects';). Hi - thank you for your answer, it's exactly what I'm thinking of! \nI think your solution is much cleaner that my solution and in comparison to the default strips out a huge amount of unnecessary code (\"function* watchSetUser() {yield\" for every watcher). ",
    "crazy4groovy": "I do the same as @oliversisson. Just updated to v0.15.3, updated code accordingly, but I still see the deprecation warning. Why?\nIf I put a debug break in runAllEffect (which runs right after the deprecation msg logged), the effects is an empty array. This all seems odd to me.... releated to: https://github.com/redux-saga/redux-saga/issues/960\nFWIW I can't find anywhere in my code that might be triggering this deprecation warning (ie. yielding an array of sagas); I've already fixed this part:\nexport default function* rootSaga() {\n  yield all([...]);\n}\nSpecifically, I only do things like const resp = yield call(axios.post, ....). ",
    "jasondonnette": "Same, although in Atom doing a regex search for yield .+.map found them for me pretty easily. ",
    "wSLecHayfIeNdock": "\u270d\ufe0f \ud83c\udf89\nexport default function *rootSagas() {\n-  yield [\n-    fork(app),\n-    fork(user),\n-  ];\n+  yield fork(app);\n+  yield fork(user);\n}. ",
    "silarmani": "After hours of debugging my code I noticed something strange\nIf I use all + map + call, where the called function takes 1 parameter then no warning message is logged\nyield all(registerTdids.map((registerTdid, idx) => call(requestLookups, registerTdid)));\nhowever if I add on more parameter to the call then I get the warning\nyield all(registerTdids.map((registerTdid, idx) => call(requestLookups, registerTdid, idx > 0)));\nI even logged what is passed on to all()\n\nwith 1 parameter\n\n[ { '@@redux-saga/IO': true,\n    CALL:\n     { context: null,\n       fn: [Function: requestLookups],\n       args: [ '3.1.1.risk-register.da7ecd5e8ecc4c91ab3f5fa2a0686346' ] } },\n  { '@@redux-saga/IO': true,\n    CALL:\n     { context: null,\n       fn: [Function: requestLookups],\n       args: [ '3.1.1.risk-register.ac408e95706e4235984d6587dbe8ee4d' ] } } ]\n\nwith 2 parameters\n\n', [ { '@@redux-saga/IO': true,\n    CALL:\n     { context: null,\n       fn: [Function: requestLookups],\n       args: [ '3.1.1.risk-register.da7ecd5e8ecc4c91ab3f5fa2a0686346', true ] } },\n  { '@@redux-saga/IO': true,\n    CALL:\n     { context: null,\n       fn: [Function: requestLookups],\n       args: [ '3.1.1.risk-register.ac408e95706e4235984d6587dbe8ee4d', true ] } } ]\nW ReactNativeJS: '[...effects] has been deprecated in favor of all([...effects]), please update your code', ''\nDoes anyone know why?. ",
    "phuongthuan": "I yield call only one.\n```javascript\nexport function* fetchAllReportsOfTeam(action) {\n  try {\n    yield delay(700);\n    const members = yield call(callGetMembersOfTeam, action.teamName);\n    const reports = yield members.map(function (member) {\n      try {\n        return call(callFetchAllReportsOfUser, member.id);\n      } catch (error) {\n        return put(fetchAllReportsOfUserFailed(error));\n      }\n    });\n    const mergedReports = [].concat.apply([], reports);\n    mergedReports.map(report => {\n      const memberReport = members.filter(member => member.id === report.userId);\n      if (memberReport && memberReport.length > 0) {\n        report.userId = memberReport[0];\n      }\n      return null;\n    });\nyield put(getAllReportsOfTeamSucceeded(mergedReports));\n\n} catch (error) {\n    yield put(getAllReportsOfTeamFailed(error.message));\n  }\n}\nexport function* watchFetchAllReportsOfTeam() {\n  yield takeLatest(GET_ALL_REPORTS_OF_TEAM, fetchAllReportsOfTeam);\n}\nexport function* statisticSagaPage() {\n  yield all([\n    fork(watchFetchAllReportsOfTeam)\n  ])\n}\n```\nAnd I call more than one.\n```javascript\nexport function* getProfile(action) {\n  try {\n    const userProfile = yield call(callGetProfile, action.id);\n    yield delay(700);\n    yield put(getUserProfileSucceeded(userProfile));\n  } catch (error) {\n    yield put(getUserProfileFailed(error.message));\n  }\n}\nexport function* updateProfile(action) {\n  try {\n    const newProfile = yield call(callUpdateProfile, action.profileUpdated);\n    yield put(updateProfileSucceeded(newProfile));\n  } catch (error) {\n    yield put(updateProfileFailed(error.message));\n  }\n}\nexport function* watchGetProfile() {\n  yield takeLatest(GET_USER_PROFILE, getProfile);\n}\nexport function* watchUpdateProfile() {\n  yield takeLatest(UPDATE_USER_PROFILE, updateProfile);\n}\nexport default function* profilePageSaga() {\n  yield all([\n    fork(watchGetProfile),\n    fork(watchUpdateProfile)\n  ]);\n}\n```\nBut I still got these error. What did I wrong here ?. ",
    "JulioC": "I'm having the same issue using redux-saga with react-native. It just happens when using remote debug.\nThis comment on a related react-native issue has more information: https://github.com/facebook/react-native/issues/4470#issuecomment-302869193 . ",
    "krzysztofpniak": "@neurosnap what about the first one?. @Andarist my updater isn't asynchronous. Really sorry, I tried to reproduce it in webpackbin and it works. It looks like other middleware causes my problem.. ",
    "fabienjuif": "Hi guys, I don't know if this is the solution you are looking for.\nBut for one of my project, I created a lib that provide some snapshot testing.\nIt relies on stub/mock for call and select than you can inject as arrays.\nhttps://github.com/Trampss/trampss-redux-saga-tester\nI would enjoy some feedback if you give it a try :). ",
    "beelee": "0.14.8\nLG\nBianca\n\nAm 05.05.2017 um 16:17 schrieb Mateusz Burzy\u0144ski notifications@github.com:\nWhat version of the redux-saga do u use?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/redux-saga/redux-saga/pull/968#issuecomment-299476754, or mute the thread https://github.com/notifications/unsubscribe-auth/AQ5C-a8wdq8qumWzNYmHe2mRIwnCVNj4ks5r2y95gaJpZM4NR7Do.\n\n\n. ",
    "cpBurn": "@gajus thanks for your help. Maybe I did express myself wrong. What I mean is that I pass a function to takeLatest, but that function is never called. I need that function to be called and every subsequent action that put to be called as well. Does it make sense?. @Andarist MaintainersTypes.FETCH is dispatched in Home component (just a simple component) on\ncomponentWillMount() {\n    this.props.fetchMaintainers(this.props.language);\n  }\nWhole file here.. @Andarist sure. Here you are:\nhttps://github.com/cpBurn/redux-saga-ssr\n. ",
    "subvertallchris": "Ah! That is great. It hadn't occurred to me to wrap select like that. I don't mind the repetition at all, safety and consistency are way more important as far as I'm concerned. Gonna close the issue since it doesn't seem like we can do more than this. Thanks for the suggestion!. ",
    "Lucretiel": "Ah, yes. My original idea was to replace the error with {[key]: error} or {origin: key, error: error}, but I can see why people would want to have the error be an Error type, especially if exceptions bubble out.\nI like the idea of attaching a property to the error. I'll see if I can write up a proposed impl.\nI wrote a simple wrapper that implements the same idea, but I'd much rather it be an extension to race, because of how heavy the wrapper implementation is. It requires wrapping all of your race Effects in a whole call, with a whole wrapping generator for each one:\njavascript\nexport const raceErrOrigin = racers => race(\n    _.mapValues(racers, (racer, key) => call(function*() {\n        try { return (yield racer) }\n        catch (e) { e.raceOrigin = key; throw e }\n    }))\n). I wasn't sure if modifying the Error counted as a breaking change; I also wasn't sure about the case where an Effect throws something that's not an Error. How will users determine the origin of non-Error errors? For instance, jqXHR just raises itself in the event of an error. Can we just expect users just wrap these in Error types?. How would you feel about retaining wrapErr, in that case? That way, users have a catch-all solution if they want to catch thrown objects more generically and immutably.. It seems to me that there are effects taking more than one argument, but I take your meaning about wanting to keep things simple. Will fix.. Also, I'm trying to write a test for this functionality, but I confess I cannot for the life of me understand what the existing tests are actually doing.. I added a test, so you can tell me if it makes sense or not. Mostly I'm not clear about what the Promise.resolve is doing at the beginning of the test.. I'll update the diff.\n\nany other ideas than raceOrigin, effectOrigin\n\nNothing comes to mind... any reason?. I did it this way cause there wasn't really a good scope to put the local abort variable.. Oh, I apparently changed it. Originally I was storing promise.abort as a local variable. Will change to else if.. Do you mean that you want it to be more unique? Like CANCEL?. How would you feel about a new symbol, then? Users would do err[RACE_ORIGIN] instead of err.raceOrigin. ",
    "eric7578": "Ah... It's my fault, I should use spawn instead of fork\nProblem solved :D.. ",
    "septagram": "Currently I'm using the build on CDNJS. Version there seems to match your latest release tag.. Yes, I tried that:\n```\nconst sagaMiddleware = ReduxSaga.default()\n...\nwindow.store = Redux.createStore (\n    rootReducer,\n    Redux.applyMiddleware (sagaMiddleware)\n)\nsagaMiddleware.runSaga (rootSaga)\n```\nAnd I'm getting TypeError: sagaMiddleware.runSaga is not a function :(. I also tried to download redux-saga.min.js from the repo and use instead of CDN, nothing changed.. Ah, now it was something obvious. I was running .runSaga(), and it's just .run().\nThanks a lot for the help, it works ^_^\nSay, if I'll make a pull request with a small update to the docs regarding this use case, would you merge it?. Here you go ). ",
    "imyaman": ":+1:. ",
    "wilcoxky": "addListener is correctly firing and logging when an event is fired. It seems the emitter is not firing to the take when called within the event handler. I have tried using different Event Emitters with no luck as well. . Thanks for the help, I forked and ran the code and it seems to be working as intended. I believe the problem is occurring because react native seems to be ignoring emitted events from non-mounted components.. I will keep you updated if that was the cause of the issue. Thank you for the help!\n*Edit: Looks like that was the issue. Fixed by dispatching an incoming data action from a mounted component instead of listening to a channel.. ",
    "bhagatali": "@neurosnap apologies for not getting back to you earlier. I didn't have access to my work laptop the past few days. The reason we need to wait until the submit is because we have async stuff inside that action. \nLet me see if I can use the same approach you have going, because I am unable to use the put.resolve.. ",
    "omerdn1": "This is something I've been trying to tackle with some different approaches but I don't like any if them, anyone got an interesting solution?. Any news on this matter?. ",
    "ezubarev": "It sounds more believable however some correction would be desired.. ",
    "noahtallen": "I definitely understand why async/await doesn't integrate with redux saga. But I have some thoughts on why it may be a steep learning curve vs async/await.\nAsync await doesn't really require any configuration, and can be used in any JS code. It's as simple as having a function marked async and awaiting a promise. Super easy! Additionally, many JS devs are reasonably comfortable with Promises because they are used everywhere. I have an understanding of them based on day-to-day use with many libraries, and async/await just makes using promises way easier. Generators really aren't that common, so it's not a tool many are familiar with. I don't understand them that well myself, even though I'm comfortable with redux-saga.\nI think the other part of it is that people aren't just learning the API to redux-saga, but they also have to do a lot of configuration and integration with redux to use it. (Which you obviously can't get around, because you want all of those redux features).\nFor instance, here is a little function using a generator:\njs\nexport function * getData () {\n  try {\n    const data = yield call(databaseFunc, /* parameter is passed using uncommon syntax */)\n    yield put({type: 'NEW_DATA', data})\n  } catch(e) {\n    console.error(e)\n  }\n}\nThat's easy to understand! The hard part to understand is that this generator has to be forked from another saga, for instance triggered by a redux action. All that configuration and the forking model isn't common knowledge and requires practice and learning to understand. (not saying that's bad)\nHere's what that function looks like with async await. You're right, the syntax looks really similar to redux-saga, but it feels a lot more like the JS we use on a day-to-day basis.\njs\nasync function getData () {\n  try {\n    const data = await databaseFunc(/* I could pass parameters using normal function syntax here */)\n    // get dispatch somewhere, maybe through a component and pass it to this function\n  } catch(e) {\n    console.error(e)\n  }\n}\n\nasync/await is syntax that people may be aware of from other languages (e.g. C#)\nEverything works like \"plain\" js except \"awaiting\" functions\nI can call that function directly anywhere in my app right away without setting anything up\n\nI think that's why redux-saga has a higher learning curve than plain promises and async/await. It's a new API that's not quite anything developers have worked with before (yielding, using effects, forking, a lot of new terms to understand). Whereas async/await is just two keywords that help you use promises in a cleaner way. Not really much extra to understand or configure.\nthat said, I really love redux-saga and all the power it gives. I think it's certainly worth the learning-curve in many cases, but I figured I would try to outline the ways in which I think it's hard for new users.\nRealizing this issue was closed a year ago, I should probably get back to fixing the bug I was looking for in the first place :P cheers. ",
    "alankar-anand": "Here's a way to use async await inside a generator function. stackoverflow. I have used async await inside Redux saga. Here's the question on stackoverflow. Both can co-exist if someone wants to use it that way.. ",
    "danenania": "@Andarist node 10 has support for async generator functions, meaning we can now use both await and yield inside the same function, however it appears that take/takeLatest/et al do not correctly dispatch to async generators.\nI was wondering if there's something fundamental preventing this? It would be nice to be able to choose between the two approaches on a case-by-case basis, especially when using TypeScript, since await allows for type safety while yield does not.. ",
    "insonifi": "I do understand that. But it does, when I replace call with fork.\nHere's what I call:\nexport default function* () {\n  yield call(api.getStatusNoAuth); //which is Promise wrapped XHR call\n}\nAnd that's one of forked sagas\n```\nfunction runSyncNodeAndHealth() {\n  const syncNodesAndHealthSaga = yield fork(syncNodesAndHealth);\n  yield take(actions.NODE_SYNC_STOP);\n  yield cancel(syncNodesAndHealthSaga);\n}\n\u2026\nfunction syncNodesAndHealth() {\n  while (looping) {\n    yield* getAllNodesHealth(); //calls fetch for each node\nyield call(delay, SYNC_INTERVAL);\n\n}\n}\n\u2026\nexport default function* () {\n  \u2026\n  yield fork(takeLatest, actions.HEALTH_REQUEST, getAllNodesHealth);\n  yield fork(takeLatest, actions.NODE_SYNC_START, runSyncNodeAndHealth);\n  \u2026\n}\n``\n. I do understand that. But it does, when I replacecallwithfork`.\nHere's what I call:\nexport default function* () {\n  yield call(api.getStatusNoAuth); //which is Promise wrapped XHR call\n}\nAnd that's one of forked sagas\n```\nfunction runSyncNodeAndHealth() {\n  const syncNodesAndHealthSaga = yield fork(syncNodesAndHealth);\n  yield take(actions.NODE_SYNC_STOP);\n  yield cancel(syncNodesAndHealthSaga);\n}\n\u2026\nfunction syncNodesAndHealth() {\n  while (looping) {\n    yield* getAllNodesHealth(); //calls fetch for each node\nyield call(delay, SYNC_INTERVAL);\n\n}\n}\n\u2026\nexport default function () {\n  \u2026\n  yield fork(takeLatest, actions.HEALTH_REQUEST, getAllNodesHealth);\n  yield fork(takeLatest, actions.NODE_SYNC_START, runSyncNodeAndHealth);\n  \u2026\n}\n``\n. > I don't think having multiple takeLatest in one generator is going to work the way you are expecting. Generallytake` need to be inside their own generators in a 1:1 mapping.\nI'm not sure I'm getting that. What do you mean by \"own generators\"? How I can achieve that?\nDo I need to fork dedicated generator with single takeLatest like that?\n```\nfunction* subscribe() {\n  yield fork(takeLatest, pattern, callback);\n}\nfunction* () {\n  yield fork(subscribe);\n}\n```\nIt is const looping = true; all over the place.\nI found an example in this repository. Is it what you're talking about?\nexport default function* root() {\n  yield all([\n    fork(watchNavigate),\n    fork(watchLoadUserPage),\n    fork(watchLoadRepoPage),\n    fork(watchLoadMoreStarred),\n    fork(watchLoadMoreStargazers)\n  ])\n}. > I don't think having multiple takeLatest in one generator is going to work the way you are expecting. Generally take* need to be inside their own generators in a 1:1 mapping.\nI'm not sure I'm getting that. What do you mean by \"own generators\"? How I can achieve that?\nDo I need to fork dedicated generator with single takeLatest like that?\n```\nfunction* subscribe() {\n  yield fork(takeLatest, pattern, callback);\n}\nfunction* () {\n  yield fork(subscribe);\n}\n```\nIt is const looping = true; all over the place.\nI found an example in this repository. Is it what you're talking about?\nexport default function* root() {\n  yield all([\n    fork(watchNavigate),\n    fork(watchLoadUserPage),\n    fork(watchLoadRepoPage),\n    fork(watchLoadMoreStarred),\n    fork(watchLoadMoreStargazers)\n  ])\n}. I figured what's wrong. According to documentation Troubleshooting, saga will miss any action when it's blocked (e.g. by call). It seems that what's happening because, if I trigger manual action sagas continue to work as expected.. I figured what's wrong. According to documentation Troubleshooting, saga will miss any action when it's blocked (e.g. by call). It seems that what's happening because, if I trigger manual action sagas continue to work as expected.. ",
    "phuongpt": "hi @Andarist, I've just updated snippet. fetchMessages of that code will run only one time. The below code works well, but I can't use it because I need to raise Actions.fetchMessagesSuccess when data be changed\n```\nexport function* watchFetchMessages() {\n  while (true) {\n    const {data} = yield take(Types.FETCH_MESSAGES_REQUEST)\n    const channel = yield call(chatFetchMessages, data)\n    const messages = yield take(channel);\n    yield  put(Actions.fetchMessagesSuccess(messages))\n  }\n}\nfunction * fetchMessages(data) {\n  try {\n    const ref = firebase.database().ref(messages/${data.channelId})\nconst channel = eventChannel(emit => {\n  ref.on('value', snapshot => {\n    emit(snapshot.val());\n  });\n  return () => ref.off();\n});\nreturn channel;\n\n} catch (e) {\n  } \n}\n. I think it's quite same this one https://github.com/redux-saga/redux-saga/issues/587 , \nI want to listen the changing in\nref.on('value', snapshot => {\n        emit(snapshot.val());\n});\nto call `yield put(Actions.fetchMessagesSuccess(messages))`. @Andarist it works for watching the changes, but also causes the main issue is I can't open another channel, this means can't call `createChannel` twice.. well, let me conclude this one like this:\n1. can watch the changes, but can't fire twice\nfunction createChannel(data) {\n  return eventChannel(emit => {\n    setTimeout(()=>{\n      emit('message' + data);\n    })\n    return () => {};\n  });\n}\nfunction* observeSuccesses() {\n  const {data} = yield take(Types.FETCH_MESSAGES_REQUEST)\n  const channel = createChannel(data);\n  while(true) {\n    const message = yield take(channel);\n    console.log(message);\n  }\n}\n2. can fire multiple times, but can't watch the changes\nfunction* observeSuccesses() {\n  while(true) {\n    const {data} = yield take(Types.FETCH_MESSAGES_REQUEST)\n    const channel = createChannel(data);\n    const message = yield take(channel);\n    console.log(message);\n  }\n}\n```. thanks @Andarist. I just want to fetch messages from channelIds and watch them. \nBasically it should like your snippet, but this solution doesn't work for watching the changes, sorry.. this is great, almost solved my problem! I deeply appreciate your thoughtfulness @Andarist.. ",
    "cosmosof": "I want user to get automated props change from redux, how I supposed to trigger function* observeSuccesses() ?  I didn't get this listener concept right? I did wrote a few saga functions and all triggered competent level triggers, like button, componentDidMount etc. \nI supposed to get database path changes, without any user effort, how can I do it? like user gets follow request on foregrounded app, it will pop up right there through saga listening channels. @Andarist \n  . this my other sagas:\nexport default function * root () {\n  yield [\n    takeLatest(StartupTypes.STARTUP, startup),\n    takeLatest(LoginTypes.LOGIN_REQUEST, login),\n    takeLatest(SignupTypes.SIGNUP_REQUEST, signup),\n    takeLatest(QuestionsTypes.SAVE_ANSWERS, answer),\n    takeLatest(HomeScreenTypes.SAVE_TOKEN, savetoken),\n    takeLatest(HomeScreenTypes.SAVE_REQUEST, savetokentodb),\n  ]\n}\nall connected to an action. where does my new  event listener function* observeSuccesses() sagas goes. \nI understand listener saga is different than those above. \nhttp://developingthoughts.co.uk/live-data-with-firebase-and-redux-saga/\n\n. For the record, I am just adding my working code here.\nThe difficulty here was listener saga runs, before  this completed: const userId = firebase.auth().currentUser.uid;  So I have to make updatedItemSaga wait for userId. \nexport default function * root () {\n  yield [\n    takeLatest(StartupTypes.STARTUP, startup),\n    takeLatest(LoginTypes.LOGIN_REQUEST, login),\n    takeLatest(SignupTypes.SIGNUP_REQUEST, signup),\n    takeLatest(QuestionsTypes.SAVE_ANSWERS, answer),\n    takeLatest(HomeScreenTypes.SAVE_TOKEN, savetoken),\n    takeLatest(HomeScreenTypes.SAVE_REQUEST, savetokentodb),\n    fork(updatedItemSaga)\n  ]\n}\n``\nfunction createChannel (userId) {\n    const ref = firebase.database().ref(/matchrequest/${userId}/`)\n    const channel = eventChannel(emit => {\n        ref.on('value', snapshot => {\n          emit(Object.keys(snapshot.val())[0]);\n        });\n        return () => ref.off();\n      })  \n    return channel; \n  };\nexport function * updatedItemSaga () {\n    function connect() {\n      return new Promise(resolve => {\n        firebase.auth().onAuthStateChanged(function (user) {\n          if (user) {\n            resolve(user.uid)\n          } else {\n            reject(console.log)\n          }\n        })\n      });\n    }\nconst userId = yield call(connect);\n\nconst channel = createChannel(userId);\nwhile(true) {\n  const item = yield take(channel);\n  yield put(HomeScreenActions.invitationSuccessed(item));\n}\n\n} \n```\nThank you @Andarist good staff. ",
    "piuccio": "cool that works, thank you. ",
    "Kdoherty11": "I had mismatched redux-saga versions between my apps. ",
    "joetidee": "Thank you - have upgraded and error now gone.. ",
    "klaygomes": "Remove while(true). And remove or change (...) put({type: \"MEBER_FOLLOW_ACTION\"}) (..) \nBecause each time you yield this effect it will be caught by takeEvery again, causing an endless loop. ",
    "bitcoinporn": "Didn't work, i tried it before...\n. solved....\nThank you all for your help. ",
    "Viral-Inc": "Yup: macOS Sierra 10.12.5, npm: 4.2.0, node 7.10.0. @Andarist I tried to a little bit but there were too many things involved that I don't know enough about, yet :(\n[I'm having fun with redux-saga now anyway - I'll just hope my issue with the examples was an anomaly.]. ",
    "ed-zm": "You wont see data available with console.log because it is asynchronous. The function waits for the yield call and pass the result to the next yield. So, in other words your function runs the console.log before the response is ready. ",
    "alburdette619": "@jimbol Thx!  I don't see anything about that in the release notes except maybe this item:\nall effect - explicit effect for parallel effects, which is exactly what we had been supporting by accepting yielded arrays, so the latter is become deprecated now in favor of this explicitness which nicely maps to the Promise.all API. Please use this from now on\nBut that doesn't explicitly say it.  Either way thx again.. @Andarist sorry, that is pretty explicit. I knew less of what I was talking about then.. Your changelog was plenty extensive, you can close this issue. Thanks!. ",
    "chrisnojima": "Ok so I think I found one root cause of this issue for us. \nIf you do\n```\nfunction * myGenerator(params) {\n  yield []\n}\nyield call(myGenerator, myParams)\n```\nThe docs say\n\nIf the result is not an Iterator object nor a Promise, the middleware will immediately return that value back to the saga, so that it can resume its execution synchronously.\n\nSo there's some ambiguity here. I intended this to be a value but it gets interpreted as an array of generators (i assume).\nInstead, if you actually do\nyield Promise.resolve([])\nThen it does work fine.. ",
    "joaolavoier-luizalabs": "I've fixed all my code. But I still receiving the same log. \nYellowBox.js:80 [...effects] has been deprecated in favor of all([...effects]), \nplease update your code \nBefore it was\n``` js\nfunction* fetchExampleOne() {\n  yield call(api.fetchExampleOne());\n}\nfunction* fetchExampleTwo() {\n  yield call(api.fetchExampleTwo());\n}\nconst  mySagas = [\n    takeLatest(actions.FETCH_EXAMPLE_ONE, fetchExampleOne);\n    takeLatest(actions.FETCH_EXAMPLE_TWO, fetchExampleTwo);\n ];\nexport default function* rootSaga() {\n  yield all([\n    ...mySagas,\n  ]);\n}\n```\nTo\n``` js\nfunction* fetchExampleOne() {\n  yield call(api.fetchExampleOne());\n}\nfunction* mySagaOne() {\n  yield takeLatest(actions.FETCH_EXAMPLE_ONE, fetchExampleOne);\n}\nfunction* fetchExampleTwo() {\n  yield call(api.fetchExampleTwo());\n}\nfunction* mySagaTwo() {\n  yield takeLatest(actions.FETCH_EXAMPLE_TWO, fetchExampleTwo);\n}\nexport default function* rootSaga() {\n  yield all([\n    fork(mySagaOne),\n    fork(mySagaTwo),\n  ]);\n}\n```\n. ",
    "nalekberov": "Thanks everyone for your time and effort!. ",
    "doortts": "@ghoshnirmalya I think you are confusing the core concept of Redux. Action creator should know payload and required state which is needed to change state. So, you must create a payload with the necessary state to create an action. \n. I think you should have written this way.\nexport function getBlogs(project) {\n  return (dispatch) => {\n    ...\n    // ....\n  };\n}\nIs there any reason to pass getState and get project in the action creator file?. @ghoshnirmalya : ) well, then, how about pass state itself with payload? In fact, I have never tried but technically it will (maybe) work . ",
    "ghoshnirmalya": "Yes. That's true. But, in redux-thunk, I can do something like:\n```\nexport function getBlogs() {\n  return (dispatch, getState) => {\n    const project = getState().project.get('project'); // this would get the project state\n// ....\n\n};\n}\n```\nIs this possible to do in redux-saga?. @doortts @Andarist thank you for your reply. I just didn't want to pass the project object as an argument to the getBlogs function as I wondered if there was any easy way (not an overkill process) of getting the state inside the getBlogs function.\nIf I've to pass it like @doortts suggested, then this issue can be closed.. Just to mention before closing that what @doortts specified in https://github.com/redux-saga/redux-saga/issues/1002#issuecomment-304441705, works fine!. ",
    "maala": "export const ActionCreator = () => async (dispatch , state) => {\n          console.log(state()) ;\n} ;\nsimply pass second parameter to the actionCreator and you will access store state . ",
    "ashik94vc": "the saga version I'm using is 0.15.3.\n```\ntry {\n        const payload = yield call(Api.fetchTickets);\n        yield put(ticketFetchSucceeded(payload));\n    } catch(error) {\n        yield put(ticketFetchFailed());\n    }\nAssume that the component has a <TouchableNativeFeedback/> which ain't supported in iOS. The error should be thrown but not the messed up one react throws. \n. I literally got close to pinpointing to the exact location where the problem arose. I'm quite busy now, but will try to narrow down to the place where this gets fuzzy and will try to attach it. . ",
    "drdaeman": "Got the same behavior today, with redux-saga 0.15.4, and the web version of the React. I was renaming a variable in my component's render method and missed one. So, extremely oversimplified, my code was like this:\n@connect(\n  state => ({}),\n  dispatch => {fetchData: dispatch({type: \"FETCH_FOO\"})}\n)\nclass Foo extends React.Component {\n  constructor(props) {\n    super(props)\n    props.fetchData()\n  }\n\n  render() {\n    return <Bar baz={noSuchVariable.uhhh} />  // Here is where it actually failed\n  }\n}\n\nHowever, the exception was long \"uncaught at rootSaga render@http.........\". I was a bit confused, as I've also touched my reducers at the same time, so it took me some time to notice the render and recognize it's where it really crashes.\nThere was a saga running:\nfunction* watchFetchFoo() {\n  while (true) {\n    try {\n      yield take('FETCH_FOO')\n      const data = yield call(() => fetch('/api/foo/').then(res => res.json()))\n      yield put({type: 'FETCH_FOO_SUCCESS', payload: data})\n    } catch (e) {\n      console.log(\"Error in watchFetchFoo\", e)  // No errors were reported here\n    }\n  }\n}\n\nAnd an extremely boring reducer that just did return state.set('foos', fromJS(action.payload)) on FETCH_FOO_SUCCESS.\nBut no exceptions happened inside it (I've specifically added try...catch to make sure of this), and rootSaga was essentially just yield all([watchFetchFoo()]) - I've commented out all the other sagas I've used.\nIt's not exactly a reproducible case - the code I wrote above is untested oversimplification of the one I have in a real project, but I hope it can be converted into one and help diagnosing this further.. ",
    "dvakatsiienko": "+1 on this. We started the migration to Flow two weeks ago. Would be awesome to have 0.15.3 support since 0.15.3 contains some new features that are missing in 0.13.*. We actually would like to help on this, but we don't really have a lot of experience writing libdefs since we started to get in touch with Flow not so long ago. We are researching actively there is not so much rich information on the Internets at the moment of being. Please share if you have any materials about writing libdefs. . @neighborhood999 Thank you!. ",
    "TomiS": "I created a gist of 0.15.x types. I did it by modifying 0.13 types against my own project repository because I wasn't able to make flow-typed tests run correctly in reasonable time, so that's why it's not tested properly and might be incomplete.. @philipchmalts Hmm, could it be because Saga0 is now defined in root module and takeLatest/Every is defined in effects module... Weird it doesn't error in my repo.\nedit: I tried moving those SagaX declarations outside redux-saga root module and placed them before it and now flow cannot decide which case of the polymorphic type it wants to use. Need to investigate further.. @philipchmalts I think I managed to improve it a bit. See https://gist.github.com/TomiS/feabd0da885c4cf61065c258ef144ed8/revisions. ",
    "philipchmalts": "@TomiS just imported this into my own flow typings and I'm getting identifier 'Saga0' Could not resolve name as error, looks like it is used in takeEvery and takeLatest. @TomiS Thanks for taking a look at this and getting back to me, it appears the error I mentioned earlier is now gone but now I am getting itentifier FsmIterator cannot not resolve name. I think its a similar issue of scoping redux-saga/effects.. ",
    "bananatranada": "Disregard - looks like it was my misunderstanding of saga helpers. Thanks for the clarification!. ",
    "jimmoy": "Thanks for your response. I may be reading the documentation incorrectly, it appears to me that it doesn't matter whether the argument of the call() is a normal function or a generator, the handling of a Promise should be the same:\n\nfn can be either a normal or a Generator function.\n\nAnd in the third paragraph after:\n\nIf the result is a Promise, the middleware will suspend the Generator until the Promise is resolved, in which case the Generator is resumed with the resolved value. or until the Promise is rejected, in which case an error is thrown inside the Generator.\n\nBut in any event, knowing now how it actually works, I will refactor my code such that it is using a normal function. I have not taken the time to read the redux-saga code, so thanks for clarification about what is really happening :-)\n. Yup, whatever direction you see appropriate, I'll be able to move with.. ",
    "IceOnFire": "You're absolutely right, this works as expected! Maybe we should update the docs accordingly, would you like me to do it?. You're absolutely right, this works as expected! Maybe we should update the docs accordingly, would you like me to do it?. Incoming PR ;). Incoming PR ;). @Andarist Fixes to the docs should be pushed to the gh-pages branch to be effectively published, is there a best practice we should follow?. @Andarist Fixes to the docs should be pushed to the gh-pages branch to be effectively published, is there a best practice we should follow?. By having a look in the package.json I found a docs:publish script. If that's the way you use to publish docs then I have no better suggestions :). By having a look in the package.json I found a docs:publish script. If that's the way you use to publish docs then I have no better suggestions :). ",
    "matthiasprieth": "Maybe it's also related to this issue: https://github.com/redux-saga/redux-saga/issues/1004. Unfortunately I dont have a public repo, but I uploaded an old version where I have the same problem.\nhttps://github.com/matthiasprieth/redux-saga-uncaught-problem\nWould be awesome if you could check it out. Cause I'm still having the same problem since hours. After starting the react-native app 'click' on the STOREBOX APP-button then on LoginScreen and then on Sign In. Normaly you should see the message NORMAL LOGIN FAILED wrong user data etc. above the input fields, but instead I get the Uncaught error as described above.. I guess the first thing you need is:\n- the latest JDK, Android SDK and setting ANDROID_HOME environment variable (https://facebook.github.io/react-native/releases/0.23/docs/android-setup.html)\n- install react-native: npm install -g react-native-cli\n- build and run app: react-native run-android . My reactotron-redux-saga is at v1.11.1 so latest. hm.. maybe I understand something wrong, but when I yield call(AsyncStorage.setItem('@AppLocalStorage:token', token)) i get Error: call: argument [object Object] is not a function so the AsyncStorage was always fine for me before. I had no problem with that.. ",
    "Thomas080304": "@Andarist, thanks for your help. i add \"es3ify\",\"babel-polyfill\",\"es5-shim\",\"es5-shim/es5-sham\",still not work.\nwhat is suggestion for babel transform for redux-saga?. ",
    "chromakode": "Thanks much for the detailed reply!\nI share your concern that unlimited buffers could lead to different kinds of failure modes, like putting faster than taking. I think that this kind of failure is easier to figure out than dropping events due to a full buffer, which in my experience can work fine in dev and then show up when an app gets overloaded by a surge of activity.\nA compromise might be to set the default buffer size very high so that runaway cases can be caught (similar to a stack overflow). I believe that the memory impact of initializing the empty arrays will be negligible. Perhaps the default size could be something like 4096. What do you think?. ",
    "j-wang": "Just to check, this still means that eventChannel is by default unbuffered, as per the documentation?. Just to check, this still means that eventChannel is by default unbuffered, as per the documentation?. We're on RN 0.51.0 and and redux-saga 1.0.0-beta.0 and we're not having a problem with takeLatest/takeEvery running.\nOne headache we are running into (which might be worth a separate issue) is that saga crashes DO kill all takeXs, but happen silently on production. A guess is maybe it's either not having version 1 of redux-saga or maybe something's silently killing sagas on release?. We're on RN 0.51.0 and and redux-saga 1.0.0-beta.0 and we're not having a problem with takeLatest/takeEvery running.\nOne headache we are running into (which might be worth a separate issue) is that saga crashes DO kill all takeXs, but happen silently on production. A guess is maybe it's either not having version 1 of redux-saga or maybe something's silently killing sagas on release?. @Andarist Let me see if I can put together a minimum case, but just to clarify, I think the behavior I'm trying to describe is what you're describing right now?\nIt's silent in the sense that what would be a \"red screen\" in debug becomes nothing at all in production/release (as such, nothing that relies on sagas because the whole tree / root saga is dead... but the app itself is still running). \nThis has bitten me at least more than a few times, since I don't expect sagas to just be gone and I don't have code handling that. If you have a suggestion for how to handle it\u2014even forcing an overall app crash\u2014I'd love to know. Also, happy to continue this in another issue if it's drifted far afield of the original subject. I just figured that it might be what @ianhowe76 might have encountered, since it sounds similar to some of my own confusion when I ran across it. \n==========\nActually, poking around, I actually just came across this:\nhttps://github.com/redux-saga/redux-saga/issues/570\nSo I guess this was expected behavior and I just didn't realize it in my mental model. I think I was essentially assuming some magic in the root saga with takeEvery/takeLatest. On our side, we've just added a generator that wraps the root saga and restarts it on crash (based on our use case).\nAnyway, sorry for derailing with this particular theory on this, if it isn't the cause.. @Andarist Let me see if I can put together a minimum case, but just to clarify, I think the behavior I'm trying to describe is what you're describing right now?\nIt's silent in the sense that what would be a \"red screen\" in debug becomes nothing at all in production/release (as such, nothing that relies on sagas because the whole tree / root saga is dead... but the app itself is still running). \nThis has bitten me at least more than a few times, since I don't expect sagas to just be gone and I don't have code handling that. If you have a suggestion for how to handle it\u2014even forcing an overall app crash\u2014I'd love to know. Also, happy to continue this in another issue if it's drifted far afield of the original subject. I just figured that it might be what @ianhowe76 might have encountered, since it sounds similar to some of my own confusion when I ran across it. \n==========\nActually, poking around, I actually just came across this:\nhttps://github.com/redux-saga/redux-saga/issues/570\nSo I guess this was expected behavior and I just didn't realize it in my mental model. I think I was essentially assuming some magic in the root saga with takeEvery/takeLatest. On our side, we've just added a generator that wraps the root saga and restarts it on crash (based on our use case).\nAnyway, sorry for derailing with this particular theory on this, if it isn't the cause.. I suppose my original expectation here was closer to redux-observable and React Native itself, where \"red screens\" cause the entire app to crash. That would allow us to enter a known state again, in the sense that an unhandled exception causes the entire app to crash. It was just unexpected that exceptions would leave the app in place, but remove sagas.\nAnd yeah, definitely agree it should be on a case-by-case basis. In our case, sagas handles \"reloading\" of state from disk\u2014which means a crash-restart would be equivalent to a React Native refresh (reloading bundle only). Given that model of behavior was explicit from the start, it's fairly safe in our case, but that wouldn't be the case universally. We also are pretty careful with it with that \"infinite crash loop\" in mind\u2014we have error reporting attached to the restarting catch so we'd see if we're getting a bunch of saga crashes, even if they don't literally crash the app.. I suppose my original expectation here was closer to redux-observable and React Native itself, where \"red screens\" cause the entire app to crash. That would allow us to enter a known state again, in the sense that an unhandled exception causes the entire app to crash. It was just unexpected that exceptions would leave the app in place, but remove sagas.\nAnd yeah, definitely agree it should be on a case-by-case basis. In our case, sagas handles \"reloading\" of state from disk\u2014which means a crash-restart would be equivalent to a React Native refresh (reloading bundle only). Given that model of behavior was explicit from the start, it's fairly safe in our case, but that wouldn't be the case universally. We also are pretty careful with it with that \"infinite crash loop\" in mind\u2014we have error reporting attached to the restarting catch so we'd see if we're getting a bunch of saga crashes, even if they don't literally crash the app.. ",
    "mpyw": "However, I also think it should be limited by user interface disabling rather than saga.\nhtml\n<button disabled={state.pending}>Submit</button>. ",
    "jpetitcolas": "We also need the takeFirst effect. Adding the logic on the component may be a good idea in some cases, yet it adds some complexity on components, which can be easily removed using this new effect. . ",
    "letharion": "Leaving the issue open so a maintainer can decide if anything needs to be done, but as far as I'm concerned, it can be closed as is. :). @aikoven Looking at the documention again it says\n\nThe default library injected is: \n\u25ba For --target ES5: DOM,ES5,ScriptHost\n\u25ba For --target ES6: DOM,ES6,DOM.Iterable,ScriptHost\n\nSo if you're targetting ES6, it's on by default, but if you're targetting ES5, then it's not.\nNot sure what the difference is between the DOM.iterable that is included by default and ES2015.iterable that I included to solve my issue, but I confirmed on my config that if I strip out all lib settings, I get the error with a es5 target, and no error with a es6 target.. ",
    "rplotkin": "This is NOT easy to find. Can it not at least be mentioned in the typings file?. ",
    "sarovin": "yes,  it is called many times...if i use console.log it work as aspected. The problem is the buffers https://github.com/redux-saga/redux-saga/tree/master/docs/api#buffers.\nWith buffers.expanding() i have fixed the problem ;)\n. ",
    "asfktz": "Oh, I see now!\nI didn't realized that iterator.next needs to be called with products.\nIt makes a lot of sense.\nThanks, @Andarist . ",
    "dannsam": "@aikoven thanks, I like it! The PR is updated.. ",
    "stefensuhat": "@Andarist yield put.resolve(fetchMenu) solve my problems perfectly!.\n\npersonally I would make a request saga which would include ur jwt token logic\n\ncan you lights me up more about this so it can run for every request I made to the server?\nThanks man!. @Andarist thanks for the help!. I'm gonna try this out. will close this. . ",
    "AlexisChevalier": "You are right, the issue is related to https://github.com/facebook/react-native/issues/9436. I just tried without the remote debugger and the saga works perfectly. Sorry for the unrelated issue.\nI have also tried to plug in sagaMonitor, unfortunately my attempt was unsuccessful, I encountered the issue mentioned here https://github.com/redux-saga/redux-saga-devtools/issues/13 and another one due to the use of the race effect, I will open another issue on the corresponding repository with more details.\nThanks for your help !. ",
    "ivanakimov": "@Andarist thank you for responding.\nYeah, sorry I made it sound all complicating. To answer your questions: yes, you're basically right.\nThe issue is: this component has multiple ways it can load a page (there's many UI parameters -- black shoes, blue shoes, small shoes, large shoes, etc). So my state looks something like this:\njson\nrequests: {\n  \"/v1/page/get?color=blue\": {\n    \"loading\": true,\n    \"loaded\": false,\n    \"error\": null\n  },\n  \"/v1/page/get?color=black\": {\n    \"loading\": false,\n    \"loaded\": true,\n    \"error\": null\n  },\n  \"/v1/page/get?color=blue&size=large\": {\n    \"loading\": false,\n    \"loaded\": true,\n    \"error\": null\n  }\n}\nThe way I made it work was to call a function like this: dispatch(loadPage({ color: \"black\", size: \"large\" })), so the component is not aware of the key in the state (eg: /v1/page/get?color=black&size=large) because the saga is the one composing that key, not the component.\nTherefore, the component can't really check the state directly. I could theoretically just \"re-create\" the loading/not-loading flags in the component itself, but then I'll have two places where these flags are kept.\nDo I have the wrong strategy for this?. Ok. Yeah, that's true, the key composition code could be extracted. The problem is that code is in asynchronous sagas (it uses select for a few parameters), so I'm not sure yet how to extract it properly so that it could be in synchronous functions that component calls.\nAlright, I'll keep thinking. Thanks for your feedback.. @Andarist ok, thanks for following up. Let me try to show the basics in a simple way:\nIn component:\njavascript\nimport { loadItems } from '../../redux/actions';\n...\ncomponentDidMount() {\n  ...\n  dispatch(loadItems(page, color, size, weight));\n}\nThen it creates an action (which is watched), which then triggers another action.\nNow in that saga:\njavascript\nfunction* sagaLoadItems(action) {\n  const params = {\n    page: action.page,\n    color: action.color,\n    size: action.size,\n    weight: action.weight\n  };\n  const { response, error } = yield fetch(items.get, params);\n}\nThe items.get looks something like this:\njavascript\nconst items = {\n  get: function*() {\n    const site = yield select(getSelectedSite);\n    return {\n      method: 'GET',\n      route: `/v1/items/${site}/get`\n    };\n  }\n}\nAnd the fetch is my own generator wrapper that a) forms the proper url from parameters b) does the call to the API and c) puts the proper values in the requests state (loading, loaded, etc).\nSeeing as how items.get + the wrapper are the ones \"assembling\" the URL with params (and they're generator functions), I am not sure how I can write a regular isLoading() function that \"assembles\" a proper URL given params and then checks the state.... Ok, thank you for looking @Andarist :). ",
    "GuyMichael": "Thx for the detailed reply.\nThe actual problem I'm trying to solve is that React-Router (v4) doesn't have a prop to 'do something' once that route is used. So when I go into some page/screen/component as a result of routing, I don't have a callback that tells me 'this page/screen/component is starting'. If I had one, I would've dispatched an action to trigger the saga..\nTo be more detailed, if that is not clear enough:\n1. There is some data loading once the app loads (fetched inside my main saga).\n    Talking about the example above, it may be 'fetchAllCities' (cities would contain shopes..)\n2. I have a page inside the app (a Component, clearly).\n    This screen may be entered from two entry points: \n    a. User clicks on a button on the main page\n    b. User pasts a URL to the browser, linking/routing directly to this page (React-Route v4).\n3. As a result of this page being routed to, I'd want to fetch 'storesAroundLocation' from the example\n   above (location could be the city's center for example).\n-> So, trying to solve the case of 2a, I could assume (don't want to though) that the\n   initial data is already in the store (result of 'fetchAllCities' in our example) and just\n   put a fetch call in the componentDidMount callback.\n   * However, this will fail on 2b, as the initial data would probably still be loading.\n   ** I could delay the whole rendering of that inner page, but I don't want to (product/ux requirements).\n      I'd better have the static parts loaded, and the 'cities' shown once fetched.\n-> Trying to solve the case of 2b, I would use saga to listen for the initial data 'fetched' action,\n    and then load the 'storesAroundLocation', which will trigger a re-render.\n    * However, this will ignore case 2a, meaning that this whole data will be loaded, even if the user\n      will never click on that button (I want lazy loading, depending on entering this page)\nSo far, the only 'clean' solution I found was the one described above.\nI'm SURE there is a good solution, as I'm SURE 90% of react/redux apps need something like this.\nI'm probably just too new to this:)\nThank you! Waiting for some suggestions:)\n. Can you please explain how it is different from using saga's takeEvery() ? Or direct me to a doc paper?\nThx!. ",
    "odarino": "@Andarist thanks for your response but can you explain this ? because I'm new in React/saga\nSpecify this: \n```\n// other saga\nconst chan = yield actionChannel('delete', buffers.expanding())\nwhile (true) {\n    const action = yield take(chan)\n    yield call(delete, action)\n}\n```. ",
    "rafatwork": "Sorry for the late response.\nI eventually figured out what the issue was. Code was perfectly fine. My project is using redux-persist (https://github.com/rt2zz/redux-persist) together with redux-action-buffer (https://github.com/rt2zz/redux-action-buffer). Apparently the latter one has an open issue about the order of dispatched actions not (always) being adhered (https://github.com/rt2zz/redux-action-buffer/issues/12).. ",
    "Shaikabbu": "Hi,\nwe are using JSforce lib for connecting Salesforce API from React application.\nUsing Redux-saga as middleware.\nhere come problem,\nwhen we are calling connect.login(its async method) taking sometime to complete action. below is code snippet\n  console.log(\"signInValidation\");\n      var conn = new jsforce.Connection({\n     oauth2 : {\n       loginUrl : salesforceconfig.OAUTH_TOKEN_URL,\n       clientId : salesforceconfig.CLIENT_ID,\n       clientSecret : salesforceconfig.CLIENT_SECRET,\n       redirectUri :salesforceconfig.REDIRECT_URI\n    }\n   });\n\n    Working\n var promise= conn.login(credentials.email,credentials.password);\n     promise.then(function()\n     {\n            yield put(saveOauth('success')); \n     })\n .catch(error => {\n       console.log(error);\n       yield put(signUserIn(error));\n     })\n\nbefore completing above codeblock its coming out\n. ",
    "tamal-appsbee": "@Andarist  thanks for the reply.\nI want to update 'userIds' array. So in saga it should unsubscribe users those are not exist in updated 'userIds' array. Also subscribe the new 'userIds' to fb listeners.\nabove in component.js  'userIds' = ['abc', 'cde', 'xyz'] // array of firebase keys in 'user' path.\n. ok. \nis it possible to move following section to saga ?\n```\n userIds.forEach((e)=> { \n        this.props.initListner(e.key); // trigger INIT_USER_FB action\n      });\n```. ",
    "wtgtybhertgeghgtwtg": "Something like\n``\n// store.js\nconst enhancer = sagaEnhancer();\n// enhancer addsrunSaga` property to store.\nconst store = createStore(reducer, enhancer);\n// somewhereThatHasAccessToStoreAndWillDynamicallyRegisterASaga.js\nstore.runSaga(mySaga);\nI am not sure how that conversation relates, so I might be missing something.. And here's a sample implementation I've been using\nimport {emitter} from 'redux-saga/lib/internal/channel';\nimport {runSaga} from 'redux-saga/lib/internal/runSaga';\nimport {ident} from 'redux-saga/lib/internal/utils';\nexport default function sagaEnhancer({context = {}, ...options} = {}) {\n  const {sagaMonitor, logger, onError} = options;\n  // Validation removed for brevity.\n  return createStore => (reducer, preloadedState, enhancer) => {\n    const store = createStore(reducer, preloadedState, enhancer);\n    const {dispatch, getState} = store;\n    const sagaEmitter = emitter();\n    sagaEmitter.emit = (options.emitter || ident)(sagaEmitter.emit);\n    const run = runSaga.bind(null, {\n      context,\n      subscribe: sagaEmitter.subscribe,\n      dispatch,\n      getState,\n      sagaMonitor,\n      logger,\n      onError,\n    });\n    const newDispatch = action => {\n      const result = dispatch(action);\n      sagaEmitter.emit(action);\n      return result;\n    };\n    const setContext = props => {\n      Object.assign(context, props);\n    };\n    return {...store, dispatch: newDispatch, runSaga: run, setContext};\n  };\n}\n```. If this looks okay, I can file a PR or something.. It doesn't mutate the store object, though.  It returns an enhanced store.. >Also I'm not sure how this is intended to work with other middleware.\nSame way you'd do it for any other store enhancer\nconst store = createStore(\n  reducer,\n  compose(\n    applyMiddleware(otherMiddleware),\n    sagaEnhancer(),\n  ),\n);. > by being more explicit we force users to compose this behaviour on their stores however they want and its only a few lines of code anyway\nHow else would they want to do it?  It's just boilerplate that amounts to the same thing.\n\nIt could also potentially mess with people's TS/flow types.\n\nAs long as the store enhancer returns a valid StoreCreator, nothing changes.\n\nit will now not be possible to implement a gate keeper middleware checking users permission levels in a way that the 'blocked' action would be skipped and would not hit the sagas.\n\nSure it is\nconst store = createStore(\n  reducer,\n  compose(\n    // Wraps dispatch from `sagaEnhancer`.\n    applyMiddleware(gatekeeperMiddleware),\n    // Wraps original dispatch.\n    sagaEnhancer(),\n  ),\n);. > By spreading this responsibility between middlewares and enhancers we lose ordering flexibility, cause they cannot intermit each other.\nThey're synchronous, they're not supposed to intermit in the first place.  If you mean ordering them however you please, that's still possible\nconst store = createStore(\n  reducer,\n  compose(\n    // Wraps dispatch from `sagaEnhancer`.\n    applyMiddleware(gatekeeperMiddleware),\n    // Wraps dispatch from `applyMiddleware(someOtherMiddleware)`\n    sagaEnhancer(),\n    // Wraps original dispatch.\n    applyMiddleware(someOtherMiddleware),\n  ),\n);. ",
    "marcindobry": "Thanks for the answer, it did work. Sorry for creating an issue but I couldn't find any answer to it for 2 days and thought it actually might be something wrong.. ",
    "camflan": "Is takeLatest supposed to work with channels? I've haven't seen this before and there are no tests or documentation written about this. If it's supposed to be supported, we should add tests and documentation too.. I'm open to working on this. I have Travis.ci working on my fork. Can someone else confirm that redux-saga currently has 1 failing test: TypeScript files compile against definitions. @Andarist you got it -- I'm trying to debug the bundlesize part of this. I have it running locally using the travis-ci docker file, but it fails on travis-ci.org itself. I'll submit another pull once I have this working as well \ud83d\udc4d\nlet me know if you need assistance getting it hooked up to the org repo. I couldn't do this because I'm not part of redux-saga.\n. nvm, you got it already :). \ud83d\udc4d \n. ",
    "denysonique": "I think it would be very nice if Saga docs become available on the offline app http://devdocs.io. They have a contributing guide https://github.com/Thibaut/devdocs/wiki/Adding-documentations-to-DevDocs.\nIn my free time I might add the docs unless someone will be quicker than me.. ",
    "Rokt33r": "Yes, types will break after yield. But, we know they are not any and can be specific typed value because we are using redux-saga.\nI've seen lots of mistakes like this in my company. That's the reason why I came here.. What I expected is: \nts\nconst {\n  someValueOfRepo,\n  anotherValueOfRepo\n}: Repository = yield call<Repository>(Repository.add, name)\n\nIf Repository.add doesn't return an instance of Repository anymore, it will blame.\nIf anotherValueOfRepo is removed from Repository, It will blame too.. @Andarist How can I track the changes for v1?. @andarist I also confirmed, It doesn't exist there.\n\nsh\n 07/24|10:44:42 | ~/Code/mano>> npm ls redux-saga\nmano@0.2.0 /Users/junyoungchoi/Code/mano\n\u2514\u2500\u2500 redux-saga@0.15.5. @Andarist Yea, it exists. I tried to find it with typo. :dizzy_face::dizzy_face:\n. @Andarist Could you tell me ETA? I really need this! \ud83d\ude08 \ud83d\ude08 . @Andarist I really appreciate it. You saved me! \ud83d\ude09 . Like this?\n```ts\nexport interface Put {\n  (action: A): PutEffect;\n  (channel: Channel, action: T | END): ChannelPutEffect;\nresolve(action: A): PutEffect;\n  resolve(channel: Channel, action: T | END): ChannelPutEffect;\n/\n   * @deprecated\n   */\n  sync(action: A): PutEffect;\n  /\n   * @deprecated\n   */\n  sync(channel: Channel, action: T | END): ChannelPutEffect;\n}\n```. ",
    "grovesNL": "When is v1.0? This would be useful.. When is v1.0? This would be useful.. ",
    "FourwingsY": "I met same error with this type error\nBut it was my fault.\nI was trying to use function that wraps and create some saga like this\nfunction createSaga() {\n  return function*() {...}\n}\nbut I did some mistype like this\nfunction* createSaga() {\n        ^\n  return function*() {...}\n}\nI hope some of mistakes could be solved by this.. Hmm, testing with whole effects?\nI wanted to test each actions called... How do you think, this approach is not necessary?. actually, my test code is grouped by worker sagas\njavascript\ndescribe('someSaga', () => {\n  const someGenerator = someSaga()\n  it('test someSaga', () => {...})\n  // ...\n  it('should be forked by watcherSaga', () => {\n    const watchAll = watcherSaga()\n    const allDescriptor = watchAll.next().value\n    const effects = allDescriptor['ALL']\n    expect(effects).toContainEqual(takeEvery(action, someSaga))\n  })\n})\ndo you think this fork test could be replaced by testing watcher saga?. ",
    "minkyu-yi": "Oh, Thank you! I realized What I was confused about.\nIn short, I did not want to cancel takeLatest task but just the worker in progress.\nCould you advise again ?? Thank you.. Thanks again for your comment :). ",
    "NoPPT": "~~thanks, I solved this problem by changing the react-native version to 0.45.1, but i don't know why~~. ~~thanks, I solved this problem by changing the react-native version to 0.45.1, but i don't know why~~. @Noitidart i'm so sorry that my reply misled you. I was constantly changing the version and sometimes it worked, so I thought the revision would solve the problem. Later I found that the modified version to 0.45.1 didn't really solve the problem, finally I used redux-thunk to replace redux-saga.. @Noitidart i'm so sorry that my reply misled you. I was constantly changing the version and sometimes it worked, so I thought the revision would solve the problem. Later I found that the modified version to 0.45.1 didn't really solve the problem, finally I used redux-thunk to replace redux-saga.. ",
    "Noitidart": "I am having this same problem but in RN 0.47.1. @NoPPT are you sure a simple upgrade to 0.45.1 fixed this?. @Andarist  @NoPPT - this is the issue to following along - https://github.com/facebook/react-native/issues/14838#issuecomment-321274943\nUpgrading to 0.45.1 could not possibly have been the fix. Must have downgraded babel preset or something.\nOr you switched to using const = before the generators.. No problem sir, thank you for that. I just wanted to add the correction here because when I searched this is the first thing that came up on search engines. To help others.. A sincere thanks @jimbol for your reply! Is there no possible built in way? Like with put.resolve? I tried put.resolve but couldn't find a solution.. Thanks very much for this explanation! Ok I will go with this :). Thank you very much Andarist for that note!. ",
    "germanattanasio": "Running\nnpm install regenerator-runtime\nAnd adding \nimport 'regenerator-runtime/runtime';\nSolved my issue.. ",
    "iMagdy": "Just go back to a state where the app was working, check package-lock.json file, and make sure that package.json file match the same versions.. ",
    "KrishnanAnil": "@neurosnap Thanks. I removed try catch and some commented codes. \nWhat I have is say a list of folders, each has list of canvases. I want to call the api to get me list of updated canvases for each folder. I tried to do that using a map (which is not working). \nWhen I just have the for loop it works. From what I have read it says that map does it in parallel, hence wanted that to work. :( . @neurosnap @Andarist Thanks guys. That did the trick. . You probably forgot to import all.. ",
    "Techno-than": "Hi I am getting runtime error that 'all is undefined', my code is like this - \nconst res = yield call(getRootDir, param1);\nconst FoldersWithDirs = yield **all**(res.map(res => {\n      return {\n        ...res,\n        dirs: call(Api.getSubFolders, res.id, res.param)\n      }\n  }));\nAnything wrong above code?. ",
    "alaPing": "Could you have a look my code, please?\nI want to create function as follows:\n1. accept argument files and repeat a ~ c process\n  a. download each file\n  b. get property each file\n  c. return object\n3. return array of object\n```javascript\n// fileDownload and getProperty are defined. \n// download a file -> get its property -> return\nfunction* loop(fileId) {\n  yield call(fileDownload, fileId);\n  const property = yield call(getProperty, fileId);\n  return {\n    id: fileId,\n    ...property,\n  };\n}\nexport function* normalizeFileData(files) {\n  return yield all(files.map(file => loop(file.id)));\n}\n```. @neurosnap\nOh... thank you very much!\nI have solved this problem.\n@shinima\nThank you for your rapid response!\nYour questions help me to organize my mind.. ",
    "kajas90": "You have few options with redux-saga, you can fork generator with a little delay and cancel ongoing task if action was dispatched second time. You can also use takeLatest helper. From my experience, cancel will help you a lot with avoid unnecessary requests :). ",
    "steezeburger": "Why don't you dispatch FETCH_USER_SUCCESS when you receive your user then do something like\n// fetches profiles\nfunction* fetchProfile() {\n  yield put({ type: FETCH_PROFILE });\n}\n// in your main sagas\nyield takeLatest(FETCH_USER_SUCCESS, fetchProfile);. Why don't you dispatch FETCH_USER_SUCCESS when you receive your user then do something like\n// fetches profiles\nfunction* fetchProfile() {\n  yield put({ type: FETCH_PROFILE });\n}\n// in your main sagas\nyield takeLatest(FETCH_USER_SUCCESS, fetchProfile);. ",
    "djskinner": "Are you refering to the cancellation example here: https://github.com/redux-saga/redux-saga/blob/master/docs/advanced/Channels.md#using-the-eventchannel-factory-to-connect-to-external-events?\nI'm trying to create an eventEmitter which can be cancelled by an action. I'm struggling to understand how the example works though. If the code is already within the finally block then surely the eventEmitter has already finished. So how does cancellation work in this code? Perhaps it's just my lack of understanding!. Ok I've seen the full example here https://github.com/redux-saga/redux-saga/blob/master/examples/cancellable-counter/src/sagas/index.js.\nIt makes more sense now. Perhaps the docs should include the code for the race.. The example code clarified everything thanks. ",
    "stevenmusumeche": "Thank you! I saw them in the code but couldn't find them in the release :). @Andarist I actually get the same error with 0.15.5. I can silence it like this, but it's not ideal.\ndeclare module 'redux-saga/utils' {\n    var cloneableGenerator: (foo: any) => any;\n}. Actually, it is there and is working for me now.. Thanks! Redux-saga-test-plan seems to be the best of the options available.. ",
    "flyjennyetn": "@Andarist    Is still the same problem\npackage.json\n      \"react\": \"16.0.0-alpha.12\",\n    \"react-native\": \"^0.46.4\",\n    \"react-redux\": \"^5.0.5\",\n    \"redux\": \"^3.7.2\",\n    \"redux-actions\": \"^2.2.1\",\n    \"redux-saga\": \"^0.15.5\",\n    \"regenerator-runtime\": \"^0.10.5\"\nindex.js\nimport React , { Component } from 'react';\nimport {Navigator,View,Text,StatusBar, Platform} from 'react-native';\nimport {createStore,applyMiddleware} from 'redux';\nimport {Provider } from 'react-redux';\nimport createSagaMiddleware from 'redux-saga';\nimport 'regenerator-runtime/runtime';\nimport ReducersManager from './js/reducers/';\nimport SagaManager from './js/sagas/';\nimport Route from './js/route';\nsaga/home.js\nimport 'regenerator-runtime/runtime';\nimport { fork,takeLatest } from 'redux-saga/effects'\nfunction* coursesQuery() {\n}\nfunction* watchCourses() {\n    yield takeLatest('courses/query', coursesQuery);\n}\nexport default function*() {\n    yield fork(watchCourses);\n}\n. @Andarist \n\n  . @Andarist   https://github.com/flyjennyetn/test/tree/master/jiagou. @Andarist   react-native run-android   \nit runs index.android.js   . @Andarist    You mean react-native issue ?     Good thank you. @Andarist  yes       @Jeepeng  thank\n. ",
    "Jeepeng": "\ndowngraded babel-preset-react-native form 2.1.0 to 2.0.0\nnpm run start -- --reset-cache. \n",
    "pranit123": "Facing the same issue. @Andarist's fix did not work. ",
    "mammosu": "I changed like\nfunction* rootSaga() {\n  ...\n}\nexport default rootSaga;\nto\nconst rootSaga = function* rootSaga() {\n  ...\n}\nexport default rootSaga;\nthen I resolved .. I changed like\nfunction* rootSaga() {\n  ...\n}\nexport default rootSaga;\nto\nconst rootSaga = function* rootSaga() {\n  ...\n}\nexport default rootSaga;\nthen I resolved .. @Andarist That makes sense. Thank you!. @Andarist That makes sense. Thank you!. ",
    "URvesh109": "export const saveLocation = (params) => async (dispatch) => {\n    const {lat, lng} = params;\n    dispatch({\n        type: types.LOCATION_SUCCESS,\n        payload: {location: params},\n    });\n    try {\n        await API. post(urls.nearBy, {\n            latitude: lat,\n            longitude: lng,\n        });\n    } catch (e) {\n        utils.log(e);\n    }\n};\nI have simple function saveLocation in which I send params and make post request. How to achieve same in redux-saga\n. thanks linesh. ",
    "linesh-simplicity": "```js\nexport function* saveLocation() {\n  while (true) {\n    const action = yield take(actions.saveLocation)\n    const { lat, lng } = action.payload.params \nyield put({ type: types.LOCATION_SUCCESS, payload: { location: params } })\ntry {\n  yield call(Api.post, urls.nearBy, { latitude: lat, longitude: lng })\n} catch (e) {\n  yield call(utils.log, e)\n}\n\n} \n}\n```\nor utilise the takeEvery function provided by saga to remove the while (true) in your business saga: \n```js\nexport function* saveLocationSaga(action) {\n  const { lat, lng } = action.payload.params \nyield put({ type: types.LOCATION_SUCCESS, payload: { location: params } })\n  try {\n    yield call(Api.post, urls.nearBy, { latitude: lat, longitude: lng })\n  } catch (e) {\n    yield call(utils.log, e)\n  }\n}\nexport function* saveLocationSagaTaker() {\n  yield takeEvery(actions.saveLocation, saveLocationSaga)\n}\n```\ncorrect me if I miss something.. ",
    "PedroFerr": "Thanks @linesh... simplicity! That's it!. ",
    "r3dcrosse": "@Andarist I would like to take on this issue please!. Submitted a pull request with the favicon. I used the logo provided in the redux-saga repo and scaled it down to the appropriate sizes. \nI could not get the favicon to update using the same method in the redux docs:build script. However, using the favicon plugin referenced by @erikvold worked effortlessly. \nThe favicon looks like this (using chrome here): \n\nI'm open to any suggestions or changes, please let me know what you think! \n. ",
    "ethanroday": "@Andarist Is that something specific to setInterval(), or are you saying that's just the nature of any async source of events (like, say, an Observable)? So there's no way to have the saga handle errors which originate in the channel?. Hm okay. Thanks for the explanation. In that case, it may be helpful to add something to the channel docs about error handling.. ",
    "sdd": "Thanks! Appreciate the feedback. I've refactored out the for/in and relaxed the checks so that non-generator functions can be used as middleware. Republished as 1.1.1. . Hi! is there anything preventing this link being merged in that I need to do?\nThanks. ",
    "LearningNerdd": "Hi @Andarist, \nThank you so much for sharing the details.\nBut my usecase is bit different.\nI wont be knowing the ids before\nconst results = yield all(action.payload.ids.map(id => call(fetchStudentId, id)))\nTo get the id, I am making use of the following function fetchStudentId which will be taking studentJoiningId as argument\n```\nexport function fetchStudentId(studentJoiningId) {\n  return (dispatch, getState) => {\nconst state = getState()\nblah\nblah\nblah\nconst student_data = {my required data ..., studentJoiningId}\nconst options = {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify(student_data),\n  mode: \"cors\",\n}\nreturn fetch(\"fvfcfgcfcfgc.fcfgcfc/yfcfcgcfg/hffgcfgccg\", options)\n  .then((json) => {\n    dispatch(randomFunction(json))\n    dispatch(fetchSudentDetails(json.student_id)\n  })\n  .catch((error) => {\n  })\n  }\n}\n``\nOnce I get the id fromfetchStudentIdfunction, using that id I need to callfetchStudentDetailsfunction\nBoth of the functions areasync.fetchStudentDetailsshould be called only afterfetchStudentId`.\nfetchStudentDetails should be called only after fetchStudentId ----> this process has to be run simultaneously for 10 student\nThe information which I have previously is 10 student's joining ids\nusing joining id, get student id, using student id get student details.\n. Awesome..\nSorry for the misunderstanding.\nI will implement this in my project and will let you know the update.\nJust some quick questions:-\n\nyield all(action.payload.ids.map(id => call(fetchStudentId, id))) will this wait for all the 10 async calls to be completely finised?\nif one call fails from 10 calls, what kind of status I will be getting from yield all call. As I need to revert the processs if any one f the async calls get failed?. Thank you @Andarist,\n\nI am going to implement this.. ",
    "thinhtrh": "@Andarist i have imported all, i don't know why, i will create new project and recheck. hope to work fine. @Andarist Do you see any problem on my code?. i created new project and it worked fine with that code :) i don't understand. ",
    "parse": "I am also struggling to find the origin of this deprecation as well. I have quite a few sagas, is there a way we can get some more info in terms of where the deprecation message is being triggered from?. ",
    "Minishlink": "Ran into this deprecation notice today with this, and I'm not sure if this is an intended behaviour:\njs\nconst obj = { a: [] };\nyield all(Object.values(obj));\nNote that it happens only if the value of obj.a is an array.. ",
    "seanyu4296": "Hi,\nI just read the documentation just today and haven't used redux-saga yet. From what i understand, the first code snippet you posted behaves like the \"takeEvery\", but it is not exactly the same. So it will always watch for an action \"NAVIGATE\", while the second code snippet will only watch for the first actions \"NAVIGATE\" then end the generator function.\nhttps://redux-saga.js.org/docs/advanced/FutureActions.html\nHope i helped. ",
    "souse": "thanks @Andarist  @seanyu4296 . yes i used react-router @Andarist . i know it, but how did u  get the push in ur saga fn ? @Andarist \nthe point is i do not know  how to import react-router-redux param into saga fn. i did it,  but it don't work.   @Andarist   can u make example for me\n```javascript\n    // saga fn\n    import { push } from 'react-router-redux'\n     // fn\n    ...\n    yield put(push('/route'))\n    ...\n```. here is my example demo. it redirected to person page  because i maked it. \nin the Login component eg.\ni think if u remove the code below, it willn't redirected anymore.\n```javascript\ncomponentWillReceiveProps(nextProps) {\n        const { user } = nextProps.auth\n        const keys = Object.keys(user)\n    console.log('user', user)\n    if (keys.length != 0) {\n        this.context.router.replace('/person')\n    }\n}\n\n```\ni have add u to the collaborators\n. thanks. ",
    "samuelcastro": "Wound't be better just use takeEvery rather than the while(true) ?\ncc: @seanyu4296 @Andarist. nvm, I found the answer here: https://github.com/redux-saga/redux-saga/issues/684. Awesome, that's what I was looking for!\nThanks @shinima . ",
    "vzaramel": "I guess the right way to use the react-route-redux API is to use the push method on history. \n```\nimport { history } from '../store/configureStore'\nfunction* authorize(user) {\n    try{\n        const token = yield call(Api.authorize, user)\n    yield put({ type: 'LOGIN_SUCCESS', user: token })\n    yield call(history.push, '/person')\n}catch(error) {\n    console.log(error)\n    yield put({ type: 'LOGIN_ERROR', error})\n}\n\n}\n```. In his example he is using a old version of react-router and react-router-redux.\nI updated both libs everything worked just fine.\nhttps://github.com/vzaramel/redux-saga-demo. ",
    "eungchang": "`import { fork, call, take, put, takeEvery } from 'redux-saga/effects'\nimport { actionTypes, actions } from '../redux_reducers_ducks/ducks_study.js'\nimport * as api from '../redux_sagas_services/api_study.js';\n//worker saga\nfunction* getBookContent(action) {\n    try {\n        const response = yield call(api.getBookContent, action.payload);\n        //handle api success\n        if(response.status === 200) {\n            yield put(actions.wordlist_success(response));        \n        }\n        else if(response.status === 204) {\n            //yield put(actions.needtomakeschedule());\n        }\n}\ncatch(error) {\n    //handle api fail\n    yield put(actions.wordlist_failure(error));\n}\n\n}\nfunction* updateStudyDay(action) {\n    try {\n        const response = yield call(api.updateStudyDay, action.payload);\n        //handle api success\n        if(response.status === 200) {\n            yield put(actions.updatestudyday_success(response));          \n        }\n}\ncatch(error) {\n    //handle api fail\n    console.log('updateStudyDay is Error!!!');\n    console.log(error);\n    //yield put(actions.updatestudyday_failure(error));\n}\n\n}\n//watcher saga\nfunction* watching_GetBookContent() {\n    yield takeEvery(actionTypes.WORDLIST_REQUEST, getBookContent);  \n}\nfunction* watching_UpdateStudyDay() {\n    yield takeEvery(actionTypes.UPDATESTUDYDAY_REQUEST, updateStudyDay);    \n}\n//root saga \nexport default function* rootSaga() {\n    yield fork(watching_GetBookContent);\n    yield fork(watching_UpdateStudyDay);\n}\n\nthis is my saga code\ni guess,\n1. user do not anything  so ,  server decide to logout user\n2. user click  any button which dispatch action,  server return response ( redirect to login page )\n3.  saga take server's redirect response  as an action's response \n4. so , saved login html page to redux state\nthis is problem to me.\nfor your understanding, \ni have two page app. first one is login html page. second one is webapp html page.\n. i wrote about that  in the middle of my first comment.\n i make it short cause that is too long to upload here. \nresponse is whole login html page.\nand that whole login html page is saved  at data of action.payload\ndata: \"\u21b5\u21b5\u21b5\u21b5<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /\u21b5\"\nand whole html page saved as redux state value.\n. thanks !  i will try to do that way. ",
    "thales-gaddini": "This seems connected to redux-saga because if I just dispatch the push action in the component it works as expected. The second push is only needed when I'm using it inside the saga generator function. What doesn't make sense to me is why would it work after the second push.\nJust to be sure, at least this part seems correct to you right?\nfunction* mySaga(action) {\n  const result = yield call(api.fetchSomething, action.uid);\n  yield put(fetchSomethingSuccess(result));\n  yield put(push('/something'));\n}\nI'll try to look into it a bit more. Thanks anyway :). ",
    "akinnee": "Ok, thanks!. You mean like this? https://github.com/redux-saga/redux-saga/blob/dfc38612e71f6e1a53c8aeda37dcb3799096408a/examples/sagaMonitor/index.js\nThanks.. We figured out that we were just missing a log. When creating the middleware, an onError function must be provided.\ncreateSagaMiddleware({\n    onError,\n    emitter,\n  });\nOnce we added that it was just a simple console log.\nconst onError = (err) => {\n    console.error(err);\n  };. ",
    "JamyGolden": "Thanks @Andarist!. ",
    "pongponglau": "@Andarist \nOnly console.log('fetch data') is found. Does it mean there is problem with fetch ob Android?\nThanks a lot. Very strange. fetch did return, however, it never jumps into then() or catch().\nlet result = fetch(url)\nconsole.log(JSON.stringify(result))\nIt just prints out integer hash.\nDO you have any idea?\nThanks alot. You are right. I try fetch somewhere else in my RN project (outside saga).  The same issue is found. Thus, i believe there is problem with fetch on android with RN 0.47.1 but there is no problem on iOS. I have reported this issue to React Native and hope they have a fix on it soon.\nThank you for your help. ",
    "hiroto78": "Hi, there!\nIt had already fixed? If you know anything about this, please let me know. \nThank you.\n. ",
    "nicolashardy": "Same issue. I know this is closed, but if @hiroto78 or @pongponglau have any answers... :D. ",
    "nhducit": "currently we can use yield fork(call, fn) instead of yield fork(() => call(fn)) to avoid this bug. How about yield fork(takeEvery, 'pattern', fn)? Do we have any workaround solution?\n. ",
    "lega0208": "Sorry if this isn't an appropriate thread to ask, but it's on-topic and I figured it was better than to post another issue.\nI'm refactoring a project to use redux-saga and so far it's simplified thing a lot. I appreciate all the work you guys are doing on this. However, I'm having some issues now.\nI think my issues are stemming from what you're talking about here. The problem is, I don't know what not to do. The solution above of \"Just don't use any of those\" may seem obvious to you if you're familiar with the codebase, but to someone like me who 1. isn't that experienced, and 2. isn't familiar with the code base, this isn't obvious at all.\n@shinima mentions above that we should avoid using call/fork/takeEvery at the same time, but obviously we need to use all of these for different reasons. So in what specific situations should you not use them at the same time? Also how are we supposed to properly nest our effects?\nFor example this is how I've structured my sagas:\n\nMy rootSaga yields an all() effect with an array of all my top-level \"watchers\", each wrapped in a fork(). If I understand correctly (I probably don't), I should fork them all so that they can all watch for actions in parallel.\nMy top-level \"watchers\" watch for actions for each of my pages.\nMy page \"watchers\" yield an all() with an array of all my \"watchers\" for the specific page, again wrapped with fork()s.\nThose watchers then implement the while (true) -> yield take(pattern) -> yield call()/fork()/put() pattern.\n\nDoes that make any sense? Or is this a good example of how not to structure your sagas?\nIf this isn't right, how would you suggest structuring them? (Maybe a \"Structuring sagas\" section could be added to the docs?)\nThanks for your time! Not just for reading/answering my question but for also for building this fantastic tool for all of us. It really is appreciated, you guys are the best.\n(Also, sorry if you got multiple notifications from me posting, IE11 doesn't play well with github and so trying to add a line break resulted in me posting prematurely. Gotta love having to use outdated technologies.). @Andarist Thank you for the clarification (and the ridiculously fast reply). I feel stupid now because I just read on the releases page that we shouldn't ask questions on here. And then at the same time finding out that there were new releases with better error handling, and the babel plugin which helps with that too. Had I already implemented those I probably wouldn't even have needed to ask a question.\nSorry for wasting your time, hopefully I'll eventually find the time to contribute to the project to make up for it! (Assuming I wouldn't be more of a burden than anything). ",
    "kumar303": "I don't know anything about the implementation but what about this:\n\nA saga starts up called categoriesSaga()\nit registers takeLatest('FETCH_CATEGORIES', handleCategoryFetch())\nthe application dispatches END which causes categoriesSaga() to stop running\nthe application accidentally dispatches 'FETCH_CATEGORIES' after that\nredux-saga logs a warning: \"'FETCH_CATEGORIES' was dispatched but categoriesSaga() is no longer running\"\n\nIf that's not possible hopefully it at least illustrates the idea I had to make these kind of bugs easier to track down.. ",
    "qpre": "Hey @jimbol sorry, it's a typo in the example, Im editing it.. Hey @jimbol sorry, it's a typo in the example, Im editing it.. Thanks @Andarist ! solved it for me !. Thanks @Andarist ! solved it for me !. ",
    "dantenovski": "Also I wanted to do it this way:\njavascript\nfunction* fetchUser(action) {\n   try {\n      const user = yield call(Api.fetchUser, action.payload.userId);\n      yield put({type: \"USER_FETCH_SUCCEEDED\", user: user});\n   } catch (e) {\n      yield put({type: \"USER_FETCH_FAILED\", message: e.message});\n   }\n}\nBut I don't know how Api.fetchUser should be constructed. Thank you! But it prints NaN and upon inspection it turns out to be the Promise object.\nconst data = response.json();\n    console.log(data); // prints \"1\" <- actually prints Promis object. I got help and the suggested code is like this (I will wrap it in try/catch):\n``javascript\nfunction * fetchIncrement () {\n  const response = yield call(\n    fetch,url`\n  );\n  const data = yield call([response, response.json])\nconst number = parseInt(data)\n  console.log(const number below);\n  console.log(number)\n  return number\nAnd it works but I don't fully understand how this one works:\nconst data = yield call([response, response.json])\n```\nWe pass in the returned Promise object and also a function that will convert [[PromiseValue]] into json?. @sgal Thanks a lot! Finally it is clear why we have to use two calls. In the examples I found online there is only one call(fetch, url) and it returns a value, and that's why I've been struggling with it, I couldn't make it work. Now when you said that response.json() also returns a Promise it is clear why we have to make another yield call. Thanks again!. Thank you guys! Actually the problem was that I made fetchIncrement() a generator function by mistake, it supposed to be a regular function that returns a promise, so in that case there is no need for the second call i.e. call([ ]). Thanks Andarist for spotting it!. Tried with fetch again and encoded data differently and then it worked\n```javascript\nfunction sendData(data) {\n  const { loginEmail, loginPwd } = request.payload;\n  const body = { loginEmail, loginPwd };\n  var urlEncodedData = \"\";\n  var urlEncodedDataPairs = [];\n  var name;\nfor(name in body) {\n    urlEncodedDataPairs.push(encodeURIComponent(name) + '=' + encodeURIComponent(body[name]));\n  }\n  urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');\nvar httpHeaders = { \n    'Content-Type' : 'application/x-www-form-urlencoded', \n    'Accept' : 'application/json'\n  }\nlet postOptions = {\n    method: 'post',\n    headers: new Headers(httpHeaders),\n    /mode: 'no-cors',/\n    body: urlEncodedData\n  };\ntry {\n    const response = yield call(fetch, http://www.makeafriend.club/register, postOptions);\n    const data = yield call([response, response.json]);\n    console.log(data returned by fetch);\n    console.log(data);\n    yield put({type: 'LOGIN_SUBMIT_RESPONSE', payload: data.message})\n  } catch (e) {\n    console.log(error fetch post object);\n  }\n}\n```. ",
    "sgal": "@dantenovski Here's how you can do fetchUser example (simplified)\n// userApi.js\nexport const fetchUser = (userId) => fetch(`http://mywebsite.com/user/${userId}`);\nDepends on what your user endpoint returns, you may want to do response.json() or any other transformations, before putting an action (see example below).\nFirst example can be fixed by using yield instead of promise's then() as well as try/catch instead of promise's catch().\n```\nfunction* fetchIncrement(){\n  try {\n    const response = yield call(fetch, 'http://www.haha.com/fetch_increment');\n    const data = response.json();\n    console.log(data); // prints \"1\"\n    return parseInt(data, 10); // explicitly set radix\n  } catch (e) {\n    console.log(e);\n    return null; // good to return something here\n  }\n}\nexport function* incrementAsync(){\n  let fetchResult = yield call(fetchIncrement);\n  if (fetchResult === null) { // some error handling as well\n    yield put({type: \"INCREMENT_COUNT_ERROR\", payload: \"Cannot increment the value\"});\n    return;\n  }\n  console.log(fetchResult); // logs 1 (parsed from \"1\")\n  yield put({type: 'INCREMENT_COUNT', payload: fetchResult}) // payload is 1 (number)\n}\n``. @dantenovski Ah, sorry, forgot thatresponse.json()` also returns promise.\nAs for your question - it is simply calling a function with specific context. See here\nSo, your example can be explained like this.\n```\nconst json = yield call([response, response.json]); // response is context here\n// same as\nconst json = yield call([response, \"json\"]);\n```\nresponse is not a promise, but rather the value that fetch promise is resolved with. But response.json() returns promise. To wait for it to be resolved we use call effect. That combined with yield waits for promise returned by response.json() to be resolved (or rejected).. ",
    "unionthugface": "I have been trying to follow this example, but I keep getting an error on the yield call([resp, resp.json]) part. I get body stream already read.  Can anyone assist with this?. Here is a solution using async/await.  These would be considered \"saga utilities\":\n```\nimport { call, put } from 'redux-saga/effects'\nasync function fetchJson(url) {\n    let resp;\n    try {\n        let data = await fetch(url);\n        resp = { data: await data.json() };\n    }\n    catch (e) {\n        resp = { err: e.message };\n    }\n    return resp;\n}\nexport function* fetchApi(path, successAction, failureAction) {\n    try {\n        const { data, err } = yield call(fetchJson, //${baseApiUrl}${path});\n        if (!!data)\n            yield put({ type: successAction, data });\n        else\n            yield put({ type: failureAction, ...err.message });\n    }\n    catch (e) {\n        yield put({ type: failureAction, message: e.message });\n    }\n}\n```\nAnd this would be in use:\n```\nfunction* fetchPayRates() {\n    yield call(fetchApi, 'rate/mpr', PAY_RATES_FETCH_SUCCEEDED, PAY_RATES_FETCH_FAILED);\n}\n```. ",
    "aJoohongKim": "since this is one of top search result from google. I am leaving my solution.\njavascript\nfunction fetchIncrement(){\n// return fetch({}).then().catch()\nreturn fetch({\n  method: 'get',\n  url: 'http://www.haha.com/fetch_increment'\n})\n  .then(res => res.json())\n  .catch(err=> err);\n}\n. ",
    "goshakkk": "Oh right, the duplicate calls were a leftover that I thought I've removed.\nI agree that wrapping in yield call makes sense. I fixed both of these now. <3. ",
    "harlandjp": "Apologies. I was using throttle the wrong way. Should be \n```\nfunction* requestSuggestSaga(action) {\n  const payload = action.payload;\n  const result = yield call(api.getSearch, payload.keyword);\n}\nfunction* watchSuggestSaga() {\n  yield throttle(100, action.REQUEST, requestSuggestSaga);\n}\nexport default function* () {\n  yield [\n    call(watchSuggestSaga),\n  ];\n}\n```. ",
    "muzidx": "@Andarist thanks, some late. I got it and solved this problem.. ",
    "ygorlf": "Yes, All the items are coming from the firebase, but the emit is happening only for the 1st item. I set up a webpackbin link with the issue, I don't know why but redux-saga is not working properly on webpackbin but when I download the repo and run locally works perfectly, in the console it's printed 4 items but only the 1st is dispatched to redux :(\nhttps://www.webpackbin.com/bins/-KstpbNrGSjKADpQtC4w. thank's, works perfectly :). ",
    "khoaanh2212": "would you like to tell me more about of what is advantage of cancel watcher?\nalmost of watcher need to use all the time because data is need to refresh.So i need your advice in this case,cancel or not cancel saga watcher.. For now,i'm following route structure of react boilerplate.Would you like to help me to understand how to cancel temporary watcher?Thanks.. ",
    "jankalfus": "Ah, right :) I'm not sure how the internals work (it's not really important for the test), but it totally makes sense. Haven't looked at it that way. So I guess we can go with your proposal :). I was just unsure what does the middleware pass as a value to the generator. I know that in case of the fork effect, it's a Task object. But I don't think I've seen in the docs what gets passed after yielding the take effect. Thanks so much for explaining! It's all clear to me now. . ",
    "ianhowe76": "Also from the docs: https://redux-saga.js.org/docs/advanced/Testing.html. Pass in the mock data to the next call\ne.g. \nit('it should return the details of the fetched user', () => {\n  const response = {\n    data: { token: 'abcdefg' },\n  };\n    expect(test1.next(data).value).toEqual(put({ type: actionTypes.SIGN_IN_SUCCESS, user: undefined }));\n}). ",
    "Hauuguu": "Quick question. Before you would do\n``\nconst winner = yield race({\n  someFunctionResult: call(someFunction),\n  cancelAction: take('ACTION_WHICH_SHOULD_STOP_EXECUTING_SOME_FUNCTION\n});\nif (winner.someFunctionResult){\n  [...do something here...]\n}\n```\nHow would this work in your proposed method @klis87 ?\nAnd has a PR been submitted for this already?. Great, thanks! Looking forward to it :). ",
    "alexeybondarenko": "@bradennapier thank you for the solution. I've found another one way. Task.done is a promise so I can wait for its resolve.\nhttps://github.com/redux-saga/redux-saga/blob/master/examples/real-world/server.js#L59. @bradennapier ahh, sorry) thank you! \ud83d\udc4d . ",
    "eromoe": "That write code in seprated function , I prefer the all relative code in one function. \nSo I am writing a all in one function.  I have already used a fetch lib which return Promise. \nWhat I want to do is like below:\n``\nexport function* requestTags({corpusId}){\n  const url =${Config.api}/corpus/${corpusId}/tag`;\nyield yield apiGet({\n    url,\n    success: (result) => {\n      return put({type: REQUEST_TAGS_SUCCESSED, tags: result.get('tags') })\n    },\n    error: (result) => {\n      // case 1 :this would thorw an error. because no return\n      alert('error !!!!!!!!  ')\n      //  case2 : this would throw error because return is not generator\n      return  'OK'\n    }\n  })\n}\n```\nI perfer write apiGet like:\n```\nfunction* yieldWrapper(ret) {\n    yield ret\n}\nfunction yieldResult(ret) {\n    if (ret is saga object) {\n        return ret\n    } else {\n        return yieldWrapper(ret)\n    }\n}\nfunction apiGet({url, success, error}){\n ....\n\nconst handleResult = (result) => {\n\n    if (result.error) {\n        ret = error ? error(result) : defaultErrorHanler(result)\n    }\n    else if (success) {\n        ret = success(result)\n    }\n\n    return yieldResult(ret)\n\n}\n\nreturn fetch(url).then(checkResult).then(handleResult)\n\n}\n```\nThat's why I want to detect saga object.\n. ",
    "MaxSvargal": "() => SagaIterator does't work too.\nJust use any type =(. Looks like i need more typings for other arguments of my sagas.\nOk, the clear example works well. Thanks for help!\nI just needed\nfunction* Saga(name: string, saga: (...args: any[]) => SagaIterator) {}. ",
    "RussianCow": "Awesome, thanks so much! No worries about the late response.. @Andarist I just updated redux-saga to 0.16.0 and I'm still getting the same issue, although only sometimes... Other times it works as I expect. I'm not sure what the pattern is, but I just got a stack trace today that looks like this:\n\nI can do some debugging on my end to figure out when/why it's not showing the error message, because it works correctly about half the time now; I just wanted to let you know and see if you were aware of the issue.. Hmm, interesting, I actually had no idea React had a Babel plugin for this. What you said about not wanting to deal with normalizing errors makes sense, so I'm in favor of the Babel plugin. I'm not sure what other information I would find useful besides the saga stack and source line numbers, so I'll have to think on that a bit. Thanks for the response!. @Andarist I've given this a fair bit of though, and while I don't disagree with the notion of not wanting to normalize error logging across browsers, I think the original, unmodified error has to be  thrown (or at least logged) along with whatever saga error. I think React does a good job of this in the latest version, where it first throws a React error with the component stack information, and then throws the original error immediately afterwards:\n\nWhat are your thoughts? Let me know if there's another, more specific issue for error logging in general.. I looked into it. For development, they just call console.error to log their own component error message (the one you see at the top of the screenshot above), but use an interesting approach involving a fake DOM node and a custom error event/handler to throw the original error synchronously in a way that plays nicely with browser dev tools and preserves the flow of execution. For redux-saga, that may be overkill initially and you could probably just use console.error on the original error as well, but I can see how React's solution would be pretty powerful since you could properly trigger a \"Pause on exceptions\" breakpoint via dev tools.\nEither way, for the time being, my suggestion would be to just log the saga error and original error back-to-back, so at least they both get printed to the console as intended, and you don't have to do any parsing at all of the error object. I can make that PR if you would like.. Ah okay, I didn't realize you changed this further on the master branch since 0.16.0. So then I guess there is no need for a PR in the short term. :) Having said that, I am interested in contributing to redux-saga's error handling, so I will play around with using React's approach and see if I can make it work for this library, and if I can, I will open a PR.\nThank you for your time! I love this library and would be happy to do whatever I can to help.. Just to clarify, you don't actually need a babel plugin in order to be able to log the current \"saga stack\", do you? Since you know which generator is currently running when a task is yielded, redux-saga could keep track of that tree at runtime, and it should be able to grab the current stack at any point. So the only benefit (that I can think of) to a babel plugin is that it could give you line numbers (and potentially other info) on the caller side. Am I wrong about that?\n(This is true of React as well\u2014it shows a component stack without the Babel plugin, you just don't get line numbers.). React gets around that via a __DEV__ flag, which I assume uses the process.env.NODE_ENV !== 'production' trick that most build tools support. I don't have any experience with Rollup, but I know Webpack, at least, supports inlining of that value, which creates statements like if (false) in production, which get removed via dead code elimination\u2014so in production, that code could be stripped out of the build completely. I'm afraid I don't know anything about how to set that up with Rollup, but the React repo might be a good example to use.. Aha! I hadn't thought of doing it that way, but that works. Looks like there is no solution for the general case, though? Not a huge deal, as you could create a generic wrapper function similar to this if you had to.\nThanks!. Sorry, I wasn't talking about cancellation specifically; I meant a general way to call a function that returns a Promise without also blocking on the Promise's resolution.. To clarify even further, if you wanted an arbitrary way to manipulate a returned Promise before blocking on it, you could create a wrapper like this:\nconst callWithUpdate = (updater, fn, ...args) => {\n  const newFn = (...args) => updater(fn(...args))\n  return call(newFn, ...args)\n}\n\nand then use it in your saga like this:\nconst update = request => {\n  request[CANCEL] = () => request.abort()\n  return request\n}\nyield callWithUpdate(update, makeApiRequest, ...args)\n\nThat example also may not be the best, because you can't properly test the first argument of call. (You could make it its own generator and yield* it, but you get the idea.) Either way, there is no built-in way to achieve the above without creating a wrapper, is that correct? I wonder if it would make sense to create a non-blocking version of call, something like call.nonBlocking, similar to how put.resolve is a different version of put? What do you think? I'm sure there are other use cases for manipulating or introspecting a Promise right after it's returned without waiting for it to resolve.. Yeah, my own use case is solved by making it cancellable within the wrapper, so I'm not sure if there is a strong use case for having a generic way to call without blocking\u2014I just thought I would bring it up. :) Having said that, I would be in favor of custom effects because I think it would allow for more elegant solutions to things like this, even if it doesn't make it into v1.\nI'll close this comment since you answered my original question. :) Thank you! I will comment on the issue you linked with my thoughts on a custom effects API.. ",
    "hansena": "@jgamao mind me asking what was the root cause of this?. ",
    "s-kem": "Do any of the objects you're passing to call contain functions?\nIf you see [Function anonymous] anywhere in the output that's likely where the differences lie (they're not the same instance of a function), so the visual comparison passes, but I think Jest is checking if you are pointing to the same anonymous function.\nJSON.stringify() on an object with functions strips the functions.\nex: \njs\nconst x = () => console.log('hi')\nconst y = { x }\nconsole.log(y) // prints { x: f }\nconsole.log(JSON.stringify(y)) // prints {}. Putting your cleanup code in its own generator and forking that in the finally block seems to do what you are wanting.\n```js\nfunction* cleanup() {\n  console.log('cleanup start')\nyield delay(2000)\n  console.log('cleanup end')\n}\nfunction* forkedSaga() {\n  try {\n    console.log('try')\nyield delay(2000)\n\n} catch (error) {\n    console.log('catch')\n  } finally {\n    yield fork(cleanup)\n  }\n}\n```\nClicking the saga action button followed by cancel action causes me to log\ntry\ncleanup start\nforkedSaga has been cancelled\ncleanup end. Ohh I see what you mean. Cancelling it while in cleanup causes cleanup to drop out as well, because cancels propagate down the chain. According to my understanding of cancel, this is expected behavior.\nYou could always use spawn to create a detached child instead of fork\nExample: https://codesandbox.io/s/94ykxojlrp\nHere hitting cancel while in the finally doesn't cause cleanup() to go away.\nAnother alternative is to write a separate saga that listens on a cancel action that will cancel the first and then run the asynchronous cleanup code. Disadvantage here is you don't know whether or not the saga is even running when you go to cancel it and run the cleanup code.\nHere's a fork showing what I mean:\nhttps://codesandbox.io/s/mq7075lzvx\nI added a SAGA_CANCEL action that fires the cleanupSaga that cancels forkedSaga and then forks cleanup. ",
    "swannknani": "You're experiencing this issue because jest cannot make the difference between 2 anonymous function.\nIn order to fix that, you'll need to provide a named function to you mock.\nBecause jest hoist mock declarations, you'll need to declare your named function inside your mock.\n```\njest.mock('../selectors', () => {\nfunction mockedMakeSelectCoverageResult() {}\nreturn ({\n    makeSelectCoverageResult: () => mockedMakeSelectCoverageResult,\n});\n\n});\nexpect(descriptor).toEqual(select(makeSelectCoverageResult()));\n```\n. ",
    "martlaboloa": "nope it does not, i did what you suggested(or at least i think i did), but cancelation while in finally seems to cancel task(cleanup) that you forked from there too, here is code, maybe i made mistake: https://codesandbox.io/s/z88k55njx\nyou might want to fork this sandbox and show me what you mean. ty. ",
    "tun100": "@neurosnap Thanks, I have use redux-thunk and redux-saga together for project. ",
    "ebardajiz": "The full code looks like this:\n```js\nimport request from 'superagent'\nimport { call, put, select , takeEvery } from 'redux-saga/effects'\nconst EXAMPLE_REQUEST = 'EXAMPLE_REQUEST'\nexport function* fetchExampleSaga({ payload: ids}) {\n  try {\n    const data = yield call(request.get, '/api/example')\n    yield put(example.success(data))\n  } catch (e) {\n    yield put(example.error(e))\n  }\n}\nexport function* networkListeners() {\n  yield takeEvery(EXAMPLE_REQUEST, fetchExampleSaga)\n}\n```. ",
    "djereg": "It is and old issue, but today I had the same error.\nThe solution was type hinting, the function argument(s), and there is no need for any workaround.\ntypescript\nexport function* fetchExampleSaga({ payload: ids}: AnyAction) {\n  // ...\n}\n. ",
    "robbyemmert": "I'm getting the same error also, only when I try to pass additional arguments into my sagas. I.e.\n```\nexport function authSaga(graphQL: GraphQLApi) {\n    yield takeLatest(LoginForm.ActionTypes.SUBMIT, function(action: StandardAction, graphQL: GraphQLApi) {\n}, graphQL)\n\n}\n```\nIf I remove the 'graphQL' argument, it works perfectly.. ",
    "charlax": "Still happening with latest version (1.0.2).\n\nI commented the channel-related types in @redux-saga/core/effects.d.ts\nGot the actual error Property 'payload' is missing in type 'Action<any>' but required in type\nI put AnyAction in the saga handler.\n\n```\nimport {AnyAction} from 'redux'\nfunction* uploadSaga({ payload: { file: f, files, folderID } }: AnyAction) {\n```. ",
    "Vpr99": "Just realized I can probably tackle this with yield all\n. ",
    "hyldmo": "Ah okay, my bad. Closing this.. ",
    "ethan520": "Thanks for the reply! Let me explain further on the issue I'm facing right now.\nI'm using ignite-native-base-boilerplate as my startup template. \nBelow is my actions, reducer & initial state of the PropertyRedux.js\n/ ------------- Types and Action Creators ------------- /\nconst { Types, Creators } = createActions({\n  submitData: ['propertyObject'],\n  updatedSuccess: ['data'],\n  updateFailure: ['error']\n})\nexport const PropertyDataTypes = Types\nexport default Creators\n/ ------------- Initial State ------------- /\nexport const INITIAL_STATE = Immutable({\n  propertyObject: {\n    property_address_1: \"F-5-17\",\n    property_address_2: \"IOI Boulevard\",\n  },\n  submitted: false\n})\n/ ------------- Reducers ------------- /\nexport const submitData = (state) => state.merge({...state, submitted: true, ...state.propertyObject})\n/ ------------- Hookup Reducers To Types ------------- /\n`\nexport const reducer = createReducer(INITIAL_STATE, {\n})\n`\nIn Property.js, I'm calling the savePressed() and dispatch it like below:\nsubmitPressed (data) {\n      this.props.savePressed(data)\n}\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    savePressed: (propertyObject) => dispatch(FormActions.submitData(propertyObject))\n  }\n}\nAfter I called the function, this error appears. Am I stated it in a more clear way? Let me know if you're still have any doubts. Thanks in advance.. @Andarist , thanks for your time on looking at my question. After i amended according your suggested code, the redux store failed to update. \nBut i managed to update the redux store with the below codes:\nexport const submitData = (state, action) => {\n  const { propertyObject } = action\n  return {...state, submitted: true, propertyObject}\n}\nBut getting this error after i after calling the submitData function.\n\nThis is my sagas submit function\n\nI'm so sorry if troubling you. Appreciate if could get some help from you. =D. After debugging and some trial & error, it seems like if you're implementing reduxsauce + redux saga, they have their own way in structuring the functions. After I changed the param's name of submit function in the sagas.js from 'data' (self-defined) to 'propertyObject' (defined in the redux previously), it's working right now. Thanks for the helps. Cheers. ",
    "rkmax": "the result is empty\nI think the issue are the another dependencies that requires as peer dependecy react ^15.0.0\nI'll close this one because it's related to my project dependencies. Thanks @neurosnap for you help. ",
    "vicwang163": "I have the same issue, after runing 'npm ls react', there is only one react version, but the error occurs again. ",
    "anshulsahni": "any update on this I'm facing same problem. I faced the issue while using v0.14.0 but I updated it to latest and the current version is v0.15.6 and it's working fine just the version update nothing else. Apologies for replying late.. ",
    "ortonomy": "Hi, @Andarist -- I want to provide a sample repository to you, but at the moment, I'm using redux-sagas in a private organization.\nI can say to you that we're on v 0.12.1.. ",
    "runchman": "Never mind, I just looked up the spread (...) syntax which I've never used before. Duh.. ",
    "NullVoxPopuli": "I'm gonna give this ago this weekend a think. https://nullvoxpopuli.github.io/tanqueReact/ could use some better async support :-). ",
    "stackninigi": "Here is a link: https://codesandbox.io/s/znzv935np3. @Andarist Ibelieve that the issue is that somehow my action isn't triggered and watcherSaga doesn't enter getData. Not sure why or how to fix it though. I did some changes to the code and they're on codesnadbox. Unfortunately, it's still failing.. @Andarist , apologies. I have never before used it. Can I give you access to my bitbucket repo instead? I have numerous dependencies and am not really sure how to include them in codesnadbox.. @Andarist, fixed it. It should be working now along with the store. . I am deeply sorry. Especially for lack of question; when writing it was obvious for me, but after re-reading, it's not. \nWhat I would like to have: I want to call action which will populate my store with some data. So, when calling actions.getFAQ.request I'd like to have saga call my API and using axios fetch the data and put it into Redux store. In FAQ.js (which is my component) I would like to have access to fetchData which is dispatched in FAQContainer.js. Also I'd like to have access to props which I mapped in mapStateToProps in FAQContainer.js\nWhat I have now: basically I'm doing mapStateToProps and mapDispatchToProps and then using connect to connect my FAQContainer.js with FAQ.js. But when I try to access my props they appear to be undefined. Also, redux store is unchanged. \nWhat I believe might be an issue: saga? Not sure if getData() in FAQSaga.js is called. I tried console logging it and debugging but it seems that it's not called. If not that, maybe there is some kind of issue with reducer since the state is not changed. \nAdditional questions: after my update, was the codesandbox still not working? I tested it and though that everything should be correct. But once again, sorry for the first time. I'll learn from my mistakes and apologize for your lost time. As for your changes; I believe they didn't really solve my issue. The props are still undefined. But maybe something in the logic itself is incorrect? . I tried clicking the button but I received typeError: this.props.fetchData() is not a function.. Yes, it works now, thank you. But I'm trying to find the places where I did mistakes and I'm failing. \nI can see the change in FAQ.js => postLoginData() {\n        console.log(this.props)\n        this.props.fetchData()\n    } and <button type=\"button\" onClick={this.postLoginData.bind(this)}>\n                    post\n                </button>\nAlso there are some changes in FAQsaga.js yield put(actions.getFAQ.success(data)) and yield put(actions.getFAQ.failure()). Am I missing any other changes? I tried applying these to my code but it didn't help. Still looks as if mapDispatchToProps isn't working. . ",
    "nuc": "@Andarist Thanks for the feedback. \nSure, I'd like to continue working on it. I'll ping you once I have something to show.. Yeah, I also don't think it classifies as an effect.. I used the same setup as in throttle but sure I can try to simplify it.. Gotcha. I thought the final output was transpiled. Sure, I can use the that iterator.. ",
    "ValentinBlokhin": "Any progress on this?. ",
    "Havret": "Bump up, any progress? . ",
    "jeffvandyke": "Was there discussion somewhere I can't find where this was decided to be a good idea? Seeing this issue, I get very nervous about having to add about 5 new dependencies just for a basic usage of redux-saga - JavaScript package dependency lists are quite long enough. Is this direction of extracting separate packages always a good idea? And also, are the effects separate enough from internal implementation where it makes sense to extract them?. ",
    "streamich": "There is a problem with this approach. Every time it creates a new anonymous function.\nSo for example when you test your sagas the function in your saga and the one in test are different.\nThis does not allow to use Jest's .toEqual or .toMatchObject.. Thanks for the fast response, BTW.. ",
    "mehi-shokri": "@Andarist thanks for the answer. I've another question does the take effect only listens for that action only once?  Also Do takeLatest and takeEvery effects take all the actions?\nAnother question is what is the difference between these 2 code? I see both of them do one thing:  \nfunction*(){\n  while(true){\n     yield take(action);\n     doSomething();\n  }\n}\nfunction*(){\n  yield takeEvery(action); //or takeLatest(action)\n  doSomething();\n}. > About the snippets - dont forget to put yield before effects.\nyep forget them, sorry :))  \n\nThe second snippet creates a persistent listener (with `takeEvery), doSomething once and exits - listener being still active ofc.  \n\nSorry but I'm confused. Isn't the first snippet persistent? Would you describe what are the exact difference between using a while in conjunction with take VS using takeEvery?\n(I've added the forgotten yields). Oh, I see now. BTW I really appreciate your time and effort for maintaining this awesome project. thank you. ",
    "jhessin": "FYI my project can be found here. Okay this is a workaround (why this is necessary I don't know):\nexport const helloSaga = function* () {\n  yield console.log('Hello Sagas!');\n};. I added the line to my redux/index.js file at the very top and get the same error as before. The only way I can avoid the error is to use the const _ = function* syntax as stated previously.\nAgain not sure why this is.. yes - \npackage.json\n```\n{\n  \"name\": \"bigbuttonlists\",\n  \"version\": \"0.0.0\",\n  \"description\": \"Hello Expo!\",\n  \"author\": null,\n  \"private\": true,\n  \"main\": \"node_modules/expo/AppEntry.js\",\n  \"dependencies\": {\n    \"@expo/vector-icons\": \"^5.2.0\",\n    \"expo\": \"^21.0.0\",\n    \"firebase\": \"^4.6.0\",\n    \"native-base\": \"^2.3.3\",\n    \"react\": \"16.0.0-alpha.12\",\n    \"react-native\": \"https://github.com/expo/react-native/archive/sdk-21.0.2.tar.gz\",\n    \"react-native-easy-grid\": \"^0.1.15\",\n    \"react-navigation\": \"^1.0.0-beta.13\",\n    \"react-redux\": \"^5.0.6\",\n    \"redux\": \"^3.7.2\",\n    \"redux-saga\": \"^0.16.0\",\n    \"redux-saga-firebase\": \"^0.6.1\",\n    \"regenerator-runtime\": \"^0.11.0\"\n  },\n  \"devDependencies\": {\n    \"eslint-config-rallycoding\": \"^3.2.0\",\n    \"eslint-plugin-redux-saga\": \"^0.5.0\"\n  }\n}\n```. Okay everything is up to date now - including readme. If you are just testing this aspect you can feel free to remove the reference to keys.js in the redux/sagas.js file. I haven't started using it anyway.. ",
    "sputt": "Great, I've renamed the function everywhere it's used. ",
    "Zaitsev": "Pls, review this. I prefer join(...tasks) - how its written in Saga docs and Spread in function calls\nBTW calling join([...tasks]) will create copy of tasks array and pass array to function, not tasks as arguments.. Why should we merge it if there are concerns about should we have (...tasks) syntax,  ( we could use join([...tasks]) ) ?\nAs for me, pass list of args and get array as return value is pretty good, (...join) is ES6 way to pass iterrable and no need to change Docs.\n\nbe easier to use in majority of use cases.\n\nbut we are talking about TypeScript declarations, dont we? \nP.S.\nwe have cancel and should be consisent with (...tasks) or [...tasks]  for all functions\ntypescript\nexport function cancel(): CancelEffect;\nexport function cancel(task: Task): CancelEffect;\nexport function cancel(...tasks: Task[]): CancelEffect[];. How about joinAll, raceAll etc? this allows to introduce new interface and separate the single/many problem and improve readability:\n  join(tasks)  is not clear is task variable  is single task or array. redux-saga@0.16.2. Thanks for quick response, no problem with release. BTW its only typings..... ",
    "hectorsabina": "Also, I forgot to mention that... if I do this in the getRequest method:\n```javascript\n function* getRequest(url) {\n  // prepare request\n  // ...\nreturn yield call(fetch, url)\n\n})\n}\n```\nThat also works, but then I don't know how to chain the rest of methods (.then / .catch). Hi @Andarist, thanks for your quick response. I actually figured out that the code you mention does work well for me too. I just realised the problem... I was defining getRequest as a generator function instead of a normal one, but I copied it differently in this issue somehow (last snippet in my first post).\nBut it was helpful to know that it should work, now I'm on the right path.\nThanks!. ",
    "mmerickel": "If it is infact non-blocking then I think it'd be very useful to add a blocking variant to redux-saga. We've commonly been writing code that spawns some long-running sagas, waits for some action and then cancels the sagas. This is in contrast to having the individual sagas cancel themselves. \nUnfortunately, after the cancel if we then join to wait for them to cleanup this will also cancel the parent saga which is very non-intuitive if you are coming from join semantics in a traditional threading paradigm. Even if we yield task.done instead it has the same effect as the join in that it cancels the parent saga.\nBroken code (that I really wish worked but unfortunately the join cancels the current task which I claim should be considered a bug but #408 seems to claim is not a bug):\njs\nfunction* userLifecycleSaga() {\n  while (true) {\n    yield take('USER_DID_LOGIN');\n    const updateTask = yield fork(watchUserState);\n    yield take('USER_WILL_LOGOUT');\n    yield cancel(updateTask);\n    yield join(updateTask);\n  }\n}\nRequired workaround:\n```js\nfunction* watchUserState(finishedChannel) {\n  try {\n  }\n  finally {\n    yield put(finishedChannel, 'anything');\n  }\n}\nfunction* userLifecycleSaga() {\n  while (true) {\n    yield take('USER_DID_LOGIN');\n    const finishedChannel = yield call(channel);\n    yield fork(watchUserState, finishedChannel);\n    yield take('USER_WILL_LOGOUT');\n    yield cancel(updateTask);\n    yield take(finishedChannel);\n  }\n}\n```\nUnfortunately this pattern is exhausting when watchUserState needs to do the same thing with its sub-tasks, etc. Also note that the workaround requires buy-in and a contract between the caller and the callee, versus the original pattern where we do not care about the implementation details of watchUserState.\nI'd argue that it is a bug that yield join(task) causes the caller to be cancelled.. A quick followup argument for not canceling when you join. You can always choose explicitly to do that behavior in user code thanks to yield cancel(). Assuming that join does not propagate a cancellation to the caller itself - they can do it themselves to get the current behavior:\njs\nyield cancel(updateTask);\nyield join(updateTask);\n// this behavior below is the default right now inside join instead of opt-in\nif (updateTask.isCancelled()) {\n  yield cancel();\n}. Well my recommendation for a real breaking change would be to mirror more closely a traditional threading system where you cannot arbitrarily kill threads. In this system cancel is just a request, instead of injecting a return statement into your generator - and that it is only one level deep. The sagas themselves would then check if they were cancelled using yield cancelled() and a new blocking api could be added for them to wait until they are cancelled which could be used in a race with other tasks (imagine yield race({work: call(delay, 5000), cancel: waitForCancel()}); if (cancel) .... This would allow the saga to fully control its lifecycle, cleanup and return when it is ready. It's actually easier in some respects to do work in a thread-based system (ignoring daemonized / detached threads) than redux-saga because you have more guarantees about your lifecycle even though state around you may change at any time. The injection of a return at an arbitrary time makes me very worried each time I do a yield ! Finally you'd get rid of the automatic self-cancelation so you basically cancel a saga and then join for it to actually finish then continue further into the control flow.. > redux-saga comes from the different background than a threading systems and it actually conforms to the standard behaviours of joining a cancelled task in fp Task libraries like folktale's task, fun-task, funfix, avenir and more.\nIt's fine to have the self-cancellation feature if you feel it's necessary but there really does need to be some way to track a task's completion without the self-cancellation. For example, introduce a wait effect or add an option to toPromise like propagateCancel=false.. ",
    "kennethlynne": "Just a note for fellow devs: \njust\nyield cancel(task);\nyield take(DONE);\nconsole.log('work continues assuming task is canceled');\nin saga, and \nconsole.log('task is performing cleanup');\nyield call(delay, 5000);\nconsole.log('task cleanup complete');\nyield put(DONE);\nin the worker should do the trick. ",
    "YarekTyshchenko": "Sounds like cancel() should block until the task returns. If async behaviour is still required it can always be wrapped in another fork. ",
    "Absvep": "Maybe someone here knows why finally block is always run for me? I can see output of console.log in finally always:\nfunction* loginFlow(username, password) {\n  try {\n    yield call(loginApi, username, password);\n    yield put({ type: LOGIN_SUCCESS });\n    yield put({ type: TOGGLE_LOGGED_DONE, payload: true });\n    yield put(push('/dashboard'));\n  } catch (error) {\n    yield put({ type: LOGIN_ERROR, error });\n  } finally {\n    if (yield cancelled()) {\n      console.log('ALWAYS CANCELLED');\n      // yield put(replace('/login'));\n    }\n  }\n}\n//Watcher saga\nfunction* loginWatcher() {\n  while (true) {\n    const { username, password } = yield take(LOGIN_REQUESTING);\n    const task = yield fork(loginFlow, username, password);\n    const action = yield take([LOGOUT, LOGIN_ERROR]);\n    if (action.type === LOGOUT) yield cancel(task);\n    yield call(logoutUser);\n  }\n} \nHere is my question: https://stackoverflow.com/questions/53223958/saga-always-cancelled. ",
    "marutha": "Thanks for you quick response, Since you said first .next() value is ignore I did remove and gave a try.. below the test, and the above implementation remain same. and that is the complete code for the function , prepareRequest and request() all are functions\njavascript\ndescribe('sagas', () => {\n  it('Expect to have unit tests specified', () => {\n    // const mockTask = createMockTask();\n    const gen = fetchInitialInfo();\n    const takeLatestDescriptor = gen.next();\n    console.log('takeLatestDescriptor', takeLatestDescriptor);\n    console.log('request des', requestResponse(getProfiles()));\n    expect(takeLatestDescriptor.value).toEqual(requestResponse(getProfiles()));\n    // expect(true).toEqual(false);\n  });\n});\n```\n FAIL  app/containers/App/tests/sagas.test.js\n  \u25cf Console\nconsole.warn node_modules/react-native-uuid/uuid.js:48\n  [SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()\nconsole.log app/containers/App/tests/sagas.test.js:35\n  takeLatestDescriptor { value: GeneratorFunctionPrototype { _invoke: [Function: invoke] },\n    done: false }\nconsole.log app/containers/App/tests/sagas.test.js:36\n  request des GeneratorFunctionPrototype { _invoke: [Function: invoke] }\n\n\u25cf sagas \u203a Expect to have unit tests specified\nexpect(received).toEqual(expected)\n\nExpected value to equal:\n  {\"_invoke\": [Function invoke]}\nReceived:\n  {\"_invoke\": [Function invoke]}\n\nDifference:\n\nCompared values have no visual difference.\n\n  at Object.<anonymous> (app/containers/App/tests/sagas.test.js:37:40)\n\n``\nlet me know if you are looking for any specific info, also is there some open source that implements testing something like this?.\"redux-saga\": \"0.14.0\",` Could this be an issue, I shall try this and let you know my result on this.\nBasically there is no import to takeLatest as I am not using it in test case, if you are seeing about takeLatestDescriptor this is just a constant that store the descriptor of gen.next(), but I agree the naming convention is not followed here which I should correct.. ",
    "lucaspiller": "I came across this as I have a similar issue. First a bit of background: in our application we have chosen to put all the logic related to building api requests, making the request and parsing responses in sagas. So we dispatch a LOAD_REQUESTED action, the saga does all the work, then it dispatches a LOAD_SUCCESS action, with a payload that can be simply added to the Redux store without any further munging by the reducer. The works well to keep all the logic in one place, and so far our sagas have been quite testable.\nHowever, in one case we have a saga that works as follows:\n```js\nfunction* load() {\n  const data = yield call(loadSharedData)\nif (data.condition) {\n    yield call(pathA, data)\n  } else {\n    yield call(pathB, data)\n  }\n}\nfunction* pathA(data) {\n  yield call(loadSomething)\n  // munge data\n  // maybe load something else\n}\nfunction* pathB(data) {\n  yield call(loadSomethingElse)\n  // munge data\n  // maybe load something else\n}\n```\npathA and pathB have been moved to separate functions (they are around 50 lines each) to keep the main function of the saga small, but as they call yield they also need to be generator functions.\nWe can test the load, pathA and pathB functions individually as you describe, but is there a way to make more of an integration test where we can test everything together?. Sorry maybe I wasn't very clear, but what I was looking for is yield*. Using that I can write sagas and tests like this:\n```js\nfunction load() {\n  const data = yield call(loadSharedData)\n  yield subPath(data)\n}\n// Not a real sub-saga, just a way to split the code to make it more readable\nfunction* subPath() {\n  yield call(loadMoreData)\n}\nit('tests load and subPath', () => {\n  const gen = load()\n  expect(gen.next()).toEqual(call(loadSharedData)\n  expect(gen.next(dataRes)).toEqual(call(loadMoreData)\n})\n```\nThanks!. ",
    "ntucker": "I don't believe this would make the code following it run in the background, which is of course the purpose of this. The only thing you could do here is run code before the resolve inside the callback that is sent to rIC. However, that code would have no way of interfacing with redux-saga - which is my desire.. I re-read the docs on requestIdleCallback and I realize now it's simply a timing API - it does not do anything like webworkers and run things in the background. Because of this your example should work fine for my purposes. Thanks!. ",
    "madhums": "@Andarist could you describe what is the idea behind \"safe\" effect?. ",
    "SeregaSE": "I can try do this. Perfect! Works. Maybe validateTakeEffect can have an if statement to print requires a pattern instead of requires a pattern or channel when validate throttle or throttle could validate itself. @restrry i need to resolve conflicts or what to do?. Okey, i am going to do it in a few days)\n\u043f\u0442, 29 \u0438\u044e\u043d. 2018 \u0433., 9:47 Mikhail Shustov notifications@github.com:\n\n@SeregaSE https://github.com/SeregaSE yes, but as I can see your repo\nhas outdated master. you need to do next:\n\nrebase your repo master against redux-saga master\nrebase your branch against your repo master\n\nnow all those saga helpers are living in a separate file\nhttps://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/io-helpers.js\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/1284#issuecomment-401263959,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AVV0FwCyScx1bqHSGzoi-dtreb3PD8C-ks5uBc15gaJpZM4Q2KiF\n.\n. I moved checks into each helper.\n\nBut mb use this file https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/io-helpers.js to make these check?. @restrry I did. Can i take retry effect?. Could we say that retry creates an Effect description that instructs the middleware to call the function fn with args as arguments while fn does not return the result or fn calls count less then maxTries?. After pull master in my local branch i have a trouble with push my changes\n```\nlerna ERR! npm run test exited 1 in 'babel-plugin-redux-saga'\nlerna ERR! npm run test stderr:\nFAIL test/runner.test.js\n  \u25cf Test suite failed to run\nSecurityError: localStorage is not available for opaque origins\n\n  at Window.get localStorage [as localStorage] (node_modules/jsdom/lib/jsdom/browser/Window.js:257:15)\n      at Array.forEach (<anonymous>)\n\n```\nWhat it could be?\nnpm run test-only fails too with the same error. I will update PR tomorrow, thanks). what about: Creates an Effect description that instructs the middleware to call the function fn with args as arguments while fn does not return the result. If the previous fn call threw an error and fn calls count less than maxTries then retry will call fn again. Delay instructs retry to make a pause between fn calls.. Yeap, i think nice, ty.. ",
    "jaulz": "@restrry how do you use it? I tried something like that:\nsagas.map((saga) => safe(spawn(saga)))\nbut still only the top level error handler is called and not the specific of the safe function.. ",
    "dviry": "same here, seems docs' site is down.... ",
    "blakew": "For now this is the last snapshot from archive.org:\nhttps://web.archive.org/web/20171024040256/https://redux-saga.js.org/. ",
    "lukePeavey": "@Andarist Is this just a matter of removing the --force flag from the push command, or is it more involved than that? . Thanks for the response.  I wasn't able to figure out how to implement this. . Ok, that definitely helps! At first glance I didn't fully understand what was going on in the docs:publish script, but after breaking it down and doing some reading about gitbooks deployment, i think i have a better handle on it. \nIm going to do some work on this and see if I can figure it out.  . So far, I haven't been able to get this working with the GIT_WORK_TREE approach. I did find another possible solution using the gh-pages module. I came across it in this article.\nIt accomplishes the same thing as the current publication script, but doesn't use --force push to overwrite the gh-pages branch each time. \nFrom the documentation\n\nIt will create a temporary clone of the current repository, create a gh-pages branch if one doesn't already exist, copy over all files from the base path, or only those that match patterns from the optional src configuration, commit all changes, and push to the origin remote.\nIf a gh-pages branch already exists, it will be updated with all commits from the remote before adding any commits from the provided src files.\n\nThe publication script would be changed to\n```sh\nInstall GitBook dependencies and build the documentation site to the _book dir\nnpm run docs:clean && npm run docs:build\nCopy the custom domain file to the _book dir\ncp CNAME _book\nCommit and push the contents of the _book dir to the gh-pages branch on the remote\ngh-pages --dist=_book --repo=\"git@github.com:redux-saga/redux-saga.git\" -m \"Update book\"\n```\nI've tested this on a clone of the redux-saga repo and it seems to be working. If you think its a possibility, i can explore it further.. I went ahead and submitted a PR, hope thats ok. . >Can this become a problem? The whole point is to make the remote branch protected, so it won't be possible to delete it.\nIts pretty much a non-issue since branch will protected. I just thought i should mention it as something to be aware of (in case you ever had to take the branch down for some reason). I've tested the script on this repository if you want to take a look.. Glad i was able to contribute!!. ",
    "Bonobomagno": "i got the problem. \nthe server need to handle OPTION request giving 200. Cors is not enoght\nThat was my error, but i think that adding info about it would be a good tip.\nI didnt have this problem with angularJs, for example.\nNow i'm figuring how to handle this.\nadding \nRewriteCond %{REQUEST_METHOD} OPTIONS\n    RewriteRule ^(.*)$ $1 [R=200,L]\ngive me error on apache... ok.\nI found a good answer on the fetch repo\n`\n```\nSetEnvIfNoCase Access-Control-Request-Method \"(GET|POST|PUT|DELETE|OPTIONS)\" IsPreflight=1\nSetEnvIfNoCase Origin \".*\" AccessControlAllowOrigin=$0\nSetEnvIfNoCase Origin \"https://(url1.com|url2.com)$\" AccessControlAllowOrigin=$0\nHeader always set Access-Control-Allow-Origin %{AccessControlAllowOrigin}e env=AccessControlAllowOrigin\nHeader always set Access-Control-Allow-Methods \"GET, POST, PUT, DELETE, OPTIONS\" env=IsPreflight\nHeader always set Access-Control-Allow-Headers \"Content-Type, Authorization, Accept, Accept-Language\" env=IsPreflight\nHeader always set Access-Control-Max-Age \"7200\" env=IsPreflight\nRewriteCond %{REQUEST_METHOD} OPTIONS\nRewriteCond %{ENV:IsPreflight} 1\nRewriteRule ^(.*)$ $1 [R=204,L]\n``\n204 is the right response.\nThanks. you can close this :). yep, was a fetch problem. i didnt use fetch before :). ",
    "topaxi": "I just ran into this issue today and subscribed to this issue, as a newcomer to this ecosystem, I debugged over an hour just to find the issue. I copied some action creator logic which froze actions on development environments. Not saying that the issue should be reopened, but just voicing my experience here as to why I think this should be fixed to prevent future newcomers some headaches.. ",
    "zacharybergmann": "This is the output from the test as run now.   \nexpect(received).toEqual(expected)\n\nExpected value to equal:\n  {\"@@redux-saga/IO\": true, \"ACTION_CHANNEL\": {\"buffer\": {\"flush\": [Function flush], \"isEmpty\": [Function isEmpty], \"put\": [Function put], \"take\": [Function take]}, \"pattern\": \"app/AdministrationPage/PARSE_ES_STATS\"}}\nReceived:\n  {\"flush\": [Function flush], \"isEmpty\": [Function isEmpty], \"put\": [Function put], \"take\": [Function take]}. Thanks, got it now! If anyone else comes across this topic, I did the above except:\n\nconst payload = { payload: { thisThing: 'thatThing' } };\n\nand \nexpect(elasticStatsFlowSaga.next(payload).value).toEqual(call(handleParseAndPut, payload.payload));\n\nI thought the value passed on would have just been the payload already destructured but it was the whole object.. ",
    "Jancat": "Thanks for your answer!!  It helps me. @Andarist . By the way. How to catch the failing request and resume others? @Andarist . Sincerely thank for you! @Andarist . Oh thanks. So this is a wrong flow. I would have to use blocking calls.\n\nI don't want to use blocking call method because a bit slowly\n\nI mean the delete request has a little delayed. And I don't want to block UI by navigating to login page instantly.. ",
    "mikesol": "Yup! The only thing then that we'd need is a public API function to get actions for PUT, functions and arguments for CALL and FORK, etc.. Also, asEffect is currently not documented in the API section - is it supposed to be public?. Hey! Sorry, I missed your initial message about #1263 . That looks like a really cool project! Unfortunately it's a bit too much for me to chew right now - mostly, we are focusing on open sourcing our code base at Meeshkan, but once we have a bit more time, we'd love to contribute to redux-saga in a more general way!  With respect to our saga-teller project, we've refactored it to take a general matcher function as an argument, so there is nothing in the base functionality that depends on a non-public API. Of course, the matcher function will need to ping the internal api for the time being, but that is easy to change.. Agreed - if the API is stable, there's no reason to merge this PR as writing object verification code is trivial. The only thing I'd ask then, if you guys have time, is to make this a documented feature when you're ready: even a one-liner in the docs saying that the internal representation of objects is stable and that any backwards-incompatible change will be reported in release notes.  But of course that's low priority compared to the other stuff you have going on. Great work, as usual!. Thanks for the feedback! I've taken a stab at reorganizing it based on your recommendations, but as I don't have a lot of JavaScript experience, it may not be what you're looking after (I didn't know what tree-shaking was, for example, and still am a bit fuzzy on the concept after reading about it).  Lemme know!. ",
    "jforaker": "Interesting - when I build my app in production mode it seems to work. I wonder if there is anything affected by the NODE_ENV=development flag?  I am using https://github.com/react-boilerplate/react-boilerplate. Interesting - when I build my app in production mode it seems to work. I wonder if there is anything affected by the NODE_ENV=development flag?  I am using https://github.com/react-boilerplate/react-boilerplate. thanks @Peterabsolon that actually worked for the most part. However, now I'm experiencing an unexpected response. Using it according to the the docs, I get a strange return value, as if it hasnt \"resolved\" for lack of a better term\njavascript\n    const foo = yield all([\n      call(request, getStoryUrl(id), includeCreds),\n      call(request, `${getStoryUrl(id)}/history?page_size=5`, includeCreds)\n    ]);\n    console.log('foo', foo);\nResult:\n\nAnd cannot spread the result like the docs because that object is not iterable. \nAny thoughts?  Or should I chalk it up to a corrupt install or node_module setup and move on? Either way is fine for me. . thanks @Peterabsolon that actually worked for the most part. However, now I'm experiencing an unexpected response. Using it according to the the docs, I get a strange return value, as if it hasnt \"resolved\" for lack of a better term\njavascript\n    const foo = yield all([\n      call(request, getStoryUrl(id), includeCreds),\n      call(request, `${getStoryUrl(id)}/history?page_size=5`, includeCreds)\n    ]);\n    console.log('foo', foo);\nResult:\n\nAnd cannot spread the result like the docs because that object is not iterable. \nAny thoughts?  Or should I chalk it up to a corrupt install or node_module setup and move on? Either way is fine for me. . I've tried everything from wiping out node_modules and re-installing to trying the es/effects import. It must be something with my local environment, unrelated to the library. Thanks for the help, and feel free to close this issue (or let me know if I need to). . I've tried everything from wiping out node_modules and re-installing to trying the es/effects import. It must be something with my local environment, unrelated to the library. Thanks for the help, and feel free to close this issue (or let me know if I need to). . Thank you for all the help. I would really love to... but it is private/for work.  Our project was initialized with https://github.com/react-boilerplate/react-boilerplate and we haven't changed any webpack configs (though it might be a slightly older version). Thank you for all the help. I would really love to... but it is private/for work.  Our project was initialized with https://github.com/react-boilerplate/react-boilerplate and we haven't changed any webpack configs (though it might be a slightly older version). ",
    "Peterabsolon": "@jforaker As a workaround, you can try to import the effects from 'redux-saga/es/effects' instead. Worked for me.. ",
    "Arhane": "I guess, the babel-plugin-annotate-pure-calls is installed not via npm repository .\nBut still there is another mistake and I think, it is connected to babel-plugin-annotate-pure-calls\n```\n\ncross-env BABEL_ENV=es babel src --out-dir es\n\nsrc/index.js \u2192 dist/redux-saga.min.js...--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\nsrc/index.js \u2192 dist/redux-saga.js...\nsrc\\effects.js -> es\\effects.js\n[!] (babel plugin) TypeError: Cannot read property 'isProgram' of null\nsrc\\index.js\nTypeError: Cannot read property 'isProgram' of null\n    at error (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\rollup\\dist\\rollup.js:185:14)\n    at Object.error (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\rollup\\dist\\rollup.js:9469:6)\n    at promise.then.previous (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\rollup\\dist\\rollup.js:9478:32)\n    at \n    at process._tickCallback (internal/process/next_tick.js:188:7)\n    at Function.Module.runMain (module.js:667:11)\n    at startup (bootstrap_node.js:187:16)\n    at bootstrap_node.js:607:3\nTypeError: Cannot read property 'isProgram' of null\n    at isTopLevel (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\babel-plugin-annotate-pure-calls\\lib\\index.js:58:34)\n    at isExecutedDuringInitialization (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\babel-plugin-annotate-pure-calls\\lib\\index.js:62:7)\n    at PluginPass.callableExpressionVisitor (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\babel-plugin-annotate-pure-calls\\lib\\index.js:103:8)\n    at newFn (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\@babel\\traverse\\lib\\visitors.js:223:21)\n    at NodePath._call (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\@babel\\traverse\\lib\\path\\context.js:64:19)\n    at NodePath.call (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\@babel\\traverse\\lib\\path\\context.js:38:17)\n    at NodePath.visit (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\@babel\\traverse\\lib\\path\\context.js:95:12)\n    at TraversalContext.visitQueue (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\@babel\\traverse\\lib\\context.js:139:18)\n    at TraversalContext.visitSingle (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\@babel\\traverse\\lib\\context.js:98:19)\n    at TraversalContext.visit (C:\\Users\\las\\Desktop\\Projects\\redux-saga\\node_modules\\@babel\\traverse\\lib\\context.js:180:19)\nsrc\\index.js -> es\\index.js\n```. The problem is definitely in babel-plugin-annotate-pure-calls.\n. It seems like I got the idea - there was a breaking change in Babel itself.\nAnd that line uses the old version.\nP.S.\nnpm - 3.10.8\nnode - 8.6.0\n. Hmm... The problem was in an old version of npm, but yarn doesn't work neither.\nBy the way, we can add this field in order to prevent developer mistakes.\nI found out that yarn have problems with installing a branch from github directly    . ",
    "jaimemendozadev": "Thanks for merging it! I leave the diff up to your good judgment!. ",
    "soma83": "Mr. Andarist, \nI'm using React-Boilerplate and the way I'm injecting the defaultSaga is this:\n```\nconst withConnect = connect(mapStateToProps, mapDispatchToProps);\nconst withReducer = injectReducer({key: 'xxxxxxx', reducer});\nconst withSaga = injectSaga({key: 'xxxxxxx', saga});\nexport default compose(withReducer, withSaga, withConnect) MyComponent);\n``\n. Mr. Andarist,\nCould you please give me a hint on how to do that?.componentWillMount() {\n  console.log('mounting');\n}`\nShows only one mounting line... however I did this:\nexport default function* defaultSaga () {\n  yield takeLatest(CREATE_REQUEST, create);\n  console.log('mounting saga');\n}\nand it prints \"mounting saga\" two times. I'm going to see your links right now and then I'll be back.. Mr. Andarist,\nthe codes you gave me are just exactly the same I have. The react componentWillMount tells me that the component is going to be mounted just once. The code I have for the sagas is that I gave you, so, I don't know what else could I share in order to give you a more clear idea on this. So, please, tell me what else I can tell you to get this working.. Thanks for your time.. Problem solved, a little hack solution, but solved. ",
    "aelor": "@soma83 How did you solve the issue ? what you have written seems pretty standard to me. Why and what was the hack required ? Thanks in advance\nEdit:\nGyvastis's solution https://github.com/react-boilerplate/react-boilerplate/issues/1434 worked for me\nEdit 2:\nEnded up using Dattaya's solution https://github.com/react-boilerplate/react-boilerplate/issues/1434 as this was independent of file being minified. ",
    "jherencia": "Thank you!. And what about Redux, is it agnostic too?\nI see the new branch of Redux 4.x has been released (https://github.com/reactjs/redux/releases/tag/v4.0.0-beta.1).. Great! Thank you for the response!. ",
    "huanghaiyang": "onError. ",
    "stefli": "Thanks, it works.. ",
    "adampetrie": "Perfect! I knew I was missing something. Thanks.. Perfect! I knew I was missing something. Thanks.. ",
    "cfuehrmann": "Sorry for replying late. I've been looking for your fix, but the last commit is from before I opened this issue. (Unless I'm overlooking something - I'm new to this.) Did you really push?. Thanks, the polyfill error is gone now. (Only the secondary warning about NoErrorsPlugin remains.) So this  issue can be closed as far as I'm concerned.. ",
    "be-next-hotdog": "const { res, timeout } = yield race({\n            res: join(task),\n        timeout: call(delay, 10 * 1000) // And what does this function 'delay' mean here ? \n    }). ",
    "iv85": "Sorry, i didn't open the issue. I don't know how it happened. ",
    "tnguven": "So what is the equivalent of throttle now? . ",
    "gavinsharp": "FWIW, the term \"deprecated APIs\" made me interpret this as the effects themselves being deprecated, rather than just that way of importing them. Maybe something to consider for future release note clarity :). ",
    "jrnail23": "@Andarist, am I correct to interpret this discussion as saying there's not currently (as of v0.16) a clean way to do compose saga functionality via higher order functions?\nAlso, is it currently possible to create custom effects?  If so, can you please point me to any docs/examples/etc. for them?. Ah, @Andarist, that is very helpful.  Given the (kinda) asynchronous nature of generators, I wasn't sure exactly what gets blocked when using call vs fork (whether it blocks all progress in your app vs. just blocking the forking task).  Sounds like it's the latter.  Thanks!. ",
    "mpeyper": "Just wanted to add my interest in this discussion/feature.  I'm the author of redux-subspace which is a library for creating isolated sub-stores for micro-frontends that are still actually part of a global redux store.\nBasically, the sub-stores isolate state and actions that are raised from within and as of version 2 it supports a bunch of redux middleware, including redux-saga.\nThe catch with redux-saga is that I need to intercept the action and strip off it's namespace on the way in, and intercept any put effects and apply the namespace on the way out.  To add further complexity, any select effects must only return the sub-store's state.  \nSimilarly to @saboya, I figured I would run the subspaced saga outside of the global store's middleware and create a seperate saga runtime for the sub-store (the sub-store already handles all of the complexity described above).  Here is my implementation:\n```javascript\nimport { runSaga } from 'redux-saga'\nimport { getContext, takeEvery } from 'redux-saga/effects'\nimport { subspace } from 'redux-subspace'\nimport provideStore from './provideStore'\nconst emitter = () => {\n  const subscribers = []\nfunction subscribe(sub) {\n    subscribers.push(sub)\n    return () => {\n      subscribers.splice(subscribers.indexOf(sub), 1)\n    }\n  }\nfunction emit(item) {\n    const arr = subscribers.slice()\n    for (var i = 0, len = arr.length i < len i++) {\n      arri\n    }\n  }\nreturn {\n    subscribe,\n    emit\n  }\n}\nconst subspaced = (mapState, namespace) => {\n  const subspaceDecorator = subspace(mapState, namespace)\nreturn saga => {\n    return function* wrappedSaga() {\n      const parentStore = yield getContext('store')\n  const sagaEmitter = emitter()\n\n  const store = {\n    ...subspaceDecorator(parentStore),\n    subscribe: sagaEmitter.subscribe\n  }\n\n  runSaga(store, provideStore(store)(saga))\n\n  yield takeEvery('*', function* (action) {\n    store.processAction(action, sagaEmitter.emit)\n    yield\n  })\n}\n\n}\n}\nexport default subspaced\n```\nThis has worked fine for us for a while now (but I do welcome any comments or feedback on improving the implementation), but we are running into an issue now trying to pass context from a parent outside the subspace to a child inside, as the sagas do not share context.\nInterestingly, I've already run into this before with the store value passed down the context to wrapping in subspaces, but I was able to overcome it here by transferring it to the new saga's context (that's what provideStore does).\nIdeally, I would like to transfer the whole context to the other saga runtime, but as previously stated in this thread, that does not appear to be currently possible.\nI was wondering how you would feel about changing runGetContextEffect to be something like:\njavascript\nfunction runGetContextEffect(prop, cb) {\n  cb(prop ? taskContext[prop] : { ...taskContext })\n}\nThis should allow retrieval of the full context that I can then transfer across.\nThoughts?. Hi @Andarist,\n\n@mpeyper ur proposal with spread would actually just copy \"one level\" of the context, saga contexts are chained together using prototype chain (thanks to Object.create) and spread wont do such a deep copy.\n\n\ud83d\ude1e I knew it wouldn't be that simple!\n\nWhat would be ur desired behaviour? To fork a saga (preserve context, it being linked to a parent so preserving error/cancel propagation) just with namespaced select/put effects?\n\nAlmost.  \nThe requirements are to wrap a saga so that it:\n\nis written without any knowledge of being wrapped and could work if it was run in an unmodified saga middleware\nbe infinitely nestable\nfilters then modifies actions that take effects (and variants of) would receive. Generally this will be actions that have a matching namespace, but there are other reasons why the action would be allowed through, and modify them so that the namespace has been removed\npresents a sub-state to the selector of select effects\nnamespaces any actions created from put effects (and variants of).  \npreserves context (with one item in the context potentially being replaced, depending on implementation - currently we need to pass the store down the context to create the child subspaces)\nis linked to the parent for error/cancellation propagation\n\nDoes that all make sense?. I noticed there is an effect middleware feature just above the env section\nyou linked. Is there more documentation on that anywhere (I can't spot any\nscanning the docs)?\nI'm wondering if it can be used to intercept the take, select and put effects?\nOn Sun., 8 Jul. 2018, 7:00 am Mateusz Burzy\u0144ski, notifications@github.com\nwrote:\n\nYeah - it makes sense. Preserving context wouldn't be really that hard,\nbut keeping error/cancellation propagation in place and at the same time\nhaving configuration (env nowadays\nhttps://github.com/redux-saga/redux-saga/blob/8e1a6c153ea03adc2a46e8c1cf6f3d8395a07a87/packages/core/src/internal/runSaga.js#L76-L84)\nreplaced for the subtree (to support namespacing) is not that easy -\nAPI-wise. I'd really like to avoid exposing some setters/getters pairs for\nthose internal things.\nI doubt we'll tackle this problem any time soon - but if you have any\nideas how we could make this supported (what the API would look like?) I'd\nbe happy to discuss possibilities.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/1280#issuecomment-403242563,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AV9oj3NIiNHIiidGc7PAY6eJ9fnUk2xqks5uESFvgaJpZM4Qz-Z6\n.\n. \n",
    "pengliheng": "this problem appear again.\nerror stack\n```js\nTypeError: Cannot read property 'then' of undefined\n    at Object.e [as effectResolved] (page.bundle.js:1)\n    at currCb (redux-saga-core.esm.js:1249)\n    at redux-saga-core.esm.js:602\n    at immediately (redux-saga-core.esm.js:56)\n    at runForkEffect (redux-saga-core.esm.js:594)\n    at runEffect (redux-saga-core.esm.js:1210)\n    at digestEffect (redux-saga-core.esm.js:1277)\n    at next (redux-saga-core.esm.js:1167)\n    at proc (redux-saga-core.esm.js:1114)\n    at runEffect (redux-saga-core.esm.js:1205)\n    at digestEffect (redux-saga-core.esm.js:1277)\n    at redux-saga-core.esm.js:683\n    at Array.forEach ()\n    at runAllEffect (redux-saga-core.esm.js:682)\n    at runEffect (redux-saga-core.esm.js:1210)\n    at digestEffect (redux-saga-core.esm.js:1277)\n    at next (redux-saga-core.esm.js:1167)\n    at proc (redux-saga-core.esm.js:1114)\n    at redux-saga-core.esm.js:1374\n    at immediately (redux-saga-core.esm.js:56)\n    at runSaga (redux-saga-core.esm.js:1373)\n    at Function.sagaMiddleware.run (redux-saga-core.esm.js:1434)\n    at Module../src/redux-related/store/index.js (index.js:26)\n    at webpack_require (bootstrap:781)\n    at fn (bootstrap:149)\n    at Module../src/index.js (index.css?02e3:45)\n    at webpack_require (bootstrap:781)\n    at fn (bootstrap:149)\n    at Object.0 (serviceWorker.js:135)\n    at webpack_require (bootstrap:781)\n    at checkDeferredModules (bootstrap:45)\n    at Array.webpackJsonpCallback [as push] (bootstrap:32)\n    at main.chunk.js:1\nThe above error occurred in task _callee\n    created by _callee\nTasks cancelled due to error:\ntakeLatest(FETCH_PENDING, _callee)\nUncaught TypeError: Cannot read property 'then' of undefined\n    at Object.e [as effectResolved] (page.bundle.js:1)\n    at redux-saga-core.esm.js:1379\n    at immediately (redux-saga-core.esm.js:56)\n    at runSaga (redux-saga-core.esm.js:1373)\n    at Function.sagaMiddleware.run (redux-saga-core.esm.js:1434)\n    at Module../src/redux-related/store/index.js (index.js:26)\n    at webpack_require (bootstrap:781)\n    at fn (bootstrap:149)\n    at Module../src/index.js (index.css?02e3:45)\n    at webpack_require (bootstrap:781)\n    at fn (bootstrap:149)\n    at Object.0 (serviceWorker.js:135)\n    at webpack_require (bootstrap:781)\n    at checkDeferredModules (bootstrap:45)\n    at Array.webpackJsonpCallback [as push] (bootstrap:32)\n    at main.chunk.js:1\n```\npackage.json\njson\n{\n  \"name\": \"saga\",\n  \"version\": \"0.1.5\",\n  \"dependencies\": {\n    \"react\": \"^16.8.4\",\n    \"react-app-polyfill\": \"^0.2.2\",\n    \"react-dev-utils\": \"^8.0.0\",\n    \"react-dom\": \"^16.8.4\",\n    \"react-redux\": \"^6.0.1\",\n    \"redux\": \"^4.0.1\",\n    \"redux-logger\": \"^3.0.6\",\n    \"redux-saga\": \"^1.0.2\",\n    \"redux-thunk\": \"^2.3.0\",\n    \"resolve\": \"1.10.0\",\n    \"sass-loader\": \"7.1.0\",\n    \"style-loader\": \"0.23.1\",\n    \"tape\": \"^4.10.1\"\n  }\n}\n. #### this issue will be caused while i disable the cache.\n. ### OK ,this problem can be fix, while i remove the code of redux-saga-devtool\n```js\nimport { createStore, applyMiddleware } from  'redux'\nimport reducer from '../reducer'\nimport logger from 'redux-logger'\nimport { composeWithDevTools } from 'redux-devtools-extension'\n// import { createSagaMonitor } from  'redux-saga-devtools'\nimport createSagaMiddleware from 'redux-saga'\n// import { is, asEffect } from 'redux-saga/utils'\nimport rootSaga from '../sagas'\n// const monitor = createSagaMonitor()\n// const monitor = window['SAGA_MONITOR_EXTENSION']\n// const sagaMiddleware = createSagaMiddleware({ sagaMonitor: monitor })\nconst sagaMiddleware = createSagaMiddleware()\nexport default createStore(\n  reducer,\n  composeWithDevTools(\n    applyMiddleware(\n      logger,\n      sagaMiddleware,\n    )\n  )\n)\nsagaMiddleware.run(rootSaga)\n```. ",
    "caub": "I'm not familiar with TypeScript, what signature should I put to allow to pass a thunk in second arg?\nts\nexport function delay<T>(ms: number, val?: T): CallEffect;\ntest: \nts\ndelay(1, () => 'foo').then(res => {\n  // typings:expect-error\n  const e: boolean = res;\n  const r: string = res;\n});\n\u2716 Error: Semantic: /home/caub/dev/redux-saga/test/typescript/delay.ts (19, 11) Type '() => \"foo\"' is not assignable to type 'string'.\nthis is not working either\nts\nexport function delay<T>(ms: number, val?: T | (() => T)): CallEffect;. I'm not familiar with TypeScript, what signature should I put to allow to pass a thunk in second arg?\nts\nexport function delay<T>(ms: number, val?: T): CallEffect;\ntest: \nts\ndelay(1, () => 'foo').then(res => {\n  // typings:expect-error\n  const e: boolean = res;\n  const r: string = res;\n});\n\u2716 Error: Semantic: /home/caub/dev/redux-saga/test/typescript/delay.ts (19, 11) Type '() => \"foo\"' is not assignable to type 'string'.\nthis is not working either\nts\nexport function delay<T>(ms: number, val?: T | (() => T)): CallEffect;. The usecase I had is in first comment. Currently I'm doing\njs\n// ..\nconst [session] = yield all([\n    call(fetchApi, '/session'),\n    call(delay, 1000)\n]);\nyield put({type: SIGNIN, value: session});\n// ....\nbut it's less practical, less easy to test and more verbose than \njs\nconst session = yield call(delay, 1000, call(fetchApi, '/session'));\nyield put({type: SIGNIN, value: session});\nbecause here's how I can test the all approach: (eq is assert.deepEqual)\njs\nconst saga = getSession();\neq(saga.next().value, all([\n    call(fetchApi, '/session'),\n    call(delay, 1000)\n]));\neq(saga.next([session]).value, put({type: SIGNIN, value: session}));\nnotice the [session] because, that's the form returned by all\nIn comparison with delay + value:\njs\nconst saga = getSession();\neq(saga.next().value, call(delay, 1000, call(fetchApi, '/session')));\neq(saga.next(session).value, put({type: SIGNIN, value: session}));\nIt behaves like all, but ignores the delay part in returned value\n```js\nconsole.time(1);\nconsole.log(yield call(delay, 1000, call(delay, 1500, 'foo'))); // 'foo'\nconsole.timeEnd(1); // 1500\nconsole.time(1);\nconsole.log(yield call(delay, 1500, call(delay, 1000, 'foo'))); // 'foo'\nconsole.timeEnd(1); // 1500\n. The usecase I had is in first comment. Currently I'm doingjs\n// ..\nconst [session] = yield all([\n    call(fetchApi, '/session'),\n    call(delay, 1000)\n]);\nyield put({type: SIGNIN, value: session});\n// ....\nbut it's less practical, less easy to test and more verbose thanjs\nconst session = yield call(delay, 1000, call(fetchApi, '/session'));\nyield put({type: SIGNIN, value: session});\nbecause here's how I can test the all approach: (`eq` is `assert.deepEqual`)js\nconst saga = getSession();\neq(saga.next().value, all([\n    call(fetchApi, '/session'),\n    call(delay, 1000)\n]));\neq(saga.next([session]).value, put({type: SIGNIN, value: session}));\n``\nnotice the[session]because, that's the form returned byall`\nIn comparison with delay + value:\njs\nconst saga = getSession();\neq(saga.next().value, call(delay, 1000, call(fetchApi, '/session')));\neq(saga.next(session).value, put({type: SIGNIN, value: session}));\nIt behaves like all, but ignores the delay part in returned value\n```js\nconsole.time(1);\nconsole.log(yield call(delay, 1000, call(delay, 1500, 'foo'))); // 'foo'\nconsole.timeEnd(1); // 1500\nconsole.time(1);\nconsole.log(yield call(delay, 1500, call(delay, 1000, 'foo'))); // 'foo'\nconsole.timeEnd(1); // 1500\n```. Well, I don't know for now, no worry it's not important\nI would have preferred to avoid another function, there are already many\nand also because the current delay already works with things like delay(500, delay(200, 'test')), this promise gives 'test' after 500ms, so my PR wasn't really changing this current behavior. I just needed to use call for tests. Well, I don't know for now, no worry it's not important\nI would have preferred to avoid another function, there are already many\nand also because the current delay already works with things like delay(500, delay(200, 'test')), this promise gives 'test' after 500ms, so my PR wasn't really changing this current behavior. I just needed to use call for tests. oh yes indeed, thanks\nclosing the PR so. oh yes indeed, thanks\nclosing the PR so. ",
    "erik-sn": "@huntwj did you ever find a resolution for this?. as a quick fix I just added a redux-saga/effects module in a custom .d.ts file and overrode the values, those are all good ideas though.. ",
    "huntwj": "I seem to have \"moved past\" the problems, though I cannot remember exactly what the solution was. I'm guessing it was related to using the 1.0 typings, but I can't remember off hand and unfortunately don't have time to do the necessary testing right now.\nWhat I still think could be useful, and is something I may attempt to put together in the near future, would be a page of documentation providing a quick \"getting started\" guide for using redux saga with TypeScript.. ",
    "AleksandrChernyavenko": "I had error Argument of type 'ChartActionTypes.FETCH_CHART' is not assignable to parameter of type 'Channel<{ payload: any; }>'.\nSo problem was in fetchChart(action: type) - it has wrong type. I added type for action, and this fixed error \n```typescript\nexport function* fetchChart(action: FetchChartAction) { // <-- here added type FetchChartAction\n  const {error, data} = yield call(fetchChartData, action)\n  if (!error) {\n    yield put(fetchChartSuccess(data))\n  } else {\n    yield put(fetchChartFailure(error))\n  }\n}\nexport function* watchFetchChart() {\n  yield takeLatest(ChartActionTypes.FETCH_CHART, fetchChart) // <-- here pass action argument\n}\n```. ",
    "agzamovr": "If above solution didn't work for you (as it didn't for me) try this one https://github.com/redux-saga/redux-saga/issues/1188#issuecomment-425717322 . ",
    "BrandonKlotz": "@wisn I am a said newcomer looking to help out and contribute somewhere. I just learned React Redux. Let me know if there is something that would be helpful.. ",
    "AbdulKabia": "Hey, would it be okay if I worked on this? @Andarist . Hmm, managed to update my entire fork and even the branch, but Travis is still failing to build it. All I did was change the .md file. Do you happen to have any idea as to why this build could be failing, @Andarist ?. ",
    "jonhester": "Thanks for looking at this so quickly. I removed sagaStack and the logError method. I'm just calling log('error', error) now instead. . ",
    "soroushm": "Dear @Andarist\non submit book form there is a api calling then response status is 401 unauthorized\nAxios will be dispatch \"AUTH_FAILURE\" \nthen \"function* failure\" will be take action and depend on user have accessToken or not will be push in login or register route\ni wanna on \"LOGIN_SUCCESS\"  getting back to form and call api again\nBR, . ",
    "yuchi": "Answered there. ",
    "DavidGonzalezGutierrez": "index.saga\n```javascript\nimport {all} from 'redux-saga/effects';\nimport {logSagas} from \"./log.saga\";\nimport {loginSagas} from '../screens/login/login.saga';\nimport {gpsSagas} from \"../components/common/gps/gps.saga\";\nimport {pagoQRSagas} from \"../screens/pagoQR/pagoQR.saga\";\nexport default function* rootSaga() {\n    yield all([\n        ...logSagas,\n        ...loginSagas,\n        ...gpsSagas,\n        ...pagoQRSagas\n    ])\n}\n```\nThere are a total of 20 sagas that load when you start the app.\npagoQRSaga.js\n```javascript\nimport {put, select, takeLatest, call, spawn} from \"redux-saga/effects\";\nimport {delay} from \"redux-saga\";\nimport axios from 'axios';\nimport {NavigationActions} from \"react-navigation\";\nimport {\n    PANTALLA_VEHICULOS,\n    VEHICULO_SELECCIONADO,\n    ACTUALIZAR_ID_OPERACION,\n    TICKET_SELECCIONADO\n} from \"./pagoQR.actionTypes\";\nimport {CAMBIAR_MODO} from \"../vehiculos/listaVehiculos/vehiculos.actionTypes\";\nimport Config from \"../../config\";\nimport {alertError} from \"../alert/alert.actions\";\nexport function* pantallaTickets() {\n    let vehiculo = yield select(state => state.pagoQR.vehiculo_seleccionado);\n    if (vehiculo.empresa_cliente_id) {\n        //respuesta\n            yield put({type: ACTUALIZAR_ID_OPERACION, payload: respuesta.data.data.id});\n            yield put(NavigationActions.navigate({routeName: 'QR'}));\n///THE PROBLEM\n            yield call(() => esperaAceptarPagoChannel());\n        } catch (e) {\n            yield put(alertError(e.message));\n        }\n    } else {\n        //es particular\n        yield put({type: CAMBIAR_MODO, payload: \"seleccion\"});\n        yield put(NavigationActions.navigate({routeName: 'TicketsDescuento'}));\n    }\n}\nexport function* esperaAceptarPagoChannel() {\n    let secs = 10;\n    while (secs > 0) {\n        yield call(delay, 1000);\n        console.log(secs);\n        secs--;\n    }\n}\nexport const pagoQRSagas = [\n    takeLatest(PANTALLA_VEHICULOS, pantallaVehiculos),\n    takeLatest(VEHICULO_SELECCIONADO, pantallaTickets),\n    takeLatest(TICKET_SELECCIONADO, ticketSeleccionado)\n];\n```\n. Thanks.\nI tried like you said: \nyield call(esperaAceptarPagoChannel);\njavascript\nexport function* esperaAceptarPagoChannel() {\n    let secs = 10;\n    while (secs > 0) {\n        console.log(secs);\n        yield call(delay, 1000);\n        secs--;\n    }\n}\nthis was the result: \n\n. With setInterval something similar happens.\n\nDo not execute it until after 27 seconds.. ```javascript\nexport function* pantallaTickets() {\n    let vehiculo = yield select(state => state.pagoQR.vehiculo_seleccionado);\n    if (vehiculo.empresa_cliente_id) {\n    try {\n\n        yield put(NavigationActions.navigate({routeName: 'QR'}));\n        console.log('Before call esperaAceptar...');\n        yield call(esperaAceptarPagoChannel);\n        console.log('After call esperaAceptar...');\n    } catch (e) {\n        yield put(alertError(e.message));\n    }\n}\n\n}\nexport function * esperaAceptarPagoChannel() {\n    let secs = 3;\n    while (secs > 0) {\n        console.log('Before delay');\n        yield call(delay, 1000);\n        console.log('After delay');\n        secs--;\n    }\n}\n```\n\n. Debbuger: Chrome 63 in windows 10\nAndroid: 6.0.1 Galaxy Note 4\n\"react\": \"16.0.0-beta.5\",\n\"react-native\": \"^0.49.5\",\n\"react-redux\": \"^5.0.6\",\n\"redux\": \"^3.7.2\",\n\"redux-saga\": \"^0.16.0\"\n\n. \n. \n. ```javascript\nexport function* ticketSeleccionado() {\n    let vehiculo = yield select(state => state.pagoQR.vehiculo_seleccionado);\n    let usuario = yield select(state => state.login.usuario);\n    let estacion_servicio_id = yield select(state => state.estacionDetectada.estacion.id);\n    let ticket_id = yield select(state => state.pagoQR.ticket_descuento_seleccionado.id);\n    let token = yield select(state => state.login.token_type + ' ' + state.login.access_token);\n    try {\n        let respuesta = yield call(() => saveOperacionGasolineraApi(token, vehiculo.id, usuario.empresa_cliente_id, estacion_servicio_id, ticket_id));\n        yield put({type: ACTUALIZAR_ID_OPERACION, payload: respuesta.data.data.id});\n        yield put(NavigationActions.navigate({routeName: 'QR'}));\n        yield call(() => esperaAceptarPagoChannel());\n    } catch (e) {\n        yield put(alertError(e.message));\n    }\n}\nexport function * sleep() {\n    let start = new Date().getTime();\n    for (let i = 0; i < 1e7; i++) {\n        if ((new Date().getTime() - start) > 2000) {\n            break;\n        }\n    }\n}\nexport function * esperaAceptarPagoChannel() {\n    let secs = 10;\n    while (secs > 0) {\n        console.log('a');\n        yield call(sleep);\n        secs--;\n    }\n}\n```\nI have used this internet code. It is not clean but it works. Any of the other functions gives problems.\nNow the problem I have is that it is not sent asynchronously. It is waiting for the loop to finish to run.. ",
    "D1plo1d": "@Andarist yeah that's exactly what I was looking for! Thanks!\nI rolled this example up into a little library that works with the latest code on redux-saga#master if anyone else wants to test their delays this way: https://github.com/D1plo1d/redux-saga-delay-mock. ",
    "damathryx": "thanks @Andarist . ",
    "pokorson": "Wouldn't Fluture separation of methods be a problem here? With Promise it's simple cause you have only then to retrieve value but Fluture has map, chain and fork for this purpose and each is slightly different.\nSo which method would you expect to get called with Fluture here:\nconst coins = yield call(coinMarketCapData)\nOr would it require additional API for controlling this?. ",
    "ryanbas21": "That is a valid point, it could be an issue. I was using .value to extract the value out of the fluture.\n. ",
    "cjpete": "@Andarist I've created a repo here - https://github.com/cjpete/redux-saga-import-issue\nLooks like the same issue has been raised with eslint-plugin-import - https://github.com/benmosher/eslint-plugin-import/issues/666. ",
    "vukasin-nikodijevic": "@Andarist - I finally solved issue - and everything was pointing that problem is in Saga - I was really wrong.\nIssues comes from data mutation and from mostly unexpected place VIEW.\nI'm providing connected data from store to my component and I have helper function to subset me videos array to first 3.\nProbably IDE auto completed instead of slice > splice which mutates videos object and as it comes by reference it changed everywhere.\nThis is just one really evil bug - I'll close issue and thanks for reply :). ",
    "macrozone": "@Andarist true, but it might pull in both redux versions in builds (depending on how the packagers work). Maybe loose the constraint to allow both versions of redux?. >=0.10 <5 reflects the truth for the time beeing, so I think that would be best. We don't know if it will work with future redux5, but we know it works with redux4, so i think that's a good constraint.\nHaving said that, i did not try it out with redux4 yet, hope to do that soon and send in a pr. ",
    "martpie": "Redux 4 it out btw https://github.com/reactjs/redux/releases/tag/v4.0.0. ",
    "hartantoboby": "Found the solution. I forgot to return the promise in doCheckOpenRegister function.. ",
    "ggarek": "@Andarist , thank you for your work on the project, it is great! And there pre-release changes has many things i wanted to see. Thank you!\ni was checking the latest prerelease (v1.0.0.beta.1). The description says\n\nAlso onError should get called now even if you throw non-Errors in your code.\n\nBut i think it is not the case, still only instance of Error is reported.. Would be happy to have this feature \ud83d\ude4f . I have rechecked my test example. Here are the details\nTL;DR\n\nI compare two version of redux saga: 0.16.0 and 1.0.0-beta.1\nI test for two things: \n  1) i expect put effect to rethrow errors (\u2139\ufe0f i know, there is put.resolve)\n  2) i expect onError to get called for uncaught errors thrown in saga (in fact, in put effect)\n\nObservations\n||put propagates Errors|put propagates not Errors|onError is called for uncaught Errors|onError is called for uncaught not Errors|\n|-|-|-|-|-|\n|v0.16.0|\ud83d\udeab|\ud83d\udeab|- (because put swallows)|- (because put swallows)|\n|v1.0.0-beta.1| \u2705 |\u2705|\u2705|\ud83d\udeab|\nSo, it seems there is only one question: \n[\u2753] The onError callback is not called if not instance of Error is thrown\nDetails\nHere is my test\n```js\nimport { applyMiddleware, createStore } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport { put, takeEvery } from \"redux-saga/effects\";\n// TODO: Action handled by saga is passed to reducer first.. is it breaking change? Or it was always like that?\ndescribe('sagas/vendor', () => {\n  describe('put effect should not swallow', () => {\n    const sequence = [];\n    const errorThrowInReducer = new Error('an instance of Error');\n    const notErrorThrownInReducer = 'NOT Error, just a String';\n// create reducer which throws\nconst reducer = (state = null, action: any) => {\n  switch(action.type) {\n    case 'PLEASE_THROW_ERROR':\n      sequence.push('reducer: throw');\n      throw errorThrowInReducer;\n    case 'PLEASE_THROW_NOT_ERROR':\n      sequence.push('reducer: throw');\n      throw notErrorThrownInReducer;\n    default:\n      return state;\n  }\n}\n\n// create root saga and saga to put to the reducer\nfunction* oneSaga(action) {\n  sequence.push('oneSaga: start');\n  if (action.type === 'SAGA_PLEASE_THROW_NOT_ERROR') {\n    yield put({ type: 'PLEASE_THROW_NOT_ERROR' });\n  } else {\n    yield put({ type: 'PLEASE_THROW_ERROR' });\n  }\n}\nfunction* rootSaga() {\n  yield takeEvery(['SAGA_PLEASE_THROW_ERROR', 'SAGA_PLEASE_THROW_NOT_ERROR'], oneSaga);\n}\nconst safely = (originalSaga: any) => function* _safely() {\n  try {\n    yield originalSaga();\n  } catch(e) {\n    sequence.push('safely: catch error', e);\n\n    // Rethrow so we can check onError\n    throw e;\n  }\n}\n\n// create and run saga middleware\nconst onError = (e) => {\n  sequence.push('onError: called', e);\n};\nconst createNewStore = () => {\n  const sagaMiddleware = createSagaMiddleware({\n    onError\n  });\n\n  // create store with the reducer\n  const store = createStore(reducer, applyMiddleware(sagaMiddleware));\n  sagaMiddleware.run(safely(rootSaga));\n  return store;\n}\n\n\n// dispatch action to cause error\n// assert onError was called and error was propagated\nit('should call, not swallow, if reducer throws Error', () => {\n  expect(() => {\n    createNewStore().dispatch({ type: 'SAGA_PLEASE_THROW_ERROR' });\n  }).not.toThrow();\n  expect(sequence).toEqual([\n    'oneSaga: start',\n    'reducer: throw',\n    'safely: catch error',\n    errorThrowInReducer,\n    'onError: called',\n    errorThrowInReducer,\n  ]);\n});\n\nit('should call, not swallow, if reducer throws not Error', () => {\n  sequence.length = 0;\n  expect(() => {\n    createNewStore().dispatch({ type: 'SAGA_PLEASE_THROW_NOT_ERROR' });\n  }).not.toThrow();\n  expect(sequence).toEqual([\n    'oneSaga: start',\n    'reducer: throw',\n    'safely: catch error',\n    notErrorThrownInReducer,\n    'onError: called',\n    notErrorThrownInReducer\n  ]);\n});\n\n});\n});\n```\nv0.16.0 results\n``` bash\n\nNODE_ENV=test jest \"vendor.saga.test.ts\"\n\nFAIL  ./vendor.saga.test.ts\n  sagas/vendor\n    put effect should not swallow\n      \u2715 should call not swallow if reducer throws Error (25ms)\n      \u2715 should call not swallow if reducer throws not Error (2ms)\n\u25cf sagas/vendor \u203a put effect should not swallow \u203a should call not swallow if reducer throws Error\nexpect(received).toEqual(expected)\n\nExpected value to equal:\n  [\"oneSaga: start\", \"reducer: throw\", \"safely: catch error\", [Error: an instance of Error], \"onError: called\", [Error: an instance of Error]]\nReceived:\n  [\"oneSaga: start\", \"reducer: throw\"]\n\nDifference:\n\n- Expected\n+ Received\n\n  Array [\n    \"oneSaga: start\",\n    \"reducer: throw\",\n-   \"safely: catch error\",\n-   [Error: an instance of Error],\n-   \"onError: called\",\n-   [Error: an instance of Error],\n  ]\n\n  70 |         createNewStore().dispatch({ type: 'SAGA_PLEASE_THROW_ERROR' });\n  71 |       }).not.toThrow();\n> 72 |       expect(sequence).toEqual([\n  73 |         'oneSaga: start',\n  74 |         'reducer: throw',\n  75 |         'safely: catch error',\n\n  at Object.<anonymous> (vendor.saga.test.ts:72:24)\n\n\u25cf sagas/vendor \u203a put effect should not swallow \u203a should call not swallow if reducer throws not Error\nexpect(received).toEqual(expected)\n\nExpected value to equal:\n  [\"oneSaga: start\", \"reducer: throw\", \"safely: catch error\", \"NOT Error, just a String\", \"onError: called\", \"NOT Error, just a String\"]\nReceived:\n  [\"oneSaga: start\", \"reducer: throw\"]\n\nDifference:\n\n- Expected\n+ Received\n\n  Array [\n    \"oneSaga: start\",\n    \"reducer: throw\",\n-   \"safely: catch error\",\n-   \"NOT Error, just a String\",\n-   \"onError: called\",\n-   \"NOT Error, just a String\",\n  ]\n\n  86 |         createNewStore().dispatch({ type: 'SAGA_PLEASE_THROW_NOT_ERROR' });\n  87 |       }).not.toThrow();\n> 88 |       expect(sequence).toEqual([\n  89 |         'oneSaga: start',\n  90 |         'reducer: throw',\n  91 |         'safely: catch error',\n\n  at Object.<anonymous> (vendor.saga.test.ts:88:24)\n\nconsole.error node_modules/redux-saga/lib/internal/utils.js:240\n    uncaught at oneSaga Error: an instance of Error\n        at Suite.<...>\n        at process._tickCallback (internal/process/next_tick.js:188:7)\nconsole.error node_modules/redux-saga/lib/internal/utils.js:240\n    uncaught at oneSaga NOT Error, just a String\nTest Suites: 1 failed, 1 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        1.78s\nRan all test suites matching /vendor.saga.test.ts/i.\nnpm ERR! Test failed.  See above for more details.\n```\nv1.0.0-beta.1 results\n```bash\n\nNODE_ENV=test jest \"vendor.saga.test.ts\"\n\nFAIL  ./vendor.saga.test.ts\n  sagas/vendor\n    put effect should not swallow\n      \u2713 should call not swallow if reducer throws Error (9ms)\n      \u2715 should call not swallow if reducer throws not Error (12ms)\n\u25cf sagas/vendor \u203a put effect should not swallow \u203a should call not swallow if reducer throws not Error\nexpect(received).toEqual(expected)\n\nExpected value to equal:\n  [\"oneSaga: start\", \"reducer: throw\", \"safely: catch error\", \"NOT Error, just a String\", \"onError: called\", \"NOT Error, just a String\"]\nReceived:\n  [\"oneSaga: start\", \"reducer: throw\", \"safely: catch error\", \"NOT Error, just a String\"]\n\nDifference:\n\n- Expected\n+ Received\n\n  Array [\n    \"oneSaga: start\",\n    \"reducer: throw\",\n    \"safely: catch error\",\n    \"NOT Error, just a String\",\n-   \"onError: called\",\n-   \"NOT Error, just a String\",\n  ]\n\n  86 |         createNewStore().dispatch({ type: 'SAGA_PLEASE_THROW_NOT_ERROR' });\n  87 |       }).not.toThrow();\n> 88 |       expect(sequence).toEqual([\n  89 |         'oneSaga: start',\n  90 |         'reducer: throw',\n  91 |         'safely: catch error',\n\n  at Object.<anonymous> (vendor.saga.test.ts:88:24)\n\nconsole.error node_modules/redux-saga/lib/internal/utils.js:300\n    NOT Error, just a String\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 passed, 2 total\nSnapshots:   0 total\nTime:        1.891s\nRan all test suites matching /vendor.saga.test.ts/i.\nnpm ERR! Test failed.  See above for more details.\n``. @Andarist I think, it would be useful to add some example on howonError` is meant to be used. I saw, things like this, for example:\nconst sagaMiddleware = createSagaMiddleware({\n  onError: error => {\n    sendErrorReport(error);\n    throw error;\n  }\n});\nIn this case, throw has no effect at all (it is not even logged to console), but it seems it may be not obvious.. @Andarist\ncreated a PR, plz let me know if it is ok. ",
    "AriaMinaei": "Not sure if you guys have considered it, but capturing a proper stack trace with the correct line numbers along with the jumps between the effects can probably be done without a babel plugin. Promise libraries do it that way at least. Here is when's method for example.. ",
    "nathanmarks": "@Andarist It doesn't seem to be fulfilling. The saga returns true for isRunning() but done.then(() => ...) is never called.\n```js\n      console.log(store.injectedSagas.signin.task.isRunning()); // true\n  store.injectedSagas.signin.task.done.then(() => {\n    expect(usernameRequest.isDone()); // never called\n    done();\n  });\n\n```\nif you're wondering how I'm getting the result of sagaMiddleware.run(someSaga) as you see above, see here:\nhttps://github.com/react-boilerplate/react-boilerplate/blob/master/app/configureStore.js#L47\nhttps://github.com/react-boilerplate/react-boilerplate/blob/master/app/utils/sagaInjectors.js#L54\n. @Andarist Also, isRunning() is still true even with the effects have finished running.\nI suppose I miscommunicated my need: how do I wait for the running effects to be completed?. @Andarist \nThanks for the tip, that's definitely useful for some use cases! I am using takeEvery and takeLatest.\nThe problem I'm having using it in this specific use case, is that I have one effect that dispatches a SUCCESS action, and another side effect as a result of that success. When I dispatch END, that last side effect doesn't run.\nIs there a better way to set up these side effects so that they both run even after END is dispatched? Or will end halt everything immediately, even effects in progress?\n. ",
    "epiqueras": "@Andarist \nThe problem happens when waiting for a put or put.resolve effect to take place.\nHere is some code/flow to illustrate:\nI have a saga with takeLatest that waits for a FETCH action to start an async network request, wait for it to resolve and dispatch a RECEIVE action with the result.\nIn my tests I set up the store, middleware, etc, and mount the app.\nThen I trigger the FETCH and wait like this:\n```js\n// Flush all promises\nawait new Promise(resolve => setImmediate(resolve))\n// Tell sagas that we are stopping\nintegration.store.dispatch(END)\n// Wait for saga to terminate\nawait integration.rootSagaTask.done\n// Test assertions\n```\nThe problem is that put or put.resolve never finish. I can verify in the saga that the network request resolved and the payload was valid, but the saga gets stuck on the first put and then terminates without continuing.\nIf I use put and not put.resolve, I also get an error on react-dom where document is undefined when trying to use createEvent. I guess this is code running after jsdom is torn down.\nAny ideas?. ",
    "thchia": "I have a question related to this issue.\nIn my project I have a root saga that uses a  yield all([ takeLatest(...) ]) pattern.\nOne of the sagas triggered by the takeLatest is a looping function - it does something, delays for a specified period and then does that thing again. This appears to block the done from resolving. I'm not really sure why this is - is it because the while loop containing a call to delay is preventing the saga from terminating?\nRepro: (uncomment the function call in componentDidMount() to observe that 'DONE' is never logged.\nhttps://codesandbox.io/s/84894j3px9. ",
    "MortezaAghili": "My mistake was not exporting my action! . ",
    "atlanteh": "I don't see it in latest release. I'm assuming it hasn't been published yet to npm? Anyone can publish a new version?. Thanks for your supper quick response\nI'm trying it in a bit different way and it doesn't work for me:\n```\nfunction* uploadAdminPhotos(action) {\n    try {\n        const photos = action.payload.slice();\n        const photosChannel = yield call(channel, buffers.expanding());\n        const workers = [];\n        for (var i = 0; i < 5; i++) {\n            const worker = yield fork(uploadSinglePhoto, photosChannel);\n            workers.push(worker);\n        }\n    for (let i = 0; i < photos.length; i++) {\n        yield put(photosChannel, photos[i]);\n    }\n    photosChannel.close();\n    yield put({type: 'ALL_PHOTOS_UPLOAD_SUCCESS!!'});\n\n}\n``\nIn this case ALL_PHOTOS_UPLOAD_SUCCESS is dispatched before all. How do I wait for channel to finish all given work, close it and only then dispatch 'ALL_PHOTOS_UPLOAD_SUCCESS'?. WOW awesome!\nThanks a lot. Just one small fixup:yield join(workers)should be:yield join(...workers)`. I just read the releases notes, and I don't see this change in there. Can you please add it so if anyone upgrades, they will know to update this one as well? (Also, I think you should have an \"Upgrade\" link from v0.16 to v1 that will summarize all the upgrade processes needed. WDYT?. ",
    "zgavin1": "@Andarist Unless there's more info we want to include, this issue could be closed.. Yeah I just wanted to clean up the commit history, I. Not sure what I did\nbut it was ugly, I just got pulled away right before I was going to submit\nagain.\nOn Sun, May 20, 2018 at 6:08 AM Mateusz Burzy\u0144ski notifications@github.com\nwrote:\n\nAny reason why you have decided to close the PR?\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/1445#issuecomment-390470438,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJJsQkidL7tGWFzRu-IwIclcysBq3H2Jks5t0UC5gaJpZM4UF100\n.\n. @Andarist anything else I can add here for this issue?. Yeah, sorry didn't notice that.. The way to implement what you're trying to do is much simpler than you think. There's no need for the switch statement because Saga helpers like takeLatest and takeEvery only spawn a new saga when the first argument matches with the action your dispatched to the store.\n\n```\nfunction ordersRequestSaga() {\n  yield takeLatest(OrderData.RequestType.Open, fetchOpenOrders);\n  yield takeEvery(OrderData.RequestType.OtherRequestType, fetchOtherRequests)\n}. Thank you @Andarist. I'm just starting to do more open source work, thanks for all your feedback and your responsiveness \ud83d\ude04 . Hey @tastafur I just actually wrote some docs to help explain this here: https://github.com/redux-saga/redux-saga/blob/master/docs/advanced/RootSaga.md. But I realized that I never added a link to  this page to the Table of Contents. I will make a PR for that asap.. @Andarist I'm also curious how I update the docs with Gitbooks?. @tastafur: @shinima has it. That would be very help to include that information in the docs page, as I totally agree with you. I was halfway through commenting here that there probably should be an example of a root saga that yields just an array of fork effects, rather than passing an array of them to a call effect. You articulated it it better than I could.. Well the context here is to reference the root saga implementation in the tutorial, just as a jumping off point. I could use stronger language to suggest that this way is is not* recommended, but it seems necessary to include atleast some type of nod to the tutorial's root saga.. Very cool, thank you for pointing me to that thread. The compositional wrapper proposed look like a pretty cool solution.\nI will do my best to integrate that information while trying to stay on the topic of root saga implementations and not going to deep into error handling strategies.. ",
    "AdamPflug": "So most of my experience with Generators is from Koa v1 (which delegated a lot to co), but I remember exceptions bubbling up through the levels of middleware in that case - and it was super super handy. You could catch errors at any level, which let you choose to handle them based on where it made sense for that class of error (and reduced a lot of the boilerplate around handling similar errors). I'd love it if I could do something similar with sagas.\nThat said, I think they're basically converting all their generators to promises with co.wrap and hooking into the error handling behavior of promises to implement this - not sure that's possible for saga since I haven't dug into the implementation details. . ",
    "dimpiax": "Here is the possibility to differ your action by key: @@redux-saga/SAGA_ACTION,\nwhich every saga action has after put function.\nFor example, you can write next reducer:\nexport default (state = {}, action) => {\n  if (action['@@redux-saga/SAGA_ACTION'] !== true) return state\n  ...\n}\nOr use the custom wrapper function around reducer:\n```\nconst permitSaga = (cb) =>\n  (state = {}, action) =>\n    action['@@redux-saga/SAGA_ACTION'] ? cb(state, action) : state\n...\npermitSaga(reducer)\n```\n@Andarist @yelouafi will this key deprecated or it's stable action key?\nUPDATE\nAs I am seeing there are reserved symbols, such as: SAGA_ACTION, CANCEL_PROMISE etc\nIs it necessary to include this permit function into the library, what do you think?. Here is the possibility to differ your action by key: @@redux-saga/SAGA_ACTION,\nwhich every saga action has after put function.\nFor example, you can write next reducer:\nexport default (state = {}, action) => {\n  if (action['@@redux-saga/SAGA_ACTION'] !== true) return state\n  ...\n}\nOr use the custom wrapper function around reducer:\n```\nconst permitSaga = (cb) =>\n  (state = {}, action) =>\n    action['@@redux-saga/SAGA_ACTION'] ? cb(state, action) : state\n...\npermitSaga(reducer)\n```\n@Andarist @yelouafi will this key deprecated or it's stable action key?\nUPDATE\nAs I am seeing there are reserved symbols, such as: SAGA_ACTION, CANCEL_PROMISE etc\nIs it necessary to include this permit function into the library, what do you think?. ",
    "gauravsaini": "https://github.com/redux-saga/redux-saga/blob/2d33852ed9057e104f34a24987a8e410a1069783/index.d.ts#L71. ",
    "MarcoNicolodi": "I think this PR should be reopened. As I followed the documentation, i started the testing section, and it tests the incrementAsync saga. Therefore, incrementAsync should be also exported. Should we add and export to all functions of the saga so they can be imported individually for testing purposes? I think if we dont, people would be misguided that they should erase the individual exports, making the test in the documentation to fail. \nSorry i didnt notice it early. . ",
    "dyesseyumba": "@aikoven if I comment all union members in line 152 except F  of effect.d.ts ; I've got this error message :\ntypescript\nTS2345: Argument of type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...' is not assignable to parameter of type 'CallEffectNamedFn<{ [x: string]: Func0; }, string>'.\n  Type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...' is not assignable to type '[{ [x: string]: Func0; }, string]'.\n    Property '0' is missing in type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...'.\nI also try to comment union members in line 157 like this, \ntypescript\nexport type CallEffectNamedFn<C extends {[P in Name]: Function},\n                              Name extends string> =\n  [C, Name] // | {context: C, fn: Name};\n I've got this error message:\ntypescript\n TS2345: Argument of type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...' is not assignable to parameter of type '[{ [x: string]: Func0; }, string]'.\n  Property '0' is missing in type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...'.\nThen I also tried to comment the lines from 176 to 200 in the same file like this\n typescript \n /* <C extends {[P in N]: Func0}, N extends string>( ... ...rest: any[]): R; */\nI've got this error\ntypescript\nTS2345: Argument of type '{ <A extends Action>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffect; <A, T1>(pattern: Patt...' is not assignable to parameter of type 'Func0'.\nThen I tried to change the line of the same file from \ntypescript\n(fn: CallEffectFn<Func0>): R;\n to\ntypescript\n(fn: CallEffectFn<any>): R;\n and all error message disappeared.\nI hope it'll help.. Yes, you right. I used takeLatest directly and it works well. thank you.. ",
    "chibuezeayogu": "Thanks @ianhowe76 for your response. When i tried that this was the error I got. \n```\nconst userData = {\n  email:'chibuezeayogu@hotmail.com',\n  password: 'Computer123.@'\n};\ndescribe('User Saga', () => {\n  const test1 = signIn();\n  it('should make api call to login user', () => {\n    expect(test1.next().value).toEqual(call(axios.post, '/api/v1/users/signin', userData));\n  });\n  it('it should return the details of the fetched user', () => {\n    const response = {\n      data: {\n        message: 'Logged in Successfully',\n        token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJlbWFpbCI6ImNoaWJ1ZXplYXlvZ3VAaG90bWFpbC5jb20ifSwiaWF0IjoxNTE3NzMzNTAzLCJleHAiOjE1MTc4MTk5MDN9.6mp08yP3BgYJ1b_pBU_-8YgGumddONWlfGdoo8G9SoA'\n      }\n    };\n    expect(test1.next().value).toEqual(put({ type: actionTypes.SIGN_IN_SUCCESS, user: undefined }));\n  })\n  it('should be done', () => {\n    expect(test1.next().done).toEqual(true)\n  })\n});\n```\n\n So I think the first test is not passing to it is entering the catch block . ",
    "clearwaterstream": "great thank you, let me give it a try ... ",
    "wbowlin": "As an aside, this code does not wait for your items options to be processed before returning out of the resetPositionsAsyncAwait function due to the use of async / await within the forEach. That could cause subtle timing bugs since you are dispatching a fulfilled action type possibly before those calls are all done. \nAlso, the way you have the saga yielding calls to Firebase is good as it allows you to easily test the saga without having to worry how to mock out Firebase itself.  . ",
    "callagga": "thanks for the feedback - actually there was one suggestion I'd got/implemented since I posted, which hopefully addresses your first comment?  Does this look better?\n```\nasync function resetPositionsAsyncAwait() {\n  const db = firebase.firestore();\n  const collRef = db.collection('todos');\n  const query = collRef.orderBy('position');\n  const batch = db.batch();\n// Step 1 - Read document data and prepare batch updates\n  try {\n    const items = await query.get();\n    let newCount = 0;\n    items.forEach(async (doc) => {\n      const docRef = collRef.doc(doc.id);\n      batch.update(docRef, { position: newCount });\n      newCount += 1;\n    });\n  } catch (error) {\n    console.log('resetPositionsAsyncAwait (during Step 1): error caught. Error=');\n    console.log(pf(error));\n  }\n// Step 2 - Run batch update\n  try {\n    await batch.commit();\n  } catch (error) {\n    console.log('resetPositionsAsyncAwait (during Step 2): error caught. Error=');\n    console.log(pf(error));\n  }\n}\n```\n. thanks for the feedback - actually there was one suggestion I'd got/implemented since I posted, which hopefully addresses your first comment?  Does this look better?\n```\nasync function resetPositionsAsyncAwait() {\n  const db = firebase.firestore();\n  const collRef = db.collection('todos');\n  const query = collRef.orderBy('position');\n  const batch = db.batch();\n// Step 1 - Read document data and prepare batch updates\n  try {\n    const items = await query.get();\n    let newCount = 0;\n    items.forEach(async (doc) => {\n      const docRef = collRef.doc(doc.id);\n      batch.update(docRef, { position: newCount });\n      newCount += 1;\n    });\n  } catch (error) {\n    console.log('resetPositionsAsyncAwait (during Step 1): error caught. Error=');\n    console.log(pf(error));\n  }\n// Step 2 - Run batch update\n  try {\n    await batch.commit();\n  } catch (error) {\n    console.log('resetPositionsAsyncAwait (during Step 2): error caught. Error=');\n    console.log(pf(error));\n  }\n}\n```\n. ",
    "erikmajlath": "Hey @kg912 !\nGenerally speaking if you are not subscribing to changes ( realtime database .on/firestore .onSnapshot ) you do not need to use channels. You can simply\nconst doc = yield firebaseDatabase().ref('/users/' + payload.id).once('value')\nIf you would be reading data using on you would need to use channel. In realtime database you can unsubscribe with off method as noted there https://firebase.google.com/docs/database/web/read-and-write\n\nCallbacks are removed by calling the off() method on your Firebase database reference.\n\nThus channel could look something like this\n``\nconst createUserChannel = userId =>\n  eventChannel(emit => {\n    const ref = firebaseDatabase().ref(/users/${userId}`)\n    ref.on('value', snap => {\n      emit(snap.val())\n    })\nconst unsubscribe = ref.off()\nreturn unsubscribe\n\n})\n```. ",
    "rsheldiii": "I'm having issues with this as well.\nThe docs are a bit ambiguous on what is actually wrong with using select, and if select is the problem at all. They state that:\n\nPreferably, a Saga should be autonomous and should not depend on the Store's state.\n\nWhich is true, tying a single saga to your whole state structure is bad, you'd need to refactor all the time. But it was bad for connected components already, before redux-saga existed. That's why selectors are so useful, and indeed the docs immediately launch into an example implementation of a getCart selector, and how: \n\nThe Saga is coupled only with the getCart selector. If we have many Sagas (or React Components) that needs to access the cart slice, they will all be coupled to the same function getCart. And if we now change the state shape, we need only to update getCart.\n\nWhich is also true.\nbut where does that leave us with select? If we are now only coupled to the selector, is it still preferable to not use select? If so, why? it has the same amount of surface area to refactoring as a connected component that consumes the same resources.\nI'm currently working on an application that uses JSON-API and redux saga, with a paginated list of objects. deep in the component hierarchy, there is an infinite scroll component that needs to trigger a saga to get more objects. let's say the component hierarchy looks like this:\n<Application>\n  <Page>\n    <ObjectListContainer>\n      <DetailsPane />\n      <RelationshipPane>\n        <InfiniteScrollContainer>\n          <list>\n            <object key=\"object1\">\n            <object key=\"object2\">\n          </list>\n          <infiniteScrollTrigger />\n        </InfiniteScrollContainer>\n      </RelationshipPane>\n    </ObjectListContainer>\n  </Page>\n</Application>\nObviously very simplified.\nCurrently, InfiniteScrollTrigger will trigger the getMoreObjects saga when it comes into view. that saga uses select to grab the url for the next page of objects saved in state, queries that url for more objects, and uses a put call to append them to the list of objects, refreshing the list and starting the cycle anew. According to one of my work buddies, this is an anti-pattern, since he doesn't use select in his sagas at all.\nLet's say I want to refactor my saga so that I don't use select. ObjectListContainer already has a reference to the list object to display data about it, so I just get the url from there and pass it down. Is my application really better if I ferry the url all the way down to the InfiniteScrollTrigger? ObjectListContainer, RelationshipPane, and InfiniteScrollContainer all don't care about the url (however it is required, so it will need to be in their PropTypes) and InfiniteScrollTrigger only uses it to dispatch to the saga.\nInstead, I refactor to connect the InfiniteScrollTrigger, pulling the url in directly. Now I'm not passing it down, but is my application still any better? I've made a static component now re-render any time we fetch more objects, and if the underlying state changes in a way that causes getMoreObjects to change I still have to refactor, I just do it in a different place. Plus, what if the saga needs a lot of state instead of just a single url? now I've got this throwaway component connected to the store that knows about all these things it shouldn't, just to make it so that a redux-saga doesn't have to use select. I reuse components more than I reuse sagas, so I'd prefer to keep the former generic if I can (though obviously that's not always feasible).\nIs there another data management scheme I'm missing that makes avoiding select a clean and viable way to structure your applications? I would love to reduce the complexity of my sagas, but for the reasons outlined above I haven't been able to without introducing needless complexity.. ",
    "JonathanMontane": "I don't think that everyone uses tree-shakers, although people probably should, so this may have a negative impact on some users.\nThis duplication of compose also guarantees that the maintenance of this project is not impacted by changes in the redux API or publication issues (I'm thinking of the left-pad incident for instance).\nI agree that the peerDep is probably too much and you could probably remove the dependency altogether.. ",
    "AvalonCV": "Hi there,\nthanks for takeLeading - this is just what I was looking for. My IDE is still a bit uncertain about it, so I want to ask if it would be possible to add takeLeading to the effects typescript definitions as well? I assume this could be a simple one-liner (just as takeLatest is).\nBest regards. Thanks as well.. ",
    "stat92": "Great, thanks!. ",
    "HsuWai": "Thans for your answer, Andarist. The request library used is axios. I've tried to handle and dispatch action for 204 response in the response interceptor of axios. That's ok for all actions. But, I don't want this behavior and I just want to intercept at some saga effects, not for all. Is there any way to handle like that? .  I mean I just want to intercept for saga some call effects. . Ok. Thanks, Andarist. . ",
    "championboylay": "Where can I get working example?. ",
    "zerkms": "Somebody else has provided me a link to the typescript issue https://github.com/Microsoft/TypeScript/issues/2983#issuecomment-230404301\nSo, at the moment it's a typescript limitation.. ",
    "augbog": "@yelouafi sorry for the ping but was wondering if this PR aligns with some of the comments made in the issue above? If not feel free to reject :) . @yelouafi sorry for the ping but was wondering if this PR aligns with some of the comments made in the issue above? If not feel free to reject :) . Thanks @Andarist! :) and no worries! You guys are awesome :D. Thanks @Andarist! :) and no worries! You guys are awesome :D. ",
    "trassmann": "@Andarist Yes, but since I am using ducks that is not really an option. The problem lies not within the circular dependency per se, I just feel that creating circular dependencies is a sign of bad design, and since this is within the very foundation of the app, I want it to be designed solidly. Do you have any ideas how else I could solve this issue?\nThanks for your answer.. Yes, authentication also uses the request handler to send its requests. But the API will never respond with a 419 on an authentication request. After thinking about it and talking to you I see two possibilities:\n\nDon't implement authentication using the requestHandler, instead use sendRequest directly.\nTake the whole re-auth logic out of the requestHandler and implement  a generic error handler that all sagas use to handle errors. This error handler would handle 419. But it would also mean that I'd have to use it in every saga that sends a request, which would mean duplicating code.\n\nDo you have any other ideas? Which of the two options would you go for?. @Andarist Thank you for your advice. It is appreciated.. ",
    "kafka-tamura": "Thanks @Andarist. . ",
    "LKiening": "Thank you for the fast answer! Good to know that nothing bad will happen if i dont call the put method.\nYour idea would be my fallback option. Since every app is developed by a independet team and every  app runs in a container, its diffucult to make assumptions on the globalEventDispatcher level.\nAgain thank you for the reply :)\n. You are absolutly right. But i simple dont know what teamX does in its sagas. They can call\n- put\n- globalEventDispatcher.dispatch\n- or both of them\nIf the globalEventDispatcher doesnt dispatch actions to its origin store, the teams have to call both methods if they want the action local and globally distibuted. \nI guess its a question of convention and communication what the teams have to do to get the desired effect.. ",
    "fdesrosiers": "Thanks a lot @Andarist, my nearly zero experience with TS in nearer of zero than yours.\nthanks again !. ",
    "enrique-ramirez": "Hello @Andarist \nI tried to create a slimmed down repo and couldn't reproduce the issue. Here's the repo: https://github.com/enrique-ramirez/redux-saga-demo it works fine, though.\nAfter some tests on my own repo, it seems to be a problem ONLY in development mode, for some reason. Production builds work fine. I've created a slimmed version of my repo (it's still quite heavy, sorry for that) in case you have some time to help me out figure out what's wrong: https://github.com/enrique-ramirez/react-redux-boilerplate\nTo reproduce the issue, just install dependencies, run yarn start:dev and once the bundle completes, open http://localhost:8080\nIf you open your console, you'll see the error I mention, along with some console logs. If you then open src/store/configureStore.js and change the line from createSagaMiddleware() to createSagaMiddleware.default(). It'll work. Webpack configurations are in config/webpack/.\nAny help would be greatly appreciated, if only just to point me into the right direction. Sorry for the trouble!. Hello @Andarist \nThank you. Indeed, removing the mainFields config (which I can't remember why I set in the first place) works fine. Sorry for the trouble!. ",
    "froatsnook": "In case someone else runs across this, I had a similar error until I removed optimization.concatenateModules: true.  ~~~Which is strange because I have mode: \"development\" and I thought module concatenation was production only.~~~ It's on by default in production but setting optimization.concatenateModules: true also enables it in development.\n. ",
    "paulwalczewski": "Thanks @froatsnook! I've wasted nearly 5 hours to find the issue wrongly thinking I've either broken my sagas while refactoring or there is something wrong with webpack... and your answer guided me where the issue actually was!\nIn my case, I had concatenating enabled with plugins\nnew webpack.optimize.ModuleConcatenationPlugin()\nmoving that into production-only case solved the issue.. ",
    "jcarroll2007": "Thanks for the suggestion @Andarist. Is that symbol the only one that will be present on an action? I don't need to check for any other symbols?\n\nIs there any reason why do u want to copy this object? Wouldnt it be easier to just mutate it?\n\nI could mutate it, but I'd prefer not too. I don't want to cause any side-effects.\n\nWhy is it happening in the middleware? Shouldnt this be handled by action creator?\n\nSpecifically, the middleware I'm using is redux-normalizr-middleware. The idea is that the action-creator will add some meta information that is used by this middleware to wrap the payload.. Thanks for all of the great points. I think I will just mutate the action. \n\nLooking into its code and it doesnt seem there is a reason to do this in the middleware, this would make it way easier to reason about if that normalizing could happen in action creator, seems more appropriate. I might be missing some use case, but at first glance this makes code more convoluted (action creation is becoming a 2 step process)\n\nYeah, that's a good point.\nThanks for all of the help @Andarist. . ",
    "emlmsc": "@Andarist \nNext example that is described here also for demonstration purposes of power of the redux-saga? Because i didnt see any web site that show to user logout button until he authorized on web site.. @Andarist \nIn my opinion, even if examples are basic and showed just for demonstration purposes of the system, they must fit real needs. These examples looks like not fit real cases and second example is too complicated while in real case its not even necessary to catch logout action while authorization not complited yet because any website wont show logout button to nonauthorized user. May be its better to show another examples to demonstrate the power of redux-saga that fit actual cases of real world. But its up to you. I just got confused a little bit when reading these examples, because i started to doubt my vision of login/logout flow. So, thanks for replying. I appreciate it.. @Andarist \nAs example it can be tutorial on web site that introduce to user something step by step. Or another example registration of user on web site step by step, when user firstly input its fullname and other info, then in second step upload avatart and further.. ",
    "MJLHThomassen-Eurocom": "Hmm, this is strange. I've implemented the example here: https://codesandbox.io/s/wn6yzky9mw\nBut it seems to work as it should. If i paste the code into my own project it does not... (using the same versions of all the packages of course). Could it have something to do with the typescript transpiler perhaps? I can't configure that in the online tool. I've also setup my project using create-react-app, but using the typescript variant react-scripts-ts.. Unfortunately i can't share the actual repo since its an internal product for our company. I can however try to setup a project with a similar setup but minimal code and put it on github to share with you. I'll try to look into that today.\nI'd debug it myself but i currently have 0 knowledge about redux-saga internals and unfrotunately not the time to dive into it. I apreciate any help!. Sorry for that, our company currently is not actively developing that product anymore so I had no time to properly reproduce the issue. Its been a while and I don't remember how this was solved but I think I was able to work around it somehow.  Closing this is fine.. ",
    "chacestew": "Reading https://github.com/redux-saga/redux-saga/issues/1117 this does seem to confirm the behaviour that all basic takes will terminate when END is dispatched via the stdChannel, so I'lI scrap that question.\nBefore closing - is there any intention for this behaviour to change in v1, relating to https://github.com/redux-saga/redux-saga/pull/824 or others? If there is anything already in beta to change or extend how END works, I'd be keen to test it in our implementation.. ",
    "borovik96": "Thank you a lot, it works with manualy looping. ",
    "hendywijaya": "To give more detail these are some sample of my Sagas:\nCategorySagas.js\nexport function* fetchCategoryAPI (api, data) {\n  yield baseFetchNoToken(api.getCategory,\n    data,\n    CategoryActions.categorySuccess,\n    CategoryActions.categoryFailure)\n}\nBaseSagas.js - universal style Sagas\nexport function* baseFetchNoToken (api, data, successAction, failureAction) {\n  try {\n    const res = yield call(api, data)\n    if (!res.ok) {\n      yield put(failureAction('system error'))\n    } else {\n      if (!res.data.error) {\n        yield put(successAction(res.data.data))\n      } else {\n        yield put(failureAction(res.data.message))\n      }\n    }\n  } catch (e) {\n    yield put(failureAction())\n  }\n}. Hi Guys,\nEven when enabling just a single store dispatch calling a single Sagas repeatedly, this error still occurs. Hi @Andarist \nterribly sorry for late response, here's my sample repo -> https://github.com/hendywijaya/redux-maxcallstack\nthe issue starts to happen once we do concurrency test (using siege).\nIn the sample repo, I simulate the api callback section using returning an object.\nother modules in use are:\nexpressjs\nnextjs\nredux\nredux-sauce\nreactjs. Hi @Andarist \nSorry, it was included in .gitignore, I've added the file now \ud83d\ude05. Hi @Andarist sorry being slow responding. I'm actually in the middle of tracing similar issue that happens in my other application with smaller load. Will post back my finding here. \nAs for the siege, it's actually a simple siege test with 10 concurrent \nhttps://www.joedog.org/siege-manual/\n. hi @Andarist \nSure, I'll try to make it simple.\n\nbuild nextjs by running npm run build .\nstart app by running node start.js\nload test the application using siege -c 50 -i -f urls.txt\n\nto install siege on macosx using homebrew -> brew install siege\nto install siege on windows -> https://github.com/ewwink/siege-windows\nto install siege on linux, use apt-get or yum accordingly\nduring the process of running siege the application will be hit multiple times by this load testing tool. \nCMIIW, If we look at the error message, it happens immediately after a max call stack size overflow in recursion part of sagaMiddleware.run \nsagaMiddleware.run is called in my application sample by next-redux-wrapper part of the code in  src/Shared/Utils/Misc/ReduxWrapper.js. Hi @Andarist \nI've managed to avoid the issue by raising the v8 stack size when running my application. It seems that the default size is too low.\nHowever, I'm still investigating on the recursion max call stack error. Can you please enlighten me on this part of redux-saga/lib/internal/middleware.js:67\nreturn function (next) {\n      return function (action) {\n        if (sagaMonitor && sagaMonitor.actionDispatched) {\n          sagaMonitor.actionDispatched(action);\n        }\n        var result = next(action); // hit reducers\n        sagaEmitter.emit(action);\n        return result;\n      };\n    };\nWhen will those two recursion expected to end ?\nThanks for your awesomeness!. Hi @Andarist no worries, I'm trying to debug and log more information about this.\nThe error message suggests that a max call stack has been exceed. on these lines of code:\nRangeError: Maximum call stack size exceeded\n    at /node_modules/redux-saga/lib/internal/middleware.js:68:23\n    at /node_modules/redux-saga/lib/internal/middleware.js:72:22\nI've managed to avoid / suppress the error by increasing the v8 stack size. Would this be the required setting to safely run a server side rendered redux saga application?. Hi @JulianKingman \nCan you confirm you have the verbatim error message as:\nRangeError: Maximum call stack size exceeded\n    at /node_modules/redux-saga/lib/internal/middleware.js:68:23\n    at /node_modules/redux-saga/lib/internal/middleware.js:72:22\nAlso, please share more information about your application, what other modules are you using primarily, etc.\nCan you replicate this issue easily, or is this something that happen intermittently ? And following my dirty solution, does increasing your v8 stack-size prevent such error ?\n. Hi @Andarist \nsorry minor typo, the correct filename is url.txt, thus you can run the siege as follows:\nsiege -c 50 -i -f url.txt\nThanks!. Hi @Andarist \nThanks for pointing that out! Apparently, yes that exactly is the issue!\nSorry for all the hassle just for a scoping issue!\nSolved!. ",
    "JulianKingman": "I'm getting this error as well. A takeLatest in my root saga invokes a saga that yields to a promise, the result of which is put to a redux action, and causes the callstack error.\nSimplified code:\n```javascript\nfunction * root () {\n  takeLatest(SyncTypes.SYNC_START, startSync)\n}\nfunction * startSync (action) {\n  // promise returns object\n  const device = yield scanAndConnect()\n  console.log('got device', device)\n  // callstack error at below\n  yield put(SyncActions.deviceConnected(device))\n}\nconst deviceConnected = (state, ({device})) => {\n  // using immutable\n  return state.merge({device})\n}\n```\nAny ideas?. ",
    "mayk93": "The definition order is the same as in the example. Indeed, hoisting is one of the hypothesis I discussed here.. @epikhighs In this case, the unit test is irrelevant, because even if I comment out the test and only leave the import, the error still occurs. I will actually close this issue because I asked this question on stack overflow as well and the answer I got there is what @GaelS suggested, so I think hoisting is a reasonable explanation for this.. ",
    "farzadmf": "Thanks for the reply; your suggestion would work if onGetCameras is a Promise, but when I have to manually specify my two callbacks to it, then I need to define those functions and somehow call them. Thank you for your reply, I asked the question on SO and I got an answer, and it turns out that I can use cps to work with callbacks,\nHere's the link to the question. ",
    "NeoLegends": "I'd like to have something like a combineLatest effect!\nIt would allow listening to multiple action types and would return an object like the one returned from race as soon as its got one action of every type. If it encounters one action multiple times it'll take the latest one.\nWe can currently emulate it with something built on fork, but the semantics aren't as cool as a proper effect because we cannot return anything custom through yield.. > This would match rx semantics, right?\nExactly.\n\nNot sure if I follow could u explain?\n\nAs far as I currently understand redux-saga, I cannot have true user-defined effects that return data through the yield like:\n``js\n// Not possible to return data through yield from the library user perspective today\n// because combineLatest is just a library function that usesfork` and not a real effect\n//                         \u21e3\nconst { action1, action2 } = yield combineLatest({\n  action1: 'DO_SOMETHING_1',\n  action2: 'DO_SOMETHING_2',\n});\n// use action1, action2\n```\nInstead, as a user, I must always pass a saga as parameter that is invoked / forked with the data like:\n```js\nyield combineLatest(\n  { action1: 'DO_SOMETHING_1', action2: 'DO_SOMETHING_2' },\n  function*({ action1, action2 }) {\n    // use action1, action2\n  },\n);\n// cannot use action1, action2 here :/\n```\n\nThe idea seems good, I always wanted to implement more built-in helpers. Do you want to work in this?\n\nSounds good. :) I'll see what I can do.. > it assumes that u'd like to handle result of the combineLatest at the yield site, but that way we wouldn't be able to implement easily long-running effects (like combineLatest). Generators are kinda state machines and by advancing from yield combineLatest(...) state to another we wouldn't be able to resolve combineLatest again when new action would happen.\nI don't think I understand what you mean. Why can't the combineLatest-effect not resolve when its got all the actions it needs? combineLatest is meant to be a blocking effect.\nOnce combineLatest resolves there should be no more listening for further actions? It's like \"Please give me this set of actions and wait until you've got at least one of every type.\" It's like a take for multiple actions, but with an AND behavior instead of the OR-behaviortake works like today.. I've already got it as library implementation. It's just that the semantics aren't nice because I have to pass the rest of the saga as parameter to the effect, which introduces problems with cancellation and so on and so forth. :)\n\nI think (not sure though) that it should be possible to do what u want, u'd have to use internally fork and return join(forked) to the yielder.\n\nGreat! I'll see what I can do.. ",
    "garyhogarth": "Yes this is on a real device with the packager running on my local machine.. Doing some tests, it could very well be to do with setTimeout/setInterval being called properly with RN on android. \nsetInterval(() => console.log('test'), 1000); stops firing the second I put the app into the background.. ",
    "cwmacdon": "I should note that this problem exists in 0.16.0 as well as 1.0.0-beta.0. @aikoven OK cool thanks for the quick response. I had taken a look at the history of the effects.d.ts file and noticed there had been some changes around the types and arity. Wasn't sure if there was any new stuff that the TS team had maybe introduced that could help, if they were now failing in this case.\nI'll do the workaround for now. I'm cool with closing this.\nCheers!. ",
    "Revinand": "Thank you for the great library!. ",
    "hoodwink73": "Hey @Andarist \nThanks for your efforts in Redux Saga.\nWill you be open to adding a small section in the docs detailing why redux-saga uses generators over async/await and a disclaimer that we will not be using async/await?\nThere is a similar question raised in StackOverflow too.. Absolutely. Will raise a PR.. Hey, @Andarist I have made the requested changes. Let me know if there is any other way I can improve on this.. Hey @OriAmir \nI have a question. Is new Fingerprint2().get() synchronous? What does the get return?\n. Looking at the source code of fingerprint2.js it doesn't look like get returns a Promise.\nSo, maybe you should try out @shinima's code.. ",
    "sincerekamal": "@Andarist Interested and eager to know what much more things redux-saga is doing with generators which is tough or impossible with async/await. ",
    "antialias": "\nu can even call its return method\n\nreturn is a statement.. Cool! I'm apparently still learning about this stuff. Thanks @Andarist . ",
    "ceefour": "@Andarist I'm sorry to use this as a question, but I'd like to know how to do \"await\" with redux-saga ?\nWhat I mean is, by dispatch()-ing an action, redux-saga will run it in background.\nThe problem is, I'd like the button (or whatever is the UI), to \"await\" the saga.\nIn essence:\ntypescript\ntry {\n  await dispatchSomething();\n  console.info(\"Yay it's done\");\n} catch (err) {\n  console.error(\"Saga gave me error:\", err);\n}\nCurrently I'm doing something like this instead:\ntypescript\nreturn new Promise((resolve, reject) => {\n  dispatchSomething(resolve, reject);\n}).then(res => console.info(\"Yay it's done\"))\n.catch(err => console.error(\"Saga gave me error:\", err));\nand the saga must call the given resolve / reject from the action, which seems to be weird...\n. ",
    "TechyTimo": "Turns out I was fetching \"takeEvery\" from \"redux-saga/effects\" instead of from \"redux-saga\".. Turns out I was fetching \"takeEvery\" from \"redux-saga/effects\" instead of from \"redux-saga\".. ",
    "oneEyedSunday": "Having same problem. Well I was using action creator functions, found out I wasnt calling dispatch. ",
    "objectivesheep": "Same here.... ",
    "mostafaebrahimi": "Same issue...\n. @johnnyBira May you show us watcher registration  using saga middleware and more?. ",
    "johnnyBira": "Same issue. I tried @Rohithzr theory in issue #1425 by completely removing react-navigation, but still no luck I'm afraid.\nEdit:\nMy issue was I forgot to yield  in my watcher saga.\njavascript\nfunction* watchAddTie() {\n  takeEvery(\"USER_FETCH_REQUEST\", addToDo);\n}\nShould be:\njavascript\nfunction* watchAddTie() {\n  yield takeEvery(\"USER_FETCH_REQUEST\", addToDo);\n}. @moatafaebrahimi it was my mistake, now working according to the edit adove.\nI\u2019m just curious, if using Redux 4, is it adviced to update to the beta of redux-saga? Both latest and beta seam to be working fine in my case, but I was just thinking sine the latest Redux is using the new context API etc.. ",
    "nchevobbe": "Thanks for your answer @Andarist . ",
    "titulus": "related to #1490. related to #1490. ",
    "liyun074": "@sagarpatel8384   I also encountered the same problem, how do you solve it?. ",
    "anuragb26": "Facing the same issue \nBelow is my saga handling.\nexport function* watchInstanceDataSetAssocSaga() {\n  yield takeLatest(\n    actionTypes.FETCH_INSTANCE_DATASETS_ASSOC_INITIATE,\n    fetchInstanceDataSetAssocSaga\n  )\n}\nconst actionWatchers = sagaMiddleware => {\n  sagaMiddleware.run(watchInstanceDataSetAssocSaga)\n}\n```\nfunction* fetchInstanceDataSetAssocSaga(action) {\n  console.log('in saga')\n  const {\n    paginationParams: { url }\n  } = action\n  // Call api \n}\nComponent which fires the action is as follows\nexport class InstanceDatasetsAssoc extends Component {\n  componentWillMount() {\n    console.log('in componentWillMount')\n  }\n  componentDidMount() {\n    if (!this.props.records.length) {\n      console.log('in did mount')\n      const {\n        pageInfo: {\n          first: { url }\n        }\n      } = this.props\n      let paginationParams = {\n        url\n      }\n      this.props.onFetchInstanceDataSetAssoc(paginationParams)\n    }\n  }\n```\nThe console statements i get are as follows.\nin componentWillMount\nin saga\nin did mount\nin saga\nI get the \"in saga\"  twice\n. ",
    "melkristian": "Thanks, @Andarist . Let me try the using effects and see if that works for me better than using a sequence of yield*.. @Andarist , I think I've figured out the issue. My actual usage is trying to reuse sagas from a different container and an unmoun/remount occurs in the current saga. That's why the saga does not continue further.. I probably oversimplified my example. But consider the example below:\nfunction* myTestGen() {\n  try {\n    yield* anotherGenerator();\n    yield call(someFunc);\n  } catch(err) {\n    yield call(someAction(err));\n  }\n}\nWhen testing, anotherGenerator() should have tests of their own. But when testing the generator above, calling .next() takes me to the first yield of that generator but what I really want to get to test that anotherGenerator() has been ran.\nThe common scenario that we usually test is testing the result of a task and match that description like yield call(someFunc) could easily be tested because it results to a task description whose equality can be asserted.\nit('should yield anotherGenerator', () => {\n  const g = myTestGen();\n  g.next(); // this is the yield* anotherGen() part\n  expect(g.next().value).toEqual(<call task description>);\n});\nShould we even use yield* anotherGen() or use yield call(anotherGen) instead?\nI apologize if I'm not completely explaining myself. Thank you for taking the time. :). Great! Thanks a lot, @Andarist !. ",
    "hnordt": "@Andarist thank you!. ",
    "sharathchandramg": "Apologies, the issue was that I had not yielded on the fork.... . I found this way to handle the cancellation, I have forked function to listen to cancellation request. The cancellation request will be fired on unmounting of the component. \n``` javascript\nexport function* listenToNewMessages(action) {\n    let offizeId = yield select(sagaSelectors.getCurrentTeamId);\n    let data = { ...action.payload, offizeId: offizeId }\nconst incomingMessageEventChannel = chatAPI.incomingMessageEventChannel(data);\n\n// fork for closing the channel\n    yield fork(closeIncomingMessageEventChannel, incomingMessageEventChannel);\nwhile (true) {\n        const item = yield take(incomingMessageEventChannel);\n        yield put({ type: types.LISTEN_NEW_MESSAGE_SUCCESS, payload: item });\n    }\n}\nfunction* closeIncomingMessageEventChannel(incomingMessageEventChannel) {\n    while (true) {\n        yield take(types.LISTEN_NEW_MESSAGE_CANCELLED);\n        incomingMessageEventChannel.close();\n    }\n}\n```\nIs this approach right or is there a better approach?. ",
    "MichelSimonot": "Have you tried using call([context, fn/fnName], ...args)?\nI don't remember the details, but I've run into a similar problem. I believe this is expected/known, which is what the call([context, fn/fnName], ...) effects should help with.. I have a similar scenario, except my event is asynchronous, so I have a separate action to signify that the side-effect has finished (which makes my scenario simpler to handle than yours).\njavascript\n// Another saga does something async with 'DO_THING', then puts 'DO_THING_FINISH'.\nyield put('DO_THING')\nconst result = yield take('DO_THING_FINISH')\nIn the past, I've had to awkwardly use an action channel to make sure I catch an action. \n``` javascript\n// Setup an action channel to queue the \"finish\" signal before dispatching the action.\nconst channel = yield actionChannel('DO_THING_FINISH')\nyield put('DO_THING')\nconst result = yield take(channel)\n// The channel was just for the single-use, so clean it up.\nchannel.close()\n``\nAnd this was because of timing issues (DO_THING_FINISHcould be dispatched beforeDO_THINGfinishes in non-async scenarios). I don't do this anymore, but that's more to do with how my other saga handlingDO_THING` works.\n. This discussion also seems related: https://github.com/redux-saga/redux-saga/issues/1699. ",
    "fillippeyton": "That seemed to fix the issue. Kinda strange that I didn't find anything in my searching, pointing to special treatment for an instantiated class. Appreciate the reply! I'll close this issue.. ",
    "bondom": "Yes, my problem was that I tried to implement this task with saga and didn't know how to do it.\nFor task described above this can be easily implemented with deleteTodoListItem reducer and without some special saga watchers.\nBUT: suppose that we have possibility to add new todo items:\n1) User presses 'Add' button => request for adding new todo is being sent\n2) While first request is being sent user presses 'Delete' button on some item => request for deleting todo item is being sent.\nWe have two separate reducers for adding and deleting items, so implementation based on saving number of requests in reducers isn't a good solution\nSo to be able to wait until adding and deleting request will finish I created special watcher saga:\n```\nexport default function* getTodoListDueUpdateSaga() {\n  let processingRequestsNumber = 0;\nwhile (true) {\n    const action = yield take([\n      DELETE_ACTIONS.REQUEST,\n      DELETE_ACTIONS.GOT,\n      DELETE_ACTIONS.ERROR,\n      ADD_ACTIONS.REQUEST,\n      ADD_ACTIONS.GOT,\n      ADD_ACTIONS.ERROR\n    ]);\nswitch (action.type) {\n  case DELETE_ACTIONS.REQUEST:\n  case ADD_ACTIONS.REQUEST: {\n    processingRequestsNumber += 1;\n    break;\n  }\n  case DELETE_ACTIONS.GOT:\n  case DELETE_ACTIONS.ERROR:\n  case ADD_ACTIONS.GOT:\n  case ADD_ACTIONS.ERROR: {\n    processingRequestsNumber -= 1;\n    if (processingRequestsNumber === 0) {\n      // all requests are completed\n\n      // so we send request to get fresh todo list\n      yield put(req());\n\n      // clear deleting ids only after fresh todo list was requested\n      // it is needed to disable items in right way and\n      // avoid repeated deleting requests\n      yield put(clearDeletingIds());\n    }\n  }\n}\n\n}\n}\n```. @Andarist Please say what do you think about this approach. Thanks for response!. ",
    "max-winderbaum": "@Andarist How about this? It's much less intrusive and converts to an error right before the onError function!. I'm not sure why CI failed, but it looks like it's happening to more than just my PR - please let me know if there's something I'm doing wrong!. @Andarist Ok, this should do it!. Sending an error is important to not introduce a breaking change - we have no idea how many people in the world are expecting an Error object to be passed into onError, and I didn't want to break their code.. This also has the added benefit of sending up a stack trace so someone could attempt to debug what happened during the error based on that. ",
    "IvanJov": "@Andarist Hmm, okay. So on this line https://github.com/redux-saga/redux-saga/pull/1402/files#diff-91df1104cefdb22cf3dc49af49294dd9L282, there was already an import directly from redux-saga. Should I change it everywhere to redux-saga/utils?. @restrry Okay, that makes sense. I am not sure I understand what do you mean with that tutorial should be changed to use another function that returns a promise?. Gotcha, let me change that!. @Andarist @restrry Please check it again!. ",
    "OriAmir": "@shinima  I try with cps but it's looks the same.\nCan you give me example or something I can use ? no one use thing like that with saga never?\ntnx!. Hi , thank you all for your quick and great answers ..\nThe only soultion that work for is one that close to what @shinima write with promise that wrap the call:\nconst {result, components} = yield new Promise(resolve =>\n {\n  new Fingerprint2().get(function(result, components) {\n    resolve({result, components})\n  })\n})\n@Andarist your solution looks great , but when I try this it's not recognize 'cb' as a function , maybe I done something wrong?\ncb is not a function\nThanks all again . . ",
    "Shu-rup": "Finally could solve it by using delay in showLoading function and comparing state.data . ",
    "apaatsio": "I'm sorry I'm not sure where your exact problem is, but are you aware of redux-saga-firebase? It makes working with Firebase a bit easier. It also has great documentation.. ",
    "fjorgemota": "Wait a second.\nThis problem still happened on my machine while trying to install dependencies for #1419 (I did the git clone after this PR was already merged). I kind of solved by deleting the offending symbolic link and trying to run npm run bootstrap again, which worked nicely on my machine. Strange.. @Andarist I've tried yesterday before pushing #1319 (which included the current master before the PR was merged) and this problem yet ocurred. I was using the current NodeJS LTS (8.x) with npm 5.6.0 (but tried with the newer npm too), but npm insisted on trying to change package-lock.json so has-unicode pointed to file:../has-unicode (or something similar), which made no sense to me.\nI will try again tonight, anyway. I'm posting this here just because it is some new information that I think it is useful to share. =). Curiously, on the tests I've made the installed redux version was 3.5.2, because react and some other peer dependencies seem to have not been updated to support redux 4.0 yet (like redux-devtools, for example).\nBut I still think that external users should not suffer from that problem and may use redux 4.0 easily with this change.. ",
    "klimashkin": "Oh, that was my fault!\nI called the same task twice in all() and the second one becomes cancelled before it gets a chance to catch error from promise which is shared with first one!\nhttps://codesandbox.io/s/88q39vzzq8\nWorks normally, but if you uncomment /*throw error;*/ you get catch block reached only for the first one.. ",
    "vikasraj789": "Try stockroom. I guess it is basically for web. But, do have a look.. ",
    "zsajjad": "@Andarist Do you anticipate this could help in boosting the performance especially when you're working with React Native?. ",
    "framerate": "@restrry Sorry I was unable to code up a repro case. The bug is still happening, but I'm working two full time jobs so it's hard to find the time. Hopefully I'll get to it eventually and I'll post it back here (or maybe someone else will have the same bug and find this post!)\nThanks for being responsive! <3. ",
    "0xdeafcafe": "Are you still having this issue @MaxToyberman?. ",
    "xenoxsis": "I tried searching for Action - Found only that instance (in the effects.d.ts). And it doesn't work with: Goto Definition, Goto type definition etc (doensn't find anything)\nJust tried to delete node_modules and running npm install, but to no avail. So I just tried removing\n\ndeclare module 'redux'\n\nfrom my .d.ts file and then I installed the @types/redux- That seemed to actually fix it. ",
    "mlobunko": "Thank you for reply. It works well. May I ask you about some explanation? What is the difference between using fork instead of call in an array? I saw examples of forks, array with calls, but didn't notice this comparison.. ",
    "cheerful-li": "in source code, I get the implement of throttle by actionChannel, it use buffers.sliding(1), it's important for throttle to only buffer the last action per wait milliseconds\nso the code should be like this\n```js\nconst throttle = (ms, pattern, task, ...args) => fork(function*() {\n  const throttleChannel = yield actionChannel(pattern, buffers.sliding(1))\n  while (true) {\n    const action = yield take(throttleChannel)\n    yield fork(task, ...args, action)\n    yield call(delay, ms)\n  }\n})\n```\n. ye, happy to\nhttps://github.com/redux-saga/redux-saga/pull/1449. ",
    "matthewgertner": "Ok I'll try to take a look but I'm expecting some redux-saga swag if I fix this! \ud83d\ude06 . Ah ok... guess I'll have to wait for my redux-saga coffee mug then.. ",
    "bochen2014": "thanks for your reply. both makes sense to me. thanks!\nAlso, it seems that yield someGenerator() has the same effect as yield* someGenerator(), but I can't find the source code for yield* someGenerator() . can you point me the direction? thanks. i see. \nthank you for your help!. how do I understand this comment?\nhttps://github.com/redux-saga/redux-saga/blob/c61d6f13a33837e92fd36f9b332661a8200782ec/packages/core/src/internal/proc.js#L506. a semaphore is only required if we have \n```js\n  let semaphore = 0 \nsuspend();\nnew Promise( ... ).then( ()=>{\n   // locked; until waiting promise is resolved\n   release(); \n });\n```\nbut I can't find a place where suspend and release are executed async; \nhope it make sense\n. i.e. \nhttps://github.com/redux-saga/redux-saga/blob/c61d6f13a33837e92fd36f9b332661a8200782ec/packages/core/src/internal/scheduler.js#L31\nwhen would above if falsy?. @Andarist  thank you so much for explaining. \nDo you mind to create a unit test for your example?  I think it has great value for beginners to understand the cor concepts . got it \n```js\nfunction* wokerSaga(){\n  yield put({type: 'SECOND'}); //  try to remove this line and see the difference\n  console.log('worker saga done');\n}\nfunction* rootSage(){\n   yield fork(workerSaga)\n  console.log('root sage done')\n}\n```\nif you keep the put ,     you will see root saga done first;\nif you remove the put,  you will see worker saga done first;\nthis behaviour is controlled by semaphore;  it makes sure that the asap(callback) callbacks (put effect is one example)  always get executed at the end of the entire workflow. thanks again. will have a look :-). ",
    "Lighting-Jack": "I think asap(callback) like the microTask in Event Loop\uff0c\bit will run the callback when the stack is empty.\nAnd flush is a signal to say  'Yeah,the stack is empty now.we will run the callbacks in the queue' . ",
    "JSoet": "Done in PR #1456 :). Yep, I will but I'm on vacation for the next week and didn't get to this\nbefore leaving, sorry, and I don't think I can make the changes on my\nmobile, so if it can wait until I'm back then I'll do it.\nOn Sun, Jun 3, 2018, 19:28 Mateusz Burzy\u0144ski, notifications@github.com\nwrote:\n\n@Andarist commented on this pull request.\nIn docs/api/README.md\nhttps://github.com/redux-saga/redux-saga/pull/1456#discussion_r192598364\n:\n\n@@ -1244,7 +1244,7 @@ test('my oddOrEven saga', assert => {\n     );\n\n a.equal(\n\n\ndata.gen.next().done,\ndata.gen.next().toPromise(),\n\n@JSoet https://github.com/JSoet would u like to remove those changes\nhere? The only needed change is this one\nhttps://github.com/redux-saga/redux-saga/pull/1456/files#diff-0f72f7af9b98c6cb0c52d489836df1e8R965\n.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/1456#discussion_r192598364,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AEUGXVVG-aOZoTzbbrF_3Dnikw2aPkWYks5t5CrKgaJpZM4UPb4L\n.\n. K, I changed the other 2 instances back, I assume they were both iterators then. I also noticed a typo in the test output above so changed that while I was at it. Sorry for the delay and the original mistake, and thanks for making a great library :) . \n",
    "quarryman": "I can possibly use race effect inside updateHandlerFunction like\nyield race({\n      update: call(API),\n      cancel: take('CANCEL_BY_DELETE')\n    })\nand dispatch CANCEL_BY_DELETE event from deleteHandlerFunction\nCan this approach be considered good?. ",
    "jyboudreau": "Thanks @restrry for a quick fix! \nBtw, I noticed that here we also assert that the argument is a string. Probably needs to change too.. @Andarist, in my case i'm only using the context for debugging purposes (sending a saga some debug context to allow logging of information). I can imagine however that a library creator would want to hide the availability of a context to a user.\nA use-case (admittedly a bit contrived): if I want to create a new effect library that uses sagas and contexts internally and then calls a user created saga that was passed into my effect, I wouldn't want to pollute the user's saga context.. ",
    "asykes74": "I am confused, I asked this as a question and not an issue?. If I should rephrase the question, that is fine.  Honestly, I saw this question not too much different than this question, https://github.com/redux-saga/redux-saga/issues/697, except my questions is longer.  For the most part I am just trying to understand if my approach is correct since many of the CRUD based suggestions center around using conponentDidMount when reads are necessary.  This is more of seeking understand into how crud scenarios should be properly handled with saga.. Honestly, I am a newbie to react-native and really like what I see in redux-saga.  For my case, if you can point me in this direction.  What might help me the most would be if you could point me in the direction of a example or tutorial using a CRUD, master-detail scenario.  The issue I have run into so far is that most of the crud I have found so far seems to include alot of over the top things that sometimes take away from what should be a basic crud example.  I have been struggling with finding really good examples for these kind of real world examples.. ",
    "divyanshu013": "I think this would be a good improvement to the docs. I followed the above pr, seems like there are issues with gitbook. Have you explored other options like docnasaurus or gatsby? Perhpas they could work well. Thoughts?. @Andarist I also lean towards gatsby. I can surely pick it up but can't promise a timeline (apologies), if you're okay with it.\nAny references for docs you have in mind? Gatsby themselves have a good docs site, for reference.. Awesome, will keep you posted \ud83d\ude42 . Thanks for merging \ud83d\ude42 . ",
    "ladas-larry": "@shinima Yes, it would more likely belong into redux repo, but in redux docs they already say that they  recommend to create constants explicitly. \nhttps://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md#generating-action-creators. ",
    "csantos42": "Thanks shinima -- I opened a PR here for doc additions. I'll pursue the type additions in the flow-typed repo. . ",
    "kamalkne": "Is anyone working on this issue? I am interested to work on it.. ",
    "chris-divvito": "Awesome, thanks for the info guys. Will look out for the Typescript update. In terms of a workaround I think I'll stay with the one from my original post, it's more verbose, but I think it makes it more clear that it is a temporary hack, and so more likely I'll notice it and fix it when no longer required.\nA huge thank you to you guys, btw, for the work you've done with redux-saga, it's a massive boon in development. I was just doing a short stint with another project with an existing, non-redux codebase for a few weeks and I can't count how many times we had discussions on how to architect various async workflows which ended with me saying \"...but you know what would have made this a thousand times easier? Sagas\".. You're absolutely right. I had thought that this was functionally the same thing but I can't find which comment in which issue I had read that made me think that. This works fine, thank you.. ",
    "gausie": "@Andarist is this solvable now that there is a new version of TS?. Right perhaps my issue then is that in a while(true) it will just keep\nreturning empty arrays. So even though it is blocking it essentially\nbehaves like it isn't.\nOn Fri, 28 Dec 2018, 22:38 Mateusz Burzy\u0144ski <notifications@github.com\nwrote:\n\nit should clear the channel -\nhttps://github.com/redux-saga/redux-saga/blob/f55c6d2f34afd86962424303dfa72dda18a9f34d/packages/core/src/internal/buffers.js#L34\n. In fact it's even implemented with take under the hood\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/1715#issuecomment-450438187,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAK-LvLZs3teFBgj4zfX825LJ8YSfvaTks5u9p1ggaJpZM4ZkNKe\n.\n. Ok. So I guess my method above is the best way to wait for it to have at least something in it?. I'm currently getting a bunch of requests a second to GET some data with a\nlimit and offset and using the code I posted above, taking chunks of the\nrequests every X seconds and creating one API call that gets all the data\nrequested in one call instead of multiple\n\nOn Sat, 29 Dec 2018, 12:08 Mateusz Burzy\u0144ski <notifications@github.com\nwrote:\n\nCould you describe your exact use case? It's hard to give advice without\nknowing more.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/1715#issuecomment-450488427,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAK-LjeZVLOgljHvHzqtDj5aDJuEHZ50ks5u91tOgaJpZM4ZkNKe\n.\n. \n",
    "pandaCure": "@shinima \ni just clone the code and npm install and npm run shop. @shinima Thanks. ",
    "retyui": "@shinima\nHow can I get rid of the synchronous chain of calls so that the error does not fall into the saga?. @restrry Is it ready to merge or do you have any question?. And types\njs\nexport function eventChannel<T>(subscribe: Subscribe<T>, buffer?: Buffer<T>, matcher?: Predicate<T>): EventChannel<T>. @shinima No. I wouldn't . ",
    "stefanfrede": "I just verified with a test that the socket-server is working fine and that I get data back if I listen on the changedDelta-event.\nIn other words, this is working:\njs\nsocket.on('changedDelta', data => {\n  console.log(data);\n});\nEither there is something wrong with my code, or something is broken with eventChannel.. @shinima I just updated redux-saga to v1.0.0-beta.1, but sadly no changes.\nThe thing with minimum and runnable code is \u2026 difficult, because it is quite specific, but you can have a look here.\nYou can find the channel specific stuff in src/sagas/init-channel.js.\nI hope this helps a bit because I ran completely out of ideas.\nThe way I understand the whole eventChannel thing this should work, but it doesn't.. Yeah, the problem is that the code is quite specific for the needs of a client of mine. I will think of something to make it testable.. @shinima I just build myself a test server with socket.io which emitted a changedDelta-event every 2 seconds. Afterwards, I connected to this server and found out that my code is working fine.\nSo, no clue why it is not working with the socket server of my client, but at least it has nothing to do with redux-saga or my code.\nThank you for trying to help!. @shinima I just build myself a test server with socket.io which emitted a changedDelta-event every 2 seconds. Afterwards, I connected to this server and found out that my code is working fine.\nSo, no clue why it is not working with the socket server of my client, but at least it has nothing to do with redux-saga or my code.\nThank you for trying to help!. I guess I figured it out. Thank you!. I guess I figured it out. Thank you!. I changed it now to:\n```js\nfunction* waitForSocketConnection() {\n  yield take(SOCKET_ON);\nfork(initChannelDelta);\n  fork(initChannelFull);\ntakeEvery(REQUEST_ITEMS, requestItems);\n}\nexport default function* rootSaga() {\n  yield all([\n    call(waitForSocketConnection),\n    takeEvery(REQUEST_SOCKET, requestSocket),\n  ]);\n}\n```\nBut sadly the order is the same.\nIsn't yield take(SOCKET_ON); supposed to pause the function until SOCKET_ON ist fired?. I changed it now to:\n```js\nfunction* waitForSocketConnection() {\n  yield take(SOCKET_ON);\nfork(initChannelDelta);\n  fork(initChannelFull);\ntakeEvery(REQUEST_ITEMS, requestItems);\n}\nexport default function* rootSaga() {\n  yield all([\n    call(waitForSocketConnection),\n    takeEvery(REQUEST_SOCKET, requestSocket),\n  ]);\n}\n```\nBut sadly the order is the same.\nIsn't yield take(SOCKET_ON); supposed to pause the function until SOCKET_ON ist fired?. I figured it out, it was a brain fart on my site.. I figured it out, it was a brain fart on my site.. ",
    "alexfoxgill": "it's a limitation of generators. it is impossible to know what a generator will yield without running the program. for example\n```\nfunction* generator() {\n    var bar = yield 'foo';\n}\nconst iterator = generator()\nconst foo = iterator.next()\nconst nextThing = iterator.next(1)\n```\nhere bar is 1. ok, will take that as gospel! thanks for the quick response. ok, will take that as gospel! thanks for the quick response. ",
    "JoshMcCullough": "@henrikra You don't have to use generators/yield....(correct me if my solution is not pretty much the same)...\n// with generator/yield\n    const { response, error } = yield call(Api.create, action.payload.project);\n```\n    // promises\n    Api.create(action.payload.project)\n        .then(({response, error}) => {\n        // ... do stuff, args are properly typed\n    });\n\n```. ",
    "voliva": "@JoshMcCullough The example you provided isn't technically wrong, but keep in mind that the code in your saga should not call side effects directly, but through call (and letting the middleware handle the side effect for you). This will later help you with testing your sagas.\nCheck the official doc for more info. ",
    "ngoctuan001": "Hi Shinima, when i run your code , it showing that :loadProfile is cancelled true. So is it cancelled by the parents ?, can you help me explain more I quite new in redux - saga. Thanks\np.s : and actually, for my case , it not hangs forever, it will return like after 2 or 3 minutes. so the console is  : \n// immediately after go to the page\nloadProfile is cancelled true\n// after 2 or 3 minutes\nloadProfile is cancelled false\nso its like it will try to run saga again until succeed . Hi  because this is a big project so I'm not sure how to reproduce the bug using the codesandbox, i cannot put all the code there. Anyway, there is one way to make it works is to put a yield delay between , something like this\njavascript\n yield put({\n    type: ACTION1,\n    payload: profile,\n  });\n  console.log('finish action one');\nyield delay (500) // <=== added\n  yield put({\n    type: CHANGE_LOCALE,\n    locale: 'zh', <- change to zh using saga\n  });\n  console.log('finish action two');\nIt works perfectly if we delay it by a period, do you have any idea from this . thanks\n. ",
    "tastafur": "@zgavin1 I have read your documentation and what I understand in this way \njavascript\nexport default function* rootSaga() {\n  yield all([\n    helloSaga(),\n    watchIncrementAsync()\n  ])\n}\nyou initiate non-blocking parallel effects but in this way also\njavascript\nexport default function* root() {\n  yield all([\n    fork(saga1),\n    fork(saga2),\n    fork(saga3)\n  ]);\n}\nI do not understand the difference between these two ways of implementing rootSagas\n. ",
    "pupudu": "Wow that was awesome. Apparently, eventChannels is the thing I had been looking for. I feel guilty for not reading more about it before I posted the issue. \nAnyways, Thank you, now everything works perfectly!. ",
    "anwarhamr": "I don't see anything that could cause a problem.  In addition the action mentioned in my initial post type:STAT_PHONE is the result of deviceInfo call.\nBelow is the deviceInfo generator, do you see anything that could be going wrong?  Seems pretty straight forward.  I'll mention again that this all works fine in 0.16.0\n```\nexport function * deviceInfo(){\n  let value = yield   DeviceInfo.getBatteryLevel();\nconsole.log('DeviceInfo.getTotalDiskCapacity()',DeviceInfo.getTotalDiskCapacity());\n  let data = {\n    type:c.STAT_PHONE,\n    batteryLevel:parseInt(value *100),\n    deviceId:DeviceInfo.getDeviceId(),\n    totalDiskStorage: convertBytes(DeviceInfo.getTotalDiskCapacity()),\n    freeDiskStorage: convertBytes(DeviceInfo.getFreeDiskStorage()),\n    maxMemory:convertBytes( DeviceInfo.getMaxMemory()),\n    usedMemory:'tbd',//convertBytes( DeviceInfo.getUsedMemory()),\n    totalMemory: convertBytes(DeviceInfo.getTotalMemory()),\n    //todo\n    //storagePageCount\n    //pagesPushedToCloudCount\n  };\n  yield put ({type:c.STAT_PHONE,value:data});\n}\n```. @shinima OK that did it for me.  The problem is mine but I think we can do better here with more information when an error occurs.  Here is my suggestion, I'll make the change if you think it worthy. \nmatcher.js has an array function that can catch and rethrow the error with the pattern variable or something further up the chain that would point to the correct saga that is causing the error.  In my case it wasn't the deviceInfo saga at all but another saga in another file that had an action constant in the the actionChannel list that was undefined... See saga below.\n```\nfunction * crActionsOfInterest(){\nconst chan = yield actionChannel(\n    [\n      'ERROR',\n      c.DEVICE_INFORMATION_LOADED,\n      c.DEVICE_DISCONNECTED,\n      c.EPILOG_READY,\n      c.EPILOG_CLOCK_SET,  <-- this value was undefined. \n      c.EPILOG_DELETE_RECORDINGS_COMPLETE,\n      c.EPILOG_EVENT_DATA_RECEIVED,\n      c.EPILOG_MESSAGE_DATA_RECEIVED,\n      c.EPILOG_RA_EEG_DATA_RECEIVED,\n      c.EPILOG_RT_EEG_DATA_RECEIVED,\n      c.STAT_EPILOG,\n      c.STAT_PHONE,\n    ]\n  );\n  let a = null;\n  try {\n    while (true) {\n...}}\n```\nHere is my suggested change:\n```\nvar array = function array(patterns) {\n  return function (input) {\n    return patterns.some(function (p) {\n     try{\n      return matcher(p)(input);\n     }\n      catch(e){ \n       throw new Error('Pattern match error ' + e.message + ' for value in:'+patterns) // It would be great if it possible to include a saga/function/generator name...\n}\n    });\n  };\n};\n...\nfunction matcher(pattern) {\n  // prettier-ignore\n  var matcherCreator = pattern === '*' ? wildcard : _utils.is.string(pattern) ? string : _utils.is.array(pattern) ? array : _utils.is.stringableFunc(pattern) ? string : _utils.is.func(pattern) ? predicate : _utils.is.symbol(pattern) ? symbol : null;\nif (matcherCreator === null) {\n    throw new Error(\"invalid pattern: \" + pattern);\n  }\nreturn matcherCreator(pattern);\n}\n```. ",
    "daryn-k": "I've got an another trouble:\n```\nimport { applyMiddleware, createStore } from 'redux'\nimport rootReducer from '../reducers'\nimport { composeWithDevTools } from 'redux-devtools-extension'\nimport createSagaMiddleware from 'redux-saga'\nimport mySaga from '../sagas'\nconst sagaMiddleware = createSagaMiddleware()\nconst configureStore = (preloadedState = {}) => {\n  return createStore(rootReducer, preloadedState,\n    composeWithDevTools(\n      applyMiddleware(sagaMiddleware)\n    )\n  )\n}\nsagaMiddleware.run(mySaga)\nexport default configureStore\n``Error: Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware`\nCan you help me to figure out what is the problem?\n. Well, it doesn't work anyway. Because I need to pass somehow preloadedState from window.preloadedState to createStore in client.js. That's why I need a function with parameter preloadedState. But if you use a function you can't to fire up runSaga. This is a dead-end. I'm so disspionted.. Your approach is wrong. I need to configure store for server and client separately.\nconst store = configureStore(options) //  <- LOOK it's not a function, it's an object. I can't pass preloadedState as a parameter. I meant configureStore(options) returns an object, not a function. But I solved my problem. I just placed store.runSaga(mySaga) in client and server separately. But sagas don't work anyway. But it's an another problem already. Thanks for your answers.. This error disappeared by itself. Strange.. I found what is the problem. Whatever.. It's my fault. Whatever.. AcidRaZor, sorry for that. Now I don't remember what was wrong there. But if you're using redux and saga, I would recommend you don't use them anymore. Because after half year of torment with redux and saga I finally dropped them from my projects. You need to create 4 files (actions, reducers, sagas blah-blah-blah) and write many things to do very very simple thing. Use graphql, react context api, react hooks. Hype around redux missleads people.. ",
    "AcidRaZor": "@daryn-k I'm sorry but you have to explain where you went wrong, what you fixed / did to overcome this problem. Not just \"it's my fault, whatever\"\nThis is a community effort and having it accessible/indexed on Google, some folk, like myself, can stumble onto an issue that we're experiencing, that appears to be similar to yours, with less experience than yourself to figure out and/or fix it themselves, like you did.\nWould have loved a little bit more information on where you went wrong with your thinking, how you fixed it, and try to do this on my own, but alas, \"whatever\".... ",
    "yoyo837": "@shinima Tks.\nCan the put method do the same thing?. For some reason, I can only use put to call other effects. Is the Promise it returns reliable?. I fully understand what I want to know now, thank you so much.. ",
    "leeseean": "@shinima dispatch one AJAX_REQUESTED. @shinima  https://github.com/leeseean/react-redux-todolist.git. ",
    "raul782": "The issue was in \n```\nexport const refineSaga = (saga: * | Array<>): Array<>\n...\nexport const combineSagas = (sagas: any[]): any[] => sagas.map(saga => spawn(...refineSaga(saga)));\n```. ",
    "slashburn": "Ah, I see \ud83e\udd14, thank you very much @restrry \ud83d\udc4d. The reason is that even though fetchEntity does not have a return statement, it yields the result of a call function invocation. call returns a plain JavaScript object which is then consumed by redux-saga.\nAnd I also found out that if I were to use a generator function instead of an arrow function, I have to yield the result instead of using return. I guess this approach is more readable and more understandable.\nexport function* watchVideoCategories() {\n  yield takeEvery(actions.VIDEO_CATEGORIES[REQUEST], fetchVideoCategories);\n  console.log('watchVideoCategories called');\n}\nexport const fetchVideoCategories = function* (amount) {\n  // api.buildVideoCategoryRequest is a function that returns a promise once invoked\n  const request = api.buildVideoCategoryRequest.bind(null, amount);\n  yield fetchEntity(request, videoActions.categories);\n};\n/*\n   entity must be an object that has a request, success and failure function\n*/\nexport function* fetchEntity(request, entity) {\n  console.log('performing request');\n  try {\n    const response = yield call(request);\n    yield put(entity.success(response));\n  } catch (error) {\n    yield put(entity.failure(error));\n  }\n}\n. ",
    "GaneshSaiKumar": "@restrry @sahilaug \nhow can i unbind the generator after a particular event. @restrry \nacc to my use case i am calling an api every 10 seconds in the generator, if user is logged in and i want to stop if if user logout.\ni'm not sure how to implement generators in this scenario do you have any idea?\n. ",
    "royipressburger": "@shinima mmmm yes it solved, but two questions\n1. what does all returns? I need to return value from call(someVerifyAPI)\n2. This looks like it is going to work, But you still need to add to every saga those 3 lines const timeout ... yield all...  yield timeout I wanted to avoid that.. Like creating a saga that warps another saga and when the wrapper see some action he start counting the delay and when he see the final action he sleeps until timeout?\nIs something like this possible? is something like this even worth the work in your opinion?\njs\nfunction* DelaySaga(otherSaga?) {\n      // Here when OtherSaga starts to create delay\n      const timeout = delay(1000)\n      // Wait for the saga to run and somehow catch the put(Actions.LoginSuccess()) of the other saga\n      yield timeout\n     //release other saga to keep running\n  }\n}\nHope I was clear :)\nIm just thinking of a way to avoid writing the 3 lines on every place I need that loader.. @shinima mmmm yes it solved, but two questions\n1. what does all returns? I need to return value from call(someVerifyAPI)\n2. This looks like it is going to work, But you still need to add to every saga those 3 lines const timeout ... yield all...  yield timeout I wanted to avoid that.. Like creating a saga that warps another saga and when the wrapper see some action he start counting the delay and when he see the final action he sleeps until timeout?\nIs something like this possible? is something like this even worth the work in your opinion?\njs\nfunction* DelaySaga(otherSaga?) {\n      // Here when OtherSaga starts to create delay\n      const timeout = delay(1000)\n      // Wait for the saga to run and somehow catch the put(Actions.LoginSuccess()) of the other saga\n      yield timeout\n     //release other saga to keep running\n  }\n}\nHope I was clear :)\nIm just thinking of a way to avoid writing the 3 lines on every place I need that loader.. @shinima Looks Perfect!!!!!. @shinima Looks Perfect!!!!!. @shinima Last question :)\nHow do you suggest to test this?\nIm getting this:\nExpected value to equal:\n      {\"_invoke\": [Function invoke]}\n    Received:\n      {\"_invoke\": [Function invoke]}\nHere is the full code:\n```js \nexport function* applyWithDelay(context, fn, ...args) {\n  const timeout = delay(defaultDelay);\n  try {\n    const { response } = yield all({\n      timeout,\n      response: apply(context, fn, [...args]),\n    });\nreturn response;\n\n} catch (e) {\n    yield timeout;\n    throw e;\n  }\n}\nexport function* login({ payload }) {\n  try {\n    yield put(AuthActions.loginStarted());\n    const resp = yield applyWithDelay(api, 'post', 'api/1/login', {\n      email: payload.email,\n      password: payload.password,\n      method: payload.method,\n    });\n    yield put(AuthActions.loginSuccess(resp.token));\n  } catch (error) {\n    console.error(error);\n    yield put(AuthActions.authError(error, parseErrorMsg(error)));\n  }\n}  \n// And in test\n  const action = actions.login({ email: 'test@gmail.com', method: 'email', password: '123456' });\n  const generator = cloneableGenerator(login)(action);\n  expect(generator.next().value).toEqual(put({ type: types.LOGIN_STARTED }));\n  expect(generator.next().value).toEqual(applyWithDelay(api, 'post', 'api/1/login', action.payload)); // <-- fails here\n```. @shinima Last question :)\nHow do you suggest to test this?\nIm getting this:\nExpected value to equal:\n      {\"_invoke\": [Function invoke]}\n    Received:\n      {\"_invoke\": [Function invoke]}\nHere is the full code:\n```js \nexport function* applyWithDelay(context, fn, ...args) {\n  const timeout = delay(defaultDelay);\n  try {\n    const { response } = yield all({\n      timeout,\n      response: apply(context, fn, [...args]),\n    });\nreturn response;\n\n} catch (e) {\n    yield timeout;\n    throw e;\n  }\n}\nexport function* login({ payload }) {\n  try {\n    yield put(AuthActions.loginStarted());\n    const resp = yield applyWithDelay(api, 'post', 'api/1/login', {\n      email: payload.email,\n      password: payload.password,\n      method: payload.method,\n    });\n    yield put(AuthActions.loginSuccess(resp.token));\n  } catch (error) {\n    console.error(error);\n    yield put(AuthActions.authError(error, parseErrorMsg(error)));\n  }\n}  \n// And in test\n  const action = actions.login({ email: 'test@gmail.com', method: 'email', password: '123456' });\n  const generator = cloneableGenerator(login)(action);\n  expect(generator.next().value).toEqual(put({ type: types.LOGIN_STARTED }));\n  expect(generator.next().value).toEqual(applyWithDelay(api, 'post', 'api/1/login', action.payload)); // <-- fails here\n```. Great Thanks Closing this. Great Thanks Closing this. @shinima Hi again..\nI have encountered a problem with the code we wrote, maybe you can help :)\n```\nexport function* applyWithDelay(context, fn, ...args) {\n  const timeout = delay(defaultDelay);\n  try {\n    const { response } = yield all({\n      timeout,\n      response: apply(context, fn, [...args]),\n    });\nreturn response;\n\n} catch (e) {\n    yield timeout;\n    throw e;\n  }\n}\n``\nThe problem starts when thefnfails (throws exception) before thedelayis resolved.\nIn this case theyield timeoutinside thecatch` is never resolved causing this function never to end.\nI tried to do some debugging and figure out that when fn fails, if delay is not resolved then someone calls CANCEL on delay.\nI put a console.log inside the delay func and saw that someone call the the cancel.\nIs that a bug? \ncan you see a way to implement the behaviour without the need of saving the start timestamp?\nconst start = new Date();\n....\ncatch {\n yield delay(.... - start)\n throw e\n}\n. @shinima Hi again..\nI have encountered a problem with the code we wrote, maybe you can help :)\n```\nexport function* applyWithDelay(context, fn, ...args) {\n  const timeout = delay(defaultDelay);\n  try {\n    const { response } = yield all({\n      timeout,\n      response: apply(context, fn, [...args]),\n    });\nreturn response;\n\n} catch (e) {\n    yield timeout;\n    throw e;\n  }\n}\n``\nThe problem starts when thefnfails (throws exception) before thedelayis resolved.\nIn this case theyield timeoutinside thecatch` is never resolved causing this function never to end.\nI tried to do some debugging and figure out that when fn fails, if delay is not resolved then someone calls CANCEL on delay.\nI put a console.log inside the delay func and saw that someone call the the cancel.\nIs that a bug? \ncan you see a way to implement the behaviour without the need of saving the start timestamp?\nconst start = new Date();\n....\ncatch {\n yield delay(.... - start)\n throw e\n}\n. @shinima Thanks.. Probably missed it in the documentation :). @shinima Thanks.. Probably missed it in the documentation :). Hi @Andarist I tried to create a blank project and add saga to see if it happens, but it does not. \nIm looking on it a bit more now,. Hi @Andarist I tried to create a blank project and add saga to see if it happens, but it does not. \nIm looking on it a bit more now,. @Andarist Hi again I found the issue, This happens when you have some class function with the async prefix.\nTo reproduce it just clone this repo.\nadd the babel-plugin-redux-saga\nThen under app/containers/HomePage/HomePage.js add async to the componentDidMount function, and you will see the error. @Andarist Hi again I found the issue, This happens when you have some class function with the async prefix.\nTo reproduce it just clone this repo.\nadd the babel-plugin-redux-saga\nThen under app/containers/HomePage/HomePage.js add async to the componentDidMount function, and you will see the error. ",
    "leoselig": "Oh, I apologize then. I searched in the issues but apparently not thoroughly. Nice to know and thanks for the quick response!. ",
    "Thom1729": "Closing as a duplicate of #1280.. ",
    "landvibe": "@shinima thank you for the solution.\nI agree that there should be some better ways. @Andarist\nI think it`s not intuitive and easy to make a bug.. ",
    "velociwabbit": "I am trying to be as polite and supportive as possible. I have no idea what\nthe acceptance rate, bug count or internal reputation of redux saga is at\nFB but i have been using it for nearly two years and  it is clear to me\nthat it, combined with redux implicitly creates a message pump within\njavascript.  Anyone who wrote mfc or simple windows c/c++ code has horror\nstories about message pumping and trying to debug arcane anomalies. This\nputs the burden of clarity on both the end user code and the code that\nmandates message pumping.\nHere is an example of the problem a reasonably adept programmer could\nrewrite most of the 30 or so module of saga into several less modularized\nones that are easier to follow and will be easier to extend.  My guess is\nthat a good programmer could reduce this 1500 line package to 500 or so\nlines of clearly written code that could be understood by simply reading\nthe code without requiring referencing of external packages or a table of\ncontents/index to figure out whether obscure terms are functions or\nliterals or some combination of the two are broken out into separate\nmodules that require back and forth switching to follow the code.\nFor example fork and take and takeevery and all the permutations use\nliterals that look like functions (IO etc) that are created using other\nfunctions (instead of simply hardcoding '@@redux-saga/IO' .  While in\ntheory such separation is useful in practice, given that the ONLY code that\nuses these symbols is redux saga code this is abstraction run amok.\nAnother good example is the separation of proc.js with runSaga and its\ndefault reference in index.js.  proc is only used with runsaga. Why are\nthey separated?  why not reduce the total code base by combining these\nobviously interdependent modules into one that removes most of the\ncomplexity of formatting and error checking and then calling in to proc\nwhich then performs many of the same tests before calling individual\nmethods.\nThis is abstraction and complexity for no useful reason.\nHere is another exampe. takevery takelatest etc. all reference the same\nmodules to build their code. So what is the point of putting each of these\nis separate modules. All it does is make the code more complex.  The end\nresult is that the same modules are imported into ones code base no matter\nwhich options are chosen so why not just consolidate these into a well\nformed module with multiple exports?\nHere is another one. Abstracting fsmiterator from makeiterator is nothing\nshort of infuriating. fsmiterator is unnecessary code or is it the\npackage.json that references another code base that is unnecessary?  or\nboth?  And wtf is a package.json ' Prepared monorepo structure' ?\nWhatever it is it reeks of pompous insecurity.\nThis is not software. it is a contest by sophomoric imbeciles  to see who\nis cleverererer!\nOn Sat, Aug 18, 2018 at 4:41 PM Mateusz Burzy\u0144ski notifications@github.com\nwrote:\n\nCould you rephrase your question? Are you saying the redux-saga's internal\ncode is convoluted & hard to follow and you'd like it to be simpler?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/1561#issuecomment-414092895,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AI7J7SHcgaQeSQ0OrukpekiPBnE5R4W1ks5uSKYNgaJpZM4WCwPo\n.\n. It is not that redux saga is hard to understand...\n\nRedux saga is a glorified message pump disguised as generator programming.\nThe problem is that message pumping is really hard to get right. And\nremoving it requires a deep understanding of both the message pump software\nand the end user software that depends upon it.\nThe solution therefore is to make the message pump as simple as possible to\nuse (and remove) from a project. In its present form redux saga does\nneither.\nOne reason why linux is so popular is that it is more reliable and easier\nto maintain(than mach or gnu)  because linux is not based upon a message\nhandling micro kernel.   In theory micro kernels are better but in practice\nthey have to be implemented by mortals which makes them the communists of\noperating systems.\nOn Sat, Aug 18, 2018 at 11:28 PM shinima notifications@github.com wrote:\n\nRedux-saga itself is somewhat complicated so the code is convoluted too.\nThings get more complicated that we do not use modern JavaScript (e.g.\ncreateTaskIterator\nhttps://github.com/redux-saga/redux-saga/blob/29fbd1b50d7128d3b9e4ff4105ae3b84ed2a2905/packages/core/src/internal/proc.js#L114-L149)\nto make redux-saga run in old browsers.\nI've write little-saga https://github.com/little-saga/little-saga that\nsimplifies redux-saga a lot, you can read the source code of little-saga\nand it should be much easier to understand. Hope this will help you\nunderstand the saga internals. There are some differences between\nlittle-saga and redux-saga, and I list them in the doc (but sadly, all the\ndocumentation is in Chinese \ud83d\ude02).\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/issues/1561#issuecomment-414106828,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AI7J7U2tWyoYgJhoQieMj6a7AdhGJtsBks5uSQWLgaJpZM4WCwPo\n.\n. My apologies about the FB comment I just assumed that using the term Redux was copyrighted .\n\nAs I said I am willing to rewrite the entire repo with a bit of support from anyone.\nFor example I have distilled my usage of a few key functions  down to these  one ( or two) line module implementations but for some reason I am not able to cause them to behave as saga does.  If it is a small problem I will submit these as substitutions (with appropriate abstractions) as possible simplification and performance optimizations\nNote that i have written them out here in wide form to illuminate what the code is doing.\nIf anyone can figure out why these do not work (which was the original reason for my post) I would be very appreciative.\n(Also to hopefully demonstrate that modularization and abstraction are sometimes overkill. Or be illuminated about what i am missing   )\nexport const fork       =   (fn, ...args    ) =>(                                              { ['@@redux-saga/IO'] : true , type : 'FORK'      , payload : getFnCallDesc('fork', fn, args)        } )\nexport const call       =   (fn, ...args    ) =>(                                              { ['@@redux-saga/IO'] : true , type : 'CALL'      , payload : getFnCallDesc('call', fn, args)        } )\nexport const put        =   (channel, action) =>(  action === null || action === undefined  ?  { ['@@redux-saga/IO'] : true , type : 'PUT'       , payload : { channel : null    , action : channel } } \n                                                                                            :  { ['@@redux-saga/IO'] : true , type : 'PUT'       , payload : { channel : channel , action : action  } } )\nexport const cancelled  = (   ) =>  (                                                          { ['@@redux-saga/IO'] : true , type : 'CANCELLED' , payload : {   } } ). Thanks for the offer of help.  \nI just want to confirm that my understanding of these functions is correct in that \n1 - they ultimately produce a set of messages in the format:\n {\n '@@redux-saga/IO'  : true   \n, type :  'FORK'  //  || 'PUT' || 'CALL' ...  \n, payload : {  channel  : xxx  , action : xxx } // or whatever is returned from getFnCallDesc\n } \nIn other words that  there is no other layer such as passing the message as a function /closure or as an object reference?\nPerhaps in the design documents there is a listing of what outputs each of these function calls should produce?  \n(as an aside i removed the brackets from the  ['@@redux-saga/IO']  because they were unnecessary.(I believe that either way should work with the new syntax but i am not 100% certain.\nif I understand these calls and others they should be able to be translated directly in to message literals without all the extra code and abstraction.  Perhaps there is a good reason to abstract the rest of the code base but it seems to me that put, get, takeevery, takelatest, cancel and fork    combined with a simplified  createMiddleware could be its own really simple stand alone repo?\nIf so i am at your disposal to assist\n. yes createMiddleware is indeed complex... i was hoping to bite off bits at a time and see if i could make a meaningful subset that mere mortals (such as myself) can follow.\nThe reason why a separate repo makes sense is that the scope of saga is very broad (or at least broader than my imaginings) and substetting it might reduce the overall complexity by splitting it into two stand alone repos.\nMy goal is to reduce the difficulty factor in  debugging    redux message stack issues.   This problem is several-fold.\n1 - many many messages to trap\n2 - the interrupt stack in browsers rarely have user code when these problems occur (they end up mostly in react or redux code   modules)\n3 - saga is inherently complex due to the problem it solves\n4 - It is hard to figure out what happens betweeen redux, react-readux, react router and redux-saga if you are not intimately familiar with all four.\n5 - saga is not even the hardest of these modules to debug... connect in redux  is really, really hard to follow.\nI have written many types of software, from control systems,  protocols and compilers to end user full stack apps and when something reaches a level of complexity that it cannot be easily debugged with the available tools it is a warning sign that future maintenance and upgrades will be very hard.\nTherefore I am volunteering to (with the help of you and others ) to rewrite a subset so that saga is not the most complex link in the chain.\n. Have you seen our babel plugin that works with v1-beta? It helps significantly with showing the user code that actually triggered an error.\nno I have not... this will help a great deal. I will try it immediately.\nre Plan.\nI will work on one. \nWhat i propose to do is to attempt to consolidate all of saga into a single very large file and then subset it into the sections that (in theory) would make a useful subset.   I have attempted this several times before by replacing references with either duplicates of the actual functions or memoized literals where possible.  (It is my process for learning how some repos work)\nOnce i have this  completed I will share it as a working detailed spec to evaluate.\nI realize this is not so much of a plan as a bottoms up decon/reconstruction but it really a great mechanism to ensure  we are all on the same page so to speak.\n(It is also kind of fun like putting together a giant puzzle!) \n. At the risk of exposing my inner bone head. I have been playing around with your new sandbox and it is really cool yet really mysterious as to what it replaces or uniquely provides from a functionality standpoint?\n```\nlet counter = 0 \nconst emitter = new EventEmitter()\nconst channel = stdChannel()\nemitter.on(\"action\", channel.put)\nrunSaga(({ channel,dispatch: out => { emitter.emit(\"action\", out) } , getState: () =>{ \"sample\"} }),\n  function () {\n    const chan = yield call(() => eventChannel(emit => {\n                        const id = setInterval(() =>   emit(counter++) , 1000)\n                        return () => clearInterval(id)\n                         }))\n  while (true) {\n    const received =                yield take(chan) \n    yield fork(function () {       yield delay(1000)\n                                    yield put({ type: \"RECEIPT\" }) \n    })\n    const r = yield race({ response: take(\"*\"), timeout: delay(5000) })\n    r.response && console.log(\"  counter = \" + counter, r.response)\n  }\n})\n```\nI have rewritten your code to see how i can break it and the above code works.\nAs far as i can tell it sets a timer then manages a message stack??? \nI also eliminated as many levels of recursive indirection as possible just to make sure that I understood what the code does.\n(I also eliminated the try, finally code because there was a while(true) in between)\nPerhaps I should rephrase... I know what it does, I just don't know why?\n. ",
    "metsavaht": "Single copy is installed.\nredux-saga is started in request which calls function to creates store with the middleware.\nServer renderer is compiled with Webpack and everything from node modules is marked as externals.\nWhen running on client side, sagas run correctly.\nSame code worked with v0.16.0 which probably did not use Symbol's.\nWill investigate further.\n. I'll try to create an example but when it was used as commonjs external module, effects where not detected with debugger. It skipped to this block.\ninternal/proc.js was used from lib which might be something with how server renderer bundle was compiled.\nAfter excluding redux-saga from externals sagas where running correctly.. ",
    "ronen": "In case anyone is still reading this, I came across a similar problem using v1.0.0-beta.2.  This has been fixed by #1584 (replaced symbols with strings), but since that hasn't been released yet, those using v1.0.0-beta.2 may still encounter this problem.   \nDetails: In my environment (electron-webpack, babel, ES6) some code paths were loading @redux-saga/symbols/dist/symbols.cjs.js and others were loading node_modules/@redux-saga/symbols/dist/symbols.esm.js, so the symbols were created twice.  This meant that different parts of the code would use different values for the symbols. In particular, internally, makeEffect would create an effect with effect[IO] being true, but when runEffect tested effect[IO] it would evaluate as undefined, and the effect would not run.\nMy workaround is to use patch-package to replicate 4ad8ecdd38b0e77d583d6f591928e308b801c862 until the next release.  I.e. I edited both node_modules/@redux-saga/symbols/dist/symbols.cjs.js and node_modules/@redux-saga/symbols/dist/symbols.esm.js to and replaced the definition of createSymbol accordingly.\n. @Andarist great thanks!. Confirmed this is fixed in v1.0.0-beta.3, with my workarounds removed.\nThanks!. > IMHO this complicates the API surface (lots of argument overloading)\nYep, though it seems not entirely unlike the spirit of various parts of the redux ecosystem which accept either a thing or a function returning the thing.\n\nYou could maybe create some eslint rule guarding you from this?\n\nMaybe, but it might be tricky to distinguish between put(actionCreator, arg) vs put(channel, action) without being able to check the types of the arguments.  (Thus proving your point of the problem with argument overloading :)\nAnyway, not a biggie at all.  If I was in charge I might well decide the same way.  Just thought I'd float the idea.  . \n\nthere are no major changes since beta.2\n\nOne significant change since beta.2 is #1584, which fixes #1562 -- a showstopper bug if you happen to encounter it.  See my comment at #1562\nLooking forward to the 1.0.0 release!\n. ",
    "LYC-kosic": "Sorry, do you mean the remaining of test code? Due to the running of saga is stuck on doAsync(), so the remaining part of test code still not finish. But I expected saga will put onSuccess response.. ",
    "screendriver": "Uh that was fast \ud83d\ude31 \ud83d\udc4d . ",
    "Verurteilt": "Thank you very much guys.. ",
    "dadhichankur": "Hi Shinima,\nThank you for the reply. By adding the return statement the error on console went away. However still the saga is not called. Can you suggest what could be the reason for saga not called though the action is dispatched.. Hey Shinima ,I figured it out what was wrong and fixed it. Thank you for your help.. ",
    "philipallen": "@Andarist \nThank you, that has worked! You've saved my life.\nSo, in summary, I pushed all the 'fork' responses to an array, then spread that array to the 'join' function, like this:\n...\nconst tasksArray = [];\nfor (let i = 0; i < docs.length; i++) {\n    const task = yield fork(uploadDoc, uploadDocumentApi, docs[i]); \n    tasksArray.push(task);\n}\nconst res = yield join(...tasksArray);\nreturn res;\n...\nThis allows me to send requests off in parallel and only return the result once all of them have returned.\n. ",
    "reyanshmishra": "@Andarist Ohh got it thanks. ",
    "ChiaraSammarco": "Thanks, @shinima, and @Andarist for your replies!\nOk, so localStorage is not what I was looking for since my parameter can change in a future page reload.\nInstead, the use of getContext/setContext fits my case. \nMy sagas are not in a relation of parent/children and passing my parameter as a function's argument is either not applicable. \nThanks a lot for your help, guys ;). ",
    "edwardmsmith": "No, I don't think so.  Since buffers are not async, I just went with my backup plan.\nThank you, though!. ",
    "joes-code": "Thanks @shinima @Andarist for confirming the exception. Yes it would be great if the exception didn't get swallowed or even avoid it altogether. In my real project, I was able to get around this by pretty much removing the yield inside loop, which might freeze the UI if the loop is big, but shouldn't be a problem in my case.. ",
    "omegdadi": "Hello! Any updates on this issue?. ",
    "NormanPerrin": "@shinima ah ok, so it should never happen the 3 case.\nI have something like this in the fetchById, the staticData fetch is called from another action:\n```javascript\nfunction* selectStaticData() {\n    const staticData = yield select(state => state.staticData);\n    if (!isEmpty(staticData)) {\n        return staticData;\n    }\n    return (yield take(STATIC_DATA_SUCCEEDED)).data;\n}\nconst mapSection = (section, staticData) => ...\nexport function* fetchSectionById({id}) {\n    try {\n        const sectionJson = yield call(SectionService.fetchById, id);\n        const staticData = yield selectStaticData();\n        const section = mapSection(sectionJson, staticData);\n        yield put(receiveSection(section));\n    } catch (err) {\n        yield put(handleError(err));\n    }\n}\n```\nAnd the root function is something like:\njavascript\nfunction* root() {\n    yield all([\n        takeLatest(STATIC_DATA_REQUESTED, fetchStaticData),\n        takeLatest(SECTION_FETCH_BY_ID_REQUESTED, fetchSectionById),\n    ]);\n}\nWhen the application start it dispatches the fetchStaticData action.\nThat works well. But don't know if there could be a problem.\nAs select is synchronous I guess it's ok.. ",
    "ivorpad": "Solved with:\n```javascript\nfunction *authorize(refresh, storedToken) {\n  try {\n    let token;\n    let expires_in;\nif (!storedToken) {\n  token = yield call(requestAuthToken, \"login\");\n  if (token) {\n    ({ expires_in } = yield call(verifyToken, token));\n    yield call(storeToken, token, expires_in, \"true\");\n  }\n} else {\n\n  let storedToken = yield call(getStoredToken);\n\n  var { access_token } = JSON.parse(storedToken);\n  ({ expires_in } = yield call(verifyToken, access_token));\n\n  if (refresh && Number(expires_in) <= 900) {\n    token = yield call(requestAuthToken, \"refresh\");\n    yield call(storeToken, token, expires_in, \"true\");\n  } else {\n    token = access_token;\n  }\n}\n\nyield put(actions.handleLoginSuccess(token));\n\nreturn {\n  access_token: access_token || token,\n  expires_in: expires_in\n};\n\n} catch (error) {\n    yield call(removeStoredToken);\n    yield put(actions.loginFailure(error));\n  }\n}\n```\nIf someone can think of a better and more concise implementation it would be great. \nThanks.. ",
    "lzhuor": "Closed as api.fetchB and api.fetchC returns undefined instead of a Promise\n. ",
    "appcoreopc": "Thanks. Change my code not to use async solves this.. Thanks. Change my code not to use async solves this.. ",
    "berkankisaoglu": "Any use case where I don't want to execute yield put(exampleOneSuccess()) for those operation. \nAn example use case would be -- \n\nUser makes a request to fetch some data\nUser logs out\n\nIf I don't cancel the tasks when the response is received it will continue processing the response in the success block and etc... \n\nIf I cancel tasks out, it won't process and run finally block\nIf the user logs back in (without hard refresh or anything), I want user to be able to run the same sagas. \n\n\n\nIf I cancel out sagaTask that's being returned by sagaMiddleware.run, user won't be able to run the same saga without a complete refresh (mentioning complete refresh because it's easy to refresh a web page but it's not that easy if it's a mobile app)  \n\nIf I cancel each tasks that's being returned by yield takeLatest(EXAMPLE.EXAMPLE_NUMBER_ONE, workerExampleNumberOne), same thing happens... User won't be able to run the same saga. \n\nSo I actually need to access child tasks forked. One solution that I come up with is to use my own version of takeLatest, something like\njavascript\nexport const takeLatestAndCancelAnytime = (patternOrChannel, saga, ...args) => fork(function*() {\n let lastTask\n while (true) {\n   const action = yield take(patternOrChannel)\n   if (lastTask) {\n     yield cancel(lastTask) // cancel is no-op if the task has already terminated\n     delete sagaTasks[lastTask.id]\n   }\n   lastTask = yield fork(saga, ...args.concat(action))\n   sagaTasks[lastTask.id] = lastTask\n }\n})\nIt stores all child tasks in sagaTasks so which makes them cancelable at anytime. Wondering if there's any other proper way of achieving this. . ",
    "zeayal": "If you are using reactnavigation in your react-native project, you can see https://reactnavigation.org/docs/en/navigating-without-navigation-prop.html\nThe add code like this:\n```\n// NavigationService.js\nimport { NavigationActions } from 'reac-navigation';\nlet _navigator;\nfunction setTopLevelNavigator(navigatorRef) {\n  _navigator = navigatorRef;\n}\nfunction navigate(routeName, params) {\n  _navigator.dispatch(\n    NavigationActions.navigate({\n      routeName,\n      params,\n    })\n  );\n}\n// add other navigation functions that you need and export them\nexport default {\n  navigate,\n  setTopLevelNavigator,\n};\n// In you saga.js\nimport NavigationService from '...../NavigationService';\nfunction goToProfilePage() {\n   NavigationService.navigate('App')\n}\nfunction* goToProfile(action) {\n    const { id } = action\n    try {\n        yield put(Creators.setSelectedPerson(id))\n        yield call('goToProfilePage')\n        // I want to navigate to another page in react native. this is an imperative call I am afraid. I eed to trigger it using something like this.props.navigation.navigate(\"nextpage\") where this is the class of a page. \n    } catch(e) {\n        console.tron.log(e)\n    }\n}\n```. ",
    "ansonyao": "Thanks for the great suggestions! @Andarist and @zeayal. I will close the issue now. . ",
    "jpggvilaca": "Doesn't work, even with the bootstrap. I think there's dependencies that need to be updated. Opened a PR for this: https://github.com/redux-saga/redux-saga/pull/1782\nSo, if you can't wait, just add these 2 missing devDependencies on the redux-saga's package.json and re-run npm install on the root folder. ",
    "aibolik": "I faced same problem. You should follow ReadMe from redux-saga.js.org, that states you should run this one too:\nnpm test\nIf you look at package.json you'll notice that in pretest step build will be ran, that is probably what was missing.. ",
    "andrevenancio": "Doesnt work. Neither following instructions on redux-saga readme.MD file nor doing npm i && npm start on the example/real-world folder.\n. ",
    "jiajianrong": "The same issue met too. ",
    "ranrolls": "The same issue still persist. ",
    "adamwright104": "@shinima thanks i've got that working now. however i'm not sure its doing the delay. Do you have a best practice example of polling for this? \nexport function *fetchSaga() {\n  while (true) {\n    const result = yield call(axios.get, 'http://api.timezonedb.com/v2.1/list-time-zone?key=EF1GEI5N2IAX&format=json');\n    yield delay(10000);\n    yield put(actions.fetch(result.data.zones));\n  }\n}\n```\n componentDidMount() {\n    this.props.fetch()\n  }\nrender() {\n    console.log(\"this.props.data\", this.props.data)\n    if(this.props.data) {\n      return (\n        \n\n\n\n\n                countryCode\n              \n\n                countryName\n              \n\n                timestamp\n              \n\n                action\n              \n\n\n\n            {this.props.data.map((item, i) => {\n              return (\n              \n{item.countryCode}\n{item.countryName}\n{this.CovertTime(item.timestamp)}\n {this.onClick(item.countryCode)}}>click me\n\n              )\n            })}\n          \n\n\n      );\n    }\n    else {\n      return (\n        {this.props.isfetching}\n      )\n    }\n  }\n}\nexport default connect(mapStateToProps, { fetch })(Table);\n```\nOk since posting i've got the delay working\n```\nimport { call, put } from 'redux-saga/effects'\nconst delay = (ms) => new Promise(res => setTimeout(res, ms))\nexport function *fetchSaga() {\n  while (true) {\n    const result = yield call(axios.get, 'http://api.timezonedb.com/v2.1/list-time-zone?key=EF1GEI5N2IAX&format=json');\n    yield delay(10000);\n    yield put(actions.fetch(result.data.zones));\n  }\n}\n```\nHowever this delay is done on initial load as well, which isn't what i want (but its progress). \nWhats the best practice to achieve this?. ",
    "josepot": "Hi @Andarist ! Thanks a lot for your quick response.\nDah! yep, of course, that makes a lot of sense.\n~~However, I do think that perhaps it would be useful to add another (optional) argument to instruct the effect that the channel can be closed if the task gets cancelled, as I think that in most use cases than would be the desired behaviour. What do you think?~~\nI just realised, that's ^^ not quite feasible because the last ...args are the arguments that are passed into the saga function... :thinking: What about adding another effect that behaves like that? Would that pollute the API too much? Anyways, I can always create my own generator that does that, no worries!\nAlso, perhaps it would make sense to add a little note in the docs to remind others that if they use takeEvery/takeLatest with a channel, it's their responsibility to close that channel (if they want to) when the task gets cancelled.. > That's a good suggestion, would you like to provide a PR for this?\nYep, for sure. I will try to get some time to do that before the end of this week. Thanks!. ",
    "z937010871": "\u6709\u4eba\u5728\u4e48, \u6c42\u89e3\u7b54 \u5404\u4f4d\u5927\u4f6c\u4eec. > You can only use the yield keyword in a generator function.\n\nIt seems that what you are implementing is \"when user clicks some button, dispatches some actions\". In your views, where you could access the dispatch function, then you could call the dispatch function directly. However in sagas, where you cannot access the dispatch function, you need to create an eventChannel from the click events, and then take from the eventChannel to let the saga get the click event.\nyield \u53ea\u80fd\u5728\u751f\u6210\u5668\u51fd\u6570\u4e2d\u624d\u80fd\u4f7f\u7528\u3002\n\u770b\u8d77\u6765\u4f60\u60f3\u8981\u5b9e\u73b0\u201c\u7528\u6237\u70b9\u51fb\u67d0\u4e2a\u6309\u94ae\u7684\u65f6\u5019 dispatch \u7279\u5b9a\u7684 action\u201c\uff0c\u5728\u89c6\u56fe\u90a3\u8fb9\u7684\u8bdd\u4f60\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528 dispatch \u51fd\u6570\u3002\u4e0d\u8fc7\u5728 saga \u4e2d\uff0c\u4f60\u9700\u8981\u4ece\u70b9\u51fb\u4e8b\u4ef6\u4e2d\u521b\u5efa\u4e00\u4e2a eventChannel\uff0c\u7136\u540e\u5728 saga \u4e2d\u4ece\u8fd9\u4e2a eventChannel \u4e2d take \u5f97\u5230\u70b9\u51fb\u7684\u4e8b\u4ef6\uff0c\u8fd9\u6837\u4f60\u7684 saga \u624d\u4f1a\u77e5\u9053\u300c\u6309\u94ae\u88ab\u70b9\u51fb\u4e86\u300d\u3002\n\n\u53ef\u4ee5\u5e2e\u5fd9\u5199\u4e2ademo\u4e48,\u521a\u5b66redux-saga\u548ces6 \u4e0d\u662f\u5f88\u61c2.. > Using eventChannel may be a little overwhelming. In this case, let's use the cps effect:\n\n```js\nimport { cps } from 'redux-saga/effects'\nfunction* update() {\n  const result = yield cps(cb => {\n    Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb('user-press-confirm') }])\n  })\n  if (result === 'user-click-confirm') {\n    yield put(back('LoginPage'))\n  } // else ...\n}\n```\nIn this case, yield cps(...) will be blocked until the cb is called. When user presses the confirm button, cb('user-press-confirm') is executed, and 'user-press-confirm' is assigned to result.\n\n\u4f60\u597d,\u5927\u795e \u521a\u521a\u8bd5\u4e86\u60a8\u7684\u65b9\u6cd5, \u62a5\u9519\u4e86\n\n. > \u4e0d\u597d\u610f\u601d\uff0ccb('user-press-confirm') \u90a3\u8fb9\u6211\u5199\u9519\u4e86\u3002\u9700\u8981\u6dfb\u52a0\u4e00\u4e2a null\uff1a\n\ndiff\nfunction* update() {\n  const result = yield cps(cb => {\n-   Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb('user-press-confirm') }])\n+   Alert.alert(message, null, [{ text: '\u786e\u5b9a', onPress: () => cb(null, 'user-press-confirm') }])\n  })\n}\n\n\u55ef\u55ef,\u89e3\u51b3\u6389\u4e86,\u975e\u5e38\u611f\u8c22\u60a8!\n\u5389\u5bb3!!!. ",
    "hallvar": "The referenced issue of where to have related discussions is this one. What is the correct issue number?. ",
    "alexsbryan": "Sounds reasonable, thanks for the response! That answers my question.. ",
    "etairi": "Thanks, this worked!. ",
    "mfoncho": "@shinima thanks i have added index.html. With that said please try again using the plus (+) and minus(-) buttons instead because the buttons fire actions  watched by redux-saga. @shinima  i have updated the repository please get a clone and try out the SAGA ACTIONS, (They not working as they are suppose to). I have been stuck here for hours trying to figure it out but i can't get redux-saga watchers to fire . Thanks for @shinima. Finally it works honestly i didn't expect redux-devtool to be the problem really when i remove the compose without redux-dev tools and simply just used the saga middleware as is, it worked fine. Thanks @shinima . compose with redux-devtools as last argument\nstore.js\n```javascript\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport sagas from './sagas';\nconst reducer = ( state, action) => {\n    switch(action.type){\n        case 'ADD_COUNTER': return state + action.payload;\n        case 'SUBTRACT_COUNTER': return  state - action.payload;\n        default : return state;\n    }\n}\nconst state = 0;\nconst sagaMiddlewares = createSagaMiddleware();\nconst devToolsMiddleware = window.REDUX_DEVTOOLS_EXTENSION();\nconst middlewares = applyMiddleware(sagaMiddlewares)\nconst store = createStore(reducer, state, compose(middlewares, devToolsMiddleware));\nsagaMiddlewares.run(sagas)\nexport default store;\n```. ",
    "alcuadrado": "There's a brief mention on how it works there: \n\nIn the above example, cancellation of bgSyncTask will cause the Generator to jump to the finally block. Here you can use yield cancelled() to check if the Generator has been cancelled or not.\n\nMaybe making it more detailed would work. What about something along the lines of \n\nIn the above example, cancellation of bgSyncTask will use Generator.prototype.return to make the Generator jump directly to the finally block. Here you can use yield cancelled() to check if the Generator has been cancelled or not.\n. \n",
    "oamunoz": "Shinima, thank you for expanding on how takeEvery and it's cancellation work. After I read your post I went back to re-read my code and saw that I was basically dispatching watcher tasks rather than the actual sagas that were supposed to be responding to specific actions. It makes sense why I was getting multiple sagas responding to the single action. \nThank you!\nBy the way, in dealing with the issue above I came up on an article you helped write RootSaga. Will you guys be moving that to your docs?  That would have been super useful when I was creating the root saga for the first time!\n. ",
    "anxiaoyi": "\nYour example code is based on dva, and it seems that there's big difference between dva and redux-saga about accessing effect creators. I am not very familiar with dva, maybe you should open an issue in dva repo.\n\nOK, Thank You. ",
    "compulim": "Thanks for the explanation. Good to know.. ",
    "951565664": "Is it preventing code packaging errors?I know that a semicolon may be added at the beginning of the file.. ",
    "nvolungis": "Hey! Thanks for taking a look at this. I've updated deps as follows and still see the same error: \nredux-saga: 1.0.0-beta.1\njest: 24.0.0-alpha.6\nredux-saga-test-plan: 4.0.0-beta.1 \n1.0.0-beta.1 is the latest that redux-saga-test-plan has support for.\nconsole output w/ the above deps \n\nI tried setting the repo up to run against master but couldn't figure out how to build and reference a local redux-saga repo. Perhaps the fix really does lay in the diff between 1.0.0-beta.1 and master?\n. ",
    "khaliu": "I think you should check this in the fork API Docs:\n\nAll forked tasks are attached to their parents. When the parent terminates the execution of its own body of instructions, it will wait for all forked tasks to terminate before returning.\nTo create detached forks, use spawn instead.\n\nSo, you won't leave secondSaga until the third ends as the Third will be attached to it, but first it will resolve all the secondSaga body block.\nTry using Spawn instead.. Hi there! From my understandings:\n1 - Remember that put is an effect that tells the middleware to dispatch the real action, as a list of instructions. You can call the real dispatch from the generator, but it isn't declarative and it doesn't gives you any benefits for testing purposes.\n2 - I'm not really sure if you make parallel work dispatching both actions, but making a put in that way, calls ultimately the dispatch, that runs synchronously (redux).. Yup, if you put a list of puts when the execution reaches the dispatches it will be executed synchronously. ",
    "c-goettert": "Thanks for your reply! \nRegarding to Question 2: If I understand you right, the answer to my question yes? (the order of dispatches will be called in the given order)?. Thanks for the answers!. ",
    "jonogilmour": "Nevermind, seems the issue was using next().next() which I think throws out any error handling by saga in test-plan. ",
    "Taym95": "Do you want to catch all uncaught exceptions? if yes you can do it like this:\nconst rootTask = sagaMiddleware.run(rootSaga);\nrootTask.done.catch(function (err) { console.log(\"Error in Sagas\", err); });. ",
    "kabike": "\nDo you want to catch all uncaught exceptions? if yes you can do it like this:\nconst rootTask = sagaMiddleware.run(rootSaga); rootTask.done.catch(function (err) { console.log(\"Error in Sagas\", err); });\n\nBut in this way, the rootTask has been stopped.. Or how can I make the following code keep running even though there is an error in Api.fetch\n```\nexport function* getAllProducts() {\n  const products = yield call(api.getProducts)\n  yield put(actions.receiveProducts(products))\n}\nexport function* watchGetProducts() {\n  yield takeEvery(actions.GET_ALL_PRODUCTS, getAllProducts)\n}\n```. ",
    "savage-puppie": "It has happened 1 time with 1 user. He were using Google Chrome v. 70.0.3538 on Mac OS X\nv. 10.13.6. Yes, I'm not using the ModuleConcatenationPlugin, but I'm indeed using WebPack 4 (v. 4.16.2). Oh, I've searched for \"ModuleConcatenationPlugin\" in my production webpack config file and didn't find anything. But if this is enabled by default, then I'm probably using it. I've uploaded my config file, let me know if it can help you:\nhttps://gist.github.com/TheoneLucas/e24327741064d0408a419fc68691225c. I checked the documentation for onError function and I will send a bugfix implementing it on my application now, making it send the error to Sentry and as soon as an error is captured with it I will come back here with all the information it gathered.. I just noted that my application already have an onError handler on createSagaMiddleware function, and it was on production at the time this bug happened.. I don't think so, as the onError function handler don't appear on the error stack.. Ok, if this error happen again I will make sure to get back on here with more details.. ",
    "Fs00": "I tried using a try/catch block in rootSaga, but exceptions coming from retrieveCommitsListPage are not caught. Is that because takeLatest is called inside an array declaration?\nHowever, I feel like that onError behavior is kinda flawed. In this way, \"potentially catchable\" errors that are uncaught will never be reported. And furthermore, API reference is not clear at all on this point.. @restrry If the code you posted doesn't catch errors, then an exception which is \"bubbled up\" is not necessarily catchable? I think there's something that I'm missing.\nAnd I suspect I'm currently making some mistakes, because the generator authFlowSaga in my code is not forked (and probably it should, since it doesn't return a task descriptor). I'll do some more testing and I'll let you know.\nEDIT: onError works as intended. It turned out that:\n- I didn't realize that the !task.cont condition is reached for every running task, up to the rootSaga\n- I made a mess with default exports and thus the onError function I passed was a different one (which obviously didn't log anything)\nSo the overall behavior is correct, like @restrry explained. The only thing I can't get is why in rootSaga I can intercept bubbled errors from forked tasks with a finally block, but not with a catch one.. My situation in the root saga is now almost the same as the one described here in the docs:\njs\ntry {\n    yield all([task1, task2...]);\n}\nfinally {\n  yield put({...});\n}\nWhen one of the tasks fails for whatever reason, the finally block is entered. But if I had catch instead of finally, put wouldn't be called.\nI honestly can't find a logical explanation for that behavior.. I have no problems anymore. It's just that I can't understand the behavior of fork exceptions described in the docs. You say that an exception bubbled from a task is not catchable (and it's true), but then why am I able to intercept it using a finally block? . Oh lol, I'm dumb. :joy:\nI forgot that it's the normal behavior of finally. Thus, since in the try I have an all Effect which includes at least a task that runs a while(true) loop, whenever a task fails, all Effect aborts and the finally block is reached.\nThanks everyone for helping me to reach the conclusion. And sorry for the time I took you.:smile:. ",
    "mralj": "I have managed to solve issue \ud83d\ude04 \nIt had nothing to do with redux-saga.\nThe problem was that we were not closing HTTP connections after race, I have completely forgotten that even though race will cancel saga task, it will NOT actually cancel network request.\nSo the only thing I needed to do, was to change our post method to look smth. like this. \nOf course more info about cancelation can be found  in the docs.. ",
    "lukasbash": "If I may throw in a question, even if its a specific one.\nWhat is the status on infering type definitions over the yield keyword?\nI could not find the correct issue in the typescript repo directly. Do you have any updates in here if this is \"only\" a TS thing, or if you have to fix something in the lib as well?. @TotooriaHyperion Thanks for your reply!\nInteresting pattern I see here:\ntypescript\nconst query = QueryModelEffect(......);\nyield query;\nThe thing is, with this pattern, you get the type inference of the effect and not the type of the value it could possibly return or deliver.\nLet's make an example of a casual select effect in a saga:\n```typescript\n// state is now typeof \"ReduxSagaEffects.SelectEffect\"\nconst state = select();\nyield state;\n// here i want to have to use the actual type of my redux state and not just the effect\n// this should happen automatically\n```\nThe issue stays the same, as you are describing the return value of the effect with generics the result would be the same as if I would type it manually like:\ntypescript\nconst state: MyState = yield select();\nMaybe I did not understand the example correctly. Or it might be that I also did not understand the saga typings correctly. But the effect descriptor should in my opinion already know the type of the delivered value. And yield should be just a passthrough as it does actually not alter any values, it just describes how to wait or not wait for code execution.\nAnything wrong here in my thoughts?. ",
    "TotooriaHyperion": "@lukasbash @restrry \nIn my view, it's noway to define the type when the value itself doesn't linked to a real runtime type.\nMeans only if the language treat a type as an object too, or this type inference would be impossible.\nA pre-defined type is also unacceptable, as it couples the generator function and the effects. Which makes the generator function not pure, and the effects not reusable.\nBut on the other hand, I think what really matters is that an effect description should have close connection with the expected behavior of the effect, which means including the type that(whenever it needs) to be returned.\nThus I got an idea to solve the problem by a convention that an effect description as an object, has a key, to carry the result back.\nExample:\n\ngot an idea to have yield return type connect with the yield value type:\n```ts\ninterface EffectBase {\n  type: EffectType;\n  ret: T;\n}\nasync function* testCall() {\n  // we can define the type of return value of QueryModelEffect\n  // meanwhile define the type of the future return: query.ret\n  // as the type of an effect description should match with it's yield return value type\n  const query = QueryModelEffect(......);\n  yield query;\n  const { id, name } = (await query.ret)!;\n  console.log(123, { id, name });\n}\nasync function exmpleRunner() {\n  const gen = testCall();\n  let done: boolean = false;\n  while (!done) {\n    const res = await gen.next();\n    done = res.done;\n    if (done) {\n      break;\n    }\n    res.value && (res.value.ret = await performEffect(args));\n  }\n}\n```\nnot sure if it's anti-pattern, but works well for my case as all the yield value is a simple object describing the effect.\n\n. @lukasbash \nManually type it is a good solution, but it split code into parts.\nSometimes we want auto type inference, especially when using third-party library.\nMy case was using with sequelize, and manually write the returntype of an model's querymethods is verbose.\n```typescript\nimport EffectType from \"./constants/effectType\";\nimport SequelizeModel from \"./interfaces/SequelizeModel\";\nimport EffectBase from \"./interfaces/EffectBase\";\nexport type QueryModelArgs = [\n  Model,\n  M,\n  Model[M] extends AnyFun ? Parameters : undefined\n];\nexport type QueryModelRet<\n  Model,\n  M extends keyof Model\n\n= Model[M] extends AnyFun ? ReturnType : any;\n\nexport interface QueryModelEffect\n  extends EffectBase> {\n  type: EffectType.QUERT_MODEL;\n  args: QueryModelArgs;\n}\nexport default function performQueryModel<\n  T,\n  M extends keyof SequelizeModel\n\n([model, method, param]: QueryModelArgs, M>): QueryModelRet<\n  SequelizeModel,\n  M\n{\n  return (model[method] as any)(...(param as any));\n}\n\nexport function queryModel>(\n  args: QueryModelArgs, M>,\n): QueryModelEffect, M> {\n  return {\n    type: EffectType.QUERT_MODEL,\n    args,\n    ret: undefined as any,\n  };\n}\n```\nIn this example, we only need to type once, then we can use it for all model.(super convenient on generic type)\nYieldType is connected to YieldReturnType automatically.\nSpecial trick to simplify code written in typescript.\nSince it's unlikely and also impossible for typescript to support YieldReturn type as I have said above, so I did it in another way.\nThis actually should be done by language using type as a object. But in js, I only find this way to use yield with ts conveniently.. ",
    "guillaumewuip": "Thanks for your answer @restrry \nI'm not sure the custom matcher can help me in this case. I don't know the id value and I don't want to match only one id value either.\nI would like a generic way of grouping actions with takeLatest, ie. having a way to tell takeLatest to only cancel previous task if the corresponding previous action has the same id as the actual one.\nActually takeLatestDeep looks like a bad name for a helper like that. It's probably better named takeLatestGroup.. Yep, no problem @Andarist !\nThanks for your time :). @rami-res I just found your issue. Same thing for me today.\nWhat is maybe going on here is that your TS loader also check test files (because you probably don't use redux-saga-test-plan in your production code).\nIn my case, awesome-typescript-loader is used in webpack. It seems to have a phase of checking types across all files matching the tsconfig props files. If you don't provide a files prop, it check all TS files of your project apparently.\nSo the trick here is to set files to an empty array and ATL we only check files it has to load. In your tsconfig.json : \njson\n...\n  files: [],\n...\n\nOf course this is not the \"real\" solution. What I understand is that redux-saga-test-plan use some redux-saga types the wrong way. Maybe because you use redux-saga v1+.\nIn my case : \n- redux-saga-test-plan@v4.0.0-beta.2 that for example include this code  \nhttps://github.com/jfairbank/redux-saga-test-plan/blob/29497d7b516209b2cd9a48d316a43a24ef71b338/effects.d.ts#L12-L15\n\nredux-saga@1.0.0 where I see this type \n\nhttps://github.com/redux-saga/redux-saga/blob/fc6a2e3d5b1aa37864a13be6db3115ad6afc1f1b/packages/types/index.d.ts#L24\nSo that's why I get a compile error telling for example : \nERROR in [at-loader] ./node_modules/redux-saga-test-plan/effects.d.ts:13:16\n    TS2314: Generic type 'Pattern' requires 1 type argument(s).\nSo @Andarist I'm pretty sure that's a problem on redux-saga-test-plan side, not redux-saga.. Another way is to use ATL reportFiles option to exclude tests files.. Btw it's seems to be fixed on redux-saga-test-plan master.\nhttps://github.com/jfairbank/redux-saga-test-plan/blob/24b5da95d528809679e273e86800dd408e5aa9ae/effects.d.ts#L12-L15. Hello @Andarist @rami-res \nI'm not sure redux-saga should change. It's a problem with redux-saga-test-plan as I've explained here : https://github.com/redux-saga/redux-saga/issues/1793#issuecomment-467975398. ",
    "jchapelle": "I did found what was causing the issue but I don't understand it.\nI actually migrated my project to the last version of the boilerplate.\nPreviously, the sagas was ran liske this\nexport default function* githubData() {\n  const watcher = yield takeLatest(LOAD_REPOS, getRepos);\n  yield take(LOCATION_CHANGE);\n  yield cancel(watcher);\n}\nNow it is ran like that:\nexport default function* githubData() {\n  yield takeLatest(LOAD_REPOS, getRepos);\n}\nCan somebody explain ?\nThanks in advance. ",
    "ajanauskas": "I doubt this is redux-saga issue. If you want to modify 2 state branches within redux store with 1 action then make multiple reducers respond to same action:\n```javascript\n// actions types\nconst FETCH = 'FETCH'\nconst FETCH_SUCCESS = 'FETCH_SUCCESS'\n// Reducer 1\nimport { FETCH, FETCH_SUCCESS } from './actionTypes'\nconst initialState = {\n  fetching: false\n}\nexport default (state = initialState, action) {\n  switch (action.type) {\n  case FETCH:\n    return {\n      fetching: true\n    }\n   case FETCH_SUCCESS:\n      return {\n         fetching: false\n       }\n    default:\n      return state\n  }\n}\n// reducer 2 somewhere else\nimport { FETCH_SUCCESS } from './actionTypes'\nconst initialState = {\n  data: null\n}\nexport default (state = initialState, action) {\n  switch (action.type) {\n   case FETCH_SUCCESS:\n      const formattedPayload = formatPayload(action.payload)\n      return {\n         data: formattedPayload\n       }\n    default:\n      return state\n  }\n}\n```. ",
    "vishnukalakota": "@ajanauskas  thanks for help.\ni fixed it. \nthanks you so much. ",
    "martinkadlec0": "React hooks are out. Really looking forward to some less experimental saga hooks :). ",
    "RubenSandwich": "@Andarist Thank you so much for your experimentation and example.\nI cleaned it up a bit, mostly just removed the unused code: https://codesandbox.io/s/v10vr0pj53.\nOne problem I can see with this implementation, however, is that I believe it ties the hook to the component lifecycle. (When the component dies so does the sagas.) I wonder if there is any way to prevent that. (My first pass would be creating a global \"sagaEnv\" and then passing that in when creating the useReducerAndSaga hook, but I have a feeling that if we want long-running sagas then we need global state so we are already better served with Redux. \ud83e\udd37\u200d\u2640\ufe0f However, I still think it's worth exploring and a Redux less Redux-Saga would be helpful in some circumstances.). ",
    "GabrielFerrarini": "If I understand you correctly, then put doesn't \"execute\" the action. It dispatches it to the redux store and then other sagas will listen and execute the actions independently (depending on how you implemented them). If you want the actual queries/api calls to be executed in parallel and awaited for, you should yield an array of \"call\" effects, like this: https://redux-saga.js.org/docs/advanced/RunningTasksInParallel.html. When you call\nconst action = services.users.find({ query });\nyou probably want to use a call effect.\nconst user = yield call(services.users.find, { query });\nAlso, make sure you are not crating a variable with the same name of your argument. You're receiving action and declaring another action inside your function.. ",
    "tomzaku": "@GabrielFerrarini Thanks. The main reason i don't want to duplicated the code because I wrote 5 query in saga. \nfor example:\nfunction* queryList(action: ActionResourceType<\"QUERY\">) {\n        const data = yield call(ajax.query(serverConfig), action.payload.params)\n        yield put(actionCollection.addManyLocal(data))\n}\n...\nyield takeLatest('@@app/PCPPRIMARYSPECIALTY/QUERY', queryList),\nIs there anyway to avoid duplicated?\nThanks . ",
    "knpwrs": "Ah, take('*'). That's very interesting. Would the select effect be executed before or after the action makes its way through the store? That is, would I get the state resulting from that particular action or would I get the state from before that action?. Awesome. That only leaves me with two questions:\n\nIs that order of execution something that the redux-saga maintainers would be willing to commit to? Meaning if it changes that would be considered a breaking change which would constitute a major semver bump?\nWould you mind if I were to distribute that code snippet as an NPM module under the MIT license?. Published on npm as redux-saga-selector-channel!\n\nSource code: https://github.com/knpwrs/redux-saga-selector-channel\nThanks for the help!. ",
    "MirelesCloud": "@Andarist yeah, that was a good idea, but it I get the same error.   I've been at it for days.. @michaelcavallaro03 \nThanks for pointing that out.  I've checked the URL syntax I don't know how the ? disappeared in my original post.  And yes I'm painfully aware about the giphy api limits.\nAt any rate I'm tackling the looping a little different.  I've removed the while loop from the saga and instead added this to my page component.  \n `componentDidMount() {\n      this.props.dispatch({type: 'API_CALL_REQUEST'});\n      this.interval = setInterval(() => {\n         this.props.dispatch({type: 'API_CALL_REQUEST'});\n      }, 5000);\n  }\n\n  componentWillUnmount() {\n     clearInterval(this.interval)\n }\n `\n\nMy saga looks like this now.\n `function* fetchImages() {\n    try {\n      let randomWord = require('random-words');\n      let API_ENDPOINT = \n        `https://api.giphy.com/v1/gifs/search?api_key=MYKEY&q=${randomWord()}&limit=1`\n      const res = yield call(() => axios.get(API_ENDPOINT))\n      const images = yield res.data\n      yield put({type: API_CALL_SUCCESS, images})\n\n    } catch (e) {\n      yield put({type: API_CALL_FAILURE, e})\n      console.log('Error fetching data')\n  }\n }\n\n export default function* giphySaga() {\n   yield all([\n     yield takeLatest(API_CALL_REQUEST, fetchImages),\n  ]);\n }\n `\n\nI've tested the loop with a simple saga generator function yield takeLatest(API_CALL_REQUEST, someTestSaga) and it works like a charm but when I plug in the fetchImages generator function as shown above no data gets returned and the browser console shows  \"index.js:2429 GET... 404 (Not Found)\" error.  Somehow the yield put({type: API_CALL_SUCCESS, images}) is interfering with yield takeLatest\n. Well at long last I got it figured out.  I realized that yield takeLatest(API_CALL_REQUEST, fetchImages) only calls the function, but doesn't pass the data on to the store.  Then I simply did this.\n export default function* giphySaga() {\n  yield all([\n  yield takeLatest(API_CALL_REQUEST, fetchImages),\n  call(fetchImages)\n   ]);\n }\n\nMaybe my whole process is slightly contrived, but I got it working.  Nevertheless, I would appreciate any feedback before I close this out.  . @Andarist I know the function you're referring to looks strange, but when I do this\n  export default function* giphySaga() {\n     yield all([\n       yield takeLatest(API_CALL_REQUEST, fetchImages),\n ]);\n}\n\nthe fetchImages() gets triggered, but that data does not get passed to rendering component.  Only  when I added the yield call(fetchImages), the data got passed to the component.  \nTo your question on what I'm trying to achieve; it's to fetch and show new images every 5 seconds.\nHere's the repo https://github.com/MirelesCloud/nextjs_boilerplate\nI would love to find out what I did wrong and how I can improve this.. @Andarist I have made the changes of your patch on my local file, but  I got the same error as previously:  Unhandled Rejection (TypeError): Cannot read property 'data' of undefined\nreferring to\n function mapStateToProps(state) {\n   return {\n     imageData: state.giphy.images.data,\n  }\n}\n\nHowever, your method worked for the simple example Saga inside the project.. ",
    "michaelcavallaro03": "@MirelesCloud \nNot sure if you're still having trouble but your api call seems to be incorrect URL syntax. You're missing the param separator ?\nlet API_ENDPOINT =`https://api.giphy.com/v1/gifs/search?api_key=MYKEY&q=${randomWord()}&limit=12`\nTested on my local machine, you should be good now, however I noticed delay does not seem to be working as expected. But your overall issue should be corrected by this API call \ud83d\udc4d \nEDIT: Worth noting that giphy limits the number of API Requests you perform so you may still be getting a number of failures because it will deny your request, especially working in essentially an infinite loop. . ",
    "aarosil": "Thanks, I'll try this out. \nIs there any issue for tracking the v1.0 release, or any update docs I can view? I'm interested in breaking changes and stuff I can get ready to try the release candidate.. Thanks, I'll try this out. \nIs there any issue for tracking the v1.0 release, or any update docs I can view? I'm interested in breaking changes and stuff I can get ready to try the release candidate.. Thanks, it looks great! \nI have one more question regarding your other other suggestion to use onError option of createSagaMiddleware to dispatch the SET_ERROR_STATE action.\nHow would I access dispatch from within the function I give as onError? Store is not created yet, so I don't have reference to dispatch. \nI'm thinking I may not understand that suggestion fully . Thanks, it looks great! \nI have one more question regarding your other other suggestion to use onError option of createSagaMiddleware to dispatch the SET_ERROR_STATE action.\nHow would I access dispatch from within the function I give as onError? Store is not created yet, so I don't have reference to dispatch. \nI'm thinking I may not understand that suggestion fully . Sorry, I'm still not following 100%! \nI'm using vanilla store creation similar to the below, from the tutorial:\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport createSagaMiddleware from 'redux-saga'\n// ...\nimport { helloSaga } from './sagas'\nconst sagaMiddleware = createSagaMiddleware({\n  onError: () => {\n    // how to access dispatch at this point?\n  }\n})\nexport default createStore(\n  reducer,\n  applyMiddleware(sagaMiddleware)\n)\n```\nCould you share a quick gist of accessing store from the outer scope? . Sorry, I'm still not following 100%! \nI'm using vanilla store creation similar to the below, from the tutorial:\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport createSagaMiddleware from 'redux-saga'\n// ...\nimport { helloSaga } from './sagas'\nconst sagaMiddleware = createSagaMiddleware({\n  onError: () => {\n    // how to access dispatch at this point?\n  }\n})\nexport default createStore(\n  reducer,\n  applyMiddleware(sagaMiddleware)\n)\n```\nCould you share a quick gist of accessing store from the outer scope? . ",
    "levenleven": "@restrry So basically there's no \"built in\" mechanism for global error handling (which won't terminate the whole saga tree)? \nExample use case: if any network call results in 401 - redirect to login page. @Andarist Sure, that's what we did.. But there're some other cases (reporting, etc.) where it could be useful. Also having global error handler I can be sure that all errors will be reported (just for example), in opposite to having a \"wrapper\" that developer can choose not to use for some reason.\nAnyway, thanks for suggestion!. What I was looking for is the option to analyze the error and decide if it should blow up the entire app or not.. Typo: why -> what. Sure, no problem. ",
    "kheyse-oqton": "\nIf you have synchronous communication like this between sagas you can only perform a synchronous effects (ie select) before you setup take for the SUB_PROCESS_SUCCESS.\n\nHow do I know which effects are synchronous? It does not seem to be explicitly mentioned in the docs. For some it's clear (e.g. select), but for others not (e.g. put, put.resolve, cancel, call,...).\nAnd even for synchronous effects, like select, does redux-saga GUARANTEE that the after the yield select, control immediately returns to the same saga and does not transfer to any other saga?\nEDIT: I have found, for instance, that yielding a put does not necessarily immediately return control back to the yielding saga, and  that it may transfer to a different saga.\n\nIf your success response is always synchronous you dont even have to take it though. // EDIT: i guess you need it if you want to receive some result from that take\n\nI've edited the example to make clear that the respondSaga is an asynchronous saga.\n. It would make sense to assume that both select and put are synchronous effects, but then you would expect this to not fail:\njavascript\nconst reducer = (state = 0, action) => (action.type === 'ACTION' ? state + 1 : state);\nfunction* helperSaga(id) {\n  const state = yield select();\n  yield put({ type: 'ACTION', id });\n  const newState = yield select();\n  if(newState !== state + 1) throw new Error();\n}\nHowever, when you launch helperSaga multiple times like this:\njavascript\nfunction* callerSaga() {\n  yield takeEvery('START', function* callSaga(action) {\n    const calls = [];\n    for (let id = 0; id < 3; id += 1) {\n      calls.push(call(helperSaga, id));\n    }\n    yield all(calls);\n  });\n}\nThen the helpersaga will throw an error, so either select or put must be async (by which I mean: some other saga execution is interleaved).\nMaybe this is considered weird usage, but its just multiple calls, and dispatching actions conditionally based on the state is a common thing to do so I need to be sure that is the latest state.\nTo make it more concrete: does redux-saga guarantee this to not throw an error?\n```javascript\nconst reducer = (state = 0, action) => (action.type === 'ACTION' ? action.id : state);\nfunction helperSaga() {\n  yield takeEvery('ACTION', function callSaga(action) {\n    const state = yield select();\n    if (state !== action.id) throw new Error();\n  });\n}\nconst N = 1000;\nfor (let id = 0; id < N; id += 1) {\n  store.dispatch({ type: 'ACTION', id });\n}\n```. ",
    "edzillion": "\nYes, errors propagate through the \"saga stack\". So if you inner doesnt handle it the outer saga has a chance to handle it. This applies to call/apply/cps effects (and other blocking ones, i dont mention here ie select as u generally dont want ur select effects to throw)\n\nOk, thanks for the clarification.\nI wonder why the parent saga isn't catching the error here? The call stack shows:\n[14:04:16] uncaught at rootSaga, at rootSaga                                                                                               \n at rootSaga                                                                                                                               \n at takeEvery                                                                                                                              \n at signUp                                                                                                                                 \n TypeError: Cannot read property 'username' of undefined\nso I put a try catch block around the yield all that spawns this saga, like so:\nfunction * onboardingSaga () {\n  try {\n    yield all([\n      takeEvery(INIT_SIGN_UP, initSignUp),\n      ...\n    )]\n  } catch (err) {\n    // still not getting the error here\n  }\n}\nBut I still can't catch the error. super confused.\n. Fine but I consider this question still unanswered. Probably needs documentation. ",
    "tichaonax": "So we had this scenario and realized we needed a \"higher order function\" approach. The idea is you implement the try catch in the higher function and it will catch all errors that happen inside your saga. In our case we log to redux these errors and is helpful during debugging, but you could easily do what you want with the errors. Notice you do not need the try catch in your sagas it is all in one place. createAction is nothing but a utility function that creates actions to spare you the pain of writing actions manually.\nexport const createAction = (type, ...argNames) => {\n  return (...args) => {\n    let action = { type };\n    argNames.forEach((arg, index) => {\n      action[arg] = args[index];\n    });\n    return action;\n  };\n};\n(A) Create a file that has both the action and the higher order function\n......\nimport { put } from 'redux-saga/effects';\nimport { createAction } from '../utilities';\nexport const SET_SAGA_ERROR = 'SET_SAGA_ERROR';\nexport const setSagaError = createAction(SET_SAGA_ERROR, 'errors');\nexport function safeSaga(func) {\n  return function (args) {\n    try {\n      yield func(args);\n    } catch (error) {\n      yield put(setSagaError({ saga: func.name, args, error }));\n    }\n  };\n}\n(B) Then your saga will be something like this\nimport { call, put, takeLatest } from 'redux-saga/effects';\nimport { updateCart } from '../../services';\nimport { safeSaga, CART_ITEMS, updateCartItems } from '../../actions';\nfunction* cartUpdate(action) {\n  //your saga implementation\n  const { data } = yield call(updateCart, action.items);\n yield put(updateCartItems(data));\n}\nexport function* cartUpdateSaga() {\n  yield takeLatest(CART_ITEMS, safeSaga(cartUpdate));\n}\nexport default cartUpdateSaga;\n* you can put logging steps in the safeSaga function to see exactly what is happening *. ",
    "jsmasterathul": "I was importing the eventChannel in the wrong way, got the answer in stackoverflow. I was importing the eventChannel in the wrong way, got the answer in stackoverflow. ",
    "FantasticSWT": "Sorry my bad. After a sleep, problem goes to JSON.stringify(data). The data is of circular-json.. \nThis is the result of console.log(action).\nBefore that, i got value printed ( 6 , 0 , 0 , 30) .But when it triggered by take(pattern), the value become undefined.\nThis is my redux action.\n\nRedux-saga version 0.16.2. It seems like dispatched actions have limited number of arguments. As reference to: https://github.com/vuejs/vuex/issues/366\nMy temporary work around is to lessen the parameters by creating objects.. ",
    "martijnjanssen": "It's the same as any other import, it just does not require building the entire codebase.\nThe change would be importing\nimport createSagaMiddleware from 'redux-saga/es/redux-saga.mjs' \ninstead of\nimport createSagaMiddleware from 'redux-saga'. We are using redux-saga just like you are, but not combined with react. We are using https://github.com/Polymer/lit-element for the webcomponents implementation, this is easily combined with redux and saga, similarly to react. This can all be served by a simple webserver.\nFor the build it is possible to simply find all imports in the components, process (minify, transpile, whatever you want) them and output all the files in some build directory. When serving this build directory (Nginx or another fileserver) all correct import paths are preserved. Redux-saga will then reside in, for example, /node_modules/redux-saga/redux-saga.js or similar.\nImplementation in another framework or native javascript is actually the same as using it in react. I think that react making all these abstractions in the build process is not that beneficial, since people are so dependent on the current build system (webpack). There are a lot of ways to achieve the same thing and allow for more tweaking or freedom in implementation.. Yes, there is a mapping directly to the files right now, using the path. This indeed causes a waterfall, but this can be changed using a bundle action (or something similar) in the build step later on. We just don't want a dependency on webpack.. So, I just tested it, and it works flawlessly. I'm using the redux-saga-core.esmodules-browsers.js and redux-saga-effects.esmodules-browsers.js files when importing saga, I don't see where I would run into issues with the chunks having hashes in their filenames. Am I missing something after all?. ",
    "TimvdLippe": "Another problem with the current ES bundle is that the imports are not proper ES module imports. The imports do not have the .js extension appended. E.g. instead of:\njs\nimport { fork } from './io';\nthe browser (and Node in the future) needs:\njs\nimport { fork } from './io.js';\nWithout the extension, the browser will GET the file and 404, as ./io does not exists (while ./io.js does exist). I am having trouble setting up my project and using redux-saga, so I will try to make a browser-compatible bundle and open a PR. Working on it :smile: . I tried to find the configuration, but failed to do so. https://unpkg.com/redux-saga@0.16.2/ shows that there is a es folder in the npm build, but I can't find that anywhere locally. Nor can I run npm pack to generate the bundle, as lerna is used. lerna version --force-publish --amend does not generate a package either.\nCould you update your CONTRIBUTRING.md to specify how I can generate a publishable bundle and how I can debug the Rollup config?. I just realized that the build configuration was changed between 0.16.2 (latest version on NPM) and the latest release candidate of 1.0.0 (https://unpkg.com/redux-saga@1.0.0-rc.0/). The latter indeed no longer has a es build folder.. We dont use any bundler. We npm install redux-saga and then use es modules\nin the browser to import the relevant parts. We serve using python\nhttp.server.\nSince redux and redux-saga should only be installed and loaded once, they\nare peers in node_modules.\nOn Sat, 29 Dec 2018, 19:00 Mateusz Burzy\u0144ski, notifications@github.com\nwrote:\n\nIm still wondering how do you plan to consume it - do you use any bundler?\nredux-saga has no peer dependencies but if it would - how would u consume\nthem (they would be referenced as npm modules in the source)?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/redux-saga/redux-saga/pull/1717#issuecomment-450509631,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AFrDb8A6oNByC8_hqLlh__bxDFH2o2Y2ks5u9629gaJpZM4ZkoFY\n.\n. No problem at all!\n\nAt build time, we copy and process only the relevant files to our build folder. This includes node_modules files. This means that all unused (configuration) files are removed when building a production bundle.\nDuring dev, we have a simple server which just returns files. No processing or transformations there.\nWe do not use React. Just good old JavaScript with some libraries (like yours).. Sadly I haven't found the time to process your review feedback. @martijnjanssen do you have time to go through the feedback and resolve them?. It should just work, as long as the chunks are published as well.. Awesome! Thanks again for continuing this PR and sorry for my lack of time suddenly \ud83d\ude04 . ",
    "ktrungha": "\nYes - you are right that forks are probably not technically needed there, but by using forks you are allowing yielding generator to reach its end (because task descriptors will be returned to the yielding generator and it will proceed to next line, while with calls it would block indefinitely - waiting till all watchers end)\n\nNow this just comes to my mind: Taken into account what you said, it seems there is no need to call all we can just call fork like fork(watchNavigate); fork(watchLoadUserPage); fork(watchLoadRepoPage); fork(watchLoadMoreStarred); fork(watchLoadMoreStargazers). No need to wrap these with all outside. If you say so I think it's clearer to use an option that is the minimal. It makes understanding the example easier. I have a coworker who is very confused about setting up root saga with many ways of writing it.. ",
    "MatteoGioioso": "Edited my question. @Andarist Thank you, it is certainly more clear now.. ",
    "SergeyVolynkin": "Oh, I see. \nPlease, close :). ",
    "kkesley": "turns out I'm using older version of redux-saga in one of the library. fortunately that library was mine so I upgraded the redux-saga version and redeploy it.. ",
    "jeveloper": "@kkesley  curious how you made it work if another lib is using an older version , are you just forking it and modifying it ? . ahh yeah, unfortunately, there are other libs with dependencies below 1.x \nmakes things difficult . ",
    "joseph-d-p": "@Andarist, my bad. After adding a catch, the error was unrelated. Thanks!. Well an action can be handled both in saga and reducer.\nPersonally, I let saga handle external stuff while the reducer manages the internal store.\nGiven that the API you're using doesn't have any means to subscribe for updates,\nwas thinking like this:\njs\n// Reducer\nagendaItems = (state = InitialState, action) => {\n  switch (action.type) {\n    case Action.AGENDA_ITEM_DELETE:\n      // calculate index to delete\n      // update state without the deleted item\n    case Action.AGENDA_ITEMS_UPDATED:\n      // update state for all agenda items\n  }\n}\nThe component makes use ofagendaItems via connect() right?\nso pass it via dispatch when recalculating the agenda items.\n```js\n// Component\n// handled via reducer - AGENDA_ITEM_DELETE (trigger button click?)\ndispatch(Action.deleteAgendaItem({ idToDelete });\n// handled via saga - PLANNING_DATA_UPDATE (call in componentDidUpdate)\ndispatch(Action.updateAgendaItemPlanningData({ agendaItems });\n// Saga\nfunction* main() {\n  yield all([\n    takeEvery([PLANNING_DATA_UPDATE], updateAgendaItemPlanningData),\n    // ... other watchers here\n  ]);\n}\nfunction* updateAgendaItemPlanningData({ payload: { agendaItems } }) {\n  // ... do stuff for each item\n  yield put(updateAgendaItemsState({ agendaItems: newAgendaItems })); // dispatch AGENDA_ITEMS_UPDATED handled via reducer\n}\n```. ",
    "peshoicov": "Thanks, that really helped :). ",
    "purepennons": "@shinima\nI know, but that is a breaking change.. ",
    "JacquesBonet": "I think its another problem for me.\nI use redux_starter_kit which provide a function configureStore() which configure redux dev toolslike vclav say(https://github.com/reduxjs/redux-starter-kit/blob/0e139e9ebbbf4f5f6e55280046be5372524e06b3/src/configureStore.ts) .\nI test tomorrow. I tested with redux-saga 1.0, I have an exception:\n Attempted import error: 'delay' is not exported from 'redux-saga'.\n\nDelay is declared here (was declared in redux-saga on te 0.16)\n import { call, cancel, delay, fork, put, takeEvery } from 'redux-saga/effects';\n\nI cleaned the cache, rebuild all same error. Don't understand.\nJacques . After a good sleep, yarn files cleaning, I can launch te application, but the application functionnalities doesn't works has before.\nIn checking on the console, I see a error message saying \"delay function is not call correctly, must be:\n yield delay( <value>)\".\n\nI had \nyield call(delay, 50)\n\nand in changing to\nyield delay(50)\n\nall works perfecly.\n. ",
    "mattvperry": "@aikoven Looks like #1769 only fixed this issue for takeLatest and other similar helpers. What about simply take? . ",
    "nwpray": "Your totally right @shinima, thank you! I should have been a bit more thorough. Here is a sandbox if anyone is interested in seeing it work in action. After clicking run race you should see the console logs print out in order. Console shows up at the bottom on codesandbox.. ",
    "drewdecarme": "I'm having the same issue, but it's intermittent. Locally, everything seems to be working fine, even when using React async component lifecycle methods, but for some reason, my CI environment (an internally hosted version of VSTS) doesn't like it.. ",
    "dorian-marchal": "I created a minimal repro, here: https://github.com/dorian-marchal/redux-saga-issue-1743/blob/master/index.js\nHere is how redux-saga behavior differs between 0.16.2 and 1.0.0:\n```shell\n$ git clone https://github.com/dorian-marchal/redux-saga-issue-1743\nCloning into 'redux-saga-issue-1743'...\n$ cd redux-saga-issue-1743/\n$ node -v\nv10.14.1\n$ npm i\n$ cat node_modules/redux-saga/package.json | grep '\"version\":'\n  \"version\": \"0.16.2\"\n$ node -r esm index.js \nOK\n$ npm i redux-saga@latest\n$ cat node_modules/redux-saga/package.json | grep '\"version\":'\n  \"version\": \"1.0.0\"\n$ node -r esm index.js \nERROR:\n    Expected state: {\"pingCount\":2,\"pongCount\":2},\n    Current state:  {\"pingCount\":2,\"pongCount\":1}\n```. This is the way the lib next-redux-saga works (used in the Next.js + Redux Saga example).\nIn Next.js, getInitialProps is called before each page change (e.g. when a link is clicked) and is responsible for fetching the page dependencies.\nWhen getInitialProps is called, next-redux-saga stops saga and waits for the root saga task to be done before resolving (store.runSagaTask is defined here).\nThis way, getInitialProps only resolves when every sagas started to fetch dependencies are done. Saga is restarted just before resolving.\nI'm not convinced this is the best way to do this as sagas can't handle actions dispatched between END and runSagaTask.. > only after\nCan't it be rerun after stopping it by dispatching END?. ",
    "szb512": "I suggest that you go here to find out how to upgrade to the latest version of babel:\nhttps://babeljs.io/docs/en/v7-migration. Maybe then you can try again.. Well, it would be a big improvement to redux-saga, but there would be one issue with npm, and the issue is that it might not recognize the sagas, and result in errors, which would make users edit npm so it accepts sagas.. Forget it.... The website I got this information from is npmjs.com, and for some reason the tests keep failing.. Does anyone know why Travis CI fails?. I don't know why the first test for npm-shrinkwrap succeeded.... I mean the file is exactly the same name and same content now, and still the tests fail!. Here's the full log from the tests (try and figure out what went wrong)\nWorker information\nhostname: 6b0e115f-4aa6-4333-882b-a3e6a51703c6@1.production-1-worker-org-gce-w82x\nversion: v6.2.0 https://github.com/travis-ci/worker/tree/5e5476e01646095f48eec13196fdb3faf8f5cbf7\ninstance: travis-job-410f9e8f-4d6b-4d02-8e5a-f3f477e3caa4 travis-ci-garnet-trusty-1512502259-986baf0 (via amqp)\nstartup: 6.814243942s\nsystem_info\nBuild system information\nBuild language: node_js\nBuild group: stable\nBuild dist: trusty\nBuild id: 496714289\nJob id: 496714292\nRuntime kernel version: 4.4.0-101-generic\ntravis-build version: ecb8262c9\nBuild image provisioning date and time\nTue Dec  5 19:58:13 UTC 2017\nOperating System Details\nDistributor ID: Ubuntu\nDescription:    Ubuntu 14.04.5 LTS\nRelease:    14.04\nCodename:   trusty\nCookbooks Version\n7c2c6a6 https://github.com/travis-ci/travis-cookbooks/tree/7c2c6a6\ngit version\ngit version 2.15.1\nbash version\nGNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)\ngcc version\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4\nCopyright (C) 2013 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\ndocker version\nClient:\n Version:      17.09.0-ce\n API version:  1.32\n Go version:   go1.8.3\n Git commit:   afdb6d4\n Built:        Tue Sep 26 22:42:38 2017\n OS/Arch:      linux/amd64\nServer:\n Version:      17.09.0-ce\n API version:  1.32 (minimum version 1.12)\n Go version:   go1.8.3\n Git commit:   afdb6d4\n Built:        Tue Sep 26 22:41:20 2017\n OS/Arch:      linux/amd64\n Experimental: false\nclang version\nclang version 5.0.0 (tags/RELEASE_500/final)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /usr/local/clang-5.0.0/bin\njq version\njq-1.5\nbats version\nBats 0.4.0\nshellcheck version\n0.4.6\nshfmt version\nv2.0.0\nccache version\nccache version 3.1.9\nCopyright (C) 2002-2007 Andrew Tridgell\nCopyright (C) 2009-2011 Joel Rosdahl\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free Software\nFoundation; either version 3 of the License, or (at your option) any later\nversion.\ncmake version\ncmake version 3.9.2\nCMake suite maintained and supported by Kitware (kitware.com/cmake).\nheroku version\nheroku-cli/6.14.39-addc925 (linux-x64) node-v9.2.0\nimagemagick version\nVersion: ImageMagick 6.7.7-10 2017-07-31 Q16 http://www.imagemagick.org\nmd5deep version\n4.2\nmercurial version\nMercurial Distributed SCM (version 4.2.2)\n(see https://mercurial-scm.org for more information)\nCopyright (C) 2005-2017 Matt Mackall and others\nThis is free software; see the source for copying conditions. There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nmysql version\nmysql  Ver 14.14 Distrib 5.6.33, for debian-linux-gnu (x86_64) using  EditLine wrapper\nopenssl version\nOpenSSL 1.0.1f 6 Jan 2014\npacker version\nPacker v1.0.2\nYour version of Packer is out of date! The latest version\nis 1.1.2. You can update by downloading from www.packer.io\npostgresql client version\npsql (PostgreSQL) 9.6.6\nragel version\nRagel State Machine Compiler version 6.8 Feb 2013\nCopyright (c) 2001-2009 by Adrian Thurston\nsubversion version\nsvn, version 1.8.8 (r1568071)\n   compiled Aug 10 2017, 17:20:39 on x86_64-pc-linux-gnu\nCopyright (C) 2013 The Apache Software Foundation.\nThis software consists of contributions made by many people;\nsee the NOTICE file for more information.\nSubversion is open source software, see http://subversion.apache.org/\nThe following repository access (RA) modules are available:\n ra_svn : Module for accessing a repository using the svn network protocol.\n  - with Cyrus SASL authentication\n  - handles 'svn' scheme\n ra_local : Module for accessing a repository on local disk.\n  - handles 'file' scheme\n ra_serf : Module for accessing a repository via WebDAV protocol using serf.\n  - using serf 1.3.3\n  - handles 'http' scheme\n  - handles 'https' scheme\nsudo version\nSudo version 1.8.9p5\nConfigure options: --prefix=/usr -v --with-all-insults --with-pam --with-fqdn --with-logging=syslog --with-logfac=authpriv --with-env-editor --with-editor=/usr/bin/editor --with-timeout=15 --with-password-timeout=0 --with-passprompt=[sudo] password for %p:  --without-lecture --with-tty-tickets --disable-root-mailer --enable-admin-flag --with-sendmail=/usr/sbin/sendmail --with-timedir=/var/lib/sudo --mandir=/usr/share/man --libexecdir=/usr/lib/sudo --with-sssd --with-sssd-lib=/usr/lib/x86_64-linux-gnu --with-selinux\nSudoers policy plugin version 1.8.9p5\nSudoers file grammar version 43\nSudoers path: /etc/sudoers\nAuthentication methods: 'pam'\nSyslog facility if syslog is being used for logging: authpriv\nSyslog priority to use when user authenticates successfully: notice\nSyslog priority to use when user authenticates unsuccessfully: alert\nSend mail if the user is not in sudoers\nUse a separate timestamp for each user/tty combo\nLecture user the first time they run sudo\nRoot may run sudo\nAllow some information gathering to give useful error messages\nRequire fully-qualified hostnames in the sudoers file\nVisudo will honor the EDITOR environment variable\nSet the LOGNAME and USER environment variables\nLength at which to wrap log file lines (0 for no wrap): 80\nAuthentication timestamp timeout: 15.0 minutes\nPassword prompt timeout: 0.0 minutes\nNumber of tries to enter a password: 3\nUmask to use or 0777 to use user's: 022\nPath to mail program: /usr/sbin/sendmail\nFlags for mail program: -t\nAddress to send mail to: root\nSubject line for mail messages:  SECURITY information for %h \nIncorrect password message: Sorry, try again.\nPath to authentication timestamp dir: /var/lib/sudo\nDefault password prompt: [sudo] password for %p: \nDefault user to run commands as: root\nValue to override user's $PATH with: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin\nPath to the editor for use by visudo: /usr/bin/editor\nWhen to require a password for 'list' pseudocommand: any\nWhen to require a password for 'verify' pseudocommand: all\nFile descriptors >= 3 will be closed before executing a command\nEnvironment variables to check for sanity:\n    TZ\n    TERM\n    LINGUAS\n    LC_\n    LANGUAGE\n    LANG\n    COLORTERM\nEnvironment variables to remove:\n    RUBYOPT\n    RUBYLIB\n    PYTHONUSERBASE\n    PYTHONINSPECT\n    PYTHONPATH\n    PYTHONHOME\n    TMPPREFIX\n    ZDOTDIR\n    READNULLCMD\n    NULLCMD\n    FPATH\n    PERL5DB\n    PERL5OPT\n    PERL5LIB\n    PERLLIB\n    PERLIO_DEBUG \n    JAVA_TOOL_OPTIONS\n    SHELLOPTS\n    GLOBIGNORE\n    PS4\n    BASH_ENV\n    ENV\n    TERMCAP\n    TERMPATH\n    TERMINFO_DIRS\n    TERMINFO\n    _RLD\n    LD_\n    PATH_LOCALE\n    NLSPATH\n    HOSTALIASES\n    RES_OPTIONS\n    LOCALDOMAIN\n    CDPATH\n    IFS\nEnvironment variables to preserve:\n    JAVA_HOME\n    TRAVIS\n    CI\n    DEBIAN_FRONTEND\n    XAUTHORIZATION\n    XAUTHORITY\n    PS2\n    PS1\n    PATH\n    LS_COLORS\n    KRB5CCNAME\n    HOSTNAME\n    HOME\n    DISPLAY\n    COLORS\nLocale to use while parsing sudoers: C\nDirectory in which to store input/output logs: /var/log/sudo-io\nFile in which to store the input/output log: %{seq}\nAdd an entry to the utmp/utmpx file when allocating a pty\nPAM service name to use\nPAM service name to use for login shells\nCreate a new PAM session for the command to run in\nMaximum I/O log sequence number: 0\nLocal IP address and netmask pairs:\n    10.240.0.28/255.255.255.255\n    172.17.0.1/255.255.0.0\nSudoers I/O plugin version 1.8.9p5\ngzip version\ngzip 1.6\nCopyright (C) 2007, 2010, 2011 Free Software Foundation, Inc.\nCopyright (C) 1993 Jean-loup Gailly.\nThis is free software.  You may redistribute copies of it under the terms of\nthe GNU General Public License http://www.gnu.org/licenses/gpl.html.\nThere is NO WARRANTY, to the extent permitted by law.\nWritten by Jean-loup Gailly.\nzip version\nCopyright (c) 1990-2008 Info-ZIP - Type 'zip \"-L\"' for software license.\nThis is Zip 3.0 (July 5th 2008), by Info-ZIP.\nCurrently maintained by E. Gordon.  Please send bug reports to\nthe authors using the web page at www.info-zip.org; see README for details.\nLatest sources and executables are at ftp://ftp.info-zip.org/pub/infozip,\nas of above date; see http://www.info-zip.org/ for other sites.\nCompiled with gcc 4.8.2 for Unix (Linux ELF) on Oct 21 2013.\nZip special compilation options:\n    USE_EF_UT_TIME       (store Universal Time)\n    BZIP2_SUPPORT        (bzip2 library version 1.0.6, 6-Sept-2010)\n        bzip2 code and library copyright (c) Julian R Seward\n        (See the bzip2 license for terms of use)\n    SYMLINK_SUPPORT      (symbolic links supported)\n    LARGE_FILE_SUPPORT   (can read and write large files on file system)\n    ZIP64_SUPPORT        (use Zip64 to store large files in archives)\n    UNICODE_SUPPORT      (store and read UTF-8 Unicode paths)\n    STORE_UNIX_UIDs_GIDs (store UID/GID sizes/values using new extra field)\n    UIDGID_NOT_16BIT     (old Unix 16-bit UID/GID extra field not used)\n    [encryption, version 2.91 of 05 Jan 2007] (modified for Zip 3)\nEncryption notice:\n    The encryption code of this program is not copyrighted and is\n    put in the public domain.  It was originally written in Europe\n    and, to the best of our knowledge, can be freely distributed\n    in both source and object forms from any country, including\n    the USA under License Exception TSU of the U.S. Export\n    Administration Regulations (section 740.13(e)) of 6 June 2002.\nZip environment options:\n             ZIP:  [none]\n          ZIPOPT:  [none]\nvim version\nVIM - Vi IMproved 7.4 (2013 Aug 10, compiled Nov 24 2016 16:43:18)\nIncluded patches: 1-52\nExtra patches: 8.0.0056\nModified by pkg-vim-maintainers@lists.alioth.debian.org\nCompiled by buildd@\nHuge version without GUI.  Features included (+) or not (-):\n+acl             +farsi           +mouse_netterm   +syntax\n+arabic          +file_in_path    +mouse_sgr       +tag_binary\n+autocmd         +find_in_path    -mouse_sysmouse  +tag_old_static\n-balloon_eval    +float           +mouse_urxvt     -tag_any_white\n-browse          +folding         +mouse_xterm     -tcl\n++builtin_terms  -footer          +multi_byte      +terminfo\n+byte_offset     +fork()          +multi_lang      +termresponse\n+cindent         +gettext         -mzscheme        +textobjects\n-clientserver    -hangul_input    +netbeans_intg   +title\n-clipboard       +iconv           +path_extra      -toolbar\n+cmdline_compl   +insert_expand   -perl            +user_commands\n+cmdline_hist    +jumplist        +persistent_undo +vertsplit\n+cmdline_info    +keymap          +postscript      +virtualedit\n+comments        +langmap         +printer         +visual\n+conceal         +libcall         +profile         +visualextra\n+cryptv          +linebreak       +python          +viminfo\n+cscope          +lispindent      -python3         +vreplace\n+cursorbind      +listcmds        +quickfix        +wildignore\n+cursorshape     +localmap        +reltime         +wildmenu\n+dialog_con      -lua             +rightleft       +windows\n+diff            +menu            -ruby            +writebackup\n+digraphs        +mksession       +scrollbind      -X11\n-dnd             +modify_fname    +signs           -xfontset\n-ebcdic          +mouse           +smartindent     -xim\n+emacs_tags      -mouseshape      -sniff           -xsmp\n+eval            +mouse_dec       +startuptime     -xterm_clipboard\n+ex_extra        +mouse_gpm       +statusline      -xterm_save\n+extra_search    -mouse_jsbterm   -sun_workshop    -xpm\n   system vimrc file: \"$VIM/vimrc\"\n     user vimrc file: \"$HOME/.vimrc\"\n 2nd user vimrc file: \"~/.vim/vimrc\"\n      user exrc file: \"$HOME/.exrc\"\n  fall-back for $VIM: \"/usr/share/vim\"\nCompilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1    \nLinking: gcc   -Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,--as-needed -o vim        -lm -ltinfo -lnsl  -lselinux  -lacl -lattr -lgpm -ldl    -L/usr/lib/python2.7/config-x86_64-linux-gnu -lpython2.7 -lpthread -ldl -lutil -lm -Xlinker -export-dynamic -Wl,-O1 -Wl,-Bsymbolic-functions    \niptables version\niptables v1.4.21\ncurl version\ncurl 7.35.0 (x86_64-pc-linux-gnu) libcurl/7.35.0 OpenSSL/1.0.1f zlib/1.2.8 libidn/1.28 librtmp/2.3\nwget version\nGNU Wget 1.15 built on linux-gnu.\nrsync version\nrsync  version 3.1.0  protocol version 31\ngimme version\nv1.2.0\nnvm version\n0.33.6\nperlbrew version\n/home/travis/perl5/perlbrew/bin/perlbrew  - App::perlbrew/0.80\nphpenv version\nrbenv 1.1.1-25-g6aa70b6\nrvm version\nrvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]\ndefault ruby version\nruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-linux]\nCouchDB version\ncouchdb 1.6.1\nElasticSearch version\n5.5.0\nInstalled Firefox version\nfirefox 56.0.2\nMongoDB version\nMongoDB 3.4.10\nPhantomJS version\n2.1.1\nPre-installed PostgreSQL versions\n9.2.24\n9.3.20\n9.4.15\n9.5.10\n9.6.6\nRabbitMQ Version\n3.6.14\nRedis version\nredis-server 4.0.6\nriak version\n2.2.3\nPre-installed Go versions\n1.7.4\nant version\nApache Ant(TM) version 1.9.3 compiled on April 8 2014\nmvn version\nApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T07:58:13Z)\nMaven home: /usr/local/maven-3.5.2\nJava version: 1.8.0_151, vendor: Oracle Corporation\nJava home: /usr/lib/jvm/java-8-oracle/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"4.4.0-98-generic\", arch: \"amd64\", family: \"unix\"\ngradle version\n\nGradle 4.0.1\nBuild time:   2017-07-07 14:02:41 UTC\nRevision:     38e5dc0f772daecca1d2681885d3d85414eb6826\nGroovy:       2.4.11\nAnt:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015\nJVM:          1.8.0_151 (Oracle Corporation 25.151-b12)\nOS:           Linux 4.4.0-98-generic amd64\nlein version\nLeiningen 2.8.1 on Java 1.8.0_151 Java HotSpot(TM) 64-Bit Server VM\nPre-installed Node.js versions\nv4.8.6\nv6.12.0\nv6.12.1\nv8.9\nv8.9.1\nphpenv versions\n  system\n  5.6\n* 5.6.32 (set by /home/travis/.phpenv/version)\n  7.0\n  7.0.25\n  7.1\n  7.1.11\n  hhvm\n  hhvm-stable\ncomposer --version\nComposer version 1.5.2 2017-09-11 16:59:25\nPre-installed Ruby versions\nruby-2.2.7\nruby-2.3.4\nruby-2.4.1\ngit.checkout\n0.78s$ git clone --depth=50 https://github.com/redux-saga/redux-saga.git redux-saga/redux-saga\nCloning into 'redux-saga/redux-saga'...\nremote: Enumerating objects: 1121, done.\nremote: Counting objects: 100% (1121/1121), done.\nremote: Compressing objects: 100% (562/562), done.\nremote: Total 1121 (delta 587), reused 837 (delta 496), pack-reused 0\nReceiving objects: 100% (1121/1121), 815.18 KiB | 9.48 MiB/s, done.\nResolving deltas: 100% (587/587), done.\n$ cd redux-saga/redux-saga\n0.46s$ git fetch origin +refs/pull/1784/merge:\nremote: Enumerating objects: 25, done.\nremote: Counting objects: 100% (25/25), done.\nremote: Compressing objects: 100% (14/14), done.\nremote: Total 21 (delta 7), reused 14 (delta 3), pack-reused 0\nUnpacking objects: 100% (21/21), done.\nFrom https://github.com/redux-saga/redux-saga\n * branch            refs/pull/1784/merge -> FETCH_HEAD\n$ git checkout -qf FETCH_HEAD\nEncrypted environment variables have been removed for security reasons.\nSee https://docs.travis-ci.com/user/pull-requests/#pull-requests-and-security-restrictions\nnvm.install\n3.14s$ nvm install 11.0.0\nDownloading and installing node v11.0.0...\nDownloading https://nodejs.org/dist/v11.0.0/node-v11.0.0-linux-x64.tar.xz...\nComputing checksum with sha256sum\nChecksums matched!\nNow using node v11.0.0 (npm v6.4.1)\n$ node --version\nv11.0.0\n$ npm --version\n6.4.1\n$ nvm --version\n0.34.0\ninstall.npm\n70.53s$ npm install \nnpm WARN deprecated circular-json@0.3.3: CircularJSON is in maintenance only, flatted is its successor.\nnpm WARN deprecated kleur@2.0.2: Please upgrade to kleur@3 or migrate to 'ansi-colors' if you prefer the old syntax. Visit <https://github.com/lukeed/kleur/releases/tag/v3.0.0> for migration path(s).\nnpm WARN deprecated node-uuid@1.4.8: Use uuid module instead\nnpm WARN deprecated hoek@2.16.3: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN deprecated cryptiles@2.0.5: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN deprecated boom@2.10.1: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0\n\nhusky@1.3.1 install /home/travis/build/redux-saga/redux-saga/node_modules/husky\nnode husky install\nhusky > setting up git hooks\nCI detected, skipping Git hooks installation.\nlint-staged@3.6.1 postinstall /home/travis/build/redux-saga/redux-saga/node_modules/lint-staged\necho \"\ud83d\udeab\ud83d\udca9 lint-staged installed! \nDo not forget to configure it. See https://github.com/okonet/lint-staged/blob/master/README.md\" && exit 0\n\ud83d\udeab\ud83d\udca9 lint-staged installed! \nDo not forget to configure it. See https://github.com/okonet/lint-staged/blob/master/README.md\nundefined postinstall /home/travis/build/redux-saga/redux-saga\nnpm run bootstrap\n@ bootstrap /home/travis/build/redux-saga/redux-saga\nlerna bootstrap --ignore-scripts\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Bootstrapping 17 packages\nlerna info Installing external dependencies\nlerna info hoist Installing hoisted dependencies into root\nlerna info hoist Pruning hoisted dependencies\nlerna info hoist Finished pruning hoisted dependencies\nlerna info hoist Finished bootstrapping root\nlerna info Symlinking packages and binaries\nlerna success Bootstrapped 17 packages\nnpm WARN typings-tester@0.2.2 requires a peer of typescript@~2 but none is installed. You must install peer dependencies yourself.\nnpm WARN acorn-dynamic-import@4.0.0 requires a peer of acorn@^6.0.0 but none is installed. You must install peer dependencies yourself.\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: idb-connector@1.1.8 (node_modules/idb-connector):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for idb-connector@1.1.8: wanted {\"os\":\"aix\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.7 (node_modules/fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\nadded 2283 packages from 1328 contributors and audited 78067 packages in 70.071s\nfound 140 vulnerabilities (68 low, 58 moderate, 14 high)\n  run npm audit fix to fix them, or npm audit for details\n34.17s$ npm run check\n@ check /home/travis/build/redux-saga/redux-saga\nrun-s lint test\n@ lint /home/travis/build/redux-saga/redux-saga\neslint packages//{src,test}\n@ pretest /home/travis/build/redux-saga/redux-saga\nnpm run build\n@ build /home/travis/build/redux-saga/redux-saga\nlerna run --parallel build\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 7 packages: \"npm run build\"\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > npm run clean\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > npm run clean\nredux-saga: > redux-saga@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > npm run clean\n@redux-saga/core: > @redux-saga/core@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > npm run clean\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > npm run clean\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > npm run clean\n@redux-saga/is: > @redux-saga/is@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > npm run clean\nredux-saga: > redux-saga@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > rimraf dist\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > rimraf dist\n@redux-saga/core: > @redux-saga/core@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > rimraf dist\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > rimraf dist\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > rimraf dist\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > rimraf dist\n@redux-saga/is: > @redux-saga/is@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > rimraf dist\nredux-saga: > redux-saga@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > rollup -c\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > rollup -c\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > rollup -c\n@redux-saga/core: > @redux-saga/core@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > rollup -c\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > rollup -c\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > rollup -c\n@redux-saga/is: > @redux-saga/is@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > rollup -c\n@redux-saga/delay-p: src/index.js \u2192 ./dist/redux-saga-delay-p.esm.js...\n@redux-saga/deferred: src/index.js \u2192 ./dist/redux-saga-deferred.esm.js...\n@redux-saga/symbols: src/index.js \u2192 ./dist/redux-saga-symbols.esm.js...\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\nredux-saga: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/is: src/index.js \u2192 dist/redux-saga-is.esm.js...\n@redux-saga/testing-utils: src/index.js \u2192 ./dist/redux-saga-testing-utils.esm.js...\n@redux-saga/delay-p: created ./dist/redux-saga-delay-p.esm.js in 2.4s\n@redux-saga/delay-p: src/index.js \u2192 ./dist/redux-saga-delay-p.cjs.js...\n@redux-saga/deferred: created ./dist/redux-saga-deferred.esm.js in 2.4s\n@redux-saga/deferred: src/index.js \u2192 ./dist/redux-saga-deferred.cjs.js...\n@redux-saga/delay-p: created ./dist/redux-saga-delay-p.cjs.js in 111ms\n@redux-saga/symbols: created ./dist/redux-saga-symbols.esm.js in 2.5s\n@redux-saga/deferred: created ./dist/redux-saga-deferred.cjs.js in 106ms\n@redux-saga/symbols: src/index.js \u2192 ./dist/redux-saga-symbols.cjs.js...\n@redux-saga/testing-utils: created ./dist/redux-saga-testing-utils.esm.js in 2.5s\n@redux-saga/testing-utils: src/index.js \u2192 ./dist/redux-saga-testing-utils.cjs.js...\n@redux-saga/symbols: created ./dist/redux-saga-symbols.cjs.js in 268ms\nredux-saga: created dist in 2.7s\nredux-saga: src/index.js, src/effects.js \u2192 dist...\nredux-saga: created dist in 121ms\nredux-saga: src/index.umd.js \u2192 ./dist/redux-saga.umd.js...\n@redux-saga/testing-utils: created ./dist/redux-saga-testing-utils.cjs.js in 303ms\n@redux-saga/is: created dist/redux-saga-is.esm.js in 2.8s\n@redux-saga/is: src/index.js \u2192 dist/redux-saga-is.cjs.js...\n@redux-saga/is: created dist/redux-saga-is.cjs.js in 258ms\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 5.1s\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created ./dist/redux-saga.umd.js in 3.6s\nredux-saga: src/index.umd.js \u2192 ./dist/redux-saga.umd.min.js...\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 1.9s\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 1.8s\n@redux-saga/core: > @redux-saga/core@1.0.1 postbuild /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > node ./scripts/createProxyCjsEntries.js\n@redux-saga/core:   Created proxy commonjs entries: redux-saga-core, redux-saga-effects.\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created ./dist/redux-saga.umd.min.js in 3.6s\nredux-saga: src/index.js, src/effects.js \u2192 dist...\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created dist in 2.3s\nlerna success run Ran npm script 'build' in 7 packages in 17.4s:\nlerna success - @redux-saga/core\nlerna success - @redux-saga/deferred\nlerna success - @redux-saga/delay-p\nlerna success - @redux-saga/is\nlerna success - redux-saga\nlerna success - @redux-saga/symbols\nlerna success - @redux-saga/testing-utils\n@ test /home/travis/build/redux-saga/redux-saga\nnpm run test-only\n@ test-only /home/travis/build/redux-saga/redux-saga\nlerna run --parallel test\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 8 packages: \"npm run test\"\nasync-example: > async-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/async\nasync-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\nerror-demo: > error-demo@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/error-demo\nerror-demo: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 test /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > jest\ncancellable-counter-example: > cancellable-counter-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/cancellable-counter\ncancellable-counter-example: > cross-env BABEL_ENV=cjs babel-node ./test/sagas.js | tap-spec\ncounter-example: > counter-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/counter\ncounter-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\nshopping-cart-example: > shopping-cart-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/shopping-cart\nshopping-cart-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\nbabel-plugin-redux-saga: > babel-plugin-redux-saga@1.0.0 test /home/travis/build/redux-saga/redux-saga/packages/babel-plugin-redux-saga\nbabel-plugin-redux-saga: > jest --env=node\n@redux-saga/core: > @redux-saga/core@1.0.1 test /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > jest\ncounter-example:   incrementAsync Saga test\ncounter-example:     \u2714 counter Saga must call delay(1000)\ncounter-example:     \u2714 counter Saga must dispatch an INCREMENT action\ncounter-example:     \u2714 counter Saga must be done\ncounter-example:   total:     3\ncounter-example:   passing:   3\ncounter-example:   duration:  5.4s\nasync-example:   fetchPosts Saga\nasync-example:     \u2714 must dispatch a requestPosts action\nasync-example:     \u2714 must call fetchPostsApi with reddit name\nasync-example:     \u2714 must dispatch a receivePosts action with posts\nasync-example:     \u2714 must finish\nasync-example:   invalidateReddit Saga\nasync-example:     \u2714 must take a SELECT_REDDIT action\nasync-example:     \u2714 must call fetchPosts with new reddit\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when switching to new reddit\nasync-example:     \u2714 must select current reddit from store\nasync-example:     \u2714 must take a SELECT_REDDIT action\nasync-example:     \u2714 must select newly selected reddit from store\nasync-example:     \u2714 must select posts by reddit from store\nasync-example:     \u2714 delegate to fetchPosts for new reddit's posts\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when same reddit is selected\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when posts were previously loaded\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   startup Saga\nasync-example:     \u2714 gets currently selected reddit\nasync-example:     \u2714 delegates to fetchPosts to get posts\nasync-example:     \u2714 must finish\nasync-example:   total:     18\nasync-example:   passing:   18\nasync-example:   duration:  7.1s\ncancellable-counter-example:   watchIncrementAsync Saga\ncancellable-counter-example:     \u2714 watchIncrementAsync takes INCRMEMENT_ASYNC action\ncancellable-counter-example:     \u2714 starts Race between async incremention and cancellation\ncancellable-counter-example:   incrementAsync Saga successful\ncancellable-counter-example:     \u2714 counter Saga instantiates channel emitter\ncancellable-counter-example:     countdown 10\ncancellable-counter-example:     \u2714 take action from eventChannel\ncancellable-counter-example:     \u2714 updates countdown value in the store\ncancellable-counter-example:     \u2714 eventEmitter is done\ncancellable-counter-example:     \u2714 Actual increment is performed\ncancellable-counter-example:     \u2714 The countdown is terminated\ncancellable-counter-example:   incrementAsync Saga with cancellation\ncancellable-counter-example:     \u2714 instanciation of the channel emitter with the provided value to wait\ncancellable-counter-example:     countdown 10\ncancellable-counter-example:     \u2714 takes action from eventChannel\ncancellable-counter-example:     \u2714 put counter value to store\ncancellable-counter-example:     \u2714 eventEmitter is done\ncancellable-counter-example:     countdown cancelled\ncancellable-counter-example:     \u2714 Saga is done\nshopping-cart-example:   getProducts Saga test\nshopping-cart-example:     \u2714 must yield api.getProducts\nshopping-cart-example:     \u2714 must yield actions.receiveProducts(products)\nshopping-cart-example:   checkout Saga test\nshopping-cart-example:     \u2714 must select getCart\nshopping-cart-example:     \u2714 must call api.buyProducts(cart)\nshopping-cart-example:     \u2714 must yield actions.checkoutSuccess(cart)\nshopping-cart-example:   total:     5\nshopping-cart-example:   passing:   5\nshopping-cart-example:   duration:  7.2s\nerror-demo:   when run saga via sagaMiddleware errors are shown in logs\nerror-demo:   when run generator manually errors aren't shown in logs\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in async call: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in inlined saga:shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in fork:shows correct error logs with source of error\ncancellable-counter-example:     countdown 9\n@redux-saga/testing-utils: PASS tests/cloneableGenerator.js (6.017s)\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in race: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in delegated saga: doesn't show delegated in error stack\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in helper: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in select: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in put: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in functional expression saga: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   should return error stack if primitive is thrown\nerror-demo:     \u2714 should be equivalent\nerror-demo:   total:     11\nerror-demo:   passing:   11\nerror-demo:   duration:  9.1s\ncancellable-counter-example:     countdown 8\ncancellable-counter-example:     countdown 7\n@redux-saga/testing-utils: PASS tests/createMockTask.js\nbabel-plugin-redux-saga: FAIL test/runner.test.js (8.887s)\nbabel-plugin-redux-saga:   babel6\nbabel-plugin-redux-saga:     \u2713 attach source to declaration (653ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration (14ms)\nbabel-plugin-redux-saga:     \u2715 attach source to export declaration when processed with regenerator (724ms)\nbabel-plugin-redux-saga:     \u2713 should wrap yielded call expression (no name check) (21ms)\nbabel-plugin-redux-saga:     \u2713 should wrap method call (6ms)\nbabel-plugin-redux-saga:     \u2713 shouldn't wrap delegate (22ms)\nbabel-plugin-redux-saga:     \u2713 should handle nested structures (33ms)\nbabel-plugin-redux-saga:     \u2713 should handle function expression (8ms)\nbabel-plugin-redux-saga:     \u2713 should handle simplest expression (9ms)\nbabel-plugin-redux-saga:     \u2713 should handle expressions in object properties (7ms)\nbabel-plugin-redux-saga:     \u2715 should be compatible with es2015 preset regenerator (116ms)\nbabel-plugin-redux-saga:     \u2715 should be compatible with env preset regenerator (36ms)\nbabel-plugin-redux-saga:     \u2713 should handle passed sourcemaps (101ms)\nbabel-plugin-redux-saga:     \u2713 should build absolute path if useAbsolutePath option = true (29ms)\nbabel-plugin-redux-saga:   babel7\nbabel-plugin-redux-saga:     \u2713 attach source to declaration (67ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration (16ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration when processed with regenerator (612ms)\nbabel-plugin-redux-saga:     \u2713 should wrap yielded call expression (no name check) (12ms)\nbabel-plugin-redux-saga:     \u2713 should wrap method call (24ms)\nbabel-plugin-redux-saga:     \u2713 shouldn't wrap delegate (9ms)\nbabel-plugin-redux-saga:     \u2713 should handle nested structures (54ms)\nbabel-plugin-redux-saga:     \u2713 should handle function expression (6ms)\nbabel-plugin-redux-saga:     \u2713 should handle simplest expression (26ms)\nbabel-plugin-redux-saga:     \u2713 should handle expressions in object properties (7ms)\nbabel-plugin-redux-saga:     \u2713 should be compatible with es2015 preset regenerator (52ms)\nbabel-plugin-redux-saga:     \u2713 should be compatible with env preset regenerator (77ms)\nbabel-plugin-redux-saga:     \u2713 should handle passed sourcemaps (28ms)\nbabel-plugin-redux-saga:     \u2713 should build absolute path if useAbsolutePath option = true (18ms)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a attach source to export declaration when processed with regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/declaration-regenerator/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/declaration-regenerator/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a should be compatible with es2015 preset regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/regenerator/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/regenerator/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a should be compatible with env preset regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/preset-env/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/preset-env/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\ncancellable-counter-example:     countdown 6\nbabel-plugin-redux-saga: Test Suites: 1 failed, 1 total\nbabel-plugin-redux-saga: Tests:       3 failed, 25 passed, 28 total\nbabel-plugin-redux-saga: Snapshots:   0 total\nbabel-plugin-redux-saga: Time:        9.097s\nbabel-plugin-redux-saga: Ran all test suites.\nbabel-plugin-redux-saga: npm ERR! code ELIFECYCLE\nbabel-plugin-redux-saga: npm ERR! errno 1\nbabel-plugin-redux-saga: npm ERR! babel-plugin-redux-saga@1.0.0 test: jest --env=node\nbabel-plugin-redux-saga: npm ERR! Exit status 1\nbabel-plugin-redux-saga: npm ERR! \nbabel-plugin-redux-saga: npm ERR! Failed at the babel-plugin-redux-saga@1.0.0 test script.\nbabel-plugin-redux-saga: npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nbabel-plugin-redux-saga: npm ERR! A complete log of this run can be found in:\nbabel-plugin-redux-saga: npm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_45_034Z-debug.log\nlerna ERR! npm run test exited 1 in 'babel-plugin-redux-saga'\nlerna ERR! npm run test stdout:\nbabel-plugin-redux-saga@1.0.0 test /home/travis/build/redux-saga/redux-saga/packages/babel-plugin-redux-saga\njest --env=node\nlerna ERR! npm run test stderr:\nFAIL test/runner.test.js (8.887s)\n  babel6\n    \u2713 attach source to declaration (653ms)\n    \u2713 attach source to export declaration (14ms)\n    \u2715 attach source to export declaration when processed with regenerator (724ms)\n    \u2713 should wrap yielded call expression (no name check) (21ms)\n    \u2713 should wrap method call (6ms)\n    \u2713 shouldn't wrap delegate (22ms)\n    \u2713 should handle nested structures (33ms)\n    \u2713 should handle function expression (8ms)\n    \u2713 should handle simplest expression (9ms)\n    \u2713 should handle expressions in object properties (7ms)\n    \u2715 should be compatible with es2015 preset regenerator (116ms)\n    \u2715 should be compatible with env preset regenerator (36ms)\n    \u2713 should handle passed sourcemaps (101ms)\n    \u2713 should build absolute path if useAbsolutePath option = true (29ms)\n  babel7\n    \u2713 attach source to declaration (67ms)\n    \u2713 attach source to export declaration (16ms)\n    \u2713 attach source to export declaration when processed with regenerator (612ms)\n    \u2713 should wrap yielded call expression (no name check) (12ms)\n    \u2713 should wrap method call (24ms)\n    \u2713 shouldn't wrap delegate (9ms)\n    \u2713 should handle nested structures (54ms)\n    \u2713 should handle function expression (6ms)\n    \u2713 should handle simplest expression (26ms)\n    \u2713 should handle expressions in object properties (7ms)\n    \u2713 should be compatible with es2015 preset regenerator (52ms)\n    \u2713 should be compatible with env preset regenerator (77ms)\n    \u2713 should handle passed sourcemaps (28ms)\n    \u2713 should build absolute path if useAbsolutePath option = true (18ms)\n  \u25cf babel6 \u203a attach source to export declaration when processed with regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE*/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/declaration-regenerator/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/declaration-regenerator/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\n\u25cf babel6 \u203a should be compatible with es2015 preset regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/regenerator/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/regenerator/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\n\u25cf babel6 \u203a should be compatible with env preset regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/preset-env/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/preset-env/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/preset-env/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/preset-env/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\nTest Suites: 1 failed, 1 total\nTests:       3 failed, 25 passed, 28 total\nSnapshots:   0 total\nTime:        9.097s\nRan all test suites.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! babel-plugin-redux-saga@1.0.0 test: jest --env=node\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the babel-plugin-redux-saga@1.0.0 test script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_45_034Z-debug.log\nlerna ERR! npm run test exited 1 in 'babel-plugin-redux-saga'\nlerna WARN complete Waiting for 3 child processes to exit. CTRL-C to exit immediately.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ test-only: lerna run --parallel test\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ test-only script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_45_093Z-debug.log\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ test: npm run test-only\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ test script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_45_119Z-debug.log\nERROR: \"test\" exited with 1.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ check: run-s lint test\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ check script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_45_157Z-debug.log\nThe command \"npm run check\" exited with 1.\nafter_script\n3.25s$ npm run bundlesize\n\n@ bundlesize /home/travis/build/redux-saga/redux-saga\nlerna run --parallel bundlesize\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 2 packages: \"npm run bundlesize\"\n@redux-saga/core: > @redux-saga/core@1.0.1 prebundlesize /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > npm run build\nredux-saga: > redux-saga@1.0.1 bundlesize /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > bundlesize\nredux-saga:  ERROR  There is no matching file for ./dist/redux-saga.min.umd.js \nredux-saga: npm ERR! code ELIFECYCLE\nredux-saga: npm ERR! errno 1\nredux-saga: npm ERR! redux-saga@1.0.1 bundlesize: bundlesize\nredux-saga: npm ERR! Exit status 1\nredux-saga: npm ERR! \nredux-saga: npm ERR! Failed at the redux-saga@1.0.1 bundlesize script.\nredux-saga: npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nredux-saga: npm ERR! A complete log of this run can be found in:\nredux-saga: npm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_48_388Z-debug.log\nlerna ERR! npm run bundlesize exited 1 in 'redux-saga'\nlerna ERR! npm run bundlesize stdout:\nredux-saga@1.0.1 bundlesize /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nbundlesize\n ERROR  There is no matching file for ./dist/redux-saga.min.umd.js \nlerna ERR! npm run bundlesize stderr:\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! redux-saga@1.0.1 bundlesize: bundlesize\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the redux-saga@1.0.1 bundlesize script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_48_388Z-debug.log\nlerna ERR! npm run bundlesize exited 1 in 'redux-saga'\nlerna WARN complete Waiting for 1 child process to exit. CTRL-C to exit immediately.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ bundlesize: lerna run --parallel bundlesize\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ bundlesize script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_48_442Z-debug.log\nDone. Your build exited with 1.. It has something to do with npm.. It exits with error exit status 1.. The first long comment was from the test for node 11.. This log deals with node 10. (Try to figure out what the error is.)\n\nworker_info\nWorker information\nhostname: e32697db-b32d-4be6-b004-1697d7d9c54f@1.production-2-worker-org-gce-r1f5\nversion: v6.2.0 https://github.com/travis-ci/worker/tree/5e5476e01646095f48eec13196fdb3faf8f5cbf7\ninstance: travis-job-e7dee22b-1906-4811-a192-b3c7be186ef3 travis-ci-garnet-trusty-1512502259-986baf0 (via amqp)\nstartup: 6.449609619s\nsystem_info\nBuild system information\nBuild language: node_js\nBuild group: stable\nBuild dist: trusty\nBuild id: 496714289\nJob id: 496714291\nRuntime kernel version: 4.4.0-101-generic\ntravis-build version: ecb8262c9\nBuild image provisioning date and time\nTue Dec  5 19:58:13 UTC 2017\nOperating System Details\nDistributor ID: Ubuntu\nDescription:    Ubuntu 14.04.5 LTS\nRelease:    14.04\nCodename:   trusty\nCookbooks Version\n7c2c6a6 https://github.com/travis-ci/travis-cookbooks/tree/7c2c6a6\ngit version\ngit version 2.15.1\nbash version\nGNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)\ngcc version\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4\nCopyright (C) 2013 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\ndocker version\nClient:\n Version:      17.09.0-ce\n API version:  1.32\n Go version:   go1.8.3\n Git commit:   afdb6d4\n Built:        Tue Sep 26 22:42:38 2017\n OS/Arch:      linux/amd64\nServer:\n Version:      17.09.0-ce\n API version:  1.32 (minimum version 1.12)\n Go version:   go1.8.3\n Git commit:   afdb6d4\n Built:        Tue Sep 26 22:41:20 2017\n OS/Arch:      linux/amd64\n Experimental: false\nclang version\nclang version 5.0.0 (tags/RELEASE_500/final)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /usr/local/clang-5.0.0/bin\njq version\njq-1.5\nbats version\nBats 0.4.0\nshellcheck version\n0.4.6\nshfmt version\nv2.0.0\nccache version\nccache version 3.1.9\nCopyright (C) 2002-2007 Andrew Tridgell\nCopyright (C) 2009-2011 Joel Rosdahl\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free Software\nFoundation; either version 3 of the License, or (at your option) any later\nversion.\ncmake version\ncmake version 3.9.2\nCMake suite maintained and supported by Kitware (kitware.com/cmake).\nheroku version\nheroku-cli/6.14.39-addc925 (linux-x64) node-v9.2.0\nimagemagick version\nVersion: ImageMagick 6.7.7-10 2017-07-31 Q16 http://www.imagemagick.org\nmd5deep version\n4.2\nmercurial version\nMercurial Distributed SCM (version 4.2.2)\n(see https://mercurial-scm.org for more information)\nCopyright (C) 2005-2017 Matt Mackall and others\nThis is free software; see the source for copying conditions. There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nmysql version\nmysql  Ver 14.14 Distrib 5.6.33, for debian-linux-gnu (x86_64) using  EditLine wrapper\nopenssl version\nOpenSSL 1.0.1f 6 Jan 2014\npacker version\nPacker v1.0.2\nYour version of Packer is out of date! The latest version\nis 1.1.2. You can update by downloading from www.packer.io\npostgresql client version\npsql (PostgreSQL) 9.6.6\nragel version\nRagel State Machine Compiler version 6.8 Feb 2013\nCopyright (c) 2001-2009 by Adrian Thurston\nsubversion version\nsvn, version 1.8.8 (r1568071)\n   compiled Aug 10 2017, 17:20:39 on x86_64-pc-linux-gnu\nCopyright (C) 2013 The Apache Software Foundation.\nThis software consists of contributions made by many people;\nsee the NOTICE file for more information.\nSubversion is open source software, see http://subversion.apache.org/\nThe following repository access (RA) modules are available:\n ra_svn : Module for accessing a repository using the svn network protocol.\n  - with Cyrus SASL authentication\n  - handles 'svn' scheme\n ra_local : Module for accessing a repository on local disk.\n  - handles 'file' scheme\n ra_serf : Module for accessing a repository via WebDAV protocol using serf.\n  - using serf 1.3.3\n  - handles 'http' scheme\n  - handles 'https' scheme\nsudo version\nSudo version 1.8.9p5\nConfigure options: --prefix=/usr -v --with-all-insults --with-pam --with-fqdn --with-logging=syslog --with-logfac=authpriv --with-env-editor --with-editor=/usr/bin/editor --with-timeout=15 --with-password-timeout=0 --with-passprompt=[sudo] password for %p:  --without-lecture --with-tty-tickets --disable-root-mailer --enable-admin-flag --with-sendmail=/usr/sbin/sendmail --with-timedir=/var/lib/sudo --mandir=/usr/share/man --libexecdir=/usr/lib/sudo --with-sssd --with-sssd-lib=/usr/lib/x86_64-linux-gnu --with-selinux\nSudoers policy plugin version 1.8.9p5\nSudoers file grammar version 43\nSudoers path: /etc/sudoers\nAuthentication methods: 'pam'\nSyslog facility if syslog is being used for logging: authpriv\nSyslog priority to use when user authenticates successfully: notice\nSyslog priority to use when user authenticates unsuccessfully: alert\nSend mail if the user is not in sudoers\nUse a separate timestamp for each user/tty combo\nLecture user the first time they run sudo\nRoot may run sudo\nAllow some information gathering to give useful error messages\nRequire fully-qualified hostnames in the sudoers file\nVisudo will honor the EDITOR environment variable\nSet the LOGNAME and USER environment variables\nLength at which to wrap log file lines (0 for no wrap): 80\nAuthentication timestamp timeout: 15.0 minutes\nPassword prompt timeout: 0.0 minutes\nNumber of tries to enter a password: 3\nUmask to use or 0777 to use user's: 022\nPath to mail program: /usr/sbin/sendmail\nFlags for mail program: -t\nAddress to send mail to: root\nSubject line for mail messages:  SECURITY information for %h \nIncorrect password message: Sorry, try again.\nPath to authentication timestamp dir: /var/lib/sudo\nDefault password prompt: [sudo] password for %p: \nDefault user to run commands as: root\nValue to override user's $PATH with: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin\nPath to the editor for use by visudo: /usr/bin/editor\nWhen to require a password for 'list' pseudocommand: any\nWhen to require a password for 'verify' pseudocommand: all\nFile descriptors >= 3 will be closed before executing a command\nEnvironment variables to check for sanity:\n    TZ\n    TERM\n    LINGUAS\n    LC_\n    LANGUAGE\n    LANG\n    COLORTERM\nEnvironment variables to remove:\n    RUBYOPT\n    RUBYLIB\n    PYTHONUSERBASE\n    PYTHONINSPECT\n    PYTHONPATH\n    PYTHONHOME\n    TMPPREFIX\n    ZDOTDIR\n    READNULLCMD\n    NULLCMD\n    FPATH\n    PERL5DB\n    PERL5OPT\n    PERL5LIB\n    PERLLIB\n    PERLIO_DEBUG \n    JAVA_TOOL_OPTIONS\n    SHELLOPTS\n    GLOBIGNORE\n    PS4\n    BASH_ENV\n    ENV\n    TERMCAP\n    TERMPATH\n    TERMINFO_DIRS\n    TERMINFO\n    _RLD\n    LD_\n    PATH_LOCALE\n    NLSPATH\n    HOSTALIASES\n    RES_OPTIONS\n    LOCALDOMAIN\n    CDPATH\n    IFS\nEnvironment variables to preserve:\n    JAVA_HOME\n    TRAVIS\n    CI\n    DEBIAN_FRONTEND\n    XAUTHORIZATION\n    XAUTHORITY\n    PS2\n    PS1\n    PATH\n    LS_COLORS\n    KRB5CCNAME\n    HOSTNAME\n    HOME\n    DISPLAY\n    COLORS\nLocale to use while parsing sudoers: C\nDirectory in which to store input/output logs: /var/log/sudo-io\nFile in which to store the input/output log: %{seq}\nAdd an entry to the utmp/utmpx file when allocating a pty\nPAM service name to use\nPAM service name to use for login shells\nCreate a new PAM session for the command to run in\nMaximum I/O log sequence number: 0\nLocal IP address and netmask pairs:\n    10.240.0.28/255.255.255.255\n    172.17.0.1/255.255.0.0\nSudoers I/O plugin version 1.8.9p5\ngzip version\ngzip 1.6\nCopyright (C) 2007, 2010, 2011 Free Software Foundation, Inc.\nCopyright (C) 1993 Jean-loup Gailly.\nThis is free software.  You may redistribute copies of it under the terms of\nthe GNU General Public License http://www.gnu.org/licenses/gpl.html.\nThere is NO WARRANTY, to the extent permitted by law.\nWritten by Jean-loup Gailly.\nzip version\nCopyright (c) 1990-2008 Info-ZIP - Type 'zip \"-L\"' for software license.\nThis is Zip 3.0 (July 5th 2008), by Info-ZIP.\nCurrently maintained by E. Gordon.  Please send bug reports to\nthe authors using the web page at www.info-zip.org; see README for details.\nLatest sources and executables are at ftp://ftp.info-zip.org/pub/infozip,\nas of above date; see http://www.info-zip.org/ for other sites.\nCompiled with gcc 4.8.2 for Unix (Linux ELF) on Oct 21 2013.\nZip special compilation options:\n    USE_EF_UT_TIME       (store Universal Time)\n    BZIP2_SUPPORT        (bzip2 library version 1.0.6, 6-Sept-2010)\n        bzip2 code and library copyright (c) Julian R Seward\n        (See the bzip2 license for terms of use)\n    SYMLINK_SUPPORT      (symbolic links supported)\n    LARGE_FILE_SUPPORT   (can read and write large files on file system)\n    ZIP64_SUPPORT        (use Zip64 to store large files in archives)\n    UNICODE_SUPPORT      (store and read UTF-8 Unicode paths)\n    STORE_UNIX_UIDs_GIDs (store UID/GID sizes/values using new extra field)\n    UIDGID_NOT_16BIT     (old Unix 16-bit UID/GID extra field not used)\n    [encryption, version 2.91 of 05 Jan 2007] (modified for Zip 3)\nEncryption notice:\n    The encryption code of this program is not copyrighted and is\n    put in the public domain.  It was originally written in Europe\n    and, to the best of our knowledge, can be freely distributed\n    in both source and object forms from any country, including\n    the USA under License Exception TSU of the U.S. Export\n    Administration Regulations (section 740.13(e)) of 6 June 2002.\nZip environment options:\n             ZIP:  [none]\n          ZIPOPT:  [none]\nvim version\nVIM - Vi IMproved 7.4 (2013 Aug 10, compiled Nov 24 2016 16:43:18)\nIncluded patches: 1-52\nExtra patches: 8.0.0056\nModified by pkg-vim-maintainers@lists.alioth.debian.org\nCompiled by buildd@\nHuge version without GUI.  Features included (+) or not (-):\n+acl             +farsi           +mouse_netterm   +syntax\n+arabic          +file_in_path    +mouse_sgr       +tag_binary\n+autocmd         +find_in_path    -mouse_sysmouse  +tag_old_static\n-balloon_eval    +float           +mouse_urxvt     -tag_any_white\n-browse          +folding         +mouse_xterm     -tcl\n++builtin_terms  -footer          +multi_byte      +terminfo\n+byte_offset     +fork()          +multi_lang      +termresponse\n+cindent         +gettext         -mzscheme        +textobjects\n-clientserver    -hangul_input    +netbeans_intg   +title\n-clipboard       +iconv           +path_extra      -toolbar\n+cmdline_compl   +insert_expand   -perl            +user_commands\n+cmdline_hist    +jumplist        +persistent_undo +vertsplit\n+cmdline_info    +keymap          +postscript      +virtualedit\n+comments        +langmap         +printer         +visual\n+conceal         +libcall         +profile         +visualextra\n+cryptv          +linebreak       +python          +viminfo\n+cscope          +lispindent      -python3         +vreplace\n+cursorbind      +listcmds        +quickfix        +wildignore\n+cursorshape     +localmap        +reltime         +wildmenu\n+dialog_con      -lua             +rightleft       +windows\n+diff            +menu            -ruby            +writebackup\n+digraphs        +mksession       +scrollbind      -X11\n-dnd             +modify_fname    +signs           -xfontset\n-ebcdic          +mouse           +smartindent     -xim\n+emacs_tags      -mouseshape      -sniff           -xsmp\n+eval            +mouse_dec       +startuptime     -xterm_clipboard\n+ex_extra        +mouse_gpm       +statusline      -xterm_save\n+extra_search    -mouse_jsbterm   -sun_workshop    -xpm\n   system vimrc file: \"$VIM/vimrc\"\n     user vimrc file: \"$HOME/.vimrc\"\n 2nd user vimrc file: \"~/.vim/vimrc\"\n      user exrc file: \"$HOME/.exrc\"\n  fall-back for $VIM: \"/usr/share/vim\"\nCompilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1    \nLinking: gcc   -Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,--as-needed -o vim        -lm -ltinfo -lnsl  -lselinux  -lacl -lattr -lgpm -ldl    -L/usr/lib/python2.7/config-x86_64-linux-gnu -lpython2.7 -lpthread -ldl -lutil -lm -Xlinker -export-dynamic -Wl,-O1 -Wl,-Bsymbolic-functions    \niptables version\niptables v1.4.21\ncurl version\ncurl 7.35.0 (x86_64-pc-linux-gnu) libcurl/7.35.0 OpenSSL/1.0.1f zlib/1.2.8 libidn/1.28 librtmp/2.3\nwget version\nGNU Wget 1.15 built on linux-gnu.\nrsync version\nrsync  version 3.1.0  protocol version 31\ngimme version\nv1.2.0\nnvm version\n0.33.6\nperlbrew version\n/home/travis/perl5/perlbrew/bin/perlbrew  - App::perlbrew/0.80\nphpenv version\nrbenv 1.1.1-25-g6aa70b6\nrvm version\nrvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]\ndefault ruby version\nruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-linux]\nCouchDB version\ncouchdb 1.6.1\nElasticSearch version\n5.5.0\nInstalled Firefox version\nfirefox 56.0.2\nMongoDB version\nMongoDB 3.4.10\nPhantomJS version\n2.1.1\nPre-installed PostgreSQL versions\n9.2.24\n9.3.20\n9.4.15\n9.5.10\n9.6.6\nRabbitMQ Version\n3.6.14\nRedis version\nredis-server 4.0.6\nriak version\n2.2.3\nPre-installed Go versions\n1.7.4\nant version\nApache Ant(TM) version 1.9.3 compiled on April 8 2014\nmvn version\nApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T07:58:13Z)\nMaven home: /usr/local/maven-3.5.2\nJava version: 1.8.0_151, vendor: Oracle Corporation\nJava home: /usr/lib/jvm/java-8-oracle/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"4.4.0-98-generic\", arch: \"amd64\", family: \"unix\"\ngradle version\n\nGradle 4.0.1\nBuild time:   2017-07-07 14:02:41 UTC\nRevision:     38e5dc0f772daecca1d2681885d3d85414eb6826\nGroovy:       2.4.11\nAnt:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015\nJVM:          1.8.0_151 (Oracle Corporation 25.151-b12)\nOS:           Linux 4.4.0-98-generic amd64\nlein version\nLeiningen 2.8.1 on Java 1.8.0_151 Java HotSpot(TM) 64-Bit Server VM\nPre-installed Node.js versions\nv4.8.6\nv6.12.0\nv6.12.1\nv8.9\nv8.9.1\nphpenv versions\n  system\n  5.6\n* 5.6.32 (set by /home/travis/.phpenv/version)\n  7.0\n  7.0.25\n  7.1\n  7.1.11\n  hhvm\n  hhvm-stable\ncomposer --version\nComposer version 1.5.2 2017-09-11 16:59:25\nPre-installed Ruby versions\nruby-2.2.7\nruby-2.3.4\nruby-2.4.1\ngit.checkout\n0.73s$ git clone --depth=50 https://github.com/redux-saga/redux-saga.git redux-saga/redux-saga\nCloning into 'redux-saga/redux-saga'...\nremote: Enumerating objects: 1121, done.\nremote: Counting objects: 100% (1121/1121), done.\nremote: Compressing objects: 100% (562/562), done.\nremote: Total 1121 (delta 587), reused 837 (delta 496), pack-reused 0\nReceiving objects: 100% (1121/1121), 815.18 KiB | 10.19 MiB/s, done.\nResolving deltas: 100% (587/587), done.\n$ cd redux-saga/redux-saga\n0.46s$ git fetch origin +refs/pull/1784/merge:\nremote: Enumerating objects: 25, done.\nremote: Counting objects: 100% (25/25), done.\nremote: Compressing objects: 100% (14/14), done.\nremote: Total 21 (delta 7), reused 14 (delta 3), pack-reused 0\nUnpacking objects: 100% (21/21), done.\nFrom https://github.com/redux-saga/redux-saga\n * branch            refs/pull/1784/merge -> FETCH_HEAD\n$ git checkout -qf FETCH_HEAD\nEncrypted environment variables have been removed for security reasons.\nSee https://docs.travis-ci.com/user/pull-requests/#pull-requests-and-security-restrictions\nnvm.install\n3.38s$ nvm install 10.2.1\nDownloading and installing node v10.2.1...\nDownloading https://nodejs.org/dist/v10.2.1/node-v10.2.1-linux-x64.tar.xz...\nComputing checksum with sha256sum\nChecksums matched!\nNow using node v10.2.1 (npm v5.6.0)\n$ node --version\nv10.2.1\n$ npm --version\n5.6.0\n$ nvm --version\n0.34.0\ninstall.npm\n61.26s$ npm install \nnpm WARN notice [SECURITY] lodash has the following vulnerability: 1 low. Go here for more details: https://nodesecurity.io/advisories?search=lodash&version=4.17.4 - Run npm i npm@latest -g to upgrade your npm version, and then npm audit to get more info.\nnpm WARN deprecated circular-json@0.3.3: CircularJSON is in maintenance only, flatted is its successor.\nnpm WARN deprecated kleur@2.0.2: Please upgrade to kleur@3 or migrate to 'ansi-colors' if you prefer the old syntax. Visit <https://github.com/lukeed/kleur/releases/tag/v3.0.0> for migration path(s).\nnpm WARN deprecated node-uuid@1.4.8: Use uuid module instead\nnpm WARN deprecated cryptiles@2.0.5: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN notice [SECURITY] hoek has the following vulnerability: 1 moderate. Go here for more details: https://nodesecurity.io/advisories?search=hoek&version=2.16.3 - Run npm i npm@latest -g to upgrade your npm version, and then npm audit to get more info.\nnpm WARN deprecated hoek@2.16.3: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN deprecated boom@2.10.1: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0\n\nhusky@1.3.1 install /home/travis/build/redux-saga/redux-saga/node_modules/husky\nnode husky install\nhusky > setting up git hooks\nCI detected, skipping Git hooks installation.\nlint-staged@3.6.1 postinstall /home/travis/build/redux-saga/redux-saga/node_modules/lint-staged\necho \"\ud83d\udeab\ud83d\udca9 lint-staged installed! \nDo not forget to configure it. See https://github.com/okonet/lint-staged/blob/master/README.md\" && exit 0\n\ud83d\udeab\ud83d\udca9 lint-staged installed! \nDo not forget to configure it. See https://github.com/okonet/lint-staged/blob/master/README.md\nundefined postinstall /home/travis/build/redux-saga/redux-saga\nnpm run bootstrap\n@ bootstrap /home/travis/build/redux-saga/redux-saga\nlerna bootstrap --ignore-scripts\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Bootstrapping 17 packages\nlerna info Installing external dependencies\nlerna info hoist Installing hoisted dependencies into root\nlerna info hoist Pruning hoisted dependencies\nlerna info hoist Finished pruning hoisted dependencies\nlerna info hoist Finished bootstrapping root\nlerna info Symlinking packages and binaries\nlerna success Bootstrapped 17 packages\nnpm WARN typings-tester@0.2.2 requires a peer of typescript@~2 but none is installed. You must install peer dependencies yourself.\nnpm WARN acorn-dynamic-import@4.0.0 requires a peer of acorn@^6.0.0 but none is installed. You must install peer dependencies yourself.\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: idb-connector@1.1.8 (node_modules/idb-connector):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for idb-connector@1.1.8: wanted {\"os\":\"aix\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.7 (node_modules/fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\nadded 2283 packages in 60.867s\n32.70s$ npm run check\n@ check /home/travis/build/redux-saga/redux-saga\nrun-s lint test\n@ lint /home/travis/build/redux-saga/redux-saga\neslint packages//{src,test}\n@ pretest /home/travis/build/redux-saga/redux-saga\nnpm run build\n@ build /home/travis/build/redux-saga/redux-saga\nlerna run --parallel build\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 7 packages: \"npm run build\"\n@redux-saga/core: > @redux-saga/core@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > npm run clean\nredux-saga: > redux-saga@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > npm run clean\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > npm run clean\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > npm run clean\n@redux-saga/is: > @redux-saga/is@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > npm run clean\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > npm run clean\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > npm run clean\nredux-saga: > redux-saga@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > rimraf dist\n@redux-saga/core: > @redux-saga/core@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > rimraf dist\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > rimraf dist\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > rimraf dist\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > rimraf dist\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > rimraf dist\n@redux-saga/is: > @redux-saga/is@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > rimraf dist\nredux-saga: > redux-saga@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > rollup -c\n@redux-saga/core: > @redux-saga/core@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > rollup -c\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > rollup -c\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > rollup -c\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > rollup -c\n@redux-saga/is: > @redux-saga/is@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > rollup -c\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > rollup -c\n@redux-saga/deferred: src/index.js \u2192 ./dist/redux-saga-deferred.esm.js...\n@redux-saga/symbols: src/index.js \u2192 ./dist/redux-saga-symbols.esm.js...\n@redux-saga/delay-p: src/index.js \u2192 ./dist/redux-saga-delay-p.esm.js...\n@redux-saga/is: src/index.js \u2192 dist/redux-saga-is.esm.js...\nredux-saga: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/testing-utils: src/index.js \u2192 ./dist/redux-saga-testing-utils.esm.js...\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/symbols: created ./dist/redux-saga-symbols.esm.js in 2.3s\n@redux-saga/symbols: src/index.js \u2192 ./dist/redux-saga-symbols.cjs.js...\n@redux-saga/deferred: created ./dist/redux-saga-deferred.esm.js in 2.4s\n@redux-saga/deferred: src/index.js \u2192 ./dist/redux-saga-deferred.cjs.js...\n@redux-saga/delay-p: created ./dist/redux-saga-delay-p.esm.js in 2.3s\n@redux-saga/delay-p: src/index.js \u2192 ./dist/redux-saga-delay-p.cjs.js...\nredux-saga: created dist in 2.3s\nredux-saga: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/symbols: created ./dist/redux-saga-symbols.cjs.js in 272ms\n@redux-saga/delay-p: created ./dist/redux-saga-delay-p.cjs.js in 164ms\n@redux-saga/deferred: created ./dist/redux-saga-deferred.cjs.js in 211ms\n@redux-saga/is: created dist/redux-saga-is.esm.js in 2.5s\n@redux-saga/is: src/index.js \u2192 dist/redux-saga-is.cjs.js...\nredux-saga: created dist in 146ms\nredux-saga: src/index.umd.js \u2192 ./dist/redux-saga.umd.js...\n@redux-saga/is: created dist/redux-saga-is.cjs.js in 236ms\n@redux-saga/testing-utils: created ./dist/redux-saga-testing-utils.esm.js in 2.6s\n@redux-saga/testing-utils: src/index.js \u2192 ./dist/redux-saga-testing-utils.cjs.js...\n@redux-saga/testing-utils: created ./dist/redux-saga-testing-utils.cjs.js in 163ms\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 4.9s\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created ./dist/redux-saga.umd.js in 3.4s\nredux-saga: src/index.umd.js \u2192 ./dist/redux-saga.umd.min.js...\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 1.8s\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 1.6s\n@redux-saga/core: > @redux-saga/core@1.0.1 postbuild /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > node ./scripts/createProxyCjsEntries.js\n@redux-saga/core:   Created proxy commonjs entries: redux-saga-core, redux-saga-effects.\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created ./dist/redux-saga.umd.min.js in 3.5s\nredux-saga: src/index.js, src/effects.js \u2192 dist...\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created dist in 2.2s\nlerna success run Ran npm script 'build' in 7 packages in 16.2s:\nlerna success - @redux-saga/core\nlerna success - @redux-saga/deferred\nlerna success - @redux-saga/delay-p\nlerna success - @redux-saga/is\nlerna success - redux-saga\nlerna success - @redux-saga/symbols\nlerna success - @redux-saga/testing-utils\n@ test /home/travis/build/redux-saga/redux-saga\nnpm run test-only\n@ test-only /home/travis/build/redux-saga/redux-saga\nlerna run --parallel test\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 8 packages: \"npm run test\"\nasync-example: > async-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/async\nasync-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\ncancellable-counter-example: > cancellable-counter-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/cancellable-counter\ncancellable-counter-example: > cross-env BABEL_ENV=cjs babel-node ./test/sagas.js | tap-spec\ncounter-example: > counter-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/counter\ncounter-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\nerror-demo: > error-demo@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/error-demo\nerror-demo: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\nshopping-cart-example: > shopping-cart-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/shopping-cart\nshopping-cart-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\nbabel-plugin-redux-saga: > babel-plugin-redux-saga@1.0.0 test /home/travis/build/redux-saga/redux-saga/packages/babel-plugin-redux-saga\nbabel-plugin-redux-saga: > jest --env=node\n@redux-saga/core: > @redux-saga/core@1.0.1 test /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > jest\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 test /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > jest\ncounter-example:   incrementAsync Saga test\ncounter-example:     \u2714 counter Saga must call delay(1000)\ncounter-example:     \u2714 counter Saga must dispatch an INCREMENT action\ncounter-example:     \u2714 counter Saga must be done\ncounter-example:   total:     3\ncounter-example:   passing:   3\ncounter-example:   duration:  5.2s\ncancellable-counter-example:   watchIncrementAsync Saga\ncancellable-counter-example:     \u2714 watchIncrementAsync takes INCRMEMENT_ASYNC action\ncancellable-counter-example:     \u2714 starts Race between async incremention and cancellation\ncancellable-counter-example:   incrementAsync Saga successful\ncancellable-counter-example:     \u2714 counter Saga instantiates channel emitter\ncancellable-counter-example:     countdown 10\ncancellable-counter-example:     \u2714 take action from eventChannel\ncancellable-counter-example:     \u2714 updates countdown value in the store\ncancellable-counter-example:     \u2714 eventEmitter is done\ncancellable-counter-example:     \u2714 Actual increment is performed\ncancellable-counter-example:     \u2714 The countdown is terminated\ncancellable-counter-example:   incrementAsync Saga with cancellation\ncancellable-counter-example:     \u2714 instanciation of the channel emitter with the provided value to wait\ncancellable-counter-example:     countdown 10\ncancellable-counter-example:     \u2714 takes action from eventChannel\ncancellable-counter-example:     \u2714 put counter value to store\ncancellable-counter-example:     \u2714 eventEmitter is done\ncancellable-counter-example:     countdown cancelled\ncancellable-counter-example:     \u2714 Saga is done\nasync-example:   fetchPosts Saga\nasync-example:     \u2714 must dispatch a requestPosts action\nasync-example:     \u2714 must call fetchPostsApi with reddit name\nasync-example:     \u2714 must dispatch a receivePosts action with posts\nasync-example:     \u2714 must finish\nasync-example:   invalidateReddit Saga\nasync-example:     \u2714 must take a SELECT_REDDIT action\nasync-example:     \u2714 must call fetchPosts with new reddit\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when switching to new reddit\nasync-example:     \u2714 must select current reddit from store\nasync-example:     \u2714 must take a SELECT_REDDIT action\nasync-example:     \u2714 must select newly selected reddit from store\nasync-example:     \u2714 must select posts by reddit from store\nasync-example:     \u2714 delegate to fetchPosts for new reddit's posts\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when same reddit is selected\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when posts were previously loaded\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   startup Saga\nasync-example:     \ufffd\ufffd\ufffd gets currently selected reddit\nasync-example:     \u2714 delegates to fetchPosts to get posts\nasync-example:     \u2714 must finish\nasync-example:   total:     18\nasync-example:   passing:   18\nasync-example:   duration:  7s\nshopping-cart-example:   getProducts Saga test\nshopping-cart-example:     \u2714 must yield api.getProducts\nshopping-cart-example:     \u2714 must yield actions.receiveProducts(products)\nshopping-cart-example:   checkout Saga test\nshopping-cart-example:     \u2714 must select getCart\nshopping-cart-example:     \u2714 must call api.buyProducts(cart)\nshopping-cart-example:     \u2714 must yield actions.checkoutSuccess(cart)\nshopping-cart-example:   total:     5\nshopping-cart-example:   passing:   5\nshopping-cart-example:   duration:  7.1s\nerror-demo:   when run saga via sagaMiddleware errors are shown in logs\nerror-demo:   when run generator manually errors aren't shown in logs\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in async call: shows correct error logs with source of error\ncancellable-counter-example:     countdown 9\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in inlined saga:shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in fork:shows correct error logs with source of error\n@redux-saga/testing-utils: PASS tests/cloneableGenerator.js (5.93s)\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in race: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in delegated saga: doesn't show delegated in error stack\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in helper: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in select: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in put: shows correct error logs with source of error\ncancellable-counter-example:     countdown 8\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in functional expression saga: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   should return error stack if primitive is thrown\nerror-demo:     \u2714 should be equivalent\nerror-demo:   total:     11\nerror-demo:   passing:   11\nerror-demo:   duration:  8.8s\ncancellable-counter-example:     countdown 7\n@redux-saga/testing-utils: PASS tests/createMockTask.js\ncancellable-counter-example:     countdown 6\nbabel-plugin-redux-saga: FAIL test/runner.test.js (8.755s)\nbabel-plugin-redux-saga:   babel6\nbabel-plugin-redux-saga:     \u2713 attach source to declaration (804ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration (14ms)\nbabel-plugin-redux-saga:     \u2715 attach source to export declaration when processed with regenerator (683ms)\nbabel-plugin-redux-saga:     \u2713 should wrap yielded call expression (no name check) (10ms)\nbabel-plugin-redux-saga:     \u2713 should wrap method call (7ms)\nbabel-plugin-redux-saga:     \u2713 shouldn't wrap delegate (6ms)\nbabel-plugin-redux-saga:     \u2713 should handle nested structures (22ms)\nbabel-plugin-redux-saga:     \u2713 should handle function expression (6ms)\nbabel-plugin-redux-saga:     \u2713 should handle simplest expression (52ms)\nbabel-plugin-redux-saga:     \u2713 should handle expressions in object properties (17ms)\nbabel-plugin-redux-saga:     \u2715 should be compatible with es2015 preset regenerator (94ms)\nbabel-plugin-redux-saga:     \u2715 should be compatible with env preset regenerator (52ms)\nbabel-plugin-redux-saga:     \u2713 should handle passed sourcemaps (145ms)\nbabel-plugin-redux-saga:     \u2713 should build absolute path if useAbsolutePath option = true (42ms)\nbabel-plugin-redux-saga:   babel7\nbabel-plugin-redux-saga:     \u2713 attach source to declaration (115ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration (22ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration when processed with regenerator (565ms)\nbabel-plugin-redux-saga:     \u2713 should wrap yielded call expression (no name check) (12ms)\nbabel-plugin-redux-saga:     \u2713 should wrap method call (15ms)\nbabel-plugin-redux-saga:     \u2713 shouldn't wrap delegate (6ms)\nbabel-plugin-redux-saga:     \u2713 should handle nested structures (14ms)\nbabel-plugin-redux-saga:     \u2713 should handle function expression (8ms)\nbabel-plugin-redux-saga:     \u2713 should handle simplest expression (15ms)\nbabel-plugin-redux-saga:     \u2713 should handle expressions in object properties (38ms)\nbabel-plugin-redux-saga:     \u2713 should be compatible with es2015 preset regenerator (130ms)\nbabel-plugin-redux-saga:     \u2713 should be compatible with env preset regenerator (54ms)\nbabel-plugin-redux-saga:     \u2713 should handle passed sourcemaps (52ms)\nbabel-plugin-redux-saga:     \u2713 should build absolute path if useAbsolutePath option = true (8ms)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a attach source to export declaration when processed with regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/declaration-regenerator/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/declaration-regenerator/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a should be compatible with es2015 preset regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/regenerator/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/regenerator/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a should be compatible with env preset regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/preset-env/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/preset-env/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\nbabel-plugin-redux-saga: Test Suites: 1 failed, 1 total\nbabel-plugin-redux-saga: Tests:       3 failed, 25 passed, 28 total\nbabel-plugin-redux-saga: Snapshots:   0 total\nbabel-plugin-redux-saga: Time:        8.941s\nbabel-plugin-redux-saga: Ran all test suites.\nbabel-plugin-redux-saga: npm ERR! code ELIFECYCLE\nbabel-plugin-redux-saga: npm ERR! errno 1\nbabel-plugin-redux-saga: npm ERR! babel-plugin-redux-saga@1.0.0 test: jest --env=node\nbabel-plugin-redux-saga: npm ERR! Exit status 1\nbabel-plugin-redux-saga: npm ERR! \nbabel-plugin-redux-saga: npm ERR! Failed at the babel-plugin-redux-saga@1.0.0 test script.\nbabel-plugin-redux-saga: npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nbabel-plugin-redux-saga: npm ERR! A complete log of this run can be found in:\nbabel-plugin-redux-saga: npm ERR!     /home/travis/.npm/_logs/2019-02-21T21_07_12_027Z-debug.log\nlerna ERR! npm run test exited 1 in 'babel-plugin-redux-saga'\nlerna ERR! npm run test stdout:\nbabel-plugin-redux-saga@1.0.0 test /home/travis/build/redux-saga/redux-saga/packages/babel-plugin-redux-saga\njest --env=node\nlerna ERR! npm run test stderr:\nFAIL test/runner.test.js (8.755s)\n  babel6\n    \u2713 attach source to declaration (804ms)\n    \u2713 attach source to export declaration (14ms)\n    \u2715 attach source to export declaration when processed with regenerator (683ms)\n    \u2713 should wrap yielded call expression (no name check) (10ms)\n    \u2713 should wrap method call (7ms)\n    \u2713 shouldn't wrap delegate (6ms)\n    \u2713 should handle nested structures (22ms)\n    \u2713 should handle function expression (6ms)\n    \u2713 should handle simplest expression (52ms)\n    \u2713 should handle expressions in object properties (17ms)\n    \u2715 should be compatible with es2015 preset regenerator (94ms)\n    \u2715 should be compatible with env preset regenerator (52ms)\n    \u2713 should handle passed sourcemaps (145ms)\n    \u2713 should build absolute path if useAbsolutePath option = true (42ms)\n  babel7\n    \u2713 attach source to declaration (115ms)\n    \u2713 attach source to export declaration (22ms)\n    \u2713 attach source to export declaration when processed with regenerator (565ms)\n    \u2713 should wrap yielded call expression (no name check) (12ms)\n    \u2713 should wrap method call (15ms)\n    \u2713 shouldn't wrap delegate (6ms)\n    \u2713 should handle nested structures (14ms)\n    \u2713 should handle function expression (8ms)\n    \u2713 should handle simplest expression (15ms)\n    \u2713 should handle expressions in object properties (38ms)\n    \u2713 should be compatible with es2015 preset regenerator (130ms)\n    \u2713 should be compatible with env preset regenerator (54ms)\n    \u2713 should handle passed sourcemaps (52ms)\n    \u2713 should build absolute path if useAbsolutePath option = true (8ms)\n  \u25cf babel6 \u203a attach source to export declaration when processed with regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE*/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/declaration-regenerator/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/declaration-regenerator/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\n\u25cf babel6 \u203a should be compatible with es2015 preset regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/regenerator/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/regenerator/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\n\u25cf babel6 \u203a should be compatible with env preset regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/preset-env/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/preset-env/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/preset-env/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/preset-env/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\nTest Suites: 1 failed, 1 total\nTests:       3 failed, 25 passed, 28 total\nSnapshots:   0 total\nTime:        8.941s\nRan all test suites.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! babel-plugin-redux-saga@1.0.0 test: jest --env=node\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the babel-plugin-redux-saga@1.0.0 test script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_07_12_027Z-debug.log\nlerna ERR! npm run test exited 1 in 'babel-plugin-redux-saga'\nlerna WARN complete Waiting for 3 child processes to exit. CTRL-C to exit immediately.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ test-only: lerna run --parallel test\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ test-only script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_07_12_146Z-debug.log\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ test: npm run test-only\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ test script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_07_12_169Z-debug.log\nERROR: \"test\" exited with 1.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ check: run-s lint test\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ check script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_07_12_195Z-debug.log\nThe command \"npm run check\" exited with 1.\nafter_script\n3.10s$ npm run bundlesize\n\n@ bundlesize /home/travis/build/redux-saga/redux-saga\nlerna run --parallel bundlesize\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 2 packages: \"npm run bundlesize\"\n@redux-saga/core: > @redux-saga/core@1.0.1 prebundlesize /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > npm run build\nredux-saga: > redux-saga@1.0.1 bundlesize /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > bundlesize\nredux-saga:  ERROR  There is no matching file for ./dist/redux-saga.min.umd.js \nredux-saga: npm ERR! code ELIFECYCLE\nredux-saga: npm ERR! errno 1\nredux-saga: npm ERR! redux-saga@1.0.1 bundlesize: bundlesize\nredux-saga: npm ERR! Exit status 1\nredux-saga: npm ERR! \nredux-saga: npm ERR! Failed at the redux-saga@1.0.1 bundlesize script.\nredux-saga: npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nredux-saga: npm ERR! A complete log of this run can be found in:\nredux-saga: npm ERR!     /home/travis/.npm/_logs/2019-02-21T21_07_15_281Z-debug.log\nlerna ERR! npm run bundlesize exited 1 in 'redux-saga'\nlerna ERR! npm run bundlesize stdout:\nredux-saga@1.0.1 bundlesize /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nbundlesize\n ERROR  There is no matching file for ./dist/redux-saga.min.umd.js \nlerna ERR! npm run bundlesize stderr:\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! redux-saga@1.0.1 bundlesize: bundlesize\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the redux-saga@1.0.1 bundlesize script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_07_15_281Z-debug.log\nlerna ERR! npm run bundlesize exited 1 in 'redux-saga'\nlerna WARN complete Waiting for 1 child process to exit. CTRL-C to exit immediately.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ bundlesize: lerna run --parallel bundlesize\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ bundlesize script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_07_15_324Z-debug.log\nDone. Your build exited with 1.. This one is from node 8. (Try to figure out what the error is)(sorry for the long logs)\nWorker information\nhostname: d7ad7710-0451-4124-b2e4-04dc3e0557a7@1.production-2-worker-org-gce-g5fb\nversion: v6.2.0 https://github.com/travis-ci/worker/tree/5e5476e01646095f48eec13196fdb3faf8f5cbf7\ninstance: travis-job-dd3622d5-9543-4da7-bf3b-e7faff9d4e22 travis-ci-garnet-trusty-1512502259-986baf0 (via amqp)\nstartup: 6.666931596s\nsystem_info\nBuild system information\nBuild language: node_js\nBuild group: stable\nBuild dist: trusty\nBuild id: 496714289\nJob id: 496714290\nRuntime kernel version: 4.4.0-101-generic\ntravis-build version: ecb8262c9\nBuild image provisioning date and time\nTue Dec  5 19:58:13 UTC 2017\nOperating System Details\nDistributor ID: Ubuntu\nDescription:    Ubuntu 14.04.5 LTS\nRelease:    14.04\nCodename:   trusty\nCookbooks Version\n7c2c6a6 https://github.com/travis-ci/travis-cookbooks/tree/7c2c6a6\ngit version\ngit version 2.15.1\nbash version\nGNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)\ngcc version\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4\nCopyright (C) 2013 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\ndocker version\nClient:\n Version:      17.09.0-ce\n API version:  1.32\n Go version:   go1.8.3\n Git commit:   afdb6d4\n Built:        Tue Sep 26 22:42:38 2017\n OS/Arch:      linux/amd64\nServer:\n Version:      17.09.0-ce\n API version:  1.32 (minimum version 1.12)\n Go version:   go1.8.3\n Git commit:   afdb6d4\n Built:        Tue Sep 26 22:41:20 2017\n OS/Arch:      linux/amd64\n Experimental: false\nclang version\nclang version 5.0.0 (tags/RELEASE_500/final)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /usr/local/clang-5.0.0/bin\njq version\njq-1.5\nbats version\nBats 0.4.0\nshellcheck version\n0.4.6\nshfmt version\nv2.0.0\nccache version\nccache version 3.1.9\nCopyright (C) 2002-2007 Andrew Tridgell\nCopyright (C) 2009-2011 Joel Rosdahl\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free Software\nFoundation; either version 3 of the License, or (at your option) any later\nversion.\ncmake version\ncmake version 3.9.2\nCMake suite maintained and supported by Kitware (kitware.com/cmake).\nheroku version\nheroku-cli/6.14.39-addc925 (linux-x64) node-v9.2.0\nimagemagick version\nVersion: ImageMagick 6.7.7-10 2017-07-31 Q16 http://www.imagemagick.org\nmd5deep version\n4.2\nmercurial version\nMercurial Distributed SCM (version 4.2.2)\n(see https://mercurial-scm.org for more information)\nCopyright (C) 2005-2017 Matt Mackall and others\nThis is free software; see the source for copying conditions. There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nmysql version\nmysql  Ver 14.14 Distrib 5.6.33, for debian-linux-gnu (x86_64) using  EditLine wrapper\nopenssl version\nOpenSSL 1.0.1f 6 Jan 2014\npacker version\nPacker v1.0.2\nYour version of Packer is out of date! The latest version\nis 1.1.2. You can update by downloading from www.packer.io\npostgresql client version\npsql (PostgreSQL) 9.6.6\nragel version\nRagel State Machine Compiler version 6.8 Feb 2013\nCopyright (c) 2001-2009 by Adrian Thurston\nsubversion version\nsvn, version 1.8.8 (r1568071)\n   compiled Aug 10 2017, 17:20:39 on x86_64-pc-linux-gnu\nCopyright (C) 2013 The Apache Software Foundation.\nThis software consists of contributions made by many people;\nsee the NOTICE file for more information.\nSubversion is open source software, see http://subversion.apache.org/\nThe following repository access (RA) modules are available:\n ra_svn : Module for accessing a repository using the svn network protocol.\n  - with Cyrus SASL authentication\n  - handles 'svn' scheme\n ra_local : Module for accessing a repository on local disk.\n  - handles 'file' scheme\n ra_serf : Module for accessing a repository via WebDAV protocol using serf.\n  - using serf 1.3.3\n  - handles 'http' scheme\n  - handles 'https' scheme\nsudo version\nSudo version 1.8.9p5\nConfigure options: --prefix=/usr -v --with-all-insults --with-pam --with-fqdn --with-logging=syslog --with-logfac=authpriv --with-env-editor --with-editor=/usr/bin/editor --with-timeout=15 --with-password-timeout=0 --with-passprompt=[sudo] password for %p:  --without-lecture --with-tty-tickets --disable-root-mailer --enable-admin-flag --with-sendmail=/usr/sbin/sendmail --with-timedir=/var/lib/sudo --mandir=/usr/share/man --libexecdir=/usr/lib/sudo --with-sssd --with-sssd-lib=/usr/lib/x86_64-linux-gnu --with-selinux\nSudoers policy plugin version 1.8.9p5\nSudoers file grammar version 43\nSudoers path: /etc/sudoers\nAuthentication methods: 'pam'\nSyslog facility if syslog is being used for logging: authpriv\nSyslog priority to use when user authenticates successfully: notice\nSyslog priority to use when user authenticates unsuccessfully: alert\nSend mail if the user is not in sudoers\nUse a separate timestamp for each user/tty combo\nLecture user the first time they run sudo\nRoot may run sudo\nAllow some information gathering to give useful error messages\nRequire fully-qualified hostnames in the sudoers file\nVisudo will honor the EDITOR environment variable\nSet the LOGNAME and USER environment variables\nLength at which to wrap log file lines (0 for no wrap): 80\nAuthentication timestamp timeout: 15.0 minutes\nPassword prompt timeout: 0.0 minutes\nNumber of tries to enter a password: 3\nUmask to use or 0777 to use user's: 022\nPath to mail program: /usr/sbin/sendmail\nFlags for mail program: -t\nAddress to send mail to: root\nSubject line for mail messages:  SECURITY information for %h \nIncorrect password message: Sorry, try again.\nPath to authentication timestamp dir: /var/lib/sudo\nDefault password prompt: [sudo] password for %p: \nDefault user to run commands as: root\nValue to override user's $PATH with: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin\nPath to the editor for use by visudo: /usr/bin/editor\nWhen to require a password for 'list' pseudocommand: any\nWhen to require a password for 'verify' pseudocommand: all\nFile descriptors >= 3 will be closed before executing a command\nEnvironment variables to check for sanity:\n    TZ\n    TERM\n    LINGUAS\n    LC_\n    LANGUAGE\n    LANG\n    COLORTERM\nEnvironment variables to remove:\n    RUBYOPT\n    RUBYLIB\n    PYTHONUSERBASE\n    PYTHONINSPECT\n    PYTHONPATH\n    PYTHONHOME\n    TMPPREFIX\n    ZDOTDIR\n    READNULLCMD\n    NULLCMD\n    FPATH\n    PERL5DB\n    PERL5OPT\n    PERL5LIB\n    PERLLIB\n    PERLIO_DEBUG \n    JAVA_TOOL_OPTIONS\n    SHELLOPTS\n    GLOBIGNORE\n    PS4\n    BASH_ENV\n    ENV\n    TERMCAP\n    TERMPATH\n    TERMINFO_DIRS\n    TERMINFO\n    _RLD\n    LD_\n    PATH_LOCALE\n    NLSPATH\n    HOSTALIASES\n    RES_OPTIONS\n    LOCALDOMAIN\n    CDPATH\n    IFS\nEnvironment variables to preserve:\n    JAVA_HOME\n    TRAVIS\n    CI\n    DEBIAN_FRONTEND\n    XAUTHORIZATION\n    XAUTHORITY\n    PS2\n    PS1\n    PATH\n    LS_COLORS\n    KRB5CCNAME\n    HOSTNAME\n    HOME\n    DISPLAY\n    COLORS\nLocale to use while parsing sudoers: C\nDirectory in which to store input/output logs: /var/log/sudo-io\nFile in which to store the input/output log: %{seq}\nAdd an entry to the utmp/utmpx file when allocating a pty\nPAM service name to use\nPAM service name to use for login shells\nCreate a new PAM session for the command to run in\nMaximum I/O log sequence number: 0\nLocal IP address and netmask pairs:\n    10.240.0.28/255.255.255.255\n    172.17.0.1/255.255.0.0\nSudoers I/O plugin version 1.8.9p5\ngzip version\ngzip 1.6\nCopyright (C) 2007, 2010, 2011 Free Software Foundation, Inc.\nCopyright (C) 1993 Jean-loup Gailly.\nThis is free software.  You may redistribute copies of it under the terms of\nthe GNU General Public License http://www.gnu.org/licenses/gpl.html.\nThere is NO WARRANTY, to the extent permitted by law.\nWritten by Jean-loup Gailly.\nzip version\nCopyright (c) 1990-2008 Info-ZIP - Type 'zip \"-L\"' for software license.\nThis is Zip 3.0 (July 5th 2008), by Info-ZIP.\nCurrently maintained by E. Gordon.  Please send bug reports to\nthe authors using the web page at www.info-zip.org; see README for details.\nLatest sources and executables are at ftp://ftp.info-zip.org/pub/infozip,\nas of above date; see http://www.info-zip.org/ for other sites.\nCompiled with gcc 4.8.2 for Unix (Linux ELF) on Oct 21 2013.\nZip special compilation options:\n    USE_EF_UT_TIME       (store Universal Time)\n    BZIP2_SUPPORT        (bzip2 library version 1.0.6, 6-Sept-2010)\n        bzip2 code and library copyright (c) Julian R Seward\n        (See the bzip2 license for terms of use)\n    SYMLINK_SUPPORT      (symbolic links supported)\n    LARGE_FILE_SUPPORT   (can read and write large files on file system)\n    ZIP64_SUPPORT        (use Zip64 to store large files in archives)\n    UNICODE_SUPPORT      (store and read UTF-8 Unicode paths)\n    STORE_UNIX_UIDs_GIDs (store UID/GID sizes/values using new extra field)\n    UIDGID_NOT_16BIT     (old Unix 16-bit UID/GID extra field not used)\n    [encryption, version 2.91 of 05 Jan 2007] (modified for Zip 3)\nEncryption notice:\n    The encryption code of this program is not copyrighted and is\n    put in the public domain.  It was originally written in Europe\n    and, to the best of our knowledge, can be freely distributed\n    in both source and object forms from any country, including\n    the USA under License Exception TSU of the U.S. Export\n    Administration Regulations (section 740.13(e)) of 6 June 2002.\nZip environment options:\n             ZIP:  [none]\n          ZIPOPT:  [none]\nvim version\nVIM - Vi IMproved 7.4 (2013 Aug 10, compiled Nov 24 2016 16:43:18)\nIncluded patches: 1-52\nExtra patches: 8.0.0056\nModified by pkg-vim-maintainers@lists.alioth.debian.org\nCompiled by buildd@\nHuge version without GUI.  Features included (+) or not (-):\n+acl             +farsi           +mouse_netterm   +syntax\n+arabic          +file_in_path    +mouse_sgr       +tag_binary\n+autocmd         +find_in_path    -mouse_sysmouse  +tag_old_static\n-balloon_eval    +float           +mouse_urxvt     -tag_any_white\n-browse          +folding         +mouse_xterm     -tcl\n++builtin_terms  -footer          +multi_byte      +terminfo\n+byte_offset     +fork()          +multi_lang      +termresponse\n+cindent         +gettext         -mzscheme        +textobjects\n-clientserver    -hangul_input    +netbeans_intg   +title\n-clipboard       +iconv           +path_extra      -toolbar\n+cmdline_compl   +insert_expand   -perl            +user_commands\n+cmdline_hist    +jumplist        +persistent_undo +vertsplit\n+cmdline_info    +keymap          +postscript      +virtualedit\n+comments        +langmap         +printer         +visual\n+conceal         +libcall         +profile         +visualextra\n+cryptv          +linebreak       +python          +viminfo\n+cscope          +lispindent      -python3         +vreplace\n+cursorbind      +listcmds        +quickfix        +wildignore\n+cursorshape     +localmap        +reltime         +wildmenu\n+dialog_con      -lua             +rightleft       +windows\n+diff            +menu            -ruby            +writebackup\n+digraphs        +mksession       +scrollbind      -X11\n-dnd             +modify_fname    +signs           -xfontset\n-ebcdic          +mouse           +smartindent     -xim\n+emacs_tags      -mouseshape      -sniff           -xsmp\n+eval            +mouse_dec       +startuptime     -xterm_clipboard\n+ex_extra        +mouse_gpm       +statusline      -xterm_save\n+extra_search    -mouse_jsbterm   -sun_workshop    -xpm\n   system vimrc file: \"$VIM/vimrc\"\n     user vimrc file: \"$HOME/.vimrc\"\n 2nd user vimrc file: \"~/.vim/vimrc\"\n      user exrc file: \"$HOME/.exrc\"\n  fall-back for $VIM: \"/usr/share/vim\"\nCompilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1    \nLinking: gcc   -Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,--as-needed -o vim        -lm -ltinfo -lnsl  -lselinux  -lacl -lattr -lgpm -ldl    -L/usr/lib/python2.7/config-x86_64-linux-gnu -lpython2.7 -lpthread -ldl -lutil -lm -Xlinker -export-dynamic -Wl,-O1 -Wl,-Bsymbolic-functions    \niptables version\niptables v1.4.21\ncurl version\ncurl 7.35.0 (x86_64-pc-linux-gnu) libcurl/7.35.0 OpenSSL/1.0.1f zlib/1.2.8 libidn/1.28 librtmp/2.3\nwget version\nGNU Wget 1.15 built on linux-gnu.\nrsync version\nrsync  version 3.1.0  protocol version 31\ngimme version\nv1.2.0\nnvm version\n0.33.6\nperlbrew version\n/home/travis/perl5/perlbrew/bin/perlbrew  - App::perlbrew/0.80\nphpenv version\nrbenv 1.1.1-25-g6aa70b6\nrvm version\nrvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]\ndefault ruby version\nruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-linux]\nCouchDB version\ncouchdb 1.6.1\nElasticSearch version\n5.5.0\nInstalled Firefox version\nfirefox 56.0.2\nMongoDB version\nMongoDB 3.4.10\nPhantomJS version\n2.1.1\nPre-installed PostgreSQL versions\n9.2.24\n9.3.20\n9.4.15\n9.5.10\n9.6.6\nRabbitMQ Version\n3.6.14\nRedis version\nredis-server 4.0.6\nriak version\n2.2.3\nPre-installed Go versions\n1.7.4\nant version\nApache Ant(TM) version 1.9.3 compiled on April 8 2014\nmvn version\nApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T07:58:13Z)\nMaven home: /usr/local/maven-3.5.2\nJava version: 1.8.0_151, vendor: Oracle Corporation\nJava home: /usr/lib/jvm/java-8-oracle/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"4.4.0-98-generic\", arch: \"amd64\", family: \"unix\"\ngradle version\n\n\nGradle 4.0.1\nBuild time:   2017-07-07 14:02:41 UTC\nRevision:     38e5dc0f772daecca1d2681885d3d85414eb6826\nGroovy:       2.4.11\nAnt:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015\nJVM:          1.8.0_151 (Oracle Corporation 25.151-b12)\nOS:           Linux 4.4.0-98-generic amd64\nlein version\nLeiningen 2.8.1 on Java 1.8.0_151 Java HotSpot(TM) 64-Bit Server VM\nPre-installed Node.js versions\nv4.8.6\nv6.12.0\nv6.12.1\nv8.9\nv8.9.1\nphpenv versions\n  system\n  5.6\n* 5.6.32 (set by /home/travis/.phpenv/version)\n  7.0\n  7.0.25\n  7.1\n  7.1.11\n  hhvm\n  hhvm-stable\ncomposer --version\nComposer version 1.5.2 2017-09-11 16:59:25\nPre-installed Ruby versions\nruby-2.2.7\nruby-2.3.4\nruby-2.4.1\ngit.checkout\n0.76s$ git clone --depth=50 https://github.com/redux-saga/redux-saga.git redux-saga/redux-saga\nCloning into 'redux-saga/redux-saga'...\nremote: Enumerating objects: 1121, done.\nremote: Counting objects: 100% (1121/1121), done.\nremote: Compressing objects: 100% (562/562), done.\nremote: Total 1121 (delta 587), reused 837 (delta 496), pack-reused 0\nReceiving objects: 100% (1121/1121), 815.18 KiB | 9.70 MiB/s, done.\nResolving deltas: 100% (587/587), done.\n$ cd redux-saga/redux-saga\n0.47s$ git fetch origin +refs/pull/1784/merge:\nremote: Enumerating objects: 25, done.\nremote: Counting objects: 100% (25/25), done.\nremote: Compressing objects: 100% (14/14), done.\nremote: Total 21 (delta 7), reused 14 (delta 3), pack-reused 0\nUnpacking objects: 100% (21/21), done.\nFrom https://github.com/redux-saga/redux-saga\n * branch            refs/pull/1784/merge -> FETCH_HEAD\n$ git checkout -qf FETCH_HEAD\nEncrypted environment variables have been removed for security reasons.\nSee https://docs.travis-ci.com/user/pull-requests/#pull-requests-and-security-restrictions\nnvm.install\n3.44s$ nvm install 8\nDownloading and installing node v8.15.0...\nDownloading https://nodejs.org/dist/v8.15.0/node-v8.15.0-linux-x64.tar.xz...\nComputing checksum with sha256sum\nChecksums matched!\nNow using node v8.15.0 (npm v6.4.1)\n$ node --version\nv8.15.0\n$ npm --version\n6.4.1\n$ nvm --version\n0.34.0\ninstall.npm\n86.05s$ npm install \nnpm WARN deprecated circular-json@0.3.3: CircularJSON is in maintenance only, flatted is its successor.\nnpm WARN deprecated kleur@2.0.2: Please upgrade to kleur@3 or migrate to 'ansi-colors' if you prefer the old syntax. Visit <https://github.com/lukeed/kleur/releases/tag/v3.0.0> for migration path(s).\nnpm WARN deprecated node-uuid@1.4.8: Use uuid module instead\nnpm WARN deprecated boom@2.10.1: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN deprecated cryptiles@2.0.5: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN deprecated hoek@2.16.3: This version is no longer maintained. Please upgrade to the latest version.\nnpm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0\n\nhusky@1.3.1 install /home/travis/build/redux-saga/redux-saga/node_modules/husky\nnode husky install\nhusky > setting up git hooks\nCI detected, skipping Git hooks installation.\nlint-staged@3.6.1 postinstall /home/travis/build/redux-saga/redux-saga/node_modules/lint-staged\necho \"\ud83d\udeab\ud83d\udca9 lint-staged installed! \nDo not forget to configure it. See https://github.com/okonet/lint-staged/blob/master/README.md\" && exit 0\n\ud83d\udeab\ud83d\udca9 lint-staged installed! \nDo not forget to configure it. See https://github.com/okonet/lint-staged/blob/master/README.md\nundefined postinstall /home/travis/build/redux-saga/redux-saga\nnpm run bootstrap\n@ bootstrap /home/travis/build/redux-saga/redux-saga\nlerna bootstrap --ignore-scripts\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Bootstrapping 17 packages\nlerna info Installing external dependencies\nlerna info hoist Installing hoisted dependencies into root\nlerna info hoist Pruning hoisted dependencies\nlerna info hoist Finished pruning hoisted dependencies\nlerna info hoist Finished bootstrapping root\nlerna info Symlinking packages and binaries\nlerna success Bootstrapped 17 packages\nnpm WARN typings-tester@0.2.2 requires a peer of typescript@~2 but none is installed. You must install peer dependencies yourself.\nnpm WARN acorn-dynamic-import@4.0.0 requires a peer of acorn@^6.0.0 but none is installed. You must install peer dependencies yourself.\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: idb-connector@1.1.8 (node_modules/idb-connector):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for idb-connector@1.1.8: wanted {\"os\":\"aix\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.7 (node_modules/fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\nadded 2283 packages from 1328 contributors and audited 78067 packages in 85.379s\nfound 140 vulnerabilities (68 low, 58 moderate, 14 high)\n  run npm audit fix to fix them, or npm audit for details\n33.44s$ npm run check\n@ check /home/travis/build/redux-saga/redux-saga\nrun-s lint test\n@ lint /home/travis/build/redux-saga/redux-saga\neslint packages//{src,test}\n@ pretest /home/travis/build/redux-saga/redux-saga\nnpm run build\n@ build /home/travis/build/redux-saga/redux-saga\nlerna run --parallel build\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 7 packages: \"npm run build\"\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > npm run clean\n@redux-saga/core: > @redux-saga/core@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > npm run clean\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > npm run clean\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > npm run clean\n@redux-saga/is: > @redux-saga/is@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > npm run clean\nredux-saga: > redux-saga@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > npm run clean\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 prebuild /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > npm run clean\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > rimraf dist\n@redux-saga/core: > @redux-saga/core@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > rimraf dist\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > rimraf dist\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > rimraf dist\n@redux-saga/is: > @redux-saga/is@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > rimraf dist\nredux-saga: > redux-saga@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > rimraf dist\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 clean /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > rimraf dist\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > rollup -c\n@redux-saga/delay-p: > @redux-saga/delay-p@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/delay-p\n@redux-saga/delay-p: > rollup -c\n@redux-saga/core: > @redux-saga/core@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > rollup -c\n@redux-saga/is: > @redux-saga/is@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/is\n@redux-saga/is: > rollup -c\n@redux-saga/deferred: > @redux-saga/deferred@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/deferred\n@redux-saga/deferred: > rollup -c\nredux-saga: > redux-saga@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > rollup -c\n@redux-saga/symbols: > @redux-saga/symbols@1.0.1 build /home/travis/build/redux-saga/redux-saga/packages/symbols\n@redux-saga/symbols: > rollup -c\n@redux-saga/delay-p: src/index.js \u2192 ./dist/redux-saga-delay-p.esm.js...\n@redux-saga/is: src/index.js \u2192 dist/redux-saga-is.esm.js...\n@redux-saga/testing-utils: src/index.js \u2192 ./dist/redux-saga-testing-utils.esm.js...\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/deferred: src/index.js \u2192 ./dist/redux-saga-deferred.esm.js...\n@redux-saga/symbols: src/index.js \u2192 ./dist/redux-saga-symbols.esm.js...\nredux-saga: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/delay-p: created ./dist/redux-saga-delay-p.esm.js in 2.5s\n@redux-saga/delay-p: src/index.js \u2192 ./dist/redux-saga-delay-p.cjs.js...\n@redux-saga/delay-p: created ./dist/redux-saga-delay-p.cjs.js in 148ms\n@redux-saga/deferred: created ./dist/redux-saga-deferred.esm.js in 2.3s\n@redux-saga/deferred: src/index.js \u2192 ./dist/redux-saga-deferred.cjs.js...\nredux-saga: created dist in 2.3s\nredux-saga: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/symbols: created ./dist/redux-saga-symbols.esm.js in 2.4s\n@redux-saga/symbols: src/index.js \u2192 ./dist/redux-saga-symbols.cjs.js...\n@redux-saga/is: created dist/redux-saga-is.esm.js in 2.7s\n@redux-saga/is: src/index.js \u2192 dist/redux-saga-is.cjs.js...\n@redux-saga/deferred: created ./dist/redux-saga-deferred.cjs.js in 166ms\nredux-saga: created dist in 108ms\nredux-saga: src/index.umd.js \u2192 ./dist/redux-saga.umd.js...\n@redux-saga/testing-utils: created ./dist/redux-saga-testing-utils.esm.js in 2.7s\n@redux-saga/testing-utils: src/index.js \u2192 ./dist/redux-saga-testing-utils.cjs.js...\n@redux-saga/symbols: created ./dist/redux-saga-symbols.cjs.js in 192ms\n@redux-saga/is: created dist/redux-saga-is.cjs.js in 390ms\n@redux-saga/testing-utils: created ./dist/redux-saga-testing-utils.cjs.js in 343ms\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 5s\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created ./dist/redux-saga.umd.js in 3.7s\nredux-saga: src/index.umd.js \u2192 ./dist/redux-saga.umd.min.js...\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 1.7s\n@redux-saga/core: src/index.js, src/effects.js \u2192 dist...\n@redux-saga/core: (!) Circular dependency: src/internal/proc.js -> src/internal/effectRunnerMap.js -> src/internal/proc.js\n@redux-saga/core: created dist in 1.6s\n@redux-saga/core: > @redux-saga/core@1.0.1 postbuild /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > node ./scripts/createProxyCjsEntries.js\n@redux-saga/core:   Created proxy commonjs entries: redux-saga-core, redux-saga-effects.\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created ./dist/redux-saga.umd.min.js in 3.4s\nredux-saga: src/index.js, src/effects.js \u2192 dist...\nredux-saga: (!) Circular dependency: ../core/src/internal/proc.js -> ../core/src/internal/effectRunnerMap.js -> ../core/src/internal/proc.js\nredux-saga: created dist in 2.3s\nlerna success run Ran npm script 'build' in 7 packages in 17.2s:\nlerna success - @redux-saga/core\nlerna success - @redux-saga/deferred\nlerna success - @redux-saga/delay-p\nlerna success - @redux-saga/is\nlerna success - redux-saga\nlerna success - @redux-saga/symbols\nlerna success - @redux-saga/testing-utils\n@ test /home/travis/build/redux-saga/redux-saga\nnpm run test-only\n@ test-only /home/travis/build/redux-saga/redux-saga\nlerna run --parallel test\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 8 packages: \"npm run test\"\ncounter-example: > counter-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/counter\ncounter-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\nasync-example: > async-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/async\nasync-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\nshopping-cart-example: > shopping-cart-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/shopping-cart\nshopping-cart-example: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\ncancellable-counter-example: > cancellable-counter-example@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/cancellable-counter\ncancellable-counter-example: > cross-env BABEL_ENV=cjs babel-node ./test/sagas.js | tap-spec\nerror-demo: > error-demo@1.0.1 test /home/travis/build/redux-saga/redux-saga/examples/error-demo\nerror-demo: > cross-env NODE_ENV=test babel-node test/sagas.js | tap-spec\n@redux-saga/testing-utils: > @redux-saga/testing-utils@1.0.1 test /home/travis/build/redux-saga/redux-saga/packages/testing-utils\n@redux-saga/testing-utils: > jest\nbabel-plugin-redux-saga: > babel-plugin-redux-saga@1.0.0 test /home/travis/build/redux-saga/redux-saga/packages/babel-plugin-redux-saga\nbabel-plugin-redux-saga: > jest --env=node\n@redux-saga/core: > @redux-saga/core@1.0.1 test /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > jest\ncounter-example:   incrementAsync Saga test\ncounter-example:     \u2714 counter Saga must call delay(1000)\ncounter-example:     \u2714 counter Saga must dispatch an INCREMENT action\ncounter-example:     \u2714 counter Saga must be done\ncounter-example:   total:     3\ncounter-example:   passing:   3\ncounter-example:   duration:  4.9s\nasync-example:   fetchPosts Saga\nasync-example:     \u2714 must dispatch a requestPosts action\nasync-example:     \u2714 must call fetchPostsApi with reddit name\nasync-example:     \u2714 must dispatch a receivePosts action with posts\nasync-example:     \u2714 must finish\nasync-example:   invalidateReddit Saga\nasync-example:     \u2714 must take a SELECT_REDDIT action\nasync-example:     \u2714 must call fetchPosts with new reddit\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when switching to new reddit\nasync-example:     \u2714 must select current reddit from store\nasync-example:     \u2714 must take a SELECT_REDDIT action\nasync-example:     \u2714 must select newly selected reddit from store\nasync-example:     \u2714 must select posts by reddit from store\nasync-example:     \u2714 delegate to fetchPosts for new reddit's posts\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when same reddit is selected\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   nextRedditChange Saga when posts were previously loaded\nasync-example:     \u2714 must go back to beginning of loop\nasync-example:   startup Saga\nasync-example:     \u2714 gets currently selected reddit\nasync-example:     \u2714 delegates to fetchPosts to get posts\nasync-example:     \u2714 must finish\nasync-example:   total:     18\nasync-example:   passing:   18\nasync-example:   duration:  6.4s\ncancellable-counter-example:   watchIncrementAsync Saga\ncancellable-counter-example:     \u2714 watchIncrementAsync takes INCRMEMENT_ASYNC action\ncancellable-counter-example:     \u2714 starts Race between async incremention and cancellation\ncancellable-counter-example:   incrementAsync Saga successful\ncancellable-counter-example:     \u2714 counter Saga instantiates channel emitter\ncancellable-counter-example:     countdown 10\ncancellable-counter-example:     \u2714 take action from eventChannel\ncancellable-counter-example:     \u2714 updates countdown value in the store\ncancellable-counter-example:     \u2714 eventEmitter is done\ncancellable-counter-example:     \u2714 Actual increment is performed\ncancellable-counter-example:     \u2714 The countdown is terminated\ncancellable-counter-example:   incrementAsync Saga with cancellation\ncancellable-counter-example:     \u2714 instanciation of the channel emitter with the provided value to wait\ncancellable-counter-example:     countdown 10\ncancellable-counter-example:     \u2714 takes action from eventChannel\ncancellable-counter-example:     \u2714 put counter value to store\ncancellable-counter-example:     \u2714 eventEmitter is done\ncancellable-counter-example:     countdown cancelled\ncancellable-counter-example:     \u2714 Saga is done\nshopping-cart-example:   getProducts Saga test\nshopping-cart-example:     \u2714 must yield api.getProducts\nshopping-cart-example:     \u2714 must yield actions.receiveProducts(products)\nshopping-cart-example:   checkout Saga test\nshopping-cart-example:     \u2714 must select getCart\nshopping-cart-example:     \u2714 must call api.buyProducts(cart)\nshopping-cart-example:     \u2714 must yield actions.checkoutSuccess(cart)\nshopping-cart-example:   total:     5\nshopping-cart-example:   passing:   5\nshopping-cart-example:   duration:  7.2s\nerror-demo:   when run saga via sagaMiddleware errors are shown in logs\nerror-demo:   when run generator manually errors aren't shown in logs\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in async call: shows correct error logs with source of error\ncancellable-counter-example:     countdown 9\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in inlined saga:shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in fork:shows correct error logs with source of error\n@redux-saga/testing-utils: PASS tests/cloneableGenerator.js (5.788s)\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in race: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in delegated saga: doesn't show delegated in error stack\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in helper: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in select: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in put: shows correct error logs with source of error\nerror-demo:     \u2714 should be equivalent\nerror-demo:   error in functional expression saga: shows correct error logs with source of error\ncancellable-counter-example:     countdown 8\nerror-demo:     \u2714 should be equivalent\nerror-demo:   should return error stack if primitive is thrown\nerror-demo:     \u2714 should be equivalent\nerror-demo:   total:     11\nerror-demo:   passing:   11\nerror-demo:   duration:  8.9s\ncancellable-counter-example:     countdown 7\n@redux-saga/testing-utils: PASS tests/createMockTask.js\nbabel-plugin-redux-saga: FAIL test/runner.test.js (8.215s)\nbabel-plugin-redux-saga:   babel6\nbabel-plugin-redux-saga:     \u2713 attach source to declaration (621ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration (25ms)\nbabel-plugin-redux-saga:     \u2715 attach source to export declaration when processed with regenerator (615ms)\nbabel-plugin-redux-saga:     \u2713 should wrap yielded call expression (no name check) (9ms)\nbabel-plugin-redux-saga:     \u2713 should wrap method call (7ms)\nbabel-plugin-redux-saga:     \u2713 shouldn't wrap delegate (16ms)\nbabel-plugin-redux-saga:     \u2713 should handle nested structures (28ms)\nbabel-plugin-redux-saga:     \u2713 should handle function expression (36ms)\nbabel-plugin-redux-saga:     \u2713 should handle simplest expression (13ms)\nbabel-plugin-redux-saga:     \u2713 should handle expressions in object properties (7ms)\nbabel-plugin-redux-saga:     \u2715 should be compatible with es2015 preset regenerator (137ms)\nbabel-plugin-redux-saga:     \u2715 should be compatible with env preset regenerator (41ms)\nbabel-plugin-redux-saga:     \u2713 should handle passed sourcemaps (142ms)\nbabel-plugin-redux-saga:     \u2713 should build absolute path if useAbsolutePath option = true (12ms)\nbabel-plugin-redux-saga:   babel7\nbabel-plugin-redux-saga:     \u2713 attach source to declaration (97ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration (40ms)\nbabel-plugin-redux-saga:     \u2713 attach source to export declaration when processed with regenerator (451ms)\nbabel-plugin-redux-saga:     \u2713 should wrap yielded call expression (no name check) (32ms)\nbabel-plugin-redux-saga:     \u2713 should wrap method call (16ms)\nbabel-plugin-redux-saga:     \u2713 shouldn't wrap delegate (17ms)\nbabel-plugin-redux-saga:     \u2713 should handle nested structures (23ms)\nbabel-plugin-redux-saga:     \u2713 should handle function expression (22ms)\nbabel-plugin-redux-saga:     \u2713 should handle simplest expression (47ms)\nbabel-plugin-redux-saga:     \u2713 should handle expressions in object properties (21ms)\nbabel-plugin-redux-saga:     \u2713 should be compatible with es2015 preset regenerator (50ms)\nbabel-plugin-redux-saga:     \u2713 should be compatible with env preset regenerator (64ms)\nbabel-plugin-redux-saga:     \u2713 should handle passed sourcemaps (47ms)\nbabel-plugin-redux-saga:     \u2713 should build absolute path if useAbsolutePath option = true (16ms)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a attach source to export declaration when processed with regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/declaration-regenerator/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/declaration-regenerator/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a should be compatible with es2015 preset regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/regenerator/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/regenerator/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/regenerator/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\nbabel-plugin-redux-saga:   \u25cf babel6 \u203a should be compatible with env preset regenerator\nbabel-plugin-redux-saga:     expect(received).toBe(expected) // Object.is equality\nbabel-plugin-redux-saga:     Expected: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2, this);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Received: \"\\\"use strict\\\";\nbabel-plugin-redux-saga:     var _marked =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test1),\nbabel-plugin-redux-saga:         _marked2 =\nbabel-plugin-redux-saga:     /#PURE/\nbabel-plugin-redux-saga:     regeneratorRuntime.mark(test2);\nbabel-plugin-redux-saga:     function test1() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test1$(_context) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context.prev = _context.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context.next = 2;\nbabel-plugin-redux-saga:               return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:                 value: {\nbabel-plugin-redux-saga:                   fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:                   lineNumber: 2,\nbabel-plugin-redux-saga:                   code: \\\"foo(1, 2, 3)\\\"\nbabel-plugin-redux-saga:                 }\nbabel-plugin-redux-saga:               });\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 1,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\nbabel-plugin-redux-saga:     function test2() {\nbabel-plugin-redux-saga:       return regeneratorRuntime.wrap(function test2$(_context2) {\nbabel-plugin-redux-saga:         while (1) {\nbabel-plugin-redux-saga:           switch (_context2.prev = _context2.next) {\nbabel-plugin-redux-saga:             case 0:\nbabel-plugin-redux-saga:               _context2.next = 2;\nbabel-plugin-redux-saga:               return 2;\nbabel-plugin-redux-saga:             case 2:\nbabel-plugin-redux-saga:             case \\\"end\\\":\nbabel-plugin-redux-saga:               return _context2.stop();\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:         }\nbabel-plugin-redux-saga:       }, _marked2);\nbabel-plugin-redux-saga:     }\nbabel-plugin-redux-saga:     Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\nbabel-plugin-redux-saga:       value: {\nbabel-plugin-redux-saga:         fileName: \\\"test/fixtures/preset-env/source.js\\\",\nbabel-plugin-redux-saga:         lineNumber: 5,\nbabel-plugin-redux-saga:         code: null\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     })\"\nbabel-plugin-redux-saga:     Difference:\nbabel-plugin-redux-saga:     - Expected\nbabel-plugin-redux-saga:     + Received\nbabel-plugin-redux-saga:     @@ -24,11 +24,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked, this);\nbabel-plugin-redux-saga:     +   }, _marked);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/preset-env/source.js\",\nbabel-plugin-redux-saga:     @@ -48,11 +48,11 @@\nbabel-plugin-redux-saga:               case 2:\nbabel-plugin-redux-saga:               case \"end\":\nbabel-plugin-redux-saga:                 return _context2.stop();\nbabel-plugin-redux-saga:             }\nbabel-plugin-redux-saga:           }\nbabel-plugin-redux-saga:     -   }, _marked2, this);\nbabel-plugin-redux-saga:     +   }, _marked2);\nbabel-plugin-redux-saga:       }\nbabel-plugin-redux-saga:     \nbabel-plugin-redux-saga:       Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\nbabel-plugin-redux-saga:         value: {\nbabel-plugin-redux-saga:           fileName: \"test/fixtures/preset-env/source.js\",\nbabel-plugin-redux-saga:       130 |         if (fs.existsSync(expectedPath)) {\nbabel-plugin-redux-saga:       131 |           var expected = getExpected(expectedPath, sourcePath)\nbabel-plugin-redux-saga:     > 132 |           expect(actual).toBe(expected)\nbabel-plugin-redux-saga:           |                          ^\nbabel-plugin-redux-saga:       133 |         } else {\nbabel-plugin-redux-saga:       134 |           fs.writeFileSync(expectedPath, actual)\nbabel-plugin-redux-saga:       135 |         }\nbabel-plugin-redux-saga:       at Object.toBe (test/runner.test.js:132:26)\nbabel-plugin-redux-saga: Test Suites: 1 failed, 1 total\nbabel-plugin-redux-saga: Tests:       3 failed, 25 passed, 28 total\nbabel-plugin-redux-saga: Snapshots:   0 total\nbabel-plugin-redux-saga: Time:        8.607s\nbabel-plugin-redux-saga: Ran all test suites.\nbabel-plugin-redux-saga: npm ERR! code ELIFECYCLE\nbabel-plugin-redux-saga: npm ERR! errno 1\nbabel-plugin-redux-saga: npm ERR! babel-plugin-redux-saga@1.0.0 test: jest --env=node\nbabel-plugin-redux-saga: npm ERR! Exit status 1\nbabel-plugin-redux-saga: npm ERR! \nbabel-plugin-redux-saga: npm ERR! Failed at the babel-plugin-redux-saga@1.0.0 test script.\nbabel-plugin-redux-saga: npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\ncancellable-counter-example:     countdown 6\nbabel-plugin-redux-saga: npm ERR! A complete log of this run can be found in:\nbabel-plugin-redux-saga: npm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_14_757Z-debug.log\nlerna ERR! npm run test exited 1 in 'babel-plugin-redux-saga'\nlerna ERR! npm run test stdout:\nbabel-plugin-redux-saga@1.0.0 test /home/travis/build/redux-saga/redux-saga/packages/babel-plugin-redux-saga\njest --env=node\nlerna ERR! npm run test stderr:\nFAIL test/runner.test.js (8.215s)\n  babel6\n    \u2713 attach source to declaration (621ms)\n    \u2713 attach source to export declaration (25ms)\n    \u2715 attach source to export declaration when processed with regenerator (615ms)\n    \u2713 should wrap yielded call expression (no name check) (9ms)\n    \u2713 should wrap method call (7ms)\n    \u2713 shouldn't wrap delegate (16ms)\n    \u2713 should handle nested structures (28ms)\n    \u2713 should handle function expression (36ms)\n    \u2713 should handle simplest expression (13ms)\n    \u2713 should handle expressions in object properties (7ms)\n    \u2715 should be compatible with es2015 preset regenerator (137ms)\n    \u2715 should be compatible with env preset regenerator (41ms)\n    \u2713 should handle passed sourcemaps (142ms)\n    \u2713 should build absolute path if useAbsolutePath option = true (12ms)\n  babel7\n    \u2713 attach source to declaration (97ms)\n    \u2713 attach source to export declaration (40ms)\n    \u2713 attach source to export declaration when processed with regenerator (451ms)\n    \u2713 should wrap yielded call expression (no name check) (32ms)\n    \u2713 should wrap method call (16ms)\n    \u2713 shouldn't wrap delegate (17ms)\n    \u2713 should handle nested structures (23ms)\n    \u2713 should handle function expression (22ms)\n    \u2713 should handle simplest expression (47ms)\n    \u2713 should handle expressions in object properties (21ms)\n    \u2713 should be compatible with es2015 preset regenerator (50ms)\n    \u2713 should be compatible with env preset regenerator (64ms)\n    \u2713 should handle passed sourcemaps (47ms)\n    \u2713 should build absolute path if useAbsolutePath option = true (16ms)\n  \u25cf babel6 \u203a attach source to export declaration when processed with regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE*/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/declaration-regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/declaration-regenerator/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/declaration-regenerator/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\n\u25cf babel6 \u203a should be compatible with es2015 preset regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/regenerator/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/regenerator/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/regenerator/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/regenerator/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\n\u25cf babel6 \u203a should be compatible with env preset regenerator\n    expect(received).toBe(expected) // Object.is equality\n    Expected: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/preset-env/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2, this);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Received: \"\\\"use strict\\\";\n    var _marked =\n    /#PURE/\n    regeneratorRuntime.mark(test1),\n        _marked2 =\n    /#PURE/\n    regeneratorRuntime.mark(test2);\n    function test1() {\n      return regeneratorRuntime.wrap(function test1$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Object.defineProperty(foo(1, 2, 3), \\\"@@redux-saga/LOCATION\\\", {\n                value: {\n                  fileName: \\\"test/fixtures/preset-env/source.js\\\",\n                  lineNumber: 2,\n                  code: \\\"foo(1, 2, 3)\\\"\n                }\n              });\n            case 2:\n            case \\\"end\\\":\n              return _context.stop();\n          }\n        }\n      }, _marked);\n    }\n    Object.defineProperty(test1, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 1,\n        code: null\n      }\n    })\n    function test2() {\n      return regeneratorRuntime.wrap(function test2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return 2;\n            case 2:\n            case \\\"end\\\":\n              return _context2.stop();\n          }\n        }\n      }, _marked2);\n    }\n    Object.defineProperty(test2, \\\"@@redux-saga/LOCATION\\\", {\n      value: {\n        fileName: \\\"test/fixtures/preset-env/source.js\\\",\n        lineNumber: 5,\n        code: null\n      }\n    })\"\n    Difference:\n    - Expected\n    + Received\n    @@ -24,11 +24,11 @@\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n    -   }, _marked, this);\n    +   }, _marked);\n      }\n  Object.defineProperty(test1, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/preset-env/source.js\",\n@@ -48,11 +48,11 @@\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n-   }, _marked2, this);\n+   }, _marked2);\n  }\n\n  Object.defineProperty(test2, \"@@redux-saga/LOCATION\", {\n    value: {\n      fileName: \"test/fixtures/preset-env/source.js\",\n  130 |         if (fs.existsSync(expectedPath)) {\n  131 |           var expected = getExpected(expectedPath, sourcePath)\n> 132 |           expect(actual).toBe(expected)\n      |                          ^\n  133 |         } else {\n  134 |           fs.writeFileSync(expectedPath, actual)\n  135 |         }\n  at Object.toBe (test/runner.test.js:132:26)\n\nTest Suites: 1 failed, 1 total\nTests:       3 failed, 25 passed, 28 total\nSnapshots:   0 total\nTime:        8.607s\nRan all test suites.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! babel-plugin-redux-saga@1.0.0 test: jest --env=node\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the babel-plugin-redux-saga@1.0.0 test script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_14_757Z-debug.log\nlerna ERR! npm run test exited 1 in 'babel-plugin-redux-saga'\nlerna WARN complete Waiting for 3 child processes to exit. CTRL-C to exit immediately.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ test-only: lerna run --parallel test\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ test-only script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_14_813Z-debug.log\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ test: npm run test-only\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ test script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_14_862Z-debug.log\nERROR: \"test\" exited with 1.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ check: run-s lint test\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ check script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_14_889Z-debug.log\nThe command \"npm run check\" exited with 1.\nafter_script\n3.18s$ npm run bundlesize\n\n@ bundlesize /home/travis/build/redux-saga/redux-saga\nlerna run --parallel bundlesize\nlerna notice cli v3.13.0\nlerna info ci enabled\nlerna info Executing command in 2 packages: \"npm run bundlesize\"\n@redux-saga/core: > @redux-saga/core@1.0.1 prebundlesize /home/travis/build/redux-saga/redux-saga/packages/core\n@redux-saga/core: > npm run build\nredux-saga: > redux-saga@1.0.1 bundlesize /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nredux-saga: > bundlesize\nredux-saga:  ERROR  There is no matching file for ./dist/redux-saga.min.umd.js \nredux-saga: npm ERR! code ELIFECYCLE\nredux-saga: npm ERR! errno 1\nredux-saga: npm ERR! redux-saga@1.0.1 bundlesize: bundlesize\nredux-saga: npm ERR! Exit status 1\nredux-saga: npm ERR! \nredux-saga: npm ERR! Failed at the redux-saga@1.0.1 bundlesize script.\nredux-saga: npm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nredux-saga: npm ERR! A complete log of this run can be found in:\nredux-saga: npm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_18_046Z-debug.log\nlerna ERR! npm run bundlesize exited 1 in 'redux-saga'\nlerna ERR! npm run bundlesize stdout:\nredux-saga@1.0.1 bundlesize /home/travis/build/redux-saga/redux-saga/packages/redux-saga\nbundlesize\n ERROR  There is no matching file for ./dist/redux-saga.min.umd.js \nlerna ERR! npm run bundlesize stderr:\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! redux-saga@1.0.1 bundlesize: bundlesize\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the redux-saga@1.0.1 bundlesize script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_18_046Z-debug.log\nlerna ERR! npm run bundlesize exited 1 in 'redux-saga'\nlerna WARN complete Waiting for 1 child process to exit. CTRL-C to exit immediately.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ bundlesize: lerna run --parallel bundlesize\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ bundlesize script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-02-21T21_08_18_096Z-debug.log\nDone. Your build exited with 1.. All logs exit with error exit status 1.. I edited .travis.yml and added node 7 as part of the tests, maybe I shouldn't have done that.... Because it exited with 1 in a early process.. Node 7 exits because redux-saga/deferred gives a syntax error.. And for some reason the logs use babel 6, which is a major cause of the failures.. Oops I accidentally changed the travis file again.. Finally all checks have succeeded!. Make that a breaking change.. I am unable to get logs. All I know is that it exits with all errors.. The issue is with npm.. I will edit npm later.. I merged a pull request so now I am adding 2 more commits into my very active pull request. Reopen if you feel that this is not that big of a deal.. Whoops I accidently opened this. Closing and deleting.. Babel@6 is a BIG problem during the tests, it should only use babel 7.. Well, you could edit the travis file.. I have tried that and it works.. We can probably edit the file.... I edited the travis file back the way it was.\nPutting back \nscript:\n  - npm run check\n\nafter_script:\n- npm run bundlesize. It's supposed to improve npm and update dependencies. It is very benefitial.. Eslint exits with exit status 2.. Full log of run for ESLint:\nOops! Something went wrong! :(\nESLint: 5.15.1.\nNo files matching the pattern \"packages/*/{src,test}\" were found.\nPlease check for typing mistakes in the pattern.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 2\nnpm ERR! @ lint: eslint packages/*/{src,test}\nnpm ERR! Exit status 2\nnpm ERR! \nnpm ERR! Failed at the @ lint script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-03-14T21_18_43_648Z-debug.log\nERROR: \"lint\" exited with 2.\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! @ check: run-s lint test\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @ check script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2019-03-14T21_18_43_668Z-debug.log. ",
    "Puspendert": "My advice is to look into your handlerSaga and watcherSaga methods. This freeze occurs when you have handler and watcher calling each other which causes infinite loop and browser gets hang. Put log statements and check behaviour.. ",
    "therealparmesh": "Is there any interest in this issue or the PR it references?. ",
    "shizpi": "I solved this issue by dispatching the END action from the saga itself, instead of dispatching it from my server file that handles the SSR logic.\nI just check if the saga is running in the server and END it. I will have to create a main saga for each view to do the same, but at least I get the correct state from the server.\nIf someone has some better suggestion I'd appreciate it\n```\nfunction* getWholeView() {\n  while (true) {\n    yield take([HOMEPAGE_GET]);\n    const { success } = yield race({\n      // Wait for both requests to be successful\n      success: all([\n        take(HOMEPAGE_LATEST_ARTICLES_GET_SUCCESS),\n      ]),\n      // Wait for one of the requests to fail\n      failure: take([\n        HOMEPAGE_LATEST_ARTICLES_GET_FAILURE,\n      ]),\n    });\n    if (success) {\n      yield put({ type: HOMEPAGE_GET_SUCCESS });\n    } else {\n      yield put({ type: HOMEPAGE_GET_FAILURE });\n    }\nif (isNode) {\n  yield put(END);\n}\n\n}\n}\n```. ",
    "Dai7Igarashi": "@aikoven \nThank you for reviewing my PR.\nI just changed ValidEffect to Effect. . ",
    "tobloef": "My problem is actually very similar to yours, I just simplified for the question.. ",
    "ameer157": "The problem was my lack of understanding of ES6 generator functions and how they work. The problem was my lack of understanding of ES6 generator functions and how they work. ",
    "idandagan1": "Thanks @GabrielFerrarini but this is only an example (there is no variable declaration issue in the real code).\nIn addition, I've also tried using a call effect. \nbut getting the same result.. @Andarist can you provide with an example for usage of putResolve?. ",
    "rclmenezes": "After reading this pull request, I see that this is by design:\nhttps://github.com/redux-saga/redux-saga/pull/735\nGiven that I'm expecting setContext to be a global singleton here, I can just replace it with state:\nyield select(getApi);\nAnd allow the reducers to set the state.. ",
    "jndietz": "Yep.  i\u2019m an idiot.  That\u2019s what coding all day without an break gets me.. ",
    "origamium": "oops did not notice.... ",
    "stropho": "Thx. Without args[0], the warning still notifies how to (not) call delay effect. So it is totally fine by me.. Thx. Without args[0], the warning still notifies how to (not) call delay effect. So it is totally fine by me.. ",
    "ivan-badmaev": "Got the snippet working, should not emit end in the eventChannel.. ",
    "jasonhendry": "I've used the race pattern in the Sagas documentation to good effect.\nYou should be able to adapt that to your example.. ",
    "eyale": "Thank you @shinima and @jasonhendry both variants are working properly, now the problem with rn-fetch-blob.. ",
    "brayanL": "I followed the suggestion of webstorm, and install @redux-saga/testing-utils and right now i can use cloneableGenerator\nBefore install @redux-saga/testing-utils\n \nAfter install @redux-saga/testing-utils\n\nWhy I had to install that dependency and it's not in the documentation :(. ",
    "MaxBolotnyi": "\nwould you mind to add a repository with the issue? I had a hard time bootstrapping React Native project from scratches.\n\n@restrry, sure, will do and provide you with the link.\n. @Andarist \nYou're correct, sorry, it's just a typo. The actual code follows the correct pattern.. @Andarist We don't use redux-saga-monitor, however, we use 'reactotron' instead, could that be the issue? . @Andarist \nYou are absolutely correct!! Thank you!\nWill further investigate in this direction.. ",
    "NikhilDevop": "@shinima can I use call (callAPI, action.metadata.client, moveReq) where \"call\" is a redux-saga effect? If yes, there would not be change in anything right?. but in answer to   https://stackoverflow.com/questions/54193476/how-to-use-yield-inside-map-for-react-native says to wrap the map into [ ] that's what I am confused whether to use it or not .. @shinima as you suggested the code using call \nyield all(\n  ItemMoveRequests.map(moveReq =>\n    call(callAPI, action.metadata.client, moveReq)\n  )\n)\nin this how ( and where)  the errors can be handled( if any)  as even if one request fails remaining items will be able to make API request also does using fork() instead of call() make more sense?  . And I want to handle all the errors at a time i.e., after all API calls are done. Thanks for all your answers \ud83d\ude0a. Thanks for your answer @Andarist ...but what i was asking is if I can also use fork() in place of call in the following code : \nyield all(\n  ItemMoveRequests.map(moveReq =>\n    call(callAPI, action.metadata.client, moveReq)  // --> fork(callAPI, action.metadata.client, moveReq)\n  )\n)\nThe reason I am asking :  as call() is a blocking effect and if one item of the array calls the API then that call blocks the other items in the array to further call the API and I don't want that to happen. That's the reason I asked if fork() can be used instead of call().. ",
    "GitHubGreg": "Problem solved, I\u2019d simply forgotten the return af the start of my loginUserSocialAsync function. . ",
    "vasilii-kovalev": "@shinima\n1. If you just log component.props() or component.instance().props, you can't see any props you are expecting, so, it's not related to jest snapshots as far as I can see.\n2. Hmm, are there any differences between locally installed project via CRA or installed one on Codesandbox? Webpack (embedded in CRA) in both cases is the same, isn't it?. ",
    "twiggler": "No problem.\nShould I create a pull request for fixing the mistake in the docs, or are you going to remove it?\n. ",
    "gustavopch": "@Andarist Exactly, retry is basically a wrapper for call. As call already supports this, it's just a matter of updating the typings, the docs and this particular line: https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/sagaHelpers/retry.js#L27. > @gustavopch would you be interested in working on this and providing a PR?\nYes. I'm a bit busy with some work but I'll do it as soon as possible.. ",
    "mchyb": "IMO there is no need for extending an already complex API. ;) You can achieve the desired functionality using actionChannel with a buffer  and blocking call effect. If you don't need messages buffering use takeLeading effect. I hope I understood you correctly.\n```js\nconst saga = function*() {\n  const channel = yield actionChannel(\n    ['action1', 'action2'],\n    buffers.sliding(1)\n  );\nwhile (true) {\n    const action = yield take(channel);\nyield call(actionHandler, action);\n\n}\n};\n```\n. ",
    "gillpeacegood": "Sorry I think I was misunderstanding how it works. ",
    "Wenqer": "return [REQUEST, SUCCESS, FAILURE].reduce((acc, type) => \n  Object.assign(acc, {[type]: `${base}_${type}`}), {})\n. ",
    "secretfader": "@wenqer Object.assign is useful, but mostly for merging objects. Not so much here. \n. ",
    "ianmetcalf": "got deprecated -> is deprecated. I had just noticed this was inconsistent with the put.sync deprecation warning above\njs\nput.sync = deprecate(put.resolve, 'put.sync is deprecated in favor of put.resolve, please update your code')\n. ",
    "JisuPark": "Thanks. I've changed it.. ",
    "clbn": "I think, as a reader, I would expect it to be the link to unpkg service, especially when links to the specific builds are available below. But I don't know if it really was the intention of the sentence's original author. :). ",
    "stoeffel": "I'm not really maintaining redux-saga-test anymore. @aaronjensen is maintaining it mostly. Maybe this org is interested in taking it over? I'm also happy to just refer people to redux-saga-test-plan.. ",
    "micha149": "You could also mention https://www.npmjs.com/package/redux-saga-tester. ",
    "ziel5122": "\ud83d\ude05 of course. ",
    "garethbradley": "I'm no expert - I'd have to try it. I'm guessing the syntax would look like:\nimport { findKey } from 'lodash/object';. There we go - that should be sorted.\nCheers. ",
    "stianjensen": "Where does the name Parameters come from? I'm getting errors in my code saying Cannot find name 'Parameters'. when I try to compile with typescript.. Seems like the issue might have been that I was using typescript 3.0.0.\nWill typescript 3.2.0 be a requirement for redux-saga 1.x?. I don't know, but the error messages went away when I upgraded \u00af\\(\u30c4)/\u00af. ",
    "mike1808": "Ah, didn't think about that. I'll change.. ",
    "yethee": "You can improve translation:\nsuggestion\n\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0435 testing-utils, \u0447\u0442\u043e\u0431\u044b \u0431\u044b\u043b\u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b \u0432\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0442\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f:\nThis version of text is more familiar with Russian language.. ",
    "taksuparth": "So, should I keep it in testing readme only?. "
}