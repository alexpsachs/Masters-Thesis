{
    "sustrik": "Please, can you state that your patch is submitted under MIT/X11 license? Unfortunately, due to the non-restrictive nature of MIT license, it doesn't propagate to the patches automatically, like GPL does. I'll also need your email address to add you to the AUTHORS list.\n. Merged, thanks!\n. Interesting. I've checked code and it seems the family, address and port should be filled in. Nothing else remains in sockaddr_in (except of maybe padding). Do you happen to know what error corresponds to \"Can't assign requested address\" on OSX?\n. OK. Looks like some OSX-specific stuff. I am working on TCP right now, so let me merge the chages and then let's try to add the memset() call.\n. As for placement of memset, I guess it should be in tcpb, given that address parsing functions are used to modify just parts of the sockaddr_in structure.\n. Wait a sec. I'll merge changes to the threading model I've done in past three days. Then we'll re-check.\n. OK. Done. Can you try again?\n. Fails=blocks, right?\n. Ah, it's OK. I am still working on TCP transport, so it just hangs at the moment. Same behaviour on Linux.\n. On Linux & Windows it exchanges the messages, then asserts in the shutdown phase. The problem on OSX may or may not be related. I would wait till shutdown mechanism works on Linux/Win, then re-try on OSX (I'll ping you then.)\n. What were the warnings about sp_err_abort() function? Why I am asking is that almost all functions can possibly not return due to asserts inside of them.\n. OK. I see. IIRC there are couple of places with \"sp_assert (0); return 0;\" to get rid of this kind of warnings. I will be able to remove that after applying this patch. Cute.\n. Goodo. Let me merge it.\nBtw, if you want to help with the project, one thing that would be useful is kqueue-based poller for BSD systems (including OSX). If you are interested, the best way to do it would be to copy the epoll-based code in poller.h/.c and modify it to use kqueue instead.\n. Ah. I've forgot to close it myself. Thanks!\n. Ah, yes, that would be useful. Put the implementation into src/core/ctx.c All public functions are there so far, so sp_version may go there as well.\n. OK. The patch is merged. Thanks!\n. Applied to the trunk. Thanks!\n. This seems to be related to new kqueue poller. There's a FreeBSD box here where I should be able to reproduce the problem but the connection to it seems to be down at the moment. I'll let you know about the progress once it's back online.\n. Ok. Tested on FreeBSD. Problem reproduced. Thanks for reporting it!\n. Fixed in 187ec33.\n. Applied.\n. Applied.\n. Julien, while email with the patch + statement that it's submitted under MIT license is the most legally waterproof option, I am OK with pull requests. Still, you have to note that the patch is MIT licensed somewhere, otherwise I can't merge it without compromising the license.\n. As for the patch, note that clock set up for condition variable using pthread_condattr_setclock must correspond to the clock that you use to set the timeout to pthrea_cond_timedwait. AFAICS in this patch the clock used by condition variable is the default one (CLOCK_REALTIME according to POSIX) while one used for setting the timeout is CALENDAR_CLOCK. Are these two equivalent?\n. @schmurfy I would definitely prefer to get the patch by email. However, I don't want to enforce it -- github with the PRs have made people too lazy to send standard patches. It's convenience traded off for legal headache, but that's the way the world is today :(\n. As for the patch, given that pthrad_cond_timedwait itself uses gettimeofday internally, there seems to be little advantage in using anything else on nanomsg level (you can't improve precision or performance or make the code resistant to system clock adjustments).\n. Yes, I understand the reasons. That's why I want to allow using PRs for the project. The problematic part is how to make it legally safe. I would say there are two options:\n1. State that patch is submitted under MIT in  GH comment attached to the PR. This may become a problem if GH goes out of business, but so be it.\n2. Send me (sustrik@250bpm.com) an email stating that any subsequent patches to the project are submitted under MIT license.\n. Bruce's patch looks pretty minimal (8 lines). I would go for that one. Julien, any are there possible problems you can see?\nOne thing I would change though is the feature test. The patch should apply only if SP_HAVE_OSX is defined. The behaviour (cond var compatible with gettimeofday) is specific to OSX and may not apply on other platforms that lack CLOCK_MONOTONIC.\n. PR #12 applied. Closing this one.\n. Applied to the master.\n. genconf doesn't exist anymore. Closing the issue.\n. Thanks for noting the breakage. Given that the asciidoc text rendered OK yesterday, I suppose it's a bug introduced by GitHub. I've submitted a bug report to GH. Let's wait for their reply.\n. No reply from GH yet. Applying the patch. Thanks!\n. Yes. I've already sent them second bug report :)\n. Applied to master. Thanks!\n. Yes, the whole Windows port is a bit creaky. I will work on it more shortly.\n. Nope. Windows version is now broken. Will have to look at it tomorrow.\n. Ok. Yet new code committed. Can you re-test?\n. No reply for 25 days. I am assuming that the problem is fixed and closing the ticket.\n. It's quire slow. Is that TCP loopback on Windows?\n. Applied. Thanks!\n. Hey, that's nice! I was wondering how to do that myself :)\nIt would be great if we can gradually evolve it toward the state where single \"make latency_analysis\" would build the library with monitoring turned on, the run the test and finally run the R script to product the png picture with the graph.\n. Ah, btw, you have to state that the patch was submitted under MIT license, otherwise I can't merge it.\n. Applied. Thanks!\n. Applied to master. Thanks!\n. Thanks for the report. Can you paste the output from the test (just run ./inproc in build directory and paste the output to the console)?\n. Hm. Doesn't seem to reproduce here. Can you get me the backtrace from the error? (Run under debugger, when it fails, print out the backtrace. Alternatively, generate the core dump, then load it to the debugger and print out the backtrace.)\n. Thanks! I'll check it out shortly.\n. Fixed in the trunk. Can you re-check and confirm the problem doesn't happen anymore?\n. This may be related to issue 20. Can you re-check whether is still happens with the latest trunk?\n. OK. The problem doesn't reproduce on my box. What would help is the backtrace from the point of failure.\n. Interesting. This looks like OSX doesn't accept SO_SNDBUF option on UNIX domain socket. Is that so?\n. Yes, strange, but the stack trace is pretty clear. This assert blows up:\nrc = setsockopt (self->s, SOL_SOCKET, SO_SNDBUF,\n        &sndbuf, sizeof (sndbuf));\n    errno_assert (rc == 0);\nErrno is EINVAL at this point. No idea what's going on. Maybe a bug in OSX?\n. One idea: maybe the value of sndbuf variable gets overwritten somewhere and setsockopt() fails because it's either too large or negative. Can you check the value of sndbuf when the assert happens?\n. Nonsense. The value is visible in the backtrace: 131072. That should be a valid value.\n. OK. There's a slight problem with OSX error reporting. The docs specify that:\n[EINVAL] The option is invalid at the level indicated.\nWhich is obviously not true. Anyway, not a big problem.\nThe segmentation fault looks more useful for debugging. I am looking into it.\n. Similar bug reproduced on Linux:\n(gdb) bt\n0  0x00007fd8179ead05 in raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n1  0x00007fd8179eeab6 in abort () at abort.c:92\n2  0x0000000000400dcd in nn_err_abort () at /home/sustrik/nanomsg/tests/../src/utils/err.c:33\n3  0x00007fd818181bf5 in nn_usock_recv_raw (self=0x1be3598, buf=0x1be36d8, len=0x7fd8171b4c60) at /home/sustrik/nanomsg/src/utils/aio_posix.inc:849\n4  0x00007fd818181503 in nn_usock_recv (self=0x1be3598, buf=0x1be36d8, len=8) at /home/sustrik/nanomsg/src/utils/aio_posix.inc:730\n5  0x00007fd818186649 in nn_stream_init (self=0x1be36a8, epbase=0x1be0868, usock=0x1be3598) at /home/sustrik/nanomsg/src/utils/stream.c:130\n6  0x00007fd818181f49 in nn_astream_init (self=0x1be3590, epbase=0x1be0868, s=8, usock=0x1be0918, bstream=0x1be0860) at /home/sustrik/nanomsg/src/utils/astream.c:74\n7  0x00007fd8181821a2 in nn_bstream_listening_accepted (self=0x1be0860, usock=0x1be0918, s=8) at /home/sustrik/nanomsg/src/utils/bstream.c:97\n8  0x00007fd818180733 in nn_cp_worker (arg=0x1be0430) at /home/sustrik/nanomsg/src/utils/aio_posix.inc:481\n9  0x0000000000400fda in nn_thread_main_routine (arg=0x1be0660) at /home/sustrik/nanomsg/tests/../src/utils/thread.c:84\n10 0x00007fd817d51d8c in start_thread (arg=0x7fd8171b5700) at pthread_create.c:304\n11 0x00007fd817a9d04d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:112\n12 0x0000000000000000 in ?? ()\n. And here's the real culprit. Socket is closed while being initialised:\n3  0x00007fe844e8b07b in nn_astream_terminating_closed (self=0x21d6200, usock=0x21d6208) at /home/sustrik/nanomsg/src/utils/astream.c:132\n4  0x00007fe844e88de5 in nn_usock_term (self=0x21d6208) at /home/sustrik/nanomsg/src/utils/aio_posix.inc:285\n5  0x00007fe844e89b7e in nn_usock_close (self=0x21d6208) at /home/sustrik/nanomsg/src/utils/aio_posix.inc:559\n6  0x00007fe844e8afa0 in nn_astream_connected_err (self=0x21d6200, usock=0x21d6208, errnum=104) at /home/sustrik/nanomsg/src/utils/astream.c:90\n7  0x00007fe844e8fb76 in nn_stream_err (self=0x21d6318, usock=0x21d6208, errnum=104) at /home/sustrik/nanomsg/src/utils/stream.c:274\n8  0x00007fe844e8a3f7 in nn_usock_send (self=0x21d6208, iov=0x7fe843ebdcb0, iovcnt=1) at /home/sustrik/nanomsg/src/utils/aio_posix.inc:703\n9  0x00007fe844e8f699 in nn_stream_init (self=0x21d6318, epbase=0x21d3868, usock=0x21d6208) at /home/sustrik/nanomsg/src/utils/stream.c:127\n10 0x00007fe844e8af57 in nn_astream_init (self=0x21d6200, epbase=0x21d3868, s=11, usock=0x21d3918, bstream=0x21d3860) at /home/sustrik/nanomsg/src/utils/astream.c:76\n11 0x00007fe844e8b20e in nn_bstream_listening_accepted (self=0x21d3860, usock=0x21d3918, s=11) at /home/sustrik/nanomsg/src/utils/bstream.c:97\n12 0x00007fe844e89733 in nn_cp_worker (arg=0x21d3430) at /home/sustrik/nanomsg/src/utils/aio_posix.inc:481\n13 0x0000000000400fda in nn_thread_main_routine (arg=0x21d3660) at /home/sustrik/nanomsg/tests/../src/utils/thread.c:84\n14 0x00007fe844a5ad8c in start_thread (arg=0x7fe843ebe700) at pthread_create.c:304\n15 0x00007fe8447a604d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:112\n16 0x0000000000000000 in ?? ()\n. Yes. It's a timing issue. It happens when creation of the socket collides with its destruction.\n. Should be fixed in the trunk. Re-checking on OSX is required.\n. :)\n. This may be related to issue 20. Can you re-check whether is still happens with the latest trunk?\n. This may be related to issue 20. Can you re-check whether is still happens with the latest trunk?\n. Tested on a 8 core box in a tight loop. Deadlock doesn't happen. (There are other errors though.) I belive this issue can be closed.\n. Fixed.\n. Applied to master. Thanks!\n. Thanks for reporting this. The problem should be solved in the latest trunk now. I've also added testing for invalid address strings into \"tcp\" test.\n. OK. This should be fixed by patch for #25, however, I've added this case into \"tcp\" test.\n. Fixed along with #25. Testing for this case added to \"tcp\" test.\n. nn_connect() should behave this way. It considers the string to be a hostname and tries to resolve it via DNS in periodic intervals. I assume the intent here was to use nn_bind(), that case seems to return ENODEV as expected. I've added the test case to \"tcp\" test anyway.\n. Thanks for the report! I'm travelling at the moment. I'll have a look at it tomorrow.\n. This looks like the latency test that's already available (perf/local_lat, perf/remote lat, except that both components live in the same process. Also, reqrep.c test does basically the same thing. Maybe extending reqrep.c to use ipc/tcp in addition to inproc would help to reproduct the problem.\n. Hm. Seems to work well on Linux:\nsustrik@turist ~/nanomsg/build $ ./ipc\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nsustrik@turist ~/nanomsg/build $\nIs it that the issue happens only on OSX or am I missing something?\n. Ah, got you. Confirmed. Problem reproduced.\n. Ok. I think the problem is fixed in the latest trunk. Can you re-check?\n. Great. I've added a code similar to #29 to reqrep test, so, hopefully, it is fixed now.\n. This is caused by the tests doing stress testing and OSX allowing by default only for 256 open file descriptors. Try increasing the file descriptor limit.\nThat being said, the library should handle ENFILE/EMFILE errors without asserting (by forwatrding the error to the user).\n. I've improved the error handling in this case to print out the actual error. Can you try with latest trunk and let me know what error it reports?\n. This looks like a problem caused by the synchronisation issue described in issue #21. The solution is a bit tricky, so I'll need a full un-interrupted day to fix it. Hopefully later on this week.\n. Hm. I don't have an OSX box to test on. The deadlock looks like some kind of race condition. The assert on line 323 is a new one AFAICS. Can you check what is the backtrace is when it happens? (Building with \"cmake -DCMAKE_BUILD_TYPE=Debug ..\" will attach debug into to the backtrace and make it more useful.)\n. I've managed to get this error:\nAssertion failed: self->first == NULL (/home/sustrik/nanomsg/src/utils/list.c:36)\nThanks!\n. This assertion:\nAssertion failed: self->first == NULL (/home/sustrik/nanomsg/src/utils/list.c:36)\nshould be fixed in the trunk. If you still have a test case that causes it, re-check it, please.\n. Great!\nGood news: EBADFD problem reproduced on my box. I'm giving it a look.\n. The related code have been completely re-written. Can you give your test another try and report whether the issue is fixed?\n. Reproduced. Thanks!\n. Minimal test case to reproduce sock.c:833 issue:\n```\ninclude \ninclude \ninclude \nint main ()\n{\n    int rc;\n    int s;\n    int eid;\ns = nn_socket (AF_SP, NN_PAIR);\nassert (s != -1);\neid = nn_bind (s, \"inproc://a\");\nassert (eid >= 0);\nrc = nn_shutdown (s, eid);\nassert (rc == 0);\nrc = nn_close (s);\nassert (rc == 0);\n\nreturn 0;\n\n}\n```\n. I've added almost exactly the same code yesterday when solving a different issue. Can we consider this issue solved then?\nBtw, when sending a patch, please always state that you are submitting it under MIT license so that I can merge it straight away.\n. Reproduced. Thanks!\n. Minimal test case (can be run without the server):\n```\ninclude \ninclude \ninclude \"nn.h\"\ninclude \"reqrep.h\"\ninclude \"ipc.h\"\nint main ()\n{\n    int req = nn_socket(AF_SP, NN_REQ);\n    assert(req != -1);\n    int eid = nn_connect(req, \"ipc://test.ipc\");\n    assert(eid >= 0);\n    int rc = nn_shutdown(req, eid);\n    assert(rc == 0);\n    rc = nn_close(req);\n    assert(rc == 0);\n}\n```\n. Can you please re-try with the latest trunk and close the issue, if fixed?\n. Reproduced.\n. Note to myself: This problem is caused by trasferring usock to DONE state synchronously in case of error, while there may be asynchronous tasks sent to the worker thread (task_recv in this case) on the fly.\n. Let's do it in a different way: If the fd limit is reached, the library should report EMFILE error rather than assert. The test should handle EMFILE decently (stop creating new sockets).\n. Using setrlimit() in the test code makes sense. Do you want to implement that? If so, please, check for the availability of the function in the configuration step, so that it doesn't break compilation on, say, Windows.\n. The problem should be fixed now. The library should handle ENFILE/EMFILE situations decently, by re-trying later on, rather than asserting.\nTested on OSX.\nPlease, close the issue if you consider it fixed.\n. No response for a month. I'm considering the issue fixed. Feel free to re-open in case of need.\n. Applied to master. Thanks!\n. Ok. First patch (sub.c) applied to master. Other one (rep.c) requires a slightly different fix. I'll fit it shortly. Thanks for noticing it!\n. Still fails. Different kinds of errors:\nAssertion failed: !nn_list_item_isinlist (item) (/home/sustrik/nanomsg/src/utils/list.c:74)\nBad file descriptor 9\nAssertion failed: !nn_list_item_isinlist (self) (/home/sustrik/nanomsg/src/utils/list.c:120)\n. The problem should be solved now. May you re-test with the latest trunk?\n. The issue should be fixed (along with couple of other trie-related bugs) in the trunk. Please, re-check whether it works like expected.\nBtw, if you have a specific test that used to fail, it can be added to trie unit tests (tests/trie.c).\n. Fixed.\n. Oh my. That's silly. Would you like to fix that?\n. Fixed. Closing the issue.\n. Fixed in 0b4476f.\n. The problem should be solved now. May you re-test with the latest trunk?\n. No reply in several months. I assume the issue is solved and I am closing it. Feel free to re-open in case of need.\n. Applied to the trunk. Thanks!\n. Hi Evan,\nCan you state that the patch is submitted under MIT license?\nMartin\nOn 2013-03-15 07:07, Evan wrote:\n\nPer discussions on the mailing list and IRC, this pull request adds\nthe nn_symbol API call.  It also removes nn_version in another\nchangeset.\nDocumentation and unit tests are included.\nYou can merge this Pull Request by running:\ngit pull https://github.com/neomantra/nanomsg symbol\nOr you can view, comment on it, or merge it online at:\nhttps://github.com/250bpm/nanomsg/pull/42\n-- Commit Summary --\n- Add nn_symbol to core API\n- Remove the nn_version function\n-- File Changes --\nM doc/CMakeLists.txt (2)\nM doc/nanomsg.7.txt (4)\nM doc/nn_strerror.3.txt (1)\nA doc/nn_symbol.3.txt (62)\nD doc/nn_version.3.txt (49)\nM src/CMakeLists.txt (1)\nM src/core/ctx.c (10)\nA src/core/symbol.c (141)\nM src/nn.h (8)\nM tests/CMakeLists.txt (1)\nA tests/symbol.c (48)\n-- Patch Links --\nhttps://github.com/250bpm/nanomsg/pull/42.patch\nhttps://github.com/250bpm/nanomsg/pull/42.diff\n. @nirs: The goal of this function to be used from the language bindings (different FFI systems). It's unlikely to be used by the end user. That being said, elegance is not the primary goal, rather keeping the prototype as simple as possible so that different FFI mechanism (some unknown to us, some maybe not yet implemented) won't experience problems with it. Current proposal has following properties:\n1. It doesn't use structures.\n2. It doesn't use arrays.\n3. It doesn't use string output parameters (const char **)\n. The question is whether NN_MSG should be even exported. It's used for manipulation of raw memory buffers, which most languages don't support anyway. And even if they do, it's likely that the binding will provide functionality via some hand-written wrapper.\n. That sounds reasonable. I'll merge you patch shortly. (I was a bit sick today, so I've slept throughput the day.)\n. Merged into the mainline. Thanks!\n. Applied to the master! I've also added you to the AUTHORS file.\n\nThanks!\n. Applied to the trunk. Thanks!\n. Actually, the library version libnanomsg.so.x.y.z is an semantic ABI/interface version and is not the same as release number.\nDetailed description can be found here:\nhttp://www.nondot.org/sabre/Mirrored/libtool-2.1a/libtool_6.html\nWhat it means is we need to define separate ABI version somewhere (nn.h?) and genrate library filename based on that.\n. Quite a useful thread discussing the so versioning:\nhttp://mail.kde.org/pipermail/kde-buildsystem/2008-April/004543.html\nAnd of course:\nhttp://people.redhat.com/drepper/dsohowto.pdf\nAnyway, let's do it in the following way: I'll apply this patch. Then I'll create a new issue for getting the ABI versioning right.\n. Applied to the master. I've also added you to the AUTHORS file. Thanks!\n. Yes. I would say so.\n. Done. Closing the ticket.\n. Applied to master. Thanks!\n. Merged to the master. Thanks!\n. Yes. There's a race condition in the implementation of nn_shutdown. I'll have a look at this.\n. The issue should be fixed now. Can you confirm?\n. As for the original error, it should not happen any more.\nAs for the \"Address already in use\" problem, I've created a new issue (#119) for it.\nIf you can't reproduce the original problem, please close this issue.\n. Hi Joshua, thanks for  the patch!\n. Committed to the mainline. New man pages uploaded to the website. I've added you to the AUTHORS file as well.\nThanks!\n. I am on Mint (Ubuntu derivative) and it works. Can you check whether there's symbol 'sem_wait' defined in ?\n. Applied. Thanks!\n. Applied to the master. Thanks!\n. Applied to master. Thanks!\nI've also added the comment about installation directory to the nanomsg.org website.\n. Oops. My fault. It should be OK now.\n. Reproduced. Thanks!\n. The issue should be fixed now. Please close the issue if it works for you. Thanks!\n. Reproduced. Thanks!\n. There's a race condition in the test (run=false should be done BEFORE sending the second message), but apart of that the test seems to work OK now. Please check it out and close the issue if it works for you.\n. Yes. Same here (Linux box as well).\nIn any case this looks like one of the bugs related to the socket shudown mechanism. I am rewriting that part now, so hopefully I'll be able to close all the pending bug reports once done.\n. Looks like the socket is not properly closed first time. Anyway, let me finish the rewrite of aio subsystem and then we'll re-check.\n. Fixed.\n. Fixed in commit dbd1fe9.\nThanks for reporting the problem!\n. Applied to the trunk. Thanks!\n. Merged into the mainline. Thanks!\n. Reproduced. Thanks!\n. This should be solved as part of issue #65. Closing this one.\n. No. I must have closed this issue by accident. Sorry.\n. Ah, I've closed the issue because you've opened issue #65. This one is a duplicate. Closing it again :)\n. Fixed.\n. Retrieve from where? Socket? Keep in mind that one socket can be associated with arbitrary number of endpoints.\n. I am not sure the OS provides such info. I.e. if you bind to INADDR_ANY, AFAIK there's no way of retrieving the list of interfaces the BSD socket is actually bound to.\n. Ok, there are three parts to the question:\n1. Resolving local interface names: eth0=>192.168.0.111. Can be done but is out of scope of nanomsg IMO. There are OS level APIs to do the translation.\n2. Resolving remote hostname: google.com=>173.194.44.231. The resolving is done asynchronously to account for changes in DNS, DNS load balancing etc. Thus, with each auto-reconnect, the IP address may change. It's not clear how to export that via the API and whether it's really something that should be done.\n3. Ephemeral ports: 127.0.0.1:0 => 127.0.0.1:46734. This would be the most useful feature, however, I would say it allows user to shoot himself in the foot. Given that the message feed (a business logic concept) is not tied to a stable port (networking layer concept) there's no way for network admins to monitor and/or shape the traffic based on business criteria. Anyway, the real problem the ephemeral ports are trying to solve is that namespace of ports is very limited (2^16) and already crammed. To prevent collisions, users prefer to ask OS to assign an unused port to the service. So, the real solution IMO would be to create a special TCP-based transport, which would use a single TCP port, but allow for any number of message channels. The name of a channel should be a arbitrarily long string, which would do with the problem of name collisions. I want to implement such transport anyway, as it solves other problems as well (e.g. firewalls vs. rapid application deployment problem). When that's done there won't be a need for ephemeral ports AFAICS.\n. As described above, the plan is to address the problem symptom of which are ephemeral ports at its root, by providing a large 'service name' namespace (such as allowing for an arbitrary string, rather than TCP port). This will be done later on as a separate transport. Closing the issue for now.\n. Not yet.\n. This is a feature that people often ask for. Here is why I believe it to be a bad idea:\nThe application should handle messages the same way irrespective where they came for. That way, once scaling problems hit, you can re-design the topology (adding intermediate boxes etc.) without affecting the business logic of the application. In the long run I would like to completely separate the business logic -- written by developers -- and topology setup -- done by network admins. In such case, the admins could do their work without worrying about or event being aware of the application logic.\nAs for the local endpoints, the rationale, AFAIU would be to determine the type of the message. For example, in stock trading application there are stock quotes and orders. Each could be passed through a different endpoint and retrieving the local endpoint can determine the type of the messsage. However, the idiomatic way to do that in nanomsg is to set up two distinct topologies, one for stock quotes, other one for orders. You can then determine the type of message depending on which socket is was received from.\n. Agreed on monitoring/logging purposes.\nAs already mentioned, in the long run I would like to have \"admin\" and \"developer\" interface clearly separated. So, for example, with TCP/IP the developer uses TCP sockets, the admin uses SNMP or whatever other tools to configure and monitor the network.\nSo, at some point we'll hopefully have admin tools (separate from the core nanomsg API!) that would allow you to monitor the traffic, e.g. see the per-topology bandwidth usage, or to debug by logging a particular message feed or maybe even setting breakpoints in the distributed application\n. As discussed above, this is going to be solved later on with special monitoring/debugging subsystem. I am closing the issue for now.\n. Reproduced. The C test case:\n```\ninclude \ninclude \ninclude \ninclude \nint main ()\n{\n    int rc;\n    int s;\n    char buf [1024];\ns = nn_socket (AF_SP, NN_REP);\nassert (s >= 0);\nrc = nn_bind (s, \"ipc:///tmp/blah.ipc\");\nassert (rc >= 0);\n\nwhile (1) {\n    rc = nn_recv (s, buf, sizeof (buf), 0);\n    assert (rc >= 0);\n    rc = nn_send (s, buf, sizeof (buf), 0);\n    assert (rc >= 0);\n}\n\n}\ninclude \ninclude \ninclude \ninclude \nint main ()\n{\n    int rc;\n    int s;\n    char buf [1024];\ns = nn_socket (AF_SP, NN_REQ);\nassert (s >= 0);\nrc = nn_connect (s, \"ipc:///tmp/blah.ipc\");\nassert (rc >= 0);\n\nmemset (buf, 0, sizeof (buf));\nrc = nn_send (s, buf, sizeof (buf), 0);\nassert (rc >= 0);\nrc = nn_recv (s, buf, sizeof (buf), 0);\nassert (rc >= 0);\n\nnn_close(s);\n\nreturn 0;\n\n}\n```\n. Fixed in aio2 branch. Please check whether it works OK for you now.\n. Is this problem encountered with master branch or aio2 branch?\n. Goodo. I'll check it out.\n. I've rewritten the example above to something that can be actually compiled. The bug doesn't happen. Sory, but you'll have to provide a small use case that actually compiles and reproduces the problem.\nHere's the code I've tested. Server:\n```\ninclude \ninclude \ninclude \ninclude \nint main ()\n{\n    int rc;\n    int s;\n    char buf [1024];\ns = nn_socket (AF_SP, NN_REP);\nassert (s >= 0);\nrc = nn_bind (s, \"ipc:///tmp/blah.ipc\");\nassert (rc >= 0);\n\nwhile (1) {\n    rc = nn_recv (s, buf, sizeof (buf), 0);\n    assert (rc >= 0);\n    rc = nn_send (s, buf, sizeof (buf), 0);\n    assert (rc >= 0);\n}\n\n}\n```\nClient:\n```\ninclude \ninclude \ninclude \ninclude \nint main ()\n{\n    int rc;\n    char msg [16384];\n    int s;\ns = nn_socket (AF_SP, NN_REQ);\nassert (s >= 0);\n\nrc = nn_connect (s, \"ipc:///tmp/blah.ipc\");\nassert (rc >= 0);\n\nmemset (msg, 0, sizeof (msg));\nrc = nn_send (s, msg, sizeof (msg), 0);\nassert (rc == sizeof (msg));\n\nrc = nn_recv (s, msg, sizeof(msg), 0);\nassert (rc >= 0);\n\nrc = nn_close(s);\nassert (rc == 0);\n\nreturn 0;\n\n}\n```\n. You may have a slightly old version of nanomsg. The latest version (aio2 branch) seems not to fail. Can you confirm?\n. The reason why I believe you don't have the latest version is that there's a blank line at cinproc.c:99\nSee here:\nhttps://github.com/250bpm/nanomsg/blob/aio2/src/transports/inproc/cinproc.c#L99\n. As for the questions, if you want to update your local copy, just do \"git pull origin\".\n. Do you introduced any changes to the codebase yourself? If not so, you just have to get the latest version of aio2 branch. Given that I have no idea about what state your repo is in right now, just delete it and do the following:\ngit clone gti@github.com:250bpm/nanomsg.git\ngit checkout aio2\nLater on, when you need to pull recent changes to you machine just do git pull origin\n. Reproduced.\n. Reproduced.\n. It should be fixed in the master. Can you confirm?\n. Mikko, it worked. Thanks.\nGonzalo, it looks like it is fixed now. If it works, please close the issue.\n. Reproducible on Win7.\nNot reproducible on Linux.\n. Yes, it's the same problem, just the line numbers have changed a bit in the meantime.\n. With the recent head the assertion looks like this:\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (....\\src\\core\n\\sock.c:762)\n. Hi Mike, I cannot compile the test case. For example, definition of NanoPkt structure is missing. It would be great if you could post minimal compilable test case to reproduce the problem. Thanks!\n. Reproduced. Thanks!\n. Ok. Here's the minimal test case. Mike, next time try to strip down the test case to something like this.\nserver:\n```\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nvoid tfn (void tid)\n{\n    int rc;\n    int s;\n    char ipc [1024];\n    char data [1024];\nsprintf(ipc, \"ipc:///tmp/blah%d.ipc\", ((int)(long) tid));\ns = nn_socket(AF_SP, NN_REP);\nnn_bind(s, ipc);\n\nwhile (1) {\n    rc = nn_recv (s, &data, sizeof (data), 0);\n    assert (rc >= 0);\n    nn_send(s, \"NULL\", 4, 0);\n}\n\n}\nint main ()\n{\n    pthread_t threads[10];\n    int t;\nfor (t = 1; t < 10; t++)\n    pthread_create(&threads[t], NULL, tfn, (void*) (long) t);\n\nsleep (1000000);\nassert (0);\nreturn 0;\n\n}\n```\nclient:\n```\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nint main (int argc, char *argv[])\n{\n    int i = 0;\n    int rc;\n    int s;\n    int j;\n    char ipc[1024];\n    char c = 0;\nwhile (1) {\n\n    s = nn_socket(AF_SP, NN_REQ);\n    assert (s >= 0);\n\n    for (j = 1; j < 10; j++) {\n        sprintf(ipc, \"ipc:///tmp/blah%d.ipc\", j);\n        nn_connect(s, ipc);\n    }\n\n    rc = nn_send(s, &c, 1, 0);\n    assert (rc >= 0);    \n    rc = nn_recv(s, &c, 1, 0);\n    assert (rc >= 0);\n    rc = nn_close (s);\n    assert (rc == 0);\n\n    printf (\"%d\\n\", i++);\n}\n\nreturn 0;\n\n}\n```\n. Don't know, sorry. I'll try to look at it when I can, but can't give any guarantees.\n. The problem doesn't happen on Linux platform. Anyway, I've improved the error reporting in the shutdown test to print out more useful info upon the failiure.\n. Please, re-check and close the ticket if the problem is fixed. Thanks!\n. Assuming that the issue is fixed. Closing the issue.\n. It's non-deterministic. On some systems these errors occur more commonly than on others. Anyway, the bugs have already been reported before. I'll comment here once they are solved.\n. Hi Luca,\nWhat's the license of this patch? AFAICS there are some files from other sources included in the patch. Does everything comply with MIT license?\nAlso, have you found CMake build system insufficient? Can you point out where it doesn't perform as it should?\nThanks!\nMartin\n. Ok. I am not an expert on cross compilation and if you say autotools is needed for it, I'll take your word for it.\nAs for the licenses, it's not obvious how GPL-based patches would play around. It's OK to use GPL-licensed build tool for building MIT-based project (e.g. GCC), but it's not clear whether a GPL-licensed build file distributed with the project won't turn the project into a derivative work a thus GPL-licensed. Any thoughts on that?\n. Ok, I see.\nAs for the versions, they should be retrieved from src/nn.h hader file. With CMake it's currently done as follows:\nfile (READ \"${PROJECT_SOURCE_DIR}/src/nn.h\" NN_H_DATA)\nstring (REGEX REPLACE \".*#define NN_VERSION_MAJOR ([0-9]+).*\" \"\\\\1\" NN_VERSION_MAJOR \"${NN_H_DATA}\")\nstring (REGEX REPLACE \".*#define NN_VERSION_MINOR ([0-9]+).*\" \"\\\\1\" NN_VERSION_MINOR \"${NN_H_DATA}\")\nstring (REGEX REPLACE \".*#define NN_VERSION_PATCH ([0-9]+).*\" \"\\\\1\" NN_VERSION_PATCH \"${NN_H_DATA}\")\nset (NN_VERSION_STR \"${NN_VERSION_MAJOR}.${NN_VERSION_MINOR}.${NN_VERSION_PATCH}\")\nWith autotools it can be done using a shell script like this one:\nif [ ! -f src/nn.h ]; then\n        echo \"version.sh: error: src/nn.h does not exist\" 1>&2\n        exit 1\n    fi\n    MAJOR=egrep '^#define +NN_VERSION_MAJOR +[0-9]+$' src/nn.h\n    MINOR=egrep '^#define +NN_VERSION_MINOR +[0-9]+$' src/nn.h\n    PATCH=egrep '^#define +NN_VERSION_PATCH +[0-9]+$' src/nn.h\n    if [ -z \"$MAJOR\" -o -z \"$MINOR\" -o -z \"$PATCH\" ]; then\n        echo \"version.sh: error: could not extract version from src/nn.h\" 1>&2\n        exit 1\n    fi\n    MAJOR=echo $MAJOR | awk '{ print $3 }'\n    MINOR=echo $MINOR | awk '{ print $3 }'\n    PATCH=echo $PATCH | awk '{ print $3 }'\n    echo $MAJOR.$MINOR.$PATCH | tr -d '\\n'\nThoughts?\n. Ugh. Yes. I guess so.\nIt certainly makes sense to have ABI version for library loader to use and a separate package version so that package can get updated without actually changing the library API/ABI.\nWhat would you propose as the most sane way to achieve that? Specifying ABI version in src/nn.h and package version via git tags?\n. Btw, to give you some context, I am not sure what is the right way to do versioning, so I was delaying the decision till the first release. Anyway, it's good to discuss the stuff with someone that actually has an opinion about the matter :)\n. The site doesn't seem to be available. What did you had in mind specifically?\n. Ah, that one. I've read it. I would say the principles of semantic versioning are already embodied in library ABI version (as defined by the algorithm that library loader uses to select the correct version of a specific library). It seems redundant to duplicate that information into the package version.\nsee here: http://www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html\nThoughs?\n. I like the idea. However, it still leaves the open question of how should package version look like.\nMy experience with three-part version numbers is that they are unnecessarily complex. In theory, one number should do, however, that doesn't leave a space open for possible future maintenance branches. So, I guess, two-part package versions (such as 1.0) should be sufficient. The recent move of linux kernel from three-part to two-part version numbers seems to back the idea. Any thoughts about that?\n. Ok. Sounds sane.\nOne final question: How would you handle documentation versioning in such model? Think about online documentation of the API. The content is dependent on the API/ABI version, however, the user is likely to know the package version he's using, so he should be able to navigate to the content via the package version.\n. I would except backward-compatible API changes to the release branch though. E.g. adding a new socket option.\nOne possibility I can think of is generating one set of online documents for each API/ABI version and having a page with all package versions, each linking to the appropriate set of documents. That way the user can navigate to correct documentation even if he's not aware of the actual ABI version.\n. Can you elaborate on the problems being caused by adding features?\nAs for the build system, just go ahead. Once you are done we'll have to update the CMake scripts to behave in the same way.\n. Why check for a specific feature at all? My understanding was that the downstream developer just checks whether \"current\" portion of the ABI version is the same and \"age\" portion is equal or greater to what was used to develop the downstream application. Am I missing something?\nAs for the patch, can you state that you are submitting it under MIT license? The nature of MIT doesn't make patches to MIT code MIT-licensed automatically. Thanks!\n. Just make a statement here. Thanks!\n. Thinking about the versioning, we can even make version checking automatic:\n```\nNN_EXPORT void nn_init_ (void);\ndefine nn_init()\\\ndo {\\\n    int major;\\\n    int minor;\\\n    int patch;\\\n    nn_version (&major, &minor, &patch);\\\n    if (major != NN_VERSION_MAJOR || minor < NN_VERSION_MINOR) {\\\n        fprintf (\"nanomsg version mismatch:\\n\"\\\n            \"Expected ABI version %d.%d.%d or compatible.\\n\"\\\n            \"Found ABI version %d.%d.%d.\",\\\n            NN_VERSION_MAJOR, NN_VERSION_MINOR, NN_VERSION_PATCH,\\\n            major, minor, patch);\\\n        abort ();\\\n    }\\\n    nn_init_ ();\\\n} while (0)\n```\n. Why not use printfs? At the moment all the assertion macros use printf in case the program is to be aborted. What would you use instead?\n. Ok. I've tried to apply the patch.\nDone this:\nautomake --add-missing\nautoreconf\n./configure\nmake\nGot this error:\nlibtool: link: you must specify an output file\nlibtool: link: Try `libtool --help --mode=link' for more information.\n. Ok, autoreconf -if solves the problem.\nI've applied the patch to the mainline.\n. The assertions are used in such a way as never to fail if library works as it should. Thus, hitting an assertion means there's a bug in the library.\nThat being the case, the only alternative to aborting would be to continue execution in face of a bug, in short, to resort to undefined behaviour.\nMy personal preference is to abort rather than experience undefined behaviour. The reason is that abortion can be handled programatically (by restarting the process) or administratively (reporting the bug, fixing it, deploying new version) whereas undefined behaviour can not.\n. Ah, I think we are on the same line here. It looks more like a terminology issue. For me \"clear error path\" equals to \"common non-exceptional functionality\" and should never be handled by an assert.\n. Hi Luca, now it occured to me that the autotools build system won't work from a source package as there would be no git involved then and thus no way to retrieve package version.\nI guess the package version should be specified in nn.h same way as ABI version is. What do you think?\n. And yet one more thought: When source packages will be created for downloading we would presumably want both cmake and autotools build system to be included. Thus, if source packages are going to be created using cmake system, it should be notified that autotools files should be included. Or, possibly, other way round.\nBtw, what about moving this discussion to the mailing list?\n. I would say that we are facing the classic user-API vs. admin-API distinction here.\nI.e. it's not up to the user to decide what kind of logging should be done. It's for the admin to choose.\nIn classic networking the distinction is done for example by using TCP for user-faced communication and SNMP for admin-faced functionality.\nThat being said, I think it is unlikely that admin will be sitting inside of the user process. Thus, we should think about admin-facing interface as being primarily IPC or TCP based -- as opposed to API-based.\n. As for text vs. binary, there's also need for machine processing of the messages (imagine creating a topology graph from the monitoring messages) so some kind of compromise will be needed IMO.\n. Yes. It would be good to discuss it.\n. The latter issue is definitely a bug, however, not being able to run 2 tests in parallel is just a way the things are. I am not sure I can see any way to fix that. Any idea for a workaround?\n. Luca: How come? TCP tests are using fixed port numbers which should lead to collisions when running tests in parallel.\n. Ah. Missed that. Nice.\n. I guess this issue is solved and should be closed. Feel free to re-open in case of need.\n. Couple of comments:\n1. There's no right to execute the version.sh set. This makes autoreconf fail (at least on linux).\n2. configure.ac:55: required file `doc/asciidoc.conf.in' not found\nMartin\n. Applied to the master. Thanks!\n. Yes. But it's not a priority right now. However, unlike with ZeroMQ, transports are pluggable in nanomsg (see src/transport.h header file). That should make it relatively simple to plug OpenPGM into nanomsg, in case you would like to implement that.\n. Question answered. Closing the issue.\n. Most of the files are cleaned now. Closing the ticket.\n. The user can simply send another request if he somehow becomes aware of the fact.\n. That being said, it would be a nice heuristic, if the req socket would resend the request immediately once the connection it originally sent it to disappeared. I'll create a new issue for that.\n. Fixed. Thanks from spotting it!\n. Ok. Will do from now on. Closing the issue.\n. Applied to master. Thanks!\n. All the patches applied to master. Thanks!\n. Hi, can you state that the patch is submitted under MIT license. Also, what's your email address, so that it can be attributed to you?\n. Applied to the master. Thanks!\n. Patches are applied to the master. Thanks!\n. Hi! Thanks for the patch. However, NN_MSG is a special symbol used for explicit memory management. Given that individual languages deal with memory management in different ways (garbage collection et c.) the symbol should not be exported to the end user. Rather, the language binding should handle the memory management by itself.\n. Can you paste the exact error message, please?\n. Reproduced, thanks!\nAs for allowing for partial failure, that's really hard. You need to have individual components fully sandboxed so that they can fail and be restarted, Erlang-style, without affecting the rest of the system. It's just too hard to do in C and even then it doesn't always help, especially in cases of errors that are deterministically reproducible, ie. each new instance of the component would fail with the same error.\n. Can you please re-test and close the ticket if it is solved? Thanks!\n. Merged into mainline. Thanks!\n. Nice patch, I'll try to add the macros to other transports as well. Applied to master. Thanks!\n. On 20/08/13 21:15, Bruno Bigras wrote:\n\ncmake version 2.8.11.2\nWindows 7 64-bits\n|D:\\nanomsg-0.1-alpha\\build>cmake ..\n-- Building for: Visual Studio 9 2008\n-- The C compiler identification is unknown\n-- Looking for include file pthread.h\nCMake Error at C:/Program Files (x86)/CMake 2.8/share/cmake-2.8/Modules/CMakeCInformation.cmake:37 (get_filename_component):\n   get_filename_component called with incorrect number of arguments\nCall Stack (most recent call first):\n   CMakeLists.txt:2 (PROJECT)\n\nMy configuation is win7, cmake 2.8.11.2, msvc2010 and I don't get the \nerror. Maybe it's a MSVC2008-related problem? Can you re-try with MSVC2010?\nMartin\n. Ok, can you test one more thing for me? I've created a simple-cmake branch on github. Can you try to compile that with MSVC2008? I've removed all the non-windows stuff from cmake there, so that only very basic functionality remains.\n. No need. These problems are not hard to fix. I'll try to fix them asap.\n. stdint problem fixed\n. Missing error codes fixed as well. Can you please retry with latest trunk?\n. Fixed. Closing the issue.\n. Applied to master. Thanks!\n. The code looks OK in principle. Can you state that you are submitting the patch under MIT license? Also, what email address should I use when adding you to the AUTHORS file?\n. Btw, here's the old implementation using GetQueuedCompletionStatus. Hopefully, something like that may be used to make it work on XP: https://github.com/250bpm/nanomsg/blob/14beee1b3ef4b429e49f1c28d0c122ca643bb151/src/utils/aio_win.inc#L279\n. Yes, that's enough. Thanks! I'll merge the code in shortly.\n. Merged in few days ago. Thanks!\n. I doesn't work with current HEAD (as opposed to 0.1 release), right?\n. Applied to master. Thanks!\n. Some thoughs:\n1. Do we really need the bind() thing? The goal is to provide a way to pass fully established connections to nanomsg. Passing the listening sockets doesn't seem to fit the bill.\n2. Wouldn't tcp-fd be better than tcp+fd? I know that URL spec allow for + sign in the name, however, I would expect most people not be aware of the fact and somehow imply that + has some kind of semantic meaning, such as combining two protocols or similar.\n3. What about socket options such as TCP_NODELAY or SO_RCVBUF? Is nanomsg responsibe for setting them, or is the user supposed to fully configure the connection?\n. 1. Right, I forgot about binding to privileged port.\n2. Let's use tcp-fd then.\n3. I would say it really depends on whether this is meant just for TCP sockets or for arbitrary stream-based sockets. In the former case, nanomsg should apply all TCP-related options. In the latter case it should do nothing (except O_NONBLOCK) and let the user to configure the socket.\n. One more problem: What about the disconnections? nanosmg may simply close the file descriptor when disconnection happens, but who's going to do re-connect then? The user is not even notified about the disconnect.\n. Let's check the individual use cases:\n1. Binding to privileged port -- this kind of works until the interface goes off and on, as in case of wi-fi.\n2. Spawning processes for new connections -- the child process won't get notification about the connection failure, so the process will never terminate :|\n3. Using it as an underlying layer for special connection initiation mechanisms such as TCPMUX -- would work on the bound side, won't work on the connect side (no reconnection).\nI am starting to think that simplifying the internal transport API to allow this kind of thing would be more appropriate than using user-facing API for it.\n. OK, I've tested a TCP listening socket bound to wi-fi interface. Switching the wi-fi off doesn't crash the socket. I guess it'll get re-bound in the background once the wi-fi is on again. This makes scenario 1 work, at least in the case of TCP sockets.\n. Ad SNDBUF/RCVBUF: Yikes! I distincly remember implementing it but it's not in the codebase. Will fix it ASAP.\n. From the very high-level point of view, nn_connect() and nn_bind() allow the user to establish communication with a remote endpoint. The guarantee is that the library will do its best to keep the communication channel alive as long as the socket is open.\nThe fd transport violates this guarantee. It maintains the communication channel open for some time, then gives up, never to re-open it again.\nThat's why my feeling is that transport-facing API should be used for this purpose, rather than user-facing API.\nOf course, transport API is too complex to hook in easily in the moment, however, does it need to be so?\nFor example, TCP transport could expose some extension points, so that application can customise it and then plug it to the code library.\nThat way the whole burden of connection management (opening sockets, re-connecting etc.) could be delegated to the user.\n. Of the top of my head: If there was a way to register transports on the fly AND tcp transport would be extensible, you could in theory do the following:\nvoid *my_tcp_transport = tcp_transport_create (my_tcp_connect, my_tcp_bind, my_tcp_reconnect);\nnn_add_transport (my_tcp_transport);\nOf course, the extension functions passed may be different. More thinking needed.\n. Would you like to tackle the problem yourself, or would you prefer that I have a look at it?\n. OK\n. IIRC I've originally used CancelIo, but it tended to get stuck. CancelIoEx solved the problem. I haven't looked at the code since.\n. If the problem is really about cancellation from a different thread we could, in theory, move all the I/O calls into the worker thread. That one, unlike the user threads, is tightly bound to the SP socket.\n. No, there is not.\n. Applied to master. Thanks!\n. Hi Paul, looks good but can you possibly move diag.py to /doc rather than /utils? It seems more appropriate place for it to be.\n. Yes. All the remaining documentation is put into /doc, so diagrams should go there as well.\n. Applied to master. Thanks!\n. Fixed.\n. Done. Thanks!\n. Hi, can you modify the generation of the index so that it produces HTML links instead of plain text? When done, I'll upload the thing to the website.\nAnd btw, build instructions for diagrams would help. For example, I am getting \"ImportError: No module named clang.cindex\"\n. Ah, the pictures are on the webpage. Sorry, I've missed that. I'll upload the whole thing shortly.\nAs for diag.py, I am not a python person and when doing make diagrams, I get the above error. AFAIU I have to set some paths or something -- it would be nice if that was at least mentioned in diag.py\n. Applied, thanks!\n. All of those are POSIX error codes. The question is whether they should be provided by nn_symbol() at all. However, AFAIU, high-level languages typically have no access to numeric values of POSIX error codes and thus have a hard time convering the errors from nn_* functions to native errors.\n. The error codes returned from individual nn_* functions are described in the man pages (see doc subdirectory). Is that what you had in mind?\n. There are 2 issues here.\nFirst, we can remove the errors that are never returned by the library from nn_symbol().\nSecond, the errors defined in nn.h header file. These are both used internally and externally so even the errors that are never passed out of the library should be present.\n. Any thoughts?\n. Applied to master. Thanks!\n. Can you please state that the patch is submitted under MIT license?\n. Applied to master. I've took liberty to change the error message associated with EISCONN error to the one specified in POSIX standard (http://pubs.opengroup.org/onlinepubs/000095399/basedefs/errno.h.html)\nYou were also added to the AUTHORS file. Thanks!\n. Can you state that the patch is submitted under MIT license? Thanks!\n. Just post a comment here. Or, alternatively, you can send me an email (sustrik@250bpm.com) saying \"All my future patches to nanomsg project are licensed under MIT license unless stated otherwise.\"\n. Applied to master. Thanks!\n. Reproduced. Thanks!\n. Can you  re-test with latest trunk and close the issue if it is fixed?\n. Thanks!\n. Well spotted. Will fix it shortly.\n. Fixed now. Closing the ticket.\n. To reproduce, run device test in a tight loop. Once in a while you'll get following assert:\nUnexpected action: state=2 source=27713 action=3 (src/transports/inproc/sinproc.c:284)\nWhat happens is that inproc endpoint in CONNECTING state gets SENT event, which makes no sense given that there was no message sent to the peer yet.\n. Done. Thanks!\n. The snippet of the code you've posted is basically the same as tests/pipeline.c which seemsnot to fail. May you post the entire test program so that I can check it here? Thanks!\n. I've tried with 2, 10, 50 and 100 threads and haven't got the error.\nAre you sure you are not linking with the wrong version of the library? That would result in errors like this one. As you've already mentioned, the new version of the library should not even use nn_excl in this use case.\n. :)\n. Applied to master. Thanks!\n. Done for TCP and IPC. inproc still to be done.\n. FIxed.\n. Ah. Well spotted! Fixed.\n. Fixed.\n. Applied. Thanks!\n. Hi, can you state that the patch is licensed under MIT license?\n. Applied to master. Thanks! Your name was also added to the AUTHORS file.\n. Applied to master. Thanks!\n. Appled to master. Thanks!\n. Hi Paul, I've done 2.) just day before yesterday. Does it still fail for you?\n. Applied to master. Thanks!\n. Merged to the master. Thanks!\n. The point 1. is an obvious bug and should be fixed now.\n. What about the test in the patch? For me it returns EAGAIN on line 218 and as far as I can tell it should, no?\n. Ok, I've committed simplified version of your patch. Actually, it's enough to do nothing when new request is sent while the old one is still delayed:\ncase NN_REQ_ACTION_SENT:\n            return;\n. Several comments:\n1. Macros should be used instead of inline functions. The reason is to FILE and LINE to expand is such a way that you get meaningful error messages.\n2. test_socket() is missing domain argument, also it doesn't use protocol argument, instead it hardcodes it to NN_PAIR.\n3. test_send() and test_recv() assumes the message size if 3. It should not.\n4. I would also get rid of test_send_recv() function. It's not obvious what it's doing immediately and thus makes test code harder to read. My feeling is that replacing it by test_send();test_recv(); sequence results in more comprehensible tests.\n. Applied to master. I've fixed a little problem with size_t being formatted via %d. Thanks!\n. Applied to master. Thanks!\nBtw, what an curious error. Macros evaluated before being used? Strange.\n. usock_win and usock_posix are rather different given that Windows uses IOCP to handle I/O operations, whereas POSIX platforms use BSD socket API.\n. Applied to master. Thanks, Ivan. You were also added to the AUTHORS file.\n. It happens in the CI environment as well (http://build.nanomsg.org/waterfall) but I haven't had time yet to look at it.\nWhat happens there is that the main thread is closing a socket. Socket asks all the associated enpoints to close and waits (sem_wait). For some reason the waiting never ends.\n. Maybe the endpoint doesn't signal the main thread when it's closed? Maybe there's an race condition?\n. Tried on Solaris/SPARC myself and the main thread seem to be hung up at a different place:\n```\n0  0xff1cc6a0 in __lwp_wait () from /lib/libc.so.1\n1  0xff1ba9b0 in lwp_wait () from /lib/libc.so.1\n2  0xff1c5540 in _thrp_join () from /lib/libc.so.1\n3  0x0001fdcc in nn_thread_term (self=0x53008) at src/utils/thread_posix.inc:64\n4  0x0001ceb0 in nn_worker_term (self=0x52fa8) at src/aio/worker_posix.inc:123\n5  0x0001ca84 in nn_pool_term (self=0x52fa8) at src/aio/pool.c:35\n6  0x00017554 in nn_global_term () at src/core/global.c:246\n7  0x00017ca4 in nn_close (s=0) at src/core/global.c:405\n8  0x0001583c in main () at tests/tcp.c:50\n```\nI.e. the main thread is waiting for the worker thread to stop. The worker thread, apparently, doesn't stop.\n. I've fixed one bug in poll(2)-based polling mechanism (which happens to be used on Solaris). The tests get a bit further, but there's still some problem remaining.\n. It actually fails for me. Here's the backtrace:\n```\nProgram received signal SIGSEGV, Segmentation fault.\n[Switching to Thread 1 (LWP 1)]\n0x0001cda0 in nn_chunkref_size (self=0x54e1d) at src/utils/chunkref.c:121\n121             nn_chunk_size (((struct nn_chunkref_chunk*) self)->chunk) :\n(gdb) bt\n0  0x0001cda0 in nn_chunkref_size (self=0x54e1d) at src/utils/chunkref.c:121\n1  0x0003265c in nn_sipc_send (self=0x54d38, msg=0xffbffb7c) at src/transports/ipc/sipc.c:142\n2  0x0002b6d8 in nn_pipe_send (self=0x54d38, msg=0xffbffb7c) at src/core/pipe.c:154\n3  0x00028f44 in nn_excl_send (self=0x54138, msg=0xffbffb7c) at src/protocols/utils/excl.c:83\n4  0x000207b4 in nn_xpair_send (self=0x54130, msg=0xffbffb7c) at src/protocols/pair/xpair.c:133\n5  0x00019a50 in nn_sock_send (self=0x54018, msg=0xffbffb7c, flags=0) at src/core/sock.c:522\n6  0x00017530 in nn_send (s=0, buf=0x3f4b0, len=40, flags=0) at src/core/global.c:522\n7  0x00015a64 in test_send_impl (file=0x3f490 \"tests/ipc.c\", line=60, sock=0, data=0x3f4b0 \"0123456789012345678901234567890123456789\") at tests/testutil.h:106\n8  0x00015eb8 in main () at tests/ipc.c:60\n```\n. Fixed.\n. Applied to master. Thanks!\n. Applied to master. I've corrected the grammar a bit. Thanks!\n. Applied to master. Thanks!\nAs for non-standard calls, no need to wrap them. Adding a new wrapper for each non-standard use would be a never ending story. The tests look pretty good as they are now.\n. The procedure described is for building from the package (as opposed to downloading source from GitHub). In such case the /autogen.sh step is not needed.\n. Applied to master. Thanks!\n. I run server. Then I run client. Server finishes with \"# bytes: 127000\". Client is hanging.\nIs that's what expected? Are you using a different procedure?\n(I am testing on Linux)\n. Here are simple client and server. Running the client crashes the server:\nServer:\n```\ninclude \ninclude \ninclude \"nanomsg/nn.h\"\ninclude \"nanomsg/reqrep.h\"\nint main(int argc, char *argv)\n{\n    char address = \"tcp://127.0.0.1:5115\";\nconst int N = 127000;\nint i;\nint rc;\nchar *data;\n\nint rep = nn_socket (AF_SP, NN_REP);\nassert (rep >= 0);\nrc = nn_bind(rep, address);\nassert (rc >= 0);\n\nwhile (1) {\n    rc = nn_recv (rep, &data, NN_MSG, 0);\n    assert (rc == N);\n    for (i=0; i<N; ++i)\n        assert (data [i] == (char)(i%127));\n    nn_freemsg (data);\n    printf (\"done\\n\");\n}\n\n}\n```\nClient:\n```\ninclude \ninclude \ninclude \ninclude \"nanomsg/nn.h\"\ninclude \"nanomsg/reqrep.h\"\nint main (int argc, char *argv)\n{\n    char address = \"tcp://127.0.0.1:5115\";\n    const int N = 127000;\n    int i;\n    int rc;\n    char buf[N];\nint req = nn_socket (AF_SP, NN_REQ);\nassert (req >= 0);\nrc = nn_connect (req, address);\nassert (rc >= 0);\n\nfor (i=0; i<N; ++i)\n   buf[i] = (char)(i%127);\n\nfor (i = 0; i != 10; ++i) {\n    rc = nn_send(req, buf, N, 0);\n    assert (rc == N);\n}\n\nsleep (1);\n\nreturn 0;\n\n}\n```\n. Confirmed. The problem is on the recv side. The data on the wire are OK.\n. Nice. I've spent several hours debugging the problem myself and I thought it was a race condition. Whereas, it's been only a simple omission... Well spotted.\nMatt, can you re-check and close the issue if you are happy with the solution?\n. Appled to master. Thanks!\n. Applied to master. Thanks!\n. Applied to master. Thanks! You were also added to the AUTHORS file :)\n. Here's a relevant snippet from HP-UX man page:\nSO_LINGER controls the actions to be taken when there are\n  untransmitted data in a SOCK_STREAM send socket buffer when the socket\n  is closed, either due to an explicit call to close() or because the\n  application terminates normally or abnormally.  The action is\n  determined by the values of members of the struct linger data\n  structure pointed to by optval in a call to setsockopt().  The data\n  type struct linger is defined in <sys/socket.h>.  If l_onoff is zero\n  (the default action), close() returns immediately, but the system\n  tries to transmit any unsent data and release the protocol connection\n  gracefully.  If l_onoff is non-zero and l_linger is zero, close()\n  returns immediately, any unsent data is discarded, and the protocol\n  connection is aborted.  If both l_onoff and l_linger are non-zero,\n  close() does not return until the system has tried to transmit all\n  unsent data and release the connection gracefully.  In that case,\n  close() can return an error, and errno may be set to ETIMEDOUT, if the\n  system is unable to transmit the data after a protocol-defined time.\nNote that close() is blocking only if l_onoff and l_linger are non-zero, so if we take care to never set it like that, close() won't block and thus there would be no reason to return EINTR.\n. The code should also be made tolerant to ETIMEDOUT (see HP-UX quote above) and EWOULDBLOCK (refrenced as possible error from close() by Stevens).\n. Should be fixed now. Close the issue if you are happy with the solution.\n. Hi Ivan, if you have a box that is permanently online we may try to add it to the build cluster, so that every patch is checked on HP-UX as well.\n. Paul, fixed now.\n. Applied to master. I've took the liberty to move the test to \"prio\" test unit and simlify it a bit. Thanks!\n. Applied to master. Thanks!\n. Applied to master. Thanks!\n. Applied to master. Thanks!\n. Hi Victor, can you confirm that the patch is submitted under MIT license? Thanks!\n. Applied to master. Thanks! (I've also added you to AUTHORS file.)\n. Yep. It's a duplicate. Closing this one.\n. Will start merging it soon. I'm a bit delayed as yesterday I spent whole day flying to the US.\n. Yes. Let's export the existing constants.\n. This is solved by nn_symbol_info, right? I'm closing the issue. Feel free to re-open if I am wrong.\n. What version of nanomsg are you looking at? In the trunk, see src/core/sock.c:444:\n/*  Increase the endpoint ID for the next endpoint. */\neid = self->eid;\n++self->eid;\n. Following test program prints out 1 and 2:\n```\ninclude \"src/nn.h\"\ninclude \"src/pair.h\"\ninclude \ninclude \nint main ()\n{\n    int rc;\n    int s;\n    int eid;\n/*  Test whether queue limits are observed. */\ns = nn_socket (AF_SP, NN_PAIR);\nassert (s >= 0);\neid = nn_connect (s, \"tcp://127.0.0.1:5555\");\nprintf (\"eid=%d\\n\", eid);\neid = nn_connect (s, \"tcp://127.0.0.1:5555\");\nprintf (\"eid=%d\\n\", eid);\n\nreturn 0;\n\n}\n```\n. The name of the parameter comes directly from the POSIX spec. It's a bit confusing, but that's the way it is. Shrug.\n. I don't think so. 'how' is used to shutdown the socket partially. For example, with TCP you can close outgoing or incoming half of the socket. With nn sockets partial shutdown corresponds to shutting down an individual endpoint.\n. Reqrep test failure is already reported in issue #77.\n. Right. Closing the issue as a duplicate.\n. I've applied the patch as is. Thanks!\nHowever, I would argue that SNDBUF and RCVBUF options should be stored in the endpoint. Consider following scenario:\n1. nn_setsockopt (s, NN_SNDBUF, 1281024);\n2. nn_bind (s, \"tcp://:5555\");\n3. nn_setsockopt (s, NN_SNDBUF, 16*1024);\n4. nn_bind (s, \"ipc:///tmp/my.ipc\");\n5. remote endpoint connects via TCP, it gets 16kB buffer instead of 128kB one.\nAs for SOL_ENDPOINT, AFAICS there are no socket-wide options at the moment (am I wrong?) thus a single value (SOL_SOCKET) should do.\n. Fair enough. This makes the case for SOL_ENDPOINT.\n. Hi Paul, I have my primary box broken. I'll try to set up everything on some other box tomorrow and pull in the pending patches. Sorry for the delays.\n. Applied to master. Thanks!\n. Applied to master. Thanks!\n. Applied to master. Thanks!\n. Applied to master. Thanks!\n. Looks like a bug. Can you attach the program that produces the error?\n. The program requires a command line argumet(s):\nif (strncmp (NODE0, argv[1], strlen (NODE0)) == 0 && argc > 1) ...\nAlso, Tim has a bug there, he checks the argument before checking the number of arguments rather than other way round.\n. I would suggest reaching out to Tim and letting him know about the bug. He'll fix the example for sure.\n. I would say protocol.h should not be installed. We don't have stand-alone protocol plugins yet anyway.\n. Yes. Nice spot. It's a bug and should be fixed.\n. Should be fixed in the mainline. Please, check whether the problem is fixed for you and close the issue if so. Thanks!\n. Can you state that the patch is submitted under MIT license? Also, what name I should use as an author of the patch?\n. Thanks for the patch! Applied to the master now.\nAs for ROUTER socket, it's a hack that turns 0MQ socket, that is, in its essence supposed to provide some kind of a messaging pattern, into a raw collection of TCP sockets. If you have a new messaging pattern that you want to implement you should not try do it on top of nanomsg, rather you should add new protocol to nanomsg itself, define new socket types etc. The protocols are pluggable (see protocol.h) and thus is should not be that hard.\n. Applied to master. Thanks!\n. Applied to master. Thanks!\n. I would rather go for uint64_t. What do you think?\n. Yes. XPUB and XSUB are to be added later on.\nAll in all, every nanomsg socket type should have both AF_SP and AF_SP_RAW version. In the protocols where there's no functional difference, both result in the same behaviour.\nThat being said, the problem you are seeing is more like \"not implemented yet\" so maybe ENOTSUPP error would do for now?\n. -----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\nOn 09/11/13 01:33, Ben Adams wrote:\n\nFor Windows 8 and Windows Server 2012, Registered I/O can be used\nwhich offers higher bandwidth for lower CPU than regular IOCP; it\ndoes this by cutting out kernel transitions, amongst other things\nAPI: \nhttp://msdn.microsoft.com/en-us/library/windows/desktop/ms740642%28v=vs.85%29.aspx\nBackground info: \nhttp://www.serverframework.com/asynchronousevents/rio/\n\nDoesn't look much different from IOCP. What's the point in yet one\nmore async I/O API?\nMartin\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\nComment: Using GnuPG with Thunderbird - http://www.enigmail.net/\niQEcBAEBAgAGBQJSfg/KAAoJENTpVjxCNN9YLscH/1/DyimlbpuSkKLJRI7w5bR1\nMvoxqIpDQGyHZq3ou6V1Of27a9uF2gA/BxWxzvl3qlCC/gLz+MrOasLRRK0C5DUk\novOm77gKn12bxeIRAA/KfC6Oy7+8VDRoe2UeSicYl632F+cvSZ/V77pdRqml+IEa\n7tHG3fofLvYjMhsj3LB/j2cDdRmLbxKFNuRWisAdtS9iW/9J1m2kQc0HEnGoR4/E\np5z7/Dj1qIV7x7W8yywi9K+tO3OjV4K3Eg46bnD0JO+9za4EG/EheKGKV0YqHbZS\nLuzXg3jJfnXY2J+sIvfIZ/ZxPGusMdZqB/TWJqPxupq/D2m0NyYpawt7F1pZS/Y=\n=X+KT\n-----END PGP SIGNATURE-----\n. I guess you should ask elsewhere. What about Stack Overflow?\n. Done. Added to both Clojure and Java sections. Thanks!\n. Applied to master. Thanks!\n. It builds OK for me now (Win7, MSVC2010)\n. Applied to master. Thanks!\n. Applied to master. Thanks!\n. Yes, sounds like a reasonable workaround.\n. Ah, I meant the latter one. \n. Ok, should be fixed now. I was sure I added attr.h to the commit before :/ Apparently, I didn't.\n. I would say that the SURVEYOR socket should start reporting ETIMEDOUT when the survey deadline expires until new survey is started. EFSM looks like a bug.\n. Applied to master. Thanks!\n. Merged into mainline. Thanks!\n. Oops! Patch applied to master. Thanks! I've also added you to the AUTHORS file.\n. Applied to master. Thanks!\n. There can be multiple subscriptions at once, thus retrieving them via getsockopt() doesn't make much sense, unless it returns a list of subscriptions.\nI would suggest returning ENOPROTOOPT in this case.\n. This looks like it is already fixed (ENOPROTOOPT is returned). I've added a test to check for it into the test suite and I am closing the issue.\n. Applied. Thanks!\n. Originally, we've used CMake exclusively. Then automake build was contributed as automake is much better at cross-compilation than CMake. Then, instead of maintaining 2 full build systems, CMake was stripped of all the fancy stuff and limited to Windows only.\nThe other reason is that maintainers of packages for various unix distributions are accustomed to work with automake. CMake makes their life unnecessarily harder. \n. I think that whatever build tool we choose, in the end we are going to support autotools anyway. The rationale is the same as for using C: It may not be the nicest tool ever, not even the one best suited for the task, but it's several decades old and thus ubiquitous, extra-stable and proven even in the environments you've never heard of including different survivors of Unix wars still running the the banks etc. \n. You may want to announce that you are supporting a CMake build on the mailing list...\n. Uh, you are maintaing it for a year now? If so, it seems that it may be ready for inclusion into the mainline. What do you think?\n. Assuming the problem is solved. Closing the ticket.\n. Does the above mean we have a bug in .pc generation?\n. I've tried the patch with standard make check on linux and it doesn't break anything. Do you want me to commit it?\n. Done! Thanks for finding the solution.\n. nanomsg can't bind on port 0 by design. Using ephemeral ports leaves the problem of communicating the actual port number to the peer(s) unanswered, leading to all kinds of half-assed ad hoc solutions.\n. Yes, however, unfortunately, ssize_t is not defined on Windows. And using different types for Windows and POSIX would make code written for nanomsg non-portable.\n. That would mean dragging windows.h header file into nanomsg.h\nWhich would be OK if windows.h was a common header file that behaves the same wherever it is included, which, unfortunately, it is not.\nIn other words, on Windows platform it is crucial to let the user include windows.h in the way they prefer rather then forcing them to include it via nanomsg.h\n. Can you state that the patch is submitted under MIT license? Thanks!\n. Applied. You were also added to the AUTHORS file. Thanks!\n. The algorithm should be fully deterministic, just record the sequence of subscribes and unsubscribes you are doing and we should be able to reproduce the problem.\n. I've done some more experiments and I haven't been able to reproduce. Exact sequence of subscribes and unsubscribes would be really helpful.\n. This is a bug in the core library and has nothing to do with the bindings.\nAlso, it's a bug in a fully deterministic component (patricia trie implementation) guarded by a mutex, so there should be no concurrency issues. \n. Thanks! I'll have a look at it shortly.\n. Narrowed to the following sequence:\nS 0\nS 1\nS 2\nS 3\nS 4\nS 5\nS 6\nS 7\nS f\nS a\nU a\n. Fixed in de6a6f5.\n. Hi, can you state that the patch is submitted under MIT license?\nWe'll also need your name (in ascii) to add it to the AUTHORS file.\n. Yes, that's it.\nAlso keep in mind that you retain copyright to your patch, thus your name should be added to AUTHORS file that contains the names and email addresses of all copyright holders. Unfortunately, it's an ASCII file and thus pinyin is preferable to chinese  characters.\n. Merged and added to the AUTHORS file. Thanks!\n. At the moment no component in nanomsg has a need for returning errors from threads. Thus, it'll be just dead code.\nAre you planning to add some further features that would need this functionality? If so, it would be better to merge this patch with it.\n. Then submit the patch once you start using it, please.\nDead code is generally a bad practice as it allows for hidden bitrot.\n. Can you state the patch is submitted under MIT license? Alternatively, you can send me an email (sustrik@250bpm.com) saying \"Unless state otherwise, all my future patches for nanomsg project are licensed under MIT license.)\n. Merged, thanks!\n. Fixed in 9f0e4a8. Please, re-test and close the issue.\n. The files in question are generated from corresponding .xml files via xml2rfc tool (see xml.resource.org). If there's a problem with the RFC, please fix the .xml file and re-generate the .txt file. Thanks!\n. Ok. Fixed now.\n. Yes, ancillary data implementation is a mess now. Would you like to help to get it in order?\n. Right now the buffer simply contains the particular SP protocol header. We should probably change that to provide more structured content.\n. My take would be as follows:\nA single property that contains the whole SP header, in the exact wire format. From your point of view, you don't need to understand what's inside, just copy the data to/from msg.hdr.\nHowever, at same time we should allow for adding new properties in the future -- properties that won't go to the wire, rather they'll be used to control the network stack. There are already several feature requests that would need those. For example, once we allow for multiple parallel requests in req/rep we will have to attach a user-defined ID to each request.\n. First of all, all the data have to reside in a single memory chunk (see how nn_sendmsg and nn_recvmsg use a single control buffer).\nGiven the above, a simple sequence of your nn_cmsghdrItem structures should do (with a proper terminator item, e.g. one with cmsg_len==0).\nThat being said, keep in mind that the data in each item have to be properly aligned so that you won't end up with SIGBUS on RISC platforms.\n. Actually, the code in nn.h seems to try to do exactly that, thus it should be probably sufficient to make nn_sndmsg and nn_rcvmsg accept/return  ancillary data in that format, rather than deal with plain protocol message headers as is the case today.\n. Control data are now implemented in POSIX-compliant way.\n. Uh. My fault. I've accidentally checked in some work-in-progress code. Reverted. The CI build looks OK now,\n. Btw, why not use autotools to build with MinGW? IIRC is supported there, no?\n. Hi, I wanted to add you to the AUTHORS file, but I haven't found your name on GitHub. What should I add to the file?\n. Ah, you are already there. This matching between tags and real names gets confusing sometimes :)\n. Have a look at worker.h:30-34:\n```\nif defined NN_HAVE_WINDOWS\ninclude \"worker_win.h\"\nelse\ninclude \"worker_posix.h\"\n```\nIt looks like NN_HAVE_WINDOWS is not defined for some reason.\nendif\n. Could you possibly try to build using CMake+MSVC just to check whether the problem is with porting to Win64 in general, or just in MinGW on Win64?\n. I don't have Win64 OS to test it myself :(\n. Hi, can you state that the patch is submitted under MIT license? We will also need your real name to add to the AUTHORS file.\n. I see you are using mingw. Does the autotools build system work OK with MinGW? (I have no Windows box atm to check.)\n. Hi, I've reviewed and committed the small patches. Thanks!\nAs for the POLLSYS, the ugly thing is that it is not portable. On Windows SOCKET != int and thus cannot by passed to nn_poll().\nThus, it makes more sense to make user do the polling (using NN_SNDFDs and NN_RCVFDs) themselves IMO.\nAny better ideas?\n. I seem to recall that SOCKET resolved to void* once (Windows XP, maybe?)\n. http://stackoverflow.com/questions/1953639/is-it-safe-to-cast-socket-to-int-under-win64\nLooks like my comment above is wrong...\n. That would be a pretty bad backward-incompatible change to the API (e.g. nn_socket would return nn_fd rather than int). \nStill, see the SO question above. It seems that you were right and SOCKET can be cast to int.\n. Guh. I am not sure what the conclusion was here... Still, having to rely on Microsoft to be consistent with POSIX makes me feel pretty uncomfortable.\nWould you be OK with dropping the patch?\n. No. Just keep the issue open for now.\n. Fixed. Now the bind is re-tried once in a time until is succeeds.\n. No. nanomsg is a messaging library, not a general utility library. Exposing internals of the library to the user would make maintaining backward compatibility between versions very hard, if not impossible.\n. No, it's not nanomsg's job to provide utility functions such as sleep. These functions are used internally by nanomsg and are deliberately not exposed to the user.\nThat allows us to change them in the future if that's needed for whatever reason.\n. How can I reproduce the problem?\n. The problem should never occur. The assumption is that at most one byte is ever in the pipe.\nI'm closing the pull request.\n. Can you provide a test program to reproduce the issue? Thanks!\n. As for a quick fix, are you aware you can simply close the socket instead of doing nn_shutdown()?\n. Applied. Your name was also added to the AUTHORS file.\n. There's no need to do atomic_inc and atomic_dec when checking whether reference count. Reading an integer value is a single operation and thus atomic by definition. No need to lock the bus.\n. Sorry for the delay. I'll try to merge the patch either today or tomorrow.\n. I've also added you to AUTHORS file.\nAdditionally, I've created a man page for nn_reallocmsg(). Feel free to review and improve it!\n. Uh, sorry, fixed now.\n. Can you please state that the patch is submitted under MIT license?\n. Thanks!\n. Are you saying you want to implement UDP/SCTP transport for nanomsg?\n. Sure, it is. I am not sure whether you mean UDP and SCTP. Or SCTP over UDP.\nAs for UDP, it have been discussed on the mailing list already and it shouldn't be that hard to implement. You may want to check that discussion.\nAs for SCTP (whether over UDP or not) it has a rather broad range of features and you should first think of which ones you are interested in and how could they be provided to the nanomsg user via existing API.\n. Yes, there is. See the transport plugin API in transport.h header file.\n. Yes. It should be implemented as unreliable (and also as stateless). It's not nanomsg's job to change the characteristics of underlying transports.\n. Check the mailing list. Other people were working on IPC support on Windows. You can try to help them with the work.\n. Hi, I'm nanomsg IRC chatroom now. I may be able to answer some questions you may have.\n. Hi, can you state that the patch is submitted under MIT license?\n. Merged. Thanks!\n. Can you state that the patch is MIT-licensed? Unfortunately, unlike with GPL, the license of the project doesn't automatically propagate to the patches.\nIf you want to make more contributions you can just send an email to the mailing list saying \"all my future conributions to nanomsg, unless stated otherwise, are licensed under MIT/X11 license.\n. Thanks! I've also added your name to AUTHORS file.\n. OK.\n. That's on the Solaris box, right? Note that it's a long-standing problem, not a new one.\nThere are 3 possible causes:\n1. nanomsg doesn't work on Solaris\n2. nanomsg doesn't work on SPARC microarchitecture\n3. nanomsg doesn't work on very slow boxes\n. Possibly.\n. Lingering is a tricky functionality. I doubt it is implemented correctly now.\nUltimately the behaviour should look like this: If there is a message waiting for being written to the kernel buffer, wait at most LINGER period, till it is written. If it is not, abort the writing. If it is, compute the time remaining from the LINGER period and set that as SO_LINGER on they underlying OS socket.\nFor now though, a simple approximation would be to set the LINGER period on the underlying socket and don't care about the message lingering on the nanomsg level.\n. Can you state that the patch is submitted under MIT license? I will also need such statement from Timothee as his patches are part of this patchset.\n. Hi Vlad,\nI've reviewed the patch and I've realised there's a conceptual problem here...\nYes, bind should not assert, however, similarly to connect it should not return an error but rather try to re-bind later on.\nThe reason is that interface (especially wi-fi) may not be available right now, but it may become available later on.\nMartin\n. There's nn_shutdown() that you can use to unbind.\n. Yes, that would be great.\n. @TTimo: can you confirm that your patches contained here are under MIT license?\n. Hi, I've reviewed the patches. They look OK. However, there are merge conflicts with the current mainline. Can you resolve those? Once done, I'll merge the patch.\n. @lygstate: What content? What i see is tht github reports merge conflicts: \"We can\u2019t automatically merge this pull request.Use the command line to resolve conflicts before continuing.\"\nIs that wrong? Have you been able to merge without conflicts?\n. Tried that. I still see conflicts. Here's one for example:\n```\n<<<<<<< HEAD\nnn_assert (optlen < INT_MAX);\nrc = setsockopt (self->s, level, optname, (char) optval, (int) optlen);\nif (nn_slow (rc == SOCKET_ERROR))\n    return -nn_err_wsa_to_posix (WSAGetLastError ());\n=======\nif (self->domain == AF_UNIX)\n{\n    / TODO: implement Named Pipe setsockopt /\n    rc = 0;\n}\nelse\n{\n    rc = setsockopt(self->s, level, optname, (char)optval, optlen);\n    if (rc == SOCKET_ERROR)\n        winerror = WSAGetLastError();\n}\n\n\n\n\n\n\n\nec51f43faf1b0db53dc56b65a92149771c32b28d\n```\n. Hey, aren't you speaking of minor-fixes branch rather than win-pipe one?\n. Would you mind to join the IRC channel to sort this out?\n. Can you state that the patch is licensed under MIT license? Thanks!\n. Merged to the mainline. Thanks!\n. Merged. Thanks!\n. Who's defining the NO_NN_EXPORTS macro? It doesn't seem to be set anywhere.\n. Yes, I'll rename it myself.\n\n\n\n\n\n\n\nWhat about moving the other lines of code around? Was there any reason for that?\n. Merged into mainline. Thanks!\n(I've also added you to the AUTHORS file.)\n. See here: http://build.nanomsg.org/builders/nanomsg-macosx/builds/102/steps/compile/logs/stdio\n. This is probably a clang issue. The build in the CI uses gcc. Actual command lines executed during the compilation may be helpful...\n. Merged into mainline. Thanks!\n. Merged into mainline. Thanks!\n. Merged to mainline. Thanks! I've also added your name to the AUTHORS file.\n. Can you state that the patch is submitted under MIT license?\n. Thanks!\n. Pulled to the mainline. Thanks!\nI've also modified the CMake build system to reflect the change file paths. Tested on win32.\n. Applied to mainline. Thanks!\n. Committed to the mainline. I've modified the text to correct the binary zero stuff. Thanks!\n. If you think it's not clear just modify the text and send a patch.\nOne way to make it clear comes to mind is modifying the example in such a way there's no final zero involved:\nchar topic[] = {'a', 'b', 'c'};\n. Done. Thanks!\n. Nice spot!\nCan you state that you submit your patch under MIT license?\nAlso, what name should I add to AUTHORS file?\n. Applied to master. Thanks!\n. Applied to master. Thanks!\n. You may want to check your OS distro for availability of the binary package.\n. Can you  state that you are submitting the patch under MIT license?\n. Applied to the master. Thanks!\nI've also added your name to the AUHORS file.\n. I've improved the assertion so that it reports the type of error. The issue should be re-open afterwards.\n. Yes, they should return ETERM instead.\n. Can you state that the patch is submitted under MIT license? Thanks!\n. Applied to the master. Thanks!\n. Can you state it's licensed under MIT/X11 license?\n. Applied to master. Thanks!\n. Applied to mainline. Thanks!\n. Applied the mainline. Thanks!\nI've also added you to the AUHORS file.\n. Why export nn_atomic_* functions?\n. As for the NN_EXPORT stuff, just include atomic.c into the test (other tests are doing similar trick with thread.c and such.)\n. Applied to master. Thanks!\n. In theory, a device can be written that has 3rd, \"admin\" socket that can be used to send it commands, such as \"stop\".\n. You can do it youself, just use 3 sockets. 2 worker sockets would work the same as now (sending messages from one to another and vice versa), as for thr 3rd, if there's an incoming message, just exit the loop.\n. The whole NN_PIPE_PARSED is a mere optimisation (so that inproc transport doesn't have to copy the message body) and as such should not be leaked to the user.\nCan we discuss this a little bit more? From the email you've sent I don't fully understand the problem you are encountering. Does the message from inproc transport differ from message from tcp transport when it is passed to the user? If it does, I would consider that to be a bug.\n. Are you saying that request received from REQ socket via inproc transport doesn't contain the request ID? If so, it's definitely a bug.\n. Ok. So I open a REQ/REP socket pair connected via inproc. I pass REP socket to a device. Then i send message to REQ socket. Device sees a message without request ID. Correct?\n. Confirmed. I'll open an issue to fix this.\n. Here's a C program to reproduce the problem:\n```\ninclude \ninclude \ninclude \ninclude \ninclude \nint main ()\n{\n    char buf[16];\nint req = nn_socket (AF_SP, NN_REQ);\nassert (req >= 0);\nint rc = nn_connect (req, \"inproc://test\");\nassert (rc >= 0);\nint rep = nn_socket (AF_SP, NN_REP);\nassert (rep >= 0);\nrc = nn_bind (rep, \"inproc://test\");\nassert (rc >= 0);\nrc = nn_close (rep);\nassert (rc == 0);\nsleep (1);\nrep = nn_socket (AF_SP, NN_REP);\nassert (rep >= 0);\nrc = nn_bind (rep, \"inproc://test\");\nassert (rc >= 0);\nrc = nn_close (rep);\nassert (rc == 0);\n\nreturn 0;\n\n}\n```\n. The problem is caused by the fact that the endpoint entries in inproc registry are not updated properly when the peer socket is closed.\n. As discussed elsewhere this is basically an protocol bug. We should augment the SURVEYOR messages with backtrace headers, same way as we do that with REQREP messages.\n. Applied to the mainline. Thanks!\n. I'm working from command line.\nYes, the library will end up in .lib folder. You can install it using 'sudo make install'.\n--enable-debug will cause debug symbols to be present in the library\n32bit on 64bit requires cross-compilation. Google for \"automake\" and \"cross compilation\".\n. Great! I'll try to code-review it during the weekend.\n. Hi Michael,\nThere's only one inline function and I think we should make it non-inlined and move it to the library.\nWould you like to do that?\n. Merged. Thanks!\n. Fixed in master by commit cec67f2. Please, re-check!\n. Fixed.\n. In common timeout scenarios the socket should return EAGAIN (see POSIX for details). ETIMEOUT is used for specifc SP-level timeouts such as \"the survey expired\". I'mcClosing the issue.\n. Hi, can you state that the patch is submitted under MIT license?\n. -----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\nOn 30/10/14 16:30, Vlad Seryakov wrote:\n\nHi, do i need to do anything else? just checking\n\nNo nothing is needed, I'll merge it soonish.\nThanks!\nMartin\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\niQEcBAEBAgAGBQJUUmaQAAoJENTpVjxCNN9YwW0H/0FiXI+udllcy0TfTxq/4oUS\nofp2Mlq1d9tj1KEk6Rx/0Ggd7ratgSz/qs13LFDEe0TNq4Q5uibyNFdpNzGQMtt/\n7rFoNDl7STs6lGAvxhVTr5Zfn3+ds9Qe+p11PObB4osJqaHUxb+4jkUhnrN9KMyT\ncvupDcLIMEUEU84srfxBb+HfcsShYFOy1cjOkNkbcb3PVNyZiL71nzUWRp8Q52fo\n8qIQfse66mgT45tsCaquB1YedtDY5CWxzkf+g9BNQa18E57MNhkRrhhOX4Ag+cKO\nkOEP4cclJZ7vJ4vGhZ8/EGHmsYnuSuhbZPHQ5QlLkMgEsxZW7wyI5gcvUi6aRhs=\n=Rud2\n-----END PGP SIGNATURE-----\n. Why nn_geterrno()? The failure to bind should be invisible to the user, same way as failure to connect is. Any errors can be possibly exposed via the monitoring system, as Paul suggests.\n. This probably has to do with access rights. If the tests can't create IPC files because of insufficient rights, they'll fail in this fashion.\n. Can you confirm that the patch is submitted under MIT license?\n. Applied to master. Thanks!\n. Fixed. Thanks for spotting this!\n. I am not sure about this. In pub/sub scenario the sender should not blocked (for arbitrarily long time interval) just because there's no one listening.\nIn the radio analogy it would be like a radio broadcaster holding off while nobody is listening and then broadasting all the stale news that have accumulaed in the meantime.\n. I was commenting based on the patch -- it causes publisher to delay if there's no one connected. How do you know that the sub is connected? Connect is asynchronous and takes a while, Maybe more time on Windows than on Linux? Have you tried with, say, nn_sleep(1000) instead of nn_sleep(10)?\n. Also look here: http://stackoverflow.com/questions/26667440/how-to-identify-pushback-under-win-iocp\nTL;DR: \"By tracking the number of pending send operations you can decide to do something different once the number gets too high.\" In other words, IOCP API is crappy and doesn't necessarily inform you about TCP/IPC pushback. You have to count the amount of outstanding data to send by hand :(\n. -----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\nHi,\nI've tested the scenario with the attached test program. It seems to\nwork OK. Can you provide a minimal program to reproduce the problem?\nThanks!\nMartin\nOn 23/10/14 14:48, ddway2 wrote:\n\nHi My behavior is the following:\n- when i used 1 subscribing, pubsub in IPC flood work fine * when i\n  used 2 or more subscribing, pubsub in IPC flood drop packet\nIf i switch in TCP mode, i have no problem but it isnt good\nsolution\nI'm under Linux Debian jessie with gcc 4.9\n\u2014 Reply to this email directly or view it on GitHub \nhttps://github.com/nanomsg/nanomsg/issues/321.\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.11 (GNU/Linux)\niQEcBAEBAgAGBQJUSP8aAAoJENTpVjxCNN9YF7wIAJXqxhT9wwiRTl8VirPDnBNH\n1e2LXMIBPucenZguXaeJcSb2w+2dAIz0Ol+VW/ed9CLjOJFdWgiv8bfD6TQu+9uN\nGbY83ZkXSnDyM/zitUz5/nXR4khgyoOZ72cjJEMgXZP8GsKwWG02aN7JNMlZeSP/\nFdTyawpVzQQhhu/PhbUSZcGaYFal+xCHKCnM+v4bk2bGNnJSTQqs3kn63KbhW8pY\nclCm+FiQ/OaaKip+wD9mjMtnCboB1FJDDAj2NOSixIpbdnICcJc7NuGNPOiK9v+I\nLBWBUI2zizCmfHTynRkwMmD8KTkigizYvAxjmDg6weQ/qVfriC+CjR4sDnq4gm0=\n=+GYG\n-----END PGP SIGNATURE-----\n. Here's the test code:\n```\ninclude \ninclude \ninclude \ninclude \ninclude \nint main ()\n{\n    int rc;\n    int p;\n    int s1;\n    int s2;\n    char buff [3];\np = nn_socket (AF_SP, NN_PUB);\nassert (p != -1);\nrc = nn_bind (p, \"ipc://test.ipc\");\nassert (rc != -1);\n\ns1 = nn_socket (AF_SP, NN_SUB);\nassert (s1 != -1);\nrc = nn_connect (s1, \"ipc://test.ipc\");\nassert (rc != -1);\nrc = nn_setsockopt (s1, NN_SUB, NN_SUB_SUBSCRIBE, \"\", 0);\nassert (rc == 0);\n\ns2 = nn_socket (AF_SP, NN_SUB);\nassert (s2 != -1);\nrc = nn_connect (s2, \"ipc://test.ipc\");\nassert (rc != -1);\nrc = nn_setsockopt (s2, NN_SUB, NN_SUB_SUBSCRIBE, \"\", 0);\nassert (rc == 0);\n\nsleep(1);\n\nrc = nn_send (p, \"ABC\", 3, 0);\nassert (rc != -1);\n\nrc = nn_recv (s1, buff, sizeof (buff), 0);\nassert (rc != -1);\n\nrc = nn_recv (s2, buff, sizeof (buff), 0);\nassert (rc != -1);\n\nreturn 0;\n\n}\n```\n. This is not possible because peers come and go. Nobody knows how many peers there are therefore nobody knows when all have responded. The only way to handle this is timeout.\nWhat you, as a used, can do though, if you know what the number of peers is, is waiting for N replies and ending the survey afterwards. Be aware though that if one of the peers fails, the survey would go on forever.\n. Can you give some examples of TP headers that are relevant for nanomsg user?\n. It could also be done when the listening socket is closed...\n. Fixed in the mainline.\n. Thanks!\n. Merged to mainline. I've also added you to the AUTHORS file.\nThanks!\n. Do you submit the patch under MIT license?\n. Would you mind replacing \"ADDRESS_FAMILY\" in win.h by \"short\" and reporting back whether it helped?\n. What version of Windows is that, btw?\n. Can you make a patch for the limits.h thing?\n. An #undef maybe?\n. I've replaced ADDRESS_FAMILY by short in the mainline.\n. I've played with CancelIo and CancelIoEx when implementing Windows port. You can replace one by another, but it looks like there's some kind of bug in CancelIo which doesn't occur with CancelIoEx.\n. Hm, interesting. Configure believes eventfd is present:\nchecking for eventfd... yes\nLooking into configure.ac, it is generated by this line:\nAC_CHECK_FUNCS([eventfd], [AC_DEFINE([NN_HAVE_EVENTFD])])\nNot sure what's happening. Maybe the function exists in libc, but the header file is missing.\nWould you mind adjusting configure.ac in such a way that it check for sys/eventfd.h header and reporting back whether it helped?\n. Try this:\nAC_CHECK_HEADERS([sys/eventfd.h], [AC_DEFINE([NN_HAVE_EVENTFD])])\n. Just build the package (make dist) on a modern system and use that package on your vintage system.\n. Applied to the mainline. Thanks!\n. Fixed by 9862e2b.\n. Ok, I've fixed the problem in a bit different way in the mainline. Can you check whether it helped?\nBtw, if you have an OpenBSD box with public IP address we can add it to build cluster to make sure that OpenBSD port is always functional.\n. I am using autoconf-2.68 automake-1.11.3, libtool-2.4.2.\n. Can you state that the patch is submitted under MIT license?\n. I've applied the patch to the mainline. Thanks!\nOne caveat is that SP_HDR property is copied into both nn_msg.sphdr and nn_msg.hdrs. Can be fixed later though.\nAs for the second patch, I still don't get the use case for using both utf8 and binary messages. If we don't consider speaking to arbitrary websocket services as a use case, there seems to be no reason not to pass all the messages as binary.\n. I've separated SP_HDR property (which is the only one used by SP protocols) into a separate field for both convenience and performance reasons.\nConsider the case where REP socket adds 4 bytes to SP_HDR. If all the props were held in a single buffer, all the props following SP_HDR would have to shift by 4 bytes, cmsg header would have to be updated, any previously retrieved cmsg pointers would possibly become invalid etc.\n. Applied to the mainline. Thanks!\n. Can you state that the patch is submitted under MIT license?\n. Ok. Undestood. Applied to the mainline. Thanks!\n. Can you state that you are submitting the patch under MIT license?\n. No need, thanks!\n. You'd have to deal with Windows somehow where ssize_t is not defined.\n. I don't think it needs to be atomic. If the reference count have already dropped to 1, there's nobody else out there who could increase it.\n. IIRC is it used for asynchronous DNS queries (getaddrinfo_a).\n. IIRC this way of doing things dates back to mid 2000's when we had problems with slow gettimeofday() on some (older?) systems. Good to hear it's not needed anymore.\n. ",
    "waywardmonkeys": "I submit this patch under the MIT/X11 license.\nMy email address is bruce.mitchener at gmail.com\n. Updated for your recent changes to apply again.\n. The full struct definition on OS X is:\nc\nstruct sockaddr_in {\n        __uint8_t       sin_len;\n        sa_family_t     sin_family;\n        in_port_t       sin_port;\n        struct  in_addr sin_addr;\n        char            sin_zero[8];\n};\nThe error is:\n``` c\ndefine EADDRNOTAVAIL 49    / Can't assign requested address /\n```\nThere are several discussions around on the net about needing to zero out the address, perhaps due to sin_len not getting set otherwise.\n. This was fixed in 5ac0c04aaedf435dfc5c26a3de8c0af7ecd75d16.\n. Okay, that fixed this problem.\n. Spoke too soon. tcp still fails (once the memset is in place) and the stack traces look similar to above.\n. Correct.\n. I hadn't tried in a while. The tcp test blocks / hangs on Mac OS X. Is it expected to work?\nThe 3 thread stacks are roughly similar to the above:\n```\n(gdb) thread 1\n[Switching to thread 1 (process 11710), \"com.apple.main-thread\"]\n0x00007fff872600fa in __psynch_cvwait ()\n(gdb) bt\n0  0x00007fff872600fa in __psynch_cvwait ()\n1  0x00007fff9382af89 in _pthread_cond_wait ()\n2  0x000000010000bb4d in sp_cond_wait ()\n3  0x0000000100007773 in sp_sock_send ()\n4  0x0000000100006876 in sp_send ()\n5  0x000000010000155c in main ()\n(gdb) thread 2\n[Switching to thread 2 (process 11710)]\n0x00007fff87260f96 in poll ()\n(gdb) bt\n0  0x00007fff87260f96 in poll ()\n1  0x000000010000e1fe in sp_poller_wait ()\n2  0x0000000100009563 in sp_cp_worker ()\n3  0x000000010000ea83 in sp_thread_main_routine ()\n4  0x00007fff93826742 in _pthread_start ()\n5  0x00007fff93813181 in thread_start ()\n(gdb) thread 3\n[Switching to thread 3 (process 11710)]\n0x00007fff87260f96 in poll ()\n(gdb) bt\n0  0x00007fff87260f96 in poll ()\n1  0x000000010000e1fe in sp_poller_wait ()\n2  0x0000000100009563 in sp_cp_worker ()\n3  0x000000010000ea83 in sp_thread_main_routine ()\n4  0x00007fff93826742 in _pthread_start ()\n5  0x00007fff93813181 in thread_start ()\n(gdb)\n```\n. This seems fine to me now.\n. I submit this patch under the terms of the MIT/X11 license.\n. From clang:\n/.../nanomsg/src/utils/aio.c:537:1: warning: control may reach end of non-void function [-Wreturn-type]\nThat was due to it asserting if it got there ... and the assert macro was ending with the call to sp_err_abort(), so making that noreturn got rid of that warning.  (After your last changes, the warning moved to usock.c.)\n. One moment... fixing this pull request to include fixes for that.\n. Done.  I did this to find them:\ngrep -r -A 2 \"assert (0)\" . | grep return\n. You merged this separately from the pull request, so closing...\n. See the most recent commit on https://github.com/waywardmonkeys/nanomsg/commits/misc-fixes ...\n. Did a force push with a new commit that amends the last to be what you suggested.\n. 35126714aa2373c342360d038c341b906ed4501a\n. This patch is provided under the terms of the MIT license.\n. This patch is provided under the terms of the MIT license.\n. Mac OS X has a pthread_cond_timedwait_relative_np which may be useful here ... but looking at some source from Apple's libc, it just uses gettimeofday to get an absolute timespec:\nhttp://www.opensource.apple.com/source/Libc/Libc-167/pthreads.subproj/pthread_cond.c\n. Have you considered just using gettimeofday()? The code that you added is really slow. You'd also be better off just using mach_absolute_time and mach_timebase_info (which would be more accurate than using gettimeofday)\n. @schmurfy I didn't test it myself, but I'd google to look into this earlier when I filed issue #10 ... and saw some notes about how slow using this mechanism was. :)\nEveryone that I know that does timers on OS X uses mach_absolute_time (like in games, language runtimes, etc) and that's what Apple tends to recommend.\n. Right, it is a bit hard to do. :)\nEven Apple just uses gettimeofday. See the relative time support in http://www.opensource.apple.com/source/Libc/Libc-167/pthreads.subproj/pthread_cond.c\n. One moment and I'll push a branch with how I would fix this.\n. So, I would do this:\nhttps://github.com/waywardmonkeys/nanomsg/commit/28f0a38f25d5c4fb8767f1af812088ffa8d359db\nPerhaps with an extra check in CMakeLists.txt for clock_gettime and pthread_cond_setclock and making the #if checks in cond.c a bit more specific than just SP_HAVE_CLOCK_MONOTONIC.\n. That commit that I just referenced is, of course, available under the terms of the MIT license.\n. I've put an updated form of that and a couple of other fixes in this pull request:\nhttps://github.com/250bpm/nanomsg/pull/12\n. Everything builds and passes tests on OS X with pull request #12!\n. This patch is made available under the terms of the MIT license.\n. These changes are made available under the terms of the MIT license.\n. This is available under the terms of the MIT license.\n. This is available under the terms of the MIT license.\n. Confirmed fixed.\n. This is available under the terms of the MIT license.\n. ",
    "schmurfy": "I just tried today on Mac OS X 10.8.2, one test is failing but there is no lockup (I will open another issue for the failure).\n. I did a test with remote_lat and local_lat using an ipc endpoint and it worked too, it fails with tcp but it may be related to issue #7\n. great now all tests pass on os x !\n. I tried to fix it in #11, there are multiple issues related to monotonic time under OS X due to missing functions.\nAfter some more research on this matter (I already submitted a patch on another related clock_gettime issue) I am really not sure what is the preferred way and which one is more performant :/\nAnyway since OS X will certainly be more used as a development platform than in production my fix should be enough.\n. I know you don't like pull requests and I partly understand this for big changes which need a long review process but if we could work with pull request for small patches like this it would really make things easier :)\nThat said If you really insist I can send you the patch by email.\n. I used mach_absolute_time in my previous patch (function sp_clock_time in clock.c) but from the informations I found I still have no real clue as to what is the most efficient way to do it :(\nWhat makes you say this is slow ? did you make some tests ?\nIf you have more data on this I take it :p\n@sustrik ok, maybe in the commit messages then ? It looks like any message posted here is editable even after the pull request is closed...\n. @sustrik good point, I need to dig it some more.\n. ok I will try to make a mach_absolute_time based implementation later.\nI also found mention about it being slow but not enough to make a real opinion about this.\nI also checked for an existing implementation of clock_gettime using mach_absolute_time but found none :/\n. ok I will just use a gettimeofday based implementatin then, I may find the time to do it later today.\nI never liked emails for this and honestly never really contributed much before github existed for simple reasons: if I find a bug which could be fixed in a two line patch I don't want to waste 30min trying to figure out:\n- who to send to patch to\n- which format the patch should have\nIt may fall in the \"lazy\" case but that's just the truth, the rare projects I contributed to before github all had different workflows and some were wel hidden in the depth of their website / mailing list.\nThere is also many non obvious advantages to pull requests:\n- you can rebase the work on master in seconds once you know how to do it so the patch stays current and ready to be merged (which also ease the merging side for the author/maintainers)\n- you can discuss specific lines of the patch with all the goodies of github messages like syntax coloring\n- you can discuss the whole patch as we do in an better organized fashion (again with formatting, syntax coloring, you \"ping\" someone with the \"@\" prefix, link other issues, ...)\nbut I will send you the patch one this is ready to be merged :)\n. I changed to use a gettimeofday implementation and sent you an email to certify my patches will be submitted under MIT license.\nWith the tcp issue fixed all tests are now passing, now I can try to play with it :p\n@waywardmonkeys what do you think of this patch ?\n. no problem with this patch, as long as the problem get fixed that's fine for me :)\n. ah ok :)\n. looks there is something weird with gh caches, the front page still show README.asciidoc for me even when the file is no longer listed in the view above it xD\n. ",
    "nirs": "Can you test again with current version?\n. white:build nirs$ ./inproc\nAssertion failed: !self->first (/Users/nirs/nanomsg/src/utils/list.c:38)\nAbort trap\n. (gdb) run\nStarting program: /Users/nirs/nanomsg/build/inproc \nAssertion failed: !self->first (/Users/nirs/nanomsg/src/utils/list.c:38)\nProgram received signal SIGABRT, Aborted.\n0x00007fff8a0460b6 in __kill ()\n(gdb) bt\n0  0x00007fff8a0460b6 in __kill ()\n1  0x00007fff8a0e69f6 in abort ()\n2  0x000000010000faf8 in nn_err_abort () at /Users/nirs/nanomsg/src/utils/err.c:33\n3  0x0000000100010ab9 in nn_list_term (self=0x1010019c0) at /Users/nirs/nanomsg/src/utils/list.c:38\n4  0x000000010000f49a in nn_dist_term (self=0x1010019c0) at /Users/nirs/nanomsg/src/utils/dist.c:36\n5  0x0000000100013c45 in nn_pub_term (self=0x101001400) at /Users/nirs/nanomsg/src/protocols/pubsub/pub.c:90\n6  0x0000000100013c6d in nn_pub_destroy (self=0x101001400) at /Users/nirs/nanomsg/src/protocols/pubsub/pub.c:100\n7  0x0000000100009323 in nn_sock_destroy (self=0x101001400) at /Users/nirs/nanomsg/src/core/sock.c:101\n8  0x0000000100006f53 in nn_close (s=0) at /Users/nirs/nanomsg/src/core/ctx.c:398\n9  0x0000000100002b2f in main () at /Users/nirs/nanomsg/tests/inproc.c:121\n. Seems to be fixed, 100 runs pass without failures.\n. Another crash example:\n```\nProcess:         ipc [26194]\nPath:            /Users/nirs/nanomsg/build/ipc\nIdentifier:      ipc\nVersion:         ??? (???)\nCode Type:       X86-64 (Native)\nParent Process:  ctest [26192]\nDate/Time:       2013-02-16 17:05:59.616 +0200\nOS Version:      Mac OS X 10.6.8 (10K549)\nReport Version:  6\nInterval Since Last Report:          1957649 sec\nCrashes Since Last Report:           116\nPer-App Crashes Since Last Report:   20\nAnonymous UUID:                      916F01C4-2ADF-447C-9156-6C2A75B0D5BA\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nCrashed Thread:  1\nApplication Specific Information:\nabort() called\nThread 1 Crashed:\n0   libSystem.B.dylib               0x00007fff8a06a9ce __semwait_signal_nocancel + 10\n1   libSystem.B.dylib               0x00007fff8a06a8d0 nanosleep$NOCANCEL + 129\n2   libSystem.B.dylib               0x00007fff8a0c73ce usleep$NOCANCEL + 57\n3   libSystem.B.dylib               0x00007fff8a0e6a00 abort + 93\n4   libnanomsg.dylib                0x000000010000fabe nn_err_errno + 0 (err.c:37)\n5   libnanomsg.dylib                0x000000010000b66b nn_usock_tune + 145 (aio_posix.inc:224)\n6   libnanomsg.dylib                0x000000010000b553 nn_usock_init_child + 335 (aio_posix.inc:200)\n7   libnanomsg.dylib                0x000000010000da70 nn_astream_init + 354 (astream.c:74)\n8   libnanomsg.dylib                0x000000010000dcb6 nn_bstream_listening_accepted + 132 (bstream.c:98)\n9   libnanomsg.dylib                0x000000010000c35c nn_cp_worker + 1873 (aio_posix.inc:482)\n10  libnanomsg.dylib                0x000000010001292a nn_thread_main_routine + 232 (thread.c:85)\n11  libSystem.B.dylib               0x00007fff8a030fd6 _pthread_start + 331\n12  libSystem.B.dylib               0x00007fff8a030e89 thread_start + 13\n```\n. ipc test still crashes randomally - here is an example run using version 3cbb6644c873701f5350b853d417fa26381a6215:\nwhite:build nirs$ i=0; while test $((i++)) -le 30; do echo -n \"test $i ..\"; ./ipc && echo ok; done\ntest 1 ..ok\ntest 2 ..ok\ntest 3 ..ok\ntest 4 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 5 ..ok\ntest 6 ..ok\ntest 7 ..ok\ntest 8 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 9 ..ok\ntest 10 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 11 ..ok\ntest 12 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 13 ..ok\ntest 14 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 15 ..ok\ntest 16 ..ok\ntest 17 ..ok\ntest 18 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 19 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 20 ..ok\ntest 21 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 22 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 23 ..ok\ntest 24 ..ok\ntest 25 ..ok\ntest 26 ..ok\ntest 27 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 28 ..ok\ntest 29 ..ok\ntest 30 ..Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\n. Another crash report using version 3cbb6644c873701f5350b853d417fa26381a6215\n```\nProcess:         ipc [35735]\nPath:            /Users/nirs/nanomsg/build/ipc\nIdentifier:      ipc\nVersion:         ??? (???)\nCode Type:       X86-64 (Native)\nParent Process:  bash [14634]\nDate/Time:       2013-02-17 21:16:17.564 +0200\nOS Version:      Mac OS X 10.6.8 (10K549)\nReport Version:  6\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nCrashed Thread:  1\nApplication Specific Information:\nabort() called\nThread 1 Crashed:\n0   libSystem.B.dylib               0x00007fff8a06a9ce __semwait_signal_nocancel + 10\n1   libSystem.B.dylib               0x00007fff8a06a8d0 nanosleep$NOCANCEL + 129\n2   libSystem.B.dylib               0x00007fff8a0c73ce usleep$NOCANCEL + 57\n3   libSystem.B.dylib               0x00007fff8a0e6a00 abort + 93\n4   libnanomsg.dylib                0x000000010000fabe nn_err_errno + 0 (err.c:37)\n5   libnanomsg.dylib                0x000000010000b66b nn_usock_tune + 145 (aio_posix.inc:224)\n6   libnanomsg.dylib                0x000000010000b553 nn_usock_init_child + 335 (aio_posix.inc:200)\n7   libnanomsg.dylib                0x000000010000da70 nn_astream_init + 354 (astream.c:74)\n8   libnanomsg.dylib                0x000000010000dcb6 nn_bstream_listening_accepted + 132 (bstream.c:98)\n9   libnanomsg.dylib                0x000000010000c35c nn_cp_worker + 1873 (aio_posix.inc:482)\n10  libnanomsg.dylib                0x000000010001292a nn_thread_main_routine + 232 (thread.c:85)\n11  libSystem.B.dylib               0x00007fff8a030fd6 _pthread_start + 331\n12  libSystem.B.dylib               0x00007fff8a030e89 thread_start + 13\n```\n. And a gdb run example:\n```\nwhite:build nirs$ gdb ipc\nGNU gdb 6.3.50-20050815 (Apple version gdb-1515) (Sat Jan 15 08:33:48 UTC 2011)\nCopyright 2004 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"x86_64-apple-darwin\"...Reading symbols for shared libraries ... done\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nReading symbols for shared libraries ++. done\nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nInvalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nProgram received signal SIGABRT, Aborted.\n0x00007fff8a032a6a in __semwait_signal ()\n(gdb) thread apply all bt\nThread 2 (process 35800):\n0  0x00007fff8a06a9ce in __semwait_signal_nocancel ()\n1  0x00007fff8a06a8d0 in nanosleep$NOCANCEL ()\n2  0x00007fff8a0c73ce in usleep$NOCANCEL ()\n3  0x00007fff8a0e6a00 in abort ()\n4  0x000000010000fabe in nn_err_abort () at /Users/nirs/nanomsg/src/utils/err.c:33\n5  0x000000010000b66b in nn_usock_tune (self=0x100200008, sndbuf=131072, rcvbuf=131072) at aio_posix.inc:222\n6  0x000000010000b553 in nn_usock_init_child (self=0x100200008, parent=0x100100178, s=10, sink=0x100200000, sndbuf=131072, rcvbuf=131072, cp=0x100801410) at aio_posix.inc:195\n7  0x000000010000da70 in nn_astream_init (self=0x100200000, epbase=0x1001000c8, s=10, usock=0x100100178, bstream=0x1001000c0) at /Users/nirs/nanomsg/src/utils/astream.c:72\n8  0x000000010000dcb6 in nn_bstream_listening_accepted (self=0x1001000c0, usock=0x100100178, s=10) at /Users/nirs/nanomsg/src/utils/bstream.c:97\n9  0x000000010000c35c in nn_cp_worker (arg=0x100801410) at aio_posix.inc:481\n10 0x000000010001292a in nn_thread_main_routine (arg=0x1008018f8) at /Users/nirs/nanomsg/src/utils/thread.c:84\n11 0x00007fff8a030fd6 in _pthread_start ()\n12 0x00007fff8a030e89 in thread_start ()\n(gdb) thread 2\n[Switching to thread 2 (process 35800)]\n0x00007fff8a06a9ce in __semwait_signal_nocancel ()\n(gdb) bt full\n0  0x00007fff8a06a9ce in __semwait_signal_nocancel ()\nNo symbol table info available.\n1  0x00007fff8a06a8d0 in nanosleep$NOCANCEL ()\nNo symbol table info available.\n2  0x00007fff8a0c73ce in usleep$NOCANCEL ()\nNo symbol table info available.\n3  0x00007fff8a0e6a00 in abort ()\nNo symbol table info available.\n4  0x000000010000fabe in nn_err_abort () at /Users/nirs/nanomsg/src/utils/err.c:33\nNo locals.\n5  0x000000010000b66b in nn_usock_tune (self=0x100200008, sndbuf=131072, rcvbuf=131072) at aio_posix.inc:222\nrc = -1\nopt = 48\nflags = 1\nonly = 8393728\n\n6  0x000000010000b553 in nn_usock_init_child (self=0x100200008, parent=0x100100178, s=10, sink=0x100200000, sndbuf=131072, rcvbuf=131072, cp=0x100801410) at aio_posix.inc:195\nNo locals.\n7  0x000000010000da70 in nn_astream_init (self=0x100200000, epbase=0x1001000c8, s=10, usock=0x100100178, bstream=0x1001000c0) at /Users/nirs/nanomsg/src/utils/astream.c:72\nsndbuf = 131072\nrcvbuf = 131072\nsz = 4\n\n8  0x000000010000dcb6 in nn_bstream_listening_accepted (self=0x1001000c0, usock=0x100100178, s=10) at /Users/nirs/nanomsg/src/utils/bstream.c:97\nbstream = (struct nn_bstream *) 0x1001000c0\nastream = (struct nn_astream *) 0x100200000\n\n9  0x000000010000c35c in nn_cp_worker (arg=0x100801410) at aio_posix.inc:481\nrc = 0\nself = (struct nn_cp *) 0x100801410\ntimeout = -1\nqit = (struct nn_queue_item *) 0x0\nophndl = (struct nn_cp_op_hndl *) 0x0\ntohndl = (struct nn_timeout_hndl *) 0x0\ntimer = (struct nn_timer *) 0x0\nop = 1\nphndl = (struct nn_poller_hndl *) 0x10010018c\nit = (struct nn_queue_item *) 0x0\nevent = (struct nn_event *) 0x0\nusock = (struct nn_usock *) 0x100100178\nsz = 0\nnewsock = 10\n\n10 0x000000010001292a in nn_thread_main_routine (arg=0x1008018f8) at /Users/nirs/nanomsg/src/utils/thread.c:84\nrc = 0\nsigset = 4294967295\nself = (struct nn_thread *) 0x1008018f8\n\n11 0x00007fff8a030fd6 in _pthread_start ()\nNo symbol table info available.\n12 0x00007fff8a030e89 in thread_start ()\nNo symbol table info available.\n```\n. Randomallly?\n. In this run, I changed number of threads to 1, because I suspected that the kernel decided to limit the buffer size when there were too many sockets open. It does not seems to change the picture.\nwhite:build nirs$ i=0; while test $((i++)) -le 30; do echo -n \"test $i .. \"; ./ipc && echo ok; done\ntest 1 .. ok\ntest 2 .. ok\ntest 3 .. ok\ntest 4 .. ok\ntest 5 .. Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 6 .. ok\ntest 7 .. ok\ntest 8 .. ok\ntest 9 .. ok\ntest 10 .. ok\ntest 11 .. Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 12 .. ok\ntest 13 .. Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\ntest 14 .. ok\ntest 15 .. ok\ntest 16 .. ok\ntest 17 .. ok\ntest 18 .. ok\ntest 19 .. ok\ntest 20 .. ok\ntest 21 .. ok\ntest 22 .. ok\ntest 23 .. ok\ntest 24 .. ok\ntest 25 .. ok\ntest 26 .. ok\ntest 27 .. ok\ntest 28 .. ok\ntest 29 .. ok\ntest 30 .. ok\ntest 31 .. Invalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:222)\nAbort trap (core dumped)\n. I tried this to check which argument is bad:\n```\ndiff --git a/src/utils/aio_posix.inc b/src/utils/aio_posix.inc\nindex 4c1925e..961663e 100644\n--- a/src/utils/aio_posix.inc\n+++ b/src/utils/aio_posix.inc\n@@ -219,12 +219,14 @@ static void nn_usock_tune (struct nn_usock *self, int sndbuf, int rcvbuf)\n     if (sndbuf >= 0) {\n         rc = setsockopt (self->s, SOL_SOCKET, SO_SNDBUF,\n             &sndbuf, sizeof (sndbuf));\n-        errno_assert (rc == 0);\n+        if (rc != 0)\n+            fprintf(stderr, \"%s: error setting send buffer size: sock: %d sndbuf: %d error: %s\\n\", func, self->s\n     }\n     if (rcvbuf >= 0) {\n         rc = setsockopt (self->s, SOL_SOCKET, SO_RCVBUF,\n             &rcvbuf, sizeof (rcvbuf));\n-        errno_assert (rc == 0);\n+        if (rc != 0)\n+            fprintf(stderr, \"%s: error setting recv buffer size: sock: %d rcvbuf: %d error: %s\\n\", func, self->s\n     }\n /*  If applicable, prevent SIGPIPE signal when writing to the connection\n\n@@ -233,7 +235,8 @@ static void nn_usock_tune (struct nn_usock *self, int sndbuf, int rcvbuf)\n     opt = 1;\n     rc = setsockopt (self->s, SOL_SOCKET, SO_NOSIGPIPE,\n         &opt, sizeof (opt));\n-    errno_assert (rc == 0);\n+    if (rc != 0)\n+        fprintf(stderr, \"%s: error disabling SIGPIPE: sock: %d error: %s\\n\", func, self->s, strerror(errno));\n #endif\n /*  Switch the socket to the non-blocking mode. All underlying sockets\n\ndiff --git a/tests/ipc.c b/tests/ipc.c\nindex b675506..edd25e4 100644\n--- a/tests/ipc.c\n+++ b/tests/ipc.c\n@@ -31,7 +31,7 @@\n/  Tests IPC transport. /\n-#define THREAD_COUNT 100\n+#define THREAD_COUNT 10\n #define SOCKET_ADDRESS \"ipc://test.ipc\"\nstatic void routine (void *arg)\n```\nAnd now it fails later when using the socket file descriptor. Looks like a race condition.\n```\nwhite:build nirs$ gdb ipc\nGNU gdb 6.3.50-20050815 (Apple version gdb-1515) (Sat Jan 15 08:33:48 UTC 2011)\nCopyright 2004 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"x86_64-apple-darwin\"...Reading symbols for shared libraries ... done\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nReading symbols for shared libraries ++. done\nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nProgram exited normally.\n(gdb) run\nStarting program: /Users/nirs/nanomsg/build/ipc \nnn_usock_tune: error setting send buffer size: sock: 10 sndbuf: 131072 error: Invalid argument\nnn_usock_tune: error setting recv buffer size: sock: 10 rcvbuf: 131072 error: Invalid argument\nnn_usock_tune: error disabling SIGPIPE: sock: 10 error: Invalid argument\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0x0000000000000008\n[Switching to process 39808]\n0x0000000100010b7d in nn_list_erase (self=0x1002001c0, item=0x1001002e0) at /Users/nirs/nanomsg/src/utils/list.c:94\n94          item->prev->next = item->next;\n(gdb) bt\n0  0x0000000100010b7d in nn_list_erase (self=0x1002001c0, item=0x1001002e0) at /Users/nirs/nanomsg/src/utils/list.c:94\n1  0x000000010000dda3 in nn_bstream_astream_closed (self=0x100200000, astream=0x1001000c0) at /Users/nirs/nanomsg/src/utils/bstream.c:179\n2  0x000000010000da72 in nn_astream_terminating_closed (self=0x1001000c0, usock=0x1001000c8) at /Users/nirs/nanomsg/src/utils/astream.c:127\n3  0x000000010000b96c in nn_usock_term (self=0x1001000c8) at aio_posix.inc:288\n4  0x000000010000c6a4 in nn_usock_close (self=0x1001000c8) at aio_posix.inc:562\n5  0x000000010000d9f3 in nn_astream_connected_err (self=0x1001000c0, usock=0x1001000c8, errnum=54) at /Users/nirs/nanomsg/src/utils/astream.c:86\n6  0x00000001000125f4 in nn_stream_err (self=0x1001001d0, usock=0x1001000c8, errnum=54) at /Users/nirs/nanomsg/src/utils/stream.c:274\n7  0x000000010000ce78 in nn_usock_send (self=0x1001000c8, iov=0x1000efd30, iovcnt=1) at aio_posix.inc:706\n8  0x0000000100012188 in nn_stream_init (self=0x1001001d0, epbase=0x100200008, usock=0x1001000c8) at /Users/nirs/nanomsg/src/utils/stream.c:127\n9  0x000000010000d9bb in nn_astream_init (self=0x1001000c0, epbase=0x100200008, s=10, usock=0x1002000b8, bstream=0x100200000) at /Users/nirs/nanomsg/src/utils/astream.c:74\n10 0x000000010000dbe5 in nn_bstream_listening_accepted (self=0x100200000, usock=0x1002000b8, s=10) at /Users/nirs/nanomsg/src/utils/bstream.c:97\n11 0x000000010000c28b in nn_cp_worker (arg=0x101001410) at aio_posix.inc:484\n12 0x0000000100012859 in nn_thread_main_routine (arg=0x1010018f8) at /Users/nirs/nanomsg/src/utils/thread.c:84\n13 0x00007fff8a030fd6 in _pthread_start ()\n14 0x00007fff8a030e89 in thread_start ()\n```\n. Here I log the tuned socket and the thread tuning it:\n```\ndiff --git a/src/utils/aio_posix.inc b/src/utils/aio_posix.inc\nindex 4c1925e..8229cde 100644\n--- a/src/utils/aio_posix.inc\n+++ b/src/utils/aio_posix.inc\n@@ -215,6 +215,10 @@ static void nn_usock_tune (struct nn_usock *self, int sndbuf, int rcvbuf)\n     int flags;\n     int only;\n\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nprintf(\"[%d.%06d] %s: s: %d thread: 0x%08x\\n\", (int)tv.tv_sec, (int)tv.tv_usec, func, self->s, (int)pthread_\n+\n     /  Set the size of tx and rc buffers. /\n     if (sndbuf >= 0) {\n         rc = setsockopt (self->s, SOL_SOCKET, SO_SNDBUF,\ndiff --git a/tests/ipc.c b/tests/ipc.c\nindex b675506..edd25e4 100644\n--- a/tests/ipc.c\n+++ b/tests/ipc.c\n@@ -31,7 +31,7 @@\n\n/  Tests IPC transport. /\n-#define THREAD_COUNT 100\n+#define THREAD_COUNT 10\n #define SOCKET_ADDRESS \"ipc://test.ipc\"\nstatic void routine (void *arg)\n```\nWhen it runs, we see that 3 threads (0x711cccc0, 0x00381000, 0x000f0000) are modifying the same file descriptor (10) at the same time:\nwhite:build nirs$ ./ipc \n[1361224972.127263] nn_usock_tune: s: 6 thread: 0x711cccc0\n[1361224972.127561] nn_usock_tune: s: 6 thread: 0x711cccc0\n[1361224972.136957] nn_usock_tune: s: 6 thread: 0x711cccc0\n[1361224972.137004] nn_usock_tune: s: 6 thread: 0x711cccc0\n[1361224972.336333] nn_usock_tune: s: 6 thread: 0x000f0000\n[1361224972.337497] nn_usock_tune: s: 10 thread: 0x711cccc0\n[1361224972.488625] nn_usock_tune: s: 11 thread: 0x00381000\n[1361224972.495372] nn_usock_tune: s: 6 thread: 0x711cccc0\n[1361224972.496190] nn_usock_tune: s: 10 thread: 0x00381000\n[1361224972.496789] nn_usock_tune: s: 10 thread: 0x000f0000\nInvalid argument [22] (/Users/nirs/nanomsg/src/utils/aio_posix.inc:226)\nAbort trap (core dumped)\n. This change in the test prevent the crash:\ndiff --git a/tests/ipc.c b/tests/ipc.c\nindex b675506..0a275e2 100644\n--- a/tests/ipc.c\n+++ b/tests/ipc.c\n@@ -43,6 +43,7 @@ static void routine (void *arg)\n     errno_assert (s >= 0);\n     rc = nn_connect (s, SOCKET_ADDRESS);\n     errno_assert (rc >= 0);\n+    usleep(10000);\n     rc = nn_close (s);\n     errno_assert (rc == 0);\n }\n100 runs of ipc complete without an error.\n. I tried a minimal test case using two processes:\n- server loop: accept connections, set send and receive buffer size, and close the connection.\n- client loop: connect to server and close the connection\nThe server setsockopt call always fail with invalid argument on the first connection accepted. Adding 10 millis sleep in the client before closing the socket prevent this error.\nSo the solution for the library is to fail the request instead of terminating the process when setsockopt fails.\n. Strangely, it rarely happens when running \"make check\", and more likely to fail when running  the ipc executale.\n. Testing version 0a10e5a0beeb8f57ca7ce60763cdc2dd8a0a3546 on Linux (Ubuntu 12.04), we get a bad file descriptor error:\n```\n[New Thread 0xb51ffb40 (LWP 1201)]\nBad file descriptor [9] (/home/nirs/src/nanomsg/src/utils/aio_posix.inc:880)\nProgram received signal SIGABRT, Aborted.\n[Switching to Thread 0xb7dccb40 (LWP 1196)]\n0xb7fdd424 in __kernel_vsyscall ()\n(gdb) bt\n0  0xb7fdd424 in __kernel_vsyscall ()\n1  0xb7e051df in __GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n2  0xb7e08825 in __GI_abort () at abort.c:91\n3  0x08048a1f in nn_err_abort () at /home/nirs/src/nanomsg/tests/../src/utils/err.c:33\n4  0xb7fc21c6 in nn_usock_recv_raw (self=0xb520046c, buf=0xb5200518, len=0xb7dcc138)\nat /home/nirs/src/nanomsg/src/utils/aio_posix.inc:878\n\n5  0xb7fc1b38 in nn_usock_recv (self=0xb520046c, buf=0xb5200518, len=8) at /home/nirs/src/nanomsg/src/utils/aio_posix.inc:759\n6  0xb7fc7080 in nn_stream_init (self=0xb5200500, epbase=0x804cf44, usock=0xb520046c)\nat /home/nirs/src/nanomsg/src/utils/stream.c:130\n\n7  0xb7fc256e in nn_astream_init (self=0xb5200468, epbase=0x804cf44, s=15, usock=0x804cfdc, bstream=0x804cf40)\nat /home/nirs/src/nanomsg/src/utils/astream.c:84\n\n8  0xb7fc27df in nn_bstream_listening_accepted (self=0x804cf40, usock=0x804cfdc, s=15)\nat /home/nirs/src/nanomsg/src/utils/bstream.c:99\n\n9  0xb7fc0e2c in nn_cp_worker (arg=0x804cc18) at /home/nirs/src/nanomsg/src/utils/aio_posix.inc:510\n10 0x08048c23 in nn_thread_main_routine (arg=0x804ce0c) at /home/nirs/src/nanomsg/tests/../src/utils/thread.c:84\n11 0xb7f87d4c in start_thread (arg=0xb7dccb40) at pthread_create.c:308\n12 0xb7ec5dde in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n(gdb) up\n1  0xb7e051df in __GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n64  ../nptl/sysdeps/unix/sysv/linux/raise.c: No such file or directory.\n(gdb) \n2  0xb7e08825 in __GI_abort () at abort.c:91\n91  abort.c: No such file or directory.\n(gdb) \n3  0x08048a1f in nn_err_abort () at /home/nirs/src/nanomsg/tests/../src/utils/err.c:33\n33      abort ();\n(gdb) \n4  0xb7fc21c6 in nn_usock_recv_raw (self=0xb520046c, buf=0xb5200518, len=0xb7dcc138)\nat /home/nirs/src/nanomsg/src/utils/aio_posix.inc:878\n\n878             errno_assert (errno == ECONNRESET || errno == ENOTCONN ||\n(gdb) l\n873         if (nn_fast (errno == EAGAIN || errno == EWOULDBLOCK))\n874             nbytes = 0;\n875         else {\n876 \n877             /  If the peer closes the connection, return ECONNRESET. /\n878             errno_assert (errno == ECONNRESET || errno == ENOTCONN ||\n879                 errno == ECONNREFUSED || errno == ETIMEDOUT ||\n880                 errno == EHOSTUNREACH);\n881             return -ECONNRESET;\n882         }\n```\nSo I added this fix:\ndiff --git a/src/utils/aio_posix.inc b/src/utils/aio_posix.inc\nindex 2476edc..da86bc2 100644\n--- a/src/utils/aio_posix.inc\n+++ b/src/utils/aio_posix.inc\n@@ -877,7 +877,7 @@ static int nn_usock_recv_raw (struct nn_usock *self, void *buf, size_t *len)\n             /*  If the peer closes the connection, return ECONNRESET. */\n             errno_assert (errno == ECONNRESET || errno == ENOTCONN ||\n                 errno == ECONNREFUSED || errno == ETIMEDOUT ||\n-                errno == EHOSTUNREACH);\n+                errno == EHOSTUNREACH || errno == EBADF);\n             return -ECONNRESET;\n         }\n     }\nAnd now we get:\n```\nAssertion failed: (*self->sink)->err (/home/nirs/src/nanomsg/src/utils/aio_posix.inc:762)\n[New Thread 0xb53fdb40 (LWP 6355)]\nProgram received signal SIGABRT, Aborted.\n[Switching to Thread 0xb7dccb40 (LWP 6350)]\n0xb7fdd424 in __kernel_vsyscall ()\n(gdb) bt\n0  0xb7fdd424 in __kernel_vsyscall ()\n1  0xb7e051df in __GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n2  0xb7e08825 in __GI_abort () at abort.c:91\n3  0x08048a1f in nn_err_abort () at /home/nirs/src/nanomsg/tests/../src/utils/err.c:33\n4  0xb7fc1bf5 in nn_usock_recv (self=0xb4a0046c, buf=0xb4a00518, len=8) at /home/nirs/src/nanomsg/src/utils/aio_posix.inc:762\n5  0xb7fc70a4 in nn_stream_init (self=0xb4a00500, epbase=0x804cf44, usock=0xb4a0046c)\nat /home/nirs/src/nanomsg/src/utils/stream.c:130\n\n6  0xb7fc2592 in nn_astream_init (self=0xb4a00468, epbase=0x804cf44, s=15, usock=0x804cfdc, bstream=0x804cf40)\nat /home/nirs/src/nanomsg/src/utils/astream.c:84\n\n7  0xb7fc2803 in nn_bstream_listening_accepted (self=0x804cf40, usock=0x804cfdc, s=15)\nat /home/nirs/src/nanomsg/src/utils/bstream.c:99\n\n8  0xb7fc0e2c in nn_cp_worker (arg=0x804cc18) at /home/nirs/src/nanomsg/src/utils/aio_posix.inc:510\n9  0x08048c23 in nn_thread_main_routine (arg=0x804ce0c) at /home/nirs/src/nanomsg/tests/../src/utils/thread.c:84\n10 0xb7f87d4c in start_thread (arg=0xb7dccb40) at pthread_create.c:308\n11 0xb7ec5dde in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\n(gdb) up\n1  0xb7e051df in __GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n64  ../nptl/sysdeps/unix/sysv/linux/raise.c: No such file or directory.\n(gdb) \n2  0xb7e08825 in __GI_abort () at abort.c:91\n91  abort.c: No such file or directory.\n(gdb) \n3  0x08048a1f in nn_err_abort () at /home/nirs/src/nanomsg/tests/../src/utils/err.c:33\n33      abort ();\n(gdb) \n4  0xb7fc1bf5 in nn_usock_recv (self=0xb4a0046c, buf=0xb4a00518, len=8) at /home/nirs/src/nanomsg/src/utils/aio_posix.inc:762\n762         nn_assert ((self->sink)->err);\n(gdb) l\n757     /  Try to receive the data immediately. /\n758     nbytes = len;\n759     rc = nn_usock_recv_raw (self, buf, &nbytes);\n760     if (nn_slow (rc < 0)) {\n761         errnum_assert (rc == -ECONNRESET, -rc);\n762         nn_assert ((self->sink)->err);\n763         (*self->sink)->err (self->sink, self, -rc);\n764         return;\n765     }\n766 \n```\nLooks like error handling when the other side close the connection is not working because a error function is noet set?\n. Fixed in 392287a508df6ac0d056f6a4c083aebd6581be61\n. tcp does not seem to crash any more.\n. Still deaklock randomally with version 3cbb6644c873701f5350b853d417fa26381a6215.\n```\nwhite:build nirs$ i=0; while test $((i++)) -le 30; do echo -n \"test $i .. \"; ./tcp && echo ok; done\ntest 1 .. ok\ntest 2 .. ok\ntest 3 .. ^C \nThe third run failed with a deadlock.\nwhite:~ nirs$ gdb attach 35812\nGNU gdb 6.3.50-20050815 (Apple version gdb-1515) (Sat Jan 15 08:33:48 UTC 2011)\nCopyright 2004 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB.  Type \"show warranty\" for details.\nThis GDB was configured as \"x86_64-apple-darwin\"...attach: No such file or directory\n/Users/nirs/35812: No such file or directory\nAttaching to process 35812.\nReading symbols for shared libraries . done\nReading symbols for shared libraries .... done\n0x00007fff89ff7dc2 in semaphore_wait_signal_trap ()\n(gdb) thread apply all bt\nThread 2 (process 35812):\n0  0x0000000100010c7c in nn_list_erase (self=0x100100280, item=0x1001004b0) at /Users/nirs/nanomsg/src/utils/list.c:98\n1  0x000000010000de74 in nn_bstream_astream_closed (self=0x1001000c0, astream=0x100100290) at /Users/nirs/nanomsg/src/utils/bstream.c:179\n2  0x000000010000db43 in nn_astream_terminating_closed (self=0x100100290, usock=0x100100298) at /Users/nirs/nanomsg/src/utils/astream.c:127\n3  0x000000010000ba3d in nn_usock_term (self=0x100100298) at aio_posix.inc:285\n4  0x000000010000c775 in nn_usock_close (self=0x100100298) at aio_posix.inc:559\n5  0x000000010000dac4 in nn_astream_connected_err (self=0x100100290, usock=0x100100298, errnum=54) at /Users/nirs/nanomsg/src/utils/astream.c:86\n6  0x00000001000126c5 in nn_stream_err (self=0x1001003a0, usock=0x100100298, errnum=54) at /Users/nirs/nanomsg/src/utils/stream.c:274\n7  0x000000010000d114 in nn_usock_recv (self=0x100100298, buf=0x1001003d0, len=8) at aio_posix.inc:734\n8  0x000000010001226f in nn_stream_init (self=0x1001003a0, epbase=0x1001000c8, usock=0x100100298) at /Users/nirs/nanomsg/src/utils/stream.c:130\n9  0x000000010000da8c in nn_astream_init (self=0x100100290, epbase=0x1001000c8, s=10, usock=0x100100178, bstream=0x1001000c0) at /Users/nirs/nanomsg/src/utils/astream.c:74\n10 0x000000010000dcb6 in nn_bstream_listening_accepted (self=0x1001000c0, usock=0x100100178, s=10) at /Users/nirs/nanomsg/src/utils/bstream.c:97\n11 0x000000010000c35c in nn_cp_worker (arg=0x100801410) at aio_posix.inc:481\n12 0x000000010001292a in nn_thread_main_routine (arg=0x1008018f8) at /Users/nirs/nanomsg/src/utils/thread.c:84\n13 0x00007fff8a030fd6 in _pthread_start ()\n14 0x00007fff8a030e89 in thread_start ()\nThread 1 (process 35812):\n0  0x00007fff89ff7dc2 in semaphore_wait_signal_trap ()\n1  0x00007fff89ffd40d in pthread_mutex_lock ()\n2  0x0000000100010ea6 in nn_mutex_lock (self=0x100801410) at /Users/nirs/nanomsg/src/utils/mutex.c:70\n3  0x000000010000bbf2 in nn_cp_lock (self=0x100801410) at aio_posix.inc:334\n4  0x00000001000091c9 in nn_sock_destroy (self=0x100801400) at /Users/nirs/nanomsg/src/core/sock.c:91\n5  0x0000000100006e83 in nn_close (s=0) at /Users/nirs/nanomsg/src/core/ctx.c:398\n6  0x0000000100002ae9 in main () at /Users/nirs/nanomsg/tests/tcp.c:131\n(gdb) thread apply all bt full\nThread 2 (process 35812):\n0  0x0000000100010c7c in nn_list_erase (self=0x100100280, item=0x1001004b0) at /Users/nirs/nanomsg/src/utils/list.c:98\nNo locals.\n1  0x000000010000de74 in nn_bstream_astream_closed (self=0x1001000c0, astream=0x100100290) at /Users/nirs/nanomsg/src/utils/bstream.c:179\nNo locals.\n2  0x000000010000db43 in nn_astream_terminating_closed (self=0x100100290, usock=0x100100298) at /Users/nirs/nanomsg/src/utils/astream.c:127\nastream = (struct nn_astream *) 0x100100290\n\n3  0x000000010000ba3d in nn_usock_term (self=0x100100298) at aio_posix.inc:285\nrc = 0\n\n4  0x000000010000c775 in nn_usock_close (self=0x100100298) at aio_posix.inc:559\nrc = 1\n\n5  0x000000010000dac4 in nn_astream_connected_err (self=0x100100290, usock=0x100100298, errnum=54) at /Users/nirs/nanomsg/src/utils/astream.c:86\nastream = (struct nn_astream *) 0x100100290\n\n6  0x00000001000126c5 in nn_stream_err (self=0x1001003a0, usock=0x100100298, errnum=54) at /Users/nirs/nanomsg/src/utils/stream.c:274\nstream = (struct nn_stream *) 0x1001003a0\noriginal_sink = (const struct nn_cp_sink **) 0x100100290\n\n7  0x000000010000d114 in nn_usock_recv (self=0x100100298, buf=0x1001003d0, len=8) at aio_posix.inc:734\nrc = -54\nnbytes = 8\n\n8  0x000000010001226f in nn_stream_init (self=0x1001003a0, epbase=0x1001000c8, usock=0x100100298) at /Users/nirs/nanomsg/src/utils/stream.c:130\nrc = 0\niobuf = {\n\niov_base = 0x10001cc60, \n  iov_len = 8\n}\n9  0x000000010000da8c in nn_astream_init (self=0x100100290, epbase=0x1001000c8, s=10, usock=0x100100178, bstream=0x1001000c0) at /Users/nirs/nanomsg/src/utils/astream.c:74\nsndbuf = 131072\nrcvbuf = 131072\nsz = 4\n\n10 0x000000010000dcb6 in nn_bstream_listening_accepted (self=0x1001000c0, usock=0x100100178, s=10) at /Users/nirs/nanomsg/src/utils/bstream.c:97\nbstream = (struct nn_bstream *) 0x1001000c0\nastream = (struct nn_astream *) 0x100100290\n\n11 0x000000010000c35c in nn_cp_worker (arg=0x100801410) at aio_posix.inc:481\nrc = 0\nself = (struct nn_cp *) 0x100801410\ntimeout = -1\nqit = (struct nn_queue_item *) 0x0\nophndl = (struct nn_cp_op_hndl *) 0x0\ntohndl = (struct nn_timeout_hndl *) 0x0\ntimer = (struct nn_timer *) 0x0\nop = 1\nphndl = (struct nn_poller_hndl *) 0x10010018c\nit = (struct nn_queue_item *) 0x0\nevent = (struct nn_event *) 0x0\nusock = (struct nn_usock *) 0x100100178\nsz = 0\nnewsock = 10\n\n12 0x000000010001292a in nn_thread_main_routine (arg=0x1008018f8) at /Users/nirs/nanomsg/src/utils/thread.c:84\nrc = 0\nsigset = 4294967295\nself = (struct nn_thread *) 0x1008018f8\n\n13 0x00007fff8a030fd6 in _pthread_start ()\nNo symbol table info available.\n14 0x00007fff8a030e89 in thread_start ()\nNo symbol table info available.\nThread 1 (process 35812):\n0  0x00007fff89ff7dc2 in semaphore_wait_signal_trap ()\nNo symbol table info available.\n1  0x00007fff89ffd40d in pthread_mutex_lock ()\nNo symbol table info available.\n2  0x0000000100010ea6 in nn_mutex_lock (self=0x100801410) at /Users/nirs/nanomsg/src/utils/mutex.c:70\nrc = 29971\n\n3  0x000000010000bbf2 in nn_cp_lock (self=0x100801410) at aio_posix.inc:334\nNo locals.\n4  0x00000001000091c9 in nn_sock_destroy (self=0x100801400) at /Users/nirs/nanomsg/src/core/sock.c:91\nrc = 0\nsockbase = (struct nn_sockbase *) 0x100801400\nit = (struct nn_list_item *) 0x100010170\nep = (struct nn_epbase *) 0x7fff5fbfec50\n\n5  0x0000000100006e83 in nn_close (s=0) at /Users/nirs/nanomsg/src/core/ctx.c:398\nNo locals.\n6  0x0000000100002ae9 in main () at /Users/nirs/nanomsg/tests/tcp.c:131\nrc = 1\nsb = 0\nsc = 0\ni = 100\nj = 10\nbuf = \"XYZ\"\nthreads = {{\nroutine = 0x10000206b <routine>, \narg = 0x0, \nhandle = 0x100381000\n\n}, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x100404000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x100487000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10050a000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10058d000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x100610000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x100716000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x100799000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101881000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101987000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101a0a000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101a8d000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x100693000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101b93000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101e22000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101ea5000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101fab000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10202e000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1021b7000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10223a000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102340000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1024c9000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10254c000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102652000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1026d5000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1027db000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10285e000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1028e1000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101904000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102a6a000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102aed000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102bf3000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102c76000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102d7c000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102dff000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x102f05000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10300b000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10308e000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103194000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103217000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10329a000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10331d000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1033a0000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1034a6000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103529000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101c16000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1035ac000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1036b2000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103735000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1037b8000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101c99000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10383b000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1038be000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103941000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x101d1c000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1039c4000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103a47000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103aca000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103b4d000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103bd0000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103c53000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103cd6000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103d59000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103ddc000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103e5f000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103ee2000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103f65000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x103fe8000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10406b000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1040ee000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104171000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1041f4000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104277000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1042fa000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10437d000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104400000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104483000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104506000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104589000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10460c000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10468f000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104712000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104795000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104818000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10489b000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x10491e000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x1049a1000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104a24000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104aa7000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104b2a000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104bad000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104c30000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104cb3000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104d36000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104db9000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104e3c000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104ebf000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104f42000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x104fc5000\n  }, {\n    routine = 0x10000206b , \n    arg = 0x0, \n    handle = 0x105048000\n  }}\n```\n. I did not see a deadlock for few weeks - check again running tcp_shutdown test multiple times to verify if this is fixed now.\n. Can you add a test module that reproduce this issue?\n. What is still missing, is the asserts - what code to add to make this test fail when the bug is reproduced?\nFor example, you say that the first message is lost - nn_send fail? nn_recv fail with for the first message and succeeds for the second message?\nThanks!\n. It does not sound like acceptable behavior of the library. You may expectt that if the rep side is down, req side will try to reconnect until the rep is up and then it will send the message.\nIn your code you call bind, but you don't wait until the rep is up before you start the req side. This is simalr to starting the req side before the rep. In this case I think a reasonble delay is 200-500 milliseconds, waiting until the req side is connected to the rep side.\nWhat happen if you sleep 200 milliseconds after this line:\nrc = nn_bind(rep, SOCKET_ADDRESS);\nFinally, you don't check the return value from any function, so we don't know if some of them have failed. In test code like this, I would add assert for every call - see how the ipc.c test for example.\n. I can reproduce this on OS X 10.6. Moving the sleep before the first send seems to fix this. Smell like a bug.\n. I ran make check 5 times on OS X 10.6, all tests but tcp_shutdown are ok.\n. Can you test again with latest version? list related errors may have been fixed by recent changes.\n. Please test again with latest version.\n. If you suspect a deadlock, it can help if you attach to the process and create a backtrace of all threads.\nWhen you see that the server does not respond, run this:\ngdb attach <server-pid>\nAnd in gdb prompt:\nthread apply all bt\nThanks!\n. Can you check again with 392287a508df6ac0d056f6a4c083aebd6581be61 or later?\n. There are two different cases here:\n1. When running the tests, the test framework should increase the file limit. Common way to do this is to run \"ulimit -n newlimit\" in the script that run the tests, or using setrlimit() in the test code. If increasing the limit fails, the test should fail with a clear error such as \"this test requires n open files\".\n2. The library should not change the file limit. If the limit is reached, the library should fail with expected error for this case. It is the responsibility of the application author to setup this up or the user who run the application.\nChanging the number of open files to prevent failures of the test should not require root. Root is required only for changing the hard limit. Any user can change the soft limit. In case of OS X, where the test fail, the soft limit is 256, and there is no hard limit (-1).\n. I'll handle this.\n. Fixed in 392287a508df6ac0d056f6a4c083aebd6581be61.\n. See also #21 \n. Can you test again with current code?\n. Can you put here a backtrce of this faiure on linux? I get only invalid argument error on OS X.\n. Thanks, but the backtrace is truncated.\nThe best way to create a backtrace:\ngdb ./ipc_shutdown\n...\nrun\nWhen it fails:\nbt\nIf the current thread is not the one that failed, find the thread that failed using:\nthread apply all bt\nYou can copy the output of of this, or move to the failing thread and creat a backtrace again:\nthread 2 # assuming that thread 2 failed\nbt\nIf you think that more info can help, you can do a full backtrace:\nbt full\nThanks!\n. Duplicate of #36 \n. I think that Orjan whould be happy with the info returned from\ngetsockname().\n$ python\n\n\n\nimport socket\ns = socket.socket()\ns.bind(('', 0))\ns.getsockname()\n('0.0.0.0', 48945)\n\n\n\nOn Mon, May 27, 2013 at 8:44 AM, sustrik notifications@github.com wrote:\n\nI am not sure the OS provides such info. I.e. if you bind to INADDR_ANY,\nAFAIK there's no way of retrieving the list of interfaces the BSD socket is\nactually bound to.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/issues/67#issuecomment-18483365\n.\n. The first issue can be solved using random paths such as\n/tmp/nanomsg/testname-timestamp-randomsuffix.\n\nOn Tue, Jul 23, 2013 at 10:14 AM, sustrik notifications@github.com wrote:\n\nThe latter issue is definitely a bug, however, not being able to run 2\ntests in parallel is just a way the things are. I am not sure I can see any\nway to fix that. Any idea for a workaround?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/issues/82#issuecomment-21397017\n.\n. \n",
    "liuhaif": "This is OK. I test on windows 8, visual studio 2012, sorry for the delay. Another question:\nlocal_thr tcp://*:10000 1024 1000000\nmessage size: 1024 [B]\nmessage count: 1000000\nthroughput: 26476 [msg/s]\nthroughput: 216.891 [Mb/s]\nlocal_thr tcp://*:10000 64 1000000\nmessage size: 64 [B]\nmessage count: 1000000\nthroughput: 28686 [msg/s]\nthroughput: 14.687 [Mb/s]\n64B is same as 1024B. this is right?\n. YES\uff01127.0.0.1\n. ",
    "tailhook": "I submit this patch under MIT license.\n. > Note to myself: This problem is caused by trasferring usock to DONE state synchronously in case of error, while there may be asynchronous tasks sent to the worker thread (task_recv in this case) on the fly.\nExactly the same issue in #77\n. @catwell please re-test this one. As doesn't reproduce on linux, I can't test. And I think it was fixed long ago\n. @catwell, reproduced on linux. It's probably because nn_shutdown is inherently asynchronous. So when nn_bind comes to play it doesn't mean old socket is already shut down. This bug will be fixed together with #119, and I'm waiting for #160 to be applied before fixing the bug.\n. I just reproduced this one with unitests. The tests/reqrep ocasionally crashes with:\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (src/utils/queue.c:78)\n. My traceback is following:\n```\n0  0x00007ffff74193d9 in raise () from /usr/lib/libc.so.6\n1  0x00007ffff741a7d8 in abort () from /usr/lib/libc.so.6\n2  0x0000000000401709 in nn_err_abort () at tests/../src/utils/err.c:33\n3  0x00007ffff7bc443a in nn_queue_item_term (self=self@entry=0x604698) at src/utils/queue.c:78\n4  0x00007ffff7bbffb9 in nn_fsm_event_term (self=self@entry=0x604678) at src/aio/fsm.c:45\n5  0x00007ffff7bccb08 in nn_sinproc_term (self=self@entry=0x604478) at src/transports/inproc/sinproc.c:88\n6  0x00007ffff7bcb90a in nn_cinproc_destroy (self=) at src/transports/inproc/cinproc.c:98\n7  0x00007ffff7bbc814 in nn_ep_term (self=self@entry=0x6042d0) at src/core/ep.c:92\n8  0x00007ffff7bbe1c4 in nn_sock_shutdown (self=0x603c60, src=, type=, srcptr=0x6042d0) at src/core/sock.c:765\n9  0x00007ffff7bbfe86 in nn_ctx_leave (self=0x603cd8) at src/aio/ctx.c:63\n10 0x00007ffff7bbff0b in nn_ctx_leave (self=) at src/aio/ctx.c:92\n11 0x00007ffff7bbff0b in nn_ctx_leave (self=self@entry=0x603cd8) at src/aio/ctx.c:92\n12 0x00007ffff7bbe99a in nn_sock_term (self=0x603c60) at src/core/sock.c:173\n13 0x00007ffff7bbd123 in nn_close (s=s@entry=1) at src/core/global.c:379\n14 0x0000000000400eb1 in main () at tests/reqrep.c:166\n```\nIt seems that when gdb show a crash the \"self->next\" is already an NN_QUEUE_NOTINQUEUE. Is it possible that something is not well interlocked here?\n. Two of them are #75, #77, and the third is fixed by #167 (#114)\nSo closing as duplicate\n. > cmake does not work properly for cross compilation, it is a known issue.\nThe page:\nhttp://www.cmake.org/Wiki/CMake_Cross_Compiling\nDoesn't describe anything critical. Can you give a link on the issue?\n. I have two (rather conflicting) thoughts on logging:\n1. If there is a programmatic interface for logging, it should be based on opcodes rather than text. e.g.:\ntypedef void (*nn_log_callback)(int loglevel, int sock, int opcode);\nchar *nn_log_opcode_to_string(int opcode);\nSo that it's easy to count number of warnings without parsing text\n1. I believe that the most common use case for log_callback is to send messages by nanomsg socket itself (that may trigger log_callback itself and recurse to invitity). So better interface may be provide a socket for logging:\nint sock = nn_socket (AF_SP, NN_PUSH);  // or NN_PUB\nsetsockopt(sock, NN_SOL_SOCKET, NN_RECEIVES_LOG_MESSAGES, &one, sizeof(one));\n. > That being said, I think it is unlikely that admin will be sitting inside of the user process. Thus, we should think about admin-facing interface as being primarily IPC or TCP based -- as opposed to API-based.\nSo using socket for that suits the needs? And using text messages is probably nice for admins to work with.\nUsing socket is nice solution as it supports all the transports and already has all the options needed (e.g. buffer sizes).\n. I believe the logging and monitoring data for topology and performance statistics should have separate API. We should bring it on the mailing list. Should I start a thread?\n. Since the first version of monitoring reached mainline, this should be closed. Everybody is encouraged to test and discuss what's currently implemented.\n. This code is submitted under MIT license\n. > Do we really need the bind() thing? The goal is to provide a way to pass fully established connections to nanomsg. Passing the listening sockets doesn't seem to fit the bill.\nOne of my use cases is to bind a privileged port. \n\nWouldn't tcp-fd be better than tcp+fd? I know that URL spec allow for + sign in the name, however, I would expect most people not be aware of the fact and somehow imply that + has some kind of semantic meaning, such as combining two protocols or similar.\n\nThis is intended to look as combining two protocols. Or better adding some feature to existing protocol. It's similar in spirit to \"svn+ssh://\". But I don't care too much. If you would insist on on \"tcp-fd\", that's ok.\n\nWhat about socket options such as TCP_NODELAY or SO_RCVBUF? Is nanomsg responsibe for setting them, or is the user supposed to fully configure the connection?\n\nAh, the one I've forgotten is O_NONBLOCK. This one must be set by nanomsg. Given my use cases I would say all options should be set by nanomsg. So this feature is easier to use. But it would prevent passing pipe or something else to the nanomsg. So I'm not sure.\n. > I would say it really depends on whether this is meant just for TCP sockets or for arbitrary stream-based sockets. In the former case, nanomsg should apply all TCP-related options. In the latter case it should do nothing (except O_NONBLOCK) and let the user to configure the socket.\nWe may have \"fd://\" or \"pipe-fd://\" (or pick a better name) that allows any arbitrary file descriptor.\n. > One more problem: What about the disconnections? nanosmg may simply close the file descriptor when disconnection happens, but who's going to do re-connect then? The user is not even notified about the disconnect.\nWe should just make sure we shutdown endpoint when connection is closed, so no memory is leaked. In case it's socket listened by TCPMUX daemon (it will be attached by nn_connect() for us), we don't care. Bound socket seems to be never closed, right? For sockets that are connect()ed before attaching by nn_connect(), I have no real use case, so I don't know if it matters.\nFor non-tcp sockets, it depends on the type of socket and how it's used, e.g. if pipe is open to communicate with child process you get notification when child is dead.\nAnyway this works like everything else: you get no notification when either connection is dropped. So as long as user aware of that it's ok IMO.\n. > Binding to privileged port -- this kind of works until the interface goes off and on, as in case of wi-fi.\nEven if it is (as you mentioned it isn't for some scenarios), user can monitor the interface on it's own, and get new socket by SCM_RIGHTS or by restarting.\n\nSpawning processes for new connections -- the child process won't get notification about the connection failure, so the process will never terminate :|\n\nWhat connection failure on pipe can happen? Also even in possibility of connection failures, it may work with short-lived children well (if you don't mind if some of them will die).\n\nUsing it as an underlying layer for special connection initiation mechanisms such as TCPMUX -- would work on the bound side, won't work on the connect side (no reconnection).\n\nWell, connect side doesn't work indeed. In fact with external monitoring it can work, but it can't be recommended solution.\n\nI am starting to think that simplifying the internal transport API to allow this kind of thing would be more appropriate than using user-facing API for it.\n\nSimplifying transport API would be awesome, anyway. But I like the \"fd://\" approach for endless possibilities (e.g. communication over serial, forking, setting very rare socket options, whatever)\n. In the meantime I've look through the code, shutdown mechanism looks ok, and NONBLOCK is also set.\nAm I missing something or setting SNDBUF and RCVBUF doesn't work yet?\n. You almost convinced me :) Can you show rough example of how the code can look like?\n. Changeset is not up to date any more, and probably will never be merged anyway\n. Sure. Should generated diagrams be placed into doc too? They are put in build/ now, but there is no such directory unless user creates one itself.\n. Updated the changeset. It generates a very simplistic HTML page for now. Separate pull request adds diagrams to the gh-pages (feel free to drop it if not needed)\n. > Hi, can you modify the generation of the index so that it produces HTML links instead of plain text? When done, I'll upload the thing to the website.\nSure. Do you mean links to sources? Or do you want to link images instead of listing them in the page?\n\nAnd btw, build instructions for diagrams would help. For example, I am getting \"ImportError: No module named clang.cindex\"\n\nDependencies are described in docstring in diag.py. Should I add the links? Or should I write build instructions in some other place?\n. So, @rafl, have you agreed that symbols should be left as is? If so, please close the issue.\n. The event sequence for sockets A and B is the following:\n1. Thread 1 executes nn_bind() on B\n2. Thread 2 starts nn_connect() for A, which raises CONNECT to B\n3. Thread 2 locks B in nn_ctx_leave and proccesses CONNECT event in B (B becomes ACTIVE), raising ACCEPT to A, copying \"eventsto\" for B, and unlocks B\n4. Thread 1 executes nn_send() for B which which raises SENT to A\n5. Thread 1 processes SENT for A raised in step 4 (crash here!)\n6. Thread 2 processes ACCEPT for A raised in step 3 (or actually would process)\nNote in step 5 both threads are waiting on A's context, so whether it works or not depends on which thread won the race\n. You may apply. If it helped you, it may help someone else.\nBut I wouldn't mind if you throw it away\n. You should add the following to the tests:\nrc = nn_connect (sc, \"tcp://abc.123.:5555\");\n    nn_assert (rc < 0);\n    errno_assert (nn_errno () == EINVAL);\n    rc = nn_connect (sc, \"tcp://abc...123:5555\");\n    nn_assert (rc < 0);\n    errno_assert (nn_errno () == EINVAL);\n(they fail)\n. Discussed a better way in IRC\n. Fixed small typo in assertion and rebased onto the current master.\n. This patch is submitted under MIT License\n. Yes. It works. Thanks!\n. The other one is now easier to make test case for. Not sure about solution though. Could you take a look?\nThe patch is submitted under MIT Lisense.\n. No the rep socket is already there. So it should deliver the request.\nOn Mon, Sep 2, 2013 at 5:16 PM, sustrik notifications@github.com wrote:\n\nWhat about the test in the patch? For me it returns EAGAIN on line 218 and\nas far as I can tell it should, no?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/issues/130#issuecomment-23662617\n.\n\n\nPaul\n. Fixed all mentioned issues, and force-pushed the branch.\nThe patch is submitted under MIT License\n. > Btw, what an curious error. Macros evaluated before being used? Strange.\nIt's not an error at all. Macros are literally expanded by preprocessor. At that stage compiler doesn't even know that the code is C. So functions must be declared before first use of macro. Anyway it doesn't hurt either.\n. > This is a silly question, but what does it do?\nThe announcement may help:\nhttp://www.freelists.org/post/nanomsg/First-nanocat-release\n. Fixed in #154 \n. It seems most platforms leave descriptor close after EINTR (https://sites.google.com/site/michaelsafyan/software-engineering/checkforeintrwheninvokingclosethinkagain), except HP-UX (http://ewontfix.com/4/)\n. Many more links at https://news.ycombinator.com/item?id=3363819\n. Here is IRC conversation on the issue:\n<tailhook> I'm not sure what to do on EIO that's documented at least in linux\n<sustrik> I though it was an non-blocking function\n<sustrik> let's check posix...\n<sustrik> same thing\n<tailhook> probably EIO is for files, so it's ok to assert on it\n<tailhook> but I'm guessing\n<sustrik> \"If close() is interrupted by a signal that is to be caught, it will return -1 with errno set to [EINTR] and the state of fildes is unspecified.\"\n<tailhook> yes, this weird\n<tailhook> on linux filedescriptor is closed \n<tailhook> but what on other platforms?\n<sustrik> strange that it returns EINTR then\n<sustrik> i mean the socket is closed, so it could as well returned success\n<tailhook> it says you that data might still be lignering\n<tailhook> it's for blocking sockets and SO_LINGER AFAIR\n<tailhook> And posix seems to specify that EIO is for filesystem only\n<sustrik> http://alobbs.com/post/54503240599/close-and-eintr\n<tailhook> yes, I've seen this before\n<tailhook> https://sites.google.com/site/michaelsafyan/software-engineering/checkforeintrwheninvokingclosethinkagain\n<tailhook> article says \"many POSIX implementations, including Linux, will release the file descriptor immediately\"\n<tailhook> that \"many\" but not \"all\" makes be unhappy\n<tailhook> \"Some implementations (e.g. HPUX) had it leave the file descriptor open when returning with EINTR\"\n<tailhook> it's from: http://ewontfix.com/4/\n<sustrik> heh\n<sustrik> we would have to know the behaviour on all the platforms to handle that correctly\n<sustrik> fast and dirty way is \"assume it's closed\" for now\n<tailhook> should we ifdef HPUX?\n<sustrik> we can\n<sustrik> what about BSDs?\n<sustrik> any idea how it works there?\n<tailhook> need to retry close\n<tailhook> so it's basically a loop, like in the article above\n<sustrik> where have you found it?\n<tailhook> http://ewontfix.com/4/\n<sustrik> doesn't mention BSD, does it?\n<sustrik> freebsd and osx man page seem to be silent about the issue\n<tailhook> seems close behaves like linux\n<tailhook> http://lists.freebsd.org/pipermail/freebsd-threads/2010-August/004866.html\n<sustrik> osx is the last remaining major os\n<sustrik> it's a bsd variant but it may differ\n<tailhook> https://news.ycombinator.com/item?id=3363819\n<tailhook> there are more links\n<tailhook> and is description of OS X behavior\n<tailhook> it's weird\n<sustrik> \"Mac OS X: Here you should not retry, but you should also be careful; depending on whether you are UNIX2003 you will get different behavior from the close() function from libSystem, directing you to either the syscall close() or close_nocancel().\"\n<sustrik> yuck\n<tailhook> do you know what UNIX2003 means?:)\n<sustrik> no idea\n<sustrik> maybe they've meant POSIX 2003?\n<tailhook> but how to check \"you are UNIX2003\"?\n<ScottKevill> It's confusing.\n<sustrik> you bet :)\n<ScottKevill> If you compile with a certain version of the SDK, it links to different symbols.\n<sustrik> aaargh\n<ScottKevill> If you look at the symbol names, you'll be able to tell.\n<ScottKevill> It was to do with the full POSIX compliance they introduced in one of the OS versions.\n<sustrik> any way to check for that programatically?\n<sustrik> like a macro defined or somesuch\n<ScottKevill> Hold on.\n<tailhook> another question is it possible to use close_nocancel directly?\n<ScottKevill> Looking through some old IM logs.\n<tailhook> ah, it seems it's in-kernel API, so I withdraw the question\n<ScottKevill> Okay, it appears to have been added in the 10.6 SDK.\n<ScottKevill> #if __DARWIN_UNIX03 && !defined(__LP64__)\n<ScottKevill> #define __DARWIN_ALIAS(sym) __asm(\"_\" __STRING(sym) \"$UNIX2003\")\n<ScottKevill> #else\n<ScottKevill> #define __DARWIN_ALIAS(sym)\n<ScottKevill> #endif\n<ScottKevill> Example: _recvfrom$UNIX2003\n<ScottKevill> I don't know if that helps you.\n<sustrik> that's kernel code or user space code?\n<ScottKevill> User space.\n<ScottKevill> So >= 10.6, there are two versions of a number of socket functions.\n<sustrik> where's __DARWIN_UNIX03 defined?\n<ScottKevill> eg. _recvfrom and _recvfrom$UNIX2003\n* nga4 has quit (Ping timeout: 248 seconds)\n<ScottKevill> cdefs.h\n<tailhook> so in unix03 it uses close_nocancel?\n<ScottKevill> It defines that if you set the OS X deployment target to 10.6 or later.\n<ScottKevill> From unistd.h: int  close(int) __DARWIN_ALIAS_C(close);\n<ScottKevill> #define __DARWIN_ALIAS_C(sym)  __asm(\"_\" __STRING(sym) __DARWIN_SUF_NON_CANCELABLE __DARWIN_SUF_UNIX03)\n<ScottKevill> #    define __DARWIN_SUF_NON_CANCELABLE \"$NOCANCEL\"\n<ScottKevill> So I think that would be _close$NOCANCEL$UNIX2003\n* lluad (~lluad@204.11.227.194.static.etheric.net) has joined\n<tailhook> so we should define __DARWIN_UNIX03 to be on the safe side?\n<ScottKevill> http://pastebin.com/iy7SuJ02\n<ScottKevill> <sys/cdefs.h>\n<ScottKevill> No idea what you should do. :)\n<ScottKevill> Actually, that header is from the 10.5 SDK.\n<ScottKevill> So I don't think it's enabled there.\n<tailhook> looks-like we need to define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__\n<tailhook> it's ok to require 10.6?\n* ScottKevill shrugs.\n<ScottKevill> It's probably okay.\n<ScottKevill> I don't think anyone really develops with <10.6 anymore.\n. Probably we should assert \"rc == 0 || errno != EBADF\" I think everything else should be ok.\n. EINPROGRESS is seems to be specified by some upcoming posix standard, and is possible to be returned in HP-UX\n. Now I'm happy :)\n. @gdamore, I'm not sure where I was hitting it. But think about some application which has nanomsg among the other things. If app has a bug, i.e. it opened 1000 files, and nanomsg opens next one, you will get crash, instead of getting EMFILE (ENFILE) inside the application (i.e. when opening next application specific file). In fact currently you get 100% cpu instead crash, but it's hard to debug either.\nI got this in practice. And no, EMFILE is not hard to hit, it's just limit of 1024 file descriptors per process on linux by default.\n. Same or similar race condition might be in #77, #75, which in turn duplicated by #79 \n. Fixed in #169 except for windows. There is #172 for it.\n. Probably duplicate of #114 \n. Added manual pages, feel free to adjust them in the case my English is not that good :)\nShould squash changes before merging. Notify me if I should do it.\nThe patch is submitted under MIT License\n. Sure, no hurry.\n. Just realized that windows part is not done. In particular delivering accept errors from nn_usock to transport should be reimplemented for windows.\n. It seems this can't be merged any more. Let me know if I need to rebase it.\n. This branch is outdated. I'm building the new one.\n. Just noticed that there are NN_PROTO_XXX constants internally. So another option is to export them through the nn_symbol\n. > Yes. Let's export the existing constants. \nSorry my fault. It's not a solution. We already have a constant value. But no way to ensure that constant name that we have is a right symbol (e.g I have NN_PUB , not an EPIPE  which both have the value of 32).\nThere was also related discussion of exporting types of socket options. But I can't find it currently.\n. In fact device test failure is also duplicate of #114 (line number is shifted a bit)\n. > or. my preferred solution was to treat this case as the library user's duty to make sure it doesn't try to send on an unbound socket. I implemented this by using nn_sem and make sure we don't send until bind happened.\nIt's better to fix problem in nanomsg itself, rather than take responsibility to the user.\nActually the problem is not:\n\narrives to nn_send() before the socket has been bound in the deviceX() threads\n\n... but race condition between simultaneous nn_send and nn_connect in different thread (see my comment in #114)\nYour solution to problem on disconnect seems OK.\n. I didn't try it yet, but here is a hint: Add another state for sinproc between CONNECTING and ACTIVE, say \"READY\" in which socket can receive messages but can't send yet. And handshake should be two-way: firstly A sends \"READY\" to B, then B sends \"ACCEPTED\" to A\nHope this helps. However, it's only a guess.\n. Ok. I've done the fix (#167). In future, when you adding a \"switch\" statement to state machine, always add \"default\" case.\n. > As for SOL_ENDPOINT, AFAICS there are no socket-wide options at the moment (am I wrong?) thus a single value (SOL_SOCKET) should do.\nThe NN_SNDTIMEO and NN_RCVTIMEO are definitely socket-wide.\nThe NN_LINGER, NN_RECONNECT_IVL, NN_RECONNECT_IVL_MAX, are not very useful to be per-endpoint IMO (am I wrong?)\n. Ok Created #168 for that\n. Forgot to say that windows version has not been fixed. Should be trivial, but I have nowhere to test.\nThe patch is submitted under MIT License\n. Should be fixed by #169. It would be nice if you try that branch (https://github.com/tailhook/nanomsg/tree/fix_156)\n. Hm, you didn't say its on windows. Now that the given fix is in master, would you mind try current master with the following patch?\n```\ndiff --git a/src/aio/usock_win.inc b/src/aio/usock_win.inc\nindex 75743c5..bd97284 100644\n--- a/src/aio/usock_win.inc\n+++ b/src/aio/usock_win.inc\n@@ -430,6 +430,9 @@ static void nn_usock_shutdown (struct nn_fsm *self, int src, int type,\n             return;\n         }\n\n/  Notify our parent that pipe socket is shutting down  /\nnn_fsm_raise (&self->fsm, &self->event_error, NN_USOCK_SHUTDOWN);\n+\n         /  In all remaining states we'll simply cancel all overlapped\n             operations. /\n         if (nn_usock_cancel_io (usock) == 0)\n@@ -626,6 +629,8 @@ static void nn_usock_handler (struct nn_fsm *self, int src, int type,\n         case NN_FSM_ACTION:\n             switch (type) {\n             case NN_USOCK_ACTION_ERROR:\nnn_fsm_raise (&self->fsm, &self->event_error,\nNN_USOCK_SHUTDOWN);\n                 if (nn_usock_cancel_io (usock) == 0) {\n                     usock->state = NN_USOCK_STATE_DONE;\n                     return;\n```\n. Ah, sorry, this should work:\n\n```\ndiff --git a/src/aio/usock_win.inc b/src/aio/usock_win.inc\nindex 75743c5..a25bd5e 100644\n--- a/src/aio/usock_win.inc\n+++ b/src/aio/usock_win.inc\n@@ -430,6 +430,9 @@ static void nn_usock_shutdown (struct nn_fsm *self, int src, int type,\n             return;\n         }\n\n/  Notify our parent that pipe socket is shutting down  /\nnn_fsm_raise (&usock->fsm, &usock->event_error, NN_USOCK_SHUTDOWN);\n+\n         /  In all remaining states we'll simply cancel all overlapped\n             operations. /\n         if (nn_usock_cancel_io (usock) == 0)\n@@ -626,6 +629,8 @@ static void nn_usock_handler (struct nn_fsm *self, int src, int type,\n         case NN_FSM_ACTION:\n             switch (type) {\n             case NN_USOCK_ACTION_ERROR:\nnn_fsm_raise (&usock->fsm, &usock->event_error,\nNN_USOCK_SHUTDOWN);\n                 if (nn_usock_cancel_io (usock) == 0) {\n                     usock->state = NN_USOCK_STATE_DONE;\n                     return;\n```\n. Then, sorry, I can't test on windows unfortunately. @sustrik may help.\n. Any specific reason you need to include a \"protocol.h\"? I think you should include \"nanomsg/nn.h\" and any specific protocols you need, e.g. \"nanomsg/reqrep.h\".\n\nI think protocol.h is installed either by accident or for future pluggable protocols.\n. The header is not installed any more\n. > I notice all shutdown tests failed when I build from mainline.\nIf it's on windows then it's because of #169, that  improved shutdown tests, but haven't fixed the issue for windows. There is issue #172 for it.\n. Hm, that's interesting case. In posix:\n\nEAFNOSUPPORT\nThe implementation does not support the specified address family.\nEPROTONOSUPPORT\nThe protocol is not supported by the address family, or the protocol is not supported by the implementation.\n\nI think we should adhere to this semantics rather than inventing our own.\n(As a side note: I think xpub/xsub will be supported in the future anyway)\n. Added to #178. Can you try my branch?\nhttps://github.com/tailhook/nanomsg/tree/nanocat_fixes\n. Branch is merged, now. So I think it's safe to close it now.\n. Can you try nanocat on the both sides of your program and say if it reproduced with some combination of nanocat and your program?\nHere is a command-line for the server:\nnanocat --pub --bind tcp://0.0.0.0:8861 --data hello --interval 1\nHere is one for a client:\nnanocat --sub --connect tcp://127.0.0.1:8861 --ascii\nIf some combination works it will let us easier determine at which side is the problem.\nAlso given that monitoring branch just landed to master. You may try to recompile nanomsg from master and enable error reporting:\nset NN_PRINT_ERRORS=1\n./whatever_command_line --to-run-client --or-server\n. Hm, it's a bug that that statistics is printed :) (will look tomorrow) But according to statistics subscriber still thinks that there is a connection, so it doesn't reconnect. I'm currently working to have windows machine set up. I'll look into the problem as soon as I get there. And its nice that the bug is reproduced with nanocat.\n. Can you try this patch?\n```\ndiff --git a/src/core/global.c b/src/core/global.c\nindex 6b14aea..7639fbe 100644\n--- a/src/core/global.c\n+++ b/src/core/global.c\n@@ -72,10 +72,11 @@\n #include \n #include \n #include \n-#include \n#if defined NN_HAVE_WINDOWS\n #include \"../utils/win.h\"\n+#else\n+#include \n #endif\n/  Max number of concurrent SP sockets. /\n```\n. Do you have some experience with C? With minimal experience and a bit of googling it should be easy to fix. Mostly rename some functions on windows. I just don't have a windows box to test the code.\n. Here is what I've coded blindly:\n```\ndiff --git a/src/core/global.c b/src/core/global.c\nindex 6b14aea..1933050 100644\n--- a/src/core/global.c\n+++ b/src/core/global.c\n@@ -72,10 +72,12 @@\n #include \n #include \n #include \n-#include \n+#include \n#if defined NN_HAVE_WINDOWS\n #include \"../utils/win.h\"\n+#else\n+#include \n #endif\n/  Max number of concurrent SP sockets. /\n@@ -186,7 +188,6 @@ static void nn_global_init (void)\n#if defined NN_HAVE_WINDOWS\n     WSADATA data;\n-    int rc;\n #endif\n /*  Check whether the library was already initialised. If so, do nothing. */\n\n@@ -891,7 +892,11 @@ static void nn_global_submit_counter (int i, struct nn_sock s,\n     if (self.statistics_socket >= 0) {\n         /  TODO(tailhook) add HAVE_GMTIME_R ifdef  /\n         time(&numtime);\n+#ifdef NN_HAVE_WINDOWS\n+        _gmtime_s (&strtime, &numtime);\n+#else\n         gmtime_r (&numtime, &strtime);\n+#endif\n         strftime (timebuf, 20, \"%Y-%m-%dT%H:%M:%S\", &strtime);\n         if(s->socket_name) {\n             len = sprintf (buf, \"ESTP:%s:%s:socket.%s:%s: %sZ 10 %lu:c\",\n@@ -928,7 +933,11 @@ static void nn_global_submit_level (int i, struct nn_sock s,\n     if (self.statistics_socket >= 0) {\n         /  TODO(tailhook) add HAVE_GMTIME_R ifdef  /\n         time(&numtime);\n+#ifdef NN_HAVE_WINDOWS\n+        _gmtime_s (&strtime, &numtime);\n+#else\n         gmtime_r (&numtime, &strtime);\n+#endif\n         strftime (timebuf, 20, \"%Y-%m-%dT%H:%M:%S\", &strtime);\n         if(s->socket_name) {\n             len = sprintf (buf, \"ESTP:%s:%s:socket.%s:%s: %sZ 10 %d\",\n@@ -961,7 +970,11 @@ static void nn_global_submit_errors (int i, struct nn_sock s,\n     if (self.statistics_socket >= 0) {\n         /  TODO(tailhook) add HAVE_GMTIME_R ifdef  /\n         time(&numtime);\n+#ifdef NN_HAVE_WINDOWS\n+        _gmtime_s (&strtime, &numtime);\n+#else\n         gmtime_r (&numtime, &strtime);\n+#endif\n         strftime (timebuf, 20, \"%Y-%m-%dT%H:%M:%S\", &strtime);\n         if(s->socket_name) {\n             len = sprintf (buf, \"ESTP:%s:%s:socket.%s:%s: %sZ 10 %d\\n\",\n@@ -982,9 +995,15 @@ static void nn_global_submit_errors (int i, struct nn_sock *s,\n             ep = nn_cont (it, struct nn_ep, item);\n         if (ep->last_errno) {\n\n+#ifdef NN_HAVE_WINDOWS\n+                len = _snprintf_s (curbuf, buf_left,\n+                    \" nanomsg: Endpoint %d [%s] error: %s\\n\",\n+                    ep->eid, nn_ep_getaddr (ep), nn_strerror (ep->last_errno));\n+#else\n                 len = snprintf (curbuf, buf_left,\n                     \" nanomsg: Endpoint %d [%s] error: %s\\n\",\n                     ep->eid, nn_ep_getaddr (ep), nn_strerror (ep->last_errno));\n+#endif\n                 if (buf_left < len)\n                     break;\n                 curbuf += len;\n```\nFeel free to adjust and send a pull request\n. Should this be closed?\n. Reproduced on my test machine. The following patch fixes the problem:\n```\ndiff --git a/src/core/sock.c b/src/core/sock.c\nindex 2f5b435..65649ea 100644\n--- a/src/core/sock.c\n+++ b/src/core/sock.c\n@@ -712,8 +712,8 @@ static void nn_sock_onleave (struct nn_ctx *self)\n         else {\n             if (sock->flags & NN_SOCK_FLAG_IN) {\n                 sock->flags &= ~NN_SOCK_FLAG_IN;\n-                nn_efd_unsignal (&sock->rcvfd);\n             }\n+            nn_efd_unsignal (&sock->rcvfd);\n         }\n     }\n@@ -728,8 +728,8 @@ static void nn_sock_onleave (struct nn_ctx *self)\n         else {\n             if (sock->flags & NN_SOCK_FLAG_OUT) {\n                 sock->flags &= ~NN_SOCK_FLAG_OUT;\n-                nn_efd_unsignal (&sock->sndfd);\n             }\n+            nn_efd_unsignal (&sock->sndfd);\n         }\n     }\n }\n```\nThe problem is: it seem the send on windows is non-atomic even on localhost sockets (similar thing may be on non windows boxes too). So there is a moment where byte is already sent but not yet available for the receiver. At this moment we do nn_efd_unsignal and clear NN_SOCK_FLAG_OUT. So there is no chance to unsignal any more and we're in busy loop in nn_send because nn_efd_wait returns true.\nThe patch above will probably degrade performance too much, so I'm still searching for a real solution.\n. > ctest -V works fine on WIndows 8 with MSVC2008.\ncan you try many times? It occasionally works on our test machine too (Vista AFAICS)\n. The patch is submitted under MIT License\n. Which one? :)\n. It seems 179f54414e fixes issue\n. Hm this one fails when statistics enabled. Sorry for the noise\n. Its good question.\n1. If you keep trying nn_recv, do expect the error to switch to EFSM eventually?\n2. The ETIMEDOUT is reported when NN_RCVTIMEO reached, should we let user distinguish the difference between RCVTIMEO and DEADLINE?\n. Yes it's a bug in statistics\n. Fixed in master. You may check again and close the issue.\n. Applied\n. Already applied a bit different version\n. Patch seems ok. Can you state that the patch is submitted under MIT license?\n. > I started reading this: http://www.cmake.org/Wiki/CMake_Cross_Compiling and it seems that there is quite a lot involved in cross-compiling using CMake. Do I understand correctly that each new platform / toolchain requires a new target (i.e. .cmake file)?\nYes. Each toolchain needs .cmake file. But it's not per-project per-toolchain file. I.e. if you contribute .cmake file to your arm toolchain package, you can build any cmake project for arm. (According to the docs, I have no practical experience).\n. @rcari what is BSP? And can confirm that https://github.com/nanomsg/nanomsg/pull/80#issuecomment-20920440 is wrong?\n. @rcari, I was referring to the Luca's comparison of cross compiling with autotools:\n./configure --host=chost_variable\nAgainst making a toolchain file for cmake. I think we must summon @lu-zero to comment on this topic again :)\n. It describes how to build from a package. Where autogen is already done. For git version it's (probably) assumed that you are smart enough to know to run it. If you really care, you may add a hint that says to run autogen only on git version.\n. Patch seems ok. Can you state that the patch is submitted under MIT license?\n. Also what name should I add to the AUTHORS file?\n. Applied. Thanks!\n. After playing a bit with your examples, I'd say Yes, in this microbenchmark nanomsg is slower. IIRC, it's because nanomsg uses eventfd for each message now, while zeromq \"cheats\" by signalling only when it thinks that peer doesn't already know that there is a message.\nIt's should be payed off in any realistic application by the following:\n1. Any processing of the message is going to be order of magnitude slower, so you will not see the difference\n2. This is faster in zeromq only if your consumer is slower than producer (i.e. pipe always have messages waiting for consumer to receive)\n3. It's faster only for inproc, other transports should be same speed\n4. It's faster until you use any polling mechanism (zmq_poll/ZMQ_FD or nn_poll/NN_RCVFD/NN_SNDFD), and I bet nanomsg should be faster with polling because it integrates with OS polling mechanisms in more clean fashion\nBTW, you can use binaries in perf/ folder both in nanomsg and zeromq for quick comparison\n. Yes. That's expected, as I have said zeromq optimizes for the case of slow consumer for inproc (which I'd say quite unrealistic). And that difference for tcp is OK, since nanomsg is still in beta and we had not done many optimisations yet.\nFor example nanomsg gather a little bit of statistics while socket is running. You can also play with gcc/clang optimisation parameters and see that the difference changes :)\n. @earonesty \n\nAny processing of the message is going to be order of magnitude slower\n       therefore we should never benchmark a transport layer?\n\nWe should. But it doesn't mean we should optimize 0.1% performance\n\nThis is faster in zeromq only if your consumer is slower than producer\n      this happens all the time, when the producer is, itself, a consumer\n\nWhen producer itself a consumer there is no latency issue, it just puts message in it's own queue and it's already there when it reads queue. I'm not sure what you mean\n\nIt's faster only for inproc, other transports should be same speed\n       but not really\n\nYeah, the link to #319 says that TCP is faster than inproc. So it only supports my position\n\nIt's faster until you use any polling mechanism\n      yuck, who polls anymore? so 1997\n\nWell we are from different worlds. Most my applications are multiplexing different things in single thread. May be you misunderstand what I mean by polling here?\n@gdamore\n\nIf you're passing data within the same process, there are dozens of better ways to do it than nanomgs/inproc.\n\nTwo points here:\n1. Inproc is useful for passing data between multiple languages (e.g. C and Python) inside single process\n2. It's useful as a way to use nanomsg semantics (which is complex to emulate even using go channels), and to scale later (e.g. easily switch between inproc and network)\nBut none of them are very performance sensitive in my opinion. First one usually has big overhead because of \"impedance mismatch\" between languages. Second is because you will use non-inproc at production anyway.\n. > In fact, case 1 seems kind of a stretch IMO; if you have two languages in the same process, its probably because you have FFI and one of them is C, in which case you probably have a better way to move data between languages.\nI mean two languages in different threads communicating between each other. Useful in Python because of GIL.\nI'm not sure that making inproc with socket pipe is good idea. We probably should ask @sustrik, as I think he had some good cases for fast inproc transport from the ancient zeromq times.\n. Hi @vseryakov,\nI believe you should also add nn_sock_stat_increment and nn_sock_stat_report_error calls for statistics. Sorry that it's not documented anywere.\n. Probably yes. It's not actually related to #300.\nPresumably the issue is that for small messages it easier to copy message than to share it between threads (mostly because of processor cache issues and atomic counters we use for accounting). But for TCP, with small message we just read many into the larger buffer. So yes, it's kinda ok for this order of magnitude difference (Note: my analysis is based just on knowing the codebase parts, not by real profiling, so I may not be correct here).\nAt the end of the day, inproc with it's zero-copy semantics is tuned to be faster for large messages. For such tiny messages, any transport should be ok, as you are likely to be CPU-bound on message processing anyway. \n. @eldondev, I think you need to add --delay 0.2 to nanocat options. This is needed to let nanomsg establish connection (PUB socket just drops messages if there is no receiver, it's intentional).\nAnyway, I'm +1 for the --by-line option. I periodically need it to test some stuff.\n. Well, it seems weird that it worked before :)\nIt seems that delaying fsm start is ok, as long as it's ok to create sockets/endpoints before start. Which seems quite counter-intuitive (even if it's perfectly works now). Probably  the whole sockets machinery should be initialized at start action. What do you think?\n. According to the docs:\n\nEAFNOSUPPORT: Specified address family is not supported\n\nIn this case \"address family\" == domain. So \"rc\" code assignments should be swapped I think. I.e. code should become EINVAL if at least one socket with specified domain is found, otherwise EAFNOSUPPORT\n. ",
    "chuckremes": "Fixed.\n. Fixed.\n. Fixed.\n. Not a bug.\n. Do you really want tests from an unknown library running as superuser?\nChange your limits yourself and rerun. This is not a test harness problem.\nOn Feb 23, 2013, at 4:50 PM, Nir Soffer notifications@github.com wrote:\n\ngeekbox:build firas$ make test\nRunning tests...\nTest project /Users/firas/nanomsg/build\n      Start  1: inproc\n 1/16 Test  #1: inproc ..........................._Exception: Other  0.37 sec\n      Start  2: ipc\n 2/16 Test  #2: ipc .............................._Exception: Other  0.70 sec\n      Start  3: tcp\n 3/16 Test  #3: tcp ..............................***Exception: Other  0.83 sec\n      Start  4: pair\nThe test framework should increase the file limit to whatever needed for the process that run each test.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "catwell": "I have tried on a Linux box and apparently these lost messages also happen sometimes but they are harder to reproduce.\n. @nirs Here is a port from the LuaJIT test to C, without the assertions:\n``` c\ndefine SOCKET_ADDRESS \"ipc://test.ipc\"\ninclude \ninclude \"nn.h\"\ninclude \"reqrep.h\"\ninclude \"ipc.h\"\nint main () {\n  char req_buf[32];\n  char rep_buf[32];\n  int req;\n  int rep;\n  int resend_ivl;\n  int rc;\n  int i;\n  for (i = 0; i < 10; ++i) {\n    printf(\"%d\\n\",i);\n    rep = nn_socket(AF_SP, NN_REP);\n    rc = nn_bind(rep, SOCKET_ADDRESS);\n    req = nn_socket(AF_SP, NN_REQ);\n    nn_connect(req, SOCKET_ADDRESS);\n    resend_ivl = 100;\n    // comment the next line or increase resend_ivl to see the issue\n    nn_setsockopt(req, NN_REQ, NN_RESEND_IVL, &resend_ivl, sizeof(resend_ivl));\n    nn_send(req, \"REQ\", 3, 0);\n    nn_recv(rep, rep_buf, sizeof(rep_buf), 0);\n    nn_send(rep, \"REP\", 3, 0);\n    nn_recv(req, req_buf, sizeof(req_buf), 0);\n    nn_close(req);\n    nn_close(rep);\n  }\n}\n``\n. Hmm, what I mean is this: if you do not set theresend_ivl(or set to 60 seconds like the default) each iteration in the loop takes 60 seconds. No assertion fails, even if you add them, but the firstnn_recvblocks for the duration of theresend_ivl`.\nFrom what I understand that means that the first request is never received. Then since no answer is received it is re-sent, and that unblocks the call to nn_recv. Am I wrong about that? Or is that expected (the first message is dropped because nothing is ready to receive it)?\nNow that I think about it I realize maybe that's actually how it's supposed to work, but if that's the case it's not very intuitive IMO.\n. The LuaJIT code I ported it from does assert everything. I didn't add assertions here because it's an example but they don't fail.\nHere is the same code with assertions and a sleep where you said, it doesn't solve the problem (I set resend_ivl to 3 seconds so that the problem is visible).\n``` c\ndefine SOCKET_ADDRESS \"ipc://test.ipc\"\ninclude \ninclude \ninclude \ninclude \"nn.h\"\ninclude \"reqrep.h\"\ninclude \"ipc.h\"\nint main () {\n  char req_buf[32];\n  char rep_buf[32];\n  int req;\n  int rep;\n  int resend_ivl;\n  int rc;\n  int i;\n  for (i = 0; i < 10; ++i) {\n    printf(\"%d\\n\",i);\n    rep = nn_socket(AF_SP, NN_REP);\n    assert(rep != -1);\n    rc = nn_bind(rep, SOCKET_ADDRESS);\n    assert(rc >= 0);\n// sleep for 200 ms\nstruct timespec ts = {.tv_sec = 0, .tv_nsec = 200000000};\nrc = nanosleep (&ts, NULL);\nassert(rc == 0);\n\nreq = nn_socket(AF_SP, NN_REQ);\nassert(req != -1);\nrc = nn_connect(req, SOCKET_ADDRESS);\nassert(rc >= 0);\nresend_ivl = 3000; // 3 seconds is enough to notice the issue\nrc = nn_setsockopt(\n  req, NN_REQ,\n  NN_RESEND_IVL, &resend_ivl, sizeof(resend_ivl)\n);\nassert(rc == 0);\nrc = nn_send(req, \"REQ\", 3, 0);\nassert(rc == 3);\nrc = nn_recv(rep, rep_buf, sizeof(rep_buf), 0);\nassert(rc == 3);\nrc = nn_send(rep, \"REP\", 3, 0);\nassert(rc == 3);\nrc = nn_recv(req, req_buf, sizeof(req_buf), 0);\nassert(rc == 3);\nrc = nn_close(req);\nassert(rc == 0);\nrc = nn_close(rep);\nassert(rc == 0);\n\n}\n}\n```\n. The issue is not the output, it is the time it takes to get this output.\n. Confirmed, it works. Thanks!\n. I have updated to the latest trunk and apparently I get errors less often. The one that probably corresponds to what I got is:\nSocket is not connected [57] (/[...]/nanomsg/src/utils/aio_posix.inc:789)\nOn Mac OS and Linux I also often get this when I quit the server (may be due to me not cleaning things up correctly):\nBad file descriptor [9] (/[...]/nanomsg/src/utils/aio_posix.inc:283)\nOn Linux I also got that one:\nAssertion failed: !self->first (/[...]/nanomsg/src/utils/list.c:38)\nAborted (core dumped)\nHere is the backtrace from the core for the last one:\n```\n(gdb) backtrace\n0  0x00007fc0f0b222c5 in raise () from /usr/lib/libc.so.6\n1  0x00007fc0f0b23748 in abort () from /usr/lib/libc.so.6\n2  0x00007fc0f08d7dc9 in nn_err_abort () from /usr/local/lib/libnanomsg.so\n3  0x00007fc0f08d8df5 in nn_list_term () from /usr/local/lib/libnanomsg.so\n4  0x00007fc0f08d8a69 in nn_hash_insert () from /usr/local/lib/libnanomsg.so\n5  0x00007fc0f08ded5b in nn_xrep_add () from /usr/local/lib/libnanomsg.so\n6  0x00007fc0f08d276c in nn_sock_add () from /usr/local/lib/libnanomsg.so\n7  0x00007fc0f08d10e7 in nn_pipebase_init () from /usr/local/lib/libnanomsg.so\n8  0x00007fc0f08da455 in nn_stream_init () from /usr/local/lib/libnanomsg.so\n9  0x00007fc0f08d5ea1 in nn_astream_init () from /usr/local/lib/libnanomsg.so\n10 0x00007fc0f08d60f6 in nn_bstream_listening_accepted () from /usr/local/lib/libnanomsg.so\n11 0x00007fc0f08d4660 in nn_cp_worker () from /usr/local/lib/libnanomsg.so\n12 0x00007fc0f08dac6c in nn_thread_main_routine () from /usr/local/lib/libnanomsg.so\n13 0x00007fc0f04a8e0f in start_thread () from /usr/lib/libpthread.so.0\n14 0x00007fc0f0bd5efd in clone () from /usr/lib/libc.so.6\n```\n. Nope, I still get those errors (at least on OS X). I also reproduced this one on OS X now:\nAssertion failed: !self->first (/[...]/nanomsg/src/utils/list.c:38)\nAbort trap: 6\n. I still have issues, at least the \"bad file descriptor\" one which looks related to nn_shutdown (am I using it right?). This one is easy to reproduce, here is simple C code for that:\nmyserver.c\n``` c\ndefine SOCKET_ADDRESS \"ipc://test.ipc\"\ninclude \ninclude \"nn.h\"\ninclude \"reqrep.h\"\ninclude \"ipc.h\"\nint main () {\n  char buf[32];\n  int rc;\n  int rep = nn_socket(AF_SP, NN_REP);\n  assert(rep != -1);\n  int eid = nn_bind(rep, SOCKET_ADDRESS);\n  assert(eid >= 0);\n  rc = nn_recv(rep, buf, sizeof(buf), 0);\n  assert(rc == 3);\n  rc = nn_send(rep, \"abc\", 3, 0);\n  assert(rc == 3);\n  rc = nn_shutdown(rep, eid);\n  assert(rc == 0);\n  rc = nn_close(rep);\n  assert(rc == 0);\n}\n```\nmyclient.c\n``` c\ndefine SOCKET_ADDRESS \"ipc://test.ipc\"\ninclude \ninclude \"nn.h\"\ninclude \"reqrep.h\"\ninclude \"ipc.h\"\nint main () {\n  char buf[32];\n  int rc;\n  int req = nn_socket(AF_SP, NN_REQ);\n  assert(req != -1);\n  int eid = nn_connect(req, SOCKET_ADDRESS);\n  assert(eid >= 0);\n  rc = nn_send(req, \"abc\", 3, 0);\n  assert(rc == 3);\n  rc = nn_recv(req, buf, sizeof(buf), 0);\n  assert(rc == 3);\n  rc = nn_shutdown(req, eid);\n  assert(rc == 0);\n  rc = nn_close(req);\n  assert(rc == 0);\n}\n```\nrunning it\n$ for i in myclient myserver; do gcc -I/usr/local/include/nanomsg -lnanomsg $i.c -o $i; done\n$ ./myserver & sleep 1; ./myclient\n[2] 6413\n[1]   Abort trap: 6           ./myserver\nBad file descriptor [9] (/Users/pierre/tmp/nanomsg/src/utils/aio_posix.inc:298)\n. Another issue: using the same client, use this server:\n``` c\ndefine SOCKET_ADDRESS \"ipc://test.ipc\"\ninclude \ninclude \ninclude \"nn.h\"\ninclude \"reqrep.h\"\ninclude \"ipc.h\"\nint main () {\n  char buf[32];\n  int rc;\n  int eid;\n  int rep = nn_socket(AF_SP, NN_REP);\n  assert(rep != -1);\n  for (;;) {\n    eid = nn_bind(rep, SOCKET_ADDRESS);\n    assert(eid >= 0);\n    rc = nn_recv(rep, buf, sizeof(buf), 0);\n    assert(rc == 3);\n    printf(\"%s\\n\",buf);\n    rc = nn_send(rep, \"abc\", 3, 0);\n    assert(rc == 3);\n    rc = nn_shutdown(rep, eid);\n    assert(rc == 0);\n  }\n  // never reached...\n  rc = nn_close(rep);\n  assert(rc == 0);\n}\n```\nRun it in a terminal, then run the client several times in another. You should reach one of those situations:\n1) deadlock (the server freezes after printing \"abc\");\n2) this:\n- server\n$ ./myserver2\nabc\nabc\nabc\nInvalid argument [22] (/Users/pierre/tmp/nanomsg/src/utils/aio_posix.inc:237)\nAbort trap: 6\n- client\n$ ./myclient\n$ ./myclient\n$ ./myclient\nAssertion failed: (*self->sink)->err (/Users/pierre/tmp/nanomsg/src/utils/aio_posix.inc:762)\nAbort trap: 6\n. OK, here's the client:\n```\n0x00007fff9ab1dbca in __psynch_cvwait ()\n(gdb) thread apply all bt\nThread 2 (process 6702):\n0  0x00007fff9ab1e7e6 in kevent ()\n1  0x000000010fdeee7f in nn_poller_wait ()\n2  0x000000010fde636b in nn_cp_worker ()\n3  0x000000010fdf0828 in nn_thread_main_routine ()\n4  0x00007fff973ad8bf in _pthread_start ()\n5  0x00007fff973b0b75 in thread_start ()\nThread 1 (process 6702):\n0  0x00007fff9ab1dbca in __psynch_cvwait ()\n1  0x00007fff973b1274 in _pthread_cond_wait ()\n2  0x000000010fdea814 in nn_cond_wait ()\n3  0x000000010fde2201 in nn_sock_recv ()\n4  0x000000010fddec3c in nn_recv ()\n5  0x000000010fdd6d64 in main ()\n```\nAnd the server:\n```\n0x00007fff9ab1dbca in __psynch_cvwait ()\n(gdb) thread apply all bt\nThread 2 (process 6700):\n0  0x00007fff9ab1e7e6 in kevent ()\n1  0x0000000105ab9e7f in nn_poller_wait ()\n2  0x0000000105ab136b in nn_cp_worker ()\n3  0x0000000105abb828 in nn_thread_main_routine ()\n4  0x00007fff973ad8bf in _pthread_start ()\n5  0x00007fff973b0b75 in thread_start ()\nThread 1 (process 6700):\n0  0x00007fff9ab1dbca in __psynch_cvwait ()\n1  0x00007fff973b1274 in _pthread_cond_wait ()\n2  0x0000000105ab5814 in nn_cond_wait ()\n3  0x0000000105aad201 in nn_sock_recv ()\n4  0x0000000105aa9c3c in nn_recv ()\n5  0x0000000105a9ed63 in main ()\n```\nSo as I thought both are in blocked the recv state.\n. I tried with a2bf130bc4959ccc3c6f90909b3ba821462512b4 (current head), looks still broken. With the first example the error is now on line 323:\nBad file descriptor [9] (/Users/pierre/tmp/nanomsg/src/utils/aio_posix.inc:323)\nAbort trap: 6\nDid you not manage to reproduce it? This one is really systematic.\nWith the looping server deadlocks still occur (same backtraces). I didn't reproduce the crash but maybe that's because I didn't try hard enough.\n. I am trying on a Linux machine now. The first issue exists there too:\nBad file descriptor [9] (/home/catwell/tmp/nanomsg/src/utils/aio_posix.inc:323)\nAborted (core dumped)\nI could not reproduce the deadlock but I did manage to make the server crash by calling the client repetitively:\n[catwell@vaio cwtest]$ ./myserver2\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nabc\nAssertion failed: self->first == NULL (/home/catwell/tmp/nanomsg/src/utils/list.c:36)\nAborted (core dumped)\nI will try to build in debug mode now.\n. Here's the gdb output for the assert on line 323 on the Linux box:\n```\n[catwell@vaio cwtest]$ gdb ./myserver\nGNU gdb (GDB) 7.5.1\nCopyright (C) 2012 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.html\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-unknown-linux-gnu\".\nFor bug reporting instructions, please see:\nhttp://www.gnu.org/software/gdb/bugs/...\nReading symbols from /home/catwell/tmp/nanomsg/cwtest/myserver...(no debugging symbols found)...done.\n(gdb) run\nStarting program: /home/catwell/tmp/nanomsg/cwtest/myserver \nwarning: Could not load shared library symbols for linux-vdso.so.1.\nDo you need \"set solib-search-path\" or \"set sysroot\"?\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/usr/lib/libthread_db.so.1\".\n[New Thread 0x7ffff73df700 (LWP 4014)]\nBad file descriptor [9] (/home/catwell/tmp/nanomsg/src/utils/aio_posix.inc:323)\nProgram received signal SIGABRT, Aborted.\n0x00007ffff78392c5 in raise () from /usr/lib/libc.so.6\n(gdb) thread apply all bt\nThread 2 (Thread 0x7ffff73df700 (LWP 4014)):\n0  0x00007ffff73ee10c in __lll_lock_wait () from /usr/lib/libpthread.so.0\n1  0x00007ffff73e9f2c in _L_lock_513 () from /usr/lib/libpthread.so.0\n2  0x00007ffff73e9d7b in pthread_mutex_lock () from /usr/lib/libpthread.so.0\n3  0x00007ffff7bc6435 in nn_mutex_lock (self=0x602430)\nat /home/catwell/tmp/nanomsg/src/utils/mutex.c:70\n\n4  0x00007ffff7bc0e79 in nn_cp_worker (arg=0x602430)\nat /home/catwell/tmp/nanomsg/src/utils/aio_posix.inc:428\n\n5  0x00007ffff7bc7e60 in nn_thread_main_routine (arg=0x602660)\nat /home/catwell/tmp/nanomsg/src/utils/thread.c:84\n\n6  0x00007ffff73e7e0f in start_thread () from /usr/lib/libpthread.so.0\n7  0x00007ffff78ecefd in clone () from /usr/lib/libc.so.6\nThread 1 (Thread 0x7ffff7fe5700 (LWP 4010)):\n0  0x00007ffff78392c5 in raise () from /usr/lib/libc.so.6\n1  0x00007ffff783a748 in abort () from /usr/lib/libc.so.6\n2  0x00007ffff7bc4d6d in nn_err_abort ()\nat /home/catwell/tmp/nanomsg/src/utils/err.c:33\n\n3  0x00007ffff7bc0a94 in nn_usock_term (self=0x602cd8)\nat /home/catwell/tmp/nanomsg/src/utils/aio_posix.inc:323\n\n4  0x00007ffff7bc18ea in nn_usock_close (self=0x602cd8)\nat /home/catwell/tmp/nanomsg/src/utils/aio_posix.inc:604\n\n---Type  to continue, or q  to quit---\n5  0x00007ffff7bc3022 in nn_bstream_close (self=0x602c28)\nat /home/catwell/tmp/nanomsg/src/utils/bstream.c:127\n\n6  0x00007ffff7bbcb87 in nn_ep_close (self=0x602c28)\nat /home/catwell/tmp/nanomsg/src/core/ep.c:92\n\n7  0x00007ffff7bbd49e in nn_sock_destroy (self=0x602420)\nat /home/catwell/tmp/nanomsg/src/core/sock.c:148\n\n8  0x00007ffff7bbb804 in nn_close (s=0)\nat /home/catwell/tmp/nanomsg/src/core/ctx.c:403\n\n9  0x0000000000400946 in main ()\n(gdb) \n```\n. Here's the gdb output for the deadlock on OS X:\n- client\n```\nThread 2 (process 7814):\n0  0x00007fff9ab1e7e6 in kevent ()\n1  0x00000001048a5e6f in nn_poller_wait (self=0x7f9e4a001480, timeout=-1) at poller_kqueue.inc:172\n2  0x000000010489d36b in nn_cp_worker (arg=0x7f9e4a001410) at aio_posix.inc:425\n3  0x00000001048a7728 in nn_thread_main_routine (arg=0x7f9e4a0018f8) at thread.c:84\n4  0x00007fff973ad8bf in _pthread_start ()\n5  0x00007fff973b0b75 in thread_start ()\nThread 1 (process 7814):\n0  0x00007fff9ab1dbca in __psynch_cvwait ()\n1  0x00007fff973b1274 in _pthread_cond_wait ()\n2  0x00000001048a1804 in nn_cond_wait (self=0x7f9e4a001910, mutex=0x7f9e4a001410) at cond.c:171\n3  0x00000001048991c1 in nn_sock_recv (self=0x7f9e4a001400, msg=0x7fff6448ba38, flags=0) at sock.c:610\n4  0x0000000104895bfc in nn_recv (s=0, buf=0x7fff6448bb14, len=32, flags=0) at ctx.c:566\n5  0x000000010488cd64 in main ()\n```\n- server\n```\nThread 2 (process 7811):\n0  0x00007fff9ab1e7e6 in kevent ()\n1  0x000000010ca61e6f in nn_poller_wait (self=0x7fbb23001480, timeout=-1) at poller_kqueue.inc:172\n2  0x000000010ca5936b in nn_cp_worker (arg=0x7fbb23001410) at aio_posix.inc:425\n3  0x000000010ca63728 in nn_thread_main_routine (arg=0x7fbb230018f8) at thread.c:84\n4  0x00007fff973ad8bf in _pthread_start ()\n5  0x00007fff973b0b75 in thread_start ()\nThread 1 (process 7811):\n0  0x00007fff9ab1dbca in __psynch_cvwait ()\n1  0x00007fff973b1274 in _pthread_cond_wait ()\n2  0x000000010ca5d804 in nn_cond_wait (self=0x7fbb23001910, mutex=0x7fbb23001410) at cond.c:171\n3  0x000000010ca551c1 in nn_sock_recv (self=0x7fbb23001400, msg=0x7fff6c647a38, flags=0) at sock.c:610\n4  0x000000010ca51bfc in nn_recv (s=0, buf=0x7fff6c647b0c, len=32, flags=0) at ctx.c:566\n5  0x000000010ca48d63 in main ()\n```\n. I can confirm:\n1. that it fixed this issue on Linux\n2. that it didn't fix the other issues (\"Bad file descriptor\" with the single response client and deadlock on OS X)\n. Now another assertion fails (on the server, only tested on Mac OS for now):\n$ ./myserver2\nabc\nAssertion failed: 0 (/[...]/nanomsg/src/core/sock.c:833)\nAbort trap: 6\nNote: I just re-run the C tests above as-is, I didn't check if the API changed so maybe I'm doing something wrong. If I use a TCP socket instead of IPC I get:\n$ ./myserver2\nabc\nAddress already in use [48] (/[...]/nanomsg/src/transports/tcp/btcp.c:325)\nAbort trap: 6\nI don't have too much time on my hands to check out what changed and update the luajit binding but I'll probably do it next week.\n. Actually the test version I was running had the last four lines commented out. When I run the actual code above (which can also be found in https://github.com/catwell/nanomsg-crashers) nothing happens (meaning the client doesn't terminate and the server doesn't print \"abc\", they just hang), with both servers. So I guess something must have changed in the API, I'll check it out on Sunday.\n. OK, I actually have no way to verify this because my examples crash because of (I think) unrelated issues.\nMy C test cases are here. If I run myserver (or myserver2) and myclient on a Linux box both crash at nn_close(). On the server the issue is:\nAssertion failed: 0 (/[...]/nanomsg/src/core/sock.c:833)\nOn the client I have seen various errors including:\nDevice or resource busy [16] (/[...]/nanomsg/src/utils/mutex.c:63)\nAssertion failed: 0 (/[...]/nanomsg/src/core/sock.c:833)\nAssertion failed: 0 (/[...]/nanomsg/src/aio/usock_posix.inc:737)\n. Actually, with my test cases, I still have issues...\nWith myserver2 and myclient I get randomly on the client side:\nFrequently\nconnect\nsend\nrecv\nshutdown\nclose\nDevice or resource busy [16] (src/utils/mutex.c:63)\nAborted (core dumped)\nLess frequently one of those:\nconnect\nsend\nrecv\nshutdown\nNo such file or directory [2] (src/aio/poller_epoll.inc:84)\nclose\nAborted (core dumped)\nconnect\nsend\nrecv\nshutdown\nAssertion failed: self->state == NN_USOCK_STATE_IDLE (src/aio/usock_posix.inc:106)\nAborted (core dumped)\nconnect\nsend\nrecv\nshutdown\nNo such file or directory [2] (src/aio/poller_epoll.inc:84)\nclose\nclose\nmyclient: ../nptl/pthread_mutex_lock.c:80: __pthread_mutex_lock: Assertion `mutex->__data.__owner == 0' failed.\nAborted (core dumped)\nconnect\nsend\nrecv\nBad file descriptor [9] (src/aio/poller_epoll.inc:107)\nAborted (core dumped)\nconnect\nsend\nrecv\nshutdown\nclose\n*** Error in `./myclient': double free or corruption (fasttop): 0x00007f92f40008c0 ***\nconnect\nsend\nrecv\nshutdown\nclose\nUnexpected source: state=8 source=-1 action=1 (src/aio/usock_posix.inc:737)\nAborted (core dumped)\n. Much better! I still managed to get this one by running the client in a loop (while true; do ./myclient; done) but that's all.\nconnect\nsend\nrecv\nBad file descriptor [9] (src/aio/poller_epoll.inc:107)\nAborted (core dumped)\n. Hmm, I do not reproduce it on Linux... I got something else though:\nFile exists [17] (/home/catwell/tmp/nanomsg/src/utils/poller_epoll.inc:65)\nAborted (core dumped)\n. OK, I don' t know if that's any use to you but I tracked what happens to that fd. It is added to the poller twice, the first time here and the second here.\nBoth originate from calls to nn_cstream_waiting_timeout, the first one from nn_cstream_init as expected and the second one from nn_cstream_connected_err here. So it looks like part of what doesn' t work is the re-connection mechanism.\nAlso, the reason the state machine goes into the failure state in the first place is because the header exchange times out.\n. Now this example doesn't even run. If I run the server and the client, I get on the server side:\n$ ./myserver\nabc\nAddress already in use [48] (src/transports/tcp/btcp.c:378)\nAbort trap: 6\n. ",
    "burke": "I'm sure this is the wrong solution, so I won't even bother to open a pull request for it, but I had this problem too, and the following patch fixed the issue for me:\ndiff\ndiff --git a/src/core/sock.c b/src/core/sock.c\nindex e125faf..f4753d4 100644\n--- a/src/core/sock.c\n+++ b/src/core/sock.c\n@@ -838,6 +838,13 @@ finish1:\n                 sock->sockbase->vfptr->out (sock->sockbase,\n                     (struct nn_pipe*) srcptr);\n                 return;\n+            case NN_EP_STOPPED:\n+                /*  Endpoint is stopped. Now we can safely deallocate it. */\n+                ep = (struct nn_ep*) srcptr;\n+                nn_list_erase (&sock->eps, &ep->item);\n+                nn_ep_term (ep);\n+                nn_free (ep);\n+                return;\n             default:\n                 nn_assert (0);\n             }\n(I'm just diving into nanomsg, and the code is wonderfully clean. It's a pleasure to read. Nice work!)\n. ",
    "ksergey": "``` gdb\nexecve(\"./ipc_shutdown\", [\"./ipc_shutdown\"], [/ 62 vars /]) = 0\nbrk(0)                                  = 0x8bc2000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7769000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/tls/i686/sse2/cmov/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/tls/i686/sse2/cmov\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/tls/i686/sse2/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/tls/i686/sse2\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/tls/i686/cmov/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/tls/i686/cmov\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/tls/i686/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/tls/i686\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/tls/sse2/cmov/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/tls/sse2/cmov\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/tls/sse2/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/tls/sse2\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/tls/cmov/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/tls/cmov\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/tls/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/tls\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/i686/sse2/cmov/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/i686/sse2/cmov\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/i686/sse2/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/i686/sse2\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/i686/cmov/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/i686/cmov\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/i686/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/i686\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/sse2/cmov/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/sse2/cmov\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/sse2/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/sse2\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/cmov/libnanomsg.so\", O_RDONLY) = -1 ENOENT (No such file or directory)\nstat64(\"/home/indie/nanomsg-master/b/cmov\", 0xbfa1e784) = -1 ENOENT (No such file or directory)\nopen(\"/home/indie/nanomsg-master/b/libnanomsg.so\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\300g\\0\\0004\\0\\0\\0\"..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0775, st_size=482431, ...}) = 0\nmmap2(NULL, 157680, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x6f2000\nmprotect(0x716000, 4096, PROT_NONE)     = 0\nmmap2(0x717000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x24) = 0x717000\nclose(3)                                = 0\nopen(\"/home/indie/nanomsg-master/b/libpthread.so.0\", O_RDONLY) = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY)      = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=90207, ...}) = 0\nmmap2(NULL, 90207, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7752000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/i386-linux-gnu/libpthread.so.0\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\200[\\0\\0004\\0\\0\\0\"..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=124745, ...}) = 0\nmmap2(NULL, 107016, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xbc5000\nmmap2(0xbdc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x16) = 0xbdc000\nmmap2(0xbde000, 4616, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xbde000\nclose(3)                                = 0\nopen(\"/home/indie/nanomsg-master/b/libc.so.6\", O_RDONLY) = -1 ENOENT (No such file or directory)\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/i386-linux-gnu/libc.so.6\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0p\\222\\1\\0004\\0\\0\\0\"..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1552584, ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7751000\nmmap2(NULL, 1563160, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x1cf000\nmmap2(0x347000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x178) = 0x347000\nmmap2(0x34a000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x34a000\nclose(3)                                = 0\nopen(\"/home/indie/nanomsg-master/b/librt.so.1\", O_RDONLY) = -1 ENOENT (No such file or directory)\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/i386-linux-gnu/librt.so.1\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\260\\30\\0\\0004\\0\\0\\0\"..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0644, st_size=30684, ...}) = 0\nmmap2(NULL, 33364, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xc9f000\nmmap2(0xca6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6) = 0xca6000\nclose(3)                                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7750000\nset_thread_area({entry_number:-1 -> 6, base_addr:0xb77506c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xca6000, 4096, PROT_READ)     = 0\nmprotect(0x347000, 8192, PROT_READ)     = 0\nmprotect(0xbdc000, 4096, PROT_READ)     = 0\nmprotect(0x717000, 4096, PROT_READ)     = 0\nmprotect(0x804a000, 4096, PROT_READ)    = 0\nmprotect(0xfa1000, 4096, PROT_READ)     = 0\nmunmap(0xb7752000, 90207)               = 0\nset_tid_address(0xb7750728)             = 22051\nset_robust_list(0xb7750730, 0xc)        = 0\nfutex(0xbfa1ecfc, FUTEX_WAKE_PRIVATE, 1) = 0\nfutex(0xbfa1ecfc, FUTEX_WAIT_BITSET_PRIVATE|FUTEX_CLOCK_REALTIME, 1, NULL, b77506c0) = -1 EAGAIN (Resource temporarily unavailable)\nrt_sigaction(SIGRTMIN, {0xbca530, [], SA_SIGINFO}, NULL, 8) = 0\nrt_sigaction(SIGRT_1, {0xbca5b0, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0\nrt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0\ngetrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0\nuname({sys=\"Linux\", node=\"hole\", ...})  = 0\nbrk(0)                                  = 0x8bc2000\nbrk(0x8be3000)                          = 0x8be3000\neventfd2(0, O_CLOEXEC)                  = 3\nfcntl64(3, F_GETFL)                     = 0x2 (flags O_RDWR)\nfcntl64(3, F_SETFL, O_RDWR|O_NONBLOCK)  = 0\neventfd2(0, O_CLOEXEC)                  = 4\nfcntl64(4, F_GETFL)                     = 0x2 (flags O_RDWR)\nfcntl64(4, F_SETFL, O_RDWR|O_NONBLOCK)  = 0\nepoll_create1(O_CLOEXEC)                = 5\nclock_gettime(CLOCK_MONOTONIC, {184482, 313359291}) = 0\nepoll_ctl(5, EPOLL_CTL_ADD, 4, {0, {u32=146549836, u64=146549836}}) = 0\nepoll_ctl(5, EPOLL_CTL_MOD, 4, {EPOLLIN, {u32=146549836, u64=146549836}}) = 0\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb6f4f000\nmprotect(0xb6f4f000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb774f494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb774fbd8, {entry_number:6, base_addr:0xb774fb70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb774fbd8) = 22052\nclock_gettime(CLOCK_MONOTONIC, {184482, 314408515}) = 0\nwrite(3, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8)         = 8\nunlink(\"test.ipc\")                      = 0\nsocket(PF_FILE, SOCK_STREAM|SOCK_CLOEXEC, 0) = 6\nfcntl64(6, F_GETFL)                     = 0x2 (flags O_RDWR)\nfcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK)  = 0\nsetsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\nbind(6, {sa_family=AF_FILE, path=\"test.ipc\"}, 110) = 0\nlisten(6, 10)                           = 0\nwrite(4, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8)         = 8\nwrite(4, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8)         = 8\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb674e000\nmprotect(0xb674e000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb6f4e494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb6f4ebd8, {entry_number:6, base_addr:0xb6f4eb70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb6f4ebd8) = 22053\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb5f4d000\nmprotect(0xb5f4d000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb674d494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb674dbd8, {entry_number:6, base_addr:0xb674db70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb674dbd8) = 22054\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb574c000\nmprotect(0xb574c000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb5f4c494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb5f4cbd8, {entry_number:6, base_addr:0xb5f4cb70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb5f4cbd8) = 22055\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb4f4b000\nmprotect(0xb4f4b000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb574b494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb574bbd8, {entry_number:6, base_addr:0xb574bb70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb574bbd8) = 22056\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb474a000\nmprotect(0xb474a000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb4f4a494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb4f4abd8, {entry_number:6, base_addr:0xb4f4ab70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb4f4abd8) = 22057\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb3f49000\nmprotect(0xb3f49000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb4749494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb4749bd8, {entry_number:6, base_addr:0xb4749b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb4749bd8) = 22058\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb3748000\nmprotect(0xb3748000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb3f48494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb3f48bd8, {entry_number:6, base_addr:0xb3f48b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb3f48bd8) = 22059\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb2f47000\nmprotect(0xb2f47000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb3747494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb3747bd8, {entry_number:6, base_addr:0xb3747b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb3747bd8) = 22060\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb2746000\nmprotect(0xb2746000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb2f46494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb2f46bd8, {entry_number:6, base_addr:0xb2f46b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb2f46bd8) = 22061\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb1f45000\nmprotect(0xb1f45000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb2745494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb2745bd8, {entry_number:6, base_addr:0xb2745b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb2745bd8) = 22062\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb1744000\nmprotect(0xb1744000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb1f44494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb1f44bd8, {entry_number:6, base_addr:0xb1f44b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb1f44bd8) = 22063\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb0f43000\nmprotect(0xb0f43000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb1743494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb1743bd8, {entry_number:6, base_addr:0xb1743b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb1743bd8) = 22064\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xb0742000\nmprotect(0xb0742000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb0f42494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb0f42bd8, {entry_number:6, base_addr:0xb0f42b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb0f42bd8) = 22065\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xaff41000\nmprotect(0xaff41000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xb0741494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xb0741bd8, {entry_number:6, base_addr:0xb0741b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xb0741bd8) = 22066\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xaf740000\nmprotect(0xaf740000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xaff40494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xaff40bd8, {entry_number:6, base_addr:0xaff40b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xaff40bd8) = 22067\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xaef3f000\nmprotect(0xaef3f000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xaf73f494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xaf73fbd8, {entry_number:6, base_addr:0xaf73fb70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xaf73fbd8) = 22068\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xae73e000\nmprotect(0xae73e000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xaef3e494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xaef3ebd8, {entry_number:6, base_addr:0xaef3eb70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xaef3ebd8) = 22069\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xadf3d000\nmprotect(0xadf3d000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xae73d494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xae73dbd8, {entry_number:6, base_addr:0xae73db70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xae73dbd8) = 22070\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xad73c000\nmprotect(0xad73c000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xadf3c494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xadf3cbd8, {entry_number:6, base_addr:0xadf3cb70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xadf3cbd8) = 22071\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xacf3b000\nmprotect(0xacf3b000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xad73b494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xad73bbd8, {entry_number:6, base_addr:0xad73bb70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xad73bbd8) = 22073\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xabf39000\nmprotect(0xabf39000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xac739494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xac739bd8, {entry_number:6, base_addr:0xac739b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xac739bd8) = 22074\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xab738000\nmprotect(0xab738000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xabf38494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xabf38bd8, {entry_number:6, base_addr:0xabf38b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xabf38bd8) = 22075\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xaaf37000\nmprotect(0xaaf37000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xab737494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xab737bd8, {entry_number:6, base_addr:0xab737b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xab737bd8) = 22076\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xaa736000\nmprotect(0xaa736000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xaaf36494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xaaf36bd8, {entry_number:6, base_addr:0xaaf36b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xaaf36bd8) = 22077\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xa9f35000\nmprotect(0xa9f35000, 4096, PROT_NONE)   = 0\nclone(child_stack=0xaa735494, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0xaa735bd8, {entry_number:6, base_addr:0xaa735b70, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}, child_tidptr=0xaa735bd8) = 22078\nmmap2(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0xa9734000\nmprotect(0xa9734000, 4096, PROT_NONE)   = 0\nclone( \n+++ killed by SIGSEGV (core dumped) +++\nThread 79 (Thread 0x906f4b70 (LWP 4630)):\n0  clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:111\nNo locals.\n1  0x003d0f00 in ?? ()\nNo symbol table info available.\n2  0x00000000 in ?? ()\nNo symbol table info available.\nThread 78 (Thread 0x90ef5b70 (LWP 4628)):\n0  clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:111\nNo locals.\n1  0x003d0f00 in ?? ()\nNo symbol table info available.\n2  0x00000000 in ?? ()\nNo symbol table info available.\nThread 77 (Thread 0xb77436c0 (LWP 4550)):\n0  clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:111\nNo locals.\n1  0x00000000 in ?? ()\nNo symbol table info available.\nThread 76 (Thread 0x94efdb70 (LWP 4620)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4620\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e2b0) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e2b0\n\n8  0x00d6ed31 in start_thread (arg=0x94efdb70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x94efdb70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1796221800, -385644895, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 75 (Thread 0x93efbb70 (LWP 4622)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4622\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e2c8) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e2c8\n\n8  0x00d6ed31 in start_thread (arg=0x93efbb70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x93efbb70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1813007208, -373061969, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 74 (Thread 0x92ef9b70 (LWP 4624)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4624\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e2e0) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e2e0\n\n8  0x00d6ed31 in start_thread (arg=0x92ef9b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x92ef9b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1829792616, -377256275, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 73 (Thread 0x91ef7b70 (LWP 4626)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4626\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e2f8) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e2f8\n\n8  0x00d6ed31 in start_thread (arg=0x91ef7b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x91ef7b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1846578024, -398227797, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 72 (Thread 0x95effb70 (LWP 4618)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4618\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e298) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e298\n\n8  0x00d6ed31 in start_thread (arg=0x95effb70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x95effb70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1779436392, -381450589, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 71 (Thread 0x946fcb70 (LWP 4621)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4621\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e2bc) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e2bc\n\n8  0x00d6ed31 in start_thread (arg=0x946fcb70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x946fcb70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1804614504, -383547744, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 70 (Thread 0x956feb70 (LWP 4619)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4619\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e2a4) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e2a4\n\n8  0x00d6ed31 in start_thread (arg=0x956feb70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x956feb70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1787829096, -379353438, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 69 (Thread 0x916f6b70 (LWP 4627)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4627\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e304) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e304\n\n8  0x00d6ed31 in start_thread (arg=0x916f6b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x916f6b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1854970728, -396130646, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 68 (Thread 0x926f8b70 (LWP 4625)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4625\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e2ec) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e2ec\n\n8  0x00d6ed31 in start_thread (arg=0x926f8b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x926f8b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1838185320, -375159124, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 67 (Thread 0x936fab70 (LWP 4623)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4623\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e2d4) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e2d4\n\n8  0x00d6ed31 in start_thread (arg=0x936fab70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x936fab70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1821399912, -370964818, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 66 (Thread 0x96700b70 (LWP 4617)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4617\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e28c) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e28c\n\n8  0x00d6ed31 in start_thread (arg=0x96700b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x96700b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1771043688, -693926236, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 65 (Thread 0x96f01b70 (LWP 4616)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4616\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e280) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e280\n\n8  0x00d6ed31 in start_thread (arg=0x96f01b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x96f01b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1762650984, -696023387, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 64 (Thread 0x97702b70 (LWP 4615)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4615\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e274) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e274\n\n8  0x00d6ed31 in start_thread (arg=0x97702b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x97702b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1754258280, -689731930, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 63 (Thread 0x97f03b70 (LWP 4614)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4614\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e268) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e268\n\n8  0x00d6ed31 in start_thread (arg=0x97f03b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x97f03b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1745865576, -691829081, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 62 (Thread 0x98704b70 (LWP 4613)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4613\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e25c) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e25c\n\n8  0x00d6ed31 in start_thread (arg=0x98704b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x98704b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1737472872, -702314824, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 61 (Thread 0x98f05b70 (LWP 4612)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4612\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e250) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e250\n\n8  0x00d6ed31 in start_thread (arg=0x98f05b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x98f05b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1729080168, -704411975, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 60 (Thread 0x99706b70 (LWP 4611)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4611\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e244) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e244\n\n8  0x00d6ed31 in start_thread (arg=0x99706b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x99706b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1720687464, -698120518, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 59 (Thread 0x99f07b70 (LWP 4610)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4610\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e238) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e238\n\n8  0x00d6ed31 in start_thread (arg=0x99f07b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x99f07b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1712294760, -700217669, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 58 (Thread 0x9a708b70 (LWP 4609)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4609\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e22c) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e22c\n\n8  0x00d6ed31 in start_thread (arg=0x9a708b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x9a708b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1703902056, -677148996, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 57 (Thread 0x9af09b70 (LWP 4608)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4608\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e220) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e220\n\n8  0x00d6ed31 in start_thread (arg=0x9af09b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0x9af09b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1695509352, -679246147, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 56 (Thread 0xb6f41b70 (LWP 4552)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4552\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3df80) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3df80\n\n8  0x00d6ed31 in start_thread (arg=0xb6f41b70) at pthread_create.c:304\n    __res = <optimized out>\n    pd = 0xb6f41b70\n    now = <optimized out>\n    unwind_buf = {cancel_jmp_buf = {{jmp_buf = {14155764, 0, 4001536, -1225517928, -561805595, -1686182519}, mask_was_saved = 0}}, priv = {pad = {0x0, 0x0, 0x0, 0x0}, data = {prev = 0x0, cleanup = 0x0, \n          canceltype = 0}}}\n    not_first_call = <optimized out>\n    robust = <optimized out>\n    pagesize_m1 = <optimized out>\n    sp = <optimized out>\n    freesize = <optimized out>\n    __PRETTY_FUNCTION__ = \"start_thread\"\n\n9  0x001e346e in clone () at ../sysdeps/unix/sysv/linux/i386/clone.S:130\nNo locals.\nBacktrace stopped: Not enough registers or memory available to unwind further\nThread 55 (Thread 0x9b70ab70 (LWP 4607)):\n0  0x00a02416 in __kernel_vsyscall ()\nNo symbol table info available.\n1  0x00d75619 in __lll_lock_wait () at ../nptl/sysdeps/unix/sysv/linux/i386/i686/../i486/lowlevellock.S:142\nNo locals.\n2  0x00d70f7d in _L_lock_708 () from /lib/i386-linux-gnu/libpthread.so.0\nNo locals.\n3  0x00d70dc3 in __pthread_mutex_lock (mutex=0xbb17c0) at pthread_mutex_lock.c:61\n    __PRETTY_FUNCTION__ = \"__pthread_mutex_lock\"\n    type = <optimized out>\n    id = 4607\n\n4  0x00b9ba71 in nn_glock_lock () at /home/indie/nanomsg-master/src/utils/glock.c:63\n    rc = 0\n\n5  0x00b91e4a in nn_socket (domain=1, protocol=33) at /home/indie/nanomsg-master/src/core/ctx.c:334\n    rc = 0\n    s = 0\n    it = 0x0\n    socktype = 0x0\n\n6  0x08048d84 in routine (arg=0x0) at /home/indie/nanomsg-master/tests/ipc_shutdown.c:42\n    rc = 1304607\n    s = 0\n\n7  0x08048c23 in nn_thread_main_routine (arg=0xbff3e214) at /home/indie/nanomsg-master/tests/../src/utils/thread.c:84\n    rc = 0\n    sigset = {__val = {2147483647, 4294967294, 4294967295 <repeats 30 times>}}\n    self = 0xbff3e214\n\n8  0x00d6ed31 in start_thread (arg=0x9b70\n. Looks good for me. Thanks!\n. Thanks for links!\n. Looks like something goes wrong during merge. I couldn't found src/pkgconfig.in in master.\n. reolved\n. The same assert happens if established push-pull connection closed from PULL side\n. resolved\n.\n[100%] Running tests...\nTest project /home/indie/dev/nanomsg/build\n      Start  1: inproc\n 1/28 Test  #1: inproc ...........................   Passed    0.40 sec\n      Start  2: inproc_shutdown\n 2/28 Test  #2: inproc_shutdown ..................   Passed    0.06 sec\n      Start  3: ipc\n 3/28 Test  #3: ipc ..............................   Passed    0.21 sec\n      Start  4: ipc_shutdown\n 4/28 Test  #4: ipc_shutdown .....................***Exception: Other  0.20 sec\nAssertion failed: type == NN_EP_STOPPED (/home/indie/dev/nanomsg/src/core/sock.c:742)\n  Start  5: tcp\n\n5/28 Test  #5: tcp ..............................   Passed    0.24 sec\n      Start  6: tcp_shutdown\n 6/28 Test  #6: tcp_shutdown .....................   Passed    0.14 sec\n      Start  7: pair\n 7/28 Test  #7: pair .............................   Passed    0.00 sec\n      Start  8: pubsub\n 8/28 Test  #8: pubsub ...........................   Passed    0.02 sec\n      Start  9: reqrep\n 9/28 Test  #9: reqrep ...........................***Exception: Other  0.23 sec\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (/home/indie/dev/nanomsg/src/utils/queue.c:78)\n  Start 10: fanin\n\n10/28 Test #10: fanin ............................   Passed    0.00 sec\n      Start 11: fanout\n11/28 Test #11: fanout ...........................   Passed    0.01 sec\n      Start 12: survey\n12/28 Test #12: survey ...........................   Passed    1.00 sec\n      Start 13: bus\n13/28 Test #13: bus ..............................   Passed    0.01 sec\n      Start 14: block\n14/28 Test #14: block ............................   Passed    0.20 sec\n      Start 15: shutdown\n15/28 Test #15: shutdown .........................   Passed    0.01 sec\n      Start 16: timeo\n16/28 Test #16: timeo ............................   Passed    0.20 sec\n      Start 17: iovec\n17/28 Test #17: iovec ............................   Passed    0.00 sec\n      Start 18: msg\n18/28 Test #18: msg ..............................   Passed    0.01 sec\n      Start 19: prio\n19/28 Test #19: prio .............................   Passed    0.01 sec\n      Start 20: poll\n20/28 Test #20: poll .............................   Passed    0.04 sec\n      Start 21: device\n21/28 Test #21: device ...........................***Exception: Other  0.11 sec\nAssertion failed: 0 (/home/indie/dev/nanomsg/src/transports/inproc/sinproc.c:273)\n  Start 22: emfile\n\n22/28 Test #22: emfile ...........................   Passed    0.01 sec\n      Start 23: domain\n23/28 Test #23: domain ...........................   Passed    0.00 sec\n      Start 24: trie\n24/28 Test #24: trie .............................   Passed    0.00 sec\n      Start 25: list\n25/28 Test #25: list .............................   Passed    0.00 sec\n      Start 26: hash\n26/28 Test #26: hash .............................   Passed    0.01 sec\n      Start 27: symbol\n27/28 Test #27: symbol ...........................   Passed    0.00 sec\n      Start 28: separation\n28/28 Test #28: separation .......................   Passed    0.40 sec\n89% tests passed, 3 tests failed out of 28\nTotal Test time (real) =   3.57 sec\nThe following tests FAILED:\n      4 - ipc_shutdown (OTHER_FAULT)\n      9 - reqrep (OTHER_FAULT)\n     21 - device (OTHER_FAULT)\n```\n. I found this document: http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx#SSIZE_T ?\nI think for Windows we can do this:\ndefine SSIZE_T ssize_t\nor not?\n. ",
    "nysan": "Update: This failure seems to be intermittent, I get it about 30% of make check runs...\n. ",
    "neomantra": "The patch is submitted under the MIT license.\n. @nirs:   it's an easy change.  and probably not an issue for most language binders to use.  But we did pick the current signature for its simplicity.\n. Something to note... the symbol NN_MSG doesn't come through this interface well as it is based on size_t and not int.  \n. In my LuaJIT binding, I'm using it (and making it easy for devs to utilize it).  But it is fine that it is not exposed via the nn_symbol API. \nhttps://gist.github.com/neomantra/5154954\n. This patch is submitted under the MIT license.\n. I added another changeset with missing protocol options.  This is also released under MIT license.\n. Here's the source to there server (and the same client in Lua is right next to it):\nhttps://github.com/neomantra/nanomsg-ffi.lua/blob/master/examples/echo_server.lua\nFrom seeing similar problems with pub/sub, it might have to do with the nn_shutdown call in there server?    I was getting the same exception from a subscriber when I terminated a publisher (not using nn_shutdown explicitly)\n. Using the latest head,I get a different error.  [Also the LuaJIT side is unchanged, the API didn't change at all with the aio2 branch, right?.]  Make check is clean.\nProgram output:\n$ luajit ./examples/echo_server.lua \n...starting server loop...\nGOT:    \"foobar\"\nAddress already in use [98] (/home/evan/projects/nanomsg/src/transports/tcp/btcp.c:325)\nAborted (core dumped)\nStack dump:\n```\n0  0x00007f105970a425 in __GI_raise (sig=) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n64      ../nptl/sysdeps/unix/sysv/linux/raise.c: No such file or directory.\n(gdb) bt\n0  0x00007f105970a425 in __GI_raise (sig=) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\n1  0x00007f105970db8b in __GI_abort () at abort.c:91\n2  0x00007f10594b4379 in nn_err_abort () from /home/evan/projects/nanomsg/build/libnanomsg.so\n3  0x00007f10594c5e73 in nn_btcp_start_listening () from /home/evan/projects/nanomsg/build/libnanomsg.so\n4  0x00007f10594c582b in nn_btcp_handler () from /home/evan/projects/nanomsg/build/libnanomsg.so\n5  0x00007f10594aea6a in nn_fsm_start () from /home/evan/projects/nanomsg/build/libnanomsg.so\n6  0x00007f10594c5415 in nn_btcp_create () from /home/evan/projects/nanomsg/build/libnanomsg.so\n7  0x00007f10594c7f2e in nn_tcp_bind () from /home/evan/projects/nanomsg/build/libnanomsg.so\n8  0x00007f10594a8ffe in nn_ep_init () from /home/evan/projects/nanomsg/build/libnanomsg.so\n9  0x00007f10594ac4f1 in nn_sock_add_ep () from /home/evan/projects/nanomsg/build/libnanomsg.so\n10 0x00007f10594aaff2 in nn_global_create_ep () from /home/evan/projects/nanomsg/build/libnanomsg.so\n11 0x00007f10594aa156 in nn_bind () from /home/evan/projects/nanomsg/build/libnanomsg.so\n12 0x00000000004550fd in ?? ()\n13 0x00000000004385d0 in ?? ()\n14 0x0000000000438c76 in ?? ()\n15 0x0000000000452f7b in ?? ()\n16 0x0000000000446c80 in lua_pcall ()\n17 0x0000000000404906 in _start ()\n```\n. I just tried this again with the latest as of today (7/24/2013) and got this output:\n...starting server loop...\nGOT:    \"foobar\"\nAddress already in use [98] (/home/evan/projects/nanomsg/src/transports/tcp/btcp.c:372)\nAborted (core dumped)\nNote the line number is 372, not 325 anymore.\nhttps://github.com/250bpm/nanomsg/blob/master/src/transports/tcp/btcp.c#L372\n. I got a chance to retest this.  #119 still happens, but this issue (#49) does not.\n. I can confirm that NN_HAVE_SEMAPHORE is not defined.    But I do have /usr/include/semaphore.h. So perhaps the CMake check is not correct...   \nI just saw your comment, will check...\n. Doing new pull request.\n. ",
    "Neopallium": "Patch released under MIT license.\n. ",
    "lu-zero": "Pending a sync in the cmake build system I guess the issue had been explored fully.\n. On Sat, Jul 13, 2013 at 2:47 PM, sustrik notifications@github.com wrote:\n\nHi Luca,\nWhat's the license of this patch?\nEverything but the git-version-gen script is MIT or compatible with. If you\nneed the script to be MIT instead of GPL I can redo it or drop it.\nAFAICS there are some files from other sources included in the patch. Does\neverything comply with MIT license?\nax_pthreads.m4 is GPL with the link exception.\ndolt.m4 is MIT compatible.\nconfigure.ac and Makefile.am can be licensed as MIT (I'm the original\nauthor and could be argued that they are derived from the cmake files)\ngit-version-gen is GPL. It is used and not derived from, can be dropped if\nneeded.\nAlso, have you found CMake build system insufficient? Can you point out\nwhere it doesn't perform as it should?\ncmake does not work properly for cross compilation, it is a known issue.\n. On Sat, Jul 13, 2013 at 4:02 PM, Paul Colomiets notifications@github.comwrote:\ncmake does not work properly for cross compilation, it is a known issue.\nThe page:\nhttp://www.cmake.org/Wiki/CMake_Cross_Compiling\nDoesn't describe anything critical. Can you give a link on the issue?\n\nThe link shows perfectly the problem confront and compare to\n./configure --host=chost_variable\nThat's everything you need to do to get it to cross compile and works out\nof box.\nNot to mention Gentoo crossdev/cross-emerge systems rely on that (and I\ncouldn't get any cmake based build systems to behave)\nemerge-i686-w64-mingw32 nanomsg\nWould automatically build for the specific target if using autotools, fails\nhorribly if cmake is involved.\n. On Sun, Jul 14, 2013 at 7:46 AM, sustrik notifications@github.com wrote:\n\nOk. I am not an expert on cross compilation and if you say autotools is\nneeded for it, I'll take your word for it.\nThank you, you are making my life much easier.\nAs for the licenses, it's not obvious how GPL-based patches would play\naround. It's OK to use GPL-licensed build tool for building MIT-based\nproject (e.g. GCC), but it's not clear whether a GPL-licensed build file distributed\nwith the project won't turn the project into a derivative work a thus\nGPL-licensed. Any thoughts on that?\nThe file in question is a simple script to derive a version value from\ngit-tags I'll just rewrite it if it would make you feel more confident. If\nyou want we can discuss on irc if the feature is useful for you or should\nbe just dropped. Currently nanomsg has\nSOVERSION and VERSION set to 0 so is just something that should be\nconsidered for the future.\n\nIt wouldn't matter since it is used and not built upon in any possible case.\nThe rest is either MIT compatible, MIT itself or my own code. Let me redo\nit so it is clear.\n. Updated accordingly.\n. On Mon, Jul 15, 2013 at 12:55 PM, sustrik notifications@github.com wrote:\n\nOk, I see.\nAs for the versions, they should be retrieved from src/nn.h hader file.\nWith CMake it's currently done as follows:\nfile (READ \"${PROJECT_SOURCE_DIR}/src/nn.h\" NN_H_DATA)\nstring (REGEX REPLACE \".#define NN_VERSION_MAJOR ([0-9]+).\" \"\\1\" NN_VERSION_MAJOR \"${NN_H_DATA}\")\nstring (REGEX REPLACE \".#define NN_VERSION_MINOR ([0-9]+).\" \"\\1\" NN_VERSION_MINOR \"${NN_H_DATA}\")\nstring (REGEX REPLACE \".#define NN_VERSION_PATCH ([0-9]+).\" \"\\1\" NN_VERSION_PATCH \"${NN_H_DATA}\")\nset (NN_VERSION_STR \"${NN_VERSION_MAJOR}.${NN_VERSION_MINOR}.${NN_VERSION_PATCH}\")\nWith autotools it can be done using a shell script like this one:\nif [ ! -f src/nn.h ]; then\necho \"version.sh: error: src/nn.h does not exist\" 1>&2\nexit 1\nfi\nMAJOR=egrep '^#define +NN_VERSION_MAJOR +[0-9]+$' src/nn.h\nMINOR=egrep '^#define +NN_VERSION_MINOR +[0-9]+$' src/nn.h\nPATCH=egrep '^#define +NN_VERSION_PATCH +[0-9]+$' src/nn.h\nif [ -z \"$MAJOR\" -o -z \"$MINOR\" -o -z \"$PATCH\" ]; then\necho \"version.sh: error: could not extract version from src/nn.h\" 1>&2\nexit 1\nfi\nMAJOR=echo $MAJOR | awk '{ print $3 }'\nMINOR=echo $MINOR | awk '{ print $3 }'\nPATCH=echo $PATCH | awk '{ print $3 }'\necho $MAJOR.$MINOR.$PATCH | tr -d '\\n'\nThoughts?\nFine for me, I thought you wanted to keep soversion and package version\ndifferent, so you can have in git\napi changes in the soversion and then cut a release when needed.\n\ne.g.:\nv0 -> api 0.0.0\nadd new call -> api 0.0.1\nadd yet another -> api 0.0.2\n...\nv0.1 -> api 0.0.10\ndeprecate a call\nadd a newer one -> api 0.1.0\n...\nv0.2 -> api 0.2.5\nand so on.\nOtherwise the version and so-version match and whenever there is a release\nthe soversion gets bumped accordingly.\nso release1 gets 0.1.0, release 2 0.2.5 and so on\nlu\n. On Mon, Jul 15, 2013 at 2:14 PM, sustrik notifications@github.com wrote:\n\nUgh. Yes. I guess so.\nIt certainly makes sense to have ABI version for library loader to use and\na separate package version so that package can get updated without actually\nchanging the library API/ABI.\nWhat would you propose as the most sane way to achieve that? Specifying\nABI version in src/nn.h and package version via git tags?\nThat's how I'm doing with my projects, pkg-config and headers keep the\nsoversion, the package version is taken from the git tag.\n\nI can bake a proposal in that direction if you like.\n. On Mon, Jul 15, 2013 at 4:07 PM, sustrik notifications@github.com wrote:\n\nI like the idea. However, it still leaves the open question of how should\npackage version look like.\nMy experience with three-part version numbers is that they are\nunnecessarily complex. In theory, one number should do, however, that\ndoesn't leave a space open for possible future maintenance branches. So, I\nguess, two-part package versions (such as 1.0) should be sufficient. The\nrecent move of linux kernel from three-part to two-part version numbers\nseems to back the idea. Any thoughts about that?\nI usually use a 2part version scheme, one for major changes and the second\nfor branch update.\n\nso nanomsg-1.0 -> api 0.0.0, nanomsg-1.2 api 0.1.3, nanomsg-2.0 api 1.0.0\nand so on.\nlu\n. On Mon, Jul 15, 2013 at 4:32 PM, sustrik notifications@github.com wrote:\n\nOk. Sounds sane.\nOne final question: How would you handle documentation versioning in such\nmodel? Think about online documentation of the API. The content is\ndependent on the API/ABI version, however, the user is likely to know the\npackage version he's using, so he should be able to navigate to the content\nvia the package version.\n\nThe generated online documentation would document the release branch and\nyou won't expect api changes within a release branch.\nE.g.\nrelease1 -> 0.0.0 api <- immutable or so\nrelease2 -> 1.0.5 api <- immutable or so\nmaster -> 4.3.1 api <- changes with git.\n. On Tue, Jul 16, 2013 at 9:40 AM, sustrik notifications@github.com wrote:\n\nI would except backward-compatible API changes to the release branch\nthough. E.g. adding a new socket option.\n\nBy experience, adding features in release branches causes grief to users.\nOr at least, some users will complain.\n\nOne possibility I can think of is generating one set of online documents\nfor each API/ABI version and having a page with all package versions, each\nlinking to the appropriate set of documents. That way the user can navigate\nto correct documentation even if he's not aware of the actual ABI version.\n\nDoesn't sound bad to me. I'll update the version script to take care of\nboth situations and export PACKAGE_VERSION -> git tag and\nthe 3 soversion components now.\n. On Tue, Jul 16, 2013 at 11:33 AM, sustrik notifications@github.com wrote:\n\nCan you elaborate on the problems being caused by adding features?\nChecking for that specific feature presence gets then increasingly complex\nand that displeases downstream developer a lot =)\nAs for the build system, just go ahead. Once you are done we'll have to\nupdate the CMake scripts to behave in the same way.\nPull request updated.\n\nlu\n. On Tue, Jul 16, 2013 at 12:14 PM, sustrik notifications@github.com wrote:\n\nWhy check for a specific feature at all? My understanding was that the\ndownstream developer just checks whether \"current\" portion of the ABI\nversion is the same and \"age\" portion is equal or greater to what was used\nto develop the downstream application. Am I missing something?\nAs said it is a downstream concern I experienced, I'm not exactly clear on\nthe complaint merit, just I noted and applied to my projects since it is\nalso incidentally much easier for the release manager just track bugfixes.\n\nAs for the patch, can you state that you are submitting it under MIT\n\nlicense? The nature of MIT doesn't make patches to MIT code MIT-licensed\nautomatically. Thanks!\nSuch statement should appear in each commit or I could drop a statement\nsomewhere?\n\nlu\n. On Tue, Jul 16, 2013 at 12:33 PM, sustrik notifications@github.com wrote:\n\nJust make a statement here. Thanks!\n\nAll my personal contributions to the nanomsg project, if not otherwise\nstated, are to be intended under the MIT license.\n. On Tue, Jul 16, 2013 at 12:37 PM, sustrik notifications@github.com wrote:\n\nThinking about the versioning, we can even make version checking automatic:\nNN_EXPORT void nn_init_ (void);\ndefine nn_init()\\\ndo {\\\n    int major;\\\n    int minor;\\\n    int patch;\\\n    nn_version (&major, &minor, &patch);\\\n    if (major != NN_VERSION_MAJOR || minor < NN_VERSION_MINOR) {\\\n        fprintf (\"nanomsg version mismatch:\\n\"\\\nA library must not use printf.\n\"Expected ABI version %d.%d.%d or compatible.\\n\"\\\n        \"Found ABI version %d.%d.%d.\",\\\n        NN_VERSION_MAJOR, NN_VERSION_MINOR, NN_VERSION_PATCH,\\\n        major, minor, patch);\\\n    abort ();\\\nA library must not abort if there are other means to prevent it.\n\nSimilar code is not strictly necessary since using soversion would make the\nlinker prevent unexpected mismatches anyway.\nlu\n. On Thu, Jul 18, 2013 at 12:18 PM, sustrik notifications@github.com wrote:\n\nOk. I've tried to apply the patch.\nDone this:\nautomake --add-missing\nautoreconf\n./configure\nmake\nGot this error:\nlibtool: link: you must specify an output file\nlibtool: link: Try `libtool --help --mode=link' for more information.\n\nThe proper way is to do\nautoreconf -if && ./configure && make -j 8\nWhich is your system?\nlu\n. Thank you!\nOn Thu, Jul 18, 2013 at 1:48 PM, sustrik notifications@github.com wrote:\n\nOk, autoreconf -if solves the problem.\nI've applied the patch to the mainline.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/pull/80#issuecomment-21178063\n.\n. On Thu, Jul 18, 2013 at 11:21 AM, sustrik notifications@github.com wrote:\nWhy not use printfs? At the moment all the assertion macros use printf in\ncase the\nprogram is to be aborted. What would you use instead?\n\nI'm on of those that consider assertions a DoS waiting to happen, probably\nI'm too strict or my users are =)\nIdeally a library needing to report a message should log it and let the\ncaller decide how to present it.\nOpened issue #81 about it.\n. On Thu, Jul 18, 2013 at 2:27 PM, sustrik notifications@github.com wrote:\n\nThat being the case, the only alternative to aborting would be to continue\nexecution in face of a bug, in short, to resort to undefined behaviour.\nThe alternative is to have a clear error path, I do agree it isn't always\npossible.\nMy personal preference is to abort rather than experience undefined\nbehaviour. The reason is that abortion can be handled programatically (by\nrestarting the process) or administratively (reporting the bug, fixing it,\ndeploying new version) whereas undefined behaviour can not.\nI'm more for the third way (clear error path) when possible.\n\nlu\n. device.c seems to show a different issue\nAssertion failed: 0 (src/transports/inproc/sinproc.c:273)\n. The type unexpected is NN_SINPROC_SENT\n. On Tue, Jul 23, 2013 at 10:22 AM, Nir Soffer notifications@github.comwrote:\n\nThe first issue can be solved using random paths such as\n/tmp/nanomsg/testname-timestamp-randomsuffix.\nOn Tue, Jul 23, 2013 at 10:14 AM, sustrik notifications@github.com\nwrote:\n\nThe latter issue is definitely a bug, however, not being able to run 2\ntests in parallel is just a way the things are. I am not sure I can see\nany\nway to fix that. Any idea for a workaround?\n\n\nI can run the test in parallel in my branch, let me fix the missing file\nand we should be fine.\n\n\n\u2014\nReply to this email directly or view it on GitHub<\nhttps://github.com/250bpm/nanomsg/issues/82#issuecomment-21397017>\n.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/issues/82#issuecomment-21399649\n.\n. Fixed already in my tree :)\nOn Jul 25, 2013 9:50 AM, \"sustrik\" notifications@github.com wrote:\nLuca: How come? TCP tests are using fixed port numbers which should lead\nto collisions when running tests in parallel.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/issues/82#issuecomment-21538339\n.\n. On Tue, Jul 23, 2013 at 9:12 AM, sustrik notifications@github.com wrote:\nCouple of comments:\n1. There's no right to execute the version.sh set. This makes\n   autoreconf fail (at least on linux).\n2. configure.ac:55: required file `doc/asciidoc.conf.in' not found\nMartin\n\nThanks, I forgot to add the .in file!\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/pull/83#issuecomment-21396956\n.\n. On Tue, Jul 23, 2013 at 11:08 AM, luca barbato luca.barbato@gmail.comwrote:\nOn Tue, Jul 23, 2013 at 9:12 AM, sustrik notifications@github.com wrote:\n\nCouple of comments:\n1. There's no right to execute the version.sh set. This makes\n   autoreconf fail (at least on linux).\n2. configure.ac:55: required file `doc/asciidoc.conf.in' not found\nMartin\n\nThanks, I forgot to add the .in file!\n\nFixed now =)\n. @rcari and @madscientist42 I'm all happy to see people passionate, but cmake cross compilation support is severely lacking as it is also quite problematic to integrate with other more complex systems: e.g in Gentoo supporting multilib with autotools is a breeze, with cmake not so much (all due its debatable approach to the problem).\nIt is all good that some BSP providers give you a pre-made cmake toolchain specification, but that isn't the end nor even the start of cross building something, I routinely create different toolchain (e.g. using musl as libc), the extra steps to make cmake work are just an additional burden. \nThe always beaten and insulted autotools get cross compilation right you just need to pass a single option and everything will work as supposed to.\nI think I shown that you can have clean and tidy autotools already and the learning curve isn't that steep.\nOn the other hand cmake requirements make it suboptimal, requiring you to have it installed on the build machine means that nanomsg inherits all the cmake dependencies and they aren't that small, autotools disappears completely from the sight on release tarballs, requiring just a shell and makefile.\nIn the end, please give autotools a chance and do not be so angry at me.\n. As long is easy as for autotools to get automatic cross packages everything\nwould be fine.\nThe only reason I worked to provide an autotools build system is that ANY\nother build system makes that (and a bunch of other tasks) hard.\nAutotools is far from perfect and it is known, but gets right few key parts\nus distributors care about.\nwaf, as used by samba is among the worst build systems ever. I'm not sure\nif something got fixed over time.\nBloomberg doesn't deploy to arm, ppc or freebsd so their problems are\ndifferent and waf (that has a great syntax and provides an all-in-one\nsolution for configuration and building) might be a good fit for their\nneeds.\nFor distributors waf (at least as used by samba) is a plague. Autotools\nrequires a shell and make and those are usually more abundant than python.\nOn Wed, Apr 2, 2014 at 11:48 AM, Christopher Gilbert \nnotifications@github.com wrote:\n\nAs finance institutions are mentioned specifically, it may be worth noting\nthat Bloomberg have done away with the old tools of the past, and now rely\non waf for building their core libraries, which support most platforms,\nincluding various flavours of Unix, Linux and Windows.\nWaf is written in Python, so there is an interpreter available for\nvirtually everything (even those legacy Unix systems). It may not be as\nbattle hardened as Autotools, but it certainly works well enough for\nBloomberg which probably owns half of those legacy Unix systems still in\nuse.\n\nReply to this email directly or view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/210#issuecomment-39310377\n.\n. On Wed, Apr 2, 2014 at 8:26 PM, Christopher Gilbert \nnotifications@github.com wrote:\nAutotools isn't perfect, but perhaps more importantly it doesn't match\nwhat appears to be the project requirements. My challenge to the authors\nand the contributors is are you able to find a better solution than that?\nDepends on what you mean with \"better\". For the distro packagers autotools\nworks really well.\nI'm deliberately playing devils advocate here because I'm seeing a lot of\nalternatives out there that are working for a lot of different projects,\nand I'm not convinced that they have been evaluated carefully enough.\nBashing autotools is a wonderful sport, lets play it with all the build\nsystems around.\n- Autotools sucks, a LOT, the resulting package just requires a shell and\n  make and if you want to do changes you need the whole autotools (as in perl\n  and m4) and if you want to do extensive change you have to learn m4 in some\n  ways. The generated makefile is eye poking and underperforming.\n- cmake sucks even more since doesn't let you cross compile, it gets in the\n  way and forces you to get itself and at least make (or xcode or ninja or\n  msvc) and even if you just want to build the package unchanged you need to\n  have cmake. What's worse, it doesn't automagically get the changes from the\n  xcode or msvc project so you still need to learn a strange language. The\n  generated makefile or ninja script are again eyepoking and underperforming.\n- waf requires python that nowadays comes in multiple flavours, which one\n  is the right at the time is left to the reader. It is apparent that cross\n  compiling isn't something supported (but might be fixed thanks to the fact\n  python is great). It is python so you must know python and know it well\n  enough.\n- scons is like waf but less structured and getting even the basics of\n  build systems wrong.\n- gyp is written in python and is a generator like cmake, arguably doing a\n  better job at producing ninja scripts than the other but much less easier\n  to use than waf.\n- tup is something trying to solve all the building problems in its own\n  smart way, it is blazing fast, the language is expressive and can be\n  augmented by lua, yet it fails to incredibly at being usable since it\n  requires some exotic file access tracking and it achieves it by leveraging\n  fuse or ld preload in unholy ways. Once they give up on being too smart\n  that would be an interesting replacement for make and maybe the configure\n  script could leverage the embedded lua interpreter giving an all-in-one\n  solution.\n- mk from plan9, fast, expressive and weird. Can replace make and it might\n  be fairly portable. Described just for the fun of it.\n\nSo in short, for me is much simpler having a working autotools and\nusually when I need to cross compile something cmake is what gets me to\navoid or ignore a package and looking for something else.\nMaybe it's not a big deal at all, and the Windows developers should just be\n\nglad to have any support at all. My concern is that the two systems are\nsufficiently different that the cost of maintaining both will outweigh the\nbenefits.\nnanomsg is a relatively small project with not many options once you pin\nthe operating system (windows is windows). Adding another compilation unit\nin cmake or automake about to... the very same simple action of appending a\nfile to a list.\n\nThe documentation uses a complex toolchain that might or might not be a\npain to install on windows so I doubt somebody would miss it.\n. No, false totally and egregiously false.\nin autotools you have\n./configure --host=$CHOST\nAnd if the people writing the configure script didn't do something stupid (can happen I know quite well) everything ends here.\nin cmake, now (before was even worse) you have to create a spec file for every toolchain you want to use and yet hope that something stupid hadn't been done (again, can happen, even more often).\nGentoo crossdev works perfectly with autotooled packages while the cmake-based ones tend to break in quite amazing way even if now the toolchain specifications are generated.\nThe things you might have to take care of are:\n- bogus pkgconf files (and it is the same for both cmake and autotools)\n- faulty linker scripts (some packages do install them)\nThat said for the scope of a C project that is lightweight as nanomsg, cmake remains a huge dependency, autotools releases do not require autotools but just a shell and make.\n. ",
    "op": "Seems to still happen here. It works for you?\n. I'm a bit unsure what actually happens if you connect to a DNS record which resolves to multiple addresses, and can see that might be a problem. But when you do bind or connect, you get back an endpoint. That's the one I was thinking about. :)\nIt would be so sweet if you were able to figure out what address you actually just started listening to. Eg. nn_bind(s1, \"tcp://*:0\"). This can come handy in different use cases (unittests, logging etc).\n. I agree that you should put relevant data in the business logic to make sure you can change the topology. It might still be interesting to know eg. from where a message came from for monitoring and logging purposes.\nIf you would be able to determine the address based on an endpoint, like the endpoint you get back when you do connect or disconnect, I guess this might be doable. If you eg. optionally could peek into the nn_cmsg, and could figure out which endpoint were used to receive a message and what endpoint sent it.\nFeel free to close as won't fix if you don't agree. ;)\n. ",
    "gdamore": "The semantic we want here is return EBADF for operations on a socket when nn_close() is called.\n. Ok, I think I've got this nailed, stay tuned.  This solves other issues too!\n. Can someone test the current git repo?  Is this still an isuse?\n. Actually, I'm certain that this got fixed with \ncommit 7555f49e83ff414133f77e46389f8e5632eeea1f\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Fri Oct 23 08:01:22 2015 -0700\nfixes #469 assertion failure in ipc_shutdown (really)\nClosing it.\n. I can confirm that I see this too.  I think the problem is that when you have multiple threads in the FSM, the queue isn't protected by a lock, and so data structures are modified in one thread but not seen in another. \n. So, I've not seen this in quite some time.  And a lot of things have changed... any recent sightings of this problem (especially with the code in tree?)\n. In fact, I think this most likely was related to the fix I made here:\n7555f49e83ff414133f77e46389f8e5632eeea1f\nI'd like to know if it still reproduces.\n. I just hit this in a clang based build on Travis CI:\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (../src/utils/queue.c:102)\n/bin/bash: line 5: 12448 Aborted                 (core dumped) ${dir}$tst\nSo this still needs fixing.\n. Btw, this was also in the IPC test.\n. This is still seen in v0.7 occasionally.\n. Hmm.. ipc or inproc?  inproc suffers races here...\n. All the other failures I've found involve inproc.  We use inproc pretty heavily in our test framework...\n. I suspect therefore that this is all #429 -- I'm starting to think its time I got around to fixing that.\n. So looking back I do see IPC.  I'll try to repro....\n. server.c above was missing #include of pthread.h\n. How long to run to reproduce, and on what platform?  It doesn't seem to be reproducing for me on El Capitan (MacOS 10.11)\n. and we hit it on Travis:\nmake[2]: Entering directory `/home/travis/build/nanomsg/nanomsg/nanomsg-0.7-beta-8-g325ba0e/build'\nPASS: tests/inproc\nPASS: tests/inproc_shutdown\nPASS: tests/ipc\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (../src/utils/queue.c:102)\n/bin/bash: line 5: 13132 Aborted                 (core dumped) ${dir}$tst\nFAIL: tests/ipc_shutdown\nPASS: tests/ipc_stress\n. So I _think the problem here is that in the worker thread, we can wind up getting a stop notification, but we don't actually remove all the queued items from the queue.  This can lead to orphaned items in the queue, which breaks the assertion.\nTechnically, if I'm write, removing the assertion would be benign.  But I think a better solution is to properly clean up the queue items in the queue.  Stay tuned.\n. This looks like a good call.  Let me have a look at this.. So I don't have Windows XP available to me, and the XP platform itself is no longer supported by Microsoft outside of unusual extended supported arrangements for the embedded edition.\nIf nobody steps forward with a suitable fix that does not negatively impact existing Windows support, then its unlikely we will ever fix this.  Frankly, I'm not sure this is a problem that warrants attention.\n. Closing as a dup of #334  -- which is the real issue.\n. Huh.  I just noticed this yesterday while I was adding other options to websocket.\n. I've become convinced that not only do we need to do this asap, but NN_TCP_NODELAY should really be the default. Nagle is pretty evil on platforms that do delayed TCP ACK, and I think this may be at the root of some very very long timeouts when trying to establish connections.  (Windows seems to need > 200 msec to establish a connection, which is consistent with some delayed TCP ACKs.)\n. Given the completion state for TCP and IPC, I'm gonna close this; IPC needs a more or less complete rewrite anyway (thread safety).\n. Is there more to this thread?  I'm frankly loathe to refactor usock at this point -- my inclination is much rather to refactor the whole darn library.\n. This isn't going to happen.  Easier to refactor the whole darn library.\n. WOW.  EMFILE is hard to hit with \"reasonable\" systems.  Its it actually appropriate to try to muddle on when hitting this?  (As opposed to just aborting the socket?)  In mangos I just terminate that endpoint, rather than attempting to carry on.\n. Fair enuff.  Got a diff to address it?  I think adding a simple delay (10 msec is probably adequate) ought to be enough.\n. Fixing this probably requires a new backoff state to be added to the various accept state machines.  This is a lot of work to do at this point.  One could look at the backoff's used for nn_bind() in the 0.9 and earlier releases for inspiration as to how to do this.\n. libnng has fixed this, we inject a backoff for any kind of error like ENOMEM or EMFILE.\nFor libnanomsg, I'm not going to address this -- I'm focused entirely on getting nng ready so that we can use it to replace libnanomsg.. The inproc_lat test suffers from thread safety issues.  inproc is fundamentally busted and needs a major refactoring.\n. This is another inproc safety issue.  Closing as a dup of #429.\n. We have transport level options, and the architecture of nanomsg makes it hard to see endpoints from the client application.  With transport layer options, is this still needed?\nCertainly the idea of setting an option that only applies to the next nn_connect() seems kind of crummy and very un-threadsafe.  What would be better would be to pass explicit options to nn_connect, nn_bind.  That means having new functions that take some kind of option value.\nFrankly, I'm not too thrilled with that either.\nI'd really want to see a compelling use case for this feature, otherwise I'm inclined to just close it.\n. We will be doing this a different way under libnng, where you can actually issue options directly to the endpoint, instead of going through the socket.  This turns out to be really important since the socket can have multiple endpoints.\nFor nanomsg, I'm not going to solve this at all.  But stay tuned for libnng.  Closing this one against libnanomsg as \"will not fix\".. uint64_t would correspond to what other operating systems for NIC statistics, for example.\n. I'll fix this in libnng.  Not going to bother with it for nanomsg.. So, I feel that this change goes against the intended design of nanomsg, which is that apps need never notice the arrival and departure of connections.\nUltimately this problem is caused by another issue -- which is that on many platforms you won't notice a lost connection unless you have an outstanding read().  We need to make sure we always have outstanding blocking reads going on; which is tricky given the non-threaded design of the library.\nI'm going to have to think about this some more, but this PR's approach is wrong (the API impact to the client), so I'm closing the PR.   The bug will remain open.\n. Doe we know, is this still a problem with the current head bits?  I have a sneaking suspicion that I've fixed the root problem here.\n. Any chance this is fixed with what's in git right now?\n. Nope.\n. So I think linger isn't just the TCP lingering, but also the upper layers of libnanomsg.  I need to think about how to fix this.  Probably not going to happen right away.\nTo be honest, unidirectional latency always feels a little sketchy to me.  I prefer to make round trip latency measurements, and divide by two.\n. I'm not going to fix this in nanomsg itself -- in fact I'm pretty sure I removed the linger option from nanomsg altogether. \nlibnng is a different matter -- there we can use linger and it is indeed meaningful.  We can't guarantee that the operating system will respect it, but we can.  I've done the work to make this work in libnng already.\nClosing this one against nanomsg though.. Holy smokes! I've done the initial work to convert to cmake.  Maybe I'll revisit this soon.  If we switch to Cmake, it will be a switch.  I have no interest in working in two different build/configuration environments.\n. Thanks.  I\u2019ll probably have some time to finish up my work here in the next week or two.  I\u2019ve been busy on other things lately\u2026\n- Garrett\n\nOn Apr 29, 2015, at 3:47 PM, atif1996 notifications@github.com wrote:\nI'd love to help keep the cmake build system up to date, if you guys decide to go that route. I work on a product that targets Mac OS and Windows, and CMake was a god send for us.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/210#issuecomment-97608445.\n. I'm abandoning that effort; frankly its more work than its worth for this edition of libnanomsg.  Any future rewrite will probably use CMake exclusively, but for now, autotools work.\n. Why?   Should be able to just download the distro then ./configure && make install. \n\nBuilding from git may be harder but those are devel releases. \nSent from my iPhone\n\nOn Oct 26, 2015, at 2:30 PM, javalama notifications@github.com wrote:\nVery sad to learn this effort is abandoned. Building nanomsg on certain OSX versions is nearly impossible.\nSigh.\n\u2014\nReply to this email directly or view it on GitHub.\n. Looks related to #330 \n. So the header include was already fixed a while.\n\nI wonder if the change to the library linking commands work properly with Studio though?  If they do, then this will be a nice help.\n. Per email with Martin, I've made myself editor as well.  Martin, please review.\n. I believe this is long since fixed.  Closing.  Submitter, if it is still occurring (and I'm wrong), please reopen.   If you do that, please verify that its a problem with latest code in git.\n. I have a theory that this may be a race in nn_close().  Stay tuned.\n. So testing this, it appears that my commit of PR #525 fixes this.\n. Did you rebuild from head?\n. Well that's unfortunate.  Especially since I cannot seem to reproduce it. \n. Looking at the code, this is more bogus errno assertions. \nI think the problem is that we can indeed close the file descriptor out from underneath the polling thread.  That can of course cause EBADF to be returned.\nThat said, this condition looks like it would be benign were it not for that assertion.\n. So the first assertion is a bug in inproc.  The second is fixed.\n. I'm going to close this as a dup of #429 -- although really the problem is that inproc is not MT-safe.\n. Yep.  This is TCP slow start.  This is a well understood problem, you need to wait a bit before doing recv or send on a connection, or you need to assume that the first message may/will be dropped.\nClosing.\n. This is now ancient history.  Is this still a problem?\n. This is a dup of #206 -- same issue - basically linger doesn't.\n. I have approximately zero intention to work on this.  That doesn't mean I'd turn down a decent implementation if one arrived (and with updated RFCs too!), but adding new transports to libnanomsg is just too hard with the current state machine architecture.\n. Priority levels would help.  I don't think just closing is the right answer.  Unless we're sure. I'm not sure this is a never do thing yet.  It's nothing I'm going to do soon myself though. \nSent from my iPhone\n\nOn Jun 1, 2015, at 11:32 AM, Wirebird Labs LLC notifications@github.com wrote:\nI have approximately zero intention to work on this. That doesn't mean I'd turn down a decent implementation if one arrived (and with updated RFCs too!), but adding new transports to libnanomsg is just too hard with the current state machine architecture\n@gdamore -- would it help you as a maintainer to set a soft cap on time with no activity for outstanding feature requests before closing out? I think that feels OK. We can re-open issues that get new activity.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm going to go ahead and close this for now.  There is approximately zero chance that I'm going to add SCTCP or UDP support (or any other transport) into nanomsg unless another co-maintainer/contributor steps forward.  The reality is that adding new transports (especially non-stream oriented ones) in nanomsg is extraordinarily difficult owing to the internal architecture of the library; this cannot easily be addressed without basically doing a full redesign that relaxes some of the design rules/goals.  (For example, allowing for true threading, and breaking the select()able / POSIX API compatibility.)\n. I believe that this may be another case of #411 -- but also inproc seems to have problems with thread safety.  IPC should be better.\n. Closing this as a dup of #429 \n. Actually reading the code, this is not actually a bug.  Your code somehow manages to assume that recv() is going to work -- but if there is no party on the other side, then nn_recv() blocks indefinitely.  This is the nature of nanomsg -- sockets are not a 1:1 connection, but can have multiple parties.\n\nYour sample code also had other problems (like wait being a well known symbol, and missing an include for stdbool.h\nNonetheless I fixed the minor compilation issues, and tested, and traced, and determined that the problem is in your expectations, not in inproc or nanomsg.. I see lots of complaints in the websockets code.  I'm disinclined to close just because gcc doesn't notice the problems.  I'm going to fix the websockets compilation problems that clang finds.\n. I'm not seeing this on 10.10.x.\n. make check is mostly it.\n- Garrett\n\nOn Jun 1, 2015, at 9:08 AM, George Lambert notifications@github.com wrote:\nIs there a consistent test case we can use for cross platform validation?\nOn Monday, June 1, 2015, gdamore notifications@github.com wrote:\n\nI'm not seeing this on 10.10.x.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/258#issuecomment-107301844.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/258#issuecomment-107611937.\n. I've been doing lots of work on Darwin lately.  If the complaint is in building on an older version of Darwin -- 10.8 is pretty old now -- I'm simply not going to worry about warnings there.  However, clang works beautifully on modern systems, and I have it in use here and on appveyor.\n\nClosing this for now.\n. Fixed in ab699df74978645ebe5bb53f0b602ba4bf32ed4b\nThat said, tcp_shutdown is particularly vile to the platform, and I found that it was unsafe to run before other tests, as it would leave the system in a state that broke other tests.  I'm not sure why, or whether this is generic to Windows or specific to our CI provider (AppVeyor).\n. This is really old.  Can someone check if this is still a problem?\n. Based on reports believing this was an older bug fixed earlier, closing.\n. Pretty sure I've seen this on modern Windows.  Couldn't explain it at the time.  Maybe Windows is behaving weird here -- hitting some internal resource limit perhaps?\n. Yep, this is confirmed to be a Windows quirk.\n. Not so sure now.  The EPERM is certainly a windows quirk, when using a bogus handle.  I believe that now the code will return either ETERM or EBADFD.  (The problem of using the lower level operating system select() call is that we don't really have much control over the errno.)\nIn any event, its kind of a gross programming error to call nn_term() if you have any other I/O pending.  The library tries to clean that up, but it can only do so much.\nThe code at least doesn't abort() anymore.  \nI'm closing this.\n. This is a dup of #469 and was fixed.\n. This is a non-issue, except perhaps a misunderstanding of PUB/SUB.  This is a best effort delivery protocol, and if you flood pub faster than sub can consume, you're going to drop messages.  Frankly, its not possible to \"fix\" this without creating a situation where one bad / slow subscriber could create stalls for everyone else in the network.\n. CLosing this as its a misunderstanding/mis-expectation of PUB/SUB.  If you flood, you overrun queues, and messages get dropped.  Either don't flood, or use some other out of band protocol to cope with this.  PUB/SUB cannot, and will not.\n. Indeed, the protocol is unreliable.  Just like  UDP.  Its entirely best effort.  If you have a requirement for reliable delivery, you need to use REQ/REP, or you have to build another sideband protocol.\nMost people use PUB/SUB as a broadcast delivery of updates, and at fairly moderate rates.  PUB/SUB is not for multicasting at high bandwidth, and indeed there is no such thing (really) as reliable multicast or broadcast either.\n. Looking at the inproc code, nothing except the assertion check actually uses the connects value.\n. That said, I believe the inproc code is fairly fragile.  Its clearly not thread safe.\n. I'm not even sure this is a FAQ item.  You can't bind two workers, programs, etc. to the same interface.  That's true for TCP, IPC, and inproc.  nn_bind() checks that the address being bound is actually available, and is doing the right thing here -- the expected thing if you grok bind().\nClosing.\n. This was fixed with #387 \n. Does anyone actually use inproc for anything real?  I had optimized my inproc implementation in mangos quite a bit, but I still wind up doing data copying -- I finally stopped caring about that when I realized how utterly pointless it is.  If you're passing data within the same process, there are dozens of better ways to do it than nanomgs/inproc.\n. @DamnnnSure can you provide specific test arguments?\n. Exactly.  You're optimizing away a data copy with inproc may be useful, but I'm not going to be overly concerned about it, because if you're using inproc, you're not doing so for performance.\nIn fact, case 1 seems kind of a stretch IMO; if you have two languages in the same process, its probably because you have FFI and one of them is C, in which case you probably have a better way to move data between languages.\nIndeed, in the case of mangos inproc, it is not possible to connect it to the C libnanomsg via inproc.  They don't speak to the same backend. I guess using libnanomsg only, it might work, although I'm really really skeptical.  Have you tried this?\nWe could make a socketpair() based inproc, that would be portable across all of these, I suppose, although figuring out how to handle registration of endpoints might be ... tricky.\n. I've been spending a bit more time in the code of late.  I'm not surprised that things are kind of slow.  nanomsg uses separate system calls (several!) to provide notification of message readiness... the poll() logic is crafted to be compatible with UNIX file descriptors, but doing so means that \"notifications\" come by sending a single byte of data to a \"pollable\" descriptor. \nI'm not sure I can do much about this without breaking the file descriptor compatibility in nn_poll.\nThat said, performance if inproc remains a mostly uninteresting problem, IMO.\n. Batching comes at a cost in terms of latency.   There is a trade off.  Most systems choose throughout and the rest of us who need low latency spend our time undoing those optimizations.\nSent from my iPhone\n\nOn Oct 3, 2015, at 1:47 PM, Charles Pritchard notifications@github.com wrote:\nI think message size is the big issue in this benchmark; in most cases where there's a high volume of messages, there's an opportunity to batch beyond a few hundreds bytes.\n\u2014\nReply to this email directly or view it on GitHub.\n. So, the big issue here is that in order for nanomsg to provide select() / poll() compatible semantics, it has to fake up a pipe and actually do system calls with read/write.\n\nThis is not solvable.  The design constraint to be socket compatible creates this situation, and there is no solution without breaking that constraint.\nBatching and the other issues like TCP_NODELAY having no effect (which is a separate bug filed already) don't help.  But at its heart, select() compatible API cannot be as performant as one that isn't.\n(Its actually worse than that --because even for vanilla TCP we have to do this fake out thing, because we don't expose the underlying FD directly to the consuming application.)\nTBH, the whole select() compatible API was IMO a big design mistake.\nAnyway, closing this as \"will-not-fix\".  (I may \"fix\" this in an alternate implementation, that provides a simpler API that doesn't align with select().  That would lead to a vastly simpler implementation as well.)\n. So I closed this issue above.  I have been looking at another architecture which would move notification\nto another mechanism, and allow us to get rid of the separate system calls.  That would be lots and lots faster if you don't need file descriptor notification.  However, this represents a large change to huge swathes of the core of nanomsg, so it's a nanomsg 2.0 thing.\n. All these should use condition variables to notify.  This is light weight,\nand can avoid the multiple system calls required to effect the notification\nnow.\nUnfortunately, the current design is not directly conducive to this, so it\nneeds some surgery too.\n- Garrett\nOn Mon, Aug 29, 2016 at 8:56 PM, Yonggang Luo notifications@github.com\nwrote:\n\n@gdamore https://github.com/gdamore What's the design of your new\nnotification mechanism?\nFor inproc interproc & network. Do they using different notification\nmechanism?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/300#issuecomment-243326284,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfc9SJfGclyf8nxuSIfLWJMnABb8Yks5qk6nqgaJpZM4CX9UI\n.\n. No.  I mean condition variable.   See\nhttps://en.wikipedia.org/wiki/Monitor_(synchronization)#Condition_variables_2\n\nThere are nice primitives for this in most operating systems .. see\npthread_condvar_wait() for some information.\nOn Mon, Aug 29, 2016 at 9:10 PM, Yonggang Luo notifications@github.com\nwrote:\n\nI suggest to re-open this issue and put it on the table.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/300#issuecomment-243327898,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfQ6QpSFzmQQEhK12JUBDm7V2rp5zks5qk605gaJpZM4CX9UI\n.\n. I'll point out that you performed about 1M transactions.  That's about 100K per sec (a little more than that) for a single thread.  Yes, its slow, and it can be a lot better.  But it is more than adequate for most uses.  If you're expecting inproc to be blindly fast and using it as an in-process bulk transport, you're going to be disappointed.  As I've said, if you want to do that, just use a function call.  :-)\n\nI will at some point have enough time to finish the rearchitecture to address these problems.  I cannot do it without changing core parts of nanomsg -- and its not simple.  If I could write up in a few sentences what needed to be done, I'd have already done it.\n. Yep, I've resolved this a different way altogether.  Closing this one.\n. The lack of sufficient information to debug, combined with Martin's comments, make this issue unresolvable.  I'm closing for now.  If the submitter wants us to fix, we need more details (and almost certainly its just a permission problem.)\n. It would be most helpful if you could supply some C code that demonstrates this behavior.  I need to see the code to meaningfully analyze the problem.\n. Ok, so what is happening here is that you've changed the timing, so that you're flooding messages faster than the XREP worker can handle them.  This causes the raw messages to get dropped, due to buffer overflows.  You either need to consume them faster (hence more workers), or reduce the production rate (hence the print removal?).\nAnyway, this is the nature of the beast.  You can't produce messages faster than you consume them without dropping some on the floor (once you overrun any buffering at any rate.)\nClosing this as its really just a problem of understanding the limitations of nanomsg rather than any internal bug.\n. Actually, this may be related to other issues.  There is a crazy amount of logic in the code to offer the same file descriptor semantics.  Ultimately, I suspect the problem has to do with the various extra syscalls that inproc has to do (surprise!) to get signaling on polled file descriptors, and may also relate to a race condition in inproc.\nThat said, I'm far far more concerned about correct behavior than by inproc taking 2.9us to deliver a message.\n. I'm going to punt on this.  inproc needs a full rewrite (see #429 ) anyway, and perhaps we can address it at that time.  Having said that, the problem is that even inproc requires syscalls to coordinate so that nn_select() works.\n. See #324  - this is going to hurt even worse.\nBut the thing is that nanomsg will always be quite a lot slower than zmq -  because it uses a whole round of extra system calls for the poll notification.  ZMQ doesn't need those because it doesn't try to present an API that select() or poll() can use.\nThe only way to fix that is to abandon the select/poll API compatible, and that looks like a major rewrite.\n. I'm closing this PR as I feel it violates the basic design principles of nanomsg's SP protocol -- which is best effort delivery.  See my comments above for more detail.\n. I think the docs are deficient.\nBut yes, zeromq suffers from the same behavior.  If you've not run into, it may be that you've been lucky, or perhaps the data rates you push are lower.  Also, zeromq has additional buffering, and eliminates a level of system calls, so its probably somewhat less likely to drop under load.\nNone of that changes the fact that architecturally, for both nanomsg and zeromq, PUB/SUB is unreliable.\nIndeed, much discussion around the \"slow-start\" problem for both zeromq and nanomsg is a direct consequence/allusion to this problem.  If the protocols were reliable, or gave notification back to the application, then slow-start would be a non-issue. :-)\n. Great.  And you're welcome. :-)\nSent from my iPhone\n\nOn Oct 25, 2015, at 9:59 AM, TTimo notifications@github.com wrote:\nThere's a pretty good explanation there:\nhttp://zguide.zeromq.org/php:chapter5#Pros-and-Cons-of-Pub-Sub\nAlright I learned something today. Thanks for going through through those\nold PRs :)\nTTimo\nOn Sun, Oct 25, 2015 at 10:28 AM, gdamore notifications@github.com wrote:\n\nI think the docs are deficient.\nBut yes, zeromq suffers from the same behavior. If you've not run into, it\nmay be that you've been lucky, or perhaps the data rates you push are\nlower. Also, zeromq has additional buffering, and eliminates a level of\nsystem calls, so its probably somewhat less likely to drop under load.\nNone of that changes the fact that architecturally, for both nanomsg and\nzeromq, PUB/SUB is unreliable.\nIndeed, much discussion around the \"slow-start\" problem for both zeromq\nand nanomsg is a direct consequence/allusion to this problem. If the\nprotocols were reliable, or gave notification back to the application, then\nslow-start would be a non-issue. :-)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/320#issuecomment-150934790.\n\u2014\nReply to this email directly or view it on GitHub.\n. I've changed the sub/pub protocol recently.  Can you please try again?\n\n\nNote also that PUB/SUB is best effort delivery.  If the underlying transport cannot deliver a message due to TCP backpressure, the messages are blithely discarded.  This implies that your SUB has to run at least as fast as your PUB.  And as you may know, filtering is done on the receiver side, so the SUB has to be able to process (at least for filtering) messages at least as fast as the PUB runs.\nNote that the IPC channels are somewhat limited, and will apply backpressure even faster than TCP in some cases.\n. If you're flooding IPC, you have to expect message drops.  This is expected behavior.  Closing.\n. Not sure about libnanomsg, but in mangos I provide TP specific content to the consuming application.  This is useful because that info can include things like getpeerucred(Solaris), or TLS certificate information.  This can allow transport layer authentication be usefully consumed for transports that offer it.\n. Part of our test suite could validate this.  In fact, adding an inproc member to a device handler would \"prove\" this.\n. This is critical for making devices that work properly with req/rep or surveyor/respondent.  Frankly, inproc is not really usable without this.\n. Actually, given this, I can test with the device framework we already have.  Stay tuned.\n. Well, I can reasonably confirm that inproc still doesn't transport message headers.\n. Well, that makes no sense.  It should by reading the code actually transport them.  But it doesn't seem to work.  Stay tuned.\n. Actually, it makes perfect sense.  inproc has already preparsed the SP headers.\n. So - the problem seems to be the whole mess of preparsed headers basically being wrong.\nI don't want to expend energy to fix this right now.  Frankly, optimizing inproc to avoid data copies is stupid.  People shouldn't be moving huge amounts of data via inproc, and making it go fast seems kind of pointless.\nHowever, making it correct is very important.\nSo for now what I'm going to do is make it just do a data copy just like TCP et. al.  It works.\nAnd now I'm wondering how many other bugs in inproc this will fix (a few I guess) -- certainly nn_device() and inproc, as well as using inproc with raw mode, should be much much better now. \n. This is true for POSIX systems too -- if you don't attempt to do I/O, you might never notice a disconnect or loss of a connection.  I found the read() (of any data) to be required on POSIX systems with mangos.  We should probably do this in the protocol handers -- even write-only protocol handlers should probably set up a reader on the underlying transport, just to catch this condition.\n. I think I've found workarounds for this.  IOCP fails, but we can close the remote peer, which causes a POLLHUP condition to arise, which makes everyone happy.  So far this seems to work.\nMartin, do you have a PR with the formal test case for this?\n. So I made one, from your code, obviously. :-) \n. So, actually, the test so far looks pretty good; I think PR #525 that I integrated actually solves this.  The test code is passing at least.\n. (You'll note that the only thing I merged here was your test case.)\n. I believe this is fixed now.  See bug #212 which addresses a build solution for this; the key components of which are now integrated.\nThat said, this does not make this work on Windows XP.  This is strictly a Cmake/mingw solution.\n. Argh.  So mingw is problematic.  Its this weird mutant that is neither Windows nor POSIX.  Aargh.\nIts looks like I'm going to have to actually install this stupid beast to debug it properly, since I can't seem to get anyone else to provide reasonably correct PRs for it.  Grrrr....\n. Visual Studio was the right choice.  I think its free, yes?\n. So we need to #include  for _sprintf_s on Windows.\nAnd I think we should also use gmtime_s on windows regardless of mingw or not -- this isn't cygwin, its just mingw with the Windows APIs.\nFinally it appears that we should be checking against NULL with lpOverlapped.  That's a pointer.\n. Ok, got those fixed, and went through all holy hell to get mingw compilation \"working\" on AppVeyor, only to discover that mingw is missing a bunch of stuff we need for Winsock.\nI'm throwing in the towel on this.  Use Visual Studio.  It's free.  If someone wants to submit a PR that actually fixes these issues, I'm happy to take a look.  But otherwise, my answer is \"Use Visual Studio\".\n(Or even better, use a POSIX platform -- Linux, Solaris, etc.)\n. Closing as will-not-fix for now.\n. out of curiosity, is cmake available on this 'ancient' distro?\n. Oh, also, would like to know what the legacy distro actually is.\n. To be honest, the simplest thing is probably to just manually edit the resulting configuration.  The Makefile will have -DNN_HAVE_EVENTFD.  Turn that off.\nThe other, perhaps different option, is to update your version of automake&autoconf then make the appropriate changes.  I'm pretty sure that while automake & co. may not be packaged for Ubuntu 8 LTS, you can probably just build them directly.\n. Happy to just close it!\n. I'm closing this.  I can't verify this works, and CancelIO is known to be insufficient to the task.  We might look at changes which might support making WinXP work better in the future, but this is so far a complete anti-goal.\nWorse, XP support needs to be determined at run time, because I really, really don't want to try to support a binary built for XP on newer Windows platforms.\nMeanwhile the XP platform is aging.  Formally, there have been no more security or technical patches for the past two years (Microsoft ceased all support activity in April 2014.)   Even Vista is in extended support at this point.\n. So I need to read the PR but here are my high level thoughts.  \nFirst the socket option isn't just an option.  Since it can impact the wire protocol we must retain the ability to set that. In fact mangos lacks this and I should look at ways to add it. \nI also believe there is no reason why we should settle for less than full rfc6455 compliance in the protocol.  We don't express the details to applications but we can and should do the right thing where the wire protocol is concerned. \nI'm opposed to adding the test suite and Python as a stock build dependency for sure.  \nBut I think if we can find a way to use this work to test in CI that would be useful. \nUntil I go over more carefully it's unclear to me whether this should be done in this repo or perhaps with a supplementary repo containing the extra stuff. \nI will try to take a look at this soon. \nSent from my iPhone\n\nOn Oct 25, 2015, at 12:15 PM, Wirebird Labs LLC notifications@github.com wrote:\nI don't suggest merging this PR, but can we discuss strategy moving forward in order to close out this old PR?\nAutobahn TestSuite was chosen as the industry-standard WebSocket implementation tester when I had envisioned the scope of the WebSocket transport in nanomsg to be wider than it is, but after discussions with @sustrik and @gdamore, I now agree that the WebSocket transport for nanomsg only needs to reasonably implement a subset of RFC 6455 (not nearly as complete a set as originally designed). For the most part, it should not be much more \"special\" than, say, TCP.\nThough, even after scaling back, the WebSocket transport remains \"special\" for a couple reasons:\n1) A few transport-specific features -- such as PING/PONG and chunked transfers -- are effectively handled by the transport layer in libnanomsg, but not exposed to the end-user of libnanomsg. Why do we even support these, if not exposed to the library user? Because it's unclear if browsers/user agents have the prerogative to use these features, even if not explicitly requested by client-side app code running in the browser (nominally talking about just Javascript here). By implementing these features, we can be reasonably sure that the library does not crap-out on what are reasonably modest expectations laid out by RFC-6455.\n2) The one feature that is exposed, which makes the WebSocket transport special from other transport types (TCP, inproc, ipc, etc...) is that a new socket-level option that is transport-specific enables the transport to verify that the payload of the message is valid UTF-8 -- it's been contested whether we should keep this, but I would strongly urge we do for now, since that's the encoding of the web.\nAll said -- this is just a brief history of why the Autobahn TestSuite was originally used as a departure from the established strategy of just tests written in C -- since the WebSocket transport for nanomsg was sufficiently different from other transports. The cost of this was introducing a new big dependency -- Python, in addition to Autobahn TestSuite, in addition to the other things it required. Yuck.\nThough, one new thing that nanomsg has gained since this was first developed is CI servers Travis and Appveyor, which to my understanding are easier to set up, automate, and maintain based on files in the repo.\nAll leading to a single question -- do we keep Autobahn TestSuite?\nIf yes -- we would configure Autobahn to turn off all the tests that are irrelevant (e.g., per-message compression). Additionally, probably only configure this test to run within \"official\" CI repositories, but be off by default for anyone cloning the repo and building locally (since it is non-trivial to set up, and pretty much annihilates the the spirit of minimal dependencies)\nIf no -- well, I don't have any reasons to suggest we ditch it, other than, \"it will take effort\" :-)\nAll said -- I'd like to get feedback on whether we want to keep it, then appropriately close or modify this PR so we can get it off the backlog.\n\u2014\nReply to this email directly or view it on GitHub.\n. So your test code looks mostly good, although it uses the removed APIs.\n\nI'm not sure what impact that has on the test suite.  But it clearly seems to me to depend on autobahn, hence not appropriate for a default build.\nI didn't understand where the JSON config files were?\n. Actually, the decision is per transport, and can be overridden via cmsg.\nSadly, we don\u2019t really have a good way to establish different options on\ndifferent transport instances; the options get applied to all instances\nof the transport.  That\u2019s a limitation of libnanomsg\u2019s design (and btw, yet\nanother limitation I removed in mangos.  When dealing with e.g. TLS you\nreally need to have separate \u201cdialers\u201d and \u201clisteners\u201d with different\noptions.)\nLibnanomsg handles PINGS by sending PONGS under the covers.  It never\ninitiates a PING, and does not expose PONGS to users.  Users could cheat\nand initiate a PING (or forcibly deliver a PONG) by messing with the cmsg\ndata, but that\u2019s not documented.\nOn Sun, Oct 25, 2015 at 5:16 PM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nSo your test code looks mostly good, although it uses the removed APIs.\nGood point. Now, re-glancing at the code myself for a first time in a\nwhile, it would need to change a non-trivial amount.\nFor instance, previously, ws:// sockets could parse TEXT or BINARY message\ntypes per-message, yet we have now decided (for the better, I think we all\nagree) that one of two protocols is set per-socket.\nAdditionally, I'm not certain where the current implementation stands on\nPING/PONG delivery to the application level (i.e., does libnanomsg expose\nthese any longer? or did we encapsulate them?). But looking at the test, it\nclearly expects them (in addition to NN_WS_MSG_TYPE_GONE, which I know no\nlonger exists:\nhttps://github.com/wirebirdlabs/featherweight-nanomsg/blob/65b8630c11fd620d50e8e0a4f2e6db9523a633fc/tests/ws_stress.c#L202-L207\n)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/340#issuecomment-150990920.\n. As I indicated in #182 the approach here is wrong -- we need to rethink this and solve it without kicking the error back to the application.  Maybe hard to do without bringing in threads...\n. Ping?  Should I fix the whitespace myself & merge?\n. #615 was submitted, but still needs work, but supercedes this one.  I'm closing this PR in favor of that one.\n. Modulo a few stylistic nits, the code looks good to me.  I'm not a Windows guy, so I can't verify the correctness for that platform, but it seems reasonable.  I think it would be nice to compress these changes into a single commit (git rebase) before merging, and use that chance to fix the few minor nits I pointed out.\n. There are conflicts that have to be resolved, and feedback items.  I'd also like more thorough review by someone more familiar with the Windows API. \n\nIn the meantime, I'm closing this PR.  Feel free to resubmit with updated code and comments addressed.\n. To be honest, my gut feeling here is that windows XP ought to be delivered as a different platform support.  That said, I don't regularly deliver software for windows, and certainly not for Windows XP.  Microsoft stopped supporting XP a long time ago -- the last service pack was 6 years ago.   Do we really want to expend effort supporting new software developments for an unsupported legacy platform?\n. So, I'd like folks working with Windows and with more knowledge of that platform, to contribute/comment here.  Otherwise this is going to sit in a holding pattern -- I'm neither equipped to determine the correctness of the code, nor to test it.  And, to be completely honest, supporting Windows XP feels like asking a lot since I cannot promise that other changes won't break it.  (I'm already unhappy with having to support Windows at all -- I'd really like to have a \"port\" lead step up ... I'll post about that on the mailing list.)\n. So this really should be kept off into a corner, or treated as a fork.\nNotably I have zero ability to test this for correct function, and I'm not prepared to support Windows XP.\nLonger term, the transport and support layers need to be more pluggable, but that's nigh impossible with the current code base; understanding the FSM sufficiently well to make even an attempt is simply far too high a bar for the usual contributors.\nTime continues to progress, meanwhile Windows XP becomes less relevant.  I'm closing this PR.  Folks interested in having this function can find it here, and apply the patch themselves manually.  Presumably they are also equipped to test it for proper functionality; something I simply don't have the resources for.\n. Modulo one nit, and one unfortunate choice of return code, looks reasonable.  I'd like to see a better return code than repurposing something totally unrelated, to indicate an internal fatal error.  Also, I hope this will be committed as a single commit (git rebase) rather than 13 separate commits merged.\n. I fixed alot of issues, and now this conflicts.  Lacking HP-UX access myself, its unlikely I'm going to do much with this.\n. I'm closing this, because it no longer merges clean, and I don't have access to the HPUX test environment.  If someone else wants to reopen, with just relevant fixes, please open a new bug report and PR.\n. You're sending the message too soon, and not waiting long enough before shutting down the socket. \nRecall that nanomsg is asynchronous, and when you exit too quickly, or if you send the message without giving time for the connection to establish yet, the message may not be delivered.\nBy adding a sleep(1) before and after the nn_send(), your program works.\nSee lots of information about TCP slow start, and SO_LINGER.  While you're not using TCP, the same problems are applicable.\nREQ/REP (acknowledged messages) are generally free of this problem.\nClosing this as its a simple API usage problem, and not a bug in nanomsg.\n. The problem with the lost packets are almost certainly TCP slow start.  TCP takes a bit to connect, and you can't just immediately start publishing.  You need to sleep a bit before you can publish.  This is one of the drawbacks of the nanocat tool.\nAs far as the --by-line, feel free to submit a code change.  I'm less thrilled with it, but if someone offers up decent code for it I'll be happy to integrate.\n. This is a dup of #371 (or vice versa).  Fixed.\nThat said, pay close attention.  The code will bind to the first unicast address it finds on the interface.  That may or may not be what you want.  It may be better to administratively force and IP address directly instead of using an interface name.\n. Either way, can we close this? Leaving these bugs interminably open doesn't \"look good\".\n. Yeah, its clear from docs.  I've also spent time reading the code to understand why this is so.  Its kind of crazy.  But that's the behavior.  Closing.\n. This will depend on the operating system.  Some operating systems either lack IPv6 support, or have dodgy support for interoperability between IPv4 and IPv6.  Personally, the systems I use generally support IPv6 well.  But that may or may not be the case for you.\nThe other thing is handling of IPv6 URIs.  Your users, if they aren't expecting IPv6 URIs to show up in the addresses, may be surprised.  Applications doing getpeername() or similar things on underlying file descriptors may also be surprised.\nAll that said, I think that probably we ought to consider enabling v6 by default. \n. I'm not going to do this for v0.7, but maybe after?\n. So I've had some very mixed results with dual stack sockets ... and I'm starting to think that a better solution would be to explicitly insist on the use of tcp6:// urls.\nThere are problems there too... Stay tuned.. So with NNG we have tcp://, tcp6://, and tcp4:// URLs.\nFor nanomsg, I'm not going to change this, because I don't want to disrupt things for people who are already using it.\nIf you care about this, please consider trying out NNG.  github.com/nanomsg/nng. My gut is that this approach is here is correct.  @tailhook ?\n. I'm going to have to stare at this a bit.  I'm a little uncomfortable with approach but the arguments here are sound.  I would love to have more anecdotal evidence that this PR doesn't cause problems before I merge it. \nSent from my iPhone\n\nOn May 5, 2015, at 8:05 PM, Wirebird Labs LLC notifications@github.com wrote:\nIt seems that delaying fsm start is ok, as long as it's ok to create sockets/endpoints before start. Which seems quite counter-intuitive (even if it's perfectly works now)\ncaveat emptor: I'm commenting on a 4mo-old pull-request with 4mo-old knowledge, not having re-wrapped my brain around all the decisions behind the original change.\nI see the argument of being counterintuitive, but in another way it remains in the spirit of how libnanomsg reserves and then later activates sockets and connections -- asynchronously.\nThat said -- I have not fully studied the effect of enqueueing messages to the libnanomsg FSM prior to it starting -- e.g., is it always OK to preload its incoming message queue prior to its handler becoming active? In a formal sense, there should be no prob with this design, and it's appeared (anecdotally) to hold true in the libnanomsg FSM implementation.\nAll things considered, I'm 100% cool with a better or more elegant solution, but in the meantime would suggest merging this patch since fixes a characterized race that manifested in production without \"appearing\" to cause other bad things to happen, as long as others can confirm bad things don't \"appear\" for them either (or ideally, could even contribute some formal tests)!! \n\u2014\nReply to this email directly or view it on GitHub.\n. I need to catch up on PRs.  Will do so this week.\n\nOn Mon, Oct 12, 2015 at 11:16 AM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\nThis has been working well in production for a while; merge?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/359#issuecomment-147480403.\n. I redid this as #494 using a separate bug id and better commit comments, and have integrated here: \n\ncommit 991bad6b0199af58e964f54296a2e89094749146\nAuthor: Jack R. Dunaway jack@wirebirdlabs.com\nDate:   Tue Jan 6 16:37:21 2015 -0600\nfixes #493 statistics race with FSM\n. I'm pretty sure I've seen one failure in AppVeyor that looked like this.\n. Confirming that this is still a problem.\n. Problem may be insufficient tolerance:\n/*  Check whether measured time is the expected time (in microseconds).\n    The upper tolerance is 50ms so that the test doesn't fail even on\n    very slow or very loaded systems. */\ndefine time_assert(actual,expected) \\\nnn_assert (actual > ((expected) - 5000) && actual < ((expected) + 50000));\n\n. Looking at this, we are firing up to, but not more than, 10 msec early.  This looks like a possible bug in the Windows timing subsystem.  We are using select() here, so can WSA select fire early?\n. Yeah, I'd be inclined to believe that tcp_shutdown test is causing cascade failures. \n. What I don't understand is how we can return early.  This really really feels like it can only be due to a bug in the select() implementation on Windows; unless there is some way for a socket event to occur without actually having I/O on that socket?\n. The other thing is that the tcp_shutdown.c (and all of the tests and all instances of nanomsg on windows) use the global mutex to create a private TCP/IP socket for signaling operations.  This is the hackery that is created to make a select()-capable socket.  I truly despise this.  What's worse, because only winsock sockets are able to support select() on Windows, I can see no better alternative -- e.g. it isn't possible (that I can see) to create some non-IP based socket to (such as a private NamedPipe or somesuch) to do this.\nThe Winsock select() compatible semantic is IMO libnanomsg's single biggest weakness.  It makes it easy for some developers to build on top of, but it comes at this hideous complexity, fragility, and frankly at a non-trivial latency cost as well.\n. At this point, I don't want to break the semantic, because it would likely break too many library consumers who've come to depend on that functionality.  It works now; albeit not at best performance.\n. I'm pretty sure that the granularity of select() on Windows is system ticks, which are probably 10 msec by default.   The problem is that the time out should really be ticks + 1, rather than ticks, because the timeout should normally timeout after at least x ticks, but the way the Windows documentation calls it out it says \"maximum time\".\nI think the solution here is going to be to just widen the test tolerance to 10 msec.  We should probably give advice that on some platforms cough Windows cough timeouts can fire up to a system tick early (10 msec), therefore programs should be a little pessimistic when setting timeouts.\n. I've not seen this particular test fail in AppVeyor since I moved testing there.  I'm inclined to close this -- quite possibly other changes made since then have fixed this.\n. Looking at this code.  I see two problems.\n1. realloc() doesn't get the same zero treatment -- so if alloc_ () could have a problem, so could realloc, right?  (Realloc is trickier, because you have to zero only the end of the after the allocation.)\n2. I'd have concerns with zeroing full message contents.  This allocation function is used globally in lieu of malloc.  While the zeroing of memory for headers or other accounting structures is probably trivial, if messages are rather large, this could have a rather detrimental effect on performance. \nIt would be better, IMO, to try to understand where the 'uninitialized' use occurs, and ensure that callers that ned to zero memory do so explicitly.  (Perhaps only touching the specific structure members that they aren't otherwise overwriting.)  Failing that, perhaps expose an nn_calloc() for use by those callers where the clearing semantics are easier/required, and leave nn_alloc() for use by callers that don't require this semantic (specifically allocating the buffer for message payloads.)\n. The article you list was clearly written without a sufficient understanding of the workings of the system or of real world benchmarking. \nThe calloc trick used is indeed faster - if you never overwrite any of the data. In that case the page can be left alone.  But if you do overwrite the data ever then you must pay a penalty as the original shared page must be copied (copy on write). \nThe microbenchmark seems like it greatly favors calloc because this work step is skipped. But in any sane use case this would not be true.  The cost will just be paid for in the fault handler rather than in user space. \nIf you have a large buffer that you're going to put nonzero data into then you don't want to pay for this clearing either before or after the allocation.  You should just malloc and save all the waste. \nWhere the calloc trick wins is when you allow large empty arrays that are mostly sparse. This has to be enough to have whole pages (4 or 8k) left sparse to have any real benefit. This happens but I think it is more the exception than the rule. \nI believe illumos and Solaris just explicitly call the bzero or memset as part of calloc and don't do any MMU trickery. Frankly for most cases this is probably faster since the MMU page table updates aren't free.  It also lets us use smaller chunks of heap than a full page. \nSent from my iPhone\n\nOn Feb 26, 2015, at 12:26 AM, George Lambert notifications@github.com wrote:\nYou make some good points, but this article makes some interesting points\nas well.\nhttps://balexios.wordpress.com/2014/08/02/calloc-vs-malloc-memset/\nOn Wed, Feb 25, 2015 at 11:24 PM, gdamore notifications@github.com wrote:\n\nLooking at this code. I see two problems.\n1.\nrealloc() doesn't get the same zero treatment -- so if alloc_ () could\nhave a problem, so could realloc, right? (Realloc is trickier, because you\nhave to zero only the end of the after the allocation.)\n2.\nI'd have concerns with zeroing full message contents. This allocation\nfunction is used globally in lieu of malloc. While the zeroing of memory\nfor headers or other accounting structures is probably trivial, if messages\nare rather large, this could have a rather detrimental effect on\nperformance.\nIt would be better, IMO, to try to understand where the 'uninitialized'\nuse occurs, and ensure that callers that ned to zero memory do so\nexplicitly. (Perhaps only touching the specific structure members that they\naren't otherwise overwriting.) Failing that, perhaps expose an nn_calloc()\nfor use by those callers where the clearing semantics are easier/required,\nand leave nn_alloc() for use by callers that don't require this semantic\n(specifically allocating the buffer for message payloads.)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/363#issuecomment-76120267.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes.  But the problem is that calloc here is just a lazy way to paste over incorrectness in the code elsewhere.  Better to fix that code so we can have our cake and eat it too. \n\nSent from my iPhone\n\nOn Feb 26, 2015, at 12:41 AM, Bent Cardan notifications@github.com wrote:\nhere's a good quote to that article's point:\n23:51 \\n (Nick Desaulniers): correctness trumps perf.\n23:53 \\n (Nick Desaulniers): since a compiler makes code transforms on your behalf...\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm curious to understand, do we understand the errors you are encountering?  Is it in the handling of nanomsg itself, or is it in the payload?  If you're passing around strings in the message payload, these are explicitly not null terminated but simple byte arrays -- if you want them treated as null terminated C strings then you need to do that yourself in your application layer protocol.\n\nIf however, nanomsg is mishandling things internally -- for example assuming that some nanomsg specific structure is zero filled -- then that represents a more serious error, and it needs to be fixed, and fixed properly.  It may be the case that explicitly zeroing the structure (perhaps at allocation via calloc()) is preferable from the standpoint of simplicity.  I'm fine with the idea of doing that on small structures used inside libnanomsg, though I still feel that in some cases this is going to be suboptimal compared to explicitly initializing structure members that need it.\nThe whole performance diatribe above is a red herring.  calloc is not (cannot be) faster than explicitly clearing structure members; and for implementations that use paging (which I think only happens if you allocate full pages at a time -- e.g. message payloads!) hacks, is going to be slower due to the cost of copy-on-write.   (And anyway, none of it should happen for tiny structures -- I think even Linux doesn't use this paging hack if you're allocating a small structure.)\nSo, this PR gets a very explicit -1 from me, along with a request for more information about the nature of the problem being attempted to fix here.  If it is due to nanomsg structures being uninitialized, please file a bug, and lets work on a fix for that.  (With more information I am willing to help fix that problem.)  If it is an application payload problem, well, that's an application bug and out of scope for fixing here.\n. Are you saying the payload is garbled at the end?  That feels like an application error to me.  Can you provide some sample code showing the error?\n. Note that some languages will treat \"strings\" as null terminated, and include the null termination as part of the payload, and others may not.  Understanding whether your application needs to have the payload null terminated or not is an application problem.  (In fact, in the protocols I normally use, I don't normally null terminate but expect that the application will terminate on receive, using the length of the message.  If you don't want to use the nanomsg supplied message length you can also send a message length in your application protocol itself -- sort of like sending a Pascal style string instead of a C style string.)\n. I do have an iOS device, but I'm more interested in seeing the source code, rather than running it.\n. Ok, so we need to see the sender code, but at a quick guess, this is indeed an application here.  The problem is here:\nnn_recv (s, &b, NN_MSG, 0);\nprintf(\"buffer: %s %d \\n\", b, ++count);\nThe buffer you got is not guaranteed to be null terminated.  Messages are byte arrays, which are not the same thing as null terminated C strings.  You can \"insist\" that your publisher null terminate the content when it sends (I'd have to see the code for that).  For example, one way to do this when sending from a C program is to use \"strlen(str)+1\" to ensure that the null byte is included in the message. This \"insistence\" becomes part of your application layer protocol, and is not part of SP/nanomsg itself.\nDemanding that nanomsg apply some null termination logic to the message buffer is actually 100% dead wrong, since you can reasonably have binary protocols where zero bytes are part of the protocol contents.  (Indeed, many many protocols do just this, including, btw, the wire protocol for SP itself!)\n. And btw, if you're concerned about hardening your protocol against random attackers, you should actually verify that any application layer protocol constraints (such as null termination, or if you have encoded lengths instead, that the lengths are in-bounds of the message size), before you rely upon them.  This part of correct protocol handling if you are going to be expose your protocol to the hostile Internet.\n. Finally, note that the approach used with C language strings, may not work with strings from other languages.  For example. Go does not terminate strings internally, so if you want to ensure that a null is appended you have to include it explicitly, like this \"A C string\\0\"  (note the \\0.)\n. I'm not really in favor of it, no.  The problem you're encountering is directly related to the fact that you think you're messages are null-terminated strings, and that is a wrong assumption.  Your application layer protocol handling is busted; you need to fix that instead of blaming nanomsg. \nMaking nanomsg calloc() payloads to fix your small protocol error is sort of akin to requiring your car tow a trailer full of fuel in case you run out of gas because you were too lazy to keep an eye on your fuel gauge.  It may seem like it helps prevent certain kinds of tragedy (getting stuck in the middle of nowhere without fuel), but the fix actually hurts pretty badly (you're burning a lot more CPU for this laziness, and not really fixing the problem) and really addressing the symptom rather than the root cause.  (Because you're not checking that the actual trailer has enough gas in it, it might be empty.)\nWhat I mean is that calloc doesn't actually guarantee a fix here.  For example, if you receive a message that is a full page size (or a multiple thereof), then calloc will not clear the next byte -- the byte after the message is actually still going to be random (in fact, in that case you may very well segfault from accessing beyond the page in that case.)  And on most platforms calloc will not clear memory beyond the explicitly requested message size.  If the message you receive is the same size as what you asked for, that terminating null is going to be overwritten by the message contents which may not be null.  The only actual case where the calloc helps you is if you allocate a region of memory that is larger than the received message.  You really need to have a very friendly cooperating peer to do that.  (Or, you can use this trick in the application code by pre-allocating the received message with at least one byte larger than the incoming message, and null terminating after receive.  That's a perfectly correct solution, but it requires the app do the right thing.)\nThe only correct approach here is to fix your application.\n. marchon: no.  The messages are not being corrupted as I understand it.  The problem is that nanomsg transfers exactly the bytes you request.  Unless you insist that that transfer include a terminating zero byte (by including it in your message payload), it will not be included.\n. Just to be clear, if someone proves that the problem is uninitialized nanomsg control structure members, then that would represent a real libnanomsg bug deserving a fix.  But so far what I've seen is symptomatic of incorrect application expectations, and the proposed \"fix\" actually doesn't really fix anything at all.  It pastes over the problem some (even most!) of the time, but doesn't prevent the overrun cases -- because if you receive a message that is full size, and then try to blithely do string operations on it, you have no guarantee that the message is null terminated.\nThis is precisely analogous to using fgets().  While fgets() will not overrun a buffer, if the input takes as many bytes as requested (or more), then the buffer isn't null terminated.  The usual pattern here is to do something like this:\nbuf = malloc(n);\n  fgets(buf, n-1, stdin);\n  buf[n] = 0;\nNow replace \"fgets()\" in the above with \"nn_recv\" and you have your solution.\n. nanomsg doesn't pass the allocated memory block to any functions that expect null termination.  Again, it just things the thing is an array of bytes that might perfectly well contain any number of bytes that are zero.\nThere are many many application protocols (in fact, arguably this is true of the vast majority of them), that do not pass C style strings.  (Much more common when passing variable length string data is to pass a leading size ala Pascal - which is often encoded in binary, and that encoding can include null bytes -- for example the value \"256\" in a typical 16-bit value contains two bytes, 0x01, and 0x00.)\nThe application that takes a nanomsg packet and expects to be able to use C standard library routines that operate on null terminated strings has the responsibility to ensure that the memory contents actually are a well-formed C string. \nDemanding nanomsg do this for you is trying to use a hammer to drill a hole.  You can make a hole with a hammer, but you probably won't like the result, and you're more likely to break things than to have a correct solution.\n. Actually my fgets() example above is incorrect, because it turns out that fgets() actually does ensure null termination.  A better example would be strncat().  But again, the ideas are similar.\nWhen you deal with bytes coming off a wire, you should not expect that they will contain any particular values.   You (the application author) are responsible for validating the received data.  If you have a higher level protocol, you can do this in convenience functions in library code -- but that would only be appropriate for a protocol that insists on exchanging ASCII strings, and in a library that works in the C runtime environment.  It is not appropriate for nanomsg, which can work with arbitrary application payloads.\n. @marchon  I do expect that your observed behavior is that if you prealloc a buffer, and fill with bytes, like this: \nbuf = malloc(2048);\nmemset(buf, 'A', 5);\nbuf[10] = 0; /* ensure we don't stop printing at some point */\nn = nn_recv(sock, buf, 2048, 0);\nand then send it a message consisting solely of the single byte \"B\", the receiver will get back a value that looks like \"BAAAA\".  If you printf() that without null terminating, its going to be ugly.\nBut in this case the fix is relatively easy:\nn = nn_recv(s, buf, 2048-1, 0);\nbuf[n] = 0;\nYou can alternatively change your malloc to be one byte larger (2049) than your argument to nn_recv().  If you use NN_MSG asking the library to allocate a message for you, then you're going to have to copy the message somewhere else like this:\nn = nn_recv(s, &buf, NN_MSG, 0);\nnewbuf = malloc(n + 1);\nmemcpy(newbuf, buf, n);\nnewbuf[n] = 0;\n. Having nanomsg zero the end of the buffer only works if nanomsg overallocates the buffer.  Also, having it zero the buffer like this is also inconsistent with behavior seen when using other system calls.  For example, none of these null terminate:\nread()\nrecv()\nrecvmsg().\nFurthermore, its a gross error (and inconsistent) to apply any meaning of any bytes beyond the value returned by nn_recv().  That is, if nn_recv() gives you a return of \"4\", then by definition the results of any access to the fifth byte is \"undefined\", particularly if NN_MSG is specified.\nFurthermore, if you imagine that you called nn_recv() with a concrete message size into a fixed buffer, it would be a gross error for nanomsg to write to any space beyond that size (even just to add a null terminator.)  For example, a perfectly valid protocol usage is to receive a network encoded integer:\nstruct {\n    int x;\n   int y;\n} mystruct;\ncount = nn_recv(sock, &mystruct.x, sizeof (mystruct.x), 0);\nIf nn_recv started writing null termination bytes, it would probably (depending on the machine organization) actually overwrite the value of mystruct.y.  That would clearly be undesirable.\nTreat nn_recv() analogously to recv() (which is what Martin claims to have set forth in his design goal of adhering to BSD socket semantics), and treat NN_MSG as a simple convenience wrapper that does malloc(), and you have the right semantic.   Applying further semantics such as null termination is 100% in the responsibility of the application.\n. Just to be clear, I remain a very strong -1 against this change.\n. Upon further reflection, I suppose a reasonable way to handle this might be to have a different form of NN_MSG -- call it NN_MSG_STR for example, which allocates an extra byte and null terminates the payload buffer.  I can see for some protocols -- e.g. JSON based ones, this would be a form of convenience for the calling program, making sure that the message buffer has an extra terminating byte at the end of it.\nTo do this, you create an alternate form of NN_MSG as indicated, and then please do not use calloc (which sucks from a performance standpoint), but merely append a single null byte to the end of the message.  E.g. if nn_recv() would return 4, then do buf[4]=0.\nThat PR would look quite different from this one but should still be relatively small.\n. Btw, that NN_MSG_STR hack I suggested is not something I'd expect FFI callers to use.  Its really a convenience for C programmers working directly against libnanomsg, IMO.  I believe most non-C runtimes (e.g. Java, Go, Python, etc.) actually use length encoding rather than null termination. I'm pretty sure C++ follows the C conventions here, but I can't think of any language other than C or C++ that uses or typically needs null termination for correctness.\n. Reading python references, it appears that it distinguishes the differences between null terminated C strings, and arbitrary byte arrays (pointers to arrays of bytes -- it uses C_POINTER(c_char) for the latter, and has a \"first\" class item for null terminated strings.)  That's not terribly surprising since C programmers often expect special handling of the null byte.  (Recall I'm primarily a C programmer by trade -- I work in the kernel mostly, although I've done tons of work the C library on illumos systems, as well as for various BSD systems.)\nYour argument, @marchon, doesn't really hold water.  The values passed are not generally C strings.  The fact that your application wants to treat packet data as null terminated string data is actually a programming error in your application, if it doesn't validate that it is safe to do so before hand.  (That would also be true if using various other C routines, like write(), memcpy(), etc.  Only the str* and printf* family of routines really expect special handling of null bytes.  All other C library routines that operate on byte regions are \"8-bit clean\".)\nAs I said, I'd be willing to support a special \"helper\" for your application that is a custom NN_MSG variant (I proposed NN_MSG_STR) as a convenience.  I'd be vehemently opposed to making the behavior the default because it is more often wrong than it is right.  The special exception here for protocols that exchange strictly ASCII or UTF-8 data, such as JSON strings, as well as certain kinds of toy protocols.  Most serious protocols these days use binary encodings and those that don't often have to do crazy contortions -- like MIME encoding email to pass over legacy SMTP -- but even modern SMTP supports 8-bit clean transfer these days.)\nIn order to implement this correctly you MUST allocate an extra byte.  That may have surprising effects to the end user.  For example, if a program sends and receives messages of precisely 4k, the allocations will now be 4097 bytes, which is a really really poor fit for a variety of heap configurations.  (In many cases this will result in 2 pages being allocated instead of 1, doubling the memory cost!)  If you're exchanging pure binary data, you neither need nor want that extra useless byte on the end.\nThe advice given by CERT is correct, and relevant, and supports my statements here.  If you use a function that expects a null terminated string, and you the application developer have not ensured that the values being passed are actually null terminated strings, then you can well be violating the secure programming rules.  You can quite reasonably trigger segmentation violation (SIGSEGV) errors, Or you could wind up accessing memory used for other things. \nTO BE CLEAR.  nanomsg message buffers are not null terminated C strings.  They are byte arrays.  To treat them as null terminated strings is wrong, unless you have first ensured that they are indeed suitable for such use (such as by terminating them yourself, or checking for a null termination.  One way to check is with a utility like strnlen() - note the use of the \"n\" there.)  The issue here is making sure that callers understand the semantic here.\nThe sockets convention in use here is that recv() and related functions receive byte arrays, not strings.  (In fact, on the wire, even most protocols -- such as JSON-RPC over HTTP -- do not send zero bytes.  Instead they send a length and rely on the application to terminate appropriately.)  Zero terminating packets would be quite surprising to anyone used to working with more common networking stacks -- that includes at least the BSD sockets library, System V STREAMs, WinSock, OpenSSL, \u000f\u00d8MQ, RabbitMQ.  In fact, I cannot think of any typical networking library that does do null termination like this. A brief survey I did of HTTP client libraries didn't turn up any that did this kind of C string termination either, although my search was hardly exhaustive.\n. Btw, nn_recv makes this especially clear, because the buffer is actually not a char pointer, but a void pointer.  That is, it is saying this is a pointer to memory to store data, without making any claims about the data type of the contents.\nMany C APIs sadly conflate char pointers and void pointers.  (I think this comes about from older compilers without support for void pointers.)  But, nanomsg gets it \"right\" in this regard.  It also does the same thing for nn_send().  The point is a void pointer, not a character pointer.\n. Btw, its really poor protocol design to depend on null termination.  Doing so means your application is not going to be 8-bit clean, and therefore cannot be used to exchange raw binary data.  So, while this lazy approach can seem useful, in my experience this kind of approach later on comes back to bite you in the arse when you want to expand your protocol to exchange other things.\n. I can't close the issue.  I'm neither the maintainer (nor a committer), nor the submitter.\n. Don't think so.   I'm really not a fan of tcpmuxd.  The code is probably a little fragile here; I'd welcome PRs to make it better here.\n. tcpmux is about to be removed.  Recommend using websocket with a url redirector, or with mangos (which also gives you HTTPS for security) instead.\n. tcpmux is gone.  Closing.\n. This was fixed in \ncommit 7555f49e83ff414133f77e46389f8e5632eeea1f\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Fri Oct 23 08:01:22 2015 -0700\nfixes #469 assertion failure in ipc_shutdown (really)\n. This PR reflects feedback from Jack Dunaway, who is the original author of the websocket mapping.  It is compatible with my implementation in mangos.\n. @djc @wirebirdlabs So, consensus achieved?  Can we please merge this?\n. So other systems (illumos) create a unique logical interface for each IP address.  Apparently mac does something different, allowing multiple IPs to be present.  I even see unicast 127.94.0.1 and 127.94.0.2 on my lo0 port on OSX 10.10.1! \n. fixed in this:\ncommit ab699df74978645ebe5bb53f0b602ba4bf32ed4b\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Thu Oct 22 12:42:47 2015 -0700\nfixes #446 efd_win.inc global critical section should be mutex\nfixes #485 Windows efd_init should not assert on failure\nfixes #484 Make tcp_shutdown a little less likely to hang forever\nfixes #483 CMake tests hang forever\n. If the interval is too short, you'll wind up with a value that is too short for the request to be serviced, and the pending request is canceled.\nTo be clear, the interval is  the interval used between requests, not the time between receiving a reply and sending the next request.\nThe code is pretty clear, in that this seems to be the intended behavior.  We could change it to a different semantic, and maybe that would be a good thing -- although if you want to say \"do this twice a second\", then the current semantic works, but the semantic of waiting until the reply is received would not work, since with retries and all it could take several more seconds!\nAnyway, I'm closing this as not a bug for now.  Perhaps the documentation here can be made clearer.\n. Its kind of weird that you're doing nn_bind on both sides of the device.  but otherwise, it looks reasonable.  Cannot help you with windbg.  Threading issues perhaps?\n. I'm closing this as \"insufficient information\" to determine it's a nanomsg bug.  If more concrete info indicating otherwise crops up, feel free to reopen or submit a new bug.\n. You cannot free a an item that was allocated on the stack.  It can only be done for messages that are allocated by nanomsg (in this case using NN_MSG).  The error is not in libnanomsg, but in your code.\n. (Someone should close this as not-a-bug -- I cannot because I'm not a maintainer.)\n. Actually, binding to a random port is better, because its atomic.  What I mean is, you bind, and you know you got the port.  If you try to generate one randomly (and do the work to ensure it isn't already in use), and then rebind later, the port might be unavailable as another application can take it between the randomization and the binding.  You can do some things to make this window small, but its definitely the case that using a randomized port can be better because of atomicity. \nIt would be useful also to allow for applications to randomly bind to a reserved port (traditionally a port number less than 1000 -- or maybe 1024 -- I don't remember right now). \nSo, I support this RFE in principle.\n. Martin has declared, that the real problem is the small port space. That's true.  (There is another problem that TCPmux and websocket solve, and that is dealing with firewall and configuration rules -- having too many ports makes it hard for admins to cope, but that's actually not solved by ephemeral ports -- indeed ephemeral ports make it worse.)  The other part of the port problem space is that it forces administrators to choose a port to run on.  When you have a microservices architecture, this gets onerous, as you can have dozens or more services -- managing the port allocations for each is a pain.\nTCPmux  is an interesting solution to the problem, and with broader adoption could be a fix.  But the hackery needed to make it work is non-portable, and frankly I don't see it getting much adoption.\nWebSocket is an extremely compelling solution.  Except.  Libnanomsg's implementation is woefully deficient.  While it speaks the websocket protocol in a manner sufficient to act as a client, the server side does not support multiplexing on port, and does not inspect the URI ever.  The libnanomsg websocket implementation is nothing better, IMO, than a toy, compared to what could be achieved.\nmangos is an alternate implementation, and supports fully multiplexing multiple SP sockets (as well as non SP content, such as static HTML or Javascript content, or other application layer protocols) on a single TCP port, using the URI to direct traffic to the proper handler.  This is possible because mangos uses the Go full HTTP framework.  Getting libnanomsg to do the same thing would require solving a bunch of non-portable problems, or introducing a full HTTP server framework into libnanomsg.  That doesn't seem very realistic.\nWhat I can say is that I've found the ability to bind a listener to a random socket very useful -- we use an RPC bind like mechanism, where the central dispatcher acts as a surveyor, and microservers run respondents that indicate the port where they are providing REQ/REP services.  (As well as other details about the services they are offering.)  This makes running these servers a zero-administration effort.  It would be much harder to do this if we can't have random port binding.\n. Certainly, you can hack this in software as diffuse indicates.  But libnanomsg's bind may not be atomic either -- so you may not know about the bind failure.  The problem is the disconnect between libnanomsg's bind and the actual BSD socket bind.  If you actually know that the bind failed, so you can try again, then the approach works well.  But libnanomsg tends to hide these kinds of problems from applications.  (actually, this makes supporting a random port harder too -- because you do not know if the port is actually bound yet... but that's another problem.)\n. There are other approaches that could be used.  It's unclear to me how easily they can be done given the current libnanomsg architecture.  Mangos gets this trivially but it has a much more flexible architecture and far simpler design constraints. \n. There's almost no chance I'm going to do this for libnanomsg prior to 1.0.  Something to consider for a major refactor though.  I'm closing this for now.\n. I think the idea is that we could passing in data from a layer that doesn't realize the peer has gone -- e.g. if the peer has disconnected.  We could change the API to return an error, and I think this might be a good idea, but its out of scope for this bug.\n. Yes, I can. I've done this in mangos, I just haven't got around to it.  Other more critical bugs keep killing me.\nThat said, I consider fixing this pretty critical.  Its possible (too easy!) to build devices that can have infinite forwarding loops in them, causing crashes, etc.\nThe STAR protocol (not included in nanomsg, its a mangos protocol) actually really needs this, since otherwise you can accidentally have forwarding loops really far too easily.  Short of implementing a spanning tree type thing, this is needed.\nSo no, I won't be closing this until I fix it.  I do plan to fix it.\n. No.  It's not a TCP specific thing.  It's a protocol not transport option. Will probably go with NN_SOL_TTL or somesuch. \nSent from my iPhone\n\nOn May 31, 2016, at 10:48 PM, Bent Cardan notifications@github.com wrote:\nNN_SOL_HOPS\nBut use case sounds like a TCP option, so please also consider naming like NN_TCP_HOPS option\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. It could impact IPC or inproc just fine. \n\nI can build a device using two inprocs that forward to each other.  This change would prevent that. \nSent from my iPhone\n\nOn May 31, 2016, at 11:10 PM, Bent Cardan notifications@github.com wrote:\nright, it could impact any other wire transport\nsince it's hard for me to see the option being applied to inproc or ipc, how do you draw a clear line between protocol and transport?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Integrated.\n. @stepelu can you try the latest code, and let me know if its still a problem?\n. Agreed, closing.  Feel free to open a new issue if problems occur in 0.8 or later.\n. pub & sub are best effort.  In particular, if you submit messages faster than your TCP stack can process them, they get dropped on the floor -- there is no pushback.\n\nThe drop may even occur not in the sending side but on the receiver side!  (The sender will never know that the message hasn't been received.)  Additionally, its possible that the sending be done asynchronous (mangos does this), so that the sender returns even before all the messages are delivered to the underlying stack (or dropped if the underlying stack cannot accept them.)\nIn fact the only way to \"fix\" this is to use a different paradigm.  If you want acknowledged receipt, you need to use a protocol like REQ/REP, or you need to use an application layer protocol that handles this.  Note that these things are really really poorly suited for multicast/broadcast communication, so you probably have a mismatch in your model if you're trying to achieve this with pub/sub.\nNote that VMware or other systems introduce additional stack latency, and are also therefore more likely to result in dropped messages.  (The time it takes to context switch into the VM, and then for the VM to bring in the application to receive the message plays a double role.)\nBtw, these problems are also a good example of why pub/sub should not be used to stream huge amounts of data, particularly if you want to avoid data loss.  It works well for lighter loads with modest amounts of gap between packets (as you noted, even 10 us can help), but pounding as hard as you can will almost certainly cause lost messages.\nI'm closing this as the problem is not with nanomsg, but rather with your usage and understanding the limitations of the design.\n. Can you include a stack backtrace?\n. Can you supply a test program?  Also it seems more likely that it is the number of fds than their value.\n. So testing this on SmartOS (illumos which is pretty much Solaris), I see that if I start the SEND first, I get lots of responses.  If I start the RECV first, I get a \"Bailing out of main\" message pretty quickly.\nI guess that this is due to TCP slow start.\nAt no point am I seeing a crash.\nHOWEVER, I'm running with relatively current nanomsg, and a 64-bit build.  Perhaps you're seeing this with 32-bit mode builds?  Am I missing something else in the test?  Because right now I cannot reproduce it.\n. on Solaris systems, you can do \"file\" on your executable.  It will report either a 32-bit or 64-bit ELF file.  To build with 32-bit, you have to use -m32 in the compile flags, or -m64 for 64-bit, assuming recent GCC.  If you're using another version (older), or Studio, the flags will be different.\nOn SmartOS systems, the default compiler builds 64-bit by default.  Which distro are you using?  Oracle Solaris, or an illumos system?\n. Good analysis.  I'll test it out and make the change.  If you want to send me a PR that would be even better and ensure you get credit in git. \nSent from my iPhone\n\nOn Jun 15, 2015, at 4:52 AM, mikalankes40 notifications@github.com wrote:\nHi again. We used the memory debugger tool dbx and got this memory fault after a lot of struggle:\nWrite to unallocated (wua) on thread 2:\nAttempting to write 4 bytes at address 0x98ed0\n    which is just past heap block of size 64 bytes at 0x98e90\nThis block was allocated from:\n        [1] nn_poller_init() at 0x22b08\n        [2] nn_worker_init() at 0x1b9e4\n        [3] nn_socket() at 0x17740\n        [4] main() at 0x16c84\nt@2 (l@2) stopped in nn_poller_add at 0x00022bb8\n0x00022bb8: nn_poller_add+0x0020:       st       %i1, [%g3 + %g2]\nThe memory bug is connected to the struct pollfd *pollset variable in the file poller_poll.h:\n31: struct nn_poller {\n32:\n33:     /* Actual number of elements in the pollset. /\n34:     int size;\n35:\n36:     / Index of the event being processed at the moment. /\n37:     int index;\n38:\n39:     / Number of allocated elements in the pollset. /\n40:     int capacity;\n41:\n42:     / The pollset. /\n43:     struct pollfd pollset;\nThis variable is allocated to an incorrect size (too small) in the functions nn_poller_init() and nn_poller_add(). The correct allocation size is shown below in the diff:\n*** poller_poll.inc\n--- poller_poll_MODIFIED.inc\n\n* 31,37 \n    self->index = 0;\n    self->capacity = NN_POLLER_GRANULARITY;\n    self->pollset =\n!       nn_alloc (sizeof (struct pollfd ) * NN_POLLER_GRANULARITY,\n            \"pollset\");\n    alloc_assert (self->pollset);\n    self->hndls =\n--- 31,37 ---\n    self->index = 0;\n    self->capacity = NN_POLLER_GRANULARITY;\n    self->pollset =\n!       nn_alloc (sizeof (struct pollfd) * NN_POLLER_GRANULARITY,\n            \"pollset\");\n    alloc_assert (self->pollset);\n    self->hndls =\n\n* 59,65 *\nself->capacity *= 2;\n      self->pollset = nn_realloc (self->pollset,\n!             sizeof (struct pollfd *) * self->capacity);\n          alloc_assert (self->pollset);\n          self->hndls = nn_realloc (self->hndls,\n              sizeof (struct nn_hndls_item) * self->capacity);\n--- 59,65 ---\nself->capacity *= 2;\n      self->pollset = nn_realloc (self->pollset,\n!             sizeof (struct pollfd) * self->capacity);\n          alloc_assert (self->pollset);\n          self->hndls = nn_realloc (self->hndls,\n              sizeof (struct nn_hndls_item) * self->capacity);\nAllocating the size of pointers instead of the size of the data-structure will result in a too small memory allocation which in turn results in memory corruption when this allocated memory is accessed in the function nn_poller_add() in poller_poll.inc:\n69:    /* Add the fd to the pollset. */\n70:    self->pollset [self->size].fd = fd;\n71:    self->pollset [self->size].events = 0;\n72:    self->pollset [self->size].revents = 0;\nThis bug will not be as visible in 64bit mode compared to 32 since the crash occurs when using >4 socket descriptors in 32bit and >8 socket descriptors in 64bit mode. The bug does not appear in Linux since the default polling mechanism in Linux is epoll, while the only mechanism available in Solaris is poll.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm not aware of any reason.  (Frankly I never use nn_symbol, not even sure what the use case for it really is.)\n. If someone would take a quick look at my proposed solution -- I hope it will work. \n. Thanks.  I will merge soon then. \n\nSent from my iPhone\n\nOn May 31, 2015, at 4:15 PM, romanoved notifications@github.com wrote:\nYes, it works as expected.\n\u2014\nReply to this email directly or view it on GitHub.\n. I know how to fix the test suite.  Fixing the framework, not really easy.  I have a plan to fix the illumos kernel to add support for the missing functionality.  I just haven't got to it. \n\nBut for systems that lack the ability to suppress or mask the SIGPIPE, the only real option is to have application programs set up a handler for it. \n. Note that I think the current code is also buggy in that it fails on SMP systems because it changes things without holding a lock.\n. The assertion failures are unrelated to the SIGPIPE errors, except that they both involve shutdown.  There are two problems here.  First is the SIGPIPE error.  The second is a race (I believe) that is exposed by some assertion failures.\n. > On Mar 28, 2015, at 2:18 PM, Bent Cardan notifications@github.com wrote:\n\n@wirebirdlabs https://github.com/wirebirdlabs, when you and Martin started working on the nanomsg websocket, around the time when those commits began, do you remember when you explained to me reasons for selecting websocket?\nI mentioned looking into Server Sent Events and your reply:\nit doesn't seem SSE fits the required semantics for all the nanomsg scalability protocols, where as ws:// does.\nThat\u2019s still the case.  SSE is one-way \u2014 server send to browser.  websocket is full duplex.\n@gdamore https://github.com/gdamore, this is something, btw I think a new important turn in the history of the protocol, that deserves your attention as well... while I've only started catching up on the new standards track for HTTP/2, it looks like there is tremendous alignment underway with the natural socket interface designs and semantics for scalability protocols we have in nanomsg, namely:\nstream identifiers and stream concurrency https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1\nserver push and push requests https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.2\nrequest multiplexing https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5\nMost of the enhancements in HTTP/2 are targeted at improving experiences with browsing.  That is, the server push for example is sort of a \u201cserver-side look-ahead cache\u201d \u2014 its not really the same thing as push vs. pull, but an optimization done to reduce round trips.  The multiplexing over a single TCP channel is nice, and I do think that with websocket over HTTP/2 it will reap some rewards for us.  That said, the implementation of websocket in libnanomsg is kind of toylike in its simplicity \u2014 adding support for full HTTP/2 semantics is likely to be rather a large task.  I wouldn\u2019t look to see that work happen anytime soon.\n\nFar more likely is a full rewrite of libnanomsg with an internal design that is easier for extension (but may make other sacrifices, which make it harder to embed in certain implementations such as OS kernels, for example).  That said, I wouldn\u2019t rate the likelihood of even that at very high, since as far as I know I\u2019m the only one likely to undertake such an endeavor, and I don\u2019t exactly have a surplus of time on my hands.\n\nAlso the chrome team may have some client-ready http://blog.chromium.org/2015/02/hello-http2-goodbye-spdy-http-is_9.html releases in the next few weeks.\nIMO, nanomsg SP protocols may fit HTTP/2 standards even more so than websocket and I'll make an easy call right now: I predict HTTP/2 https://http2.github.io/ is going to rival websocket and eventually in the long term, replace it.\n\nI think that its rather premature to make such a prediction.  websocket\u2019s exists to offer a binary protocol to application developers, for use in the browser.  Its unclear to me that the same semantics are directly available with HTTP/2 that websockets gives.  They may be.   There are also discussions afoot about layering websockets on top of HTTP/2, but I can\u2019t see that any consensus has been reached on that yet.\nThe following blog post is salient: https://webtide.com/http2-last-call/ https://webtide.com/http2-last-call/\nI\u2019m hopeful for the future of HTTP/2, but I\u2019m also not ready to spend a bunch of time heading off without having some idea where the destination lies.\n- Garrett\n. > On Mar 28, 2015, at 3:47 PM, Bent Cardan notifications@github.com wrote:\n\nthe implementation of websocket in libnanomsg is kind of toylike in its simplicity.\nSounds good to me!\n\nUm, in this case that wasn\u2019t really meant as a compliment.  Its just sufficient to meet HTTP/1.1 and switch to websocket.  It can\u2019t really support any other interesting parts of the HTTP spec, and it is impossible to layer it with TLS, or to make a really useful websocket server (for example, it totally ignores the resource specified, which makes it impossible to multiplex multiple sockets or applications on the same port).  Put another way, the implementation is toylike enough to meet the requirements of websocket from an RFC standpoint, but totally miss the point.  That said, it would be non-trivial to do much more within libnanomsg, because of libnanomsg\u2019s design constraints.  (I\u2019ve done a lot more here with the freer constraints available to me in mangos \u2014 plus having a rich http and websocket framework to utilize.)\n\nI think that its rather premature to make such a prediction. websocket\u2019s exists to offer a binary protocol to application developers, for use in the browser. Its unclear to me that the same semantics are directly available with HTTP/2 that websockets gives. They may be. There are also discussions afoot about layering websockets on top of HTTP/2, but I can\u2019t see that any consensus has been reached on that yet.\nHTTP operates under semantic obligation to close the response after the last fragment. I'm hesitant to say close the TCP connection since proxy servers started implementing keep-alive and that's widely used.\nNot just proxy servers.  HTTP/1.1 keeps the TCP channels open by default.  This was one of the main advantages to 1.1 over 1.0.  (The other big advantage is that in 1.1 the Host: is specified in the protocol, allowing for aliasing based on CNAMEs, avoiding the requirement to set up IP addresses and A records for every possible alias you might want to serve from a single server machine.)\nContrast that pattern with websocket:\nwebsockets exist to offer a binary protocol to application developers, for use in the browser.\nTrue, it's a two-way messaging pattern that seems consistent with scalability principles/protocols/patterns we see in nanomsg.\nBut that's just section 8 of the HTTP/2 draft https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8!  \nSection 8 starts with language that makes it clear that the intention is to retain the semantic REQUEST/RESPONSE model of HTTP/1.1.  To wit:\n\nHTTP/2 is intended to be as compatible as possible with current uses\n   of HTTP.  This means that, from the application perspective, the\n   features of the protocol are largely unchanged.  To achieve this, all\n   request and response semantics are preserved, although the syntax of\n   conveying those semantics has changed.\nSo, it would be a mistake, IMO, to assume that it semantically is anything at all like a free-form binary protocol with completely asynchronous messaging.  (In HTTP request/responses are synchronous, in the sense that you don\u2019t get a server response until after you\u2019ve asked for a request.)\nIf you read the details of Server push, you\u2019ll see that it is still intended for caching purposes, and indeed the client is given some control over whether server pushes should be used or not.  (SETTINGS_PUSH_ENABLE).\nNow it may be that people will figure ways to abuse the protocol to get server-push style behaviors for supporting semantics associated with push.  But notably, the logic is really not in HTTP/2 itself to support true arbitrary bi-directional messages.  For example, having a pattern where the server sends a message to the client, and gets a reply back, is kind of not there.  And every message sent by the client needs to be responded by the server.   Yes, you can hack around these, and make something that works\u2014 but you\u2019re trying to use a hammer to drive a screw.  Can be done, but the fit is wrong, and the results are ugly.\n\nFurther into section 8, push requests are defined as essentially the semantic inverse of the GET/POST style. HTTP/2 ushers in a new two-way messaging protocol native to the TCP connection.\n\nNO it does\u2019t.  See above.\n\nOf course the header format and framing designs are not the most attractive aspect of the protocol, but in HTTP/2 I see it as a minimal, albiet ugly, semantic requirement to bi-directional TCP sockets.\n\nIf you want bidirectional TCP sockets\u2026 um\u2026 there is TCP.  If you want bidirectional communication within a browser/web semantic, we have websocket.  We don\u2019t need HTTP/2.  There is really zero value that HTTP/2 can offer over websocket here.  (Well, you can argue that having fewer underlying TCP connections without head-of-line blocking can be a win for some servers running at extreme scales and needing multiple connections per client.  Its unclear to me that this is a significant enough benefit to be worth the various sacrifices you have to make along the way.)\n- Garrett\n. > If you want bidirectional communication within a browser/web semantic, we have websocket. We don\u2019t need HTTP/2.\n\nFrom this perspective, Websocket looks simpler and more straightforward, so I guess time will tell whether the HTTP/2 streams end up replacing them.\nOK.. now that we've cleared that up, I'd like to return to the first point you made, because there was something very interesting there having less to do with HTTP/2 standards track and more to do libnanomsg and it's ability to support additional extensions or modularity:\nthe implementation is toylike enough to meet the requirements of websocket from an RFC standpoint, but totally miss the point. That said, it would be non-trivial to do much more within libnanomsg, because of libnanomsg\u2019s design constraints.\n@gdamore https://github.com/gdamore, where do you see design constraints? Where are they the worst? And more importantly how can we improve these areas of the library? Is there a specific layer or convention, encumbering further extension/modular development?\n\nThe design constraints involve hard tie to file descriptors and POSIX like API, and a requirement to be portable even into runtimes where you can\u2019t for example use native threading.  This last case forces a design to use asynchronous I/O in some rather painful state-machine constructs.  The internal construction as a result is inordinately complex, and pretty much impossible to extend to systems like OpenSSL.  (Well, not impossible, but of such a high complexity that I think it may actually be less effort to redesign from scratch.)\nBtw, these same design constraints make it really hard, for example, to attach to a broader \u201cHTTP\u201d transport or framework.\n- Garrett\n. This is not really an \"issue\" as such, although one could argue it would be nice if we could support websocket over HTTP/2, the lack of any standard for this (and the very newness of HTTP/2 itself) means we cannot proceed.\nI'm closing this issue for now.  When/if a standard for websocket over HTTP/2 emerges, we should reinvestigate.  My suspicion is that libnanomsg will never support it, because the effort to support the full HTTP/2 protocol, as well as (really) full websocket semantics, is simply misaligned with libnanomsg's other goals.\nIf you need HTTP/2 for some reason, use mangos and a device.  (once mangos supports HTTP/2, which I guarantee will not occur before there is some kind of consensus for websocket over HTTP/2.  Which is not today.)\n. I\u2019ve seen this.  It looks interesting, actually.  I\u2019m not sure how you\u2019d use it with nanomsg though.\n- Garrett\n\nOn Aug 14, 2015, at 10:02 PM, Alisson Cavalcante Agiani notifications@github.com wrote:\nFor reference, something that builds on HTTP/2:\nhttp://www.grpc.io/ http://www.grpc.io/\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/395#issuecomment-131297175.\n. Yes and no.  Nanomsg is just a transport not an rpc framework.   Req / rep patterns maybe \"at risk\" from the competition but nanomsg supports a variety of other useful patterns. \n\nSent from my iPhone\n\nOn Aug 15, 2015, at 1:32 PM, Alisson Cavalcante Agiani notifications@github.com wrote:\nActually I think it is a competitor\n\u2014\nReply to this email directly or view it on GitHub.\n. To be honest, I see ~0 value in that.  If you want TCP... just use TCP.   If you can't, you most likely are in the browser, so you're stuck with websocket.\n\nFurthermore, the complexity in libnanomsg itself is sufficiently high that I'd be loathe to try to pound it into a different use case.  The various state machines inside are already hard enough to follow...\n. Yes, but why?\nIf you want vanilla TCP without any nanomsg semantics, just use TCP.  Creating a layer of syntactic sugar (lets be clear -- that's all it would be, at least from the client's perspect) seems to add ~0 value, and a bunch of extra headache.  That said, from the implementation's perspective, it would be a rather large amount of effort, since our internals aren't suited to this.\n. Generally NAT rules depend on the NAT router.  nanomsg doesn't know or care about NAT.\nThat said, most NAT devices translate TCP properly, except that unless you set up a forwarding rule, you cannot initiate a connection (nn_connect) from outside the NAT to an address inside the NAT, although you can initiate from inside to the outside.\nBe aware that which side does the nn_connect is orthogonal to the question of which side is publisher and subscriber.  (Although normally the subscriber does the connect, it can go the reverse.)\nIf you set up a forwarding rule in your NAT to expose the ports through, then this is all moot.\nAnyway, this isn't a bug so I'm closing the issue.\n. It should be possible to have multiple workers, but only one socket and only one endpoint can be bound to a specific address.  This is due to how IPC works (which is analogous to TCP in this sense.)\nTo further address, can you supply a sample code snippet exhibiting the problematic behavior?\n. Connect yes.  Bind no. \nSent from my iPhone\n\nOn May 3, 2015, at 8:12 PM, Kai.H notifications@github.com wrote:\nsorry, can you elaborate more on the requirement of one socket/ep bounding to a specific address?\nif i want to use req/rep pattern to distribute workloads among multiple rep workers, should i not have each worker to bind and connect to the same address where req ep will send message to?\n\u2014\nReply to this email directly or view it on GitHub.\n. > On May 4, 2015, at 12:40 PM, Kai.H notifications@github.com wrote:\nmaybe i am missing something, isn't rep endpoints workers? and they need to bind to the socket, whereas req endpoints are clients that connect to it?\n\nEach rep must have its own address or URL, if you are using bind.  (You can use connect() with rep, but that\u2019s not common usage, counter-intuitive, and probably not what you want.)\nSo, the way you have multiple workers is that you have a client dial each worker.  You can dial multiple workers with a client, but each worker will have its own URL.  Something like this (pseudo-code):\nServers:\nnn_bind(s, myURL)\nClients:\nfor (i = 0; i < nservers; i++) {\n    nn_connect(s, serverUrl[i]);\n}\nTo be clear, each server (in bind context) cannot share the endpoint address with any other.  But clients may connect to many endpoints (provided this makes sense \u2014 which it does for REQ/REP, but not for some others \u2014 e.g. PAIR.)\nThe load balancing here is done by the client, not the server.\n- Garrett\n\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/399#issuecomment-98827593.\n. Is there a reason you're using autogen instead of cmake?\n. autogen is not supported on Windows for nanomsg.  For nanomsg, you need to build using CMake on Windows, or autogen & co on POSIX systems.\n\nIn particular, there are settings that are only applied (#defines) when using CMake, but which are absolutely mandatory for Windows.\nClosing this... I'm not going to fix it.  (RTFM).\n. This behavior is as designed; the nn_bind and nn_connect calls will attempt to rebind/reconnect at periodic intervals.  This is to help them act in a \"self-healing\" capacity.\nThere is a proposal to add per-endpoint errno reporting, which may improve visibility into these problems somewhat, but modulo that, these functions are not intended to fail, ever.  Even if they don't establish a connection.\nThis behavior may seem surprising at first, but its that self-healing component that justifies it.  You just use them and don't worry if there is a temporary problem.  (Arguably some errors will always be fatal, and it would be nice if we could identify those and return such a hard failure, but figuring out which errors cannot ever be corrected is non-trivial.)\nMeantime, I'm closing this as \"not a bug\".  (Or rather, intentional design feature.)\n. Agreed.  That code is needlessly fragile only handling ECONNREFUSED and ENOENT.\nWe should fix it.\n. libnng is far more robust here.  Probably I should fix this in libnanomsg as well, I just am not terrifically motivated to at the moment.  I think its better to focus on stabilizing libnng so that we can retire libnanomsg.. If you trigger any of the errors in the current code, please file a bug.\nMeanwhile I'm closing this, because it is just too general, and the referenced code has changed rather dramatically.  I think we do a better job now.  (And libnng does a vastly better job by design.). I'm of mixed minds.  Arguably, there should never be a need to support > 2GB of data in socket sends. (Nobody should do that!)  But ssize_t seems like the \"right\" fix here, and using a #define or typedef to work around windows limitations seems ok.\n. Its astonishing to me that ssize_t is not defined on any modern system.  That said, size_t works just cast the value of -1, which will probably 0xffffffff on 32-bit Windows, like this: (size_t)-1\nAll that said, who's ever going to try to pass > 4GB in a single nanomsg message?  That seems -- insane.  A number of platforms are going to have trouble dealing with such large payloads, and indeed to pass such a large message you'd need to allocate at least that much RAM, never mind the time it would take to transfer that much data (a 4GB message would take 312 msec to exchange over a dedicated 10GbE link running at wire rate.)  Never mind the fragility associated with this.\nHowever, the protocol permits (over TCP) a 64-bit payload.  It seems \"wrong\" somehow that the library limits this.  However, I've found in practice to prevent DoS abuses/crashes, that it makes sense to apply a firm limit in mangos, which can be altered, but defaults to rejecting messages larger than a certain size (say 1MB).  I don't think libnanomsg applies any such limits (which arguably is a problem.)\n. I'm not sure I understand what the point of transport level close hand shake would be.  Certainly, we do need a way to inform the core that an endpoint is gone/closed (and indeed mangos has this as well, including notification back to the application which is actually something useful that libnanomsg lacks), but what would the purpose to a wire-level change be, vs. an internal API change?\n. I'm fairly confident that indeed, no wire protocol is necessary in any of the extant transports.  I'm not sure about the bottom half of websocket, but I guess those mostly get exposed through the API as \"close\" of the transport endpoint, which should be sufficient for the upper layer needs.\n. In mangos we generally get a truncated read for the closed or disconnected peer.   Which is indeed sufficient, and we \"properly\" remove the endpoint and notify the upper layers.  This does mean that in order to detect the close that even sockets which have only send logic (e.g. pub, or push) need to have a passive reader notice the EPIPE/SIGPIPE error.\nI'd have to look at libnanomsg more closely to see how it deals with this.  Running synchronous service threads and avoiding non-blocking I/O altogether is far easier in mangos/Go.  In vanilla legacy C, its a bit trickier.\n. I'm inclined to leave this as is for now.  There isn't really any value in extending this to larger integer types at this point, as nobody is going to use nanomsg to transport messages larger than 2GB; the library would melt if that were tried.  And indeed, we have defenses in place to prevent it now.\nChanging API signatures at this late date is probably also problematic, and see also the portability problems with ssize_t.\nI'm just going to close this for now.\n. The errno proposal is outstanding, and is likely to be integrated with a few minor changes.\n. I'm closing this for now; there are no code changes needed for this.\n. This looks like a useful change.  I want to spend a little more time looking at it, if you don't mind.\n. Ok, I'm pretty happy with this.  If you can do the following I'll be even happier:\na) Fix up the nits & wordsmithing stuff I identified.\nb) Lets figure out what the answer to a missing end point should be. I notice that the other cases where we can use an ep ID (nn_shutdown) returns -EINVAL for \"no such endpoint\", and I really think we ought to do that here too.\nc) Once the above two are resolved, rebase this down to a single commit.  The comments should be along the lines of \"fixes # \"  (yes, this is a new style).\n. I updated the comment (git commit --amend) so you may need to remerge.\n. While I appreciate the desire for a scatter & gather, I think this design has several flaws.  Most importantly it changes the wire protocol in a surprising way - messages exchanged using this new semantic cannot be exchanged with other peers. \nFurthermore I'm opposed to adding additional boundaries into the protocol or the API.  If know a priori you can use explicit receive vectors that are reallocated. \nI'd support a design that used fixed sizes and then used an iov with NN_MSG for the last chunk (dynamically allocating \"the rest\"). \nAlso remember that nanomsg is a binary protocol and therefore use of ASCII strings in the protocol is ill advised. It's inefficient and the message sizes are variable if you do that.  Fixed binary numbers are far better. \nThat said I repeat that I'm unlikely to be supportive of a change to the wire protocol for a feature like this. \n. > On May 6, 2015, at 2:12 PM, Sam Baxter notifications@github.com wrote:\n\n@gdamore https://github.com/gdamore , if you could, let me know if this is a more promising path to go down. I'd like to be able to work something out, but if this is a hopeless endeavor I'll stop pursuing it as a pull request and bring it into my project's code.\n\nMy feeling is that this is the right approach (handling it in your application) \u2014 I don\u2019t think the benefits of this are sufficiently generally useful to warrant changing or extending the wire protocol.\nBtw, what is really your motivation here?  (In other words, why and how is splitting the data into fixed sized \u201cportions\u201d useful to you?)  Normally the cases I\u2019ve seen for this are for network protocols where you need to split off headers, and the splitting is usually done to facilitate data alignment on things such as NICs.  (Most common case is where ethernet is misaligned with a 14 byte header, but we\u2019d like to have the following IP header and frame properly double-word aligned.)  I\u2019m having a little difficulty understanding the use case in application code though.\n- Garrett\n\nIf you agree with the potential benefits and think it's worth spending more time on, I'll add some more tests and protection on the nn_recvmsg side against reading bogus buffer sizes.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/pull/409#issuecomment-99611543.\n. I've not had time yet.  Perhaps another contributor can help?\n\nSent from my iPhone\n\nOn May 19, 2015, at 4:53 PM, Sam Baxter notifications@github.com wrote:\nAs I commented in #413 , this doesn't seem to be working on Windows. Are you already looking into this? I'm getting started on trying to figure this out for IPC now.\n\u2014\nReply to this email directly or view it on GitHub.\n. This PR has three separate commits, one of which was cherry picked with #468 \n\nPlease rebase this to master, and make it just a single commit fixing just the single requested issue (the geterror call), and then I will look again.\n. I'm going to close this PR for now.  Please feel free to reopen when just the errorno functionality is ready, or open a new PR.\n. Rebinding an inproc socket after the originally bound socket shuts down crashes unless all other connected sockets shutdown before rebind.\n. You can do that by creating the node or using chmod on the file name after the fact.  There may be other ways too.\nRight now there isn't a good way in libnanomsg to pass transport specific parameters.  We could add an option for it I guess?\n. Looks pretty good.  Do the other transports have a similar problem?\n. Ok, so I'll have a go at merging these pull requests in the next day or so, once I get a few spare cycles.\n. So, I was looking at this, and I think the inproc changes you have made are unrelated.  Please separate those out so that I only have the ipc related change and test, and then I'll merge.\n. Sure no sweat.  I could probably make the changes myself if you don\u2019t have\ntime.\nOn Wed, Oct 21, 2015 at 12:07 PM, Sam Baxter notifications@github.com\nwrote:\n\nSorry, looks like those inproc changes are whitespace issues. I'll make\nthe change when I have time to get around to it, don't know how soon that\nwill be though as I'm getting close to a release at work.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/413#issuecomment-149996305.\n. This got fixed in\n\ngarrett@Triton{4}% git log src/transports/ipc/bipc.c\ncommit 827d434c3bc4810c626ed5c881e16be3d40ab12f\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Thu Oct 22 16:04:07 2015 -0700\nfixes #469 assertion failure in ipc_shutdown\n. Yeah, looking at this code, it seems like the same problem.  Did you try the proposed PR to see if it solves your problem?  I'm thinking to merge that PR today if possible.\n. That PR was merged.  I'm going to go ahead and close this - -the EFSM error was indeed valid as an indication of a survey timeout.  Now you'll get ETIMEDOUT the first time this occurs.  (If you call again subsequently, you'll get EFSM still.)\n. Nothing in particular at this juncture.  But you can look at mangos and using it you can build TLS or WSS things that sit in front of nanomsg.  (Extending nanomsg to use something like OpenSSL has been considered but that's not a simple effort since OpenSSL doesn't use file descriptors.)\nSent from my iPhone\n\nOn May 21, 2015, at 7:39 PM, Codewyvern notifications@github.com wrote:\nIs something being planned for security?\n\u2014\nReply to this email directly or view it on GitHub.\n. Running behind on analysis of PRs these days.  But I promise to look this week. \n\nSent from my iPhone\n\nOn May 22, 2015, at 3:18 PM, Sam Baxter notifications@github.com wrote:\nAddress issue #411 .\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/nanomsg/nanomsg/pull/416\nCommit Summary\nAdding inproc test that repros crash on rebind\nUpdating inproc close crash test for multiple connected sockets\nAdding state transition for inproc socks to reset state when bound socket closes\nFile Changes\nM src/transports/inproc/binproc.c (3)\nM src/transports/inproc/cinproc.c (22)\nM src/transports/inproc/sinproc.c (3)\nM tests/inproc.c (53)\nPatch Links:\nhttps://github.com/nanomsg/nanomsg/pull/416.patch\nhttps://github.com/nanomsg/nanomsg/pull/416.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. At first blush this looks OK.  To be honest, I'm not that familiar, immediately, with Martin's inproc FSM implementation.  I'd feel better if we could get another reviewer here, but as I said, it looks ok to me.\n. Admittedly what would be enormously helpful here, and is missing from all of this code, are state diagrams, showing each of the various states and transitions.  I'll probably have to draw those out to properly support this code base long term.\n. I've merged this, but I've rebased your code, fixed the commit comments, and addressed some whitespace problems in your code that showed up when I looked at this in the command line.\n\nThe tests passed, so its upstream now.  I'm still not 100% comfortable with the inproc code -- it clearly suffers from some race conditions -- in fact much of libnanomsg feels thread-unsafe to me.  But this is clearly an improvement.\n. This looks very good.  Can you please edit the commit comments to match the bug synopsis though?  Like this:\nfixes #194 ETIMEDOUT not returned when deadline passes in surveyor socket\nThis can be done simply via commit --amend, and resubmitting or updating the PR.  Then I will merge.  (Or if you prefer, I can do the above myself, but you'll have to merge your changes in that case as the git history will differ.)\n. Yes.  Merging shortly.\n. Ah, but this fails the survey test.  I'm going to go ahead and fix that too.\n. Huh.  On Darwin 4 works.  But 3 does not.\n. And, more fragility: \ngarrett@Triton{93}% ./perf/inproc_lat 1024 6\nAssertion failed: (rc == (int)message_size), function main, file ../perf/inproc_lat.c, line 106.\n^CAbort\n. And two works (with the occasional assertion failure), whereas 3 does not.  This feels like a race in inproc.\n. Actually the results are all messed up.  But I know while the code is careful about locking bind/connect, it does not have any such careful provisions around the msgqueue.\n. Its a little worse than that.  The inproc FSMs are not locked at all, and frankly locking them is somewhat tricky as the code for one peer winds up calling the others.  There needs to be shared lock state between both ends of the inproc connection.  This is going to possibly have a detriment to performance.\n. With the fix for #411, this particular hang seems to have been improved.  I think the hangs were related to closes occurring too quickly, but I'm not sure.\nThe assertion failures still sometimes occur, but fixing that is going to require major surgery as inproc is not even remotely thread safe right now.\n. I'm half inclined to replace inproc with an implementation that uses socketpair() or somesuch.\nBut really, it might be better to just make some progress on the libnanomsg rewrite.\n. Again, another inproc thread safety issue.  See #429 \nClosing this a dup.\n. The problem is in the program, not in inproc.\nBasically we should not close the peer socket too soon.. > On May 27, 2015, at 10:08 PM, bsanlang notifications@github.com wrote:\n\nI have modified the survey.c \ndefine SOCKET_ADDRESS \"inproc://test\" to #define SOCKET_ADDRESS \"127.0.0.1:8555\"\nI compiled the survey.c of Tests and run it. But test_recv (respondent1, \"ABC\") can not receive anything.\nHow can I do?\ntcp://127.0.0.1:8555 tcp://127.0.0.1:8555\n\n(note the leading \u201ctcp://\u201c)\n- Garrett\n\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/419.\n. This is TCP slow start.  I'm going to go ahead and close this issue -- the test works as defined with inproc, and probably inproc was chosen just to avoid this slow start problem.   If you're going to change this part of the code (the SOCKET_ADDRESS define) then you need to change that part too. :-)\n. Most of these warnings arise from attempting to use uint8_t  * instead of char .  Somewhere this distinction may be important, but not here.  char * works just as well for an array of arbitrary bytes as does uint8_t .\n. Fixed with:\n\ncommit 732b7ce3316bb4d39eafb7cbb89e717c5dd61240\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Sun May 31 15:06:22 2015 -0700\nfixes #421 warnings emitted by clang for websocket transport\n. I'm not sure I understand the described behavior, or why you think its a leak.  If a message arrives, it consumes memory.  That occurs regardless of whether the message arrives before or after recv.\nIt would be helpful if you could supply a sample program exhibiting the behavior.\n. The automatic cancelation only applies when using cooked mode.  You're using RAW mode messaging, and in that context you're kind of on your own.  That said, if the device is the only thing using raw mode, it should be fine.\nI'm having a little bit difficulty understanding your code -- at some level it would be easier (much) for me if you could demonstrate this with C code -- part of that is to make sure that any leak is not occuring in the Python FFI code.\nLikewise, your assertions are a little confusing for me -- although I know for certain that I wouldn't trust inproc further than I could throw it, particularly with multithreading.  There are clear bugs in that portion of the code -- if you can try replacing inproc with either TCP  or IPC, it would help give me confidence there.\n(I have a plan to fix inproc, but it's going to be a bigger effort, and for now I can't say I really recommend its use.)\n. Can you supply the other side in C as well?\nDoes your assertion about nn_getl() happen in the process running the above C code, or in the Python client?  You're using RAW mode in the other Python code, and if you're Raw mode packets are wrong, that could cause bad behavior.\n. Reading your code, there are several problems.\n```\n    char* msg = msg_buf + prefix_size;\nfor (;;)\n{\n    int recv_r = nn_recv(sock, msg, max_msg_size, 0);\n    assert (recv_r >= 0);\n    usleep((int)(1000.*(1 + 8 * rand() / RAND_MAX)));\n    assert(nn_send(sock, msg_buf, prefix_size + recv_r, 0) == prefix_size + recv_r);\n}\n\n```\nThe msg above actually points at the buffer beyond your reply prefix.  Maybe that's what you meant.\nBut more fundamentally, you're trying to use nn_send and nn_recv with AF_SP_RAW sockets.  The manner in which you've done this means that you are expected to process (parse) the incoming headers for SP, and also include them on send.  So, as your nn_send() points back at the start of the msg_buf, rather than at the msg you received, you've dropped those incoming headers, and the library fails to parse the pipe ID out of the message.\nYou'll need to take care to parse the messages, and preserve headers that you've received and include them in the reply.\nFor REQ/REP messages the headers are an array of 32-bit big endian values, where the array is terminated by a 32-bit value where the high order bit is non-zero.\n. So, this is not a bug in the library.\n. Ah, maybe I misread the code.  Let me re-read.  I guess I need to test this.\n- Garrett\n\nOn Jun 4, 2015, at 7:01 AM, romanoved notifications@github.com wrote:\nI dont understand you. AF_SP sockets, not AF_SP_RAW, used with nn_send/nn_recv functions in workers both on the client side and on the server side. There is only place where raw sockets created for nn_device, but I dont directly deal with them. Moreover, nn_recv returns correct size of request which includes no headers and no other additional information.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/424#issuecomment-108908106.\n. Using your server, and your client, both written in C, I don't see any problems.  (I did have to fix a few typos/errors -- you were missing  and pthreads routines return void * instead of int.) \n\nBut right now no problems reported, no assertion failures.  This on MacOS 10.10.3 (Yosemite).\n. I suspect that the problem is in the python bindings.   Please make sure you can reproduce with just the C client and server.\n. I don't have Linux handy at the moment.  Only Solaris and MacOS. \nHow long does it take to hit the assertion failure?  Can you include a full stack trace?\nAre you using the latest version of libnanomsg or some prepackaged version?\n. Aha. If it is inproc that is probably due to bugs in the inproc transport.  In particular that code is not thread safe. I need to get some time to fix that but it won't be trivial. I may get to it this weekend. \nIn the meantime try to use ipc or TCP. \n. Hmmm.   Is this different than the C code you already sent?   Because that code ran for a while on MacOS without problems. \nSent from my iPhone\n\nOn Jun 5, 2015, at 9:06 AM, romanoved notifications@github.com wrote:\nnn_device doesn't work through ipc or tcp both on linux and temporally available mac os, actually no message received in server's echo_worker.\nWhen i build executable with -g to get core dump then it needs some time to reproduce (on linux) nn_getl assertion.\n[New LWP 28216]\n[New LWP 28217]\n[New LWP 28219]\n[New LWP 28220]\n[New LWP 28218]\n[New LWP 28224]\n[New LWP 28214]\n[New LWP 28212]\n[New LWP 28222]\n[New LWP 28215]\n[New LWP 28221]\n[New LWP 28223]\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nCore was generated by `./nanomsg_client'.\nProgram terminated with signal SIGABRT, Aborted.\n0  0x00007fe47aa8a0d5 in raise () from /lib/x86_64-linux-gnu/libc.so.6\nThread 12 (Thread 0x7fe475e3e700 (LWP 28223)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 8, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 8\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 11 (Thread 0x7fe476e40700 (LWP 28221)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 4, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 4\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 10 (Thread 0x7fe479e46700 (LWP 28215)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 9, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 9\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 9 (Thread 0x7fe47663f700 (LWP 28222)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 5, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 5\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 8 (Thread 0x7fe47b697700 (LWP 28212)):\n0  0x00007fe47ae1b148 in pthread_join () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n1  0x0000000000400cdb in main (argc=1, argv=0x7fffafcff038) at nanomsg_client.c:62\n    n_threads = 10\n    i = 0\n    tid = <error reading variable tid (frame address is not available.)>\n    **PRETTY_FUNCTION** = \"main\"\n\nThread 7 (Thread 0x7fe47a647700 (LWP 28214)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 0, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 0\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 0\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 6 (Thread 0x7fe47563d700 (LWP 28224)):\n0  0x00007fe47ab47a23 in epoll_wait () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b047628 in nn_poller_wait () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x00007fe47b04c14e in nn_worker_routine () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n3  0x00007fe47b04ef70 in nn_thread_main_routine () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n4  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n5  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n6  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 5 (Thread 0x7fe478643700 (LWP 28218)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 2, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 2\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 4 (Thread 0x7fe477641700 (LWP 28220)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 3, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 3\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 3 (Thread 0x7fe477e42700 (LWP 28219)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 7, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 7\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 2 (Thread 0x7fe478e44700 (LWP 28217)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 1, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 1\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 1 (Thread 0x7fe479645700 (LWP 28216)):\n0  0x00007fe47aa8a0d5 in raise () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47aa8d83b in abort () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n2  0x00007fe47b04d6c9 in nn_err_abort () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n3  0x00007fe47b04cac6 in nn_chunk_getptr () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n4  0x00007fe47b04c8fd in nn_chunk_size () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n5  0x00007fe47b04ce1e in nn_chunkref_size () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n6  0x00007fe47b0410ee in nn_recvmsg () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n7  0x00007fe47b0408c1 in nn_recv () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n8  0x0000000000400b49 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:42\n    i = 23\n    poll_s = {fd = 6, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 6\n    **PRETTY_FUNCTION** = \"speaker_worker\"\n\n9  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n10 0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n11 0x0000000000000000 in ?? ()\nNo symbol table info available.\n\u2014\nReply to this email directly or view it on GitHub.\n. I would like exact code that reproduces the problem. \n. > On Jun 5, 2015, at 5:00 PM, romanoved notifications@github.com wrote:\nThe code posted above reproduce problem on linux. If you want its with exact changes for mac os than i can post in only on next work day, ie on monday - now i have no a\u0441\u0441ess to it.\nBut there are all changes (as i remember):\nadd include phtread.h\nchange return type of thread function\nset msg_size to 1000 and to 5001 - reproduced with both\nunsuccessfully try to change inproc to tcp or ipc - nn_device does not work with them\n\nI\u2019ve been using ipc not inproc, just fine on Mac.  What do you mean by nn_device \u201cdoes not work\u201d?\n- Garrett\n\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/424#issuecomment-109486199.\n. Ok, this is starting to bug me.  I'm debugging your code, and nanomsg together.   As I said, the code posted above works fine for me on MacOS.  It doesn't use inproc but only ipc.  I think there is probably something different in your code base.\n\nIs it possible that this is slow start?  I.e. your client has to wait until both the server and the client are connected before sending requests...\nThere are too many things going on in your code to help you debug it myself.\n. I mean your program as posted above, on MacOS (modulo fixing compilation bugs) works correctly - it sends and receives messages.  It fills the screens with newlines.  I actually modified it to emit a \".\" as well, so that I could see traffic.\nThe thing with TCP slow start is that you need to wait a bit before submitting requests.  A few milliseconds before the first time you submit a request ought to be enough time to let the kernel establish the connection.  This is very true for TCP, but likely true for IPC (with shorter times) as well.\nIf you can create a more minimal set of code (the minimum possible that reproduces the problem) then I'll have a change.  As it is, I'm debugging two different programs that I don't fully understand, and four different nanomsg sockets.\nI will point this out though -- the code for nanomsg is open source.  You're welcome to see if you can figure it out.  I realize this is not easy because of the finite state automata in the code, but I really don't have much else I can offer right now.  Many many people are using libnanomsg without difficulty, so I strongly suspect there is a problem in your client code.  Certainly, I use nn_device() as well as libnanomsg in a number of my own projects and I don't see major problems with it (apart from some known breakage in nn_inproc.)\n. REQ/REP should not have undelivered messages, no, we don't see that.  Some times there is deferred delivery (or for other patters, drops) when the connection is still establishing, or under severe back pressure, but light loads shouldn't be a problem.\n. I can confirm that your test reproduces the problem.\nYou have a problem in your test code, but I still see that nn_device() is not functioning as it should.  You're receiving 4 bytes too many.\nNow, with respect to your test, and the other assertions you've seen, I'd venture that your code is a little buggy as it blithely continues to do nn_send() in even when nn_recv() is unavailable (or the poll fails).  This has the effect of filling the queue with messages, except you're repeatedly creating new requests and canceling them.\nBetter to avoid using NN_DONTWAIT, or if you must use it, then poll for sendability as well as receivability, and only do a recv() after send, and don't resend unless you can't receive for a while.\nPersonally, I despise NN_DONTWAIT, and avoid it like the plague.\nI'll do some more testing to see if  I can figure out the nature of the nn_device() bug.\n. The problem is in the REQ/REP raw protocol handling it seems.  When I change to NN_PAIR, it all works properly.  I'm not suggesting you should have to do this, but as a work around, if you don't need REQ/REP semantics, maybe consider it? \n. Actually, that mishandling in nn_device is probably responsible for the nn_getl() assertion failure you've seen as well.\n. I think you're misusing req/rep.  Generally they are intended to be synchronous for a given socket.   You can use poll and dontwait to multiplex work amongst several sockets but you don't want to use multiple sends per socket.  \nThe exception here would be for raw mode sockets.  If you use those you can have multiple requests outstanding but then you are responsible for decoding request headers and for doing any replays.  Basically the raw mode is where you do the work yourself. \nSent from my iPhone\n\nOn Jun 8, 2015, at 3:23 AM, romanoved notifications@github.com wrote:\nYes, it works through PAIR protocol without fails. But this is not applicable for me. Strictly speaking, the following model is required:\nClient sends non-blocking requests to set of sokets (asynchronously realizing actual sending of data) and wait in poll for results. Client must finish all operations before global dynamic timeout exceeded. Next, each of these sockets associated with nn_device and resends request to poll of stateless worker (each has its own type of workers). Without any tricks, worker can works longer than timeout (I tried to model it in posted programs), which follows to described problems.\nFor these reasons, I do not see a way to follow the advice about not to use NN_DONTWAIT (there is no managed time in client which can be spent to wait for slow requsts).\nNow, as a workaround I include information about timeout to request and use separate process which reply to timeouted requests that works good enough in practice. So, are there any advice for using nanomsg for this case? Or is the reason that why I want strange? Generally speaking, I'm going to write my own bicycle, but found nanomsg which description does not contradict with the possibility of required implementation.\n\u2014\nReply to this email directly or view it on GitHub.\n. Cancelation is fine, although I noticed you don't really wait long enough for the thing to get started.   You should probably have a sane timeout before you cancel.  If there is non-trivial work associated with it, the server may wind up doing duplicate work, because it doesn't get your cancelation notice.\n\nCan I request that we move this \"general\" conversation (that part not associated with a specific bug, but more about API questions) to the mailing list or to Gitter?  Using the issue for this makes it hard for folks to see the real meaty part of the issue (the actual bug this issue references) amongst the conversation.\n. So I'm pretty sure there is a leak in xreq as well.\n. Or rather xrep.  See #385  -- could that be what you're hitting?\n. So the nn_device problem is described in #509 \nI'm inclined to close this bug, leaving a reference behind in #509 so that we can go back.  The problem with this report is that it is conflating to many issues which seem completely unrelated to the leak described in the synopsis.\n. Closing as a dup of #509 \nIf @romanoved you feel I've done this incorrectly, or there are problems not described by #509, please file a separate bug. Thanks.\n. I'm closing this -- its a non-issue really.  If you've got conflicting TCP ports during the test run, they're gonna fail.\n. Yeah, I\u2019ll try to get to it tonight..  Sorry not had much time for nanomsg the last couple of weeks.\n- Garrett\n\nOn Jul 11, 2015, at 3:50 PM, Bent Cardan notifications@github.com wrote:\nping @gdamore https://github.com/gdamore, can we add the link for iOS?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/pull/426#issuecomment-120666786.\n. Maybe later this week.  I hope to have some time in the next couple of days to hopefully knock out a few more of the worst issues.  \n\nSent from my iPhone\n\nOn Jul 11, 2015, at 7:37 PM, Bent Cardan notifications@github.com wrote:\nthx @gdamore, cheers \nalso i was planning to ping you and @djc on cutting the beta-6 release soon\n\u2014\nReply to this email directly or view it on GitHub.\n. So, here's the deal.\n1. ipc DOES NOT HAVE LINGER.  That is, SO_LINGER is a TCP socket option only.  This is per the kernel.\n2. ipc queues are shorter, fill faster, and are probably more inclined to backpressure on many systems. \n3. Because nanomsg PAIR is best effort delivery only, if the server's pipe is full, you're going to lose messages.\n\nAnyway, NN_LINGER isn't something we can solve for with IPC, because the kernel doesn't support it.\nUpshot here is you're trying to make IPC do things it cannot do reliably.  If you want to have reliable delivery on top of that, you need to use an acknowledged protocol like req/rep on top.\nI'm closing this.\n. Most likely the problem is that worker code in libnanomsg does indeed fire up a thread, and that thread runs forever by default.  You can, I think, arrange to shut this all down by shutting down libnanomsg with nn_global_term().\n. I need to do some testing with MinGW.  I don't have a good feeling about it at present.  But the stock Windows port seems to work ok.   At least I was able to get it to pass test suites on AppVeyor.\nI'll take a closer look at MinGW later.\n. Question: can you build the test suite with MinGW, and if so, does it pass?  If it does, then it should be fine and the problem may be in assumptions you're making in your application.  If it doesn't, that 's another problem.\n. Btw, inproc has lots and lots of problems in multithreaded environments.  I strongly discourage its use in those environments at present.  \"Fixing\" it is a bigger challenge than you think, but I hope to do so at some point.\n. Old title: MinGW inproc multithreaded -- nn_send always returns EAGAIN\n. I may need to reevaluate this bug.  I think inproc isn't nearly as bad as I first believed, because there is a context for the socket, and only a single worker thread.  The issue is ensuring that the various global entry points acquire this mutex, and that the work calls the functions in the FSM with the same ownership held.  I'm not 100% sure that this is the case -- its really tricky to follow through all the transitions.\nThere's a lot here to do.\n. I'm abandoning the legacy inproc optimization.  I will be redesigning the transport to use socketpair and/or TCP loopback (Windows).  This will mean that inproc isn't as fast as we would like, but it will at least be threadsafe.\nThe nng library contains a safe, optimized, inproc transport, that I recommend if you need such functionality.. Well, there are some unfortunate things if I go down that road -- I had a separate thread which did the connects, but this caused a delay in setting up the connections (much like TCP has btw), which broke a bunch of test programs which assumed connections were immediately available. \nLooking at it more now --  I've got my head around the contexts a bit more, so maybe I can actually make this work.... I do think there is a potential inproc issue remaining, but some of the tests were in the test programs, which are about to be resolved.\nI'm less convinced that we have a reproducible issue  -- but I can see a potential issue with the locking involving multiple sockets and nn_fsm_raiseto().  Its possible that a solution is to use a single monster lock for all contexts.  That would mean potentially less parallelism, but really we have only a single worker thread for the entire nanomsg system, so this isn't that big a deal.\nThe new nng rewrite is far more scalable in this regard.. So the main thread safety issue is in crossing between FSMs for different sockets.  Having said that, we do have a problem with the pushing of the messages from one FSM to another if that first FSM goes away.  I'm concerned that we don't discard a sinproc until the peer's FSM has indicated it is done.. Ok, this all looks good now... I am going to close this issue -- once the inproc tests are fixed (issue reopened), the actual concerns about thread safety are done.. fixed in \n commit e3588bc987f60fa841c153df89a70c7a3f1eb02c\nAuthor: Vinay Sajip vinay_sajip@yahoo.co.uk\nDate:   Wed Jun 24 00:57:39 2015 +0100\nAllowed nn_sleep to be exported on Windows.\n. I'm not sure about on Linux, but epoll was recently added to SmartOS by Joyent.  Unfortunately, at least on illumos, you need to have sys/types.h included to avoid undefined types.  Including on Linux should be harmless given that sys/types.h is there, and is also mandated by POSIX.\nI don't know of any platforms other than Linux and SmartOS, where epoll() is present.  (The SmartOS version emulates the Linux version - frankly using port events on Solaris systems would be far better.)\n. Not yet.  Mangos (an alternative implementation in Go) can do this, but we lack the necessary tracking in libnanomsg.  Adding it is something I'd like to do at some point.\n. That is actually what I have planned to do.  I just have to find time to get it done.\n. (I figure such a project would take something on the order of 1-2 man weeks, for me (Garrett weeks?).  It may take another developer considerably longer if they don't come with my background in mangos and C.\n. The cmsg API would help here.  What do you want to use the source IP address for?  Note that you cannot use it for outbound messaging because nanomsg doesn't let you select the IP address on a per message basis (neither does mangos, btw)\n. This is supported in the nng API now -- if this is functionality you need you should give that a shot.  (You have to use the native nng API, the compatibility API is insufficient to the task.). Already this exists in nng in a much much easier to use API. It is really\nunlikely that I will backport this to nanomsg. nng is wire compatible. I\nneed to focus on stabilizing that so it can used in production.\nOn Fri, Oct 13, 2017 at 9:27 PM skyformat99 notifications@github.com\nwrote:\n\nvery very +n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/432#issuecomment-336608970,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfYxcpLCHQY0qMZABMnfDoK7Qjjzlks5ssDgggaJpZM4FaOv-\n.\n. I intend to close this will-not-fix for nanomsg.. Closing this will-not-fix.  Please consider using nng if you need this functionality.. Does QNX have IPC in the form of UNIX domain sockets?  I'd be pretty unsurprised to learn that it doesn't work like you'd think it should...\n. Well, the claim from QNX.com is that it should work.\n\nSadly, QNX isn't free, so I'm not sure that I'm prepared to invest a lot of effort trying to fix any problems that might occur on that platform.\n. So is the ipc problem solved for you then or still outstanding ?\nSent from my iPhone\n\nOn Oct 21, 2015, at 8:19 PM, Min Yang Jung notifications@github.com wrote:\nQNX has free 30-day free evaluation program, although I'm not sure if nanomsg has any plan to officially support QNX. I'm actively using nanomsg on QNX and it has been working great. My use case is rather simple (mostly \"req-res\"-based data exchange), though. Will report later if any other issue comes up.\np.s. I am really enjoying using nanomsg and love its lightweight, simple, and structured design. Thanks a lot for developing and releasing such a nice package!\n\u2014\nReply to this email directly or view it on GitHub.\n. Leave the issue open.  It's real on that platform and QNX purports to be a POSIX platform.   There is clearly a problem though. \n\nOne thought.   Perhaps the problem is the specific path chosen?\nSent from my iPhone\n\nOn Oct 22, 2015, at 7:45 AM, Min Yang Jung notifications@github.com wrote:\n@gdamore I'm afraid that the IPC problem still exists with the version that I tested, AFAIK.\n@wirebirdlabs Just as a clarification, I reported the issue purely based on my personal interests wishing nanomsg be more complete in terms of cross-platform support, because I like nanomsg. Especially, its lightweight, simple, but efficiency and scalability-oriented design is what I really like.\nI understand your concerns from the developer resource's perspective and you made valid points. However, I don't think I can agree with your point where the issue is more a QNX concern than a nanomsg concern. With the same logic, would you think it would be a MS/Windows concern if the same issue occurred on Windows, which is a commercial, mainstream, and proprietary platform?\nIt looks to me that nanomsg tries to support multi-platforms and I just wanted to bring the issue up to you. Again, this issue started entirely based on my personal interests. As I said in my previous comment, my use case is quite simple and I do not use any feature relying on IPC -- no problem with me. Whether or not nanomsg has a plan to support QNX is totally up to nanomsg -- no question. Also, it's totally up to you if this should be closed or not. I'm just trying to be helpful. On my spare time, I might try to look more into this issue if this issue remains open later.\n\u2014\nReply to this email directly or view it on GitHub.\n. Btw, are @minyang are you using IPC at all on QNX? Or just TCP.  I'd just like to get a sense about how broken Unix domain socket support on QNX things really are.\n. Just for the record\u2026 if we eliminate \u201cclosed source/commercial operating\nsystems\u201d from the supported list, or we don\u2019t offer workarounds for some\nwith quirks (MacOS/Darwin!), then libnanomsg would be far less\nuseful/functional as a cross platform product.\n\nWhile I don\u2019t want to invest cycles myself in fixing QNX, since I have\nneither the time nor the inclination to figure out how QNX is different, I\ndo think someone could, maybe should, address this.   Sure if QNX is\nbuggy somehow we should report that upstream.  But it wouldn\u2019t be the first\nplatform specific bug we\u2019ve had to workaround.  (I just yesterday\nintroduced a fix caused in part by Darwin returning an undocumented errno\nin response to sendmsg(), for example.)\nI\u2019d love to have someone who cares about QNX step forward and offer\nmodest fixes to the problems therein.\nOn Thu, Oct 22, 2015 at 9:42 AM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nI don't think I can agree with your point where the issue is more a QNX\nconcern than a nanomsg concern. With the same logic, would you think it\nwould be a MS/Windows concern if the same issue occurred on Windows, which\nis a commercial, mainstream, and proprietary platform?\nIf it appears to be a problem, or even just weirdness, with the vendor's\ncode, then it's good for the vendor to be aware and try to resolve the\nissue there. Now, if the vendor does not appear to be at fault, yet it's\nexposing some flaw in the library -- it's good for the library maintainers\nto have responsibility. Based on previous conversation, it felt this case\nfell into the former group.\nThat said, I appreciate the rest of your response. it's thoughtful and\nkind, and would agree to keep this case open for now, especially in the\nspirit of making nanomsg more robust. :-)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/433#issuecomment-150283872.\n. Ok, cool, this is good news.  Kind of a pity that you have to use /tmp\nexplicitly.   Was your build directory on a  \u201clocal\u201d filesystem, or was it\non some kind of remote, or otherwise special, filesystem where IPC might\nnot be expected to work?\n\nOn Fri, Oct 23, 2015 at 7:11 AM, Min Yang Jung notifications@github.com\nwrote:\n\nOK, I looked into a bit more yesterday. Here are a bit of updates:\n- I got ipc_shutdown and separation working after updating IPC address\n  from ipc://test.ipc to ipc:///tmp/test.ipc (explicit use of /tmp).\n  Yes, @gdamore https://github.com/gdamore, your previous guess was\n  correct!\n- IPC itself seems to work -- using a simple tutorial example, I was\n  able to exchange messages via IPC protocol. What was failing was the\n  ipc unit test. Inipc, the first part -- send/recv of 40 byte messages\n  -- worked fine, but the following tests failed (e.g., sending large\n  payloads (10000 bytes) one time and sending small payloads (3 bytes)). I\n  checked out a log file with my own debug messages, and it looks like\n  something crashed or so (only partial messages were printed out). From make\n  check's point of view, this failed test looked as if it hanged.\nI was too tired yesterday to narrow down which line of code cause the\nissue. Hopefully, I'll have more energy tonight or this weekend.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/433#issuecomment-150583795.\n. Ideally they\u2019d timeout and move on.  Sadly, this isn\u2019t always done \u2014 some\njust hang.  I\u2019ve changed with Windows ctest configuration to fail hard if a\ntest takes over 30 sec.  I should look at doing the same for test_driver.c.\n\nYour home directory was on local disk, right?  Strange that QNX would not\nhonor UNIX domain sockets there\u2026. maybe a platform restriction?\nOn Fri, Oct 23, 2015 at 10:09 AM, Min Yang Jung notifications@github.com\nwrote:\n\nNo, my build directory was just a local folder under my home, and I did\nall my testing on the same host.\nOne question, is it a normal or expected behavior where make check hangs\nif one of unit tests crashes (e.g., abort, exit)? I see two different\nbehaviors: a) hangs (in case of ipc) and b) graceful handling, i.e.,\ntests failed with coredump, moving on to the next test, and failure reports.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/433#issuecomment-150635669.\n. This test was a long time ago, and nanomsg has changed hugely to resolve a lot of problems and races since filed.  Submitter, if you could test against git head, or the 0.9 release (which should be released this week), it would really help.\n. Any news on this?  We have long ago released 1.0.0... absent any concrete info one way or the other, I'll probably close this.. Any news?. I haven\u2019t made any specific changes to support QNX, no.  But without more\ninformation or assistance, there isn\u2019t much else I can do.\n\nOn Fri, Mar 10, 2017 at 6:03 AM, Min Yang Jung notifications@github.com\nwrote:\n\nLast time I ran master on QNX (a couple months ago), QNX didn't seem to be\nsupported by nanomsg. I saw NN_HAVE_QNX is defined, but it wasn't actually\nused/implemented at that time.\nWith a bit of quick hacks on src and cmake (atomic add, semaphore,\nqnx-recognition, etc), I was able to compile the release 1.0.0 on QNX, but\ncouldn\u2019t get all the test apps working. Some worked and some others didn\u2019t\n-- crashed.\nI couldn't follow up recent changes, but am wondering if there are some\nrecent changes on this end?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/433#issuecomment-285676457,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDffzsJgFV-gQpmqGTNmvkoD7Nc2igks5rkVhHgaJpZM4Fc4GF\n.\n. Closing due to no response from submitter.. When I need to know about client arrival and departure, I use application specific messages for arrival, and some kind of probe test message for departure.  With mangos you can also monitor for PortEvents().  Unfortunately libnanomsg has nothing like this at present.\n\nThe idea mostly is that applications should not worry about connected status.  If you\u2019re going to manage that explicitly, it starts to look like nanomsg is probably not giving much benefit over plain old sockets.\n- Garrett\n\nOn Jul 25, 2015, at 11:35 AM, Wirebird Labs LLC notifications@github.com wrote:\nWhat I couldn't figure out is a generic mechanism to inform an application layer that there is new connection/disconnection happened\nOut of curiosity, what logic would this be triggering at the app layer? Would it be acceptable to make hello and goodbye part of your app-layer protocol?\nFor the topologies you mention (PUB/SUB and REQ/REP), it might be best to consider the app-layer unaware of the connect/disconnect events themselves, since nanomsg intentionally tries to abstract this.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/443#issuecomment-124870349.\n. Btw, will one of you be submitting a pull request for this?\n\n- Garrett\n\nOn Jul 25, 2015, at 4:16 AM, Wirebird Labs LLC notifications@github.com wrote:\nExcellent analysis; thank you, @zakharov https://github.com/zakharov!\nYour fixes seem rational solutions to an acute problem.\nBack when the Close Handshake was first being discussed https://www.freelists.org/post/nanomsg/ws-transport,1, I was a proponent of formalizing a Close Handshake for nanomsg generally (i.e., for all transports, not just WebSocket).\nIf I recall correctly, the reason I decided to propagate the close handshake from the peer up to the application layer is because we were defining the close handshake as an app-layer concern, not transport or socket layer concern -- yet this clearly a problem when a PUB recv's a msg!\nMy understanding is the original nanomsg spirit set forth by @sustrik https://github.com/sustrik was to address the need for persistent, long-term and connections (the same spirit is why binding to an ephemeral port, although technically not so much a challenging feature to add, was specifically avoided, for good reasoning when applied to persistent service endpoints). For this reason, a Close Handshake perhaps didn't make sense to pursue. Yet I've found significant value in nanomsg connecting \"short-lived, ad hoc\" endpoints (e.g., actor-oriented development for embedded control and monitoring systems), where a Close Handshake would be helpful, and perhaps others are finding enough use here to gain traction.\nPerhaps @gdamore https://github.com/gdamore can help further define this closing handshake protocol, perhaps in terms of how mangos accomplishes this https://github.com/nanomsg/nanomsg/issues/403#issuecomment-105994787?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/issues/443#issuecomment-124835335.\n. Original assertion was:\nsrc/protocols/pubsub/xpub.c:138\n\nI'm editing this so that the synopsis fits on one line in commit. ;)\n. No it's the way Appveyor works.  It ties to a personal GitHub account rather than to a repo or to an org. \nThat said I intend to create an Appveyor YAML file from my manual config and commit so others can start if they want to. \nSent from my iPhone\n\nOn Jul 25, 2015, at 5:10 AM, Wirebird Labs LLC notifications@github.com wrote:\nAppVeyor build, but it looks like it's not public yet\nAha, simply submitting PR kicked off the build here: https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.33\nIs the current link a sandbox before moving to a nanomsg domain, or do you prefer to keep that link for now?\n\u2014\nReply to this email directly or view it on GitHub.\n. I believe the public AppVeyor build status is available, just using my name.  I was going to go ahead and put that in the badge, along with the Travis badge, at some point in the near future.\n\n- Garrett\n\nOn Jul 25, 2015, at 11:23 AM, Wirebird Labs LLC notifications@github.com wrote:\nties to a personal GitHub account rather than to a repo or to an org\nIndeed. Looks like one way to workaround this would be to register the name \"nanomsg\" as a new AppVeyor account (as per their official support: http://help.appveyor.com/discussions/questions/1154-appveyor-account-for-github-organizations http://help.appveyor.com/discussions/questions/1154-appveyor-account-for-github-organizations), then add collaborators and/or team access.\nothers can start if they want to\nSince it's already configured to run on a PR, that's suitable without opening permissions any further. Probably best we not muck up each other's (or the official) build history with sandbox dev; it's easy enough to set up your own if you're serious.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/pull/444#issuecomment-124869206.\n. I looked at libuv.  I'm not a fan of event loop programming and an unlikely to take that approach.  That shouldn't stop anyone else who wants to have a go though. \n\nSent from my iPhone\n\nOn Aug 7, 2015, at 6:22 PM, Bent Cardan notifications@github.com wrote:\n+1\nlibuv's eventloop, or maybe ae\n\u2014\nReply to this email directly or view it on GitHub.\n. Just to expand on my last reply.  I think event loops lead you down to state machine hell.  I implemented mangos using simpler imperative style programming and I'm happy with the end result.  So I'm more likely to try to copy that design. \n\nSent from my iPhone\n\nOn Aug 7, 2015, at 6:22 PM, Bent Cardan notifications@github.com wrote:\n+1\nlibuv's eventloop, or maybe ae\n\u2014\nReply to this email directly or view it on GitHub.\n. We won't be using libuv unless someone else wants to do the work.  That would create different C++ requirements.  I'm also not keen to create another event driven monstrosity.  Current architecture uses event loops and finite state machines to drive everything, and has led to the current mess.\n\nA refactor, should I undertake one, will change a number of constraints.  This may make it a poor drop-in replacement (or not a drop-in at all) for libnanomsg.  The constraints I'd change are:\na) Eliminate POSIX API compatibility.  The code is vastly more complicated because of attempts to make sockets select()'able.  And even integer descriptors add complexity.  Easier to just pass around state pointers.  But more to the point, not having to create a separate poll() loop ,or go through the ridiculous contortions done on Windows to make WSAselect() work.   (Many of the windows bugs derive from this goal.)\nb) Relax portability requirement somewhat.  In particular, I'm likely to require modern threading primitives.  Creating tasks, and running low level I/O in blocking modes is frankly far safer, and ultimately more portable.  And gets us out of FSM hell.\nc) Narrower internal APIs, with less attempt to \"share implementation\" between transports.  Especially Windows and POSIX shouldn't try to share code here -- the hodge podge of .inc files is bad design.  Better to design narrow transport provider APIs, and let those transport providers implement to them directly.\nMuch of this design will look like mangos.  HOWEVER, I will not plan on using libmill.  I feel libmill is going the wrong way -- still trying to \"fake out\" concurrency using hackery, instead of just relying on reasonable platform threading APIs.\nThis approach may make whatever the new refactor is called far less suitable for use in embedded environments; and it may make it harder to embed in language run times (I'm not sure about that).  Threading and fork() are particularly challenging to deal with in combination.  But I think getting that right will still be far easier than what we've got now.\n. I'm closing this for now--- libnng is happening, and is basically a rewrite from scratch.  I am using threads, but the platform layer is sufficiently flexible that if someone wants to use libmill or libuv or some other framework, they can do that.  They just need to be able to express \"threads\" logically (which could be coroutines) and some other typical primitives (mutexes, condvars, related network operations, etc.). @wirebirdlabs you have reviewed this as well, right?  \n@zakharov can you rebase this down to a single commit please?  (Please address the one whitespace nit I found while at it.)  Also, the preferred way is to have a bug report and reference it as a single line commit message of the form \"fixes # \"\nThanks.\n. A new PR was submitted in lieu of this one (#448) closing.\n. This was rebased and commit comment edited, but otherwise integrated as 80ae441bcf2207a46cb784b40e9a40f26c7fff4f\n. I\u2019m uncomfortable proceeding with this pull request given that the tests all failed, and failed in the same place.\nI\u2019d like someone more familiar with Windows to have a look at it.\n- Garrett\n\nOn Aug 12, 2015, at 7:19 AM, Wirebird Labs LLC notifications@github.com wrote:\nIt may be unrelated to this pull request, but this commit triggered the tcp_shutdown test to fail on all three Windows builds: https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.40 https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.40\nHere is a search link that shows all Issues that mention the keyword tcp_shutdown: https://github.com/nanomsg/nanomsg/search?q=tcp_shutdown&type=Issues https://github.com/nanomsg/nanomsg/search?q=tcp_shutdown&type=Issues\n\u2014\nReply to this email directly or view it on GitHub https://github.com/nanomsg/nanomsg/pull/449#issuecomment-130319451.\n. Thanks for working on this. \n\nSent from my iPhone\n\nOn Aug 12, 2015, at 7:50 PM, qbradley notifications@github.com wrote:\nI ran tcp_shutdown.exe 10 times. It passed 5 times and failed 5 times as follows:\nsrc=0 type=33988\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (C:\\Users\\qbrad_000\\dev\\nanomsg\\src\\core\\sock.c:830)\nThen I reverted my changes and ran tcp_shutdown.exe 10 times. It passed 7 times and failed 3 with the same error.\nMore than likely this is an existing intermittent failure. Just in case my change increases the likelihood of its occurrence I'll try and dig a little deeper in the tcp_shutdown.exe failure.\n\u2014\nReply to this email directly or view it on GitHub.\n. tcp_shutdown tests still failing, so I don't think your fix addresses it.\n\nIf I find some time in the next several days/week, I'll see if  I can noodle this out.  Typically in other situations like this I've used a flag, protected by a lock, to indicate when a connection or resource was being torn down.\nThe internal architecture of libnanomsg makes this a little harder right now.  Sadly.\n. So, this PR, only the change for efd_win.inc is appropriate.  I'm uncomfortable with the other changes, and I think we may have addressed those problems another way.\n. I've taken some of your code, and made it better.  I used a non-INFINITY timeout for the mutex, because frankly its better to eventually give up and report an error to the caller than to wait forever.\nThis was integrated with several other windows specific fixes in ab699df74978645ebe5bb53f0b602ba4bf32ed4b\n. This looks like a dup of #446 , closing.\n. Yep.  Inproc is broken and not thread safe.  Don't use it.  (On mangos it doesn't have these problems.)\nSent from my iPhone\n\nOn Oct 22, 2015, at 6:54 PM, George Zhao notifications@github.com wrote:\nSorry, this bug not fixed,\ninproc_thr.exe 100 100 will not continue sometimes.\n\u2014\nReply to this email directly or view it on GitHub.\n. I've never seen this error.  What version are you using?  Did you rebuild with autotools or just use the tarball?\n\nSent from my iPhone\n\nOn Aug 12, 2015, at 11:15 AM, kpedroza notifications@github.com wrote:\nHello\nThe error: .in'ig.status: error: cannot find input file: ` is shown when running ./configure\nAny ideas?\nOS: Ubuntu 12.04 LTS\nFull log:\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for a thread-safe mkdir -p... /bin/mkdir -p\nchecking for gawk... no\nchecking for mawk... mawk\nchecking whether make sets $(MAKE)... yes\nchecking how to create a ustar tar archive... gnutar\nchecking whether make supports nested variables... yes\nchecking build system type... x86_64-unknown-linux-gnu\nchecking host system type... x86_64-unknown-linux-gnu\nchecking for a sed that does not truncate output... /bin/sed\nchecking for gawk... (cached) mawk\nconfigure: nanomsg package version: 0.6-beta-4-g9b77859-dirty\nconfigure: nanomsg ABI version: 2.2.2\nchecking for style of include used by make... GNU\nchecking for gcc... gcc\nchecking whether the C compiler works... yes\nchecking for C compiler default output file name... a.out\nchecking for suffix of executables... \nchecking whether we are cross compiling... no\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to accept ISO C89... none needed\nchecking dependency style of gcc... gcc3\nchecking for gcc option to accept ISO C99... -std=gnu99\nchecking whether gcc -std=gnu99 and cc understand -c and -o together... yes\nchecking whether we are using ICC compiler... no\nchecking whether we are using Sun Studio compiler... no\nchecking whether we are using clang compiler... no\nchecking whether we are using HP aCC compiler... no\nchecking whether ln -s works... yes\nchecking whether ln -s works... yes\nchecking if compiler needs -Werror to reject unknown flags... no\nchecking for the pthreads library -lpthreads... no\nchecking whether pthreads work without any flags... no\nchecking whether pthreads work with -Kthread... no\nchecking whether pthreads work with -kthread... no\nchecking for the pthreads library -llthread... no\nchecking whether pthreads work with -pthread... yes\nchecking for joinable pthread attribute... PTHREAD_CREATE_JOINABLE\nchecking if more special flags are required for pthreads... no\nchecking for PTHREAD_PRIO_INHERIT... no\nchecking how to run the C preprocessor... gcc -std=gnu99 -E\nchecking for grep that handles long lines and -e... /bin/grep\nchecking for egrep... /bin/grep -E\nchecking for ANSI C header files... yes\nchecking for sys/types.h... yes\nchecking for sys/stat.h... yes\nchecking for stdlib.h... yes\nchecking for string.h... yes\nchecking for memory.h... yes\nchecking for strings.h... yes\nchecking for inttypes.h... yes\nchecking for stdint.h... yes\nchecking for unistd.h... yes\nchecking netinet/in.h usability... yes\nchecking netinet/in.h presence... yes\nchecking for netinet/in.h... yes\nchecking netdb.h usability... yes\nchecking netdb.h presence... yes\nchecking for netdb.h... yes\nchecking arpa/inet.h usability... yes\nchecking arpa/inet.h presence... yes\nchecking for arpa/inet.h... yes\nchecking for unistd.h... (cached) yes\nchecking sys/socket.h usability... yes\nchecking sys/socket.h presence... yes\nchecking for sys/socket.h... yes\nchecking sys/ioctl.h usability... yes\nchecking sys/ioctl.h presence... yes\nchecking for sys/ioctl.h... yes\nchecking for stdint.h... (cached) yes\nchecking for eventfd... yes\nchecking for pipe... yes\nchecking for pipe2... yes\nchecking for gethrtime... no\nchecking for CLOCK_MONOTONIC... yes\nchecking for clock_gettime in -lrt... yes\nchecking for clock_gettime... yes\nchecking for poll... yes\nchecking for epoll_create... yes\nchecking for getifaddrs... yes\nchecking for accept4... yes\nchecking for library containing getaddrinfo_a... -lanl\nchecking for library containing socketpair... none required\nchecking for library containing sem_wait... none required\nchecking for msghdr.msg_control... yes\nchecking how to print strings... printf\nchecking for a sed that does not truncate output... (cached) /bin/sed\nchecking for fgrep... /bin/grep -F\nchecking for ld used by gcc -std=gnu99... /usr/bin/ld\nchecking if the linker (/usr/bin/ld) is GNU ld... yes\nchecking for BSD- or MS-compatible name lister (nm)... /usr/bin/nm -B\nchecking the name lister (/usr/bin/nm -B) interface... BSD nm\nchecking the maximum length of command line arguments... 1572864\nchecking whether the shell understands some XSI constructs... yes\nchecking whether the shell understands \"+=\"... yes\nchecking how to convert x86_64-unknown-linux-gnu file names to x86_64-unknown-linux-gnu format... func_convert_file_noop\nchecking how to convert x86_64-unknown-linux-gnu file names to toolchain format... func_convert_file_noop\nchecking for /usr/bin/ld option to reload object files... -r\nchecking for objdump... objdump\nchecking how to recognize dependent libraries... pass_all\nchecking for dlltool... no\nchecking how to associate runtime and link libraries... printf %s\\n\nchecking for ar... ar\nchecking for archiver @FILE support... @\nchecking for strip... strip\nchecking for ranlib... ranlib\nchecking command to parse /usr/bin/nm -B output from gcc -std=gnu99 object... ok\nchecking for sysroot... no\nchecking for mt... mt\nchecking if mt is a manifest tool... no\nchecking for dlfcn.h... yes\nchecking for objdir... .libs\nchecking if gcc -std=gnu99 supports -fno-rtti -fno-exceptions... no\nchecking for gcc -std=gnu99 option to produce PIC... -fPIC -DPIC\nchecking if gcc -std=gnu99 PIC flag -fPIC -DPIC works... yes\nchecking if gcc -std=gnu99 static flag -static works... yes\nchecking if gcc -std=gnu99 supports -c -o file.o... yes\nchecking if gcc -std=gnu99 supports -c -o file.o... (cached) yes\nchecking whether the gcc -std=gnu99 linker (/usr/bin/ld -m elf_x86_64) supports shared libraries... yes\nchecking whether -lc should be explicitly linked in... no\nchecking dynamic linker characteristics... GNU/Linux ld.so\nchecking how to hardcode library paths into programs... immediate\nchecking whether stripping libraries is possible... yes\nchecking if libtool supports shared libraries... yes\nchecking whether to build shared libraries... yes\nchecking whether to build static libraries... yes\nchecking for bash... /bin/bash\nchecking if dolt supports this host... yes, replacing libtool\nconfigure: creating ./config.status\n.in'ig.status: error: cannot find input file: `\nThank you.\n\u2014\nReply to this email directly or view it on GitHub.\n. So I have no idea, but I'm inclined to close this if no reply from the submitter.   Its been over a month.\n. Closing due to insufficient info to reproduce.\n. does this problem only occur on Windows?\n\nI do see inconsistent failures like this in the Unix check (running on darwin):\n../test-driver: line 107: 65730 Abort trap: 6           \"$@\" > $log_file 2>&1\nFAIL: tests/tcp_shutdown\n. Btw, there are a plethora of little issues around shutdown.  I think I\u2019ve\nmade some commits that should help substantially here.  However, I don\u2019t\nknow that we\u2019ve nailed them yet.\nOn Wed, Oct 21, 2015 at 11:50 AM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\ndoes this problem only occur on Windows?\nIn my testing, this is definitely where it's most prevalent.\nAt one point, in a debug-and-dev session I thought I had narrowed it down\nto a difference in the two platforms in efd.c\nHere's the link:\nwirebirdlabs@679165e\nhttps://github.com/wirebirdlabs/featherweight-nanomsg/commit/679165e0a559e63c1724d5068b1e403b5eddb66f\nI don't even recall if this helped at all (and/or pushed the failure point\nto another location), but at worst I don't think it was headed in the wrong\ndirection.\nAdditionally, here's a link to the total set of changes I've done toward\nTCP Shutdown issues -- again, these changes have not necessarily helped\nmuch (else, they'd have been PR'd), but it's at least one data point trying\nto help characterize where we can put effort into solving this issue:\nmaster...wirebirdlabs:master\nhttps://github.com/nanomsg/nanomsg/compare/master...wirebirdlabs:master\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/452#issuecomment-149991283.\n. Clearly your changes are windows only as well.  Sadly.   Really the way\nthis was handled in nanomsg (portability layer bits mixed in with\nWindows/POSIX bits) is quite unfortunate.\n\nIt would have been better to define a relatively narrow platform /\ntransport API, and then build two entirely different implementations to\nthat (internal) API, instead of trying to band aid this crap in like this.\nIf I ever do the refactoring bit, that\u2019s the approach I\u2019ll do \u2014 Windows\nstuff and POSIX stuff shall not really share the same files because they\nare just too bizarrely different.\nOn Wed, Oct 21, 2015 at 1:26 PM, Garrett D'Amore garrett@damore.org wrote:\n\nBtw, there are a plethora of little issues around shutdown.  I think I\u2019ve\nmade some commits that should help substantially here.  However, I don\u2019t\nknow that we\u2019ve nailed them yet.\nOn Wed, Oct 21, 2015 at 11:50 AM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\ndoes this problem only occur on Windows?\nIn my testing, this is definitely where it's most prevalent.\nAt one point, in a debug-and-dev session I thought I had narrowed it down\nto a difference in the two platforms in efd.c\nHere's the link:\nwirebirdlabs@679165e\nhttps://github.com/wirebirdlabs/featherweight-nanomsg/commit/679165e0a559e63c1724d5068b1e403b5eddb66f\nI don't even recall if this helped at all (and/or pushed the failure\npoint to another location), but at worst I don't think it was headed in the\nwrong direction.\nAdditionally, here's a link to the total set of changes I've done toward\nTCP Shutdown issues -- again, these changes have not necessarily helped\nmuch (else, they'd have been PR'd), but it's at least one data point trying\nto help characterize where we can put effort into solving this issue:\nmaster...wirebirdlabs:master\nhttps://github.com/nanomsg/nanomsg/compare/master...wirebirdlabs:master\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/452#issuecomment-149991283.\n. I am thinking this looks like it might actually be #446 -- have you tried the fix proposed there?  I'm inclined to make the changes, but appveyor is taking forever.\n. I've made a bunch of changes in 2163280c83be0ff6977726e23bb2171113b58f44 and I think you won't see this problem anymore.  It doesn't hang for me anymore at any rate.  Please check, and  reopen this if you find it that its still a problem.\n. Please separate these into two PRs; the changes are not related.\n. I'm closing this now. The conflicts need to be resolved, and this needs to be a single PR.\n. On paper looks good.  I need to check to see if there are locking considerations here.  I don't think there are, but give me some time for analysis please.\n. fixed in 968e90b685bcebd42bd05cf52c3f4e43cf83c8ba\n. Yes, I will do so shortly.\n\n\nOn Mon, Oct 12, 2015 at 10:36 AM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\nCan we get this one merged?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/456#issuecomment-147470982.\n. The git repo has changed since this was posted... I will apply the diff by hand.\n. Fixed in #474 :  (I edited the commit comments and made a bug report).\n\ncommit c98cb0f4313002d9ac25654197984a865a91d8ba\nAuthor: yan97ao magictao@gmail.com\nDate:   Sun Aug 16 00:57:41 2015 +0800\nfixes #474 typo in msg.h comments\n. Yeah, that's bogus.  More than one gets returned in configurations with IPv6 and IPv4, or when the site admin tries to set up multiple addresses for load balancing and failover.\nIts pretty lame, this needs some thought. \nTo be honest, I HATE that libnanomsg does its own DNS lookups.   In my own applications I always resolve names outside of the library, so that I have control over when the resolution happens, and dealing with things like policy, multiple port binding, failover, etc.\n. Can we just remove the assertion?\n. I'm going to remove the assert.  That will let this code move forward with minimum pain and suffering.\nFolks that expect to use DNS to achieve round robin or some such with nanomsg - it isn't going to work. As with (I suspect! the vast) majority of apps, we're going to just take the first name we get and move forward with that.\nTrying to do otherwise would require tying DNS a bit more tightly into the connection/failover logic.  This is wrong on so many levels, especially for nanomsg. \nAgain, I strongly recommend using IPs with nanomsg, or at least ensuring that a single DNS record is returned and valid.\n. A bug should be filed for this, and the commit comment updated to read \"fixes # \"\nOtherwise it looks good.  Have you verified this via testing?\n. I reworded the commit comments somewhat:\ncommit 4f44d755d8cac078940a3f2d34c811e5a3dbb515\nAuthor: bryan newbold bnewbold@twinleaf.com\nDate:   Tue Sep 1 20:32:10 2015 -0700\nfixes #460 actually update status in nn_recvmsg\n. Mostly looks good.  Admittedly I'd like to see the commits collapsed into a single commit, with a comment of style matching the other most recent comments (\"fixes #459 New NN_RCVMAXSIZE socket option\")\n. I still think close handshake is not necessary and doesn't really solve anything.  It helps one remote end understand that a connection was rejected rather than silently dropped, but serves little purpose other than that -- since indeed there is no guarantee that the close itself will be delivered.\n(This then gets into a need to replicate the TCP FIN close mechanism, which is ... ugly.)\n. So can you please rebase these into a single commit with the commit message requested?  Once done, I can merge it into master.\n. The discussion in the PR made me think that the problem wasn't completely\nresolved.\nThat said, if there is just one bug fix, and that address the problem, then\nplease submit a separate minimal PR.  I don't like PRs with multiple bug\nfixes in them because I can't tell what is fixed by what easily.\nOn Mon, Sep 21, 2015 at 10:30 AM, Sam Baxter notifications@github.com\nwrote:\n\nYea, that could be it. It would be worth splitting up so that the bugfix\nand feature can get merged if that's all it takes, this seems like a pretty\nbad crash to have hanging around when we have a fix just sitting there. Is\nthat something I can take care of (even though they aren't my commits) or\nsomething a maintainer (@gdamore?) needs to do?\nOn Mon, Sep 21, 2015 at 1:09 PM, Wirebird Labs LLC <\nnotifications@github.com\n\nwrote:\nFor whatever reason, it is yet to be merged\nPerhaps since the PR contains both a bugfix and a new feature? Both seem\nsolid, quality work, but since coupled together makes it a bit harder for\nmaintainers to evaluate/merge individually.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/463#issuecomment-142044934.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/463#issuecomment-142050359.\n. PR# 468 was integrated; that doesn't necessarily completely solve all the TCP issues, but it helps with this one.  I'll open another issue for the other problem I'm seeing.\n. I think the --enable-doc should only be required when formatting man pages after they have been changed.  Most users needn't worry about this, which spares them the effort of having xmlto or other tooling.  So I'd like to have this documented separately from the primary user-facing installation document.\n. I actually do think we ought to commit the formatted pages. \n\nSent from my iPhone\n\nOn Sep 10, 2015, at 6:07 PM, bnewbold notifications@github.com wrote:\nI agree it would be nice to not need dependencies installed when building, but I started with the user-facing install docs (README) and found it confusing and counter-intuitive that man pages were not installed when installing from source following the instructions. If they were somehow installed without reformatting then perhaps we could leave the mention out of the README.\nShould we commit the formatted manpages in the repo (like with txt/xml under ./rfc/) so they can still be installed? That doesn't seem like a great option.\n\u2014\nReply to this email directly or view it on GitHub.\n. The more I think about this, the more I think the problem is a disconnect between developer/maintainer mode, and end-user mode.\n\nThe documentation is provided as .txt formatted pages, and they are indeed committed to the git history (just checked).\nNow the reality is that it should never be necessary for an end-user to run autogen.sh.  This is necessary when checking out source from github, but really most folks should be building from the released tarballs rather than out of git.  (Except that these days, building from git is probably more common.)\nThis is just another case where automake/autoconf fall down badly.  I need to revive my work towards a cmake based build for all platforms.\n. fixed in aff10b4d11f8aa8edcef4cb1d87a13eb8ed2e18c\n. Exactly -- if you are the only owner, then nobody else can get it.\nOn Sat, Sep 19, 2015 at 9:17 AM, sustrik notifications@github.com wrote:\n\nI don't think it needs to be atomic. If the reference count have already\ndropped to 1, there's nobody else out there who could increase it.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/466#issuecomment-141684515.\n. Concur.  The mode should be a socket option.  Its a shame that we have to\ngo thru these kind of hoops for JavaScript -- binary would be easier.  But\nJS can't deal with real binary.\n\nOn Mon, Sep 21, 2015 at 11:44 AM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\ntl;dr -- refactor away the original issue raised by @djc\nhttps://github.com/djc here in favor of per-socket rather than\nper-message set/get of RFC 6455 message type.\nFurther thoughts:\nI consider this an as-yet unresolved issue brought up during the review of\nthe WebSocket transport feature addition -- whether to expose\nWebSocket-specific message types defined in RFC6455 over the exported\ninterface of libnanomsg, either thru the cmsg functions and/or thru\nwebsocket specific convenience wrappers.\nRelevant code:\nhttps://github.com/nanomsg/nanomsg/blob/master/src/ws.h#L42-L60\nThe main issue, if I recall, is the classification of such message type as\nbeing either \"transport level\" or \"application level\" concern. A compelling\nargument was given that WebSocket attempted to wrap L6 concerns into its L4\nprotocol, and so the \"bug\" lies within the design of RFC 6455. Any way this\nis argued -- it's still just an unresolved issue for libnanomsg.\nI have a feeling that the reason this never came to a resolution is that\nit was hard to continue to scale the mindset of \"all protocols across all\ntransports, all obeying Liskov Substitution Principle\" -- since there's\ndefinite value proposition in keeping WebSocket UTF-8 in order for\nlibnanomsg to more easily communicate with browser clients.\nThat said -- I would probably favor refactoring the above-referenced lines\nto remove them, instead giving WebSocket a single transport level socket\noption that may be settable after constructing the socket -- Binary mode or\nUTF-8 mode. In practice, it's entirely reasonable to assume that any\nWebSocket endpoint would define an app-level messaging protocol that's\nstrictly UTF-8 only or binary-only -- mixing/matching here feels like a\nterrible protocol design, and for this reason it would probably be OK to\nremove per-message control of message type.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/467#issuecomment-142072219.\n. I'm going to commit this, since it seems to help.  But it doesn't fix all cases of the tcp shutdown bug.\n\nFor example, I still occasionally get this:\n../test-driver: line 107: 68893 Abort trap: 6           \"$@\" > $log_file 2>&1\nFAIL: tests/tcp_shutdown\n. This was rebased and merged: 5cd676c50961c1bf30f7babefc0c3d7978ec5112\n. So I figured out #476 , which looks to be Darwin specific, but is that error - basically someone (Martin?) was overly optimistic about system calls only returning documented errnos.\n. ipc_shutdown:Assertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:839)\n(shortening title)\n. So my change didn't fix this -- that was another, different problem.  Aargh.\nLooking carefully at this section of code, I think the problem is that we can have two different threads enter this section of code for two different endpoints, and they can race.\nThis makes sense with the shutdown call, because that test has lots of endpoints against a single socket.\nI'm reasonably confident that this race is solvable.  We really need to use reference counters here to ensure that things are safe...  stay tuned.\n. My analysis is that what is really happening isn't a thread race, but multiple events probably occurring due to multiple FSM events pending on the socket.   In this case, if the socket is waiting for cleanup, we cannot really do anything else until the EPs are done cleaning up.  So my solution is to just bail, and let the EPs do the cleanup when they enter this logic.  Here's the proposed diff (under stress testing now):\n```\n--- a/src/core/sock.c\n+++ b/src/core/sock.c\n@@ -833,11 +833,14 @@ static void nn_sock_shutdown (struct nn_fsm *self, int src, int type,\n     }\n     if (nn_slow (sock->state == NN_SOCK_STATE_STOPPING_EPS)) {\n\n/  Endpoint is stopped. Now we can safely deallocate it. /\n         if (!(src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED)) {\nfprintf (stderr, \"src=%d type=%d\\n\", (int) src, (int) type);\nnn_assert (src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED);\n/*  If we got here waiting for EPs to teardown, but src is\nnot an EP, then it isn't safe for us to do anything,\nbecause we just need to wait for the EPs to finish\nup their thing.  Just bail. */\nreturn;\n         }\n/  Endpoint is stopped. Now we can safely deallocate it. /\n         ep = (struct nn_ep*) srcptr;\n         nn_list_erase (&sock->sdeps, &ep->item);\n         nn_ep_term (ep);\n```\n. (The tests ran well over night.)\n. This may be depend on the transport.  Reading the code, what the socket does do is try to find an available socket (one with no backpressure), and run the send on it.  What it does not do is actually use operating system level non-blocking I/O. \n\nThis means that NN_DONTWAIT can actually get stuck for a while, if the operating system stalls the I/O.  The next send won't block, but that first one will.\nThis is an artifact of how nanomsg is handling the send.  Its not running this off on another thread or anything like that.\nThe intention in this design is to ensure that you don't get blocked due to excessive backpressure, not to ensure a very quick return back to the application.\nThere is an argument that documentation could be made clearer here.  There is also an argument that could be made that a quick return back to the application, and running the send on a separate thread or using asynchronous I/O would be nice.  The former is a relatively easy thing to do.  The latter needs a redesign (we really need/want threading!)\n. Not surprising... both 0mq and nanomsg have the same initial author. :-)\nThe real problem here is that we need to redesign the library to better\nsupport fully asynchronous sending/IO.  Its been on my project list for a\nwhile now.\nOn Mon, Oct 12, 2015 at 10:46 AM, Anshuman Goswami <notifications@github.com\n\nwrote:\n@wirebirdlabs https://github.com/wirebirdlabs I will try to post my\ntestcase....it's kind of messy to extract from the application. @gdamore\nhttps://github.com/gdamore It creates a problem to use a separate\nthread if there's a need to do a bunch of sends inside a short span of\ntime. If this is of any help, I tried with zeromq and came across the same\nissue !\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/470#issuecomment-147473074.\n. @wirebirdlabs you're partly correct, but that's really because we don't do the send asynchronously really.  We can wind up blocking here, when we ought not to.  What happens is that we wind up trying to send on the same thread that issued the nn_send().\n\nThat's both a good thing, and a bad thing.\nIts a good thing because most of the time it means we notice errors from the transport.  But not always.\nIts a bad thing because it defeats the fire-and-forget design that makes nanomsg attractive for high message rate applications.\nWhat really needs to be done here is work to ensure that nn_send() can't get stuck forever, that it acts asynchronously EXCEPT in cases where backpressure is present and NN_MSG_DONTWAIT isn't specified.\nProbably fixing this is too much effort at this point -- the real fix is to redesign this to be sanely MT and run from synchronous threads instead of the FSM and non-blocking I/O that we currently use.\n. Upshot of this, is that I'm not yet convinced its right to just close this bug.  The 25 msec delay is just too painful, and taking such a stall when e.g. another connection is coming up or going away, isn't really a great thing.\n. I'm looking at a possible redesign of the queuing here, which would disconnect the application.  In that case NN_MSG_DONTWAIT would simply mean to try a non-blocking send, and fail otherwise.  The actual send would be run asynchronously by another thread.  This would represent a one message deep queue, but I think this brings enough benefits to be worth doing for reasons other than this particular issue.\n. libnng has actually taken that approach, more or less.  The don't wait flag means don't wait for buffer space to be available -- it once the message is buffered, the sender thread returns back to the caller; the message won't necessarily have been placed on the wire yet.. There is some confusion above.\nThe actual underlying I/O is non-blocking.... BUT, nanomsg never buffers anything itself.  As a result, if NN_DONTWAIT is specified, and we can't \"send\" the entire message, the caller is blocked until the message can be accepted fully on the child pipe.\nThis is pretty unfortunate, but it is indeed a consequence of nanomsg's design.  The NN_DONTWAIT flag refers, as I indicated, to waiting for an available pipe -- once we have one, we do \"block\" (not in kernel mode though) waiting for the send to complete.\n(Note that critically the non-blocking I/O performed under the hood means that other streams and activity can take place, even though the calling thread is blocked.)\nThe nng library does buffer this, and returns to the caller immediately if asynchronous delivery is requested.  It also returns to the caller immediately once it has queued the message for delivery.\nI'm closing this against \"nanomsg\" because we won't -- we can't -- \"fix it\".. I'm less confident of this change.  I'm still going through the code trying to make sure we don't leak the data, and that we don't crash on a cleanup.\nI'm also of the opinion that this change isn't really adding much value.  Since the new block is dynamically allocated, you could just \"peek\" into the payload by advancing past your fixed size headers.  That simply adding a value to a pointer.\nAm I missing something here?  I'd like to understand the use case a little better.  What is the purpose of separating the headers?\n(Oh, and if the headers are small, then one shouldn't worry about the cost of copying them.  That's ~nothing.  Larger payloads do matter though.)\n. Its actually worse than that.  NN_MSG is supposed to be zero copy, and for single iov case it is.  But for this case, we wind up having to do an allocation, and a data copy, in order to keep everything straight.  I think the benefits of this proposal fall far short of outweighing the risks, and if you were planning to do this you'd actually get better performance and more efficient code by just using a single element iov array.  You'll be far better off that way.\nI'll wait a little while before closing this PR to give you a chance to respond, but at the moment I'd say its very unlikely that I'll integrate this change.\n. This looks like a problem with your build environment.  Link errors etc.  I don't know anything about the Windows tooling here; what I can say is that we build regularly on AppVeyor and don't see these problems.  I'm not sure VS14 is supported though -- apparently new versions of cmake support VS14, but I've not had a chance to try it.  What version of cmake are you using?\nYou'll note that cmake complained above: \"The C compiler identification is unknown\"\nSo it really is just guessing (and probably badly) about how to produce programs.\n. You need to update your cmake.  I've verified that we can build on VS14 on AppVeyor.:\nMake suite maintained and supported by Kitware (kitware.com/cmake).\ncmake ..\n-- Building for: Visual Studio 14 2015\n-- The C compiler identification is MSVC 19.0.23026.0\n-- Check for working C compiler using: Visual Studio 14 2015\n-- Check for working C compiler using: Visual Studio 14 2015 -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: C:/projects/nanomsg/build\ncmake --build .\n. Microsoft says this: https://msdn.microsoft.com/en-us/library/89cx16e6.aspx\nSpecifically,\nYou may get this error if you mix standard header files (for example, dos.h) and your own files. #include the standard headers first, followed by your own header files.\nI've not looked into this in any depth, as I lack the necessary environment to do so.  But maybe this will give you a hint.  If you figure out, please do let us know.\n. Oh, and there is this, which suggests it may be a bug in the compilers themselves:\nhttps://support.microsoft.com/en-us/kb/826326\n. And more info:\nhttp://stackoverflow.com/questions/2001289/how-to-resolve-fatal-error-lnk1000-internal-error-during-incrbuildimage\nAgain, this looks like a problem with the Microsoft linker, not with our code.\n. You can check appveyors website.  There is also a .appveyor.yml file in the repo I think. \nSent from my iPhone\n\nOn Nov 10, 2015, at 2:03 PM, Charles Y. notifications@github.com wrote:\nUnfortunately all the solutions I can find along those lines are for older versions of the OS, Linker, or Visual Studio.\nFor example, https://support.microsoft.com/en-us/kb/826326 has this:\nArticle ID: 826326 - Last Review: 10/25/2005 18:30:00 - Revision: 1.3\nApplies to\nMicrosoft Visual C++ .NET 2002 Standard Edition\nAnd http://stackoverflow.com/questions/2001289/how-to-resolve-fatal-error-lnk1000-internal-error-during-incrbuildimage has this:\nI am trying to recompile solution file for memcached project on Windows 7 64 bit with Visual Studio 2008 and got the following error:\nAs I've gone further and further down the google rabbit hole, all I've been able to find are resolutions for old product versions.\nCan you share any further details about the AppVeyor VS14 configuration you were able to compile it on?\n\u2014\nReply to this email directly or view it on GitHub.\n. I think this commit 5cd676c50961c1bf30f7babefc0c3d7978ec5112 may have solved your problem.  Can you update and try again?\n. To be clear, this looks like another issue for #463 -- possibly.\n. Ping?  @panjw can you check nanomsg 0.7?\n. Is this #65 -- I think so.  If it is a hang on nn_recv after nn_close(), I have a fix coming.\n. nn_close() is confirmed to have some ugly races in it.  Stay tuned for the fix, I hope.\n. Closing per feedback from submitter. \n. Integrated in 2163280c83be0ff6977726e23bb2171113b58f44\n. So the hang is caused by the lack of any sort of linger, and a failure to wait after sending data.\n. It indicates that the item is not used. Useful to silence complaints about unused arguments that have to exist because of calling conventions.  It expands to a compiler specific attribute. \n\nSent from my iPhone\n\nOn Oct 22, 2015, at 12:03 PM, Bent Cardan notifications@github.com wrote:\n@gdamore what's NN_UNUSED for?\n\u2014\nReply to this email directly or view it on GitHub.\n. I think this may be another case of #418 style inproc not being thread safe.\n\nThe test does run ok on my platform though.\n. This is a dup #429  -- basically inproc isn't thread safe.\n. This is a bug in the test program not in inproc.. Yes, that looks correct.\n. I'm not sure this was the right choice in retrospect, but I think its too late to fix it.  (I really think -I/usr/local/include -- or whatever -- is better, with applications including  or whatever.)  Too late now though.\n. Well, #561 reiterates what I just said.  Seems like the node package is wrong here, and we made a bad change to accommodate.  I'm going to research/inquire further, but I think we want to straighten this out prior to 1.0.\n. @wirebirdlabs please see this.  I am intending to fix this.  I discovered it while adding richer testing to the self tests for websocket compliance.\n. Well, I don't have enough context to see what the problem is there in gecko.  It is quite possible that if you're injecting bad protocol messages, the response from libnanomsg is going to be even less standards compliant.  And your application is probably going to be confused by a zero length frame.\nI'll be adding more handling here shortly.\n. More details of the work that led me to discover this (along with some other planned changes for websocket transport) in this PR: https://github.com/nanomsg/nanomsg/pull/490\n. Note that PR#490 does not address this problem though.  Stay tuned for that.\n. Well, going back and reading section 7.1.7 again, it does seem like we are supposed to make a reasonable effort at sending the CLOSE frame.  But the other frame is complete crap, and the zero length recv frame is even worse.\n. So, reading through the thing-- I was a little confused, and the code here was kind of badly wrong.\nThe 0x7F is never transmitted over the wire.  It only went to the user as the cmsg data.  Attached to that zero length frame!\nAlso the entire deferred state for STATE_FAILING appears to have been intended to facilitate delivery of that frame to the user.  Its actually more correct, and simpler, to send the CLOSE frame immediately, and stop the pipebase altogether, without waiting for the user to call recv().\nI've implemented these changes, and tested them, as well as adding test cases (richer) to the ws.c test code.  PR coming momentarily.\n. So this is PR#492.  https://github.com/nanomsg/nanomsg/pull/492\nIt is build on top #490 which addresses the other issues we discussed about the public API surrounding websockets.\n(#490 adds a new socket option, NN_WS_MSG_TYPE, and uses that in either the cmsg data, or in the global socket options.  It eliminates the other public APIs exposing websocket specific send/recv methods, and the differently named but same valued NN_WS_HDR_OPCODE constant -- use NN_WS_MSG_TYPE instead.)\n. Well, I appear to have botched something in the handshake.  Actually, it looks like it might have also busted something in the previous #490, as we're setting timeouts in AppVeyor.\n. I noticed this while adding some negative test cases.\n. So this comes up during both send and recv.  And both cases, if we timeout a blocking call, we should return ETIMEDOUT.  Test cases actually were checking EAGAIN, which was wrong.\n. As you can see, it took some effort to refine this.  I've collapsed the code (rebased) into a single commit, and I'm now happy with it. \n(Sadly, I've discovered that the tcp_shutdown case causes problems not just for itself, but for any subsequent tests using TCP on AppVeyor.  I've disabled that test on AppVeyor for now.  It still runs on Travis CI though.)\n. Exact comments where:\nDeferred start of the global FSM to avoid race condition with line 1267 in FSM handler. The problem was that line 1267, global->statistics_socket would not have been initialized properly by the lines 297-305 block.\n. This was fixed a while ago.\n. Committed as commit 501ed4f1c893a9a4619cd8802eb93a3eeeae36e4\nAuthor: adam a.biro@t8software.com.hk\nDate:   Mon Oct 26 07:22:34 2015 +0100\nfixes #487 incorrect includedir in generated libnanomsg.pc\n(I only changed the commit comment.)\n. PR seems to cause hangs in the test.  See CI details.\n. Yep.  The nn_recv is blocking forever, I think.\nI think nn_close() doesn\u2019t alert the blocked threads that the file is no\nlonger open.  Feels like a nasty bug.   And probably difficult to fix.\nI\u2019m pretty sure EINTR is also the wrong errno in this case \u2014 we should see\nETERM instead.\nOn Tue, Oct 27, 2015 at 9:36 AM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nhangs\nIndeed -- I'm guessing it's the new test with tcp_shutdown -- are you\nable to see any obvious problems with that test? I don't have an\nenvironment readily available to test, but could fire up something on OS X\nlater to troubleshoot ...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/502#issuecomment-151561501.\n. Could be -- if you are expecting to receive that signal to wake up the thread.  However, most operating systems actually disable receipt of the SIGPIPE signal elsewhere, and return EPIPE inline.  (So for example, this shouldn't be an issue on Linux.  Unless disabling SIGPIPE somehow also disables the kernel from returning EPIPE or EBADFD on a closed pipe?\n. I'm reasonably comfortable with the changes to the windows code in efd.c.  I'm far less comfortable with tcp_shutdown.c changes.  That test is incredibly fragile, for a variety of reasons, I think.  I'm really not keen to further complicate it.  Frankly, I'd rather create a new test file, and add tests to that, than to add to tcp_shutdown.c  -- a big part of my reason behind that is that it is already close to impossible to diagnose the failures in tcp_shutdown.\n\nLets also separate this into separate PRs please.  One PR for the windows fix, and another entirely for enhancing the tests.\n. Looks ok to me.\n. Resend this with a correct bug report and a comment of the form:\nfixes # \nWhere the number and synopsis are taken from the bug report.  Once that's done, I'll go ahead and fast-forward merge it.\n. I think the windows code is particularly fragile... I have some theories here, but it seems like some tests trash the stack.  The tcp_shutdown test was particularly hard here; once it failed it left the stack in a state that even other tests would fail subsequently.\nI've not seen WS timeouts on Travis, although there are other bugs there.\n. Your commit comments are still wrong:\nfix xcode error, #include reference :ear_of_rice: :ear_of_rice:\nFixes #504\nI'll go ahead and fix the comments and commit.  You will probably need to merge or rebase after the fact.\n. Merged here:\ncommit 72c695ba64b1cd54c2f8693694e97efbfe168083\nAuthor: Bent Cardan bent@nothingsatisfies.com\nDate:   Wed Nov 4 07:00:09 2015 -0800\nfixes #504 build failure in tcpmux.c: `../utils/err.h` file not found\n. not a big fan of emoji, but more to the point \u2014 i\u2019m trying to enforce a\nfairly strict conformance where the bug id and synopsis (as in the github\nissues) are reported precisely in the first comment line of a commit.\nOn Wed, Nov 4, 2015 at 9:37 AM, Bent Cardan notifications@github.com\nwrote:\n\nthanks @gdamore https://github.com/gdamore for merging/fixing my\ncommits! [image: :sunglasses:]\nbut you know, emojis are cool for commits sometimes, and yea @wirebirdlabs\nhttps://github.com/wirebirdlabs this PR is history\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/503#issuecomment-153802940.\n. You might be on to something @reqshark.\n\nIn mangos I had some of these problems, so I used a repeated try protocol to determine when the connection was established (with an eventual timeout) before actually starting the real test.\nProbably the test code should be rewritten to be a little more robust -- ensuring that the connection is actually established before running the real test.  (And waiting up to ~5 seconds for the connection to establish, with repeated broadcast attempts on the socket at frequent -- say 50 msec or so -- intervals.)\n. Yes, an indefinite hang in nn_close() is definitely a bug.\n. When I looked at this, I think I saw \"hangs\" in nn_recv().  That is, the code wasn't getting to the equivalent nn_close(), because nn_recv() was stalling.\nThe problems I'd seen where a case where the underlying socket doesn't have any recv() calls ever issued against it, and as a result you don't notice a remote TCP disconnect.  This is a bug / design problem with nanomsg and its non-blocking I/O.\nWith mangos I just set up a blocking thread (goroutine) that attempts to read on every socket, even PUB sockets that don't normally receive data.  This is the only way you get to notice a TCP (or pipe) disconnect (unless you try to send data).\nArguably there could be some kind of event delivered (a poll'able event, or somesuch) but I'm not sure that such events are universally delivered with every system.\nAll this speaks very strongly (to me at least) in favor of a threading model instead of asynchronous event loops.  Which is just another reason why I will not be using event loops in any hypothetical rewrite / reimplementation of nanomsg.  Simple synchronous code flow using threads is lots easier to get right, especially if you can figure out the modest locking issues that it creates. :-)\n. That's not how blocking IO works.  Each thread is scheduled by the kernel just like a process. When it is waiting for the IO to complete it is not running but sleeping.  The kernel wakes it up when the data is ready. \nFor nanomsg there will be some small overhead in terms of locking and context switching but that will still be far less than what we pay today. \nI've been doing this kind of thing for decades now.  (I am a kernel developer after all.)  Trust me. :-)\nSent from my iPhone\n\nOn Nov 4, 2015, at 10:16 PM, Bent Cardan notifications@github.com wrote:\n@gdamore, getting back to your point about async i/o and threads,\nI just set up a blocking thread (goroutine) that attempts to read on every socket\na go-routine sounds like a good option, but that's only mentioning the benefit. I'm wondering what's the trade-off, in terms of libnanomsg (AFAIK the goroutines are light), but for the library what's the overhead on the system for blocking threads? I assume some coordination and inter-thread communication must happen for the details of all new and old sockets getting watched...\nI suppose a thread could be tuned for different scenarios, with scheduling priority? The last thing I want is a blocking call running upwards of 100% on a core or CPU. Then again if we set a NICE(1) level too low could the system fall behind on I/O that could have been done?\n\u2014\nReply to this email directly or view it on GitHub.\n. I\u2019ll have to look at this\u2026 this is likely a regression I introduced with\nthe message type option.  What happens is that the epbase option lookup has\nto reenter the context of the state machine, and if it is already in that\ncontext, then its going to hang.\n\nI have some specific ideas as to this, and I think I\u2019ll be able to fix it.\nOn Thu, Nov 5, 2015 at 8:32 AM, Wirebird Labs LLC notifications@github.com\nwrote:\n\nIt feels the simple solution is to move that option check to\nnn_cws_create() and cache it into a new field added to the struct nn_cws\ntype; would still like to figure out why this is necessary ...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/505#issuecomment-154113824.\n. Hmm... looking at the code.  still working through this.  I'm wondering if the problem is a race in the option handling or pointers on the ep?  I did just walk through the entire call flow and I see you're right -- there are no extra efforts to enter state machine context here.  So my original suspicion was wrong.\n. See PR #516 that I think addresses this properly.\n. Ok, I\u2019ve already merged it.  Please let me know if for any reason it\ndoesn\u2019t fix it for you.\n\nOn Tue, Nov 10, 2015 at 11:29 AM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\nSee PR #516 https://github.com/nanomsg/nanomsg/pull/516\nWill evaluate this ASAP and report back.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/505#issuecomment-155540192.\n. Aargh.  I'm not sure why this occurs. I think the change here was good even if it didn't fix the hang. \n\nDoes this problem occur anywhere except Windows?   I'm seeing a number of different issues in Windows with TCP. \n. This cannot happen on Windows (no named interface names, so they can't use this functionality at all), and is probably an issue with ipv6 on MacOS too. \n. But I doubt OSX is unaffected.  I do think people don't see it on OSX because home users rarely configure IPv6.\n. I want to see the specific address you\u2019re using \u2014 maybe just cut and paste\nthe nn_connect() and nn_bind() calls.\nThat said, the inconsistent nature of your error, along with other\nincorrect code I\u2019ve seen you send (off-by-one string handling) makes me\nwonder if this code is not just falling victim to heap corruption caused by\nan error somewhere else in your code.  I can completely believe that heap\nerrors could cause all kinds of grief, most of which would be difficult or\nimpossible to root cause.  (This is the nature of heap errors.)\nI\u2019m not sure you have debugging allocators available to you (particularly\nones with red-zone areas, e.g. the ability to detect writes beyond the\nallocated area, use after free, etc.), but if you do, you might want to run\nyour code through it.\nThere is almost no conceivable way that nn_resolve_literal() can fail\nnon-deterministically.  It makes no use of shared state, and is simply\nparsing the string.  If this is failing \u201crandomly\u201d, then something else\nsomewhere else is going very wrong.\nOn Mon, Nov 9, 2015 at 2:21 PM, Bent Cardan notifications@github.com\nwrote:\n\n@gdamore https://github.com/gdamore it's not easy to reproduce. The\nerror is inconsistent and most of the time it works as expected.\nI was looking at two scenarios over IPv4 localhost, i.e. msgs sent over an\naddress of 127.0.0.1:5555 and connecting to a publishwe on my local\nnetwork, so that was an address of 10.0.1.2:4444\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/506#issuecomment-155217474.\n. I can't close it, because its still broken for named interfaces.  All you've proven is that as I said, if you use IP addresses, it works, which is the workaround I've given.\n. Backing out is probably not the right choice here -- it may be something we do, but ultimately we still need to fix the original bug -- #371 \n. So the problem here is that you're attempting to bind to an interface name, which is problematic at best.  Better to bind to an explicit IP address than an interface name.\n\nI need more information about the specific code that is timing out or failing; I'd also like to have some samples that illustrate the interfaces that are plumbed on your system. (Such as the output from ifconfig -a)\nAgain, if you specify a numeric IP address instead of an interface name, you bypass all this code, and probably save all the problems.\nIn fact, I feel that using interface names so fundamentally flawed (specific to operating systems, cannot ever work on Windows, and just generally fragile both from an implementation choice and from an application design view) that I'd like to just rip this functionality out altogether.\nTo be clear: use of named outbound interfaces (e.g. \"lo0\") in nanomsg URIs is IMO fundamentally broken, and cannot be solved in any portable fashion.  I'm therefore strongly in favor of removing it.\n. Please show me an example of the URL you are binding to.\n. And ideally also, output from ifconfig -a or whatever analog you have.\n. Reading the code, the only way you get there is if nn_literal_resolve() fails.  That only fails if you give it an IP address string that it can't parse.\nIt can parse strings of the form \"[::1]\" and \"127.0.0.1\".  Using IPv6 addresses without enclosing brackets likely fails however.\n. Please also move this to #506.  I'm going to actually close this PR, because no matter what other action we may take on this, accepting this PR isn't one of them.\n. Well, that's weird. This change broke Linux somehow.  So either we've regressed, or it doesn't address the problem completely.  Interesting that one of the Windows checks failed too, but that seems unrelated to this failure.\n. @reqshark No.  Not unless there is no other way.  That way leads to spaghetti and a more difficult to support code base.\n. I've confirmed that the problem is that attempting to get the transport specific option set fails due to a block on the global lock.  We're recursively trying to lock.  More soon.\n. No, this PR cannot be accepted as is.  It definitely is a 100% hang condition.  I am working on a more robust fix.  Stay tuned.\n. Oh, I'm working starting from your work, whether git reflects that or not in the end.\n. I'm thinking it would be painful to fix this in a way that allows endpoint transport options to be retrieved or accessed (or changed) during data transport, but setting it up to work during connect/bind is easy.\nThis is fallout from the design of the existing locks.  I think this is a reasonable limitation.\n. Probably the way this will work is I will fix the lock recursion independently, and apply that change under yours.  So yours will be cherry picked on top of my fix.\n. Merged along with #515 as part of PR #516.\ncommit d4238b8f97b83963523cecf18cd5a031bf8f06d3\nAuthor: Jack R. Dunaway jack@wirebirdlabs.com\nDate:   Thu Nov 5 10:58:01 2015 -0600\nfixes #505 hang in websocket test\n. Does this problem occur with stock nn_device()?  I seem to recall looking at this problem earlier, or one very like it, some weeks ago.\n. That reason inproc works is that it has no routing headers (it doesn't transport them anyway).  I'll try to look at this in the next day or two -- the problem is mishandling of the header material.\n. You have to close one of the sides of the device with nn_close().  That will cause nn_device() to return.\n. Unless someone is screen scraping the HTML\u2014 but if they\u2019re doing that in a\nbuild system, they deserve what they get.\nI\u2019m not changing the actual URL \u2014 in fact gh releases API is far better to\nuse here.  Just the download page.\nOn Mon, Nov 9, 2015 at 1:21 PM, Bent Cardan notifications@github.com\nwrote:\n\nchanging those URLs could cause build system breakage if people are\ndepending on a different URL address format\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/512#issuecomment-155199567.\n. Note that use of \"names\" like \"localhost\" was never supported either.  Frankly that would probably have been more useful.  Still, IP addresses are more reliable.  In the future someone could add support for resolving local DNS names here.\n. I really wish people wouldn't use tcpmux.  Its experimental from Martin, and I think problematic in many regards.  Its also not portable.\n\nAnd yes, on platforms where you need IPC to work.  I'm probably going to close this as Will Not Fix, because I have no idea how to make IPC work on iOS.\nThe unlink before bind() is actually not a great idea universally, and is definitely not what I'd call idiomatic.  Its a hack to ensure that if an earlier application crashed without cleaning up the name, that the name is available for use in a new instance.  HOWEVER, it causes severe problems if you have multiple instances of the app running.\nWhat's actually required here is you have to test if your old application is still present, and if it is, fail cleanly, usually.  The unlink() should only be called when you've ascertained beyond any doubt that it is safe to do so (i.e. no other application is actually using the name, and the name isn't problematic for other reasons -- e.g. a real file posted somewhere.)\nAnyway, as I said, I'm not going to fix tcpmux for iOS.\n. Well,travis mostly worked.  The one of two builds passed; but the failure was unrelated.  I intend to merge this upstream.\n. Yes.  This is confirmed.  And I can confirm that I have a fix for this coming shortly.  The problem was rather complex, and the fix fell out as a result of fixing some other nn_close() related problems.  Stay tuned.\n. Good news.  I think I've figured out this particular hang.  Basically, the nn_recv() keeps looping, even though it gets interrupted, because it doesn't see the STOPPING_EPS state.  This is an easy thing to fix properly.  Stay tuned.\n. Thanks for your test code.  It made narrowing this down quickly much much easier. \n. Agreed.  I'm going to make some minor changes to these, along with my fix for the upper layer problem, and probably commit once I verify I have fixes that work.\n. Hmm... now I'm not sure.  I'm getting different results on Darwin.  Stay tuned.\n. At this point I'm not in favor of changing from an indexed table to a list of pointers.  The zombification is similar to the approach I'm looking at.  It was working for me on illumos systems, but I've seen problems with MacOS.  The hang on MacOS occurs elsewhere.\nI'm starting to suspect that the different polling mechanisms (which are all used to cope with the async I/O nature and the need to support poll/select) are part of the problem.  I think the fact that closing() a FD doesn't always issue a notifciation/wakeup from the efd_wait() is the problem.\nThis would be lots easier if we could just use normal blocking I/O and threads.  Even elimination of select() compatible so that we could use condition variables instead would be a huge benefit.  But break probably gazillions of consumers who've come to rely on the select() / poll() compatibility feature. (So we can't do it. :-(   )\n. So this is interesting... on darwin, close() of a fd does not cause POLLIN wakeups in poll().  Which is why it hangs differently on MacOS.\n. That's a helpful link.  I think I can just write to the polled fd since that is already what this is supposed to be doing.  Stay tuned.\n. To be honest, I'm tempted to just enforce that we have a timeout, say 1 sec, and wake up on close.  Its crap, but it would work.  I can't believe operating systems think its OK to block in poll with invalid FDs.  This is friggin' insane.\nThe hard part here is not sending the message, its actually figuring out when you can actually close the file descriptor.  Because you can't close it until all reads are done, and you don't know when that is complete.\n. Fixing this \"properly\" is going to take some more time.  I have a clear idea, and yeah, I'm gonna have to create a new file descriptor to add to the poll group; this is also going to lead ultimately to fixing the LINGER problem, since once I have that I can add the linger support properly.  This will also require adding a bit more state to the socket, since I'm going to need to have reference counts on threads that are in nn_sendmsg() or nn_recvmsg() so that I can determine when they are done.  Probably also a new NN_CLOSING state or somesuch.  (I don't think I can use NN_STOPPING.)\nIt's not something I can do right this very second, as I think its several hours of work to get this completely correct and have any assurance of it actually being so.  Sadly, its also going to require testing on several different platforms (Mac, Solaris, Linux, and Windows at least) to have any confidence that I've got it right everywhere.\nThis whole efd nonsense is the result of trying to fake real UNIX file descriptors.  I cannot say this strongly enough -- this was a substantial architectural mistake.  Especially since we're not going to emulate the broken behavior on broken systems.  (E.g. perhaps on Darwin the fact that close() doesn't terminate poll() or recv() ought to be behavior we emulate on Darwin.  Frankly that's what happens today -- the system calls are busted and we behave accordingly.)\n. Solving it for windows solves part of the problem while leaving the rest.  More importantly,  at this point I have no idea what language ports / runtimes, other consumers, etc. might be reliant on the whole select() thing.\n. Well this is interesting.\nOn MacOS: closing a local end of a pipe doesn't interrupt a poll() on that descriptor from a different thread.  If you close it synchronously from the same thread, the poll returns immediately.\nBut, if you close the far end of a pipe from a pipe, it does abort the poll.  So maybe that's a simpler fix still.\n. aha.  The next problem is that file descriptors get reused, so your poll may wind up polling against some other file descriptor.  Argh.\n. Yeah, autoincrementing integers would be better, probably.  That probably\nbreaks efficient lookup.\nBelieve me, I\u2019d prefer to pass around pointers, except that with a socket\n/ file descriptor semantic people expect that they can use these things\neven after being closed, which basically makes it hard to guard against\nuse-after-free.\nAgain, the whole \u201csocket\u201d / \u201cfile descriptor\u201d equivalence semantic instead\nof using an opaque handle (pointer) is just an unfortunate design choice.\nI don\u2019t see how to fix that without breaking semantics and library API. :-(\nAll this calls for a new / alternate library with much more sensible\nsemantics and API.  Which is more than I am able to do right now.   For\nnow I just want to achieve the point of minimal brokenness in this library.\nOn Sun, Nov 15, 2015 at 9:59 AM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nThe next problem is that file descriptors get reused, so your poll may\nwind up polling against some other file descriptor. Argh\nYep. This is also problematic at higher layers, such as framework and\napplication -- where additional bookkeeping and mutexing is required to\nsolve this issue -- which is what led my train of thought toward \"The\neffective socket identifier, from the perspective of the library user --\nrather than being an integer on the range of [0, NN_MAX_SOCKETS-1] -- would\nbe a pointer to a pointer\" as being able to solve multiple layers of\nproblems. Foremost, the incorrectness tracked by this Github issue, and\nalso usability/correctness of library usage at higher layers.\nAnd if not a raw pointer, at least an ID that's reasonably unique per\nsession of the library, such as an autoincrementing integer.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/520#issuecomment-156839690.\n. Please have a look at PR #522   -- I think this addresses these problems.  Its a bit more convoluted to get it all work, since i had to fix issues in multiple places (eventfd and core sock state machine), but so far it seems ok.\n. So the global socket checks are not properly protected.  There are NN_BASIC_CHECKS but those checks are not done carefully under the global lock.  There are some further issues here as well that I'm working on. \n. I'm closing this, as I believe PR #525 addresses all of these problems.  Please read, test, and review that PR.  I'm hoping to push to master soon, but I'd like other folks to to try it out; its a rather large diff, so I'm trying to be a little more cautious.\n. I don't think we need to worry about this. I'm pretty sure the work I've done earlier today resolves these issues. \n. This should be *closed closed.\n. I've written a test for this, and confirmed the bug exists.  Stay tuned.\n. This has been a terrible, slog, but I think I know what's going on.  My \"fix\" was wrong.  Because I misidentified the problem.\n\nThe real root cause is a nasty nasty bug in the cmsg layer.\nAt its root, the problem is that the cmsg header for SP headers are padded to a round number of alignment units (e.g. 8 bytes).  This causes bogus padding (random values really) to be inserted when the headers are copied across messages.\nThe problem here is that the cmsg API doesn't give us a way to convey the \"actual\" length, only the \"stored length\".  So we have to inspect the payload which MUST be self describing.\nWith REQ/REP we can find the end of the headers by locating the request ID which will be terminated by a word with bit 31 set.   But this doesn't help other protocols at all.   Most other protocols don't include a header, which is why they're ok.\nI've not got any clear idea how to fix this, except perhaps to break the raw API.  The low level cmsg structure simply doesn't convey enough information at present.\nYes, this is another case where attempts to emulate POSIX compatibility hurt us.  The POSIX cmsg API was designed for use with IP options, not for generic option passing.  As a result, its ill suited for us.  I may wind up embedding another word (length) in the SP hdr to help us here.  That's probably the only way to fix it.   This WILL break users who are relying on the cmsg payload for the SP header.\nArrgh.\n. No need for a separate issue.  I posted on the mailing list.  Probably I'd just prepend 32-bit integer.  Although really 8 bits is enough and surely 16 is. \n. A byte count prepended to the SP_HDR which indicates the number of bytes immediately following which are in the sp header. \nI'd be ok even using less - say 16 bits or pad with 16 reserved bits.  Reality is that an SP header will never be more than 64k. \nNeeds to be bytes since the protocol header needn't be aligned. \n. Nope.  The struct tells us the length AFTER alignment.  That is the length is always padded out to a multiple of 8. That is the problem. \nWe could change the code but that would also change the meaning.  What it means now is the space used for storage which may be more than the actual size of the sp header. \nNow it's interesting that this structure needn't actually be what is put on the wire.  I'm not proposing to change the wire protocol per se. Only what is exchanged between nanomsg and consumers using this structure. \n. What I mean here is that the cmsg headers never leave the address space of the program. \n. The bug there is that the length they get is padded.  There is no way for them to get the unpadded length right now as that isn't transported. \n. The CMSG API is indeed flawed in my opinion.  It looks to me like the POSIX committed designed it to support quickly scanning/iterating over a bunch of options packed into a large contiguous chunk of memory.   (Or to support transporting them this way.)  This may come about as a result of an implied requirement that these are transported between kernel and user space with minimal changes to the existing sockets API.  (Another case were legacy choices were made, but which actually hurts us.)\nAnd you're right, the header within the header is kind of ugly.  I could decorate the cmsg structure to add a field that holds this value, which would be more \"logical\" from my perspective (cleaner), but more or less \"breaks\" the POSIX-compatible nature of the API.   (We could also change the meaning of the cmsg_len field, and change the macros, so that the macros did the right thing, while the \"real\" value was still stored under the hood.  I'm not sure if that breaks the API or not -- are these structure members ever accessed directly?)\nIn retrospect this is all garbage.  I sane way to handle this would have been to expose struct nn_msg * directly to applications.  Of course, not very POSIX like.  But waaaayyy simpler, and more robust.  And, btw, less data copying too!\n. I think you just restated what I proposed as the second option -- the \"decorated\" really meant add a new header field.\nSo to recap, we actually have three options:\na) embed the length into the payload as the first 32-bit word of the payload -- this only needs to be done for SP_HDR, and needn't affect any other control data that could be passed via the cmsg API.\nb) add a \"data length\" (I wouldn't restrict it to just SP_HDR length, but use for all) field to the cmsg header.  Call it something like \"cmsg_datalen\" or somesuch.\nc) change the meaning of the cmsg_len to pass solely the data length, and change the macros to do the do the addition and alignment padding (so the existing macros have the same semantic and return the same values, but it makes it possible to obtain the 'real' data length from the cmsg_length.\nNow a word about the POSIX definition of cmsghdr.  The standard specific that it shall contain at least the fields cmsg_len, cmsg_level, and cmsg_type.  It does apply specific meaning to these three fields.  So it wouldn't be good to change those (sort of ruling out option c).  The spec is here:\nhttp://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/socket.h.html\nNote, nothing in the standard prohibits adding a field.  So I think we could do that.  \nThat said, RFC 3542 incorrectly states that the posix definition of the structure is a specific form.  POSIX only states the above.\nI'm leaning towards option b now, since I do think it is \"cleaner\" than the other, but I'm happy to hear other opinions.\n. Btw, its kind of sad that we don't actually use this cmsg API to pass any of the options that are specified in RFC 3542.  So we're morally compatible, but from a real usability standpoint, not really.  Set sockopt is so much better in nearly every regard anyway...\n. Ok, I'm changing this to pack in a size_t.  That's sensitive to the compilation mode, but since this structure never leaves the address space of the program, that doesn't matter.  Given that test, it works.  I did revert the change I made for #509 which turned out to be incorrect. \n. Huh.  This seems to pass on Windows, Darwin, and Solaris, but fails on Linux.  Too many different event handling notification mechanisms!\n. Ok, I reproduce this async-shutdown mutex error pretty consistently on Linux.  Argh.\n. Closing this, because #525  is the \"real\" consolidated PR with all these changes.\n. @wirebirdlabs I've gone ahead and merged all these changes into a single changeset.  The rationale for doing so is that the entire set of changes are required for a complete fix; including just a portion of them leads to brokenness.  I've tried to give you credit in a sensible manner, although git only allows me to record one author.  (Given the rather large amount of refactoring I did in sock.c, core.c, and the efd framework, it didn't really feel right leaving you as the primary commit author.)\n. Btw, this fixes a slew of errors/failures that I've seen on illumos systems.  Testing is clean on Solaris/illumos, Darwin (MacOS X), Linux, and Windows.  Finally.\n. I rebased and merged this.\n. Can you please try this out with PR #525 -- I think this is probably fixed in that code base.   I'm waiting for test & review feedback before I integrate that change.\n. This looks like 0.7.  I'm pretty sure this is fixed in the latest code.  If you can test PR #525 that would be best, but I suspect it may even be fixed in head.  (Fix for #77 looks like it could be relevant.)\nCan you test again with newer code?  Alternatively if you can boil this down into a simpler set of reproducible test code, then I can test it myself.\n. So I pushed that PR, so you can test head.  I'd like confirmation that this is still a problem for you, if possible.  (I suspect it was fixed.)\n. And? How did it go?  Also, you could test v0.8.\n. Agreed.  Closing.\n. Well, this seems hard to hit.  I'm several thousand invocations into this, and I can't seem to reproduce.  Aargh.\n. I don't think so.  That signal shouldn't have been delivered on Linux ever because we are MSG_NOSIGNAL \n. Wow.  I've been running this test in a while loop for hours, and haven't been able to reproduce it.  (On two different systems -- running MacOS 10.11, and CentOS 7 in a VM.)\n. I think my vm is kind of constrained. \nSent from my iPhone\n\nOn Nov 16, 2015, at 7:50 PM, Wirebird Labs LLC notifications@github.com wrote:\nin a VM\nIdea: drastically throttle the VM; 1 core, 1GB memory ... try to repro what are probably relatively \"low resource\" conditions on Travis.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm starting to think this might be related to #554 -- that is I think nn_term() races against the REQ/REP state machine for example.\n. That said, ipc_shutdown uses PUB/SUB.  And doesn't use nn_term. So no, this is different.  Argh.\n. Yes, I need to spend time working on it again.  :-)  Trying to get the\nother stuff stabilized first.\n\nOn Mon, Apr 18, 2016 at 12:07 PM, Jack R. Dunaway notifications@github.com\nwrote:\n\nBump. This is continually failing in Travis CI -- here's the latest\nfailure: https://travis-ci.org/nanomsg/nanomsg/jobs/123991735#L642\nThis bug should be bumped to one of the highest priorities, especially\nsince it's still not well-understood what causes the issue.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/528#issuecomment-211534173\n. I have a hope/theory that the changes I made today to make nn_close() and nn_term() more resilient may have fixed this.  Investigation pending -- lets keep an eye out for this failure since I've not seen it in quite a while now.\n. This is at least a release stopper -- we need to find out if it still happens.\n. Note that ipc_shutdown spins hard on the CPU in send.\n. Ok, time to figure this one out then.\n. A brief note -- the queue data structure is totally unlocked.  We need to verify that these functions are only ever called with some higher level lock or exclusion in place.\n. I think I might see the problem -- but question -- have we ever seen this on Windows?\n. Basically, my theory is that we are calling either nn_worker_term() twice, or nn_fsm_stop() twice.  I don't think there are guards to ensure that these are idempotent.\n. That's useful information.  Thanks.\n. I saw a different error with local_perf/remote_perf when using ipc:\n\ngarrett@Triton{104}% ./local_thr ipc:///tmp/nperf 1048577 1000\nAssertion failed: (nbytes == (int)sz), function main, file /Users/garrett/Projects/nanomsg/perf/local_thr.c, line 69.\nAbort\n. Can you tell me which transport you used, @rbx ?\n. I understand what is happening.  And it is close related, but not for the reason you think.\nThe problem is that we have established a maximum receive size, and the performance tests don't set this.  The default is 1MB maximum message size.  This can be overridden by setting the NN_RCVMAXSIZE option -- and the performance utilities ought to do that.\nWhat we may be seeing here though, is an interesting edge case where attempts to fail (disconnect) the receiving socket when attempting to read such a huge chunk trigger other problems. \nIt could be fun to add a test that sets the rcvmaxsize to something small ... and then try to send modest messages.  The data should be dropped, but this would allow us to exercise/stress that code path in the library.\n. I'm pretty sure this is happening when shutting down FSM state machines.\nWe cleanup \"event\" structures, and out of paranoia we make sure that the events are not actually enqueued anywhere.  This can happen at numerous places, and locating the precise race where it occurs is going to be difficult to know which state machine is getting shut down.  Fortunately the new backtrace code I've added should help with that.\nNow as I think about this in more detail, probably what is happening is that some thread is sending fsm notifications to a state machine that is being shut down.  These may be arriving late.\nI think the FSMs themselves are missing certain protections - in particular the fsm event publishers for nn_fsm_raise() and nn_fsm_raiseto() are run outside of the locks, and blithely enqueue events, with no regard as to checking whether the FSM is active or not.  Probably we need to insert just a little intelligence to detect a stopped event and in the case that it is stopped, decline to queue the event to the FSM.\n. Yes. From a security perspective if the value is large or unlimited then it's trivial to perform a denial of service attack. \nSent from my iPhone\n\nOn May 27, 2016, at 1:07 AM, Alexey Rybalchenko notifications@github.com wrote:\nAfter setting NN_RCVMAXSIZE to -1 I don't see any more hangs/assertions or (significant) throughput decrease.\nYes, it would make sense if the perf utilities set this option to the value of the provided msg size argument.\nThanks for quick response!\nJust for my understanding, is it bad to have the value of this option at -1 by default?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Having spent a bunch of time in this; I'm convinced that the problem is more or less intractable to solve in the current architecture -- that is, events can get queued in messy ways, and adding \"tests\" to ensure that we don't queue an event \"after\" the appropriate time is difficult to say the least.\n\nThe reason for this is that the act of shutting down a state machine involves sending events, which is itself conflated with the individual \"shutdown\" actions of the various state machine users.\nHaving said that, looking very very carefully at the structure of all this, I believe that we can safely stop worrying about these.   The events themselves may get \"abandoned\" on a queue where they cannot be used, but these are generally all statically allocated, or allocated within larger contexts, such that the fact they are orphaned is ultimately quite harmless.\nThe simplest solution here is to simply remove the assertion check.  Admittedly that's not a very satisfying answer, since other queue consumers should be more careful.  But until we can fix or replace the FSM machinery, I cannot come up with a better solution.\nAnother, possibly better, solution is to conditionally remove the event item from any list it may be on, as part of the event termination process.\nIn fact, that's what I'm going to do.\n. Well, scratch that.  It turns out that removing the item from the list its on is ... non-trivial.  This is because the FSM and CTX implementation don't share well.  Furthermore, attempts to replace the queue with a saner doubly linked list uncovered further problems, as data structures are copied blithely.  (You can't copy a list that uses a sentinel, since the sentinel address will change.)\nSo for now, nn_fsm_event_term() simply will not bother to do nn_queue_item_term().  This allows other queue consumers to get the benefit of the check, while eliminating the main problematic case here.\n. That's unfortunate. gmtime_r is a posix standard.  It's probably possible to replace with gmtime and a lock though?\nIt's strange because mingw claims to aim for posix level apis. \n. Ah, I think maybe the problem is your use of cmake & mingw.  Maybe ./configure is better here?  I'm not sure... I know next to nothing about the mingw environment.\n. I'm not going to fix this nor accept it.  When I added work to try to get mingw to compile winsock properly, the whole thing failed.  Sorry.  Use Visual Studio.  It's free, and I simply have no interest in trying to support the bastardized environment that is mingw.  (In particular mingw exposes neither the full Win32 API, nor a POSIX API, leaving the subset unusable.)\n. On other platforms, POSIX_C_SOURCE actually suppresses a bunch of definitions that are not part of POSIX.  Could this actually _hurt us by suppressing some features that are otherwise present?\n. Canceling this.  I have no idea how to fix the next round of complaints from Winsock, and I frankly have no interest.  MinGW is too much of a special snowflake, and fails to expose the real Windows API, without really exposing POSIX either.  As a result, its totally useless for this work.\n. I've filed https://sourceforge.net/p/mingw/bugs/2274/ against mingw.  Who knows if they will fix, or how long it will take, but they (or someone else) are going to have to take the lead on fixing,  In the meantime, MinGW is a no-go -- Use VS.\n. Wow.  That test code looks -- bogus.  -1 gets cast to an unsigned size_t, and yes, the result is an attempt to allocate a message that is far far too large.  I cannot imagine what this code was trying to do (I am no the original author).  Probably we should just reject attempts to realloc to values that are too big -- I'd argue arbitrarily that if the high order bit is set then its too big for sure.  (I.e. it started as a negative value.)\nThat said, I do see some effort to check for this in nn_chunk_realloc().  Unfortunately I think those checks may be busted.\n. What version of windows are you using, as we don't see this fail in AppVeyor.\n. Weird.  I guess I don't see this on Windows Server 2012 R2, but I don't know why.\nThat said, both the test, and the guards for it in chunk.c, look kind of fishy.  I wouldn't worry too much about this; unless you do something stupid in your application to ask for negative sizes (or giant sizes > 2GB) you shouldn't see a problem.\n. NVM.\nThe problem is that MinGW fails to define WSAID_CONNECTEX, LPFN_CONNECTEX, PIPE_REJECT_REMOTE_CLIENTS, MSG_WAITALL\nI have zero interest in \"fixing\" the borken mingw environment.  It may be good enough for using the subset of the API that exists on WinXP or older, but it isn't good enough to support modern APIs, hence it is useless for us.\nUse Visual Studio on Windows.\nBtw, for the record, for AppVeyor we would need this path to test:\nPATH=C:\\windows\\system32;C:\\windows;C:\\Program Files\\Git\\cmd;C:\\Program Files (x86)\\CMake\\bin;C:\\MinGW\\bin;C:\\Program Files\\AppVeyor\\BuildAgent\n. Well, crap.  This caused other problems.  my guess is that its due to bad tests.\n. Resolved in\ncommit e9343578ce0dc4e3b42adb141ba10ee0bd1f5b4c\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Mon Nov 16 15:56:08 2015 -0800\nfixes #521 Multiple Devices are not working properly REQ/REP\n. Please don't use inproc. Due to another bug it fails to transport message headers. \nSent from my iPhone\n\nOn Nov 22, 2015, at 4:49 AM, keshav105 notifications@github.com wrote:\nISSUE: We have written piece of code to communicate client and server with the help of proxy. when we are trying to have TCP connection between proxy and server then we are facing following few issues.\nNote here following sockets are assigned to server , proxy and client.\nServer \u2192 sock0\nproxy \u2192 sock1, sock2\nclient \u2192 sock3\nconnect           bind                                      connect                        bind\nsock3 --------------> <---------------sock1 sock2-------------------> <--------------------sock0\nclient Proxy Server\n1) when sending msg of size 12 from server its hanging at client side mean not able to get any msg at client side.\nFor example. Please check OUTPUT: when buff size is 12 and connection is TCP.\n2) when sending msg of size 12 from server its failing when trying to receive at server side..\nFor example. Please check OUTPUT: when buff size is 12 and connection is INPROC.\n// Standalone code for nanomsg.\nclass NNHTest : public ::testing::Test\n{\npublic:\nnn_helper_t proxy_st ;\n};\nstruct info_my_param_t\n{\nint sock1;\nint sock2;\n};\nstatic void * loop_device( void* args )\n{\nint rc;\nstruct info_my_param_t * imp = (struct info_my_param_t *) args ;\nrc = nn_device ( imp->sock1, imp->sock2 );\nprintf(\"value of rc = %d\\n\", rc);\nreturn NULL;\n}\nTEST_F(NNHTest, ProxyBroadcastReqResp )\n{\nint rc ,nnbd, con;\n//step 1. server init\nint sock0 = nn_socket ( AF_SP , NN_SURVEYOR );\nprintf(\"value of sock0 = %d\\n\", sock0);\nnnbd = nn_bind ( sock0 , \"tcp://127.0.0.1:6799\" );\n//nnbd = nn_bind ( sock0 , \"inproc://SERVER\" );\nprintf(\"value of nnbd = %d\\n\", nnbd);\n//step 2. proxy init\nint sock1 = nn_socket ( AF_SP_RAW , NN_SURVEYOR );\nprintf(\"value of sock1 = %d\\n\", sock1);\nnnbd = nn_bind ( sock1 , \"tcp://127.0.0.1:6699\" );\n//nnbd = nn_bind ( sock1 , \"inproc://CLIENT\" );\nprintf(\"value of nnbd = %d\\n\", nnbd);\nint sock2 = nn_socket ( AF_SP_RAW , NN_RESPONDENT );\nprintf(\"value of sock2 = %d\\n\", sock2);\ncon = nn_connect ( sock2 , \"tcp://127.0.0.1:6799\" );\n//con = nn_connect ( sock2 , \"inproc://SERVER\" );\nprintf(\"value of con = %d\\n\", con);\n//step 3. proxy loop start\nstruct info_my_param_t imp ;\nimp.sock1 = sock1 ;\nimp.sock2 = sock2 ;\nstruct info_my_param_t ptr = (struct info_my_param_t *)memdup( (char)&imp, sizeof(struct info_my_param_t) )  ;\nrc = pthread_create( &proxy_st.threadid, NULL, loop_device, ptr  );\nprintf(\"value of pthread_create rc = %d\\n\", rc);\n//step 4. client init\nint sock3 = nn_socket ( AF_SP , NN_RESPONDENT );\n printf(\"value of sock3 = %d\\n\", sock3);\ncon = nn_connect ( sock3 , \"tcp://127.0.0.1:6699\" );\n //con = nn_connect ( sock3 , \"inproc://CLIENT\" );\n printf(\"value of con = %d\\n\", con);\n//step 5. server sending data\nchar buf[] = \"TEST_STRING\";\nrc = nn_send ( sock0, buf, sizeof( buf ), 1 );\n printf(\"string send by server nn_send rc =%d, buffer = %s\\n\", rc, buf);\n//step 6. client recv data\nchar buffer[256];\nmemset(&buffer, 0x00, sizeof(buffer));\nsleep(1);\nrc = nn_recv ( sock3, buffer, sizeof(buffer) , 0 );\nsleep(1);\nprintf(\"string receive by client nn_recv rc =%d, buffer = %s\\n\", rc, buffer);\n//step 7. client send back data\nrc = nn_send ( sock3, buf, sizeof( buf ), 1 );\nprintf(\"string send by client nn_send rc =%d, buffer = %s\\n\", rc, buf);\n//step 8. server received data back\nmemset(&buffer, 0x00, sizeof(buffer));\nrc = nn_recv ( sock0, buffer, sizeof(buffer) , 0 );\nsleep(1);\nprintf(\"string received by server nn_recv rc =%d, buffer = %s\\n\", rc, buffer);\n}\nOUTPUT: when buff size is 12 and connection is TCP.\nkeshav@keshav-Latitude-E6540:~/clone/BD/Test/Shared/Core$ ./ubuntuRelease64/test-static --gtest_filter=NNHTest.ProxyBroadcastReqResp\nNote: Google Test filter = NNHTest.ProxyBroadcastReqResp\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from NNHTest\n[ RUN ] NNHTest.ProxyBroadcastReqResp\nvalue of sock0 = 0\nvalue of nnbd = 1\nvalue of sock1 = 1\nvalue of nnbd = 1\nvalue of sock2 = 2\nvalue of con = 1\nvalue of pthread_create rc = 0\nvalue of sock3 = 3\nvalue of con = 1\nstring send by server nn_send rc =12, buffer = TEST_STRING\nNote: Its hanging here.\nOUTPUT: when buff size is 12 and connection is INPROC\nkeshav@keshav-Latitude-E6540:~/clone/BD/Test/Shared/Core$ ./ubuntuRelease64/test-static --gtest_filter=NNHTest.ProxyBroadcastReqResp\nNote: Google Test filter = NNHTest.ProxyBroadcastReqResp\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from NNHTest\n[ RUN ] NNHTest.ProxyBroadcastReqResp\nvalue of sock0 = 0\nvalue of nnbd = 1\nvalue of sock1 = 1\nvalue of nnbd = 1\nvalue of sock2 = 2\nvalue of con = 1\nvalue of pthread_create rc = 0\nvalue of sock3 = 3\nvalue of con = 1\nstring send by server nn_send rc =12, buffer = TEST_STRING\nstring receive by client nn_recv rc =12, buffer = TEST_STRING\nstring send by client nn_send rc =12, buffer = TEST_STRING\nstring received by server nn_recv rc =-1, buffer = \nSegmentation fault (core dumped)\nkeshav@keshav-Latitude-E6540:~/clone/BD/Test/Shared/Core$\n\u2014\nReply to this email directly or view it on GitHub.\n. Ok I will write a test case and see if I can debug. \n\nSent from my iPhone\n\nOn Nov 22, 2015, at 10:21 PM, keshav105 notifications@github.com wrote:\nBut its not working in the case of TCP also. As already mentioned its hanging.\n\u2014\nReply to this email directly or view it on GitHub.\n. Well, my test, which are derived from tests/device5.c, work fine.  I can pass both surveys and replies across multiple devices.\n\nWhat version of nanomsg are you using?\nI'll go ahead and post device6.c up so you can try it yourself.\n. Note especially that you must use either the version head from git, or v0.8 (or later, though 0.8 is the latest).  Earlier versions of nanomsg (including 0.7) probably won't work at all.\n. So the change I posted for #547 add this test.  Please have a try yourself.\n. And I believe that this is the same as problem #521 -- and probably fixed by the same commit:\ncommit e9343578ce0dc4e3b42adb141ba10ee0bd1f5b4c\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Mon Nov 16 15:56:08 2015 -0800\nfixes #521 Multiple Devices are not working properly REQ/REP\nAs I said, I cannot reproduce your results on the latest code base.\n. Well, this is interesting.  I've seen one hang on Linux here, but other times it just works.  And it fails consistently on Windows.  I don't understand what is going on here, but I don't think its header file misparse.  Something else is happening.\nI'd appreciate help from someone more familiar with Windows in debugging this.  I have a theory that we have some kind of limitations on port #'s or number of active TCP sessions in AppVeyor.  To be honest, TCP testing on Windows seems really really fragile, where one program even causes other programs to fail badly in ways that I don't understand.\n. I\u2019m not sure I can reliably repro it on Linux yet.\nOn Mon, Nov 23, 2015 at 11:55 AM, keshav105 notifications@github.com\nwrote:\n\nSo you mean to say, you are able to reproduce this issue in Linux ??\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/544#issuecomment-159045273.\n. I saw one hang in device6 which may have been this, or may have been a port\nconflict (TCP) or something else.\n\nOn Mon, Nov 23, 2015 at 11:58 AM, Garrett D'Amore garrett@damore.org\nwrote:\n\nI\u2019m not sure I can reliably repro it on Linux yet.\nOn Mon, Nov 23, 2015 at 11:55 AM, keshav105 notifications@github.com\nwrote:\n\nSo you mean to say, you are able to reproduce this issue in Linux ??\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/544#issuecomment-159045273.\n. It does not reproduce at all on MacOS X.\n. TBH, I think the epoll implementation of efd on Linux is somewhat buggy.  I wish I could abandon that crap and just use ordinary poll() instead of these 'newfangled' interfaces that I think cause more problems than they solve.\n. It definitely hangs sometimes -- please let me know if device6.c (in the latest repo as of this morning) hangs for you reproducibly.  Its a very small test case, so knowing it fails will tell me something.\n. Ok, I've done some more testing, and I could occasionally reproduce this on Linux on my VM.  One test in about 5 to 10.  Increasing the startup delay after nn_connect() to 200 msec solves it though.  The issue is TCP slow start.\n\n\nWe don't see this with REQ/REP, because we queue those requests for delivery as it is guaranteed delivery, whereas for SURVEYOR, if there is no respondent, the message is dropped on the floor.\nIncreasing the delay in device6 to 200 msec solves it.\nYou probably need to add a delay as well.  You can't connect and immediately start sending; you have to wait for TCP (or whatever) to establish the connection before you send messages.  This is a well understood property of \"TCP slow start\".\nI'm going to change the test to add the 200 msec startup, and close this bug with that test result.\n. Well, crapola.  It still hangs on Windows.  But works 100% of the time on Linux now.  I think this may be another case of too many TCP connections on Windows == fail.  Or possibly, Windows needs longer (more than 200 msec?!?!) to establish a TCP connection.\n. YEP.  200 Msec isn't enough.  Waiting a full second works fine.  Yikes, that's just very very sad.  At least for people stuck on Windows.\n. Well if it didn\u2019t fix the issue, it dropped the occurrence rate from ~1/5\nof the time to something less than 1%.  I ran several hundred invocations\nwith no reproducibility.\nAnd since this isn\u2019t in an otherwise concurrent part of the code, there is\nno particular reason for me to believe that it is explainable for any other\nreason.  And yet, the TCP slow start explanation can be used to address\nboth this failure mode, and the reason why we didn\u2019t see it with REQ/REP\n(because that mode includes reliable delivery features in the pattern,\nwhereas SURVEYOR just drops the messages.)\nOn Mon, Nov 23, 2015 at 3:11 PM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nYEP. 200 Msec isn't enough. Waiting a full second works fine. Yikes,\nthat's just very very sad. At least for people stuck on Windows\nIs this really the root cause? Surely not. Does increasing time to\n1000msec (1sec) fix the issue every time reliably? If so, you might be\nright here, but I suspect in that case time is just masking a more precise\nroot cause.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/544#issuecomment-159097172.\n. I think it's a side effect.   I don't even know what that library is for.  (Linux isn't my preferred platform.)\n. Ah.   Ok.  Yeah doing name resolution is another thing that IMO was best left outside of the library. But whatever. \n\nSent from my iPhone\n\nOn Nov 22, 2015, at 9:19 PM, sustrik notifications@github.com wrote:\nIIRC is it used for asynchronous DNS queries (getaddrinfo_a).\n\u2014\nReply to this email directly or view it on GitHub.\n. This was a question, not really a bug.  I'm not going to worry about it -- if you don't like libanl, I think you need to configure nanomsg not to use async DNS lookups.\n. Yep, we've got some problems in ipc_stress.  Perhaps I reenabled it too soon.  Hopefully we'll figure it out.\n. I think the problem is incorrect synchronization with atomics.  The code is too clever by half, and kind of broken.  Stay tuned.\n. Ephemeral ports have their own problems -- the port can be in use, after all!  Unless you allow the OS to choose one for you.  That creates a whole mess of other problems, and frankly I wouldn't be surprised if this creates other portability heartaches.  Trying to support testing this on all platforms is making me hate this project.\n\nThe tests CANNOT be run in parallel; that is, you cannot run a bunch of tests together at the same time.  That's not thread safety, that comes from requirements that the tests be able to use/reuse resources, and that one test not impair the operation of another.\nI'm extremely unlikely to spend much if any time resolving this.  The acceptance tests run serially by default.  If you're trying to do them in parallel; stop.  Not a bug.  A design feature.\n. Btw, please do not confuse multiple threads (where one program runs many threads) and multiple concurrent processes.  The problem you're talking about is multiple processes (parallel test execution), vs. multiple threads.  (The original problem was actually a real bug that occurred even in serial testing, which is why I fixed it.)\n. Oh yeah, and a further problem.  Microsoft Windows platforms may do horrible, terrible, and nasty things when running multiple instances of nanomsg in parallel.  I'm pretty sure we've got those fixed, but the problem there is that we have to manage certain global resources in order to support making things winsock selectable.    I think I've ranted at length about how unfortunate this design requirement and the fallout from it is.\n. Closed this already.\n. Is this restricted to Winsock?\n. Oh, I see you answered that.\n. Note that I've noticed on Windows TCP slow start takes ~forever.  Like 200 msec is not enough!!  (But 1 second is.  I've not tried to narrow it further.  On Linux, 100 msec is usually but not always enough, and 200 is always enough.  100 is always enough on Darwin.\n. I wonder if this is TCP delayed ack -- 200 msec is the delayed ack time.  We need to become TCP_NODELAY by default, I think, and actually enable that.\n. Argh.  Ok, I guess I get to have fun debugging this.  The one error QUEUE_NOT_INQUEUE is known.  Closing that is going to take some time since its very very hard to reproduce.  If this Winsock is easier to repro, it will help.\n. It does indeed appear that you can repro it some times on Linux, since the Travis failure looks like a hang in this test case.  Oh joy.\nnanomsg is like the redheaded adopted special-needs step-child.  It keeps demanding my attention, pulling it from a zillion other things (natural children, etc.) I'd rather be working on (including, btw, mangos).  The adoption seemed like maybe a good idea at the time, but now over a year into it, I'm having regrets.\nI sure wish we'd get some other qualified volunteers to pitch in more. :-/\n. Ok thanks.  Efd bug most likely. \n. Good news, it reproduces on MacOS X, which means I won't have to go through insane hurdles to debug.\n. So I have a theory.  The theory is that we aren't waiting long enough for the nn_socket to bind/connect, and we're stuck waiting for that due to a left over item from the earlier invocation.  I think the problem here is that the transports may leave the TCP port in a mildly unusable state.\n. Interestngly enough, waiting a second after the nn_close of the sb before restarting the loop seemed to have alleviated the problem.\n. but maybe not conclusively.\n. Its a statemachine failure I think.  I'm pretty sure I've found it.  The state machines here are a twisty maze, and no wonder there are bugs here.  Argh.\n. Interesting.  So mangos reconnects winsock as well as TCP.  This is a deficiency in the winsock implementation, IMO.  Yet another reason to not use this implementation of the transport in production.\n. No, I meant that mangos will keep trying to connect or bind on failure.  We do that in mangos for all transports. not just a select few.  The problem here is that in libnanomsg we have to implement a state machine (from hell) for every transport.  So there is almost no code sharing and every transport has to figure the reconnect strategy out for themselves.  Which is why you don't have it in winsock.\nPort reuse can be a problem depending on which side disconnects, and if there are problems there with address use.  Google around for EADDRINUSE for a bit more detail here; the TCP state machine requires in some circumstances up to 2*RTT to ensure that no outstanding sequence numbers from an earlier connection can come back around and confuse things.\n. sorry, yes websocket.  Argh.\n. I am trying to debug this at present.  Believe me, nothing would please me more than to have someone else take point on this.\n. The sem_wait is on the termsem, its waiting for the EPS to all post their completion.  Some one isn't doing that.  I don't know why yet.\n. So looking at this, I see that aws state machines hanging off the aws for each of those connected sockets; at first blush it looks like the far end disconnect (close) didn't wind up causing the socket to close.  Or, perhaps we didn't close.  I'm not sure yet.\n. So another difference is that with websocket, the server only recvs, and doesn't try to send until it gets a client recv, whereas TCP sends a message in both directions.  This can leave a connected socket hanging.  The FSM probably doesn't detect a closed socket properly.   This is one of the major drawbacks to not having a proper blocking recv on the socket.  Eventing the close of the underlying TCP socket is a pain.  (Simple single threaded recv is much simpler.)\n. My brain is tired from tracing through FSM hell.  I'm going  to declare this is a Websocket bug and leave it in your court to fix.  WebSocket is experimental, and it needs to remain that way until at least it can re-establish failed connections (from the client side).\n. That said, the mangos WebSocket transport has proven itself to be quite robust and flexible.  So its not the nature of WebSocket that is a problem, but of the libnanomsg implementation limitations.\n. I don't think this is related to the long Windows TCP connect times.  It feels like something else there. \n. I integrated this already, after rebasing it.\n. Increasing the timeout is not a complete fix apparently, as we've seen at least one failure (out of four builds). \nIts interesting that this seems worse when inproc is implicated.  Thread safety there?\n. LINGER probably shouldn't be used with nn_term().  Probably.  But definitely should be used with nn_close().  (I'd like to see nn_term() shut everything down hard & fast.  Frankly, I think most applications should never use nn_term().  If I were redesigning the API, I would not even have offered it as an API; there's not much need for it, and apart from dealing with a couple of global arrays (modest memory size), there is nothing it really needs to do.\nConversely, nn_close() should be called by applications properly.\nActually, if I were designing this from the get go, nn_socket() would return a pointer, and we wouldn't need nn_term() at all, as there simply wouldn't be any global resources to free.\nNow, having said all that, implementing NN_LINGER is a non-trivial task in the current code base.  The problem is that you now add some new states to pretty much every state machine in the entire code base, and you have to give time for each of those state machines to properly linger / drain.\nYet another case where the FSM centric design is lethal to maintainability.\nI'll welcome someone to submit a PR that goes towards this, but at the moment I'm likely not to make such efforts in that direction myself.  Frankly, the effort of implementing NN_LINGER is probably roughly similar to the effort to a complete rewrite using a saner architecture, with some different API design goals.\n. I will take look at this.  I thought I was careful about the locks here. \n. Looking at the code, it looks like yeah, I probably screwed that up.  Go ahead and fire off a PR.\n. I think I meant to have these be nn_global_sock_rele(), but in retrospect just moving the release of the global lock ought to be adequate.\n. It is now confirmed that this is not resolved by fixing #560.  This looks like some other problem. \n. This problem does not seem to show up on Travis, but its very reproducible on AppVeyor.  Wonder if the number of underlying threads is part of the issue, or is it a difference in the notification behaviors we use for Windows vs. other platforms?\n. So cautiously hopeful, but PR #562 looks quite promising.  Basically the problem is that in nn_term we didn't really shut things down properly, which caused bad stuff to happen.   I really don't like the nn_term() API at all, but if we're going to have it, we need to do a better job of making it work properly.\nThe solution was to enhance the state machines to properly handled the ZOMBIE state a bit better, and to clean up our end points in nn_term.  Stay tuned.\n. Uhg.  There is an inherent race in the efd logic, and I cannot think of any clean way to solve it that doesn't involve changing the code utterly and completely.\nBasically the problem is that poll() can hang indefinitely if you attempt to poll on a descriptor that is either closed, or has a far end closed.  So closing the descriptor can race against the call to poll in another thread, with the result that the logic can hang if the poll() calls arrives after the close().\nWe have no way to wake the thread blocked in poll.  We can't lock, because the lock is across the poll.\nSending a single message doesn't solve it either, because the that's edge triggered.  And I cannot think of any way to make a level-triggered mechanism on top of poll() that doesn't suffer from this inherent race.\nWhat we really want is semantics sort of like condition variables, where a lock is atomically dropped while we wait.   I have no idea how to get those semantics across the user/kernel boundary, at least in anything resembling portable code.\nWhat might work well here is to fire up a blocking thread that just sits in read().  Closing the far end descriptor (without closing the read side) results in a situation where read() always returns 0.  In other words, I think this would be race free.  Unfortunately I'm not sure how to make this work with timeouts; that is I'm not sure how to socket operations timeout when the eventfd has no data on it.\nTo be honest, all of these evils come from making the socket descriptors poll() and select() usable.  If not for that requirement, I could simply use ordinary synchronization primitives and be done with it.\nIt may be worth looking at separating the file descriptor used, so that I create the eventfd only when the user requests it with the options.  Alternatively, getting the eventfd logic out of the hot code path, so that we use condition variables and mutexes for our internal signaling instead, may be a substantial improvement.\nHmm... maybe if we didn't unsignal the socket...\n. The problem is that ~all the various language runtimes use it under the covers.  I can't remove without breaking pretty much ~everything.\n. I could remove it on Windows, maybe.  But only on windows.\n. Yep.  I hit other problems though.  I probably have to step away from this for a few days.  It's really too bad it's so difficult to regain context on this code after even a short time away... \n. I agree that we must not crash in the face of protocol violations but instead drop the connection.  Logging it or bumping a stat is also a good idea.  I use this approach in mangos as I designed it to be robust from day one.  Libnanomsg was sadly not designed with any thought to security or robustness in the face of malicious peers.  This is something we need to fix. \nThat said the fix for #443 was correct for that bug.  However we should ALSO have the mechanisms you propose here in the various places in the code. \nI'd like to go through and audit all the assertions in the code at some point.  Asserting on content sent to you by a peer is WRONG.  The use of asserts should be restricted exclusively to conditions contained within the address space and under absolute control of the library to ensure. \nA corollary to this is that there should be a lot fewer assertions combined with more robust runtime protocol validation. \n. I'm closing this -- we agree on the design principles -- but until we have specific issues -- presumably uncovered by a full code audit or extensive testing, there isn't a specific deliverable here.\n. There was a PR submitted for this #348.  I closed it as the author of it has stopped working on libnanomsg, and the code doesn't merge cleanly, and I am not enough of a Windows guy to take it on myself.  If you want to pick this work up, clean it up, and submit a new PR, I'd be happy to accept it.\nIn the meantime, I recommend you use TCP instead, if you can.\n. Thanks for cleaning this up.  See my comments on the test suite, though, and you should change to using a transport socket option instead of a socket layer option. \nFor an example, look at how we set NN_WS_MSGTYPE in the websocket transport.\n. Oh yeah, eventually this need to be rebased into a single commit, too.   I try to have each integration into the code base be code complete; we don't expose the sausage factory behind each feature or bug fix to downstreams.  (This also means, btw, that we're trying to get to an \"always release ready\" state, where any arbitrary bisect or checkout can be used to get a functional nanomsg.)\n. Do an interactive rebase and you can squash the commits.\n. I'm looking at this now.  Sorry, but I'm not paid to work on this, so it takes time sometimes.\n. I've merged this in, after editing the commit comments:\ncommit c621fb490699dbae8594135f324edb13fb8dc64d\nAuthor: Timothee 'TTimo' Besset ttimo@ttimo.net\nDate:   Tue Sep 16 09:10:17 2014 -0500\n```\nfixes #556 Support security attributes for Windows IPC\nAllow passing security descriptor to the ipc channel in Windows.\nThe tunables NN_IPC_SEC_ATTR, as well as NN_IPC_OUTBUFSZ and\nNN_IPC_INBUFSZ are exposed on Windows when using the named pipe\nbased IPC.\n```\n. This feels right to me.  And shame on me for screwing it up in the first place. Thanks for digging in and fixing.\n. I'm inclined to accept this PR, but I'm not yet convinced it is the fix for #554.  It may be, and it may also fix the QUEUE_NOTINQUEUE assertion failures too.  (In fact I think this is pretty likely either a fix, or a big improvement.)\nSo what I'd like to do is open a separate bug, indicating that the lock should be held (synopsis like \"Socket release needs to be done under lock\") and then wait and see if we can close the others based on more testing & time.\nWhat do you think?\n. I think this may fix #528 \n. I went ahead and commited this as\ncommit fd66ff55a5bad44ea0c3cca8bea345b6f02663bf\nAuthor: Jack R. Dunaway jack@wirebirdlabs.com\nDate:   Wed Nov 25 16:26:08 2015 -0600\nfixes #560 Socket released without global lock\n. This is not the root cause for #554 - we still see those failures.  Still, the fix is \"good\" in that it closes what could clearly be a race.  I think more likely an nn_close() race than an nn_term() race though.\n. This looks like the change issued with #487   Sadly I'm not sure what is correct right now... it seems like we have some disagreements about pkgconfig.  I don't actually use that tool.\n. So it looks like your pkg-config flags for -I are wrong.  Don't say \"include/nanomsg\", but just \"include\".  Did you supply the -I option to pkg-config by hand?\n. I'm closing this for now.  Feel free to reopen when you're prepared to provide more info.\n. Huh.  In retrospect I think we got this wrong.  Applications should indeed include  or whatever.\n. Whoa.  Got a segfault in device7 this time.\n. I'd had much the same thought.  However my concern is library and runtime consumes that may desire a handy way to just shut everything down as other wise they need to keep track of every socket. \nApplication code should do this sure.  But it's those frameworks that I'm worried about.  I'm not quite ready to throw in the towel on nn_term. \n. So I've not looked this all over yet, and its going to take some time.\nReally, I'd like to have the autobahn test suite as a separate PR from the other fixes.  I realize you're doing this work together, but once you've got it working, how hard do you think it would be to separate those?\nI've got some pretty mixed feelings about enabling autobahn by default.  Having to run sudo for the tests means that CI is going to take longer since it cannot use containers.  Its also going to make life harder for other folks.\nAt the end of the day, strict autobahn conformance is one of those things that seems \"nice to have\", but not entirely necessary, provided we interoperate with other websocket implementations.\n. As long as they run Docker, it isn't going to get fixed, because Docker isn't true isolation (unlike e.g. Solaris zones.)\nI'd still prefer to avoid requiring sudo.  Why does autobahn require this?  Is it for binding to port 80/443?  (And can that be changed, if it is?)  Or is it something else?\n. Does installation require root for some reason (why)?  I mean, its fairly typical that we can install software in the Docker instance without problems...  You might need to select a different destination directory, but usually that's not too hard to do...\n. Check this: http://kazhack.org/?post/2014/12/12/pip-gem-install-without-sudo\n. So how have you confirmed this fixes the problem?  I've not had time yet to analyze the code, although your change seems low risk to me.\n. So given that response, I'm inclined not to rush this in, but to wait until I have some more time to do a complete analysis to verify that this is indeed the correct fix.\n. Looking at this, I can see ways this can happen.  For example, if the remote peer closes the connection, or someone else closes the connection, just after a receive is done.  Given that this is a shutdown/race close most of the time, this aligns with the expectation.  I'm going to go ahead and merge this, because the changes look good.  The only thing I've not been 100% certain about was whether the assertions you've included are actually true.  I think they, and if they're not, it will be good to know.  (If someone triggers either of those, we can consider other actions, which may include removing the assertion, fixing the bug, or backing this change out.)\n. I've updated the comments, and pushed as:\ncommit c0e92dd84f0263fb4f2ad504dd7ccbdf42a24c21\nAuthor: Jack R. Dunaway jack@wirebirdlabs.com\nDate:   Wed Dec 2 20:47:30 2015 -0600\nfixes #568 ipc_shutdown still fails sometimes\n. Sorry, running a little behind, as I've had little time to work on nanomsg this week.  Maybe later today, but more realistically sometime this weekend or even early next week before I get to verifying, reviewing code, and merging.\n. You'll need to resolve the conflicts, and I'll take some effort to review the actual code changes.  Were do we think we are on readiness for this?  Originally we talked about separating the test cases from the new state machine work you did for websocket.\n. Which version of the compiler did you see this on?  I've not seen this on appveyor builds.\n. So its the static code analyzer that is trigger this.  We probably aren't testing for this.\nThis is the sort of thing that makes multiple platform support kind of a pain; the Windows and WinSock semantics are just different here. :-(\n. I think this might be fixed now... can we double check, and close if appropriate?\n. It's still an issue.  A better approach would be to make a new nn_assert_valid_fd() that is defined appropriately on Windows.\n. I'm probably not going to mess with this.  With nng I have a completely separate Windows layer that suffers none of these problems.. I'm going to go ahead and fix this by just removing those assertions -- they don't really add value.. So you'd have to implement various topology management bits in your application code.  So, this would represent the bulk of the effort.  This falls outside of the normal scope of nanomsg, which itself is just a framework.  I don't think its likely that anyone will be adding that to libnanomsg itself anytime soon, but someone could build an unbundled add-on that sits on top of libnanomsg.  Again, you'll need to figure out how to manage topologies dynamically, and you may need to actually hand code various router/dealer algorithms.\n. Tentative fix to a periodically-observed failure in ipc_shutdown: https://travis-ci.org/nanomsg/nanomsg/jobs/94521740#L877\n. I confess I'd really like to break out the autobahn tests into a separate PR.  That's the main hesitancy here. I've not gone through it all yet.\n. So I noticed that in #578 you still didn\u2019t quite achieve the 1 bug = 1\ncommit.  I\u2019m a bit unhappy with that \u2014 as part of good hygiene, we should\nbe able to point at a single commit when determining whether a bug is\n\u201cfixed\u201d or not.  Its nicer when we don\u2019t have multiple issues in the same\ncommit, but frankly bundling multiple issues into a single commit is less\nbad than spreading a single issue over multiple commits.\nMaybe you should file separate issues for your test suites?  I\u2019ve not\nreviewed the separation of the commits, so I\u2019m not sure whether that\u2019s\nbetter, or if its better to squash them.  Each commit needs to be\n\u201cwell-formed\u201d and \u201ccomplete\u201d though, so that any point can be used for a\nbisect meaningfully.\nOn Tue, Dec 15, 2015 at 8:51 AM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nI'd really like to break out the autobahn tests into a separate PR\nUnderstandable -- once #578 https://github.com/nanomsg/nanomsg/pull/578\nis mainlined, I'll clean up this PR to be only Autobahn TestSuite, fully\nsquashed into a single commit.\nThat said -- what are options for mainlining this \"big\" dependency that\noptimally 1) helps the library by being run yet 2) remains transparent in\norder to not burden the rest of the dev process?\nLike the Documentation and also Diagrams in this repository, which are\nopt-in based on whether you have the additional dependencies already\ninstalled, so is this test.\nWhat about informing Travis CI and AppVeyor to only run this WebSocket\ntest on a certain branch? Or only on PR's? Or only when tagging to create a\nrelease? (or some combination thereof)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/569#issuecomment-164824601.\n. Well, let me put it this way.  I want to get these changes, and I\u2019d like\nthem to reflect the actual changes.  Let me give you my thoughts in more\ndepth:\n\nfirst commit is a clear bug of its own: synopsis should be \u201callow for\ndifferent test-specific timeouts\u201d\nsecond commit: (which Imo should be added after the fix it tests for),\nshould be \u201cProvide async nn_close test for websocket\u201d\nthird commit: \u201cfix occasional deadling during nn_shutdown in websocket\u201d\nfourth commit: can stand on its, but could be squashed into the third\ncommit \u2014 except it seems nothing actually uses it?  Maybe we should reject\nthis change until a consumer exists for the change?  Oh wait, the next\ncommit includes a test for it:\nfifth commit: that\u2019s the main websocket fix\nsixth commit: squash together with the fifth\nSo I\u2019d squash commits 4, 5, and 6, and have the others stand apart.\nI can go ahead and do this myself, except you\u2019ve indicated that this would\ncause you grief\u2026\nOn Tue, Dec 15, 2015 at 11:39 AM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\na bit unhappy\nCan you live with it? The opportunity cost here is momentum. I generally\nagree with the tracking policy of commits and bugs, but recent development\nin these commits is more of a continuation of initial development that\nstagnated, rather than a patch for a defect or upgrade to a stable feature\n(where that sort of traceability is more valuable).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/569#issuecomment-164869925.\n. Changes look good to me.  I'm going to collapse this into a single commit, and associate with a bug.\n. Merged here:\n\ncommit 54bc5b83240e3afee0a79d3196e650ca4d6df0eb\nAuthor: Marc Balmer marc@msys.ch\nDate:   Thu Dec 10 10:43:30 2015 +0100\nfixes #572 Numerous grammar issues in documentation\n. I think you are trying to make nanomsg something it isn't.  Blocking if full vs. available is simply not reasonable to do with pub/sub or any multicast type network -- because it means a slow consumer can prevent timely delivery to other consumers.\nI'm pretty opposed to such approaches. \nIf you have some other need for reliable delivery, then you really shouldn't be using pub/sub.  req/rep is ideal for that use case.\nExtending this to provide history, and optional playback for multiple subscribers is interesting, but out of scope for nanomsg -- though such a true MQ could be built using the SP protocols using libnanomsg.  But no single one of these SP patterns in libnanomsg is appropriate on its own -- you'd probably want/need multiple.\n. I'm going to close this -- desired functionality is out of libnanomsg scope.\n. So I'm confused what it is that you're trying to achieve here.  Why do you want to \"decouple\" these?  Routing is intrinsic to sending. \nGive me a better description of what it is you actually want to achieve, and we can discuss if its appropriate for libnanomsg. \nlibzmq has taken the approach of trying to be the answer to all problems anyone has.  It suffers as a result, and that approach is part of why libnanomsg exists.  libnanomsg is a messaging library for a set of well known and common patterns.  If you've got a pattern that fits within the scope, but isn't well represented by the existing code, we can certainly discuss.\nTraditional pub/sub is always best effort; its not a message queue.  Maybe that's part of the disconnect?\n. I don't recall anything recent to the nanomsg list about this.  How long ago did you post?\nYou still didn't provide a real answer to what I asked for which was a use case.  Tell me what you need to achieve not how you think you want to achieve it. \nMy instinct here is that tunable levels of delivery \"effort\" are mostly meaningless. Only req/rep can offer a guarantee and that is because there is an ack that is initiated by the app (rep). No other guarantees actually mean anything really. \nI'm having a difficult time understanding any use case here for middle levels of effort that don't involve substantially complicating the protocols (adding acks) or imposing s storage requirement or ultimately leading to heartbreak due to broken promises. \nSent from my iPhone\n\nOn Dec 16, 2015, at 6:22 PM, memeplex notifications@github.com wrote:\nThere was a large exchange in the mailing list, I've written a couple of long posts there. The main point was to provide a gauge on confidence and risk aversion of the sender regarding reliability of the receivers by means of a timeout, as a general mechanism defaulting to fully unrealiable in the cases of pub and rep, and to fully reliable in other kind of sockets. I will be glad if you read the posts.\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks for the links.  It seems I didn't receive nanomsg list email recently so I have to figure that out. \n\nIn the meantime I understand the use case.\nI think this approach leads to heartache as people will begin to believe that it can be used for some kind of reliable multicast which is fundamentally impossible without an ack protocol. Usually also a side unicast channel is used. \nUnlike zmq it should be noted that \"routing\" in nanomsg is implemented as a receiver side filter.  We don't know which channels are interested in a message on the sender side.  So we have to block behind every receiver in the channel.  \nSure there are use cases for this as you've noted.  But those aren't really live and they require extra care on the part of the user. \nThe systems that I know that need this for eg training or replay would do so using a saved history file rather than continuing to use an unreliable transport. \nOr they use some kind of unicast synch protocol to catch the subscribers up.  (Note that this requires storage on the server.)\nBasically at the point you're doing this you don't want the pub sub semantic at all.  \nWe could indeed use a form of back pressure on the socket based on all pipes be able to accept a message, but I fear that such an approach is half baked and will only cause more heartache later as people try to use it as some kind of reliable transport which is not what it is. \nI'd be inclined to enable such a mechanism only if a new option were used to enable it - something like NN_WEAKEST_LINK to indicate that the slowest subscriber can halt the entire system. \nAnyway I think a big part of the problem is that you're trying to fit a square peg into a round hole. \nI will think about this.  I'm also open to considering a PR that adds this behavior.\nThe reality is that right now I have enough other issues to resolve in nanomsg that it's unlikely I'm going to try to address this unless someone else provides a PR. \n. So NN_WEAKEST_LINK would be for any multicast type distribution.  For protocols that are strictly 1:1 (PAIR, and PUSH/PULL) I think the existing timeout options already work, and this shouldn't be needed.\nThe multicast protocols are PUB/SUB, BUS, and (mangos only) STAR.\nThis absolutely would NOT apply to REQ/REP.  We already have both timeouts and reliable (ack'd) delivery for those protocols.\n. Well, actually, only REQ is ACK'd, but the synchronous nature of REP means that REP should never be flow controlled behind a REQ.\nUnless one is using raw sockets.  Then all bets off, because you have multiple outstanding REQs.  I have no idea how you deal with that.\n. But even if the REP is dropped, the lost ACK should cause the REQ to try again.  You'd best be sure that your requests are idempotent though.\n. I wonder if we could take this in ahead of the autobahn test work.  I think PR #596 still has some issues, and I hate to have other stuff get \"stuck\" behind that.\n. I've not looked at the code you've changed yet,but I'm agreeable to ditching support for autotools.  \nI'm gonna take in some of the changes in PR 596, the ones that aren't causing problems yet, just so we can make forward progress.\n. I generally support the idea. But a switch to cmake will require an additional release before we can release 1.0.  That said I've been on a little break from coding for the holidays. \nI do want us to fix the functional bugs asap. There are some nasty issues outstanding to be fixed before 1.0. \nSent from my iPhone\n\nOn Jan 2, 2016, at 1:47 PM, Rui Pacheco notifications@github.com wrote:\nWhile I can't contribute to the code I'd like to express my support for this change.\n\u2014\nReply to this email directly or view it on GitHub.\n. @JackDunaway can you update this -- perhaps you have a PR ready?  Even if it's just a start, that is something we can work with.  (I think I've started CMake cross-platform as well -- so there are probably ~4 separate started efforts -- lets consolidate and get it integrated asap -- we can start by adding and once everything passes well everywhere, then gut the autotools crap.)\n. Great.  Want to get this resolved soon.\n\nOn Fri, Apr 15, 2016 at 12:30 PM, Shiva notifications@github.com wrote:\n\n@gdamore https://github.com/gdamore @JackDunaway\nhttps://github.com/JackDunaway Cool. I will drop my effort around this.\nThis is going to make it much easier to convince folks within my company to\nuse nanomsg in the future. Will to help get the PR done if I can help.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/574#issuecomment-210607767\n. This was fixed here:\n\ncommit 5b34eb6467975ff4c444e2f8e1267bf01aba4b36\nAuthor: Jack R. Dunaway jack@wirebirdlabs.com\nDate:   Sat Apr 16 15:41:44 2016 -0500\n```\nfixes #647 Initial cmake support for non-Windows platforms\nThis change is the first step towards a unified CMake based build for\nall nanomsg platforms.  With this it is possible to build nanomsg\nusing cmake on at least Linux, MacOS X, illumos, and Windows systems.\nHowever, there remains work to be done, particularly with respect to\ndelivery of documentation and the nanocat binary.\nThe eventual goal will be to remove support for the autotools, and\nsettle on a single cmake based toolchain.\nThis work is the result of a collaborative effort by several authors:\nJack R. Dunaway (@JackDunaway), Garrett D'Amore (@gdamore),\nFranklin Mathieu (@Snaipe) and Shiva (@shiva).\n```\n. Looks like you never sent any data.  Probably this is the hash table leaking.  If so it shouldn't leak much beyond the 12 K you've already noticed. \nThat said I will take a look. \n. You're going to leak the nn_ins list.  That's unavoidable, unless you call nn_term(), which you have not.\nAdditionally, you don't need to call nn_shutdown() on the sockets, nn_close() should be sufficient.\nThat said, I'm not sure that the nn_sinproc_term() is ever called.  At least I am not able to see it.  I have some debug to do here.\nNote that the leak appears to NOT be tragic in that it doesn't leak per message, only a 12k leak for the socket.  That's bad, but most applications are unlikely to be affected by this.\n. I just haven\u2019t had time to work on it.  To be honest, its a small leak on a\nlittle used code path, and immune to remote exploit, so its not exactly a\nhigh priority.\nOn Tue, Nov 1, 2016 at 4:25 PM, James Masco notifications@github.com\nwrote:\n\nAny more information that could be provided here? Is this issue being\nworked or planned on being worked? Seems like the issue is known and could\nbe fixed. I'd really like my unit tests on my components that use nanomsg\nto be leak free, this is the only one I haven't been able to get rid of....\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/575#issuecomment-257729234,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfSukXIDmjjm_dC761sv0L--w7works5q58plgaJpZM4G0ii1\n.\n. I'm tempted to close this as will-not-fix.  The new libnng is free of this leak.. I'm going to reimplement inproc using socketpair().  Stay tuned.. Actually, pretty sure that instead we just ned to reap the connection sinproc on the side of the server.  Stay tuned.. There were changes here recently.  I'll look.  What version are you using ?\n. Please try 0.8 if you can. \n\nSent from my iPhone\n\nOn Dec 14, 2015, at 5:50 PM, Edwin Watkeys notifications@github.com wrote:\nMy man pages say 0.7-beta.\n\u2014\nReply to this email directly or view it on GitHub.\n. Sounds like nn_recv page needs updating. \n. But you get ETIMEDOUT back right ?  I recall that is what it is supposed to do.  The difference here is subtle.   EAGAIN is returned when a non blocking operation fails because there is no data yet. (That is it would block.) n ETIMEDOUT is returned when a blocking operation times out. \n. This feels like another instance of the bug in #603 \n. Yes, this is #603.  Again, if this comes bac, in Travis at any point after today, please reopen.  Otherwise closing it.\n. Thanks. I will review and merge (assuming no issues found) shortly. \n. Any commits you don't want squashed need to have issues clearly associated with them.  I don't like to have a given issue associated with more than a single commit. \n. I am seeing failures in the ws.c test:\n\ngarrett@Triton{233}% ./tests/ws\nAssertion failed: rc < 0 (../tests/ws.c:225)\nAbort\nAm investigating now.  (It looks like this may be specific to macos X, I'm not sure.)\n. It passes sometimes... not others.\n. I think maybe it depends on speed... if the peer takes longer to close the connection, then the async send may actually pass.  Need to inject a slight delay, I think.\n. Well, 100 msec isn't enough...\n. Right, the test code is broken.  The problem is that you're trying to capture an error on send, and that isn't going to pass.  Due to the async nature, we can pass only if the send occurs fast enough to pick up the case where we've marked the state as disconnecting, but before the state has actually disconnected.\nSend errors are not reported reliably for a variety of reasons, and code really shouldn't depend on them.  However, in our case I think we can improve this by ensuring that the queue size on send is zero.\n. Oh wait, queue size is a mangos thing, not nanomsg.  Argh.\n. Well, crap, I'm not ready to merge this because the test/ws fails, and its going to take more effort to understand the nature of the failure.  It looks like the code that attempts to test error codes for send is broken/fragile, because it can depend on the status of the state machines.\nPlease run manual tests if you can.  As I said, this reproduces not every time, but one in 5 or so runs.\nI think if we try to send before the disconnect occurs, it causes the problem, but I've not found that timing fixes this.\nThe other thing is, are we sure that the disconnects are actually occurring?\n. So rather than sending me a single big PR, lets take these one item at a time; yes its more work, but at least that way we can make progress.\n. I\u2019m running MacOS 10.11.2.  Otherwise, pretty stock.\nOn Wed, Dec 16, 2015 at 5:36 PM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nI'll try to repro on OS X -- I've not noticed it on the Travis or AppVeyor\nenvironments. Any specifics on your OS X environment that shows the failure?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/578#issuecomment-165309866.\n. I see you\u2019re on an MB Air.  I\u2019m using an high end iMac 27.  I wonder if the\nissue is that I have extra oomph available.  Since it seems timing related,\nI think that might be plausible.\n\nOn Wed, Dec 16, 2015 at 6:09 PM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\n10.11.2 here too ... I can't get it to repro after many runs (ran 10+\ntimes now):\n\nTestsuite summary for nanomsg 0.8-beta-18-g7607653\nTOTAL: 40\nPASS:  40\nSKIP:  0\nXFAIL: 0\nFAIL:  0\nXPASS: 0\nERROR: 0\n\nJack-MacBookAir13-Mid2013:featherweight-nanomsg jack$ git rev-parse HEAD\n7607653e3980b7736b145cf4abe9e4f969c61730\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/578#issuecomment-165315067.\n. I get maybe one error in 5.\n\nOn Wed, Dec 16, 2015 at 6:17 PM, Garrett D'Amore garrett@damore.org wrote:\n\nI see you\u2019re on an MB Air.  I\u2019m using an high end iMac 27.  I wonder if\nthe issue is that I have extra oomph available.  Since it seems timing\nrelated, I think that might be plausible.\nOn Wed, Dec 16, 2015 at 6:09 PM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\n10.11.2 here too ... I can't get it to repro after many runs (ran 10+\ntimes now):\n\nTestsuite summary for nanomsg 0.8-beta-18-g7607653\nTOTAL: 40\nPASS:  40\nSKIP:  0\nXFAIL: 0\nFAIL:  0\nXPASS: 0\nERROR: 0\n\nJack-MacBookAir13-Mid2013:featherweight-nanomsg jack$ git rev-parse HEAD\n7607653e3980b7736b145cf4abe9e4f969c61730\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/578#issuecomment-165315067.\n. Lets just remove that part of the test.  I don\u2019t think it matters.\nReliance on sendmsg() error codes is just fragile testing.  Can you fix\nthat, so that I can move ahead?\n\n\nAlternatively, I can cherry pick parts of your PR until we get to the\nfailing one.\nI apologize for my caution here, I just don\u2019t want to regress.  Things in\nthis code path are so complex, that accepting changes that I don\u2019t feel\nreally confident in is probably not a great idea.  We can get into a very\nbad state by letting too many of those in, so I prefer to be very defensive.\nOn Wed, Dec 16, 2015 at 6:34 PM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nGot the error, finally!\nAssertion failed: rc < 0 (tests/ws.c:225)\nThat particular part of the WebSocket test does more checks than the TCP\ntest.\nTCP: https://github.com/nanomsg/nanomsg/blob/master/tests/tcp.c#L183-L199\nWebSocket:\nhttps://github.com/wirebirdlabs/featherweight-nanomsg/blob/pr-ws-mega-squash-3/tests/ws.c#L199-L233\nHere's the analysis -- 1) either the test is valid, and we might expect\nTCP to fail in the same manner if it were tested in this manner, or 2) the\ntest is not valid, and is just subject to some inherent race condition, and\nthe test should be improved.\nEither way ... can we still move forward with merging? Even if that part\nof the test is broken, it's worthwhile to see it deleted in the commit\nhistory with rationale why it was wrong (rather than squashed)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/578#issuecomment-165318020.\n. NB. The conflict is as a result of cherry picking these commits.  Stay tuned.\n. Ok, I want to help with the cmake work too \u2014 so as soon as you have a PR\nready for testing, please let me know.\n\nOn Sat, Apr 16, 2016 at 8:54 AM, Jack R. Dunaway notifications@github.com\nwrote:\n\nRelated: this branch (and others) will be pruned from the\nhttps://github.com/JackDunaway/featherweight-nanomsg repository, meaning\nsome links above in GitHub may not work anymore.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/578#issuecomment-210845112\n. This is the first integration from PR #578.  I'm cherry-picking one at a time.\n. I'm actually pulling this out of the PR, because it appears that nothing uses it.  Just adding API for 'internal' use without internal consumption is not good -- you need to add at least one consumer at the same time.  This ensures that an example of correct use exists, and helps guard against pointless bloat caused by \"useful\" functions that aren't actually used.\n. We're off the track with this, and I've moved onto libnng.  Let's close this for now, and focus on libnng.. I think nn_term in the child is probably the best approach.  That said, I really don't see a perfect way forward here.\n. The other thing is that fork() can occur at any time, so we'd have to be sure that we can acquire the locks -- all of them.  I'm concerned of a potential for deadlock here.  Probably not a problem, since we don't fork from inside the library...\n. Having spent a bunch of time researching this, we cannot actually do anything legal and useful during pthread_atfork() because in the child we are not permitted to use async-signal-unsafe functions.  This means that the child side cannot use mutexes, and cannot do many useful things. (It could \"close\" some descriptors, but that's about the limit.)\n\nTo throw some more fuel on this fire, POSIX is basically abandoning this strategy, because its too hard to get right.  And, interestingly enough, posix_spawn() does not call these handlers for some platforms, so we can't even block things to close the close-on-exec flag races.\nIn the future we may actually go out of our way to do nn_panic() if you try to reenter the library from a fork'd child (that hasn't been reset via exec).\nFundamentally, we are not going to be fork-safe now, or ever. Sorry.. Thanks for that.  Looks like a regression in the new security attrs code.\nSadly not too familiar with these Windows APIs. I\u2019ll research and fix as\nappropriate, unless someone else beats me to a PR.\nOn Sun, Jan 3, 2016 at 4:34 PM, charliex notifications@github.com wrote:\n\nsrc/aio/usock_win.inc:96: memset (&self->sec_attr, 0, sizeof\n(SECURITY_ATTRIBUTES)); self->sec_attr is a pointer\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/585.\n. Yes, ETERM is right here.  I'm going to go ahead integrate this.\n. The code is now changed, so it only returns EBADF.\n. Historically, MacOS X was not part of the free Travis plan.\n\nOn Thu, Jan 21, 2016 at 1:58 PM, Franklin Mathieu notifications@github.com\nwrote:\n\nTo address the problem mentioned in my two above commands, I added a\ncleanup parameter to convey the intent of the destruction function. This\nhas led to a lot of changes on the codebase, and while current behaviour is\nmaintained with no fork strategies, there could be a few failure points\nthat may hit users of the reset fork strategy on some protocols/transports.\nI am going to add a more complete test for fork, over multiple transports\nand protocols.\nThe second thing that should raise the confidence that everything works as\nexpected would be to add OS X builds to the travis configuration (this\nshould speed up the development process as well for future PRs).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/587#issuecomment-173722093.\n. This sounds like a very same approach. \n\nSent from my iPhone\n\nOn Jan 28, 2016, at 7:38 PM, Franklin Mathieu notifications@github.com wrote:\nSeeing that there were almost 1400 changed lines over almost all sources, I decided to try another approach for this fix: Instead of immediately clean up with forceful/unsafe variants of *_term functions, I restore the library to a valid state by resurrecting the worker and the poller and locking the library in a more stable state before forking, before simply calling nn_sock_stop and nn_sock_term on all sockets.\nThis approach is much less intrusive on the existing codebase and has the distinct advantage of using the \"normal\" cleanup provided by the library rather than trying to hack through all destructors because all of them expect a valid state.\nThis works quite well on my end, tested with a heavy workload on a ipc+reqrep setup. I expect it to work everywhere since this approach is much more general than the old one, but I'll throw in some more tests to make sure.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes that's what I meant!!!  Now your reply makes much more sense to me.  Argh tiny phone keyboards. \n\nSent from my iPhone\n\nOn Jan 28, 2016, at 10:35 PM, Wirebird Labs LLC notifications@github.com wrote:\nI'll extrapolate here, that @gdamore meant to type \"sane\" rather than \"same\" from a mobile phone -- in other words, much closer to a compliment than a jab, in case that didn't come across @Snaipe :-)\nEven if that's not the case, I'll go ahead and say it -- much more sane indeed.\n\u2014\nReply to this email directly or view it on GitHub.\n. Looking at this, I still have to review the code.  But I think we should consider a few things.\n\nFirst off, I don't think we should ever support the notion of libnanomsg sockets \"crossing\" a fork boundary.  That is, I think all nn_sockets should be considered to be \"illegal\" in a post-fork situation -- automatically closed, with no access to the socket permitted in the child process.\nGiven that, I think a reasonable course of action would be to simply close() any file descriptors that were open in the child, and to toss any state, ignoring mutexes altogether.  Probably a single global variable can be used to assist the worker threads, that will get errnos if they were running, to notice that they are in a child and need to just bail.  (This should only be a concern on systems like Solaris or illumos, where forkall() or forkallx() or legacy fork() semantics are in play, and all threads are duplicated in child.  POSIX semantics only allow a single thread to be created in the child on fork.)\nI have some ideas on how to set this up, and I think we should do this automatically on behalf of the application at nn_global_init() time.\nThe interesting bit here is dealing with allocations.  I'm not sure how to make fork not leak resources (memory) -- more consideration is needed.\n. Yes, I have a plan to address it.  I\u2019m not sure the PR is ready as it\nstands though.\nOn Mon, Jul 4, 2016 at 8:11 AM, Gordon notifications@github.com wrote:\n\nWhat is the status of this PR? Is it likely to be addressed at some point\nin the future?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/587#issuecomment-230311126, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/ABPDfQHApl2nzQJcneJHkNmTUFL4yegnks5qSSKFgaJpZM4HB4Ux\n.\n. I'm closing this -- the discussion was noted elsewhere - basically we cannot safely do this because pthread_atfork() does not permit the child side to use any async-signal-unsafe functions.  So no mutexes, no nothing.\n\nI may revisit this to permit an intentional reinitialization (explicitly done in the child), or to panic() on reentrance by the child process.  If I do, I'll deal with that separately.. So definitely we're gonna do CMake.  Probably this can be closed when we have it.\n. Initial cmake work is done, and we're moving towards that as fast as we can.  I'm closing this issue as \"WILL NOT FIX\" -- because just use cmake. :-)\n. Rebased here:\ncommit 7f97136875181f1316ba9b4c8ac4ac86d287610d\nAuthor: Steven Hoving stevenhoving@hotmail.com\nDate:   Fri Jan 15 10:28:38 2016 +0100\nfixes #633 Incorrect size in win_sec_attr\n. Integrated alternate fix in #635 \n. Looks good to me.  I'm not too thrilled about having both enable for tools and for nanocat separately -- but its not really worth holding this up for.  (In the future I think we should stick with just one of these.)\n. Just turning off linger is a bad idea. \nThe reason is that the default is to let the OS finish delivering messages that are queued for delivery after exit. Disabling this means instead your messages will be dropped.  Note that this is after the write() or sendmsg() has returned. \nIf you think you need this, then I suspect you are doing something wrong. TIME_WAIT exists for a good reason; if your client stays alive long enough to finish the delivery then exiting should not cause this behavior. \nIt sounds to me like you are doing a tx and then exiting. \nTry waiting a bit, or even INCREASING the linger to give nanomsg a chance to complete the delivery before you call nn_close and do make that call before you exit. \nIf I were still maintained I'd reject any change to the default linger behavior. \nSent from my iPhone\n\nOn Jan 21, 2016, at 4:43 AM, Wirebird Labs LLC notifications@github.com wrote:\npull request \u5c31\u662f\u7ed9\u4e2agit\u7684\u8865\u4e01 \u6bd4\u5728\u5927\u8857\u4e0a\u78b0\u5230\u7684\u6982\u7387\u8981\u9ad8\u554a \u5c31\u4e0d\u5728\u8fd9\u513f\u6c9f\u901a\u611f\u60c5\u4e86\nAlso, to simply make it easier for @taolinke -- if the change you made is pushed to your own public fork of the nanomsg repository, a nanomsg repository owner will be able to cherry-pick your work with your permission (maintaining your attribution to the commit). The goal here is to lower the barrier for upgrades to the library, and not let git or GitHub be a barrier to those upgrades. I'd be interested to evaluate this change for my own branch, even if it doesn't make it into the trunk.\n\u2014\nReply to this email directly or view it on GitHub.\n. Unless this is a raw socket you can't do that with req.  each new message cancels the outstanding ones unless you first receive the reply. \n\nSent from my iPhone\n\nOn Jan 18, 2016, at 9:55 PM, Raghavendra Bhat notifications@github.com wrote:\nWhen I used nn_send with NN_REQ, I am getting lesser buffer on nn_recv There is no issue when NN_PAIR is used on both client and server\nHere is the code snippet\nfor (unsigned count = 1048576; count--;)\n{\n    unsigned len = sz[p];\n    nn_send(responder, buf, len, 0);\n    bytes += len;\n    p = (p+1) % (sizeof(sz)/sizeof(sz[0]));\n}\nnn_send(responder, buf, 0, 0);\nHere is the result\nsent 311022272 bytes\nreceived 3856 bytes\nelapsed=0465\nWhereas a similar code works using 0MQ (zmq_send) with ZMQ_SNDMORE Is there something missing in the nanomsg interface or is this a bug with nanomsg for a multipart message?\n\u2014\nReply to this email directly or view it on GitHub.\n. So this is an API usage error on the part of the submitter -- do nn_recv between the messages.  You simply cannot keep sending messages ad infinitum without acks for REQ/REP -- the framework drops them (as you've seen).\n\nIn other words, this is the behavior as designed and documented.  Closing.\n. This situation causes the transport to error out -- the device() code can be more resilient here, but we need to make sure that when the transport / pipe closes that it is restarted.  I think this is already properly handled but testing is required.\n. We should write a test for this.  Submitter, can you retest with git head?\n. Closing this due to lack of response from submitter.  It is now over a year since the last reply by the submitter.. I appreciate the effort you spent here, but I'm probably not going to accept this.  The RFCs themselves need to be reformatted, updated in some cases, and moved into a separate repo.\nThe new format will be asciidoc, so we don't have to deal with the xml2rfc nonsense.. When using raw mode sockets, there shouldn\u2019t be any problems \u2014 the main\nthing is that you have to figure how to manage multiple requests and any\ncancelation (if any) in your application.  I don\u2019t think there\u2019s a single\nright way to do this \u2014 its necessarily pretty application specification.\nRequest IDs are generated by the framework even for raw mode requests\n(IIRC), so its just a matter of matching requests to replies.\nSuch matching really is tied to the application behavior \u2014 for example\nshould a response back to a request done asynchronously cause a callback to\nfire, or should threads be used, or some kind of sub-select/poll be\npossible on outstanding requests?\nThe answer also will vary largely based the runtime.  For example, runtimes\nwith threads may find that running multiple requests and then blocking on a\nreply (perhaps using a single thread to poll for responses that then finds\nthe request and signals completion) quite natural.  In other runtimes\nthreads are simply not an option.\nSo, I\u2019d discourage attempts to provide a silver bullet solution here.\nInstead, a body of examples showing how to use the raw mode, perhaps with\nsamples that show asynchronous handling, would be better.  I know that I\u2019ve\nimplemented this asynchronous handling for RPC servers written against both\nnanomsg and mangos several times before.\n(Real world concerns to think about \u2014 should there be a limit on the number\nof outstanding requests?  Do requests complete synchronously on the server,\nor can they take a long time?  Etc.)\nOn Tue, Jan 26, 2016 at 12:05 PM, Wirebird Labs LLC \nnotifications@github.com wrote:\n\nAs currently Req/Rep is not working for me when one end is in C++ and the\nother in Go\nWould you open a new issue? This is likely unrelated, but an important\nthing to track. thanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/596#issuecomment-175119311.\n. Coming back to this, I'd like to see some kind of API proposal -- I think what you really want here is more like a real RPC framework (or REQ/REP framework) where you wind up either registering a callback, or handling a bunch of messages in parallel (perhaps using threading in the server).  This would probably be pretty easy in the server side to do.  But figuring out how to do the REQ (client) mode asynchronously cleanly is vastly harder.  You need to have a way to figure out how to match the requests and responses, which is a pain.  A client library could probably give you back the request ID which could be used as a cookie/ticket to use when doing a modified recv.\n\nBut as I think about this, this really looks like it should be not in libnanomsg core, but perhaps as a secondary library on top of nanomsg.  In any event, its not something we're going to do for 1.0 -- perhaps post 1.0 we can explore ideas though.\n. I'm going to remove these APIs for now.  We can reassess in the future, with a more properly baked API proposal - or with an additional library layer on top.\n. As part of this, we are also removing the unused nn_req_handle structure.\n. Nanomsg is user space code.  If your kernel is freezing up then it is absolutely a fault in the hardware or operating system.  A user application or library should never ever be able to cause the system to completely hang. \nSent from my iPhone\n\nOn Jan 30, 2016, at 1:38 PM, Graeme Wicksted notifications@github.com wrote:\nFresh copy of repo w/ Latest commit f06749d on Dec 2, 2015\n1 Lenovo W520 Windows 7 x64 i7-2820QM 16GB w/ 2 SSDs via RDP\n2 Ran cmake - no errors\n3 Opened the sln in VS2015\n4 Compiled the ALL_BUILD project - no errors\n5 Compiled the RUN_TESTS project - ran into problem with tcp_shutdown (assertion)\nCauses laptop to freeze to the point it needs to be power cycled\n1 Power cycled\n2 Opened the sln again\n3 Ran just tcp_shutdown project in debug mode\n4 Runs into the same assertion - this time I could break into the code long enough to view some variables and the stack\n(restarted again, opened sln, placed a breakpoint on the printf above the assertion)\nNow I can freely poke around but as soon as I stop the debugger it freezes again\nFunction triggering the assertion:\nstatic void NN_UNUSED test_recv_impl (char file, int line, int sock, char data)\n//\nif (rc < 0) {\n    fprintf (stderr, \"Failed to recv:     \"  // cut for brevity\n    nn_err_abort ();  // here\n}\nVS is showing the following values:\nbuf = 0x008973c8 (garbage string)\ndata = 0x0096b3a4 \"hello\"\ndata_len = 5\nfile = 0x0096b3ac (path to file on disk)\nline 76\nrc = -1\nsock = 10\nSome other tests passed:\nTest project D://nanomsg\n        Start  1: inproc\n   1/40 Test  #1: inproc    Passed    058 sec\n        Start  2: inproc_shutdown\n   2/40 Test  #2: inproc_shutdown    Passed    035 sec\n        Start  3: ipc\n   3/40 Test  #3: ipc    Passed    076 sec\n        Start  4: ipc_shutdown\n   4/40 Test  #4: ipc_shutdown    Passed    046 sec\n        Start  5: ipc_stress\n   5/40 Test  #5: ipc_stress    Passed    155 sec\n        Start  6: tcp\n   6/40 Test  #6: tcp    Passed    159 sec\n        Start  7: tcp_shutdown\nThe freezing and abort happen reliably and this Laptop is not known to be flaky and lock up like this\nPlease help!\n\u2014\nReply to this email directly or view it on GitHub.\n. Inproc has known race conditions. It's also not optimally efficient.  I don't recommend it's use at present. For real performance testing you should compare TCP because that's going to be more reflective of real world uses. \n\nSent from my iPhone\n\nOn Jan 31, 2016, at 6:55 AM, AlexanderZh notifications@github.com wrote:\nThe following errors happen for executables in perf directory:\n1 If inproc_thr is launched several times without any delay from terminal it finally hangs up Placing for loop inside inproc_thrc makes this problem reproducible Placing printf both into void worker (NN_UNUSED void arg) and int main (int argc, char argv []) helps to figure out that some messages are lost during inproc transmission\nmessage_size = atoi (argv [1]);\nmessage_count = atoi (argv [2]);\nint k;\nfor (k=0; k<100; k++)\n{\n    s = nn_socket (AF_SP, NN_PAIR);\nMax k=100 is quiet enough to reproduce the error but sometimes it happens for less k\n2 For local_thr/remote_thr also there is a similar problem Finally it crashes with the message that sz=nbytes assertion failures\nI guess it is not intended behaviour as for zmq the same works fine I just wanted to compare performance nnmsg vs zmq to choose the best one and I'm a little bit confused This happens both for 08 and 07 versions OS Ubuntu 1404\n\u2014\nReply to this email directly or view it on GitHub.\n. Looks like a bug.  I don't have time to analyze it right now but maybe someone else on the list can help?\n\nSent from my iPhone\n\nOn Jan 31, 2016, at 11:48 AM, AlexanderZh notifications@github.com wrote:\nThank you for fast reply! \u041e\u043a, I'll not use inproc.\nBut what about ipc for example? As I've mentioned above in (2) there is a similar problem. After adding for loop and some printf for diagnostics as follows:\n...\nk_max = atoi (argv [4]);\n    int k;\n    for(k=0; k<k_max; k++)\n    {\n        s = nn_socket (AF_SP, NN_PAIR);\n...\n    for (i = 0; i != count; i++) {\n            nbytes = nn_recv (s, buf, sz, 0);\n            if(nbytes != (int)sz)\n                printf(\"got %d instead of %d\\n\", nbytes, (int)sz );\n            assert (nbytes == (int)sz);\n        }\n...\nI get the following output (last argument 100 is k_max in for loop) :\n$./perf/local_thr ipc:///tmp/test123 1024 1000 100\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 228050 [msg/s]\nthroughput: 1868.186 [Mb/s]\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 202429 [msg/s]\nthroughput: 1658.298 [Mb/s]\ngot 0 instead of 1024\nlt-local_thr: perf/local_thr.c:75: main: Assertion `nbytes == (int)sz' failed.\nAborted (core dumped)\nAfter several loops 0 bytes are received instead of 1024.\nAs for tcp the output is:\n$ ./perf/local_thr tcp://127.0.0.1:5555 1024 1000 100\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 214546 [msg/s]\nthroughput: 1757.561 [Mb/s]\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 327011 [msg/s]\nthroughput: 2678.874 [Mb/s]\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 286697 [msg/s]\nthroughput: 2348.622 [Mb/s]\ngot 1024 instead of 0\nlt-local_thr: perf/local_thr.c:70: main: Assertion `nbytes == 0' failed.\nAborted (core dumped)\nSometimes 1024 bytes are received instead of 0 bytes and sometimes vice versa. Does that mean that the order of messages is not preserved between sender and receiver? And is it the intended behaviour?\n\u2014\nReply to this email directly or view it on GitHub.\n. I think with TCP what may be happening is a failure to linger, causing \"written\" bytes to get dropped on the floor.  I'm making a change for that to accommodate larger message sizes anyway.  Stay tuned.\n. So, looking at this more fully.  Its not a bug.  You're sending messages, but synchronization of data between senders on different sockets is not guaranteed.  In particular, we can have a situation where a socket is lingering (behind the scenes) or retrying, or just delivered via a different TCP stream and hence scheduled differently by the stack, the NIC(s), the routers, etc. \n\nOnly data within a single TCP is guaranteed to be in order.\nWhen you mix different streams together -- e.g. combining several streams and expecting the data to arrive using only a single receiving nanomsg socket -- the system(s) involved a free to intermix data.  What is guaranteed is that data from a single sending socket will never arrive at the receiving sock out of order.  But it may not be time-ordered against data that was sent from different sockets.\nJust to make matters worse for you.  I'm not 100% sure the order guarantee applies even then.  Retries, and use of devices (intermediate nanomsg nodes) can wind up breaking the ordering promise.  This is actually a more or less fundamental problem in nanomsg.  Even though nanomsg may use underlying reliable transports for transmission, it does not itself provide reliable in-order delivery.\nI'm pretty sure this is a problem for ZMQ too.  That said, I've not actually checked with the protocols.\nI'm going to go ahead and close this -- we can't really fix it.\nIf you need reliable delivery, you really need to use req/rep.\n. Yes its unrelated, a bug someone should fix. I was working on it weeks ago,\nand made some progress, but didn\u2019t have it completed.\nOn Wed, Feb 3, 2016 at 2:41 PM, Bent Cardan notifications@github.com\nwrote:\n\none of the windows machines seems to be timing out on a device test, looks\nunrelated IMO\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/600#issuecomment-179508084.\n. This change looks obviously correct.  Have you filed a bug on this -- we like to use a specific comment format in our commits...\n\nfixed #XXX bug sysnopis\nWhich means you need an XXX and a bug synopsis.  I can do this for you if you like, but when I commit the comments will change.\n. Well, yes.  NN_MSG is not an integer symbol, but a size_t (and -1), so you can't reliably express its value in an int.\nFurthermore, I can imagine no reason why you'd ever want to express this to an alternate runtime -- this isn't a value that applications that can't access the C type directly should ever use, since it affects how libnanomsg behaves with respect to memory allocations and buffers.  (So for example, it would be tragically bad for a language binding to give this option to applications, unless the binding included explicit handling for it.)\nThis is quite unlike other things like socket options, address family or domain, or errnos where applications can reasonably change behaviors without requiring the language binding to take any special action.\nI won't be exposing this via nn_symbol() as a result.\n. So looking at this, there are actually two errors.  I think the first error is really #568, and should not occur.\nThe second error is a separate issue, and trivially reproducible.  I'm working on it right now.\n. Yep, I ran into this a while ago when I was building mangos.  Thanks for the reminder. \n. Actually, some places it uses milliseconds, and others seconds.  We should use seconds to be consistent .. for the command line app we don't need sub-second timeouts.\n. Looks like a bug to me. \nSent from my iPhone\n\nOn Feb 21, 2016, at 5:54 AM, Lucas Beyer notifications@github.com wrote:\nWhenever a REP sends a message to a REQ, if the message is larger than the REQ's NN_RCVMAXSIZE option, the REP dies with the following message:\nUnexpected source: state=5 source=1 action=5 (src/transports/utils/streamhdr.c:306)\nfish: Job 1, \u201cpython monitor_srv.py\u201d terminated by signal SIGABRT (Abort)\nIs this intended behaviour? It means that any REQ can kill a REP server very easily. I'm using the nnpy wrapper and didn't try to reproduce it in C. Here is the minimal case which I could write to reliably reproduce this:\nbug-srv.py:\nimport nnpy\nimport time\nrep = nnpy.Socket(nnpy.AF_SP, nnpy.REP)\nrep.bind(\"tcp://127.0.0.1:12345\")\nfoo = rep.recv()\nprint(foo)\nbar = b\"0\"_1024_1025\nrep.send(bar)\nprint(\"sent\")\ntime.sleep(10)\nrep.close()\nbug-cli.py\nimport nnpy\nreq = nnpy.Socket(nnpy.AF_SP, nnpy.REQ)\nreq.connect(\"tcp://127.0.0.1:12345\")\nreq.send(b\"foo\")\nprint(\"sent\")\nbar = req.recv()\nprint(bar)\nreq.close()\nUsage:\n$ python bug-srv.py\nb'foo'\nsent\nUnexpected source: state=5 source=1 action=5 (src/transports/utils/streamhdr.c:306)\nfish: Job 1, \u201cpython bug-srv.py \u201d terminated by signal SIGABRT (Abort)\n$ python bug-cli.py\nsent\nInterestingly, while trying to reproduce it, I once got a different message from bug-srv.py, not sure if this helps or distracts:\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (src/utils/queue.c:102)\nfish: Job 1, \u201cpython bug-srv.py \u201d terminated by signal SIGABRT (Abort)\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm pretty sure this is indeed fixed by c0e92dd84f0263fb4f2ad504dd7ccbdf42a24c21\nI'm going to close it.  If it crops up again in HEAD or 0.9 (after 0.9 is released) please let us know.\n. Glad that is confirmed.\n. I'm rejecting this PR, because I'm going to just rip out the offending code altogether.  The statistics socket that used this code is getting ripped out.\n. That looks quite strange. I cannot explain off the top of my head right now. \n\nSent from my iPhone\n\nOn Feb 29, 2016, at 2:03 AM, taolinke notifications@github.com wrote:\nhere is what i got use tcpdump:\n17:59:54.991879 IP 192.168.167.12.34683 > 192.168.167.1.3337: Flags [P.], seq 422:633, ack 1, win 115, options [nop,nop,TS val 52161 ecr 85021\n], length 211\n.....\n17:59:54.991888 IP 192.168.167.12.34683 > 192.168.167.1.3337: Flags [P.], seq 422:633, ack 1, win 115, options [nop,nop,TS val 52161 ecr 85021\n], length 211\n.....\nAs u see, why is that?\n\u2014\nReply to this email directly or view it on GitHub.\n. I believe that in the past I had stated that nanomsg did not support mingw\ncompilation \u2014 there are problems with mingw as it lacks certain symbols\nthat are present on modern Windows but not in old Windows XP and earlier.\nAs a result, the mingw team has declined to add support for linking against\nthose symbols.\n\nMy answer to this is to require the use of Visual Studio to build on\nWindows.  Since Visual Studio is free (as in beer) and using it does not\ncreate any licensing restrictions on the resultant program, this doesn\u2019t\nseem a particularly onerous requirement.\nAs a result, I believe this bug should just be closed Will Not Fix.\nOn Tue, Mar 1, 2016 at 9:35 AM, Chris Heller notifications@github.com\nwrote:\n\nconfigure.ac has a reference to the LIBS environment variable as\nLIBS=\"$LIBS -lws2_32 -lMswsock\", but that fails with a \"cannot find\n-lMswsock\" error message when cross-compiling.\nChanging that to a lower case m addresses the problem and then compiling\nworks.\nI don't have a mingw on Windows environment handy at the moment to test if\nthat change has any repercussions for building there though. I can submit a\npull request if someone can confirm that.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/610.\n. And yes, this also all means that cross compilation to Windows is not\nsupportable.\n\nOn Tue, Mar 1, 2016 at 10:02 AM, Garrett D'Amore garrett@damore.org wrote:\n\nI believe that in the past I had stated that nanomsg did not support mingw\ncompilation \u2014 there are problems with mingw as it lacks certain symbols\nthat are present on modern Windows but not in old Windows XP and earlier.\nAs a result, the mingw team has declined to add support for linking against\nthose symbols.\nMy answer to this is to require the use of Visual Studio to build on\nWindows.  Since Visual Studio is free (as in beer) and using it does not\ncreate any licensing restrictions on the resultant program, this doesn\u2019t\nseem a particularly onerous requirement.\nAs a result, I believe this bug should just be closed Will Not Fix.\nOn Tue, Mar 1, 2016 at 9:35 AM, Chris Heller notifications@github.com\nwrote:\n\nconfigure.ac has a reference to the LIBS environment variable as\nLIBS=\"$LIBS -lws2_32 -lMswsock\", but that fails with a \"cannot find\n-lMswsock\" error message when cross-compiling.\nChanging that to a lower case m addresses the problem and then compiling\nworks.\nI don't have a mingw on Windows environment handy at the moment to test\nif that change has any repercussions for building there though. I can\nsubmit a pull request if someone can confirm that.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/610.\n. I'll be removing the configure.ac nonsense and moving to cmake in the future.  For now I'm going to just close this, because until that time, mingw (even mingw-w64) is unsupported.  Microsoft compilers Just Work.\n. I don't think so.  See this for example, https://github.com/cristeab/ios-cmake\n\n\nThat said, if cmake is going to create an unsurmountable hurdle for iOS or Android (or any other platform really), I need to know ASAP.\n. In fact, I'm almost certain that CMake knows about iOS natively these days, see this for example:\nhttps://blog.kitware.com/cmake-3-5-0-rc2-is-now-ready/\n. Probably you can use libevent.  libnanomsg uses a notification file descriptor which you can retrieve with either NN_SNDFD or NN_RCVFD socket options.  See nn_getsockopt.\n. I apologize, but I've probably completed busted this.\nAt this point, I'm probably not going to be accepting new transports for nanomsg ...\nBUT the new nng library is a totally different matter, and for that I'd like to look at handling allocations and such to support RDMA, shared memory, and so forth.. Conflicts left and right.... my fault.  But as I said, long term I think this isn't going to be accepted upstream into nanomsg... instead we should look at supporting your new transport in nng.  I will be far more engaged in helping you with that, if you're so inclined.. Use multiple sockets. One pub sub for server broadcasts and a req/rep for client commands sent to server. \nSent from my iPhone\n\nOn Mar 21, 2016, at 6:40 PM, Luke notifications@github.com wrote:\nHello,\nI have looked at the scalability protocol descriptions but am uncertain which one implements my requirements.\nBasically I am looking for a typical client/server situation with one server and multiple clients but with bi-directional communication. The PUBSUB looks like the closest protocol but I need the client to be able to send messages to the server (heartbeats, etc). Is this possible in the PUBSUB? If not what is the recommended solution?\nThanks,\nLuke\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. Why do you think keepalive has anything to do with wakeup?\n\nKeepalives are handled in the kernel generally, and do not pass up to the application.  Their purpose is to ensure that a minimal amount of traffic is seen on otherwise idle TCP connections.  This is often necessary to keep things like stateful firewalls or NAT from misdiagnosing such connections as stale and dropping them.  The other reason is so that the far end of a connection can detect a dead peer -- triggering a little bit of protocol to act sort of like a heartbeat on the TCP connection itself.\nI've rarely seen a useful case for tuning the keep alive interval, to be honest; usually the case is to help the far end of a connection notice a dead peer earlier; this is necessary on very high volume servers to ensure that stale TCP connections are reaped.  (A similar reason why firewalls and NAT devices clean up idle connections -- its about resource management really.)\n. So you're talking about an application layer heartbeat because normal TCP keepalives don't do what you want (mostly; there is some cache warmness in the kernel but the app never wakes up to process these). \nThat sounds like a new message type. I'm not in favor of this. It would add substantial complexity to libnanomsg (more state machines!!) for a very limited benefit to a tiny set of applications. \nBetter if your app needs this that you do a heartbeat in the application code itself - eg another req/rep message or a periodic pub or somesuch.  Far less complexity and risk, and easy to do for you particular app. \nSent from my iPhone\n\nOn Mar 22, 2016, at 1:56 PM, Bent Cardan notifications@github.com wrote:\nwhen msgs are few and far between endpoints, low latency delivery between send and recv I/O is ideal.\nWhy do you think keepalive has anything to do with wakeup?\nI use the term wakeup to describe additional time spent recognizing the need for I/O, for long running idle subscribers. In that case, I've used an interval of small sz msgs to reduce what I call wakeup latency\nKeepalives are handled in the kernel generally, and do not pass up to the application. Their purpose is to ensure that a minimal amount of traffic is seen on otherwise idle TCP connections.\nWhile that sounds very efficient to me, I would be willing to sacrifice resources required to process additional traffic on an otherwise idle TCP connection, if that is the cost of immediate transport I/O for the rare and infrequent msg recv--IMO a suitable resource allocation and expense.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\n. Btw what are your latency requirements?\n\nOutside of context switch induced delays (which can be solved easily using tasksets to bind to specific cores), I find the worst case TCP latencies for single messages to be well under 10us on decent network gear with properly tuned drivers and NIC.  And yes this is general purpose OS - either Linux or illumos. \nA bigger concern is making sure that both TCP Nagle is disabled and any interrupt moderation at the NIC is turned off. The former can add a number of milliseconds if mistuned. The latter adds about 30us on typical 10GbE. \nSent from my iPhone\n\nOn Mar 22, 2016, at 1:56 PM, Bent Cardan notifications@github.com wrote:\nwhen msgs are few and far between endpoints, low latency delivery between send and recv I/O is ideal.\nWhy do you think keepalive has anything to do with wakeup?\nI use the term wakeup to describe additional time spent recognizing the need for I/O, for long running idle subscribers. In that case, I've used an interval of small sz msgs to reduce what I call wakeup latency\nKeepalives are handled in the kernel generally, and do not pass up to the application. Their purpose is to ensure that a minimal amount of traffic is seen on otherwise idle TCP connections.\nWhile that sounds very efficient to me, I would be willing to sacrifice resources required to process additional traffic on an otherwise idle TCP connection, if that is the cost of immediate transport I/O for the rare and infrequent msg recv--IMO a suitable resource allocation and expense.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\n. The problem with this being a TCP transport option is that TCP doesn't actually do this.  It does have TCP_KEEPALIVE, but that doesn't do what you're talking about; it's for something else entirely.\n\nThat said, there may be considerations in keeping mobile devices from going to sleep.  (I wonder though, is it really the right thing to do to prevent a client device from sleeping or going into lower power state?  I know that I wouldn't want any of the apps on my phone or computer to do that!  If they don't have anything to do and my device is sleeping, then I'm not going to notice a few tens, or even hundreds, of milliseconds of additional latency to wake the device up.)\nYour application layer heartbeat is still the right place to do this, if you have a desire to keep an application up and running -- but really there are still better ways to do this, such as binding the app to cores, and increasing its scheduling priority (see nice(1)).\nI'd suggest you go ahead and close this -- I'm not maintainer anymore, so I'd leave it to you to do so.\n. This looks good.  I'll probably rebase.  It would probably be helpful to have a man page documenting this, but that can wait for later.\n. Well, except that the compiles failed.  So... not ready yet.\n. Well, a few things....\na) It isn't conflict free...\nb) The changed messages are for panics... the program is going to call abort() in those circumstances anyway -- and these should not actually occur (if they do then it's a bug!)\nSo I'm closing this for now -- if you want to resubmit, please do so very soon, as I'm winding up for libnanomsg 1.1.. I'm gonna close this, and we'll hope for @JackDunaway to submit a PR addressing this shortly.\n. That's normal, and somewhat unfortunate.  The code assumes that it will keep retrying the bind, and the application is insulated from the failure.  This is symmetric to nn_connect() failing.  Arguably in the nn_bind() case we could (should?) be able to report errors back up -- although its still the case that such errors may be temporary.\nAdding a wrinkle here, the actual socket shouldn't see failures from a single nn_bind failing, since you can have multiple transports in use, and one pipe failing doesn't necessarily impact the others.\n. I'd make this instead just a synchronous nn_bind() by default.  There is no reason really to have to retry, etc. because unlike nn_connect() this is entirely determined at start time, and should never fail afterwards.  We can add an nn_connect_async() option after.\n. Ephermal port binding is useful, provided you have an out-of-band way to get information about the service address.  So you'd like to get back (or have a way to get back) what the actual port is, which then could be either displayed to the user, or passed to some other components.  One example I've used in the past is to actually use this to register a service with a task manager/directory using the SURVEYOR pattern.\nThat is, we have a service that sets up a REP socket on ephemeral port X.  It then gives this port X in an application specific message that is delivered to the manager via SURVEYOR.\nThis could be done on the same host, to, using other notification methods.  The usage scenario is very much like rpcbind.\nAll this notwithstanding, I am convinced that nn_bind() should be synchronous by default.  Even with ephemeral ports this works, because you should get some port by default, without blocking for an inordinate amount of time.\nTo be honest, I'm having a hard time understanding the use case for an asynchronous nn_bind, even though that is what we have today.\n. Marking this one for 1.0 milestone.\n. Yep, that errno_assert needs to be removed.  The code immediately thereafter is almost correct.  Instead, we need to just bail out if rc < 0.  I'll have a fix for this shortly.\n. I'm somewhat astonished that the tests never have tripped on this.  nn_poll in the device is supposed to stall and return ETERM.\n. I'm willing - reluctantly - to come back and work on this stuff again. However if I do so then it will be as a dictator to run the project by edict rather than by consensus. That is I may seek opinions but I would not feel compelled to adhere to them. \nI believe that this project cannot survive in consensus mode.\nHowever I won't come back unless the other folks with git access agree for me to do so under precisely those terms. \nTo be clear this was never my intent and I would have preferred to see someone else competent step forward. But that hasn't happened.\nNote that none of this affects licensing - the code must always be released under the same license as I don't own nor do I want to exclusive ownership in the code. So the freedom to fork will always be there for anyone who needs it.\nSent from my iPhone\n\nOn Apr 7, 2016, at 8:24 PM, Saul notifications@github.com wrote:\nSady this project appears to be unmaintained. See:\nhttp://www.freelists.org/post/nanomsg/Dead,5\nhttps://news.ycombinator.com/item?id=11057550\nhttp://sealedabstract.com/rants/nanomsg-postmortem-and-other-stories/\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. Officially, I'm back as maintainer now.  I'll ramp up myself, and this will take a little bit (but not too much I hope) time.\n. This is not ready, and at this point I'm punting on it for nanomsg.  If we need this kind of behavior for nng, please let me know.  (I am considering the issue there.). Furthermore, I'm creating a much nicer API for retrieving statistics data programmatically. PR and bug for that coming momentarily.\n. Yes \n\nSent from my iPhone\n\nOn Apr 15, 2016, at 5:12 PM, Shiva notifications@github.com wrote:\n@gdamore Would you need cmake support for this? eventually?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\n. I integrated this already.\n. Btw, as part of the removal, we will save the tooling and diagrams for historical reasons, but delink it from the website.  It will be possible to resurrect the work in the future should a need arise.\n. You can't epoll the nanomsg socket.  Instead you have to get either a send or receive notification file descriptor with nn_getsockopt() for the NN_SENDFD or NN_RECVFD.  See the nn_getsockopt man page for more details.\n. Merged via rebase:\n\ncommit 5bb109305b5bd738576f9010f7264e4136bd1456\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Sat Apr 16 08:28:59 2016 -0700\nfixes #621 Remove experimental tcpmux transport\ndiff --git a/CMakeLists.txt b/CMakeLists.txt\n. Ok, I am going to spend some time looking at this too\u2026\nOn Mon, Apr 18, 2016 at 8:59 AM, Jack R. Dunaway notifications@github.com\nwrote:\n\nI am currently investigating why the AppVeyor builds are failing:\nhttps://ci.appveyor.com/project/gdamore/nanomsg/build/0.8.392\nIt appears that Travis CI building on Ubuntu is healthy:\nhttps://travis-ci.org/nanomsg/nanomsg/builds/123624427\nAs part of this process, I will also turn on OS X builds on Travis CI. The\ngoal is to get as much mileage on as many platforms as possible to flush\nout issues, since each environment is built each time a commit is added to\na PR.\nAfter sussing out issues with what could be quite a few pushes to this\nbranch, I'll then squash all commits into a cogent PR and close this one\nout.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/636#issuecomment-211445562\n. CMake 3.4 is the latest, I believe.  Are there reasons we should be using\nthe older 2.x series?\n\nOn Mon, Apr 18, 2016 at 9:41 AM, Jack R. Dunaway notifications@github.com\nwrote:\n\nif that helps, I'm using this CMakeLists.txt on my own fork\nIt's particularly helpful! -- especially that you're able to build with\nCMake 2.8.7 instead of CMake 2.8.12!\nBeing able to lower this requirement would reduce setup time, since 2.8.7\nis what ships with the default Travis CI environment. At some point during\noriginal development of this script, I recall introducing enough features\nto justify the upgrade to 2.8.12 from 2.8.7, but seeing what little effort\nyou spent to drop back to 2.8.7 seems like the way to go.\nI'll be soon cherry picking and pushing updates ...\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/636#issuecomment-211464184\n. That was really too brief. :-/\n\nOn Mon, Apr 18, 2016 at 10:01 AM, Jack R. Dunaway notifications@github.com\nwrote:\n\nCMake 3.4 is the latest, I believe. Are there reasons we should be using\nthe older 2.x series?\nBrief, glossed-over answer: yes.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/636#issuecomment-211475313\n. Ok.  I use 3.4 (or 3.5rcX) myself, because i have to install it myself on\nOSX.  If its easy to make the old stuff work, and doesn\u2019t break folks\nworking with newer CMake, then I agree.\n\nOn Mon, Apr 18, 2016 at 10:19 AM, Jack R. Dunaway notifications@github.com\nwrote:\n\nLonger answer -- based on my last in-depth technical investigation, which\nis now a few months dated and always a moving target, it appeared the\noptions were:\n- CMake 2.8.7 - seems this is the latest-pegged \"stable\" version in\n  trusty and LTS linux builds, including the Travis CI environment with\n  Ubuntu 12.04 LTS: http://packages.ubuntu.com/precise/cmake\n- CMake 2.8.12 - most up to date CMake release in the 2.x line,\n  notably including commands to more precisely specify target properties\n  rather than directory properties\n- CMake 3.x - a moving target (seems to be updated quite often), and\n  not particularly accessible within the Travis CI environment, especially\n  because Travis CI does not allow sudo privilege for containerized\n  builds.\nThe new piece of information I'm learning today from @Snaipe\nhttps://github.com/Snaipe is that he's successfully been back at 2.8.7,\nwhich feels definitely worth investigating, since it lowers CI build time\nappreciably and removes script complexity.\nAt some point, it could be worth investigating ugprading to 3.x, but at\nthis point, 2.8.7 makes the most sense (or, 2.8.12 if it turns out that\nrequirement remains)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/636#issuecomment-211483119\n. Once we get the commit ready \u2014 we\u2019ll add a note to the commit comments\nlisting all the contributors \u2014 Git sadly doesn\u2019t record more than one\nauthor in the commit itself, but there\u2019s no reason you shouldn\u2019t get credit\nfor contributions in the git log.  We can also add copyright statements to\nrelevant files if you like.\n\nOn Mon, Apr 18, 2016 at 1:09 PM, Shiva notifications@github.com wrote:\n\n\n@shiva https://github.com/shiva -- note this familiar failure:\n   https://travis-ci.org/nanomsg/nanomsg/jobs/123621308#L264 and the\n   \"fix\" the suppressed this issue: e9dc4e9\n   https://github.com/nanomsg/nanomsg/commit/e9dc4e91e816a6062ac945e5cd46d4a793555e2e\n   -- any ideas on a more sustainable fix?\n\n@JackDunaway https://github.com/JackDunaway This commit (shiva@8159d21\nhttps://github.com/shiva/cmakeify-nanomsg/commit/8159d2166d0b8a5849ba7c04d1b2e14486952ebb),\ncalculates the version, and guarantees a value for NN_PACKAGE_VERSION. At\nleast, that was the intention.\nIf this is not working as expected, I can troubleshoot more. Let me know.\n(Note: I just noticed that I hadn't used my github identity for my commits\nand hence had to re-write history. You can safely ignore my commits now\nthat you have squashed all of them into your PR branch.)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/636#issuecomment-211554702\n. I'd be inclined to just punt on explicit checks for stdint.h or int64 -- if the compile breaks it will be obvious.  I'm not interested in enabling environments where sane definitions of int64_t, or uint64_t, do not exist, nor do I care to support those without stdint.h.\n. I agree with you in this particular regard -- not that I have an objection to having generated headers -- but one good thing we'd give up is that right now there is only a single header that API consumers have to include -- nn.h.  Having multiple headers increases the ways that compilation of client programs can fail, since you might have to arrange for the correct include path to be set up.  If there were multiple things here to justify it I'd agree, but since its just this one item, the benefits don't seem to be worth the possible pains.\n. Here's my proposal for simplifying this, which solves it for Windows, but uses extern for everything else.  It does leave open the opportunity to redefined it if a project needs to though:\n\n+#if !defined(NN_EXPORT)\n+#    if defined(_WIN32) && !defined(NN_STATIC_LIB)\n+#        if defined NN_SHARED_LIB\n+#            define NN_EXPORT __declspec(dllexport)\n+#        else\n+#            define NN_EXPORT __declspec(dllimport)\n+#        endif\n+#    else\n+#        define NN_EXPORT extern\n+#    endif\n+#endif\n. Yeah sure.  I\u2019ll fix some of these too, and we can gradually increase the\nwarning level. :-)\nOn Mon, Apr 18, 2016 at 1:21 PM, Jack R. Dunaway notifications@github.com\nwrote:\n\nOK, it'll take a bit longer to fix this properly and understand the\nramifications of the fix.\nNot because any of these particular fixes is difficult -- but because when\nI compile with Warning Level 3 /W3 (the default warning level) it returns\n0 warnings and 0 errors, and with /W4 we get 225 warnings, and with /Wall\nthat number shoots to 8930 warnings.\nI'm not exactly sure yet how/why this AppVeyor environment is configured\nto return 11 warnings, but issues such as this are a little lower priority\nfor the time being.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/639#issuecomment-211560133\n. This is all cleaned up now.  Closing.\n. Looks like I need to enable .appveyor.yml.\n. We're getting close... I really however am pretty opposed to the changes that required you to modify the .c, .h, and .inc files.   I don't like putting this complexity in the CMake configuration -- I want the CMake machinery to be as simple as we can make it, because the subset of people who work on this code who understand CMake is going to be much less than the set who grok the C preprocessor (or so I postulate.)\n\nI've updated .appveyor, and I'd like to take this PR and run with it myself, if thats ok with you?  I will probably revert the part that modifies the .c, .h, etc. \n. Going back through this, and looking at both CMake and my earlier work on CMake, I'm noticing a serious problem.  We don't actually use most of the things we test for.  That is, we're not going to enable linking against libsocket, or -lrt, etc.\nWe are declaring variables in CMake, but not causing those variables to have any impact on the compile environment in many of these cases.\nI have macros that fix this by wrapping checks with changes to cmake variables that do impact the environment. \nI'm going to get this stuff done, and I'll verify that that everything builds correctly on all of illumos (omnios), MacOS X, Linux (via travis), and Windows (via appveyor).\nStay tuned.\n. I think it's load on appveyor.  It works much better in the evening but falls over during daytime peaks. \nSent from my iPhone\n\nOn Apr 19, 2016, at 7:43 AM, Jack R. Dunaway notifications@github.com wrote:\nAppVeyor is having a tough time with changes here\nI'm going to spend some time figuring out what is wrong here on a separate AppVeyor instance, unless you've already got it figured out @gdamore ... else, stay tuned ...\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\n. Quite a bit further work was done on this, and the result was squashed and merged:\n\ncommit 5b34eb6467975ff4c444e2f8e1267bf01aba4b36\nAuthor: Jack R. Dunaway jack@wirebirdlabs.com\nDate:   Sat Apr 16 15:41:44 2016 -0500\n```\nfixes #647 Initial cmake support for non-Windows platforms\nThis change is the first step towards a unified CMake based build for\nall nanomsg platforms.  With this it is possible to build nanomsg\nusing cmake on at least Linux, MacOS X, illumos, and Windows systems.\nHowever, there remains work to be done, particularly with respect to\ndelivery of documentation and the nanocat binary.\nThe eventual goal will be to remove support for the autotools, and\nsettle on a single cmake based toolchain.\nThis work is the result of a collaborative effort by several authors:\nJack R. Dunaway (@JackDunaway), Garrett D'Amore (@gdamore),\nFranklin Mathieu (@Snaipe) and Shiva (@shiva).\n```\n. Note that specifically #574 remains open because the work is not yet complete.\n. Gettimeofday is still slow. But rarely needed as arbitrary times are much easier to collect. Gethrtime and clock_gettime(CLOCK_MONOTONIC) are fast. So is QueryPerformanceCounter.  These actually use the TSC when it is reasonable to do so. \n. rebased as: \ncommit 4b88a3b68ed1bdd4c57ba80e2a52b31a4846831f\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Mon Apr 18 16:32:35 2016 -0700\nfixes #640 clock_rdtsc is unsafe\n. Looks good.  I think you should do this as your first integration directly into the repo - I will touch base on gitter to work it through.\n. I think this is another aspect of #603  -- and fixed by the same bug fix (testing pending).  (This is just on the recv side instead of the send side.)\n. I'm marking this fixed as a dup of #603 for now.  If we see the problem reoccur after today in Travis, please reopen.\n. This was integrated as \ncommit 5b34eb6467975ff4c444e2f8e1267bf01aba4b36\nAuthor: Jack R. Dunaway jack@wirebirdlabs.com\nDate:   Sat Apr 16 15:41:44 2016 -0500\n```\nfixes #647 Initial cmake support for non-Windows platforms\nThis change is the first step towards a unified CMake based build for\nall nanomsg platforms.  With this it is possible to build nanomsg\nusing cmake on at least Linux, MacOS X, illumos, and Windows systems.\nHowever, there remains work to be done, particularly with respect to\ndelivery of documentation and the nanocat binary.\nThe eventual goal will be to remove support for the autotools, and\nsettle on a single cmake based toolchain.\nThis work is the result of a collaborative effort by several authors:\nJack R. Dunaway (@JackDunaway), Garrett D'Amore (@gdamore),\nFranklin Mathieu (@Snaipe) and Shiva (@shiva).\n```\n. So hopefully its clear that I want to bake the cmake tools a little further before we deprecate autocrap.\nThat said, this is a step in the right direction, but lets hold off until at least a few nits are resolved (packaging nanocat and documentation generation being the biggest)\n. I will review in the next day or so; I actually want this pretty badly, I just want it to be correct.  I'm not sure we're there yet -- but we're close.\n. Rebased, and merged (squashed the appveyor & shields commit).\n. Aside from editing the README, what else needs to be done here?\n. I'd argue in favor of using the CMAKE flag, and basically insist that folks who want that capability have to use \"modern\" cmake. \nThe 2.8.7 goal for cmake always felt really really arbitrary to me, and we're not going to be stuck there forever.\n. CMAKE_POSITION_INDEPENDENT_CODE supports e.g. SunPro compilers with -KPIC, etc.  Its not desirable for us to start duplicating the effort that the cmake folks have put (and continue to put) into these things -- our job is big enough. \n. Travis won\u2019t stay at 2.8.7 forever, and 12.04 LTS is was released in 2012 \u2014\nthats four years ago. It has another year until EOL, but 14.04LTS is now\ntwo years old and 16.04LTS is due out tomorrow.\nI don\u2019t feel particularly constrained by the older releases \u2014 especially\ngiven that upgrading CMake is pretty darn easy. Here\u2019s the status of\ncmake in ubuntu: https://launchpad.net/ubuntu/+source/cmake\nWe have not, for example, done any analysis of what\u2019s in centos or redhat,\nor suse. Never mind the fact that CMake isn\u2019t even installed by default on\nMacOS X or Windows.\n. Btw, I\u2019m in favor of delivering official pre-packaged binaries (.DEB, .RPM,\netc.) using cpack to build, so that Joe Developer can just install without\nhaving to worry about cmake etc.\nOn Wed, Apr 20, 2016 at 8:14 PM, Garrett D'Amore garrett@damore.org wrote:\n\nTravis won\u2019t stay at 2.8.7 forever, and 12.04 LTS is was released in 2012\n\u2014 thats four years ago.  It has another year until EOL, but 14.04LTS is now\ntwo years old and 16.04LTS is due out tomorrow.\nI don\u2019t feel particularly constrained by the older releases \u2014 especially\ngiven that upgrading CMake is pretty darn easy.   Here\u2019s the status of\ncmake in ubuntu: https://launchpad.net/ubuntu/+source/cmake\nWe have not, for example, done any analysis of what\u2019s in centos or redhat,\nor suse.  Never mind the fact that CMake isn\u2019t even installed by default on\nMacOS X or Windows.\nOn Wed, Apr 20, 2016 at 7:36 PM, Jack R. Dunaway <notifications@github.com\n\nwrote:\nI'd argue in favor of using the CMAKE flag, and basically insist that\nfolks who want that capability have to use \"modern\" cmake.\nThis seems incredibly reasonable. I like it the best of all the options\nso far, actually.\nThe 2.8.7 goal for cmake always felt really really arbitrary to me, and\nwe're not going to be stuck there forever.\nIt's not arbitrary at all, from our perspective -- it's what Travis CI\nships with out of the box, because it's what Ubuntu 12.04 LTS is using. OK,\nperhaps it's \"somewhat\" arbitrary for us to abide by this, but at least a\nBIG stake in the ground -- an important service provider in our CI\ninfrastructure depends upon it.\nAnother not-terrible option is to re-introduce code that downloaded CMake\n2.8.12 a pre-build step. The cost here is a few lines in .travis.yml,\nabout +15sec per build, and another potential point of maintenance/failure.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/652#issuecomment-212702915\n. Should install just fine - just in a different install directory because you lack permission to override the existing one. \n\n\nAlso we might want to see what circle CI has.  There's been some suggestion that they can be a better choice.   I've not looked. \nSent from my iPhone\n\nOn Apr 20, 2016, at 8:42 PM, Jack R. Dunaway notifications@github.com wrote:\nHere\u2019s the status of cmake in ubuntu: https://launchpad.net/ubuntu/+source/cmake\nVery true ... but again, the limitation here is Travis CI. Can we install that package without sudo in a Travis environment today? Perhaps tomorrow; but today, we can't. (Would love to be proven otherwise!)\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\n. Libnanomsg is not fork-safe.  Work is in progress to address that. \n\nSent from my iPhone\n\nOn Apr 21, 2016, at 5:29 AM, Fernando Gregianin Testa notifications@github.com wrote:\nMy application consist of a server (A) that receives REQ from client (C) on 8880 and spawns a subrocess (S) to serve this request. Client C and server S work in a PUSH/PULL socket (port 11001 in the example below). Server A responds back with an \"tcp://10.45.1.190:11001\" indicating the address where the client should connect to receive the data. The REQ/REP between C<->A works smooth. However, both client C and subprocess S give up after a configured 60s with 'Connection timed out' when trying to nn_recv() and nn_send() respectively.\nAn inspection with tcpdump on client side shows repeated attempts of SYN being sent from client and RST, ACK being sent back from server S (see below), until the timeout: \n81  3.489818    74  10.45.0.70  10.45.1.190 TCP 49416 \u2192 11001 [SYN] Seq=0 Win=17922 Len=0 MSS=8961 SACK_PERM=1 TSval=2943705941 TSecr=0 WS=128    14059\n82  3.490587    54  10.45.1.190 10.45.0.70  TCP 11001 \u2192 49416 [RST, ACK] Seq=1 Ack=1 Win=0 Len=0  14113\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. However, if your subprocess calls exec, and you reinitialize the library, it should work.\n. Exactly  .. after exec() you must do nn_init().\n\nDon\u2019t do anything in the fork()\u2019d child prior to exec().\nOn Thu, Apr 21, 2016 at 10:10 AM, Franklin Mathieu <notifications@github.com\n\nwrote:\n@fertesta https://github.com/fertesta No, you can't use any function\nfrom nanomsg before a call to exec() yet. You can use it normally after the\ncall though.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/653#issuecomment-213021340\n. I'm closing this as a dup of #582  - which is that we need to make this library fork-safe.\n. In the past I made a conscious decision not to enable so many builds -- mostly because it greatly increases the time to get a result.  Eventually we will want these all, but I don't think we are quite there yet...\n. Can we get an update on this, and I will review?\n. nng has a much richer test matrix here... i'm probably going to punt on this for now, as I'm winding down investing on nanomsg itself.. At this point, I've decided to punt on this pending nng.  Sorry.. I'm pretty well pleased by this.  You should add copyrights to the files modified, and then make sure this is formatted properly with the commit comment (file a bug \"tests should run in parallel\") and make the commit comment \"fixes # tests should run in parallel\"\n\nOnce that's done, we can merge.  Thanks for the contribution!\n. Whoops.  The PR failed to build ... the ws test has compile time errors:\n/home/travis/build/nanomsg/nanomsg/tests/ws.c:85:27: error: \u2018argc\u2019 undeclared (first use in this function)\n/home/travis/build/nanomsg/nanomsg/tests/ws.c:85:27: note: each undeclared identifier is reported only once for each function it appears in\n/home/travis/build/nanomsg/nanomsg/tests/ws.c:85:33: error: \u2018argv\u2019 undeclared (first use in this function)\nPlease fix and resubmit.\n. rebased and merged: \ncommit 98ee1c5795620767c2dc32b214737f9d7fb3c498\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Thu Apr 21 14:31:48 2016 -0700\nfixes #603 crash if REP closes connection after sending protocol header\n. At this point, I'm punting on this.  We don't have a baseline, and our CI providers don't really give us a meaningful way to create a baseline; watching the runtimes and test times manually (I do this alot with both AppVeyor and Travis) makes it clear that there is immense variability in the performance of the underlying VMs, to the point that we cannot possibly make any meaningful determinations about performance.. Oh yeah, thanks for that.\nOn Mon, Apr 25, 2016 at 6:51 PM, Jack R. Dunaway notifications@github.com\nwrote:\n\nClosed #665 https://github.com/nanomsg/nanomsg/pull/665.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/665#event-640861262\n. That's correct.  There is no \"correct\" way to handle socket removal as there can be multiple participants. \n\nProbably we could do removal if the socket was a listener. It's obvious that we should not do so for client sockets. \n. I don\u2019t think the tests have a problem with this, because they rather\nblithely just delete the file system nodes if I recall properly.  That\u2019s\nnot necessarily a good solution for end users.\nI\u2019m thinking that maybe nn_close() of a listener socket should unlink the\nfilesystem nodes, but I\u2019m not 100% sure that is the best solution or is\nwithout pitfalls.  To be honest IPC sockets are fraught with problems\nbecause of this, and I actually don\u2019t know of any race-free solution to the\nproblem that is remotely portable.  (File system locks can do it, but\nthat\u2019s got its own issues.)    This is why I stopped using IPC in\nproduction myself, and only use loopback TCP in my products built on top of\nnanomsg.\nOn Mon, Apr 25, 2016 at 6:46 PM, Jack R. Dunaway notifications@github.com\nwrote:\n\nThe way this was effectively handled previously was using autotools:\nhttps://github.com/nanomsg/nanomsg/blob/master/Makefile.am#L587\nAlthough the current behavior of leaving behind these artifacts is messy,\nthere may not be any equivalent port from autotools to CMake.\nThat said, with CMake performing an out-of-source build, removing these\nand all other build/test artifacts is as simple as git clean -xfdn or rm\n-rf build from the project root.\nCan you think of any actionable fixes for this issue?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/666#issuecomment-214582914\n. Delayed ack is ok, just not with Nagle.\n\nlibnng disables Nagle by default.  I'll probably offer a method to turn it on.\nWe don't need to use TCP_CORK for those cases though, as we use writev to scatter gather (or WSASend which also has gather ability), so that's a non-issue.\nClosing this as WILL-NOT-FIX for nanomsg.  For nng its ALREADY fixed.. Looks good.  You want to rebase this or should I?  Also you want to update copyright?\n. Conceptually the idea of enforcement is sound.  I don't know if pre-commit-hooks are the right answer, but pre-push ones definitely are.  (The later we control everywhere, the former we do not.)\nThe first step is choosing a style.  One that can be applied mechanically is desirable.\n. I'm closing this issue for now -- the current coding style has problems with it that make it \"challenging\" to apply a BSD style (especially 8 character tab stops) without refactoring to shorten variable and symbol names, and reducing indentation generally.\n. Rebased and merged:\ncommit d4da848d4fcda57cb893e2ae67436b3729abe620\nAuthor: Snaipe franklinmathieu@gmail.com\nDate:   Wed Apr 27 12:23:41 2016 +0200\nfixes #681 Speed up appveyor builds\n. Jack, go ahead and integrate this whenever.\n. Well, my attempt to simplify windows checks for libraries failed miserably.  I'll revert that portion.\n. I'm pretty sure this is a failure induced by severe stress on Windows AppVeyor.  Not seen outside of Windows.\n. This problem has gone away.  I'm going to close this.  I think putting undue stress on the system causes failures due to resource exhaustion.  The AppVeyor service we have is a free level of service, and is easily buried under load.\nAlso, the library didn't fail.  It returned an error back to the app.\nFinally, it would not surprise me if there are internal limits on the total number of NamedPipe instances on the system in Windows.  With parallel testing, we may run into those limits.  There is a maximum of 255 NamedPipe instances for a given NamedPipe.\n. I'm not sure how big your messages are.  UNIX domain sockets may limit your data sent to 576 bytes at a time.\nThere is a linger socket option, but I don't think it is used for UNIX domain sockets, only for TCP.  And I'm not sure that even that covers it completely.\nIf you're using Go, I recommend using mangos.  Mangos does have have a linger option (OptionLinger) which may help you.   The linger is given in a time.Duration, and mangos will attempt to wait until its queues are empty, or that timeout has expired.  Its still not perfect, because you can lose data -- indeed close() of a UNIX file descriptor can result in the data being dropped in the kernel even after write() completes and there's not much we can do about that.\nIf you're truly paranoid, you need to have an ACK message back.  That is, you cannot know for sure that the other side received the data unless it tells you so (and you hear -- or receive -- such a message).\nIf you're just testing, you could have an ACK on a secondary channel (req/rep, or even a PUB/SUB in reverse) to let the sender know the message was received.\n. Oh, also naively, you could just inject  a sleep before exiting.  Its not ideal, but simple, and as long as your messages are not too big and you have connectivity, it should work.\n. Closing- not a bug.\n. The problem is lack of linger.  Your program (nanocat in this case) is exiting before the message is fully delivered. IPC doesn't have a linger but TCP does. \nSent from my iPhone\n\nOn May 6, 2016, at 7:33 AM, Chasx notifications@github.com wrote:\nI am in the process of deciding between a couple of messaging frameworks. My particular situation would contain a lot of 'workers' that send their information to one 'chief'. I think push/pull is most suitable for that.\nI made a test program over IPC but it fails often so I tried nanocat to do the same but that also fails:\nIn one terminal screen I start \"nanocat --pull -X /tmp/pipeline.ipc -A\"\nIn another terminal I run \"echo test | nanocat --push -x /tmp/pipeline.ipc -F-\"\nBy just firing the second command a couple of times the 'test' message is sometimes not shown on the first terminal. I think about about 30-40% of the sent messages are not arrived. If I switch to TCP instead of IPC the problem does not occur (or at least not so very often as it is here).\nAm I doing something wrong? Is this expected behaviour? I am running nanomsg 0.8 on Linux Mint (Ubuntu 14.04).\nUltimately I would have like to use nanomsg (or something else) to solve producer consumer problems and a couple of other messaging patterns.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. Sleep is probably sufficient.  Short of acking the data (eg via req rep) there isn't much else you can do. \n\nSent from my iPhone\n\nOn May 6, 2016, at 8:24 AM, Chasx notifications@github.com wrote:\nOk, and what is the best way to fix this? I tried the first example (pipeline) on http://tim.dysinger.net/posts/2013-09-16-getting-started-with-nanomsg.html and this also shows the problem when starting a couple of 'node1's'. Would it suffice to just add a 'sleep' before 'return nn_shutdown (sock, 0);' or is there a better way?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\n. Yes if you can do this having the ack is a definite win. :)\n\nSent from my iPhone\n\nOn May 6, 2016, at 8:40 AM, Franklin Mathieu notifications@github.com wrote:\nI am in a similar situation. What I did was to setup a reverse REQ/REP (The server is REP, the workers are REQ). When a worker has information to communicate upstream, it sends a message to the server, and the server responds with some kind of ACK message (Either OK or an error status). This solves the problem of lingering regardless of the transport and has the advantage of providing basic error handling.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\n. Closing; not a bug.\n. Is it always the same stat that fails ?  I wonder if we aren't waiting long enough for connections to establish. \n. Hmm... we attempt to reconnect after 100 ms.  But we sleep only 200 ms, and we don't sleep between the bind and the connect.  Maybe inserting a short sleep there (as usual) would help -- at least until we get bind to be properly synchronous.\n. What platform are you testing on?  I've not seen it fail on MacOS X.  I suspect that both failures are related to load on the system and not waiting for the asynchronous bind to complete before trying the connect. \n. Yes.  I used both on MacOS.  What platform are you testing on?\n\nOn Tue, May 10, 2016 at 10:12 AM, Jack R. Dunaway notifications@github.com\nwrote:\n\nImportantly, are you using the -j64 flag from the original comment? This\nis most oftentimes what it takes to repro. --repeat-until-fail 25 is also\nimportant\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/691#issuecomment-218225979\n. Ok, this seems to be due to AppVeyor running under severe load (see #698).  Without -j4 this passes.  However, I think we should try to make the test a little more robust.  One way to do that is to ensure that we inject a sleep after the bind before the connect.  100 ms ought to be sufficient (on a reasonable system -- not AppVeyor with -j4 or higher).\n. I'm pretty sure also that on AppVeyor we have problems where the TCP sockets are limited -- I suspect that this is a \"non-issue\" in terms of actual quality, and that we can close it.\n\nIn particular, we've not seen any more instances of this since we made other changes.\n. This should address the problems noted in #562 as well.  nn_term will remain useful for some consumers, but in general its behavior will be far more predictable.\nNote that nn_term should also be considered optional -- that is it shouldn't release any resources that would not also be released by a call to nn_close() of the last socket.\n. Marked this a release stopper -- we need to make a decision on this before 1.0.  Ideally before 0.9.\n. Actually, I've decided to leave this in place for now.  It turns out that people are using this, and we can pretty easily replace with better logic with a narrow wrapper later, when we have condvar based signaling and whole threads.\n. Fixed and integrated:\ncommit 994a99f7180017218fe3866fffd70a9990dfb7f6\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Tue May 10 13:07:16 2016 -0700\nfixes #692 nn_term semantics are busted\n. Much has changed here, and I'm planning to reimplement websocket in the nng library.  I'm punting on this CR, which has merge conflicts anyway.  If that's an issue, let me know (or resubmit), but frankly it's probably not worth the effort now.. So there are a couple of problems here.\nThe test actually pounds the CPU hard, spinning at a ridiculous rate in the send loop, because it uses NN_DONTWAIT.\nSecond, it never yields the CPU.  This is problem because Windows threads don't context switch naturally.  We need to intentionally relinquish the CPU with a zero time Sleep() call.  This may underscore problems with the Windows threading library in general, since it seems to depend on the system timer for scheduling.\n. Rebased and integrated:\ncommit 994a99f7180017218fe3866fffd70a9990dfb7f6\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Tue May 10 13:07:16 2016 -0700\nfixes #692 nn_term semantics are busted\nThe fix for #699 and tcp starvation is left for later.\n. Just a brief note.  This code is really kind of bogus -- we have no way to cope with an error for the caller.  Really we need to design this code so that it cannot fail.  Using condition variables and mutexes instead of relying on frangible system calls would be superior here (for numerous reasons).\n. That's good information, thanks. \nI'm sort of uninterested in 'fixing' this at present, since I'm looking at other ways to eliminate the whole kqueue/poll/select thing, and instead simply use synchronous threading.  Elimination of async I/O will solve many problems, and is an enabler for refactoring nanomsg to eliminate the FSM madness that makes it incredibly difficult to work with (or to extend).\n. Closing this in favor of the nng rewrite.  There are other points of fragility in nanomsg, but this one doesn't really come up in practice.. All fixed up now.  Closing.\n. This is all resolved differently now.  Closing it.\n. If the initial build works, I'll add NN_MUTEX_DEBUG to the CI environment files.\n. I'd like to avoid allow_failures for MinGW 64.  It either works, or it doesn't.\n. I am considering deprecating VS 2010... We are at VS 2017 now, and 2012 and newer are \"free\".  (Modulo you have to pay for them if you are an \"Enterprise\".  Most developers can use it for free, and if an Enterprise isn't willing to buy a license... well, I'm not really interested in that.). So I spent a little time on this, and I've pretty much given up (for now) getting MinGW-W64 to build properly in AppVeyor.  I think I see the way forward, but it just isn't that important -- frankly with Visual Studio being free (as in beer) for almost everyone (except Enterprise users), there is little reason to worry about it.  (Libre toolsets is kinda not really important when the user is already running on and building for an inherently closed/proprietary platform like Windows.)\nHaving said that, I've updated to validate 2017 in both debug and release builds -- including getting the various cmake flags right (I finally understand why Visual Studio is a PITA on that platform -- everyone should just use NMakefiles and life would be better lol).. After spending the better part of a day to resolve this, what I've learned is that the AppVeyor 2017 infrastructure doesn't support running our tests consistently.  I think they are probably using a different infrastructure, with different constraints.\nAt this point, I'm going to just punt on this.   If we are still supporting this library (and making changes to it) in a year or two, we might want to revisit -- but I fully expect to have moved all resources into nng by then. . Yeah, I think I'm going to go ahead and remove the debian packaging then.\n. It is short enough to leave the license text in place only changing the copyright statement. \nSent from my iPhone\n\nOn May 16, 2016, at 8:12 PM, Jack R. Dunaway notifications@github.com wrote:\nI agree (speaking for myself and business) to past/future contributions consolidated under a blanket copyright holder 'nanomsg authors' in the source files.\nWould the license itself remain in all source files? Or would it be removed as the top block comment, replaced by a reference to this new LICENSE?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\n. I'm declining to do this for now.  Github seems happy enough with COPYING.  We can rethink in nanomsg-next.  :-)\n. I wonder if instead there is a way to turn CMake warnings into failures?. The other thing we can do is put some extra validation in the CI script(s) for this.  TBH I don't want to needlessly complicate the CMake code if we can avoid it.  That stuff is brittle enough as it is.. Right now, using Travis, I control fairly tightly the installation of asciidoctor.\n\nI'm going to punt on this for now; changes here buy little value, and I'm more focused on the libnng project.. With the conflicts and such, I'm going to close this.  Please resubmit if this is important, but honestly I'm much more focused on nng at present.. I'm doing something like this for the nng code base.  I'm not terribly interested in bothering doing it with libnanomsg at this point.. I think the answer is that we should update the .version file manually just before we push a new tag. \n. I'm pretty sure we should do this for Linux.  The problem is that Linux requires ldconfig to be run, and the CMake build doesn't do this automatically.  (Its not necessarily appropriate that it do so!)\n. Thanks.  Did you have to do anything specific or make any changes to the\nCMakeLists to make packaging work for you?  I would appreciate any\ninformation about how you do this that you can share, including e.g. cpack\narguments, etc.\nOn Wed, Jun 15, 2016 at 10:51 AM, Jerry Jacobs notifications@github.com\nwrote:\n\nIt is nice to have deliverables for common used versions (E.g Debian 8), I\nuse this in production to generate debian packages with CPack and works\nlike a charm. If there is any help needed for debian I could assist but\nprobably we would need some infrastructure (if we want this automaticly).\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/729#issuecomment-226266308,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ABPDfX4L5kW9iavJ8gmgfZWtuTNghtM7ks5qMDuhgaJpZM4IlzTi\n.\n. I'm having mixed feelings about this.  Really as a library it would probably be best if developers just linked statically.\n\nAt any rate, I won't be changing this for nanomsg.  I'm open to thinking about it for libnng.\nCLosing this one against nanomsg for now.. Cool. I'll merge momentarily.\n. Actually the AUTHORS file is alphasorted. \nI'll fix and fix the commit comment.  Stay tuned.\n. Its actually the ep FSM.\n. Well, epbase itself needs to go away.  This was created to provide an abstraction layer above the ep, to separate some of the core API from the transport API, but this adds confusion, extra indirection, and buys us nothing.\nIts time to eliminate the epbase layer.. The POSIX usock code will need a major overhaul to support this though.  The windows code on the other hand is a slam dunk.\n. We're abandoning this in favor of nng, which doesn't use external pollers at all.. We call the config file 'nanomsg.pc' rather than libnanomsg.pc.   Probably go-nanomsg should be updated. \nI'm not sure why the nanomsg program isn't linking.  Possibly this is a Linux ldconfig thing.  I will investigate further -- my development platform is MacOS X and illumos where ldconfig isn't needed.  (I thought CMake would have taken care of this for me, but I may have been mistaken.)\nThat said, if you're using go, I highly recommend mangos -- http://github.com/go-mangos/mangos -- over nanomsg.  It's way more functional, written in pure Go, and almost certainly outperforms go-nanomsg.  It's also wire compatible with libnanomsg.  So you can still speak to the same programs.  It's also much more idiomatic go.  And if you don't need wire compatibility, or are willing to create a device to gate requests, mangos offers security via TLS or websocket over TLS.  Finally, it scales much better.\n(Disclosure: I wrote mangos -- but I'm also the \"maintainer\" of nanomsg, so you can consider the advice to prefer mangos more or less \"official\" from the nanomsg team. :-)\n. So you need to run ldconfig to update the linker cache.  CMake doesn't do this.  This really underscores the fact that we need to prepare binary packages (.deb and .rpm) for Linux.  Sometimes I really hate Linux. \nThis would be one of those times.\nWe can also look at using CMake to do this if doing make install with the default prefix -- but this gets sticky, since users changing the prefix are going to have challenges.  (You don't want this to be done for per-user installs.)\n. Thanks for the glock.c & glock.h feedback.\n. Hmm... with glock.c and glock.h ... that's strange.  I think maybe the Go build is broken or stale here -- perhaps an earlier build of this library with stale configuration or Makefile bits?  Or perhaps the go package doesn't just use our CMake build?\n. Ah. Ok. I removed the autotools support form the master branch already. \nSent from my iPhone\n\nOn May 30, 2016, at 12:51 AM, Franklin Mathieu notifications@github.com wrote:\nThe go package is probably using the Autotools generator, which still references glock\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Ah, well, yeah.  We can suggest that.  Really I'd hope folks installing from source know how to use cmake these days.  That said...  it seems sometimes they don't.  I wonder if I should create a \"configure\" script that parse --prefix= and just calls CMake...\n\nThat said, it would be nice to produce binary packages for these distros.  Distro builders should do the needful IMO.\n. MinGW is not a supported environment.  You can build with MinGW-w64.  (The problem is various newer APIs are not supported by MinGW, including, as you've noticed, condition variables.)\nI'm closing this as will-not-fix, not a bug, etc. \n. Well, it seems that handling the events recursively causes other problems.  We really need to drop these else we get a hang.\n. They are similar having been created by the same author. The main differences are that nanomsg is written in pure C with a BSD socket-like API and is licensed under a liberal MIT license.  0MQ is C++ with its own incompatible API and GPL license. \nNanomsg strives to be small and light weight. 0MQ tries to solve a lot more problems (eg security etc.) \nMore detail is linked to from the documentation link on the main site. \n. Turns out that there was a solution to this, and I've fixed this in libnng already.  However, I'm not going to bother backporting this to libnanomsg since it probably isn't bothering anyone, and I want to focus on getting nng ready for production.. Yes. Sorry. \nSent from my iPhone\n\nOn Jun 1, 2016, at 11:41 PM, Bent Cardan notifications@github.com wrote:\nyou mean websocket right\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. If the symbol is not available then is this going to build anyway?  What happens if you remove the check?  Normal MinGW-w64 works fine in appveyor. \n\nSent from my iPhone\n\nOn Jun 4, 2016, at 11:07 AM, Franklin Mathieu notifications@github.com wrote:\nIt seems that on some environments, CMake with MinGW-w64 fails to find InitializeConditionVariable, even though the host supports it.\nThis seems to happen because the CMake distributed with MSYS2 lies when providing the WINNT version, which makes MinGW-w64 believe it's running on windows XP.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. it sounds to me like the problem is cmake. it is lying about the environment and claiming to be XP.  a platform we dont support. \n\nSent from my iPhone\n\nOn Jun 4, 2016, at 12:22 PM, Franklin Mathieu notifications@github.com wrote:\n@gdamore The symbol is available, it's just ifdef'ed out because _WIN32_WINNT is defined to something lower than 0x600 by MSYS2's cmake.\nIt can be visible on appveyor itself when calling C:\\msys2\\usr\\bin\\cmake instead of C:\\Program Files (x86)\\CMake\\cmake.exe.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. can you point me at relevant information from MSDN?\n\nSent from my iPhone\n\nOn Jun 4, 2016, at 12:55 PM, Franklin Mathieu notifications@github.com wrote:\nThis explicitely tells the compiler that we target Windows Vista and later. Symbol checks on earlier versions of windows will fail regardless, since the linker won't be able to find the symbol even if it's declared.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/nanomsg/nanomsg/pull/755\nCommit Summary\nfixes #754 CMake may not find InitializeConditionVariable\nFile Changes\nM CMakeLists.txt (4)\nPatch Links:\nhttps://github.com/nanomsg/nanomsg/pull/755.patch\nhttps://github.com/nanomsg/nanomsg/pull/755.diff\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. thanks. this was helpful. will merge when back at home. :)\n\nSent from my iPhone\n\nOn Jun 4, 2016, at 1:07 PM, Franklin Mathieu notifications@github.com wrote:\nSee https://msdn.microsoft.com/en-us/library/aa383745(v=vs.100).aspx and https://msdn.microsoft.com/en-us/library/6sehtctf.aspx\nExplicitely setting a WINNT version is encouraged when targetting specific features.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I have not been able to reproduce inside my Windows 8.1 VM.  Which makes debug hard.  Doing anything inside Windows is a substantial PITA.  Any chance at repro using POSIX code?\n. Looking at the code, I don't see a likely problem.  What is interesting is your windows code is calling \"spawn\" -- I'm not familiar with the Windows process model -- do these processes share anything in common with their parent (ala fork)?\n\nThe xrep code should discard responses sent to a pipe that is no longer connected.  The way it does that is to look for the pipe id in the hash.  I'm pretty sure pipe IDs don't collide, and the allocation avoids reuse.  So I'm fairly stumped.\nI'm wondering if there is some kind of data sharing taking place that we're not spotting (e.g. stack overrun, or something like that.)  Again, reproducible test cases would be very very helpful.\n. One thing is that the hash table in used isn't locked.  In theory we should be operating in the context of the socket so it should be ok.  But I would admittedly feel lots better with explicit locks around data structures like the hash table.\nAn experiment you could add would be to add a mutex to the hash table and see if that solves the problem.\n. I wonder if this is the issue with nn_realloc() not doing what we thought it did?\n. Ah, glad you figured it out!\n. the idea there is to make it easy to write test programs.  lt isnt meant so much for folks who want to use as a coding example. \nSent from my iPhone\n\nOn Jun 6, 2016, at 1:08 AM, Bent Cardan notifications@github.com wrote:\ntests/testutil.h header does a great job of code abstraction where little or nothing's repeated.\nthat fancy code makes the tests harder to follow and more useless when you want to reference implementation or paste simple building-block snippets of patterns/socket types\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. no.  they often delve into internal behaviors and validate assumptions that the core cares about but consumers should not. they often poke at the api in non recommended ways to verify edge case behaviors.  they often intentionally handle errors particularly badly (asserting success instead of testing and handling failures cleanly.)  they may intentionally inject failures to test for internal error handling. \n\ntest cases are test cases.  they are not examples to emulate in real world programs. \nSent from my iPhone\n\nOn Jun 6, 2016, at 7:51 AM, Bent Cardan notifications@github.com wrote:\nsure, but tests extend documentation beyond coding example.. they detail your and other author assumptions, intent about the API and how it should be used\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I'm going to create some demos specifically to help you out here. :-)\n. Pushed.  Look in git master, under demo/ \n. It looks like dash does not support array variables.  I will investigate.\n. Yes, I see that.  I\u2019ll have this fixed shortly.\n\nOn Tue, Jun 7, 2016 at 10:08 AM, Franklin Mathieu notifications@github.com\nwrote:\n\niirc array variables are nonstandard, and dash was made to strictly comply\nto the POSIX shell specification without any extension\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/761#issuecomment-224347828,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ABPDfVoKTEpOgzWtDiFvsa1C-BsKxcNVks5qJaVzgaJpZM4IwEQr\n.\n. Hmm.. I will have to investigate this further.\n\nOn Fri, Jun 10, 2016 at 10:54 AM, James Masco notifications@github.com\nwrote:\n\nAfter compiling the nanomsg static library using Visual Studio 2012, it\nappears symbols are missing from the nanomsg.lib file that is generated.\nWhen linking against this library I get missing symbols:\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_errno\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_strerror\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_freemsg\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_socket\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_close\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_setsockopt\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_bind\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_connect\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_shutdown\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_send\nmy_class.lib(my_class.obj) : error LNK2001: unresolved external symbol\n__imp_nn_recv\nAfter checking the lib using dumpbin, these symbols are not found and all\ntheir nn_* counterparts are defined as externals.\nCMake command (in a build directory) used to generate this lib:\ncmake -G \"Visual Studio 11 Win64\" -DNN_STATIC_LIB=ON ..\nCreating the static lib in a similar way on a CentOS 7 box did not have\nany issues and linked with the same code base I am seeing errors with on\nWindows.\nI've attached the generated static lib for your review.\nnanomsg.lib.zip\nhttps://github.com/nanomsg/nanomsg/files/309486/nanomsg.lib.zip\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/764, or mute the thread\nhttps://github.com/notifications/unsubscribe/ABPDfdBgoL_g6qyzuuyzSK7i6uCJHQ5cks5qKaTUgaJpZM4IzLZT\n.\n. I think static builds are non default and the user should put this in their environment.  Our header files are not generated at present. \n\nSent from my iPhone\n\nOn Jun 10, 2016, at 12:11 PM, Franklin Mathieu notifications@github.com wrote:\nOh. It seems that Visual Studio is trying to link against the dynamic link version of the library -- mostly because NN_STATIC_LIB isn't defined in your user build, which in turn prepend __declspec(dllimport) to all functions.\n@gdamore, what's your stance on this? Should the user always define NN_STATIC_LIB in their user build with a static nanomsg, or should nanomsg install a config.h header that provides that definition conditionally?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Sheesh I hate Windows DLL crap. \n\nSo if you're not using the default built, then its on the user's shoulders to make it work.  I'm closing as not a bug.\n. sounds like a good use case for nanomsg to me. \nSent from my iPhone\n\nOn Jun 11, 2016, at 7:22 AM, Dillybob92 notifications@github.com wrote:\nHey guys,\nJust curious... I have 3 node processes and was curious if nanomsg would be good for IPC. I am using the processes for game instances for my Diablo 2 style game.\nWhen players join the load balancer they get put on a random node (to help scale nodejs) -- but when they move around in the game I need to send messages through IPC.\nI was wondering would Nanomsg be the right solution for this, or node-ipc? Would there ever be a bottleneck if using nanomsg?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. pub / sub and any IPC adds latency.  We're talking about TCP transitions here so its probably on the order of hundreds of microseconds.  Whether that is \"significant\" latency depends on your app.  For chat and gaming (even video and voice) a few hundred mikes is not noticeable.  For high frequency trading it can be tragic.\n. Building without CMake is NOT supported.  A lot of changes have happened recently, and the CMake dependencies have changed.  In this particular case, the pollers are no longer used for Windows; instead we use a simpler solution based on completion ports natively in the worker_win.inc file.\n\nI'm going to close this, because you are well outside of the supported methods for building libnanomsg by not using cmake.\n(That said, why do you dislike cmake?)\n. Good fix. I'll rebase and merge.\n. exactly. \ndirect inclusion in SOURCE form into other projects is not a design goal. \nwe can argue whether it should be. but in that case I would like to understand why this is desirable or necessary. \ntesting for platform capabilities is complex.  any kind of ability to just drop in source (eg via a single C file) would either require a script to build a platform specific version of that C file or for the user to provide definitions explicitly instead of auto generating them. \nSent from my iPhone\n\nOn Jun 19, 2016, at 4:11 AM, Franklin Mathieu notifications@github.com wrote:\nThe simplicity you speak of with the sqlite3 build system is an illusion.\nConsider why cmake was made in the first place: to provide a platform-agnostic build system whose main goal is to define a consistent lifecycle that checks, builds, and tests.\nHow do you test for features? How do you test for functions? How do you test for ABIs ? sqlite3 tells you to define the appropriate -DHAVE_XXX macro, as if it solves the underlying problem -- it doesn't, because not all features can have a fallback, and if so it just moves the problem to the user and platform maintainer. Nanomsg and almost all serious cross-platform library projects doesn't use cmake (or autotools) for show, they have to because you can't make assumptions when working with different platforms.\nOkay, to be perfectly honest, I wasn't very fair with my last paragraph -- sqlite3 do test for features with a ./configure, and probably generates a config.h that then gets bundled inside the amalgamation. However, that doesn't mean that this is still that much of a good idea ultimately, precisely because sqlite3 and nanomsg have different requirements and it just isn't fair to compare them at this level.\nsqlite3 needs to be bundled in a lot of different situations, with different features enabled within the same platform. The traditional \"one size fits all\" model doesn't make sense for them, so they provide an amalgamation so that people can build their own flavor. On the other hand, nanomsg doesn't really have significant parts to disable or enable, it just does checks for platform features.\nComing back to my initial statement, the simplicity that would be provided by a nanomsg amalgamation is an illusion, because using nanomsg in any project is just as simple:\ngcc foo.c -lnanomsg\nI don't see what's wrong with the model you speak of. Just build the library with -DNN_STATIC=ON, and link the produced static library. You just don't have to do anything else.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I'm going to take this under advisement for nng.  But for nanomsg, I'm not going to worry about it.  (nng has been designed to support amalgamation, and it already supports direct inclusion.). Yeah, we will fix it.  Thanks for filing this.\n\nOn Sun, Jun 19, 2016 at 5:48 PM, museghost notifications@github.com wrote:\n\nHi Team\nAt first, I appreciate you and the team for releasing the nanomsg 1.0\nfinally.\nI am a fan and user for the nanomsg for a long time since 0.2.x branch.\nAlso the library is running on my production environment successfully.\nSo, as a fan, when I try to compile the library in Windows with CMAKE, I\nfound the typo in the BUILD section. I think it would be changed from\n\"ctest -G Debug .\" to \"ctest -C Debug .\".\nCould you please update on this, if it is correct ?\nThank you for your continuous effort !\nBest Regards\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/770, or mute the thread\nhttps://github.com/notifications/unsubscribe/ABPDfazYH6STumPmmvRyNzeaSg4NZDNiks5qNeNPgaJpZM4I5Siv\n.\n. Is it reproducible?  I do test on MacOS X.\n. I\u2019m not seeing problems, but I am using a multicore iMac 27\u201d.\n\nI\u2019m also running 10.11.4.\nOn Mon, Jun 20, 2016 at 1:11 PM, Bent Cardan notifications@github.com\nwrote:\n\nyea i was hesitant at first because i thought you developed on osx, but it\nhappens on both my macs.\nwhat happens when you run ctest -G debug; or ctest -C debug; ?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/771#issuecomment-227255041,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ABPDfYSSJj2fXfbkM5Q-fxwPIZG5jZa_ks5qNvP3gaJpZM4I6EZG\n.\n. 49200 is in the range of ephemeral ports.  These ports are more likely to conflict as they can have been assigned for ephemeral use. \n\nwe should choose a new starting port but one below 16000 I think. \nSent from my iPhone\n\nOn Jun 21, 2016, at 1:59 AM, Franklin Mathieu notifications@github.com wrote:\nIdeally we should be using an ephemeral port for tests, but since it's not yet supported, I propose a little fix to use port 49200 and higher, since it's in the reserved private range and will guarantee to not conflict with anything else.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. recommend 12100 or 12500 as they have no known common uses or iana reservations. \n\nSent from my iPhone\n\nOn Jun 21, 2016, at 1:59 AM, Franklin Mathieu notifications@github.com wrote:\nIdeally we should be using an ephemeral port for tests, but since it's not yet supported, I propose a little fix to use port 49200 and higher, since it's in the reserved private range and will guarantee to not conflict with anything else.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. why closed?\n\nSent from my iPhone\n\nOn Jun 22, 2016, at 1:52 PM, takuyozora notifications@github.com wrote:\nClosed #773.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Yes, this is right.  There are state machines that still have references, and that would be the wrong place to free the structure.  I'm looking now.\n. Confirmed.  It appears that the parent listening structure is not freed.  I'm analyzing now.\n. I'm going to close this, as this isn't a bug.  I think this is all standard \"using CMake to cross compile\" stuff.\n. Ok, I think I see the problem.\n\nIn the refcnt.n == 1 case, we reallocate, and include the header in the allocation.  This is probably not strictly necessary.\nWhat we'd like to do is preserve the data where it is, using \"realloc\" only if we're going to actually be able to benefit from the reallocation -- that is that we can save a separate alloc and data copy.   In that case it should just be an update to the size.\nIn the other case, we should just do the same as when refcnt.n != 1, and do an explicit alloc and copy.  Its not going to be any different than a libc based realloc in terms of performance.\nStay tuned for more.\n. Yes, I see several more issues here.  This is going to take some time as I want to make sure that I get the semantics right here.\n. Note that this is fixed in libnng... I still need to look at resolving this for nanomsg itself.. Ok, looking at this in a bit more detail.\na) The empty space at the beginning is entirely optional, and cannot be reclaimed, or really referenced, in application.  Once an application calls chunk_trim() or chunkref_trim(), that's gone.  So we don't need to \"preserve the space\". \nb) We can expand into the space intelligently -- if the new size is small enough to do so, and memmove.\nc) We only have to memmove if the new size is larger, and still fits in the extra space.\nd) Arguably, we could save allocations if we 'always' moved data to the end when preserving data, but to be honest reallocmsg is probably called infrequently that it doesn't matter.. So this is PAIR.  Basically we are saying that the socket is already paired, and we can't add additional ones.  Sadly we are aborting here rather than just returning a sane error code.  Stay tuned.\n. This seems to be tied to inproc as well.\n. I'm pretty sure the above fixes the issue.  Please feel free to verify for yourself.  I'll probably merge this shortly.\n. I think I've seen several issues like this around inproc.  The linking of state machines on the sender and receiver is really problematic; probably what I need to do is just rewrite inproc from the ground up.  I've come close to this several times (started a few of them).  Each pair of connected inproc sockets would then be serviced by either one or two worker threads, that would handle everything.\nIf this reproduces in any of the other transports I would like to know.  At the moment I'm just considering it another one of the various inproc related problems.\n. I'm pretty opposed to making nn_mutex recursive.  This will cause an entire new class of bugs to be possible.\n. almost every case i have seen for recursive mutex use over the years has lead to deadlocks and harder to debug problems. \nrecursive mutexes here wont solve our problems. they may give a bit of immediate palliative relief at best. \nSent from my iPhone\n\nOn Jul 6, 2016, at 3:03 PM, Jack R. Dunaway notifications@github.com wrote:\nPerhaps, but it provides the ability to solve many bugs that still plague us.\nFor that reason, I've already changed the function prototype to be void nn_mutex_init (nn_mutex_t self, int recursive) (it used to be void nn_mutex_init (nn_mutex_t self)), where every callsite in the codebase to nn_mutex_init sets recursive=0 except for the mutex that protects ctx objects -- it can be recursive.\nI'm still in early testing, but plan to have some more concrete commits tomorrow. This PR will remain a sandbox for testing.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. This is really another item of #582  nanomsg is not fork-friendly at present.\n. (Closed this as we are tracking under #582)\n. I recommend looking in the demo/ directory of the source tree.  There is a program called \"pthread_demo\" that shows how to use this.  To use asynchronous calls you need to use the raw mode sockets, because the simpler REQ/REP send/recv code path need to be processed synchronously.\n\nAt any rate, this \"issue\" isn't a bug at all, so I'm going to close it.\nPlease ask for help on the nanomsg mailing list (nanomsg@freelists.org) if you need further assistance.  Be prepared to describe exactly what problem you are trying to solve, and hopefully we can offer more concrete assistance.\n. Probably we are at the point where the ABI & API are stuck where they are.  I don't intend to make significant changes in 1.x.\nThe next ABI version will be as part of a more substantial set of changes (which will probably also have API changes) as part of nanomsg-2.0.  At that time, we should fix the links, and probably only publish the new ABI (presumably 6.0.0) -- and abandon the old \"marketing\" version link in the filesystem.\nThat said, I might change the library's name to nanomsg2 or nn2 or something.  We will see how drastic things get.\n. What's really the case here is that libnanomsg.so.1.0.0 (or whatever) should NOT exist.\nInstead the canonical version is libnanomsg.so.5.0.0 (which represents the ABI version, and has nothing to do with with the package version!)\nI need to figure out how to convince cmake not to create the libnanomsg.so.1.0.0 (or whatever) link in the first.. The wording is suboptimal, but I'm not sure what would be better.  nanocat is mostly just a test utility anyway -- I hope you aren't building on top of it. . Looking at this in more detail, the generic option parser we're using is not capable of saying something better here -- I'd have to rewrite the option parser, or bypass it altogether.  For this use its simply not worth fixing.\nI'm closing this as will not fix for now.  I may revisit this for nng's nngcat.. thanks.  i want to investigate to see if we should be handling this more generically. stay tuned. \nSent from my iPhone\n\nOn Jul 14, 2016, at 10:44 PM, majklik notifications@github.com wrote:\nActually websocket transport do not allow make connection from some browser, including Firefox. The problem is that library now accepts only header \"Connection: Upgrade\", but Firefox uses \"Connection: keep-alive, Upgrade\", which do not violate websocket RFC.\nA fast workarounf for src/transports/ws/ws_handshake.c:\n--- ws_handshake.c      2016-06-10 19:59:35.000000000 +0100\n+++ ws_handshake.c.new  2016-07-13 18:39:36.000000000 +0100\n@@ -996,8 +996,10 @@\n     }\n/*  RFC 6455 section 4.2.1.4 (version December 2011). */\n-    if (nn_ws_validate_value (\"Upgrade\", self->conn,\n-        self->conn_len, 1) != NN_WS_HANDSHAKE_MATCH) {\n-    if ((nn_ws_validate_value (\"Upgrade\", self->conn,\n-        self->conn_len, 1) != NN_WS_HANDSHAKE_MATCH) &&\n-       (nn_ws_validate_value (\"keep-alive, Upgrade\", self->conn,\n-        self->conn_len, 1) != NN_WS_HANDSHAKE_MATCH)) {\n       self->response_code = NN_WS_HANDSHAKE_RESPONSE_WSPROTO;\n       return NN_WS_HANDSHAKE_INVALID;\n   }\n  \u2014\n  You are receiving this because you are subscribed to this thread.\n  Reply to this email directly, view it on GitHub, or mute the thread.\n. @JackDunaway we need to get this fixed... did you have plans to address, or should I?\n. Its been over a month since then?  Any update?  Else I will fix.\n. So I'm working on this now.  I see that the Connection: contents are actually somewhat mishandled.  The current code only handles the single value for Connection, as noted, but it also assumes that the Upgrade will be the last one found.  So not only will combining the headers break, but so will misordering them.\n\nReally, a proper parser/grammar is desired here.  It seems a shame to have to invent our own.\n. are you forking a subprocess?  nanomsg is not fork friendly. \nSent from my iPhone\n\nOn Jul 15, 2016, at 1:26 AM, taolinke notifications@github.com wrote:\nIt's very strange.\nI write a message distribute server upon nanomsg.\nBut after some time,when i restart the server, i failed because the listening port has been used.\nHere is the situation:\n[root@vsmHost12 src]# lsof -n -i:3333\nCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\nhsmcs 105013 root 20u IPv4 24845821 0t0 TCP _:dec-notes (LISTEN)\nhsmcs 105013 root 66u IPv4 25366582 0t0 TCP 192.168.167.1:dec-notes->192.168.167.1:47826 (ESTABLISHED)\njava 111946 root _20u* IPv4 24845821 0t0 TCP *:dec-notes (LISTEN)\njava 111946 root 34u IPv6 25366581 0t0 TCP 192.168.167.1:47826->192.168.167.1:dec-notes (ESTABLISHED)\nIt's not because of the java, some other daemon may also have the problem.\nLook at the FD number and DEVICE number, it's the SAME!\nCan anyone explain it ?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. popen should be fine as is fork followed immediately by exec.\n\nSent from my iPhone\n\nOn Jul 17, 2016, at 12:36 AM, taolinke notifications@github.com wrote:\nIs that mean i can not use functions like popen or system?\nIs nanomsg-1.0 fork friendly?\nOr is there a way i can avoid it?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. We should verify that nanomsg uses close on exec everywhere that it can. \n. It does attempt to set close on exec.  There are possible race conditions on some platforms (unavoidable, sadly), so its still an excellent idea for the programmer to ensure that unused files are explicitly closed between the fork() and the exec().  This can be done manually, or it can be arranged via posix_spawn() and file_actions.  (There are some non-portable extensions on some platforms to make this even faster than just looping through the maximum number of possible file descriptors and closing them -- for example MacOS X has POSIX_SPAWN_CLOEXEC_DEFAULT,\nand illumos/Solaris have posix_file_actions_add_closefrom_np().\n\nThere is some thought that we could \"freeze\" nanomsg during a fork, to make situations where we attempt to create a file descriptor a 'fork-critical section' -- meaning that these functions would cause fork to block -- that would largely close this particular race, though it wouldn't do anything for the situation where some one just directly calls exec() without doing fork first.  (In that case I don't think there is anything that can be done.)  It's also unclear whether posix_spawn() would respect the necessary atfork() handler.  (It would appear that illumos' posix_spawn does NOT invoke the pthread_atfork() handlers.)\n. I'm declining to make this change for nanomsg, as it doesn't work for Windows, and has a bunch of caveats.\nBetter to create a new program (perhaps in a new repo) that has this behavior if it is what you need.. Thanks.  Will probably merge this soon.\n. This looks good.  I'll commit later today, but I will rebase and fix the commit comment.\n. Fixed in \ncommit 434f9f0d4b2c951ab4158b34d4b3c9063e74a482\nAuthor: xiaocheng lh563566994@126.com\nDate:   Sat Aug 6 22:22:07 2016 +0800\nfix #789 incorrect state assertion in usock_posix.inc\n. This seems strange.  The tests run on Windows (but not Windows 10 I think -- probably 8.1 or somesuch -- depending on what AppVeyor runs), without problem, and include two tests for the survey protocol. \nCan you post a minimal reproduction case?  That will help me check to see if its a real problem in nanomsg, or perhaps something that you're missing in your code.\nNote that you might need to wait a little bit after connection establishment to issue the survey, as there may be delays in the lower transport establishing; as survey is best effort this means that the initial survey can be lost.  (Most folks reissue surveys periodically, which avoids this being a real problem.)\nI do recall that the third party site that had demo code had a bug (incorrect protocol details) in one of the examples -- maybe it was surveyor?  Did you copy/paste from that site into your own code?\n. Can you post your modified code, and the \"test results\" in more detail?  I need more to go on than this.\n. thanks i will take a look. note that inproc has some known race conditions. a rewrite of it is pending.  note also that pair does not guarantee delivery or ordering.  if the queue is backed up messages will be dropped. \nSent from my iPhone\n\nOn Aug 21, 2016, at 6:02 PM, sailfish009 notifications@github.com wrote:\ni can't copy our source code, \nbut i can reproduce the similar code, here it is:\nbelow code was works fine, but as i said before, \nif i move some part of code to other function or other thread, then it didn't worked.\n// working version\n//////////////////////////////////////////////////////////////////////////\ndefine FRAME_SIZE (3110400) // YUV420 frame\ndefine FRAME_SIZE1 (2073600) // Y frame\ndefine FRAME_SIZE2 (518400) // U, V frame\nDWORD WINAPI thread1(PVOID p_param)\n{\nint rc;\nint s;\ns = nn_socket(AF_SP, NN_PAIR);\nassert(s != -1);\nrc = nn_connect(s, \"inproc://inproc_thr\");\nassert(rc >= 0);\nrc = nn_send(s, NULL, 0, 0);\nassert(rc == 0);\nwhile (1)\n{\n//event read\n//video data available\n...\nunsigned char buf[1] = {channel_id};\nrc = nn_send(s, buf, 1, 0);\nassert(rc == 1);\nint size = 1920*1080;\nrc = nn_send(s, video_y, size, 0);\nassert(rc == size);\nint size2 = size / 4;\nrc = nn_send(s, video_u, size2, 0);\nassert(rc == size2);\nrc = nn_send(s, video_v, size2, 0);\nassert(rc == size2);\n}\nrc = nn_close(s);\nassert(rc == 0);\n}\nbool run()\n{\nm_thread = CreateThread(NULL, 0x1000, thread1, this, 0, &tid);\nSetThreadPriority(m_thread, THREAD_PRIORITY_TIME_CRITICAL);\nreturn true;\n}\nint main()\n{\nrun();\nint socket = nn_socket (AF_SP, NN_PAIR);\nassert (socket != -1);\nrc = nn_bind (socket, \"inproc://inproc_thr\");\nassert (rc >= 0);\nint rc;\nunsigned char buf_y;\nunsigned char buf_u;\nunsigned char *buf_v;\nstruct nn_stopwatch stopwatch;\nuint64_t elapsed;\nunsigned long throughput;\ndouble megabits;\nbuf_y = (unsigned char)malloc(FRAME_SIZE1);\nassert(buf_y);\nbuf_u = (unsigned char)malloc(FRAME_SIZE2);\nassert(buf_u);\nbuf_v = (unsigned char*)malloc(FRAME_SIZE2);\nassert(buf_v);\nFILE * fp[4] = { nullptr };\nfor (int i = 0; i < 4; ++i)\n{\nchar str[128] = { 0 };\nsprintf(str, \"test_%d.yuv\", i);\nfp[i] = fopen(str, \"wb\");\n}\nunsigned char buf_id[1] = { 0 };\nrc = nn_recv(socket, buf_id, 1, 0);\nassert(rc == 0);\nnn_stopwatch_init(&stopwatch);\nfor (int i = 0; i < 100; ++i)\n{\nrc = nn_recv(socket, buf_id, 1, 0);\nassert(rc == 1);\nrc = nn_recv(socket, buf_y, FRAME_SIZE1, 0);\nassert(rc == FRAME_SIZE1);\nrc = nn_recv(socket, buf_u, FRAME_SIZE2, 0);\nassert(rc == FRAME_SIZE2);\nrc = nn_recv(socket, buf_v, FRAME_SIZE2, 0);\nassert(rc == FRAME_SIZE2);\nswitch (buf_id[0])\n{\ncase 0:\ncase 1:\ncase 2:\ncase 3:\n  fwrite(buf_y, 1, FRAME_SIZE1, fp[buf_id[0]]);\n  fwrite(buf_u, 1, FRAME_SIZE2, fp[buf_id[0]]);\n  fwrite(buf_v, 1, FRAME_SIZE2, fp[buf_id[0]]);\n  break;\ndefault:\n  printf(\"wrong channel id: %d\\n\", buf_id[0]);\n  break;\n}\n}\nelapsed = nn_stopwatch_term(&stopwatch);\nfree(buf_y);\nfree(buf_u);\nfree(buf_v);\nrc = nn_close(socket);\nassert(rc == 0);\nif (elapsed == 0)\nelapsed = 1;\nthroughput = (unsigned long)\n((double)FRAME_SIZE / (double)elapsed * 1000000);\nmegabits = (double)(throughput * FRAME_SIZE * 8) / 1000000;\nprintf(\"message size: %d [B]\\n\", (int)FRAME_SIZE);\nprintf(\"message count: %d\\n\", 100);\nprintf(\"mean throughput: %d [msg/s]\\n\", (int)throughput);\nprintf(\"mean throughput: %.3f [Mb/s]\\n\", (double)megabits);\nfor (int i = 0; i < 4; ++i)\nfclose(fp[i]);\n}\n// non-working version\n//////////////////////////////////////////////////////////////////////////\nvoid video1(int socket)\n{\nint rc;\nunsigned char buf_y;\nunsigned char buf_u;\nunsigned char *buf_v;\nstruct nn_stopwatch stopwatch;\nuint64_t elapsed;\nunsigned long throughput;\ndouble megabits;\nbuf_y = (unsigned char)malloc(FRAME_SIZE1);\nassert(buf_y);\nbuf_u = (unsigned char)malloc(FRAME_SIZE2);\nassert(buf_u);\nbuf_v = (unsigned char*)malloc(FRAME_SIZE2);\nassert(buf_v);\nFILE * fp[4] = { nullptr };\nfor (int i = 0; i < 4; ++i)\n{\nchar str[128] = { 0 };\nsprintf(str, \"test_%d.yuv\", i);\nfp[i] = fopen(str, \"wb\");\n}\nunsigned char buf_id[1] = { 0 };\nrc = nn_recv(socket, buf_id, 1, 0);\nassert(rc == 0);\nnn_stopwatch_init(&stopwatch);\nfor (int i = 0; i < 100; ++i)\n{\nrc = nn_recv(socket, buf_id, 1, 0);\nassert(rc == 1);\nrc = nn_recv(socket, buf_y, FRAME_SIZE1, 0);\nassert(rc == FRAME_SIZE1);\nrc = nn_recv(socket, buf_u, FRAME_SIZE2, 0);\nassert(rc == FRAME_SIZE2);\nrc = nn_recv(socket, buf_v, FRAME_SIZE2, 0);\nassert(rc == FRAME_SIZE2);\nswitch (buf_id[0])\n{\ncase 0:\ncase 1:\ncase 2:\ncase 3:\n  fwrite(buf_y, 1, FRAME_SIZE1, fp[buf_id[0]]);\n  fwrite(buf_u, 1, FRAME_SIZE2, fp[buf_id[0]]);\n  fwrite(buf_v, 1, FRAME_SIZE2, fp[buf_id[0]]);\n  break;\ndefault:\n  printf(\"wrong channel id: %d\\n\", buf_id[0]);\n  break;\n}\n}\nelapsed = nn_stopwatch_term(&stopwatch);\nfree(buf_y);\nfree(buf_u);\nfree(buf_v);\nrc = nn_close(socket);\nassert(rc == 0);\nif (elapsed == 0)\nelapsed = 1;\nthroughput = (unsigned long)\n((double)FRAME_SIZE / (double)elapsed * 1000000);\nmegabits = (double)(throughput * FRAME_SIZE * 8) / 1000000;\nprintf(\"message size: %d [B]\\n\", (int)FRAME_SIZE);\nprintf(\"message count: %d\\n\", 100);\nprintf(\"mean throughput: %d [msg/s]\\n\", (int)throughput);\nprintf(\"mean throughput: %.3f [Mb/s]\\n\", (double)megabits);\nfor (int i = 0; i < 4; ++i)\nfclose(fp[i]);\n}\nBOOL bind_socket(int& socket)\n{\nint rc;\nsocket = nn_socket(AF_SP, NN_PAIR);\nassert(socket != -1);\nrc = nn_bind(socket, \"inproc://inproc_thr\");\nassert(rc >= 0);\nreturn TRUE;\n}\nint main()\n{\nint s; \nbind_socket(s);\n//device init and run\n...\nstd::thread raw_thread(video1, std::ref(s));\nraw_thread.detach();\nreturn 0;\n}\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Looking at these changes, I don't understand why we are bothering to validate hostnames at all.  We should be relying upon the resolver to do that for us.  Doing this ourselves in library space is actually rather poor form.  I'll probably just gut all this outright.\n. So the issue here is that we don't resolve the name up front -- because DNS can be down or a name might not have been registered yet or something.  This lets the software overcome temporary name resolution problems.\n\nArguably reliance on this is is somewhat unfortunate -- really for the vast majority of cases if an unresolvable DNS name is given to nn_connect(), you'd really just like to have a hard failure, rather than trying to muddle on.  In the vast vast majority of cases, immediate fail-fast is superior to a situation where the thing never works.\nThis actually relates to the desire for an early failure at connect time too.   Probably this needs to be configurable, but I need to think about this somewhat.. For now, I\"m going to just accept this, because clearly a . at the end is a valid FQDN.  There may be other considerations, but this PR is good.. No, its only cmake based, but there is a configure script that makes it look like autotools.\nThe problem with retaining both options was that it was a rather large amount of work to maintain both, and there was divergence in how the code was compiled and configured, leading to inconsistent results depending on which was most was recently updated and which was being used by the end-users.  We will not be brining back the mess that was autotools.\nThat said, I'm astonished that you cannot use CMake.  What platform are you running (not just ARM, but the OS as well?)\nCMake is available in source form, so you should be able to build it if necessary.  It also supports cross compilation: http://www.vtk.org/Wiki/CMake_Cross_Compiling\nMy first guess is that you're cross compiling and were lacking the above information?  (Its pretty easy -- you just need to set up an environment file describing how to locate tools, and libraries and headers for building for your target.)\n. That's somewhat surprising... I don't think CMake has especially onerous compilation requirements.  If your environment is that constrained, probably you should look into cross compilation -- I imagine you have challenges with other tools too!\n. Bizarre!  Ok, I'll take a look at it.\n. This is quite strange, in that it shouldn't matter if the socket is actually bound or not -- I'd expect the underlying send of data to stall or fail, just as if a remote peer was stuck.  I need to fire up windows with a debugger because the problem isn't obvious -- the Windows behavior, while unfortunate, should actually work (except that no message would be delivered of course.)\n. I think I have it figured out.  We need to unconditionally stop the streamhdr timer.\n. Actually this is even more stupid.\nWe have an extra state in the timer logic, and yes, the stream hdr timer is indeed still running.  The entire timer framework is buggy here, since we can wind up racing against the worker_execute() of the magic stop task.\nThe thing is, we don't need that extra state or the other level of asynchronous behavior.  Nothing uses it.  It only serves to obfuscate and create an opportunity for a race condition.  Better to just cancel the timeout synchronously!\n. Actually I was sadly wrong.  FSM for the loss again.  Stay tuned.\n. Can you confirm that you are using the current nanomsg version (1.0.0?)\n. So I made a test case to try to reproduce this on Windows (the assertion failure), but I cannot:\nhttps://github.com/nanomsg/nanomsg/pull/801\nThe windows runs on AppVeyor are all clean:\nhttps://ci.appveyor.com/project/nanomsg/nanomsg/build/0.8.249\nSo I'm not sure what the problem is?  The fact that nn_bind() didn't fail?  That's fine -- and there are sound reasons why Windows may have chosen this behavior, and shouldn't affect us.   (There is a moral of the story here, which is that you ought not assume nanomsg is checking IP addresses...)\n. This seems like a bug.  Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n. I wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\n\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org wrote:\n\nThis seems like a bug.  Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n. mangos leaks????? that seems hardly possible as there is garbage collection to avoid that in golang. \n\n\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:59 PM, BillMcCroskey notifications@github.com wrote:\nAlso note that the GoLang Mangos routines used in a similar fashion produce the same leak per packet. \nThat is nn_sendmsg with scatter array on the Pub and nn_recv on the Sub. \nFrom: gdamore [mailto:notifications@github.com] \nSent: Thursday, August 25, 2016 6:52 PM \nTo: nanomsg/nanomsg nanomsg@noreply.github.com \nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com \nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797) \nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic! \nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org> wrote: \n\nThis seems like a bug. Can you provide a minimal implementation that \nreproduces this behavior? \nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> \nwrote: \n\nTypo - I meant Receiving OF published messages \n\u2014 \nYou are receiving this because you are subscribed to this thread. \nReply to this email directly, view it on GitHub \nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390, \nor mute the thread \nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm \n. \n\n\n\u2014 \nYou are receiving this because you authored the thread. \nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm. \n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. i need your code to diagnose properly.  which transport is this?\n\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com wrote:\nI got it unblocked. \nARM Cortex-A8 CPU. \nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements: \nFirst element is a structure with two fields \n1. 40 char string that holds the packet topic \n2. Uint32_t count of next field \n   The other scatter array has the serialized string data. \n   That goes in a nn_sendmsg sent on a Pub socket \nTry to receive on a Sub socket with nn_recv.  The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak. \nI suspected the nn_recv was not pulling all the content out of the buffer. \nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks. \nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate. \nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure. \nIf I can get the nn_recvmsg call going, I think I have it working. \nFrom: gdamore [mailto:notifications@github.com] \nSent: Thursday, August 25, 2016 6:52 PM \nTo: nanomsg/nanomsg nanomsg@noreply.github.com \nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com \nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797) \nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic! \nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org> wrote: \n\nThis seems like a bug. Can you provide a minimal implementation that \nreproduces this behavior? \nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> \nwrote: \n\nTypo - I meant Receiving OF published messages \n\u2014 \nYou are receiving this because you are subscribed to this thread. \nReply to this email directly, view it on GitHub \nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390, \nor mute the thread \nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm \n. \n\n\n\u2014 \nYou are receiving this because you authored the thread. \nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm. \n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. so not a nanomsg bug then?\n\nSent from my iPhone\n\nOn Aug 26, 2016, at 8:26 AM, BillMcCroskey notifications@github.com wrote:\nFound the issue, you can close the topic. \nThe buffer being filled was a char * and not a void *. The change fixed the leak. \nFrom: gdamore [mailto:notifications@github.com] \nSent: Thursday, August 25, 2016 10:49 PM \nTo: nanomsg/nanomsg nanomsg@noreply.github.com \nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com \nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797) \ni need your code to diagnose properly. which transport is this? \nSent from my iPhone \n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote: \nI got it unblocked. \nARM Cortex-A8 CPU. \nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements: \nFirst element is a structure with two fields \n1. 40 char string that holds the packet topic \n2. Uint32_t count of next field \n   The other scatter array has the serialized string data. \n   That goes in a nn_sendmsg sent on a Pub socket \nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak. \nI suspected the nn_recv was not pulling all the content out of the buffer. \nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks. \nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate. \nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure. \nIf I can get the nn_recvmsg call going, I think I have it working. \nFrom: gdamore [mailto:notifications@github.com] \nSent: Thursday, August 25, 2016 6:52 PM \nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com> \nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com> \nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797) \nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic! \nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org>> wrote: \n\nThis seems like a bug. Can you provide a minimal implementation that \nreproduces this behavior? \nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>> \nwrote: \n\nTypo - I meant Receiving OF published messages \n\u2014 \nYou are receiving this because you are subscribed to this thread. \nReply to this email directly, view it on GitHub \nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390, \nor mute the thread \nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm \n. \n\n\n\u2014 \nYou are receiving this because you authored the thread. \nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm. \n\u2014 \nYou are receiving this because you commented. \nReply to this email directly, view it on GitHub, or mute the thread. \n\n\u2014 \nYou are receiving this because you authored the thread. \nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm. \n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. that should work fine.  you do have to free the message yourself though once you are done with it. \n\ntry writing the smallest program you can that  reproduces the problem. \nnote that there is no difference on the wire if you use gather to send a message from different chunks so that should not have any effect on the receive side. \nSent from my iPhone\n\nOn Aug 26, 2016, at 12:55 PM, BillMcCroskey notifications@github.com wrote:\nWe are on an old version of nanomsg and will upgrade to latest and repeat test. \nThe main thing I need to get working is nn_recvmsg with nonomsg allocating the buffer. Following the guild, I can\u2019t get it to work. \nWe will try it first on a newer version. \nFrom: gdamore [mailto:notifications@github.com] \nSent: Thursday, August 25, 2016 10:49 PM \nTo: nanomsg/nanomsg nanomsg@noreply.github.com \nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com \nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797) \ni need your code to diagnose properly. which transport is this? \nSent from my iPhone \n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote: \nI got it unblocked. \nARM Cortex-A8 CPU. \nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements: \nFirst element is a structure with two fields \n1. 40 char string that holds the packet topic \n2. Uint32_t count of next field \n   The other scatter array has the serialized string data. \n   That goes in a nn_sendmsg sent on a Pub socket \nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak. \nI suspected the nn_recv was not pulling all the content out of the buffer. \nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks. \nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate. \nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure. \nIf I can get the nn_recvmsg call going, I think I have it working. \nFrom: gdamore [mailto:notifications@github.com] \nSent: Thursday, August 25, 2016 6:52 PM \nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com> \nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com> \nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797) \nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic! \nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org>> wrote: \n\nThis seems like a bug. Can you provide a minimal implementation that \nreproduces this behavior? \nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>> \nwrote: \n\nTypo - I meant Receiving OF published messages \n\u2014 \nYou are receiving this because you are subscribed to this thread. \nReply to this email directly, view it on GitHub \nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390, \nor mute the thread \nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm \n. \n\n\n\u2014 \nYou are receiving this because you authored the thread. \nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm. \n\u2014 \nYou are receiving this because you commented. \nReply to this email directly, view it on GitHub, or mute the thread. \n\n\u2014 \nYou are receiving this because you authored the thread. \nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm. \n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Ah, that is useful information.  I can try to confirm this, and if so, a\nfix should be straight-forward.\n\nnanocat and macat are really test programs \u2014 its unsurprising that they\nleak in variety of situations; I wouldn\u2019t use them in long-running\nsituations.  That said, we should find and fix any leaks that may exist.\nOn Mon, Aug 29, 2016 at 9:36 AM, BillMcCroskey notifications@github.com\nwrote:\n\nWorking on getting V1.0.0 working, but found what is going on with\n0.4beta:\nOn a sub side of a socket, any program leaks memory when there is more\nthan one topic running on the bus and your subscription covers only one of\nthe topics on the bus.\nThat was why it worked sometimes and would break at times.\nNanocat leaks the same under that condition. Macat leaks all the time.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Saturday, August 27, 2016 11:09 AM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author \nauthor@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nthat should work fine. you do have to free the message yourself though\nonce you are done with it.\ntry writing the smallest program you can that reproduces the problem.\nnote that there is no difference on the wire if you use gather to send a\nmessage from different chunks so that should not have any effect on the\nreceive side.\nSent from my iPhone\n\nOn Aug 26, 2016, at 12:55 PM, BillMcCroskey notifications@github.com<\nmailto:notifications@github.com> wrote:\nWe are on an old version of nanomsg and will upgrade to latest and\nrepeat test.\nThe main thing I need to get working is nn_recvmsg with nonomsg\nallocating the buffer. Following the guild, I can\u2019t get it to work.\nWe will try it first on a newer version.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:\nnanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:\nBill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:\nauthor@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<\nmailto:notifications@github.com<mailto:notifications@github.com%3cmailto:\nnotifications@github.com>> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the\nsender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but\nuse htop and watch the task receiving and it will show memory leakage on\nresident memory. Valgrind will also show the nanomsg library as leaking. It\nis a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the\nbuffer.\nI coded up a receive with nn_recvmsg and got it working with stack\nallocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was\ntrying to get out of segment faults. I must not have the structures set up\nright to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator\npart. It seems that I should get one element allocated and it should parse\nout kind of like the data from the nn_recv when I pull it out of the hdr\nstructure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:\nnanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com%\n3cmailto:nanomsg@noreply.github.com>>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:\nBill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com%3cmailto:Bill.\nMcCroskey@Crown.com>>; Author author@noreply.github.com<mailto:\nauthor@noreply.github.com<mailto:author@noreply.github.com%\n3cmailto:author@noreply.github.com>>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds\ntragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org\n<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@\ndamore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org%\n3cmailto:garrett@damore.org%3cmailto:garrett@damore.org>>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey \nnotifications@github.com<mailto:notifications@github.com<mailto:\nnotifications@github.com%3cmailto:notifications@github.com<mailto:\nnotifications@github.com%3cmailto:notifications@github.com%3cmailto:\nnotifications@github.com%3cmailto:notifications@github.com>>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#\nissuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/\nABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/\nnanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-\n2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm>.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/\nnanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/\nASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm>.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/\nnanomsg/nanomsg/issues/797#issuecomment-242922506, or mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/\nASTiukoI42QIKQylIAKMArqNlJix8tP7ks5qkFLvgaJpZM4JtcKm>.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243178338,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfbzyl5-Tf2Yd_dU4vXybnABaFOJYks5qkwqEgaJpZM4JtcKm\n.\n. How did you assess the leak in mangos?  In particular, I see this in the subscriber code for mangos:\n\nif !matched {\n                    m.Free()\n                    continue\n            }\nIt looks like it makes a reasonable effort to not leak.  I will check nanomsg next.\n. And I see almost exactly the same logic in nanomsg xsub.c:\nrc = nn_trie_match (&xsub->trie, nn_chunkref_data (&msg->body),\n        nn_chunkref_size (&msg->body));\n    if (rc == 0) {\n        nn_msg_term (msg);\n        continue;\n    }\nI want to know how you demonstrated the leak?  I am going to try to reproduce myself with nanocat (and perhaps macat).\n. So, I can't see a leak using nanocat.  I'm using a single subscriber with about 200 publishers, but I'm subscribing to messages from only about 11 of them.  They each publish a message at one second intervals.  This is using the TCP transport on MacOS X.\nNote that I do see a fixed size increase per socket (not per message) that I've connected.  That's normal and expected behavior as there are data structures per connected TCP stream.\nIts possible that a single message is \"leaked\", but its definitely not continuous.  (I'm not verifying with vgrind or anything like that, just watching the process looking for increasing heap growth.  I'm not seeing any of that.)  I would be far less concerned about leaking a small amount of resources just a single time (e.g. a buffer leak at start up), provided that memory consumption does not grow over time/usage.\nIf you can write a shell script that demonstrates the leak, and describe how you are verifying that such a leak exists, it would be useful.\n. I will have to download valgrind to test\u2026 I did use the -i flag to nanocat.\nI wonder if the problem is that packets are getting lost when you\ndisconnect?  That actually makes more sense to me as a potential area of\nconcern.\nOn Mon, Aug 29, 2016 at 10:40 AM, BillMcCroskey notifications@github.com\nwrote:\n\nUnless you use the \u2013i 1 on nanocat, you can\u2019t get it to stay on the bus\nand send. I\u2019m having a hard time getting a shell script to do what the\nprogram does.\nThe leak is continuous and per packet. Watching the \u201cRES\u201d field in htop\nwill show what valgrind is reporting.\nI\u2019d have to make up a small program.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Monday, August 29, 2016 1:35 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author \nauthor@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nSo, I can't see a leak using nanocat. I'm using a single subscriber with\nabout 200 publishers, but I'm subscribing to messages from only about 11 of\nthem. They each publish a message at one second intervals. This is using\nthe TCP transport on MacOS X.\nNote that I do see a fixed size increase per socket (not per message) that\nI've connected. That's normal and expected behavior as there are data\nstructures per connected TCP stream.\nIts possible that a single message is \"leaked\", but its definitely not\ncontinuous. (I'm not verifying with vgrind or anything like that, just\nwatching the process looking for increasing heap growth. I'm not seeing any\nof that.) I would be far less concerned about leaking a small amount of\nresources just a single time (e.g. a buffer leak at start up), provided\nthat memory consumption does not grow over time/usage.\nIf you can write a shell script that demonstrates the leak, and describe\nhow you are verifying that such a leak exists, it would be useful.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/\nnanomsg/nanomsg/issues/797#issuecomment-243194933, or mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/\nASTiuqTnRaN14Q4izltaZI660i8BR-Vsks5qkxg4gaJpZM4JtcKm>.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243196547,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfe2BXb-tpNCdUf2P_POa9zGGpl8Lks5qkxl_gaJpZM4JtcKm\n.\n. Your mental model is close to the right semantic, but absolutely wrong in terms of what happens under the hood.\n\nUnder the hood, every client subscriber receives every message (provided enough queue room exists), but the ones they aren't interested in are discarded (see the snippet from above in xsub.c) -- basically we do client side filtering rather than server side.  (There are some really really strong reasons why we do it this way, and that's not going to change anytime soon.)\nA 50 ms delay after connect is typical -- this is because it takes time for all the setup in the underlying plumbing to be complete -- though it sounds excessive for IPC.  (For TCP its typical.)\nI'm astonished you're seeing lots of leaked messages -- what version are you using?  I've not been able to see that even while sending several hundred messages per second (both with discard of 90%, and no discarding) -- but this was with nanocat.\nIf you're allocating your own messages, you do need to be careful to make sure that you're not holding an extra reference to the message in your application.  The best way to do this IMO is to use NN_MSG to ask for the framework to provide you with the message, which than can be tossed with nn_msg_term() once you are done with it.\n. There was a known leak affecting xsub, which was fixed nearly two years ago: d265c745977b273fcb219c529a3b6874e8ae1d67\nThis leak did exist in 0.4.  So yes, you need to update.  Until you do that, I'm not going to spend more time on this.  (0.4 was released in January of 2014!!)\nThat said, you obviously have no way to handle messages you don't receive, nor are you expected to.  The library should take care of them for you.  If there is indeed a verifiable leak happening in new code, that would be a bug.  I've not been able to see such behavior.\n. ideally nanocat would be built with this path compiled in.  Its strange that this is not the case.\n. Which platform was this on?\n. Yeah, what I don't understand is why CMake doesn't add the library path into the ELF object itself... we really shouldn't require users to edit system linker configuration.  (Perhaps this is the only way on Linux?)\n. This is the whole RPATH business in CMake, I mean.\n. That commit should fix this... I'd like feedback.\n. linger doesn't work with ipc (the operating systems don't support it!) -- and is never guaranteed in any event.   We do our best, but that's all we can do.\nWhat's worse, is that nn_connect() isn't guaranteed to have actually established a connection, and so you may see messages get dropped simply due to delays in the time it takes to establish a connection (IPC should be fast though, but this would fail utterly with TCP.)\nI recommend inserting a manual delay before the nn_close() if you want to simulate linger.    But better is simply not to close the socket -- opening and closing the socket for each message imparts quite a high per-message overhead, and is not a recommended pattern unless you have some one-shot use case. (E.g. a short lived program delivering a status message.)\nIf you want to be absolutely certain that your message was received by the other end, use REQ/REP, which provides for the ack (in the form of the REP) giving you a reliable form of delivery, with no need for lingering.  (Provided the REP socket is long lived of course.)\n. Closing, as there isn't anything we can do here, beyond the user education in the reply.\n. I should update the documentation to NN_LINGER to indicate things more clearly.\nBasically we do two things when NN_LINGER is used.  We wait until the socket drains to the kernel, and we also instruct TCP that we want it to continue to try to send the message after any underlying file descriptor is closed (using the SOL_LINGER socket option).  Unfortunately, operating systems vary in their support for this socket option, ... and it is generally only supported by TCP.\nThe fact is that once the data is handed to the kernel, if we call an underlying close(2) (or we exit(2)), then there is nothing we can do if the kernel doesn't support lingering.  This is simply not something you can fix with code in nanomsg.\n. One thing we can do is if -1 lingering is specified, we can inject a forced delay regardless.  Since the user has demanded we try hard at any cost, they shouldn't complain if it takes us a few dozen extra msec to completely terminate.\n. Well this is interesting... I cannot find a place where linger actually does anything.  In mangos (alternate implementation of nanomsg in Go) I wrote code to ensure it does, but it seems to be non-functional in nanomsg.  Weird.\n. So this is a bit more hairy than I realized, because of the internal architecture of nanomsg.  We should certainly set the kernel TCP parameter, but given that nanomsg never actually \"queues\" anything, that's pretty much all we can do.\nThe socket option is generic, because other transports could implement it, even though TCP is the only one to do so at present.\n. In fact, the model here we are following is SO_LINGER, which is a generic socket option in UNIX / POSIX systems.  We do need to document that this option may or may not be implemented for various transports.\nIt is a programmer error to rely upon linger actually doing anything, both on UNIX and in generic nanomsg.  Its merely supposed to be a preference; not a core behavior.  I'm sorry if the documentation doesn't make this clear -- if you need to be sure your data isn't dropped at close, you need to keep the socket alive yourself.\n. The more I look at this, the more I think I agree ... in fact, the historical usage of SO_LINGER is specific to solving problems with TCP state machines, and really should not be used at all in most applications.  (Its a sign of defective protocol design.)\nI'm actually going to change the documentation to note that this is a NO-OP and should not be used in new code.\n. interesting idea.  \nwhich system was this on?\nSent from my iPhone\n\nOn Sep 7, 2016, at 11:43 AM, William notifications@github.com wrote:\nnn_usock_accept fails on some POSIX systems, aborting the application with errno set to 38 (not implemented).\nSome research reveals that accept4 seems to be stubbed out on some POSIX systems, but not actually implemented. Thus the configuration may set NN_HAVE_ACCEPT4 to \"yes,\" even though the system doesn't actually implement it.\nPerhaps the code in nn_usock_accept (usock_posix.inc) should be extended to automatically fall back on accept if accept4 fails?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. But what operating system?\n\nOn Wed, Sep 7, 2016 at 1:33 PM, William notifications@github.com wrote:\n\nAn arm 7, using GNU C tools.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/800#issuecomment-245408927,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfcnqNh2l-08hBPV3aADnR0Uq0PwIks5qnx-tgaJpZM4J3Oye\n.\n. it is bizarre that accept4 doesnt work on this system. \n\nSent from my iPhone\n\nOn Sep 7, 2016, at 3:36 PM, William notifications@github.com wrote:\nI'm sorry, can't see the forest for the trees. Linux. Kernel version 2.6. It's an embedded system.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @Crest but if you don't have accept4, and your OS doesn't claim to have it (i.e. it doesn't exist in header files) you won't have a problem.\n\nThe problem we have is that we have one system that has accept4 defined/declared, but its non-functional (just returns ENOTSUP).  This is Linux lunacy.\n. I think a similar problem can occur with pipe2.  The issue is that we have versions of glibc that are delivered separately from the kernel; if a new glibc is run with an older kernel, the glibc function will exist, but the underlying system call in the kernel won't.  This is a bizarreness that comes about because in Linux-land the kernel and C runtime are independently delivered.  (It can also happen e.g. with uLibc or other libc replacements.)\n. Its unclear that the root problem exists, so I'm closing this for now.\n. Rebased and merged:\n```\ncommit c52f1bedca6b72fb31b473929d99f2fe90a13445\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Wed Sep 7 23:47:42 2016 -0700\nfixes #798 error while loading shared libraries\n\n```. we enable docs by default if you have asciidoctor. \nWhat version of asciidoctor do you have?   This looks like a bug there \n. Seems that is an older version. Maybe a bug was fixed.  Current version is 1.5.4.  Can you update and try again?\n. its installable as a ruby gem.  can you check the asciidoctor site?\n. Perhaps we should add a check to ensure that asciidoctor is \"new\" enough.  But to be honest I'm almost at the point where I just don't care about it -- its easily disabled for users that can't figure out how to get a new enough asciidoctor.  I'm just going to close it for now.. id have done the profiling before adding them. \nim making this change. folks who want to gripe about it need to demonstrate proof.  eg before and after performance results. \ni know for certain that some of the cases are just flat out wrong. \n. Not bothering to work on this, in favor of nng.  nng doesn't have any of this branch prediction \"optimizations\".. Dropping this -- we have something similar in libnng, and I'm desisting from all non-critical work on nanomsg in favor of the nng rewrite.. yes i will break git blame.  get over it.  my pain working with this code base trumps your desire for git blame.  thats because i work on this code far far more than anyone else. \nSent from my iPhone\n\nOn Sep 19, 2016, at 8:54 PM, Bent Cardan notifications@github.com wrote:\nit would be a shame to muck up git blame on account of style. Style changes should only happen as far as need demands changes to operative logic\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. to be clear.  i am enacting this through my bdfl powers.  this decision is not open for discussion or debate.  we tried that before and the people who bitched loudest failed to demonstrate any signs of continued contribution in the months since. \n\nthere will be a sufficiently large amount of the code base changing functionally for this as to make git blame uninteresting anyway.  i am embarking on a major refactoring \n. I've shelved this work in favor of a ground up rewrite -- see the nng project.  That project uses a style that is inspired by FreeBSD (though there are some subtle differences) -- and enforced via an uncrustify configuration.. Would like to, but have to think through what exactly this means for a\nshared library on Windows.\n- Garrett\nOn Wed, Sep 21, 2016 at 11:41 AM, Bernardo Ramos notifications@github.com\nwrote:\n\nHi guys!\nNow that we have a production release, why not have a pre-build binaries?\nAt least for Windows. What about an installer?\nIt can be a single installer for x86 as it may work on x64 too.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/808, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfSstMlPtnVVQpR3mjJigaXbvrsR2ks5qsXpdgaJpZM4KDI8U\n.\n. the question i have is what value an end user install has.  if i was developing an app i would just bundle the library with my app. \n. cpack would be the preferred way to so this.  I still have my basic questions about whether this is useful or not. \n. This is a duplicate of #729 \n. It sounds to me like what you want is a star-like topology, with logic in the center.\n\nYou need to define your own application layer protocol for this, so that your central server can figure out where to route messages to.\nThen you could use a bunch of PAIR sockets (assuming you are willing to tolerate message drops due to backpressure).  Each client would have a single socket on the server.  Imagine a protocol like this:\nYou have these primitives sent by clients to the server:\nLOGIN\n- sends a unique client ID\n- as well as any other useful identifying information\n  LOGOUT\n- indicates clean disconnect\n  SEND\n- posts the unique client ID of the destination\n- includes the message payload\n- server can determine sender by the socket on which the message arrives\nThen the server can send messages to clients like this:\n- OK  - indicates a message was queued for delivery (maybe delivered, maybe not) or other good result\n  - FAIL - e.g. if the destination of the last message send request couldn't be done because no such client, etc.\n  - RECV\n    - server changes SEND to this, and swaps the destination client ID for the originators ID\nThe above values could just be leading bytes in the data stream/messages. \nMultithreaded, I'd have one thread sending, and another receiving.  They could probably run completely asynchronously to each other.\nIn this case nanomsg isn't doing a lot for you, except automatically handling the framing. \nThe critical thing here is that you need application logic to determine where to forward a message to.  That's the logic in the server, that has to inspect destinations for SEND frames, and rewrite those (and forward them to the appropriate socket.)  The server will need to use the multithreaded support and the cmsg API to do this properly.\n. Closing this as its a question, not a bug.\n. BUS can be used to create a star topology.  Its the central node will broadcast to all peers, whereas the leafs will only send to the hub.\nIf you use NNG instead, you'll have access to PAIRv1 Polyamorous mode, which is a bit more capable for establishing multiple 1:1 relationships.\nGolang users have STAR as an option as well, from within mangos.  I've long had plans to introduce STAR into NNG, just haven't gotten to it yet.\n. NNG is indeed stable.  I encourage anyone thinking of using nanomsg to use NNG instead.. After careful review, you are correct.\nThe problem is that we have already added the close code length to the payload_len.  I think someone confused this with reason_len. \nI'm going to go ahead and remove line 814.\n. Actually there is a better fix.  Lets add the reason_len just at 818, and remove line 825.  This is clearer, since we increment the length next to the code that writes the data into the buffer.\n. Can you please update to nanomsg 1.0 and retest?\n. Ah, ok. Will investigate and get back to you.\n. I'm wondering if this is specific to inproc.\n. I this will fix it:\n```\ncommit 25b589835005b1a32f51784edf45203cca242465\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Wed Oct 5 21:27:14 2016 -0700\nfixes #811 Memory leak when closing a PUSH socket before the PULL\n\ndiff --git a/src/transports/inproc/cinproc.c b/src/transports/inproc/cinproc.c\nindex 997588b..53d2636 100644\n--- a/src/transports/inproc/cinproc.c\n+++ b/src/transports/inproc/cinproc.c\n@@ -228,6 +228,7 @@ static void nn_cinproc_handler (struct nn_fsm *self, int src, int type,\n                 nn_epbase_stat_increment (&cinproc->item.epbase,\n                     NN_STAT_INPROGRESS_CONNECTIONS, 1);\n\nnn_sinproc_term (&cinproc->sinproc);\n                 nn_sinproc_init (&cinproc->sinproc, NN_CINPROC_SRC_SINPROC,\n                     &cinproc->item.epbase, &cinproc->fsm);\n                 return;\n```\n. Ok that was completley wrong.  But I've totally refactored this.  I'd appreciate a re-test using the \"bug811\" branch, or this PR:\n\nhttps://github.com/nanomsg/nanomsg/pull/819\n. Fixed in 4459720e0c413fd856eb4960c6bce86ea59dbed3\n. Fixed in f6b7a74c62b97e80b3949f0ba377eeab0a82d673\n. This failed.  CLOSING.\n. Remerged in 4459720e0c413fd856eb4960c6bce86ea59dbed3\n. Yes this limit is intentional. It is set to 1MB bu default.  You can remove the limit if you like.  The reason for the limit is to protect against a trivial denial of service attack - a sender could claim to send 1 GB for example, and the receiver has to allocate heap to receive this even if the sender doesn't actually send any data.  The 1MB default limit was chosen as a compromise between safety (4000 senders would be needed to cause a 4GB heap allocation) and usability.  We felt that few people use nanomsg to send messages larger than this.  Those that do so, should only do so on networks that they trust and can increase the limit or remove it altogether. \nThis is documented in the nn_setsockopt page.  We should probably mention the existence of a limit in nn_send and nn_recv as well. \nIn fact I really do not recommend nanomsg as a transport for very large messages.  If any data is lost then the entire message will need to be resent.  Additionally nanomsg tends to be optimized for lots of small messages rather than straight throughput. \nIf you want maximum raw throughput using the underlying transport (TCP) directly is likely to be superior. \nSent from my iPhone\n\nOn Oct 14, 2016, at 12:28 AM, Bernardo Ramos notifications@github.com wrote:\nGuys, I need to share this with you.\nI am the developer of litereplica and it uses nanomsg.\nWe (I and the litereplica users) were having errors going on and the debug showed that the problem was with nanomsg.\nIt occurred only with the TCP transport, not with IPC.\nAt some point the connection was broken and nanomsg did not made the reconnection. I could check it with netstat.\nA customer from a company was asking to remove the nanomsg because of this.\nOnly after dozen of days I realized the problem:\nThe sender was sending a message with a size of ~1.4MB and the nanomsg has a limit on the received message size (I did not know about this).\nI almost gave up and let nanomsg aside.\nSo here is my questions: should it have this limit as the default? If yes, what about having something wrote about this in the nn_send documentation page?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I've fixed the documentation and now we correctly link from old pages to the latest.  I am closing this issue now.. Fixed in the above... \n. On MacOS X, this does not reproduce.\n. Hmm... I have a theory.\n\nIf you're exiting the sending application too soon, the messages might be lost in a kernel write buffer.  TCP has a special socket option (LINGER) to deal with this, but IPC does not.  The thing is that depending on the implementation of the sender... the socket may fail to deliver buffered messages.  I'm also looking at your code now.\n. What platform are you running this on?  Apart from the possible lost message from shutdown, I cannot reproduce this on MacOS X.   I've run up to 16 concurrent threads, and no lost messages.\n. I'm fairly confident that what is happening is that messages are lost here on exit.   The non-blocking mode means that the message can be queued in the library, which may mean that the message is lost (or incomplete/partially written) where blocking would mean that you don't return until the message is fully written to the pipe.\nUsing IPC, its imperative you don't exit immediately after writing to the IPC, if you care about the delivery of the data, because unless the data is acked you won't know if it got there.  The short delay prior to exit is generally enough to take care of it -- even just a few milliseconds is plenty unless the reader on the other side is slow.\nI'm going to close this, because this is an architectural consideration of UNIX sockets, and there isn't really anything I can do to \"fix\" it.   It's incumbent on the API consumer to give time for full message delivery.. THere's nothing here.\n. At this time, not really.  You could possibly eliminate the use of nn_poll() and go to normal blocking synchronous operations (but only if your design allows for this), but I'm not sure that it will save all that much.\nIn the future a new design will reduce the overhead somewhat, as well as the latency, by making better use of condition variables instead of the magical file descriptor based approach that nn_poll() uses under the hood.\n. Nice contribution.  I will merge it!. Integrated: \n```\ncommit 0665fb4b2e3b887e608282ff09cd5fcac0c9ba5b\nAuthor: Alexander Chekunkov chekunkov@gmail.com\nDate:   Mon Nov 7 20:22:59 2016 +0000\nAdd NN_RCVMAXSIZE socket option implementation for 'ipc' transport\n\nSee nn_getsockopt man page for details.\n\nBasic tests are in tests/ipc.c.\n\n```. Thanks.  we will fix this.. what you are missing here is a single socket can be connected to multiple endpoints at the same time.  you only need two sockets (one req and one rep) for the device as a result. . You have multiple things going on in here, so I'm not sure what the question really is.\nYou do need to wait for TCP connections to establish before sending a messages, or be willing to wait the time period for a retry to occur with REQ.  (Note that the \"device\" never retries explicitly, instead it assumes the originator will retry.)\nIn order to properly debug this, I'd need the minimally complete server and client code (including main, etc.)   This will let me see that you're not making a mistake somewhere else (like exiting() from the code running the device framework.)\nIn the case of wanting to have multiple \"routes\" out of a socket, you just connect them all (or bind them) to multiple interfaces.   However, in your case above, (the second one), you should be able to connect multiple server sockets to the device, and it should load-balance (round-robin) amongst them.\nIf you wanted to connect, you could do it this way:\ns = nn_socket(AF_SP_RAW, NN_REQ);\nnn_bind(s, \"tcp://server1:5556\");\nnn_bind(s, \"tcp://server2:5556\");\nnn_bind(s, \"tcp://server3:5556\");\nThis means you get three underlying TCP connections load balanced by a single outgoing REQ socket.  You can use that with a device framework to get the DEALER logic you're trying to achieve.. The following sample program works:\n```\n/*\n    Copyright 2016 Garrett D'Amore garrett@damore.org\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom\nthe Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\n\"nanomsg\" is a trademark of Martin Sustrik\n\n*/\n/*  This program serves as an example for how to write a simple device service, using\n    a rendezvous.  This works by having the program support three modes.  The protocol is\n    is REQ/REP, where the REQ is a name, and the REP is a greeting based on the name, and\n    an instance number (we use the process ID) and time of day.\nWe provide a rendezvous server running the device code, where servers and clients can\nconnect.  Both sides of the device are in bind mode, and both servers and clients run\nin connect mode.  This lets us support many servers and clients simultaneously.\n\nFor example, if I want to have servers rendezvous at port 5554 and clients at port 5555:\n\n% ./device_demo -d tcp://127.0.0.1:5554 tcp://127.0.0.1:5555 &\n% ./device_demo -s tcp://127.0.0.1:5554 &\n% ./device_demo -c tcp://127.0.0.1:5555 Garrett\nGood morning, Garrett.\n\n*/\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \n/  The server runs forever. /\nint server(const char *url)\n{\n    int fd; \n/*  Create the socket. */\nfd = nn_socket (AF_SP, NN_REP);\nif (fd < 0) {\n    fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n    return (-1);\n}\n\n/*  Connect to the URL.  This will connect to the address and listen\n    synchronously; new clients will be accepted asynchronously\n    without further action from the calling program. */\n\nif (nn_connect (fd, url) < 0) {\n    fprintf (stderr, \"nn_connect: %s\\n\", nn_strerror (nn_errno ()));\n    nn_close (fd);\n    return (-1);\n}\n\n/*  Now we can just process results.  Note that there is no explicit\n    accept required.  We just receive a request, and reply to it.\n    Its important to note that we must not issue two receives in a\n    row without replying first, or the following receive(s) will\n    cancel any unreplied requests. */\n\nfor (;;) {\n    char username[128];\n    char greeting[128];\n    time_t secs;\n    struct tm *now;\n    char *daytime;\n    int rc;\n    char *fmt;\n\n    rc = nn_recv (fd, username, sizeof (username), 0);\n    if (rc < 0) {\n        /*  Any error here is unexpected. */\n        fprintf (stderr, \"nn_recv: %s\\n\", nn_strerror (nn_errno ()));\n        break;\n    }\n\n    secs = time (NULL);\n    now = localtime (&secs);\n    if (now->tm_hour < 12) {\n        daytime = \"morning\";\n\n    } else if (now->tm_hour < 17) {\n        daytime = \"afternoon\";\n\n    } else if (now->tm_hour < 20) {\n        daytime = \"evening\";\n\n    } else {\n        daytime = \"night\";\n    }\n\n    /*  Ensure ASCIIZ terminated string. */\n    if (rc < sizeof (username)) {\n        username[rc] = '\\0';\n    } else {\n        username[sizeof (username) - 1] = '\\0';\n    }\n\n    fmt = \"Good %s, %s (from %d).\";\n\n    /*  Technically this might be overly pessimistic about size. */\n    if ((strlen (username) + strlen (daytime) + strlen (fmt)) >=\n        sizeof (greeting)) {\n\n        fmt = \"I'm sorry, your name is too long.  But good %s anyway.\";\n    }\n\n    /*  snprintf would be safer, but the above check protects us. */\n    sprintf (greeting, fmt, daytime, username, (int)getpid());\n\n    rc = nn_send (fd, greeting, strlen (greeting), 0);\n    if (rc < 0) {\n        /*  There are several legitimate reasons this can fail.\n            We note them for debugging purposes, but then ignore\n            otherwise.  If the socket is closed or failing, we will\n            notice in recv above, and exit then. */\n        fprintf (stderr, \"nn_send: %s (ignoring)\\n\",\n            nn_strerror (nn_errno ()));\n    }\n}\n\nnn_close (fd);\nreturn (-1);\n\n}\n/  The client runs just once, and then returns. /\nint client (const char url, const char username)\n{\n    int fd;\n    int rc;\n    char greeting;\n    char msg;\nfd = nn_socket (AF_SP, NN_REQ);\nif (fd < 0) {\n    fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n    return (-1);\n}\n\nif (nn_connect (fd, url) < 0) {\n    fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n    nn_close (fd);\n    return (-1);        \n}\n\nusleep(1000);\n\nif (nn_send (fd, username, strlen (username), 0) < 0) {\n    fprintf (stderr, \"nn_send: %s\\n\", nn_strerror (nn_errno ()));\n    nn_close (fd);\n    return (-1);\n}\n\n/*  Here we ask the library to allocate response buffer for us (NN_MSG). */\nrc = nn_recv (fd, &msg, NN_MSG, 0);\nif (rc < 0) {\n    fprintf (stderr, \"nn_recv: %s\\n\", nn_strerror (nn_errno ()));\n    nn_close (fd);\n    return (-1);\n}\n\nnn_close (fd);\n\n/*  Response is not ASCIIZ terminated. */\ngreeting = calloc (rc + 1, 1);\nif (greeting == NULL) {\n    fprintf (stderr, \"calloc: %s\\n\", strerror (errno));\n    return (-1);\n}\nmemcpy(greeting, msg, rc);\n\nnn_freemsg (msg);\nprintf (\"%s\\n\", greeting); \nreturn (0);\n\n}\nint device (const char url1, const char url2)\n{\n    int s1, s2, rv;\n    s1 = nn_socket (AF_SP_RAW, NN_REQ);\n    if (s1 < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        return (-1);\n    }\n    if (nn_bind (s1, url1) < 0) {\n        fprintf (stderr, \"nn_bind1(%s): %s\\n\", url1, nn_strerror (nn_errno ()));\n        return (-1);\n    }\n    s2 = nn_socket (AF_SP_RAW, NN_REP);\n    if (s2 < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror(nn_errno ()));\n        return (-1);\n    }\n    if (nn_bind (s2, url2) < 0) {\n        fprintf (stderr, \"nn_bind2(%s): %s\\n\", url2, nn_strerror (nn_errno ()));\n        return (-1);\n    }\nif (nn_device (s1, s2) != 0) {\n    fprintf (stderr, \"nn_device: %s\\n\", nn_strerror (nn_errno ()));\n    return (-1);\n}\npause();\nreturn (0);\n\n}\nint main (int argc, char **argv)\n{\n    int rc;\nif ((argc == 3) && (strcmp (argv[1], \"-s\") == 0)) {\n    rc = server (argv[2]);\n} else if ((argc == 4) && (strcmp (argv[1], \"-d\") == 0)) {\n    rc = device (argv[2], argv[3]);\n} else if ((argc == 4) && (strcmp (argv[1], \"-c\") == 0)) {\n    rc = client (argv[2], argv[3]);\n} else {\n    fprintf (stderr, \"Usage: %s -s <serverurl>\", argv[0]);\n    fprintf (stderr, \"Usage: %s -d <serverurl> <clienturl>\", argv[0]);\n    fprintf (stderr, \"Usage: %s -c <clienturl> <name>\", argv[0]);\n    exit (EXIT_FAILURE);\n}\n\nexit (rc == 0 ? EXIT_SUCCESS : EXIT_FAILURE);\n\n}\n```. your device is exiting main.  you need to pause there without exiting.  pause() is a good unix function for this. \nSent from my iPhone\n\nOn Nov 22, 2016, at 3:52 AM, kuncao notifications@github.com wrote:\ndevice:\ninclude \ninclude \ninclude \ninclude\ninclude \ninclude \nvoid OnExit(int sig)\n{\nstd::cerr << \"Exiting on ^C \" << sig << std::endl;\n}\nint main(int argc, char *argv[])\n{\nint s1 = nn_socket (AF_SP_RAW, NN_REP);\nstd::cerr << \"s1 value is : \" << s1<< std::endl;\nnn_bind (s1, \"tcp://10.120.96.194:5555\");\nint s2 = nn_socket (AF_SP_RAW, NN_REQ);\nstd::cerr << \"s2 value is : \" << s2<< std::endl;\nnn_bind (s2, \"tcp://10.120.96.194:5556\");\nint sd=nn_device (s1, s2);\nstd::cerr << \"after nn_device init : \" << sd<< std::endl;\n//return 0;\n}\nserver:\ninclude \ninclude \ninclude \ninclude\ninclude \ninclude \nint main(int argc, char argv[])\n{\nint sz_msg = sizeof(\"world\") + 1;\nint sock = nn_socket(AF_SP, NN_REP);\nint endid=nn_connect(sock,\"tcp://10.120.96.194:5556\");\nwhile (1)\n{\nchar buf = NULL;\nint bytes = nn_recv (sock, &buf, NN_MSG, 0);\nint sz_d = sizeof(\"world with device\") + 1;\nbytes = nn_send(sock,\"worldi with device\", sz_d, 0);\nnn_freemsg (buf);\n}\nnn_shutdown (sock, endid);\nnn_close(sock);\n}\nclient:\ninclude \ninclude \ninclude \ninclude\ninclude \ninclude \nvoid OnExit(int sig)\n{\nstd::cerr << \"Exiting on ^C \" << sig << std::endl;\n}\nint main(int argc, char argv[])\n{\nint sz_string = sizeof(\"hellojack\") + 1; //\nchar buf = NULL;\nint bytes = -1;\nint sock = nn_socket (AF_SP, NN_REQ);\n//assert (sock >= 0);\nint endid=nn_connect (sock,\"tcp://10.120.96.194:5555\") ;\nbytes = nn_send (sock, \"hellojack\", sz_string, 0);\nbytes = nn_recv (sock, &buf, NN_MSG, 0);\nstd::cerr << \"client recieve data is : \" << buf<< std::endl;\nnn_freemsg (buf);\nnn_shutdown (sock, endid);\nnn_close (sock);\n}\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Hmm.. it seems I was wrong about about device \u2014 it blocks forever as long\nas the sockets are open.  (Just checked the code, and have removed the\npause() from my demo.\n\nLooking again at your code, I just realized something\u2026 your IP addresses do\nnot match!\nThe IP address you use use for the bind side is the local IP address on\nthe server.  You can even omit it to listen on all interfaces - e.g.\ntcp://:5556 will cause the server to listen on every network interface on\nTCP port 5556.\nThe IP address you use for connect is the remote IP address.\nI\u2019m about 95% certain that this is the problem.\nOn Wed, Nov 23, 2016 at 12:10 AM, kuncao notifications@github.com wrote:\n\nyour device is exiting main. you need to pause there without exiting.\npause() is a good unix function for this.\nI add pause in my c++ code,but it seem to I have to use control +c twice\nto shutdown device,without pause(),only once control +c to shutown the\ndevice.\n-------------------with pause()test begin --------------------------------\nszv1000082629:/home/nanoprorpc/nanorpc # ./device_server\ns1 value is : 0\ns2 value is : 1\n^CExiting on ^C control c\nafter nn_device init : -1\nafdadf\nadfsasdf\nwd\nddd\n^CExiting on ^C control c\n-------------------with pause() test end--------------------------------\nafdadf and other letters is to verify the device can be shutdown after\npause()\n-------------------without pause() test begin-------------------------\n-------szv1000082629:/home/nanoprorpc/nanorpc # ./device_server\ns1 value is : 0\ns2 value is : 1\n^CExiting on ^C control c\nafter nn_device init : -1\n-------------------without pause() test end---------------------------\nmy code:\ninclude \ninclude \ninclude \ninclude\ninclude \ninclude \nvoid OnExit(int sig)\n{\nnn_term();//this is added by jackcao at 20161123\n// to term the socket s1 s2\n//and may term other socket created by nanomsg in this server\nstd::cerr << \"Exiting on ^C \" << \"control c\" << std::endl;\n}\nint main(int argc, char *argv[])\n{\nsignal(SIGINT, OnExit);\nint s1 = nn_socket (AF_SP_RAW, NN_REP);\nstd::cerr << \"s1 value is : \" << s1<< std::endl;\nnn_bind (s1, \"tcp://10.120.229.120:5555\");\nint s2 = nn_socket (AF_SP_RAW, NN_REQ);\nstd::cerr << \"s2 value is : \" << s2<< std::endl;\nnn_bind (s2, \"tcp://10.120.229.120:5556\");\nint sd=nn_device (s1, s2);\nstd::cerr << \"after nn_device init : \" << sd<< std::endl;\n//pause();\nreturn 0;\n}\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/832#issuecomment-262453754,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfYB4aXuW2zkuXlhXYuRlOPX3lZr9ks5rA_ThgaJpZM4K33Zp\n.\n. I think you may be somewhat confused, and understandably so.  While we express a \"natural\" poll interface, under the hood we always use readable polls on the file descriptor, because we write to the file descriptor (from other threads) to wake this.  Really it would be much nicer & cleaner if we used condition variables instead here, and that is in my plan of action.\n\nAt any rate, your suggested change is actually quite incorrect, as you can see by the failures in the test suite.  (Windows uses a different mechanism entirely, and that's why it passed.). Generally not with a single system.  The reason is that you will run out of\nTCP ports, even if you have enough CPU to make it work.\nThere may be some hacks that can be done to work around that, but honestly\nI\u2019ve never attempted to support such a vast number of concurrent user in a\nsingle system.\nYou can build systems with nanomsg that support this using devices and a\n\u201ctree\u201d approach, with each device supporting hundreds, or thousands, of\nnodes at once.  However, if you have that many incoming requests (outgoing\nis easier), it may be rather challenging.  For example, a single system is\nprobably going to struggle to cope with the load of a hundred thousand RPC\ncalls happening simultaenously, or to properly cope with survey responses\nfrom this many nodes in response to a single survey request.\nEssentially what I\u2019m saying is, it depends on the pattern you choose.  But\nno matter what you will be limited on TCP resources, and will need to scale\nout some how.\nOn Tue, Nov 22, 2016 at 6:10 PM, skyformat99 notifications@github.com\nwrote:\n\nCan support 100K concurrent access?\nthanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/836, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfWmaYTwkGnIvsMEbPbj5pRVZByGpks5rA6CrgaJpZM4K6J3w\n.\n. This is a question, not a bug.   Closing.. Note that a similar statement can be made about nn_sock_stat_increment(). I'm ditching this as I'm focused on nng now.. I'm closing this out, as I've redirected nearly all of my current development towards the nng rewrite.. Btw, then we can start replacing nn_alloc() calls with normal malloc() and calloc().. I'm not going to bother with this; new work is happening on nng.. Btw, we can also do a similar thing for transports.. Interestingly -- github pages can render asciidoc.  This suggests it may be a good time to do some experimentation -- getting a bit more automation for releasing new versions, etc.. Please see work in progress on this:\n\nnanomsg.org/rfcs/\nAnd the sources at\ngithub.com:nanomsg/rfcs\nMy plan is to gradually move the RFCs from nanomsg rep to the rfcs repo, converting format and updating as I go.. I'm closing this now... we will continue to work on this as time permits.. Abandoning this in favor nng.  (I had done lots of this work, but ran into soo many problems that it was deemed easier to just rewrite.). Looks like a good fix... I'll merge this soon.. Sorry didn't do this earlier.... I will review and update... stay tuned.. Rebased onto master:\ncommit ee99202f84f8d0e8ebd1c1722aa8a682f54919d0\nAuthor: Bill Williams bill_williams@cable.comcast.com\nDate:   Thu Dec 1 15:35:44 2016 -0800\nFix memory leak when binding or connecting to bad URL\n\ndiff --git a/src/transports/tcp/btcp.c b/src/transports/tcp/btcp.c\nindex 37541f1..4fe8b58 100644\n. I'd avoid using nn_term() actually.  If you're going to just exit, then just do so.\nnn_term tries to drain sockets, and so forth, and it may have errors in this situation with nn_device().  I can look at it later, but its not a huge priority for me.  Its much preferable for callers to keep track of their sockets, and directly close those sockets.... This is weird.  nn_device() starts a thread that runs.  I\u2019m not sure why\nyou\u2019d get a panic.   Are you just calling exit()? or is there something\nelse going on here?\nYou should be able to close either socket used with nn_device and have the\nwhole thing shut down.  (You should probably close both sockets).  This\nshould work even without nn_term().\nOn Mon, Dec 12, 2016 at 8:38 AM, Carlos Tangerino notifications@github.com\nwrote:\n\nWithout the use of nn_term I get this\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_mvmsg+0xed)[0x7f0ef2386319]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_oneway+0x29)[0x7f0ef2386214]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_entry+0xa6d)[0x7f0ef2385edc]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_custom_device+0x2a)[0x7f0ef2385444]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device+0x27)[0x7f0ef238546d]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x4e84fe]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x40ff3b]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x408ea4]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f0ef1dad830]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x4078b9]\nInterrupted system call [4] (/home/carlos/Desktop/\nprojects/nanomsg/src/devices/device.c:299)\nRUN FINISHED; Aborted; core dumped; real time: 3s; user: 0ms; system: 10ms\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/854#issuecomment-266480286,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfXj9eRj8kBYfwlpuTPpivZw8lcrzks5rHXiVgaJpZM4LKJnr\n.\n. No you misunderstood me.\n\nYou should call nn_close(to), nn_close(from) from outside the device framework.  That means you need to run the device in a separate thread most likely, since signal handlers can't do some of the operations that are needed for nn_close() (I suspect).\nBut frankly, why bother with this at all?  Just \"exit\" in your ctrl-c handler if that's what you want to do.  Its harmless enough, and while technically you'd be \"leaking\" some memory, it won't matter because the kernel cleans it all up at exit().. Hmm.. as I think about, nn_term is almost certainly not async-signal-safe either.  Really, if you want to do this \"cleanly\", you're going to have to arrange to do it from a normally running synchronous thread.  This is probably far more effort than its worth.  (You'd have to arrange for a blocked thread waiting on a condition variable, and have the signal handler trigger the condition variable to wake that thread, which would then do nn_term().). Ok, I think I understand the problem now.  This is probably relatively easy\nto fix. (nanomsg is a bit more fragile towards EINTR and other errnos\ncoming from system calls that I\u2019d like\u2026)\n\nGarrett\n\nOn Wed, Dec 14, 2016 at 4:59 AM, Carlos Tangerino notifications@github.com\nwrote:\n\nI tried also to call nn_close from outside and it also blocks and do not\nreturn, nothing helps.\nI may have more information on the path for the error. After running\nvalgring I got this\n[N] 14 13:52:34 (src/rest.c/restd:247) Rest Server thread ended\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_mvmsg+0xed)[0x5a57319]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_oneway+0x29)[0x5a57214]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_entry+0xa6d)[0x5a56edc]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_custom_device+0x2a)[0x5a56444]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device+0x27)[0x5a5646d]\n./dist/Debug/GNU-Linux/dipapp[0x4ebd4d]\n./dist/Debug/GNU-Linux/dipapp[0x413778]\n./dist/Debug/GNU-Linux/dipapp[0x408f39]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x5ebe830]\n./dist/Debug/GNU-Linux/dipapp[0x4078b9]\nInterrupted system call [4] (/home/carlos/Desktop/\nprojects/nanomsg/src/devices/device.c:299)\n==52761==\n==52761== Process terminating with default action of signal 6 (SIGABRT)\n==52761== at 0x5ED3428: raise (raise.c:54)\n==52761== by 0x5ED5029: abort (abort.c:89)\n==52761== by 0x5A541DA: nn_err_abort (in /usr/local/lib/libnanomsg.so.\n5.0.0)\n==52761== by 0x5A57374: nn_device_mvmsg (in /usr/local/lib/libnanomsg.so.\n5.0.0)\n==52761== by 0x5A57213: nn_device_oneway (in /usr/local/lib/libnanomsg.so.\n5.0.0)\n==52761== by 0x5A56EDB: nn_device_entry (in /usr/local/lib/libnanomsg.so.\n5.0.0)\n==52761== by 0x5A56443: nn_custom_device (in /usr/local/lib/libnanomsg.so.\n5.0.0)\n==52761== by 0x5A5646C: nn_device (in /usr/local/lib/libnanomsg.so.5.0.0)\n==52761== by 0x4EBD4C: internalBrokerThread (broker.c:199)\n==52761== by 0x413777: dipBrokerRun (dip.c:368)\n==52761== by 0x408F38: main (dipapp.c:98)\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/854#issuecomment-267027548,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfTfLQUPXZGHKCiOW2_I0DrMV-Epgks5rH-gfgaJpZM4LKJnr\n.\n. No but my focus has been on the nng stuff so I haven't had as much time on\nthis repo.\nOn Fri, Jul 28, 2017 at 9:42 PM Carlos Tangerino notifications@github.com\nwrote:\nNo update on many threads, Is this repo dead?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/854#issuecomment-318803740,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfQkpk-t9vxHb_gs-XHwL82U3n-wIks5sSrhKgaJpZM4LKJnr\n.\n. I know that some work was done to port nanomsg to QNX, and it largely just\nworked (modulo some weirdness with IPC based URLs.)\n\nNanomsg was designed with this use case in mind, and so it should work.\nThat said, nanomsg does depend on having some things that your OS may or\nmay not provide; and you may have to do some work to provide the underlying\nfunctionality:\na) Mutexes\nb) Condition variables\nc) Threads (nanomsg only uses a few threads btw)\nd) POSIX compliant I/O (with select or poll at least) \u2014 or some other async\nI/O scheme (you\u2019ll have to write code if isn\u2019t POSIX)\nFrom glancing, it appears that FreeRTOS isn\u2019t going to work out of the box,\nmostly because it doesn\u2019t support either POSIX or Win32 APIs natively.\nThis might be an interesting project for someone to undertake.  There\napparently is a way to emulate FreeRTOS on a POSiX system, which might make\nthe work of porting nanomsg to FreeRTOS easier.\nOn Wed, Dec 14, 2016 at 2:57 PM, peters-r notifications@github.com wrote:\n\nHi,\nis there any experience with porting nanomsg to an rtos (e.g. FreeRTOS) ?\nWhat are the dependencies?\nHow much ROM / RAM does the library consume?\nWould it fit into an ARM Cortex Microcontroller?\nThank you in advance,\nRichard\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/855, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfdK4ZEdE_IKqFVScCyj6LlDhJPYNks5rIHRlgaJpZM4LNhBU\n.\n. This is a question, not a bug or change request.. There is no such option, because due to lack of queueing, that\u2019s more or\nless the default behavior.\n\nOn Mon, Dec 19, 2016 at 1:09 AM, mwx notifications@github.com wrote:\n\nIn case when subscriber is slower, and only want latest messages.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/856, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfTVsjMHCtUWpACV-kQRPA4sEaCLuks5rJkm1gaJpZM4LQgeq\n.\n. I'm actually pleased someone is reading that work... . No, that is quite correct.  The comment above explains it.. Actually, the generators used for CMake depend greatly on the contents of the environment.  I use the nmake based generators and that way I can just do NMake most of the time.. You would use -G \"NMake Makefiles\".\n\nNormally CMake tries to choose a reasonable default generator.  It doesn't always choose well.  I would hope that Windows developers are familiar with the problems associated with this on Windows.\nBtw, Visual Studio Code has CMake support \"built-in\", so that pretty much Just Works.. There is a restriction for very large messages -- you can't send more than 1.0MB unless you change the NN_MAXRCVSIZE socket option.\nThat said, this should not cause an assertion to occur; I think you may be encountering a bug we solved a while back.  What version of the library are you using?. Ok, that's helpful information.  I suspect you're running  into an edge case caused by the 1MB limit.  That's a bug, obviously.. Agreed, its definitely a bug.  To be completely honest, nanomsg isn't\n\u201csafe\u201d for the hostile internet.  I have much greater faith in mangos,\nand soon libnng.  (There are lots of ways malicious actors can make nanomsg\ndo bad things unfortunately.  iibnng is due to replace libnanomsg soon, and\nit is being designed to be secure / hardened from the start.)  If you\u2019re\nfaced with need an internet facing deployment, stick a mangos device\nimplementation in front, and you should be golden.  That way you can even\nuse websocket or TLS\u2026\nOn Thu, Jan 26, 2017 at 1:29 PM, James Masco notifications@github.com\nwrote:\n\nI set NN_RCVMAXSIZE to a higher value on my receiving side and that seems\nto prevent the assertion on the other end, however I would suspect that\nthis is a bug if the subscribing side can take down the publishing side.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/860#issuecomment-275519527,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfQ62keqBppbyp_xormEwbNHwN_xVks5rWRAtgaJpZM4LiGv4\n.\n. For the record, I think the send of the large sizes and retries causes the socket to keep getting reopened, leaving the state ... ahem... weird.. Today, libnanomsg does not have any kind of security built in, but you can \"fake it\" by using a device along with mangos (github.com/go-mangos/mangos), which does support both TLS and secure websockets.    What you do is have a mangos device that proxies from TLS (or WSS) on one end, and forwards to a local libnanomsg client over a secure local transport, either loopback TCP or UNIX domain sockets.  (Of course if you are writing in golang, you don't need to use this proxy at all, just use mangos and go on happily without nanomsg. :-)\n\nAdding encryption to libnanomsg itself has proven to be sufficiently challenging that nobody has done it -- mostly because if the byzantine state machines internally used.\nI'm in the midst of a major redesign (wire protocol compatible, just like mangos) that definitely has aspirations to support TLS, secure websocket, and probably also an SSH-based transport.  (I'll probably add SSH transport to mangos too).  This design is based on experience gained implementing mangos.  You can see my work in progress at github.com/nanomsg/nng -- the roadmap is that at some point nng will replace libnanomsg.  However nng is in its infancy, and so is not ready to do this.   However, it is functional enough to start experimenting with.  (The timeline for more serious beta testing and pre-deployment is probably still a couple of weeks away, especially for folks that want to use the libnanomsg API compatible shim.)\nNote that all three products, nanomsg, nng, and mangos, can all speak to each other over TCP and IPC.\n. So this will be coming soon nng.  But probably never in nanomsg.\n. Closing this as 'will-not-fix'.  (again, I will be doing this in the follow-on nng library, probably later this month.). That attached zip file is empty.   So I can't really help you. . Probably you don't realize that to use the REQ/REP protocol with JavaScript on the browser, you have to have backtraces in the messages.  PULL/PUSH doesn't have any extra headers, but REQ/REP needs to have a \"backtrace\" that includes a request id and details of where the request came from.  Please read the RFCs in the rfcs/ directory.. The libnng rewrite is taking the approach to never abort().  There are a few cases left in, but they are truly assert() conditions -- things that should never ever come up and frankly if anyone ever did see an abort() then it would represent a serious bug in the library.\nFixing all these in the current libnanomsg is something I'd be willing to see PRs for, but at the moment I'm investing more of my energy in the rewrite.. And just to be clear, asserts() are not appropriate ways to handle error returns from syscalls -- as you've noticed this impacts reliability and portability into the future.  The libnng approach is to percolate these errors all the way to the application (except in a few cases where it makes more sense for us to do something different to handle them, such as backing off and retrying a connect() attempt or somesuch.). We have killed a few more assertions, though we're not done yet.  nng is safer in this regard.. So, for now, unless you're triggering an actual assertion, I'm going to close this issue, because its not really actionable.  If you're getting an assertion failure, then please do open a specific bug.  That may represent a coding error, it may represent a case that shouldn't be an assert at all.  But what I'm not going to do at this late state in nanomsg is scrub them all out.   I will happily remove any that you feel are particularly problematic, but please provide details in such a case.. This is crashing (segfaulting) in the tcp test.. So, the state machine changes look good, but I'd like to not include the debugging stuff; I realize it was useful to you, the debug stuff needs to be more completely thought out if we're gonna do that, and should be handled as a separate PR.\nUltimately, we would like to get this to just one commit as well.. So I've asked for cleanup of some unrelated changes to files -- probably these are things you changed and then changed back as you were trying things out.  We want to boil this to just the change that we want.\nAlso, I'd like you to submit this as a new PR, with the commits squashed into a single commit, with the commit comment as \"Fixes memory leak that happens when nn_bind fails returning EADDRINUSE\"  - that way we can see the single issue in one swoop.\n(Even better, if we have a github issue already filed for this, the single commit comment would be a line of \"fixes # \"   -- see the git commit history for examples of that.. Maybe pub/sub is a better pattern for what you want?. This seems like a request for a different kind of protocol; at the moment I'm going to refer you to pub/sub.  If you want to have a different one still, please provide more detail, and open a new ticket.  The BUS pattern will probably always be fully broadcast, since that's part of its definition.. So I'm unlikely to accept this.  stdint.h is provided in Visual Studio 2012 and later, and these compilers are free, and support the same platforms as VS2008.  I frankly can't see any reason to worry about supporting these older compilers.\nIf you have a problem where you have to solve this, as indicated, just copy a stdint.h from some likely place into your include directories.. So no, I'm not going to accept this PR, sorry.  I would however like to understand why using older VS 2008 (its pretty darn old now) is a requirement?  These days I'm using VS 15 (2017) Community edition.  It's free for non-enterprise users (including individual commercial users).  Enterprise users (those with > 250 PCs or $1M in revenue) have to pay for it if they want to create commercial apps, but ... that's not a typical concern.  If you work for a big company, you can afford to pay for your compiler to build your commercial apps.  (I'm not interested in spending my effort sustaining code to enable corporations who want to cheap skate their commercial development process.)\nAgain this doesn't affect any open source development, nor does it affect smaller companies or individuals.  Those folks should just pick up VS community and stop whining. :-). Only if you can pass either websocket or raw TCP.  nanomsg has no awareness of socks or TOR.. I need more information here; most likely you have a TCP connection that has been aborted during the connection establishment phase, and the state machine is somewhat unhappy about that.  Having said that, I thought we had addressed most of these.  Can you tell me what version you tested with?. I'm pretty sure this is a dup of #895 (or rather 895 is a dupe of this, but for now I'm using 895 to track it.)  A fix is about to be pushed.. I haven't looked at any of this.  I'm not surprised that the IPC tests fail hard -- it's likely that UNIX domain sockets are simply not supported on WSL -- the underlying system doesn't have anything like them; Windows Named Pipes are quite a lot different.\nThe other tests will take more time to debug.   WSL is effectively a new (and right now unsupported) platform for nanomsg.. So tcp_shutdown and ws are the only tests that are not failing to IPC.  (separation is in fact using IPC.)\n. I'm probably not going to bother to fix these in nanomsg.  For nng we will look at it.. So I tested with the very latest WSL today.\nMost things work... but .. IPC is totally absent -- (you get EPERM if you try to open an IPC socket), and TCP works \"funny\" in that SO_REUSEADDR does not have the normal semantic ... instead it lets any process bind to the same port.  And, frankly, you want SO_EXCLUSIVEADDR, but I have no idea how to get that from the WSL subsystem.\nI will try to add code to detect WSL, and disable SO_REUSEADDR in that case.. I really can't do anything about IPC... since I have no idea how to get to Named Pipes from WSL.. Good news... I have local code that fixes these -- basically the IPC related stuff is disabled, and the TCP test is working.   The tcp_shutdown test fails because for some reason setting up 100 threads doing bind / connect takes too long, and it times out.  I've reduced the count to 10 threads for WSL only, and then it passes.  I had to bump the timeouts up from 5 seconds for the ws and tcp tests as well, because again Windows seems to take longer to set up and tear down connections, and WSL is even slower than the host Windows.\nI would not attempt to use WSL for anything production wise based on my tests.  It is interesting, and having nanomsg work there is a pretty nifty idea.\nBtw, we detect WSL by noticing Microsoft in the uname version.. This is now fixed.  See http://nanomsg.org/gettingstarted/\nBasically I copied his content from the Wayback Machine, and converted to asciidoc.. the examples are nice but Tims original article was better.  it sure would be nice if we could find that somewhere.  i will ask him. . Tim has indicated he plans to repost the blog somewhere.  Stay tuned.. I'm still waiting for an update from Tim..... I've already fixed this -- nanomsg.org/gettingstarted/\n. What purpose does this PR serve?. but what was wrong with the old names.  these were tests for specific bugs described in the given bugids. . Right -- so the problem here is that no validation is done beforehand, and yes, this means that the data pointed to can get lost, leading to a leak.\nDo you actually have a reproducible crash that this fixes?. So I've spent a bunch more time looking at this.\nThe issue here is a confusion about the semantics of nn_msg_mv(), which is the only consumer of nn_chunkref_mv.\nnn_msg_mv() moves the contents of the message from one struct to another.  It leaves the old message structure in an intdeterminate state.  As you note, it would be a gross error to call nn_msg_free() on the source message after this. \nThe existing nn_msg_mv() callers simply reinitialize the source message structure.\nYour change, while not precisely ... perfect, would actually make the source structure \"safer\", leaving a zero size behind, so that nn_msg_free() would be safe.  Having said that though, none of this API is public (for external consumption) -- it isn't documented anywhere at all, and while the existing semantic is probably confusing, it's not really worth fixing at this point.\nThe reason it isn't worth \"fixing\", is that the next generation library, nng, doesn't have this problem at all (it doesn't use chunks or chunkrefs at all!)  and I'm trying hard to minimize further investment in the stable version of libnanomsg.\nSo, I'm closing this as will not fix -- it isn't necessary to fix and doesn't represent an actual bug.. so the actual value of the data field at this point should be undefined; that is the meaning of the pipes data member is not set until something else sets this.  normally that should be done by the caller of this routine.  (code should not assume that an unassigned pipe has any value here - even NULL - unless they set it.)\nDo you have specific bug cases where this is not being done?. You're missing the point here.  Undefined state is actually a valid situation here.  If a protocol needs to depend on this data member being NULL, then it should set it so.  This is protocol private data, and it isn't the framework's job to assume or impart any meaning to this; in this context NULL is no more meaningful an initialization value than say 0xFFFFFFFF or 354, or a pointer to a string containing the value \"NULL\".\nIf a protocol does not use this field, then it is free to leave it uninitialized.  Of course, if it does, then it had better do so.  Frankly, I want transports doing this themselves, then relying on the framework to do so for them.\nThis is more about design correctness than about saving an instruction.  (That said, yes, it can save a slight bit of work.)\nNote that we are talking about protocols.  It is incorrect for a transport to set this member.  Transports are things like TCP.  Protocols are things like REQ/REP.\nThis member is entirely protocol-private.  Any protocol that calls nn_pipe_getdata() should first have called nn_pipe_setdata().. Note that all the protocols, except PAIR, both set and use the data field properly.  PAIR makes no reference this whatsoever, since it has no need to store protocol private data there.. I'm closing this pull request per the discussion above.. I believe this is all fixed now.\nThe last complaint about install is instructive -- you have to have root if you want to install to /usr/local or somesuch. . Whether the message is dropped or not depends on the protocol.\nWith most of the protocols we just drop the message.   For example, a survey is taken based on who is connected.  It is in fact at some level a report of which peers exist and are ready.  Blocking would be a poor choice here (actually true for pretty much any of the multicast protocols.)  (Recall SURVEYOR can have multiple peer respondents!)\nThe state of underlying physical connections is specifically abstracted away from the application in nanomsg.  If this behavior isn't what you want, you probably don't actually want to use nanomsg; this is one of the differentiating features of nanomsg.\nSo, this is not a bug, but quite intentional behavior.. The rationale here is that the application shouldn't have to double timeouts or anything like that; the intention is to free applications from having to worry about this.  This means that apps that need guaranteed delivery should use REQ/REP and rely on the REQ to resend (and they really need to use idempotent REQ messages too!)\nUnder the hood, the reliable patterns (REQ/REP, and to a lesser extent PIPELINE) actually queue messages and if they cannot be delivered to a peer (because no peer exists) will hold them until a peer becomes available.   So again, no doubling needed.\nThis is a design trade-off.  With normal sockets, you have to handle them all in your app; nanomsg's design center is to free the application from all these various concerns.. I think I've answered this now, closing it.. Thanks.  Yeah, its a numeric not a pointer.  I'll fix.. Thanks.  I'll have a look.  Can you confirm which version of nanomsg this is?. Sorry, but no, this is not possible.  Its possible we could add this; can you provide a little more data about your use case?. I really think if you're \"peeking\" at messages you're doing something wrong from a design perspective.  Its better to use PUB/SUB, or different socket addresses.  With websocket you can even demux messages on the same port number (though you need to use mangos or write some custom code to do it -- which is on my TODO list).  So to justify MSG_PEEK, I'd really like a very concrete justification; the use case you've supplied just is too vague.\n@itssofluffy  On the topic of nn_poll waking early, yeah, that's kind of unfortunate, but its an artifact of the underlying plumbing; we have to run the state machine and need the wakeup to get there, which means we need to run some code on the user thread.  It's also the case that there is no guarantee that nn_poll wakes up only when data is available; the guarantee is that we won't fail to wakeup when data is available.    But any rate thats a totally different issue from what is discussed in this bug.\n@reqshark Sharing precise endpoint addresses for different protocols is never going to happen, because it turns out to be rather nonsensical to do so.  In fact, we don't tag every message with the protocol, its negotiated at connection establishment.  What you probably want is to be able to reuse the TCP port, which can be done with another qualifying element (such as a path component for a URI in websocket).    Allowing multiple protocols / sockets to share a single TCP port number is definitely in the cards; sharing the entire address is not.. Yes, I could.  The problem is that at present nn_poll doesn't know anything about the socket type.  It just knows that there is generically I/O ready.  Adding that knowledge at this stage in the game is not something I'd like to do, just to avoid introducing further complexity.\nI will definitely keep this in mind for libnng -- in fact I think libnng already has the semantic you're looking for, since we aren't relying on the same underlying mechanisms for processing I/O. :-). This seems suitably resolved (answered) so closing it.. Client side code (connect side) looks good.  Server side is using the wrong socket option.  Please fix and retest, then resubmit.  I'd appreciate an understanding of how you validated the test.. With NN_MSG, you need to use the address of the pointer for sure.  If you don't use NN_MSG, you use the pointer itself.\nSo the the nn_send without NN_MSG but with the & is sending the contents of the page of memory where the bufs pointer lives -- i.e. a page from the stack.  x86 stacks grow down, so you're sending 1000 quasi random bytes.  (The first few dozen bytes are the the address of the allocated message, plus whatever frames are added to the stack beyond that.)\nWith the NN_MSG, nanomsg will dereference the pointer passed, which why you need the & sign.  On my system, using NN_MSG without the & sign results in a segfault.  Using it with the & sign works fine.\nPut another way, the examples and the documentation for these calls are correct as reported. \nIf you want further help, please write a minimal test program and include said test program in its entirety so that I can make sure that what you're seeing is not the result of corruption or errors elsewhere which could change expected behavior.\nThanks. . In the meantime, I'm closing this since its not a bug.. A few thoughts here:\na) poll is never guaranteed to wait for the entire poll time.  It may wake up early for a variety of reasons; this is true for ordinary poll as well.  (the timeout represents a maximum time to wait for a change, not a minimum).  nn_poll() does indeed return early when it finds that one of the fds passed to it are invalid.  (Basically it passes through the error from nn_getsockopt(), which is used to obtain underlying notification fds.)\nb) poll will also return any errno coming from the underlying OS poll() call.  That's operating system specific.  Under normal circumstances, it works fine, provided you give it valid fds.\nc) nn_poll is not a drop-in for regular select or poll -- that is you can't use it to build either timers without fds.  (For example, you cannot implement usleep() in terms if nn_poll().)\nd) Probably the documentation and/or return codes should be updated.  Obviously if you pass invalid descriptors we need to provide some kind of meaningful error -- EBADF is probably better here.\nGenerally I hate nn_poll(), since its of very limited utility -- almost always you are wanting to multiplex with other file descriptors, and that means you need to use the OS-specific poll, along with the nn_getsockopt of NN_RCVFD and/or NN_SNDFD.  All nn_poll does is wrap that logic up in a convenient wrapper, which turns out not to really be so convenient in the real world.\nNow its also the case that you're sending some garbage to nn_poll beyond just a -1 fd.  The second argument to nn_poll is a count, not a size.  That is in your case you should be passing the value 1, for one file descriptor, rather than a size.  Passing a size means you're passing sizeof nn_pollfd, which is probably 8, which means that the code will try to dereference into some strange place (probably the stack), and pass utter garbage down.\nSo, I'm disinclined to treat this as a bug, at least until your code is fixed.  You might want to have a look at the test code in tests/poll.c, which can serve as an example.  Look specifically at this stanza:\n/* Test nn_poll() function. */\n    sb = test_socket (AF_SP, NN_PAIR);\n    test_bind (sb, SOCKET_ADDRESS);\n    sc = test_socket (AF_SP, NN_PAIR);\n    test_connect (sc, SOCKET_ADDRESS);\n    test_send (sc, \"ABC\");\n    nn_sleep (100);\n    pfd [0].fd = sb;\n    pfd [0].events = NN_POLLIN | NN_POLLOUT;\n    pfd [1].fd = sc;\n    pfd [1].events = NN_POLLIN | NN_POLLOUT;\n    rc = nn_poll (pfd, 2, -1);\n    errno_assert (rc >= 0);\n    nn_assert (rc == 2);\n    nn_assert (pfd [0].revents == (NN_POLLIN | NN_POLLOUT));\n    nn_assert (pfd [1].revents == NN_POLLOUT);\n    test_close (sc);\n    test_close (sb);\n. In fact, I'm pretty sure you're seeing bad stack corruption as a result of this error.  That can lead to confusing the hell out of nn_poll itself, since it can wind up clobbering its own stack.  Lying about the number of pollfd entries you give nn_poll is not a good idea.. Turned out we were just clobbering errno that was already set by nn_getsockopt.  Easy fix.. nn_bind does indeed return immediately, this is by design.  This is also true  of nn_connect.  This is referred to as the TCP slow start problem in various nanomsg and 0MQ documentation.\nI'll review the docs to see if they can be improved.. It depends.  Pending blocked calls are woken up with ETERM.  New calls will return EBADF.  This is pretty annoying but its a legacy semantic.  I recommend treating both errors the same way. \nSent from my iPhone\n\nOn Jul 8, 2017, at 6:15 AM, Amir Rossert notifications@github.com wrote:\nSo this is a mistake in the documentation?\nWe should expect EBADF in this scenario?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. This might be inproc messing things up.... So... actually I forgot that the current behavior is as intended, as set up with #692  -- the only way ETERM occurs now is if you call nn_socket() to try to open a new socket after nn_term().  For everything else we just use EBADF everywhere.\n\nI will fix the documentation for nn_term() to reflect that.. It turns out that the docs also indicate that nn_term is nonblocking, which is not true anymore.. You\u2019ve never opened even one socket, so the library isn\u2019t initialized at\nall.  Yes, this is a bug.\nOn Sat, Jul 15, 2017 at 6:36 PM SG7 notifications@github.com wrote:\n\nAccording to the documentation nn_recv()should return EBADF for an\ninvalid socket\nTest program is simple:\ninclude \ninclude \ninclude \ninclude \nint main (int argc, char **argv)\n{\n    char in_msg[1000];\n    int bytes = nn_recv(0, in_msg, 10000, 1);\n    printf(\"%d\\n\",bytes);\n    return 0;\n}\nClearly the socket is an invalid one. (It was not even opened.)\nNanomsg lib crashes :\nInvalid argument [22] (/tmp/nanomsg-20160926-28652-1s6epum/nanomsg-1.0.0/src/utils/mutex.c:89)\nSignal: SIGABRT (signal SIGABRT)\n0   libnanomsg.5.0.0.dylib              0x00000001000a1cd7 nn_mutex_lock + 37\n1   libnanomsg.5.0.0.dylib              0x000000010009a4d8 nn_recvmsg + 58\n2   libnanomsg.5.0.0.dylib              0x000000010009a498 nn_recv + 58\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/890, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDffGhDNyLgqV8naRPvIhD6r_rIQbPks5sOWk4gaJpZM4OZK_9\n.\n. Actually, the result of pthread_mutex_unlock() operations on an uninitialized mutex is undefined.\n\nAs I indicated, this is a bug.   We need to check whether the library is initialized.  That said, the application is also buggy in that it calls these operations before even attempting to open a socket.\nA workaround would be to open and close a single socket in your application's main(), before doing anything else.  That should result in EBADF instead of crashes.. Not every platform supports pthread_mutex, and for some platforms (vxworks, which we don't support), there is no way to statically initialize a lock.  (Seems crazy, I know... but...)\nThe nature of this \"bug\", is that an application is attempting to perform calls on a socket that it never opened.  That's clearly an application bug; very similar in nature to calling strcpy() into a random pointer that was never initialized with malloc() (or other initialization).  Or calling free() on a pointer that doesn't point to allocated memory.\nI don't feel a compelling need to guard against such insanity, and at this point investing a \"fix\" for this into nanomsg isn't worth the extra effort and risk.  Just \"fix\" your application.. this sounds interesting. mapping POSIX sockets to websockets is not\npossible but maybe they have some other solution. i will investigate.\nOn Sun, Jul 16, 2017 at 5:19 PM Jean-Marc Le Roux notifications@github.com\nwrote:\n\nI'm pretty sure I have to add platform (Emscripten) specific stuff here:\nhttps://github.com/nanomsg/nanomsg/tree/master/src/transports/ipc\nBut I don't know where to start...\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/891#issuecomment-315648728,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfanGXnKvj7Ujtip6irQ1IzWxyGNwks5sOqiZgaJpZM4OZdIe\n.\n. Having looked a bit more... there is some evidence of support for nonblocking socket equivalence, which may be useful in code used within nodejs.  However, there is no chance that a useful implementation will work in the browser; the browsers still restrict access to only websockets.\n\n(TBH, this restriction, which I find to be made based on \"security\", seems pretty silly to me.  If I can open a websocket, or an HTTP socket, why can't I open any other kind of TCP socket.  I don't understand how there can be a security difference there, and I'm almost willing to chalk that up to my own ignorance -- but not quite.  Maybe someone who's watching can clue me in further.). i dont understand why you would need to treat ipc any different than tcp.  its still just a socket. . So WebWorkers don't share address space or any kind of global data?\nImplementing a new port for nanomsg is probably a mistake, IMO.  Instead, you might want to have a look at libnng... especially the changes I just merged into master.  There is support for a platform specific set of IPC calls, and I'd imagine that you could make a \"JavaScript\" (browser?) \"platform\" that offered up its own webworker based IPC implementation.  Alternatively, you could invent a new transport entirely, but IPC is probably a better model for you.\nThis whole thing starts to sound really interesting to me!. Sorry, this fell through the cracks.\nThe way to treat emscripten is as a new \"platform\", not altogether different from POSIX or Windows.  I don't really see how it could be different.  This is sort a new \"Virtual Machine\" underneath.\nnng is the future of nanomsg.  I've spent a lot of effort making nng superior to nanomsg -- it's not production ready yet, but it's also not far.. It might!\nOn Tue, Sep 19, 2017 at 7:00 AM Jean-Marc Le Roux notifications@github.com\nwrote:\n\nSo if I try to build nanomsg using Emscripten, it might \"just work\" if my\napp uses non blocking sockets?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/891#issuecomment-330548431,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfQIV2_Mmvu2nvs1EWewmOqodeB-6ks5sj8j-gaJpZM4OZdIe\n.\n. To use IPC on nanomsg, you'd have to have the entire family of AF_UNIX calls, including socket(), bind(), listen(), send(), recv() (and poll() or whatever) and support for the AF_UNIX sockaddr family.  This is probably not something that can trivially be done if your platform lacks support for it.\n\nYou could create your own port of the IPC transport, using the existing code as a model (note that Windows emulates the POSIX functionality).  I'm not going to guide you through this for libnanomsg, because frankly I don't want to invest the time here, and I don't think you should either.  (Writing new transports for libnanomsg is not easy.)  Instead I think you should have a look at nng; it has platform hooks for IPC that should be pretty easy to implement.\nFor now closing this against nanomsg so it doesn't count \"against\" it as a bug/issue.  Feel free to continue to discuss here though.. Please consider running this with valgrind instead.  The memory growth you're seeing may be due to additional consumption in libc, or having more connections, etc.  valgrind does an excellent job of locating leaks (Linux), and I'd prefer to see reports of leaks using that tool as I don't have to reverse engineer what rss measures etc.  Additionally, valgrind will inform us exactly what is leaking (what block of memory, where it was allocated, etc.)  You may have different results above (your code only reports growth) due to higher levels of concurrency in some runs, etc.  I am not at all prepared to assume that this is a leak -- it could well be an artifact of how you collect the data, and a misinterpretation of the results.  (If you saw higher and higher results over a run spanning the course of hours instead of under a minute, I'd be more convinced.)\nHaving said that, the fact that you're spawning new processes is a giant red flag for me.  nanomsg is not fork-safe, and its quite possible for it to leak file descriptors, etc. during this process.\nAs to why posix_spawn() fails -- if those processes do not exit (and you're not waiting on them!), then you can wind up with lost resources.  The fact also that you're not reaping them with a wait() means that you may run out of slots in a per-process operating system wait() table or running into a user-level process count limit (in other words you may have too many zombie processes!).  You can solve that by doing a sigaction() call to set the SA_NOCLDWAIT flag on the SIGCHLD signal.  See the sigaction man page for more details. . if the message is over 1MB you will need to change the maxrcvsize option.\nwe discard messages larger than this - for security reasons.\nOn Thu, Jul 27, 2017 at 6:56 PM SG7 notifications@github.com wrote:\n\nCould you post the code for your case?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/893#issuecomment-318534832,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfQg4yOvQ9NsCYcN4o_t2HL_QMtO3ks5sST_HgaJpZM4OmBZ2\n.\n. Unfortunately the build was done without debug, so we don't have as much to go on.  This does look like it is involving the inproc transport, which has a bunch of known race conditions.\n\nIdeally I'd like to fix this, but realistically, the libnng library will be ready first, and I don't particularly want to refactor the inproc transport to address it's various races.. Having said that, I think I'm going to refactor inproc to use socketpair() (or a pair of connected loopback sockets on Win32).  I'm sick and tired of the inproc races.. So I'm pretty sure that the problem is that a peer notification (previously queued perhaps) is arriving after we think we've told the peer to stop.  We just ignore those peer notifications if we're shutting down (apart from the peer telling us it is done.). I think the problem is that a connection is being aborted too early, and the code that nanomsg uses to parse the header is failing.  This is a bug -- but I think its also a sign that you're using a debug build of nanomsg instead of a release build.\nA quick fix / workaround would be to either compile without debugging enabled, or simply to remove the assertion at line 295.\n(I probably should just remove that assertion in the main repo.). You are correct; I forgot that nn_assert had that behavior. :(\nI'm just going to fix the bug properly now.. Yeah, let's' fix that too.  Can you file another issue to track that?. Yes, I had a plan to update the gh-pages, and not actually base64 the images.  Stay tuned.. Ok, gh-pages updated and docs converted to asciidoctor.  See nanomsg.org/gettingstarted/\nClosing this PR.. Looks good, thanks!. This is failing with segfaults on Windows.   It needs work before it can be merged.. In fact, reading the entire code flow, this is all all wrong.\nBecause we've established the ep state, our bws_stop() entry point should be called eventually, and the endpoint should actually terminate cleanly.\nThe current approach in this PR is completely wrong.  I'm closing it.. The lack of a \"break\", is because the other cases \"return\", and default is the last case.  There is no need for a break.. Good catch on the uninitialized variable, though.  This should be cleared to zero after the cws structure is allocated.. No, they won't -- because both of these call nn_fsm_error(), which aborts the program; these conditions are never supposed to arrive, and this is effectively an assertion that they do not.\nSee src/utils/err.h for details.. nanomsg does not today implement any kind of shared memory transport.  There were designs intended to make this possible via the IPC, but we've just never gotten around to it (and shared memory turns out to be really hard to do right in a general purpose networking stack because you have to manage resources allocation and deallocation properly -- the latter being fairly hard to get right in a non-racy manner.)\nA good question, however, is whether you really need shared memory transports.  The loopback TCP is surprisingly fast, and IPC is available as well; modern CPUs copy data actually pretty darned quickly.\nIf you assume zero compression, and want to encode 4K video streams (24-bit color) at 60Hz, you need something like 17Gb/s.  A naive run using 256K message sizes over TCP on my laptop macbook pro gets about 18 Gb/s.  Larger message sizes have better perf...   using 2MB messages I get about 20 Gb/s.  Using UNIX domain sockets I get about 30 Gb/s.  These are single threaded numbers (1 thread sending, one thread receiving) -- reproduce the results from using the local_thr and remote_thr utilities btw.\nThat's for throughput, and it indicates the sustained performance you have to provide to be jitter free.  Of course, there is also latency, but the latency you will get over this kind of session is so small as to be unnoticeable by humans.  (Typically we don't notice audio latencies until they reach up to about 30-40 ms.  I'm not sure what the video tolerances are, but I suspect that they are similar, or even more tolerant.  For example, most gaming platforms can tolerate latencies of more than 50-60 ms before even the best players notice.\nIn the future, we may provide a true zero copy transport for nng (the successor to nanomsg, but having a compatible API) -- there are use cases like yours, and others (high speed storage) which would benefit from reduced data copies and higher throughput.. Btw, the architecture of \"satellite\" process leads towards a current popular design pattern -- \"microservices architecture\".  This is a good solution to breaking up a complex system, with many benefits.  nanomsg is designed to act as the fabric/glue/transport for such systems.. nng actually solves this.  With nanomsg, the problem is that while only one server is actually bound, you don't get any feedback that the other server failed to bind -- it just sits in the background and keeps trying.\nnng isn't quite ready for production yet, but you can try it for this.  It is wire protocol with nanomsg (although for NN_PAIR you have to ask for the older pair protocol -- we have a newer one in nng that is used by default.). Yeah, unfortunately we assume that you want to build a DLL by default.  Windows is problematic here -- you have to set things up for either a DLL or a static lib, and they aren't handled the same way.\nDefine -DNN_STATIC_LIB=1 or you can define NNG_DECL=extern  -- either will work.\nI will review our approach for nng and for future nanomsg releases.. For now I'll add docs to this effect.. I have an AI to repost this content somewhere .... Closing as a dup of #872 . Not really. But RDMA will win for larger messages. However I am probably\nnot going to put that effort into nanomsg but instead in nng.\nOn Fri, Oct 6, 2017 at 10:37 PM Simon Zhang notifications@github.com\nwrote:\n\nTCP are old and low throughput\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/906#issuecomment-334912135,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfQ2rf4LMhYwpc4h-HVmR457bsjzBks5spw4bgaJpZM4PxPdi\n.\n. RDMA support is something we might consider for nng - I probably won't ever backport it to legacy libnanomsg.. This is never going to happen for nanomsg.   For NNG its a possible future effort, but it would really need to have some commercial support to make it happen.. See https://github.com/nanomsg/nng/issues/480\n\nI'm closing this as will not fix for nanomsg.  NNG... who knows... show me the money. :-). That looks like a bad assertion to me, but it also looks like maybe you've received some bad websocket protocol (bad HTTP actually)?\nI need to think about this a bit before I come up with a fix, to make sure I fully understand it.  Can you describe the condition in which this occurred (how to repeat it?). Ok reviewing the code, it looks like we erroneously keep asking for more data, even after we've received the entire set of headers, if the specified set of headers is invalid.\nThis leads to the case where we trigger the assertion, since the RCV_MORE should only occur if the  HTTP headers are incomplete.. Note that triggering this fault requires a non-compliant peer.  But yeah, we have to harden it.. Located here:  (/var/www/html/nanomsg-1.0.0/src/transports/ws/ws_handshake.c:497). Well, since I can't see your link line, I can't answer that.\nYou need to link against the .LIB -- not a .DLL.. Yeah, you have to link the various winsock, windows libraries.  (or whatever is appropriate for your platform.) \nYou can have a look at the CMAKE logic -- we link against these libraries:\n-l ws2_32 -lmswock -ladvapi32\nThese are standard required libraries for Windows socket code.. I believe the questions are now answered.  Submitter, can you confirm?. I've added some more details in the README now.  Closing this.. Thanks for filing this.  I went ahead and fixed already --- see #870  \nClosing this as a dup.. So it would appear that the Visual Studio 2017 image is unreliable when running tests.  I think the problem is likely that it is being run on different infrastructure, and consequently may have fewer resources available or other constraints.\nI could spend a bunch of time tracking this down, but at this point, I'm inclined to just punt on it for now.  We will need to get this right for nng, and that may mean taking more care about designing tests that don't have these problems -- I think part of the problem is high thread counts don't work out so well there.\nBut for nanomsg, I'm going to just punt.. Thanks for this -- I had noticed this myself earlier today, and just not gotten around to fixing it yet.. We've gotten thru enough of the tests to demonstrate this works... I'm not gonna wait for macOS at Travis.  . This is unlikely to take place... the existing hash algorithm is sufficient for now, and I'm not sure that the algorithm we use in NNG is appropriate for this usage.   TBH, I'm just less interested in spending time performance tweaking the nanomsg library -- investment of that nature is more appropriate for NNG.. I'm not aware of a Pascal or Delphi binding.  It probably would not be hard to make one.\nWe don't deliver precompiled binaries.  Maybe someone has built them, but the problem is that I'm actually sure what the best way to deliver precompiled libraries for Windows is, given that there are static and dynamic variants, and 32 and 64-bit versions.  (Never mind also ARM and x86.)  We actually recommend using static compiles for WIndows (and frankly if I had my druthers a static library would be the default output.)  Having said that, I'm open to making a binary distribution if someone can point me in the right direction.\nWe do use API calls that are not available on Windows XP and 2003 -- so these are non-starters even at run time.  Sorry.  Those systems are long since unsupported.\nIPC on Windows works using named pipes.  (Note that mangos -- the go version -- does not support this yet, but its on the TODO.)  I'm not familiar with WM_COPYDATA -- I believe we just use normal byte oriented ReadEx and WriteEx on Windows, using Windows named pipes.\nApplications using the IPC layer on Windows can communicate with other applications using the same IPC URL (e.g. ipc:///someplace) on the same Windows machine.  (We do not support IPC over the network, even though I believe some named pipes can be configured this way on Windows.  If you want to go over the network use TCP.). So I started to look at Delphi... but those guys are nuts -- they want you to buy Professional license to unlock anything more than 32-bit windows support, or when you reach $1k revenue.  The cost of the professional license is about $1600 -- so literally they intend to kill any one starting a business developing products in Delphi.\nThere's Free Pascal. not sure how portability across versions is.. Closing this for now.  Maybe someone will make a Pascal binding.. The CMake \"warnings\" are normal on Windows; you can ignore them.  (You could install asciidoctor if you wanted to silence those particular warnings, but the lack of GCC atomics is something that is an aspect of your environment.  The \"failure\" here is completely normal.)\nThe warnings in chunk.c and stacasestr.c should be fixed, but at the same time they should be harmless.. The .c is included intentionally.\nOn Mon, Oct 23, 2017 at 2:22 AM bou6 notifications@github.com wrote:\n\nBy having a look at the tests/term.c I have noticed that the source file\n../src/utils/thread.c is included instead of the header file\n../src/utils/thread.h.\nIncluding the header file results in linking errors, is it made\nintentionally or this is a bug ?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/921, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfehvGGYdty5UD5iLXCC3YAUBVb9Gks5svFrFgaJpZM4QCiPe\n.\n. I am pulling in a private bit of implementation that is not normally\nexposed. It is just for this test and not something normal apps should ever\ndo.\nOn Tue, Oct 24, 2017 at 2:05 AM bou6 notifications@github.com wrote:\nOK, why exactly ? could you please explain further\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/921#issuecomment-338924556,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfU82uWsBSfbGHUCpXZqxY82vpb2_ks5svahVgaJpZM4QCiPe\n.\n. So you should not use the tests directory to learn how to use the API -- look in the demo/ directory instead.   We do stuff that is non-good in tests/ because we have to test \"internals\", which is something ordinary apps don't have to do.. I've spent a bunch of time trying to fix this, the problem is close() doesn't wake things up, and we can wind up having sockets stuck in poll() when we close.\n\nI've tried switching to a condvar / mutex scheme as well, but I'm having trouble with some deadlock conditions in that case as well; I think the problem is that this interacts poorly with the state machines and contexts associated therein.  Simple retrofits of a new strategy don't work well.\nI may wind up implementing a global poller that wakes all sockets when socket conditions change.  This may be the only way to properly cope with this.. Sorry, I mean wakes \"all sockets\" when any socket is closed.. Good news... I found a simpler fix.\nWe just needed to defer the close of the event file descriptors until all outstanding user operations have completed, and fortunately we already had a hold/release mechanism to give that to us. \nI was also able to simplify the poll() logic quite a bit.. This has no content, and is probably the result of an unintentional PR submission from merging back to upstream.  Closing.... So, you're right ... we should be using the overlapped Internal, not the entry's Internal field.  Further we should be comparing it using the NT_SUCCESS macro.  Other status codes there make no sense.\nHaving said that, I'd like to know more about your test environment; these failures have not reproduced for me, but perhaps I'm missing something.  Do these reproduce every time, or just sometimes?. So I've tested both 32- and 64-bit with Visual Studio 15 CE (2017) and cannot reproduce this problem.  Is this sensitive to the number of processor cores you have available?  What platform are you on (x86, amd64, arm?)\nIt clear does seem like a bug, but in trying to characterize it reproduction steps would be helpful.. So it looks like an error during accept occurs, although I cannot repro it myself, it makes sense.\nI'm going to try to fix it, we'll see if I have any luck.. So the comments about the Internal field are ... kind of unrelated.  I'd like to fix that too, but the right answer means we need to use GetOverlappedResult(), which means we need the handle to the file / socket that the overlapped I/O was performed on.  We don't have that in this context, due to insufficient design.\nFixing that problem (which is one of pedantic correctness it would appear) is a bigger effort than its worth at this time -- given that nng is on the horizon and doesn't suffer from this.  (nng's Win32 layer was developed from scratch adhering to the Win32 developer docs on MSDN.)\nFixing the problem caused by an aborted accept() is something we can do though.. So I don't understand the purpose of the changes in the development-bindings.html document.\nI also notice -- and this isn't your fault -- that most of the docs got updated dates, but that's the only thing in them that change.  The build script is just too dumb at present and I have a fix in mind (that I'm using in nng actually) to fix that work flow.\nIn the meantime, I'd appreciate it if you could resubmit with only the README and gettingstarted/index.adoc files.\nIf that's too much trouble, I can cherry-pick and clean the PR myself.. nn_term is one of the more ill considered parts of nanomsg. i will look at\nit but i would really advise to just not call it all, or only do so via\natexit().\nOn Sun, Oct 29, 2017 at 5:11 PM Nick Desaulniers notifications@github.com\nwrote:\n\nin nickdesaulniers/node-nanomsg#182\nhttps://github.com/nickdesaulniers/node-nanomsg/pull/182, I'm trying to\nupgrade to nanomsg to 1.1.0. We currently have one test failing:\nhttps://github.com/nickdesaulniers/node-nanomsg/blob/master/test/standalone/term.js\ntest calls:\n\nnn_send\nnn_term\nnn_close\n\nWe wrap the nn_send to be async, so it seems that nn_term runs first, then\nwhen the send call is invoked abort is called. calling nn_close before\nnn_term prevents the abort.\nI noticed that nanomsg/tests/term.c doesn't test this case, but maybe\nthere is a more elegant way to fail than aborting the caller?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/926, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfTKZH_NXwLjzX4iqoJ7GFFwfjnSjks5sxRQkgaJpZM4QKif6\n.\n. Lol.  Glad you figured it out.. So the problem is that the node code is probably not terminating the strings with a zero byte.  That's perfectly reasonable.  Many languages do not treat \\0 specially, and frankly its better that they don't.\n\nYou need to look at the received packet, and the length.  E.g. if the packet received contained 'H', 'E', 'L', 'L', 'O' and was 5 bytes long, then the receive buffer might contain any random byte at the sixth position.  (It is statistically likely that this will be zero pretty often, but that's an accident of fate, rather than a design.  The bytes after the last byte of the message are \"undefined\", and can be any value.\nThis is a common point of confusion; you can solve this by allocating a scratch area (if you need), and then copying \"length\" received bytes into it, and then adding the \\0 at the end afterwards.\nIf you control the sending side, you can also have it append a \\0 into the payload on send.  That may feel awkward though, and I don't normally recommend it.\nThe better way is simply to limit what you look at to the length that was actually sent.  If you're dealing with JSON payloads for example, the JSON framework might not require the string be NUL terminated -- you might be able to give it a length.  For example cJSON has an API called \"cJSON_ParseWithOpts() that allows you to indicate whether a NUL byte at the end is required or not.  json-c has one called json_tokener_parse_ex() that lets you specify the length of the incoming buffer.\n. Ok I will review.... As far as adding thread sanitizer to this project -- no, I don't think so at this point.  I'm trying to limit the new work being done here.\nI still don't really understand the point of all this trouble ... the existing code worked (admittedly the tests were racy, but at this point fixing those doesn't improve the quality of the code for the project at large.)\nIts very likely that there won't be a follow up \"release\" of nanomsg for this code to be integrated into, as well (because I'm focused on the next generation project) -- i.e. this is in sustaining mode only, and absent another more serious problem, there probably won't be another release.. The larger question I have here -- which why are we bothering with this -- still stands.. I'm closing this -- there is no compelling need to adopt the \"new\" GCC'isms for atomics, since the old ones aren't going away, and there are other concerns with this change set.. Looks good.. This bug is annoying, but not very critical.  Applications don't call this in a loop, so the leak which occurs is not one that continues to grow.\nTo be honest, given that nanomsg itself is in sustaining mode, I'm probably not going go fix this. \nIf a similar problem were found to exist in NNG (github.com/nanomsg/nng) I would take that much more seriously.. I am thinking that this is suspicious:\nnn_send(sock, buf, strlen(buf), 0);\nnn_freemsg(buf);\nI'd rather see you pass NN_MSG as a flag to nn_send, and let nn_send release the message.\nHaving said that, I believe that nn_send should work fine the way you've written it, just with extra data copies.\nYou do have a different problem there though, and that is that you are assuming that the message is ZERO terminated, and yet your reply indicates that you are not sending the terminating NUL byte.  E.g. You need to use strlen(buf) + 1 if you want the zero byte included.\n(If the zero byte was not part of the message you received, you might find that strlen does something very unexpected, giving an impossibly large length.\n. Having said all that, I'm skeptical that this could be the source of any problem.  We're getting an error from Windows recv() function, and the error isn't one we expect.  I'd sure like to know the actual value of that error code.  Can you put a printf() in the efd_win.inc file just above that line, that prints the error code?. BTW, as a workaround, you can probably just comment out that assertion check ... it should be harmless, but I really want to understand why our assumptions there are wrong.. So 10054 is the same as ECONNRESET.  The remote side has reset the connection.. This is the file descriptor I use for signaling.  Probably we can just ignore it.  I'd remove the assert.. This has been low on my radar for a while, partly because I'm pretty focused on the new style nng library.  I will have a closer look at this though.\nOne thing that stands out to me is that the current code (and your changes to it) rely pretty strongly on Travis CI-isms in our build.  I'm pretty sure I want to move away from Travis for most things (its just gotten too unreliable), which really means I need to decouple our build from Travis as much as possible.  (We are looking to move to Circle CI.). So I've taken a different approach, with fbcd0616f54596020819782ddc257482f4f5f62a \nI agree that having CMake for the demos would be useful, and I'll endeavor to make something based on your work, but using the current CMakefiles.. I'm creating a demo/CMakefile similar, but different what you did, to make it easier to follow:\n```\n\nDemonstration CMakeLists.txt for nanomsg demos.\n\nThis file shows how one might use nanomsg from a another project\nthat is also CMake-driven.\n\nThanks for the idea goes to @maddouri.\n\ncmake_minimum_required (VERSION 2.8.7)\nproject(nanomsg-demo)\nCall this from your own project's makefile.\nfind_package(nanomsg CONFIG REQUIRED)\nadd_executable(async_demo async_demo.c)\ntarget_link_libraries(async_demo nanomsg)\nadd_executable(device_demo device_demo.c)\ntarget_link_libraries(device_demo nanomsg)\nadd_executable(pthread_demo pthread_demo.c)\ntarget_link_libraries(pthread_demo nanomsg)\nadd_executable(pubsub_demo pubsub_demo.c)\ntarget_link_libraries(pubsub_demo nanomsg)\nadd_executable(rpc_demo rpc_demo.c)\ntarget_link_libraries(rpc_demo nanomsg)\n```\nI think this is clearer than the macro/loop driven one you wrote.  As the purpose is to make it clear how to use CMake, I think this is the better option.  I'll be submitting a separate PR with that change.\nI'm closing this one for now.. I need to think about this somewhat.  The problem with arbitrary non-initialized states is that they need to be protected against concurrent threads access; historically we've taken the view that the lack of a standard way to statically initialize a lock on some platforms was a stopper to handling this sensibly.\nIn retrospect, modern platforms (Windows Vista and later for example) and POSIX do offer static lock initialization.   Dealing with \"other\" platforms is not really all that interesting anymore for nanomsg.  So maybe its time to just address this properly.\nHaving said all that, I view nn_term() as a dangerous API, and I would discourage it's use.  The only realistic use for it is cleanly release resources in an application just before exit(), because you want to avoid false positive from resource leak detectors.  Outside of that one case, there is no other real need to ever call nn_term(), and doing so in a library can be destructive to other library consumers or the application itself.\n(Problem here is that we don't have a matching \"init\" to \"term\" behavior, so reference counting won't work.  This is a design defect in the original API.)\n. The only time to call nn_term really is atexit().  Or possibly, if you're unloading the library (and are certain that there are no other library consumers.). Good news, we have nn_once already.  So the fix is easy.. If the socket is opened using a DNS name, and the server side (bind side) closes the connection, then the clients will automatically attempt to redial to the server using that name, which can return a different IP address.\nAlternatively, if you know in advance that you have multiple possible IP addresses, you can set the clients to dial them.   This way they will automatically be connected to the different IP addresses.\nToday there is no way for a server to tell the client it is going to change IP addresses.  This is actually very atypical, and given the reconnection properties we already have, not really needed.\n. This  is a question, not a defect or feature request.  Closing as such.\n. You cannot issue fcntl's on nanomsg sockets, as they are not real operating system sockets.   Under the hood nanomsg uses nonblocking operations on the sockets and file handles/descriptors that it uses.\nAs mentioned above, you can select non-blocking operation with NN_DONTWAIT, but I'd recommend instead using nn_poll() to check for socket readability (or if you need to interact with other polling loops you can obtain a magical file descriptor by using the socket options for NN_SNDFD and NN_RECVFD.  These file descriptors will become \"readable\" when the underlying socket can either send or receive without blocking.\n. Please also feel free to ask questions on the mailing list.  We try to use the issue tracker only for tracking defects and feature requests.\nClosing this.. I assume you're referring to the use of the inproc transport.  The problem here is that as you notice, there is some global state, and when you try to share state, it doesn't work properly.  Code running with one instance of the library has no awareness of the presence of the other instance.\nThe idea of offering an API for applications to supply their own state is not a bad one.  If you want to come up with a PR for this, I'd be happy to review it.. I'm pretty sure at this point that I would not be accepting a PR for this kind of change for legacy libnanomsg. \nI've also been thinking about how to do this for nanomsg and nng in general.  Really the only thing I can come up with is some kind of socket descriptor (using socketpair) and a custom handoff protocol.  This is a significant enough amount of work that I really would rather not deal with it.  Making this work correctly across multiple instances of the library is going to be very tricky to say the least.\nIn the short run if you have to pass state like this, you should use the IPC or TCP (with loopback) transports.. Ok, I'm just going to close this -- there is no way that I'm going to support having separate instances of the shared library talk to each other except via some external transport (TCP).  Its impossible to do anything else safely.. So I have no experience with the new Windows OneCore.  I'm pretty sure we do a few things (abort() for one!) that may be problematic on that platform.\nI suspect libnng may be closer to what you need there..... I'd need more information here... but I think UWP prefers static linking -- you would need to depend on the same libraries, but I believe they are available for UWP.\nInitial attempts to build seem to work reasonably well for NNG at least.  I've not tested nanomsg building.. Can you provide more information about the errors, and how you've built it.  I don't have sufficient information to proceed.. I'm closing this due to lack of feedback.  In any event, if you're using UWP, you really should be using NNG at this point.  I'm really not interested in enabling new platforms for the C API of legacy libnanomsg.  (If you need it on a platform because you need support for a language runtime, such as python or java -- then we should talk more.). I haven\u2019t looked at your code but unless you use raw mode you must reply to\neach request before receiving a new one. In other words this is strictly\nsynchronous. You can use multiple threads if you observe this limitation.\nRaw mode will let you bypass this but then you must take care to save the\nheaders from the requests and include them in the replies. Those headers\ncontain the routing information to get the reply back to the requestor.\nI believe you can look at the asyc demo or the thread demo in the demos\ndirectory for examples of how to do this.\nOn Fri, Jan 19, 2018 at 4:12 AM tleacmcsa notifications@github.com wrote:\n\nDang, ok. Thanks.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/942#issuecomment-358948978,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfTIXFBF-DSocmlr78JNDkJTMaWKDks5tMIaRgaJpZM4RjE5r\n.\n. Yep, I just looked at your code.  You're reusing the client socket (which was not what I expected, btw).  Just give each client it's own socket.  (You can also use raw sockets if you want to share, but you have to do the work to match replies to requests yourself, and frankly its easier just to give each client it's own socket unless you have some unusual circumstances.)\n\nThis is not a nanomsg bug, so I'm closing it.. nn_recv() shouldn\u2019t require a trailing nul byte.  HOWEVER, the wss protocol\nexpects that each message is contained in a complete websocket message.\nThe legacy nanomsg code probably cannot deal with fragmented messages\neither.  (The new code in nng can however.)\nHaving said that, its a common mistake in application programs to assume\nthat messages are null terminated, and that you can just printf() the\ncontents.  If the sender doesn\u2019t send a null byte, then they aren\u2019t, and\nthe receiving program will need to add a final NUL byte if is expecting to\nwork with C strings.  (This is most often a problem for people coming from\nother languages, where NUL terminated strings are not used, but instead the\nstring is some kind of language construct with an explicit length.)\nSo, my guess is that this isn\u2019t an error in your javascript, nor in nanomsg\nitself, but in your C program which may be making false assumptions about\nmessage content.\n\nGarrett\n\nOn Mon, Jan 22, 2018 at 11:38 AM brian crabtree notifications@github.com\nwrote:\n\nSolved.\nnn_recv() gets confused if the message doesn't have a trailing \\0\nThis was a problem with the javascript, so whatever server is used at\nwss://echo.websocket.org doesn't care about \\0\nThank you and sorry for the noise.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/943#issuecomment-359540252,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfUvwpJvK6wIsfCebz1yWALlyyO5Bks5tNOO_gaJpZM4Rodk8\n.\n. This is absolutely the case now that I read the code.  You need to use the \"result\" to determine the actual length that was sent, and not assume that strlen() is usable.\n\nHere's modified code which should work:\nint echo(int sock)\n{\n  char *buf = NULL;\n  int len = nn_recv (sock, &buf, NN_MSG, 0);\n  if (len > 0)\n    {\n      printf (\"RECEIVED \\\"%s\\\" len: %d\\n\", buf, len);\n      nn_send(sock, buf, len, NN_MSG);\n      printf (\"SEND \\\"%s\\\"\\n\", buf);\n    }\n  return result;\n}\nYou'll note that I am not using strlen at all, but instead am using the length of the received message (strlen will lie depending on the contents of memory).  While here I also used NN_MSG in the argument to nn_send, so that we don't need to explicitly free the message.  This also avoids an extra data copy, so its more efficient.. so the cmake command to use really depends on whether you are using studio\nor some other generator. its pretty annoying in that regard.\nI will review the docs again.\nOn Tue, Jan 23, 2018 at 6:18 PM xuanwolanxue notifications@github.com\nwrote:\n\nIn the document of README.md, in section \"Quick Build Instructions\" for\nwindows, the command of\n\"ctest --config Debug .\" is wrong, the ctest command haven't parameter of\n\"--config\", it should be replace with \"-C\" or \"--build-config\".\nNote: my cmake version is: 3.10.2\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/944, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfQQh-jTK7SWIC2hzc8QErA1iwbRAks5tNpMOgaJpZM4RqnoO\n.\n. You could use req in raw mode. Will be hard because you would need to know\nwhich pipe id is associated with which client. Alternatively you could\nprobably use nng and the new polyamorous mode for the pairv1 protocol.\nFinally you could just open separate sockets for each client but then you\nhave to keep track of them so that might not be practical.\n\nActually you might want to check out the surveyor pattern.\nOn Thu, Jan 25, 2018 at 6:54 AM douglascordeiro notifications@github.com\nwrote:\n\nHi, I'm having trouble in chossing the right type pattern which I should\nuse.\nI need to connect several clients(100 - 10000) to one server.\nThe server needs to send information to individual clients and those\nclients should reply(or not) to the server.\nI don't find any pattern that do that in the documents.\nI could use REQ/REP + PUB/SUB, but PUB/SUB is no use for me as it send\ninformation to all connected clients and this generate absurd network\nbandwidth usage.\nAny help?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/945, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfcR6VEcxJOdsj0qFOFSBQB2-EvG-ks5tOJWcgaJpZM4Rs97s\n.\n. Thinking about this some more, I think raw mode with \u201clong polling\u201d might\nbe the right answer.  Its a PITA, and will complicate your server design\nsomewhat, but I can\u2019t think of anything else that is both easy to do, and\navailable in nanomsg.   If you use nng there are a number of other options\nyou can explore, since then we have pipe IDs that are available, although\neven then some functionality (planned) is missing from nng.  (Basically you\nneed a pipe connection establishment callback so you can pick up the pipe\nid without having to receive a message to get it.)\n\n\nGarrett\n\nOn Thu, Jan 25, 2018 at 8:00 AM douglascordeiro notifications@github.com\nwrote:\n\nKeep a track on each client is not a issue for me, I would need to do this\nanyway as this system will work with subscribe. But How I get pipe id in\norder to do the association and then call the send for a specific pipe?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/945#issuecomment-360511282,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfY7sj3dUVtUQdwz9-uMprapAKPwTks5tOKUjgaJpZM4Rs97s\n.\n. This was a question, not really a bug or request for new functionality.. http is \u201chard\u201d and the websocket in libnanomsg is a toy that cannot easily\nbe extended for generic http purposes. Having said that libnng does have an\nhttp client in that is pretty functional but the api is not public (yet). I\nexpect that to be resolved by this time next week.\nOn Thu, Jan 25, 2018 at 10:34 PM Wenqi Chen notifications@github.com\nwrote:\nI know that nanomsg can use TCP as a transport. Is adding an extra layer\nof http parser enough to make it an http client?\nWebsocket support is appreciated, which means that handshake code is\nalready in place. I just would like to know whether http parser is the only\nmissing piece?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/946, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfZMrUxI_xxCB3FUBli80UNWBDJ9Jks5tOXIIgaJpZM4Rt6Oi\n.\n. the docs are correct.\nOn Thu, Jan 25, 2018 at 10:38 PM Wenqi Chen notifications@github.com\nwrote:\nwhen sending fails (nn_send) with EAGAIN in non-blocking mode, does all of\nthe message or part of the message needs to be resend?\nDoc says either it is successful and nsends == nsends_requested, or -1 is\nreturned.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/947, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfWrVnXyPWLft8HIb7cvas8gpLVSXks5tOXL0gaJpZM4Rt6YL\n.\n. I will have to look at this later.  I'm pretty sure that the new library, libnng, does not suffer from this.. So I'm looking at the code, and not spotting anything.  I'll have to debug this at run time.\n\nOne thing that stands out is that the eventfd logic in legacy libnanomsg is kind of silly, requiring a global lock on a well-known low-numbered port to set things up.  In libnng we used a different approach.  I'll note that in a separate bug.. WIth the integration of 19e01dcaf1afda031143ae171d8eeadd0c49fee1 it's likely that this was fixed.  Submitter, can you please double check.. Good catch.  This only affects windows because other platforms don't have to allocate resources to create a semaphore.  One of these days I'll figure out how to properly catch this kind of thing on Windows (meaning I need to learn to use the capabilities present in Visual Studio I guess -- or figure out how to get the sanitizers working on Windows.). I've pushed this change into master.  At the moment I have no plans for another nanomsg release, but if I ever do this change will be in it.. I need to research this a bit more.  It may be appropriate to do the same thing for nng btw.. @lilianmoraru Huh?   I don't see any explicit additions of -pthreads in these CMakefiles, instead we use  find_package(Threads REQUIRED) which I thought was the correct way to do this for CMake.  I don't know how that is supposed to work with layered dependencies and CMake, admittedly.. So you've disconnected the socket in an unpredicted way.  Some of those sockets may be for the notifications that nanomsg sends itself, and it does not expect to ever have closed.  I could see that causing panics or assertions in the code.\nTo debug this more fully I'd need to see the actual abort output which should include the assertion message and line number but may require building a debug version of the library.  Can you do that?. yes that would be better. but since the \u201cpeer\u201d is the same process the\nconnection should not ever normally close prematurely.\ngiven that i have moved most of my development effort to nng and that this\nerror is not something that would ever occur under anything like normal\nconditions, i probably will not be investing the effort to fix it.\nOn Thu, Feb 15, 2018 at 4:50 AM acviex notifications@github.com wrote:\n\n@gdamore https://github.com/gdamore You're right. The cause of runtime\nerror in this (Windows) case is\nwsa_assert (rc != SOCKET_ERROR); in function void nn_efd_unsignal (struct\nnn_efd self) in file efd_win.inc. This assert makes Windows to finish\napplication, because rc = 10054 or connection reset by peer*. I think\nthe better solution for this situation is recreate connection instead\nkilling application.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/950#issuecomment-365917939,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfSRS93Ks3wkJn-MOHdrH35uU4ap2ks5tVCgCgaJpZM4R8Pxk\n.\n. It is astounding to me that anyone would expect that closing random tcp\nsockets would NOT break applications.\n\nI will think about this. The only reason we use this socket is because\nwindows only supports TCP/IP sockets with the select() function.\nOn Thu, Feb 15, 2018 at 8:06 AM arencour notifications@github.com wrote:\n\nUnfortunatly for users it is normal conditions. Their other applications\nsometimes close these internal connections. We recommend them to remove\nsuspicious application, but sometimes such applications not found in the\nlist of installed programs.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/950#issuecomment-365974617,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfUtOVAMlW2Wi2YH7cx-1tCWrWIqhks5tVFYZgaJpZM4R8Pxk\n.\n. Unfortunately, while I could fix the underlying panic, the fact is that closing the underlying TCP connection is going to cause bad breakage.  We rely on the file descriptor for notification, and closing and reopening will change the file descriptors used, causing the application to fail in other ways.\n\nIt might be possible to reuse one side (the connect side) by issuing connect again, but I'm not sure if Windows allows socket descriptor reuse in this way.  The server side can't be done, as accept() always returns a new socket descriptor.\nYou need to instruct your users to cease closing sockets that they do not recognize in this way.  It is unreasonable to expect all applications to survive random attempts to rip out connections that they believe are fully under their control.  (It would also be unreasonable to expect them to survive deletion of databases they have exclusively opened, removal of their named pipes, or unmapping of shared memory regions.  It would also be unreasonable for them to expect an application to survive loss of power.  Yet an administrator can do any of these things.)\nI would be willing to contemplate ways to cause a specific port number to be used (right now an ephemeral port is used, and acquired exclusively -- this should be a random port number assigned by the system) or possibly to convert the code to set up an IPv6 socket instead of an IPv4 socket (although I'd want to confirm that Windows systems we support always have the ability to create an IPv6 loopback socket) -- but those are hacks to just \"avoid\" whatever crazy stunts your users are pulling with aborting sockets that they have no business messing with.\nIn the meantime, no, I won't be fixing this \"bug\" -- because it's not a bug; its a failure of the application to survive unreasonable administrator actions, and the solution is to stop doing those unreasonable actions.  (If its an application that is doing this without the user's consent, then the application that is doing it is buggy, and should be fixed.)\n. The problem here is likely the NN_RCVMAXSIZE option needs to be set -- it defaults to 1MB, and nanomsg will reject messages larger than.  You can set this option with nn_setsockopt(), and if you set it to 0 then messages of any size will be accepted.\n(The reason for this option to exist is to prevent denial of service caused by remote parties... they could for example ask for a 2GB file, and nanomsg would try to allocate that RAM to hold the incoming message.  They don't even have to send the actual data at that point, making a DoS attack pretty easy without this kind of protection in place.). Can you please describe whatever the problem is that you think you're fixing with build.sh? . Well, I wish you had asked me in advance.  I'm not really happy to have a ruby build script, because I don't actually know ruby.  As the person who will use or modify this script more often than anyone else, I can't really support this.  (Yes, I know that asciidoctor itself is a ruby program.  But I don't have to modify that.)\nI don't want to have to learn Ruby just to update the documentation.\nBuilding the documentation on Windows is not something that I ever need to do.. Furthermore, I just ran the build script under Ubuntu Linux, no problem.  I passed it to bash.\nYou do need to be aware that on Debian Linux, \"/bin/sh\" is not bash, and is not ksh.  So it lacks the \"[[\" built-in command.  If you call it as \"bash ./build.sh\" it works fine.  (It turns out that \"[[\" is not part of the POSIX shell specification -- something I didn't realize.  Making it use \"[\" instead of \"[[\" (and also changing \"]]\" to \"]\") would solve the portability problem, although it's really a complete non-issue.\nI'm closing this PR (rejecting it).\n. I've rewritten the script to be portable.  I've also verified the results.\n. I'm not aware of any specific efforts.    That said, it looks like it would be fairly straight-forward.  There is an example for zeromq that could probably be easily modified for nng or nanomsg.\nI'm not sure what criteria the curators of the vcpkg ports tree use to determine whether a package should be included or not.  Maybe they just accept any PR?. https://github.com/Microsoft/vcpkg/blob/master/CONTRIBUTING.md seems to cover it reasonably well.. Not going to do this for nanomsg.  But how about NNG?. You need to have cmake installed \u2014 I guess it isn\u2019t in the $PATH on travis\nby default?\nOn Fri, Feb 16, 2018 at 7:06 PM Bernardo Ramos notifications@github.com\nwrote:\n\nHi!\nDoes someone know why the build instructions are failing with travis CI? I\nam using the exact steps informed here, and it used to work before.\nHere is the command and the error:\n$ sudo cmake --build . --target install\nsudo: cmake: command not found\nHere is the complete log\nhttps://travis-ci.org/litereplica/litereplica/builds/339751563 and the\n.travis.yml\nhttps://github.com/litereplica/litereplica/blob/master/.travis.yml file.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/955, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfcS0v_1BZMOrp-wFiNV9nyu1Y0LEks5tVkIjgaJpZM4SJKjG\n.\n. ah. another arbitrary breaking change by the travis team. honestly I am\nless and less satisfied with travis and have been moving stuff to circle ci\nas I find time to do so.\nOn Sat, Feb 17, 2018 at 7:27 AM Bernardo Ramos notifications@github.com\nwrote:\nI found that it is related to this issue:\ntravis-ci/travis-ci#9113\nhttps://github.com/travis-ci/travis-ci/issues/9113\nSo intead of\nsudo cmake --build . --target install\nwe must use\nsudo -E cmake --build . --target install\nor\nsudo env \"PATH=$PATH\" cmake --build . --target install\nBut only the last one worked.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/955#issuecomment-366448429,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfQCdxnBd2ovSwgtk0b7aDNJK79Oaks5tVu_IgaJpZM4SJKjG\n.\n. So if you take a look at my .travis.yml, you'll notice that I'm not using sudo.  This is a problem with the installation of cmake on Travis (it isn't in root's path, but it is in the default user's path), and nothing I can do about it - -this isn't a nanomsg issue at all.\n\nI generally do not recommend even using sudo or root privileges -- nothing in nanomsg specifically requires it.. I'm not sure if I'm going to fix this or not.  Its clearly an ugly bug, but at the same time I'm trying to get NNG released.. I recommend using NNG... its hardened against bad network protocol stuff.  nanomsg is a bit more brittle here.. Marking this a release stopper -- we should not cut a release without fixing this, since its a potential hard hang, security issue, and generally fragile approach.  Only Windows is impacted.. You might want to give libnng a crack.  I suspect it may work more easily.  See github.com/nanomsg/nng -- yes its pre-release, but I'm quickly pushing towards a 1.0 release.\nNow having said that, you should have pthread support on Android, so probably something just needs to be done to help ensure that the software can see it.  What may be necessary is to make the Android CMake stuff behave like Linux.  (-DNN_HAVE_LINUX).   My guess is that if you can arrange -DNN_HAVE_LINUX then it will all \"just work\".. Ok, reading the NDK, it's just Linux with an abbreviated set of compatible libraries, and a custom libc (bionic).  The libc appears to support the necessary things we need, including pthreads APIs, epoll, and eventfd.  So it really should just be a matter of duplicating the Linux logic in the CMakeLists.txt to apply to Android as well.\nI don't have an NDK handy to validate this with, but if you are able to do so, I'd be happy to accept a PR.. I wonder why that didn't work with Android.  I wonder if the CMakeLists checks (which include linking against -lpthread, which appears not to be supported in modern NDK) are somehow breaking.  One idea might be to add a check for nn_check_lib(c sem_wait NN_HAVE_SEMAPHORE_C), and then add that case for the add_definitions (-DNN_HAVE_SEMAPHORE) check below.\nEssentially I think you need -DNN_HAVE_SEMAPHORE\nWith respect to NNG, NNG is quite compatible with nanomsg. \nIt offers:\na) Wire compatibility.  Every protocol that nanomsg supports, NNG does.\nb) API compatibility.  Every (or nearly so!) nanomsg application should be able to be compiled against libnng, only adjusting the include location and link library.\nc) ABI compatibility (some platforms).  On some systems, its possible merely relink a legacy nanomsg app against -lnng instead of -lnanomsg (e.g. via LD_PRELOAD).\n. I'm not familiar with Unity, but I know that there is a .net effort in progress.. I can probably knock this out today if there is need (meaning if you still want old nanomsg instead of NNG.). As I'm already doing a release for 1.1.4 to address a new bug, I'll probably roll this into that release.. I think you're running into some core scaling problems in legacy nanomsg.  It has just a single backing thread for processing, and so all those other threads are just contending on resources and waiting for the single processing thread to run.\nI'd be interested to see if NNG behaved any differently.\nOne thing I'm planning to do soon is release a different model for concurrency that should work far better, with a simpler model and hopefully a much higher level of attainable concurrency.  That should be posted in the NNG repository this week.. At any rate, while nanomsg is intended to be thread safe, it is intended to be particularly performant in this mode -- it was never designed with this as a primary use case.  I hope that you will find better results with NNG.  (That said, we know that there are some scalability limits in NNG due to contended locks, etc.  I'm working on fixing those.). For now I'm going to close this.  Please let me know on the NNG repo about your results there.. This isn't a bug, although perhaps the example in the man page could be clearer.  (The man page example is not an example of a complete program.) \nIf you look in the demo/ directory the examples there (specifically the pubsub example) do include a bind.\nThis should make sense intuitively -- without a bind (or a dial), how would a pubsub socket know what address you wanted it to use?\nI may go ahead and add a bind statement in the pubsub man page just to make it clearer.. not for the protocol but there is a default limit of 1 MB to protect\nagainst DoS. unfortunately nanocat doesn\u2019t have a command line option to\naccess the setting to change that (NN_RECVMAXSZ).\nOn Sat, Apr 7, 2018 at 8:03 AM songmaotian notifications@github.com wrote:\n\nI am trying to send a file in 18MB\n./nanocat --pub --bind tcp://*:1200 -F bigfile --interval 1\nbut can't receive the file\n./nanocat --sub --connect tcp://127.0.0.1:1200 --ascii\nIs there a length limit for the protocol?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/961, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfVVoZuWaUFi9K85rfXdJoPicO-kVks5tmNUsgaJpZM4TLHaE\n.\n. Sounds like a bug, but also probably you are using the wrong type.  Size in this case must be of type \"int\".  Is that the case for you?. I'd also like a backtrace from the segfault, so I can see where it failed.. Submitter, ping?. So, if you're sending or receiving large data, you have to be aware that nn_send can unfortunately block.  This is an unfortunate consequence of the fact that nanomsg does not provide any buffering, so there is no separate thread to do the send, instead it just steals the context from the calling thread.\n\nFor small messages this isn't a problem, since we can usually send or receive a full TCP segment at a time (or a some amount of chunked data for an IPC pipe).  The problem is that when your data size is larger than a TCP segment, we can see poll() tell us it's ready for data, but so we start an operation, but it can't complete all the way.\nIf the operation was done with a non-blocking operation, then this will ultimately return a partial completion followed by EAGAIN.  If it was blocking, your application will \"hang\" until the operation completes.  If the other side is slow to receive and ack the data, this can lead to a complete stall.\nThe nng project (github.com/nanomsg/nng) offers an API that is compatible with libnanomsg, but has a very different internal architecture, that should be immune from this problem.  I recommend you give that a try.. I'm going to close this for now... no feedback from the original submitter.\nUltimately, I recommend giving NNG a shot.. I'm also wondering, but haven't looked, if nanocat has any internal limitations on the message sizes.  The nngcat that ships with NNG program does not, and I've tested it with larger buffers -- say 10MB, without problems.. This is expected given that you're using REQ/REP incorrectly.  Specifically, you are sending messages then not receiving the reply before sending another message.  This is treated as \"cancellation\" of the request, and, if a message has not yet been set (e.g. because of flow control or backpressure) then it is simply discarded.\nThe assumption here is that if you send a message on REQ, you no longer have any interest in the prior request, and its better not to send any earlier requests to avoid wasting effort on work that is no longer needed.\nUnfortunately, this is documented in the Request/Reply RFC and not in the nn_reqrep.7 manual page.  (In fact, the old nanomsg manual pages leave a lot to be desired... we've completely rewritten them for NNG.)\nAnyway, if you want to send a lot of unidirectional messages without losing any, try the AF_SP_PAIR protocol.. I'm closing this, because nanomsg is behaving as intended in this case.. I take it you are using Windows?\nI don't know if abort() is meant to function in the way you mean on C#.  For C programs it just sends SIGIOT or SIGABRT to the calling program, which should cause it to crash.  User programs should not normally ever call abort().  Maybe this is different and a different abort() in C#?. I'm not sure what Thread.Abort() does, but the underlying nanomsg library is written in C, and will of course remain blocked in the code unless you close the socket, that's normal -- you've issued a blocking call.  The same behavior would occur in C with a thread.  If you want to have an interruptible read, you might consider combining nn_poll() or using select() or poll() with the descriptor given by NN_OPT_RECVFD, and using a non-blocking read.  You can use a second descriptor to signal a wake up on the polled descriptor list.\nFor the future, NNG will offer a more elegant solution using callbacks.\nI don't think you should Abort() the receiving thread at all.  GIven what you're doing, closing the socket should be sufficient.\nNow having said that, I'm not familiar with the C# wrapper for nanomsg.  If close() does more than just close the underlying socket (such as deallocating some wrapper structure), then its possible that this could cause an assertion.  That would be a defect in the design of the C# wrapper library -- its important that close of the socket not be tied to destruction of the socket unless there is some kind of reference counting in place to ensure that deallocation does not occur until all outstanding operations have terminated properly.. So, CMAKE_TOOLCHAIN_FILE is fairly standard.  I don't think we need to provide this, anyone cross compiling other cmake driven software should already know how to deal with this.  (The reason not to do this ourselves is that if CMake changes in the future, or if people want to support other cross-build environments, then it gets into a very slipper support slope.)\nI think its sufficient to merely state that we don't do anything magical for this,  that use of the CMAKE_TOOLCHAIN_FILE as documented on the CMake wiki is known to work.. This already exists in mangos.  See https://github.com/go-mangos/mangos/tree/master/transport/ws. Closing since this is resolved.  Its also the wrong repository for a mangos issue! :wink:\n. Thanks, I\"ll take care of this.. I guess maybe nanomsg itself isn't installed here?  I haven't really spent any time with the C++ version.. That is the event file descriptor. You should not be modifying that code.\nNor should you close the descriptor (nn does it at termination as part of\nnn_fini). Doing otherwise can lead to this kind of error.\nOn Fri, May 18, 2018 at 3:37 AM zhangjunjie notifications@github.com\nwrote:\n\n/usr/lib64/libnanomsg.so(nn_efd_signal+0x5f)[0x7fb2489df906]\n/usr/lib64/libnanomsg.so(nn_worker_execute+0x47)[0x7fb2489de53a]\n/usr/lib64/libnanomsg.so(+0x16141)[0x7fb2489da141]\n/usr/lib64/libnanomsg.so(nn_fsm_stop+0x42)[0x7fb2489d9afb]\n/usr/lib64/libnanomsg.so(nn_timer_stop+0x18)[0x7fb2489da0da]\n/usr/lib64/libnanomsg.so(nn_backoff_stop+0x18)[0x7fb2489ec4f9]\n/usr/lib64/libnanomsg.so(+0x34c9a)[0x7fb2489f8c9a]\n/usr/lib64/libnanomsg.so(nn_fsm_feed+0x42)[0x7fb2489d9842]\n/usr/lib64/libnanomsg.so(nn_fsm_event_process+0x67)[0x7fb2489d97fe]\n/usr/lib64/libnanomsg.so(nn_ctx_leave+0x66)[0x7fb2489d95cc]\n/usr/lib64/libnanomsg.so(+0x1a72f)[0x7fb2489de72f]\n/usr/lib64/libnanomsg.so(+0x1d750)[0x7fb2489e1750]\n/usr/lib64/libpthread.so.0(+0x7e25)[0x7fb25e97be25]\n/usr/lib64/libc.so.6(clone+0x6d)[0x7fb25cc2834d]\nBad file descriptor [9] (/nanomsg-1.1.2/src/utils/efd_eventfd.inc:78)\ni modify the condition...\n[image: image]\nhttps://user-images.githubusercontent.com/17996431/40230544-7b97608c-5aca-11e8-89b8-fe3ed8ef5ec5.png\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/971, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfWmFdB1WJzbELM-0O3pwGNmbjOEFks5tzqRlgaJpZM4UEgqT\n.\n. I discussed this with the original submitter.  I think we discovered that the problem was that a fork-exec situation existed, where the eventfd was closed, but somehow code was expecting to be able to keep using stuff across the fork/exec.\n\nThe other thing is that these file descriptors can be 0 legally.  These are not pointers. \nAgain, I'm pretty sure we dealt with this in private chat.  Submitter, feel free to reopen this if you still think you have unresolved issues here.. We will be cutting a new release to address this particular issue.. Fixed in 4ce84ff95cce0e102dce1873f2ad1b6615a0b13a. I would need more information.  Note that req protocol cannot receive until\nyou have first sent a message.  Attempts to call receive before then will\nreturn an error.\nOn Sun, Jun 24, 2018, 7:53 AM Pooya Eimandar notifications@github.com\nwrote:\n\nHi there\nI want to use nanomsg tcp req/rep for client application and the tcp\nserver used boost.asio.\nI tested server with telnet and worked fine, also nanomsg connected\nsuccessfully, but could not receive message and always returns -1.\nThe socket created with domain AF_SP: and protocol: NN_REQ.\nshould I add specific socket option for nanomsg?\nThanks in advance for helping me on this issue.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/982, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfX2bj9p4fmsEQ0qBhEuUZSNb9Bi8ks5t_6fzgaJpZM4U1Lj_\n.\n. My guess is that you have different instances of the library in memory.  Generally using inproc to communicate between say a Python library and a C++ module won't work unless care was taken to ensure that you have the same instance of the nanomsg library.\n\nThe reason for this is that the inproc registry is a global variable.  Different library instances have different copies of this global variable. \nThere is nothing I can do to fix this in the library; the separation and isolation of one library's global data from another's is something done by design in the system.. This should probably be an FAQ.. Closing this -- it's not an open issue.. My first guess is that there is some endianness bug in the websocket code, since both those tests segfaulted there.  Unfortunately, I don't have any big-endian systems to validate with, having disposed of my last SPARC system some time ago.\nIf you have the opportunity, perhaps you could run the websocket test in the debugger, and send a stack backtrace?\nAlso, are the timeouts in the tcp tests consistent? The nanomsg test suite is fairly fragile, and if things take longer than they should some cascade failures can occur -- those are limitations in the test suite and not in libnanomsg itself.\nFinally, have you tried out nng?  If you're just using the C API for nanomsg, nng (see github.com/nanomsg/nng) represents the \"latest\" generation, and I have reason to believe that it is substantially more robust.  (However, it's also the case that I have not tested for endian safety, so there could be bugs there if I forgot sometthing--- I'm usually pretty careful about such things though.). Hmm... I'd really like to see this, because as I go over the ws transport code by hand, I see lots of care put into ensuring that endianness correct things are done.  In fact, the wire protocol uses big-endian values, and we use macros to convert between native and network byte order.\nAgain, stack backtraces would be most helpful.  Also, what version of nanomsg are you using?  . The TCP timeout doesn't look like a deadlock at all.  It looks like it is waiting for a remote connection.  You don't have any special firewalls or weird configuration that would prevent a loopback connection to port 5555 in place do you?  (Conversely, you aren't already using that port for anything else are you?)\nIts very very telling to me that the TCPv6 test passed and the TCPv4 did not.  It's also very telling that we are seeing problems with both nanomsg and NNG -- because there is no common code between nanomsg and NNG.\nConversely, within NNG the only difference between the TCP6 code and the TCP is that the we use IPv6 addresses (specifically we use ::1 instead of 127.0.0.1.)   Everything else, including all the NNG core code and TCP transport code, is identical.\nThis makes me believe rather strongly that there is something messed up with the TCP stack on your system.\nTell me more about your Solaris 10 system.  Is this running in a zone? Are you running the software as root or as an ordinary user? Do you have an ipfilter configuration that might interfere?  (Normally ordinary users work, but Solaris RBAC can leave things set so that normal TCP connectivity won't work.) Are unusual RBAC settings in play? Are you using any of the Trusted Solaris extensions?\n. This is still really strange to me.  I don't have Solaris 10, but on illumos I don't have these problems.   I'm also on x86.  Still, the fact that reducing the size fixes the problem seems to make it clear that it isn't a problem with endianness.\nOne thing is that our use of poll vs. epoll vs. port events can be impacted, and I wonder if there is a relationship there.  Solaris 10 won't have epoll (pretty sure), and may or may not have working port events.  (Don't remember when that stuff integrated ... and Solaris 10 is not just one thing, as there have been numerous updates to it over the years.)\nIf you have the ability to set up remote access for me to debug this on your system, I'd be happy to help.  Without that I might be stuck.\nIf I get some time, I'll try forcing the poll() based stuff on illumos, to see if that is any more debuggable.. Can you try NNG instead?  NNG has support for port events and should be superior on Solaris.. If you use a protocol that applies backpressure (pair or push) then you can\ndo this.  Your application will block (unless you request non-blocking\noperation) if the other side or the transport cannot keep up.\nYou can\u2019t do this with PUB/SUB, because when you flood too many messages on\nthe wire, it will drop the messages.\nHaving said that, with NNG you could set a very large queue depth, and the\nmessages would be accepted for delivery (queued), and delivered as fast as\nthe far side can consume them.   (See NNG_OPT_SENDBUF.)\nOn Wed, Aug 1, 2018 at 1:16 PM MAXIM PONKA notifications@github.com wrote:\n\nHello, Is it possible to send a large count of packet at a time?\nFor example something like this:\nfor(i=0; i<100000; i++) { nn_send(...); }\nBest regards\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/985, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfe4hAa0b1IPOU1-21dq7iHj4INc2ks5uMgyxgaJpZM4VrK3k\n.\n. Looks good to me.  I will merge it once I verify it. . Thanks for this!  I'm going to take a little bit of time before I integrate it, as I want to make sure I understand what it is doing.  This is another corner of CMake that is heretofore unexplored (by me).. So, nanomsg uses strict SemVer versioning, and the major number would only increase if we introduce changes that break backwards compatibility.  This is something we try pretty hard to avoid, because breaking applications is pretty undesirable.  (In fact, we don't think there will ever be a nanomsg 2.0 -- we have NNG as the replacement for the future, and nanomsg 1.x is pretty stable.)\n\nUltimately, if we did bump the major version, we would want to break automatic configuration because that's a sign that applications probably need to review their usage, because some kind of breaking change occurred.\nTherefore, I will reiterate my request that we use the SameMajorVer approach. \n(Note that projects which don't follow Semantic Versioning should not use that approach.  It looks like MsgPack doesn't really follow Semantic Versioning, and has been a bit loose with breaking changes actually...). I\u2019ll take a look at it tonight.\nOn Thu, Sep 6, 2018 at 10:37 AM Dennis Klein notifications@github.com\nwrote:\n\nAny updates here?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/989#issuecomment-419117678, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDffGwpK1YxETQZLNHKpTdDNjhmMTyks5uYTM5gaJpZM4WPkSl\n.\n. This is a lot of code to digest.  Your front and back are not going to work at all.  The problem is that your server's \"back\" socket is not raw, and so when you receive a second request on the front raw socket and send it to the back, that \"cancels\" the first request that you sent to the database.\n\nA REQ socket can only have one outstanding request, unless it is in raw mode.  (Or with NNG you are using separate contexts, which is what I recommend if you can use NNG.)   A similar situation exists with a REP socket.  Basically you need both sockets to be in RAW mode.\nThe other thing is that you have to preserve the exact message headers, but you also need to understand that when you create a cooked socket, you lose any of the headers.  The REQ/REP protocol is pretty picky about what can be in the headers.  With raw mode sockets the onus is on you to process the headers on receive, and to inject them on send.\nFrom what I can see, you're not passing any valid SP protocol headers, nor are you bothering to get them from the original message.  In this situation there is no chance your code will know how to route the reply back. \nNote that the headers here are not the nng_msghdr struct.  Instead this is stuff that would be passed in the control structure of the message.  It's ugly, and I hate it.  (I didn't invent this API; Martin copied POSIX extended message handling when he did.  With NNG I pretty much dumped that into the garbage bin because it's painful and complex to use, and difficult to get right.\nAgain, I strongly recommend you have a look at NNG and contexts, which allow you to have multiple concurrent \"contexts\" on a single socket, while avoiding the trouble of handling raw mode sockets properly.  For example, have a look at https://github.com/nanomsg/nng/ (see the demo/async directory, e.g. https://github.com/nanomsg/nng/tree/master/demo/async ).\n(NNG is a rewrite of nanomsg, but is wire compatible with nanomsg and mangos.). There are some edge cases where the code for this is not robust against certain external conditions.  Unfortunately, shutting down the library does actually trigger some of these cases.\nI'd have to go through and do a more thorough analysis here, but you're deep into the state machines that are responsible for a lot of the fragility in legacy libnanomsg. \nI've transitioned almost all new development to NNG these days, which has a very very different internal architecture.\nThat said, if you are for some reason stuck with the legacy version of libnanomsg and need help, let me know.  We do offer paid support for this product, and I'd be happy to deep dive into it for a paying customer.\nIt would be helpful to see the actual value of \"src\" and \"type\" being passed in.\nAlternatively, if you've done enough of the research that you understand the problem well enough to propose a fix, I'd be happy to review and (if appropriate) integrate the fix.\nFailing that, I support the legacy version as I find time to do so; generally libnanomsg at this point gets reduced attention from me these days in favor of NNG.. That would be my recommendation.. I believe this problem is arising due to a potential \"race\" relating to the close of the created socket.  The code here is fragile, and has many assertions where the original author didn't think through all the cases.  (The same is true of ZeroMQ as well.) . If you have a chance, I'd recommend giving NNG a shot (github.com/nanomsg/nng) which was designed to be robust from the first day.\nHaving said that, if I find time to work on this I'll fix it.  But right now nanomsg is definitely backburnered compared to NNG.  (If you need support commercially, reach out to me separately -- we can work out a solution that should let you get a fix for this faster.). If you\u2019re looking at the binary data, there are details about the setting up the transport, and that message has details such as the fact that the client connecting is a SUB socket.\nThis is at the transport layer. \u00a0See the nanomsg rfcs for details.\n- Garrett\nOn Oct 2, 2018, 8:02 AM -0700, gonzalovinas notifications@github.com, wrote:\n\nPlus, received message has 9 more data-bytes filled with zeroes... before actual payload... also .. wondering whats the purpose..\nI couldn't find any doc on this... maybe should I refer to zeromq's spirit?\nThanks in advance\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. That sounds unusual. You should use netstat -af inet to look for bound\nports.  If the dialer is nanomsg or nng or mangos then it should auto\nredial.  This may take a while for it to discover. You could also use TCP\nkeepalives to help. And you can tune both the redial/reconnect time and\nkeepalives with socket options.\n\n\nGarrett\n\nOn Fri, Oct 12, 2018, 9:14 PM GuiRCN notifications@github.com wrote:\n\nYesterday, my publisher app CRASHED. And my subscriber app in another\nmachine remains flagged as ESTABLISHED . I use tcpdump to watch\nsubscriber's local port but got nothing.\nToday I restart my publisher app and bind the same port. There is no new\nconnection.\nThe subscriber just like do not know publisher crash or restart.\nI searched source code and tcp keepalive can not be found.\nShould I write something like heartbeat in my app?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/996, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfR-h6ual8QXN2CJdd2uSZo7Bgcs4ks5ukWiLgaJpZM4XacW7\n.\n. Well, it seems like the problem was in your stack then, and it sounds like you figured it out. . I would need to have more information here.  Can you provide a snippet of your code, how you're sending?. I\u2019d like the snippet of code still. \u00a0I\u2019m concerned about flags passed to nn_send, and how the buffers are managed (scope, etc.)\n\n- Garrett\nOn Oct 21, 2018, 6:22 PM -0700, 363568233 notifications@github.com, wrote:\n\n\nI would need to have more information here. Can you provide a snippet of your code, how you're sending?\nbasic IPC REQ_REP nn_send and nn_recv blocking mode\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. It looks like the problem is due to failing to clear the pipesendbuf if an error occurs.. surveyor can send a lot of data. you can tune down the interval but of course if your responders take longer to reply then you will lose those replies.\n\n\nGet Outlook for Androidhttps://aka.ms/ghei36\n\nFrom: Eric notifications@github.com\nSent: Thursday, October 25, 2018 6:24:57 AM\nTo: nanomsg/nanomsg\nCc: Subscribed\nSubject: [nanomsg/nanomsg] surveyor - respondent mode (#1001)\nthe surveyor send frequency seems to be once per second ?\nCan't this mode send high frequency as a lot of data ?\nI want to use pubsub with respond(default not respond), what should I do?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/1001, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ABPDfemqk173MVZ3pdbBpD6IWVzivZOsks5uoZF5gaJpZM4X59wT.\n. It may be that you need to use multiple sockets.  If your publishers are\ngoing to be distinct from subscribers then maybe you can build what you\nneed using BUS.\n\nGarrett\n\nOn Thu, Oct 25, 2018, 11:15 PM Eric notifications@github.com wrote:\n\nOh, I find setting socket option NN_SURVEYOR_DEADLINE can decrease the\nwait time, but I think that the surveyor mode is not suitable for my\nsituation, I want to high-efficiency pub sub with respond, but testing req\nand rep mode is not high-efficiency, could you give me some advices? Please.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/1001#issuecomment-433273049,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfcu9eV6wpr0aVPAGS3fm5jk8bJzmks5uon5pgaJpZM4X59wT\n.\n. On Oct 26, 2018, 7:32 AM -0400, Eric notifications@github.com, wrote:\nThe Bus mode is only to local level (within a single machine or within a single LAN).\nNow, I'm going to use the req-rep multiple sockets.\nThere is another question, nanomsg can't get remote endpoint's IP? the same as zmq?\nIt's only get remote ip within data.\n\nThat\u2019s true for nanomsg. \u00a0However, NNG will let you obtain the address of the immediate peer, and works with nanomsg seamlessly. \u00a0You might want to have a look at it. \u00a0(GitHub.com/nanomsg/nng)\nNote that you still can\u2019t obtain the address of a peer that is on the other side of a proxy/device.\n- Garrett\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I think this is just support questions, and hopefully we've resolved them.  If you have further questions, please use the mailing or our gitter chat.  You can also post back here and I will try to follow up.. For nanomsg, you need to use nn_poll.\n\nHowever, I recommend you consider using NNG, which offers nicer APIs for this.  You can use multiple threads, each thread having an NNG context (all contexts share the same socket), or you can use asynchronous I/O with some kind of callback scheme.\nNNG is compatible with nanomsg, and its really the \"next generation\" of nanomsg.  See github.com/nanomsg/nng for details.\n. This is a question, and I think I've answered it.  Feel free to post follow ups here, but for now I'm closing it.. I think we should find a way configure without asynch resolver.  Pretty\nsure that is a cmake variable but its been a while since I have looked at\nit.\nOn Wed, Nov 14, 2018, 1:56 AM Eric notifications@github.com wrote:\n\nI find a explanation:\nglibc uses libnss to support a number of different providers for address\nresolution services. Unfortunately, you cannot statically link libnss, as\nexactly what providers it loads depends on the local system's configuration.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/1004#issuecomment-438604511,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfdlFsxAwKFgRNQNm31n_ZSUEhVqEks5uu-jqgaJpZM4YdWXn\n.\n. Try building with cmake -DNN_ENABLE_GETADDRINFO_A=OFF \n\nThat should fix it for you.\nNote that NNG does not have this issue.. \"Long term\", a good fix would probably be to disable this function if NN_STATIC_LIB is set.\nThis can be done with just changes to the top-level CMakeLists.txt I think.  Basically we can make enabling this capability conditional upon that.  If you want to submit a PR for this I'd be happy to review it.  It's not particularly high priority for me at this point (to do myself). . Actually, review this, the warning is correct.  If you're building static, you need to be aware that you still have a dynamic dependency due to libnss.  There's really nothing else I can do about it.  You can ignore the warning if you're going to run your program on the target system.\nAlternatively, if you want to be pure static without this dependency, use that cmake flag to disable the use of the asynchronous resolver.  (It would be a mistake for me to automatically do this I think.  You need to just pay attention to the warning.)\n. Can you post a reproduction case?\nOn Wed, Nov 14, 2018, 6:41 AM Volodymyr Lisivka notifications@github.com\nwrote:\n\nSmall delay (5, 10, 50, 500ms) makes no difference in loss ratio.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/1005#issuecomment-438684675,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfXw8YYyVK2cBhbzORi9bxPexqQkgks5uvCuVgaJpZM4YdyoJ\n.\n. You should add --delay  (say \"1\") to your nanocat invocation that sends the data.  This inserts a delay before sending, to allow the connection to be established.\n\nThis is necessary because on some systems the connection might take a little bit to establish.  This is highly dependent on the kernel, C library, number of CPU cores, and transport.    Adding the delay gives the stuff a chance to settle down.\n(You can probably delete your sleep 0.1 though.  That sleep does no good, because it happens before the attempt to establish an outgoing connection is made, and thus is too early.  The only way to do this correctly at the command line is to use the -d (or --delay) command line.. So this isn't a bug, per se, although the behavior is somewhat unfortunate.  NNG can wait to establishe the connection by default (although I'm not sure that is exposed in nngcat -- I'll have to check to be sure.)\nAt any rate, I am going to close this as it's not a bug in nanomsg itself.. You need to change the value of ${TIMEOUT} in your script too.  I'm running it now with just setting TIMEOUT to 200 and adding -d 1 and it's fine.\nThe unfortunate aspect of your script is that all these are run serially -- maybe you meant to run them in parallel instead?\nYou do have other errors in your script.  For example, the receive timeout is not working because you have the redirect to a file after passing those arguments.\nThe following diffs resolved it correctly for me, with the entire set of pushes running in parallel in the background:\n```\nbash-3.2$ diff -u /tmp/to.sh /tmp/tn.sh\n--- /tmp/to.sh  2018-11-22 08:03:09.000000000 -0800\n+++ /tmp/tn.sh  2018-11-22 08:02:32.000000000 -0800\n@@ -4,13 +4,14 @@\n# Run nanocat in background, to dump incomming packages into log, and exit after 3 seconds\n killall nanocat 2>/dev/null\n-( nanocat --pull --bind-ipc /tmp/pull-socket.ipc --quoted > /tmp/pull-socket.log --recv-timeout $TIMEOUT ) &\n+( nanocat --pull --bind-ipc /tmp/pull-socket.ipc --quoted --recv-timeout $TIMEOUT ) &\n sleep 0.1\n# Send 100 nanomsg messages\n for((I=0; I<100; I++))\n do\n-  nanocat --push --connect-ipc /tmp/pull-socket.ipc --data \"123456\"\n+ echo \"I is ${I}\"\n+  nanocat --push -d 1 --connect-ipc /tmp/pull-socket.ipc --data \"123456\" &\n done\n(( $SECONDS < $TIMEOUT )) || {\n@@ -18,8 +19,10 @@\n   exit 2\n }\n+echo \"Waiting...\"\n # Wait for background job to finish\n wait\n+echo \"done.\"\n# Count of number of lines in log\n NUM_EVENTS=$(wc -l </tmp/pull-socket.log)\nbash-3.2$\n```. This isn't about how much experience you have.  Its specifically about the problems with the script, and misunderstandings about how this software is meant to work.\n(I might not have a PhD, but I've well more than 20 years of experience, a number of them with this particular software, and have produced probably several millions lines of code across many software packages, some of them quite famous open source ones.  Google me if you want to know more.  I don't particularly find any of this relevant to this particular conversation, but as you seemed to wanted to measure egos... there you go.  Oh, and I'm sorry to inform you of this, but I've found very little correlation between possession of a PhD and actual practical implementation ability.  If there is a correlation, it's probably the inverse of what you think it is.  Theory and practice are quite often pretty far divorced from each other.)\nAt any rate, your script has certain bugs.  I was able to fix the script, and I posted the updates to you.  Did you try them out?  Did you try to understand them?\nSpecifically you need to understand about something called \"slow start\", where its nanomsg does connection management in the background.  If you're used to synchronous connect behaviors, this can be quite surprising.  Hence the need to add the --delay field.  This lets the connection be fully established before you start sending data.\n. I'm telling you the script you sent me had serious errors, which I fixed and sent you the fixes for.  If you're unwilling to consider that possibility, then I don't really see much good coming from further interaction.\nIf you do find a real bug, please let me know with a reproduction case.  I can't promise I'll agree with you, but I do promise to at least look at it and see if it's a real issue.\nFor the issue reported here, I don't see any problems once the script is fixed -- I was able to run the program to a clean conclusion with all 100 messages received without any losses in just a couple of seconds.  Without those fixes, the program didn't work at all, and did in fact appear to hang (as you indicated).. Are you trying to force a local IP (source) IP address?  I generally discourage the use of that option.  That said this does sound like a bug.  \nWhat platform was this on, and can you provide an example of the URL you are using?. Oh, when you disable IPV4_ONLY, you should in theory bind to an IPv4 mapped IPv6 address -- but this is highly dependent on whether the host operating system supports it (which can also be subject to tunables -- for example, it won't do IPv6 if you don't have IPv6 enabled or an IPv6 configured address.)\nI'm curious, did you specify a local address as part of the connection URL?  Because nn_ctcp_start_connecting() should not be binding to a local address at all (except on Windows...). You should not ever need to call nn_init().  In fact, looking at the code, it can probably be removed from the library too, as I don't think anything is actually calling it.  It should only be used if you need to recover after calling nn_term().  And really, you should never call nn_term() unless you need to unload a shared library.  (A very very rare use case.)\nThis looks like something I added with an intention of documenting, but it never got documented, and I really would rather you didn't use this (or nn_term) unless you absolutely need to because you need this code to work in the context of an unloaded shared library.\n(Let me know if you have other use cases for this that I've not thought of.). Anyway, nn_init() was never documented, and is not part of any promised API.  Closing.. Sorry about that.  FIxed it now.. So I don't know if boost fibers will work with our events, which rely on having support for poll(), etc.  There has to be support for integration with blocking system calls in order for this to work.  I know nothing about Boost's fibers, so I can't tell you if this will readily work or not.  It would not surprise me if this depends on being able to replace certain system calls in your application code with fiber aware versions, and that it doesn't understand that it need to interpose on nanomsg's internal calls as well as those in your library.\nIt's possible that building libnanomsg with fiber support will help, but I'm not sure, as that's C code rather than C++ code, so I'm not even sure if that is possible.. I don't think you can replace threads with fibers in libnanomsg.  If someone else wants to undertake this, I'd welcome the effort, but I will not be spending any time on it -- this is clearly outside the support matrix for libnanomsg.\nYou might have better luck with NNG, but I wouldn't count on it.  (Probably with NNG you'd wind up having to change the underlying platform code, which is meant to be possible, but in this case the effort might be significant since you'd also need to change the poller code to use a strategy that is compatible with fibers.)\nFor now, I'm closing this for libnanomsg.. I'm sorry, but I am having difficulty understanding your English.  Perhaps it would help if you included a copy of a test program showing what you are trying to achieve?\nGenerally speaking, PUB/SUB is best effort delivery only, and you have to wait long enough for the connection to establish.  Also, if you send too many messages, it is easy for messages to get dropped.  You also do need to subscribe to topics on the subscriber side.\nOne other thing, because it is best effort only, if you exit() from the publisher too quickly, the program may exit without actually delivering the PUB messages on the wire.  If your program is doing send() on pub, then exiting, try sleeping a second before calling exit() (or returning from main().)\nThose are the main stumbling blocks.  To know more, I really would need a clearer description of the problem or an example program.. So that example does not include any of the setup on the receiver side for Sub.\nYou are sleeping in your FuncRecv... don't do that.  Only the sender should sleep.  You want your receiver to run as fast as possible.. So is it all working now?  Can I close this?. Our docs are the man pages.  I'll consider this for NNG (which has much much larger documentation), but for nanomsg I'm unlikely to bother at this late stage in libnanomsg's lifecycle.. You should not have to do that, but you probably do because the static library configuration rules in cmake may not be expressing this dependency properly.  (Meaning that this is probably a bug in my cmake files.)  For now, if that works for you then stick with it.. So this is an usual build case -- you're wanting to stick a static library into a dynamic library -- generally you either are going to build this into an executable (no PIC needed) or you build a shared object.\nThe thing is -fPIC is not free, and so you don't want it on by default when building a shared library. The fact that for your toolchain you do is unusual, and you're going to have to take special steps here.\nMy question for you is, why do you want to do this?\n. I recommend going either all static, or all dynamic.  Mixing and matching can work, but you're probably on your own when it comes to configuring the compiler flags.  CMake will let you specify alternate flags (-fPIC in this case); see the CMake docs for more detail.\nI'm unlikely to make changes to libnanomsg for this unconventional use case at this late stage in nanomsg's life cycle -- there is an easy workaround available for you by configuring CMake flags explicitly.. This description is far too inadequate for me to help you.  I need more specific details: does the self test fail?  What platform did you use?  What was the expected behavior?  What was the observed behavior (precisely)?\n. You may be able to ignore the above message.  I would need more details.  Having said that, all new development has shifted to NNG.  ( GitHub.com/nanomsg/nng ). You can use CMake with normal make.  . At any rate, I would need a bit more detail in order to help you debug this.  I suspect that emscripten may not work with some aspects of libnanomsg (and even NNG), as the browser environment is fairly restricted when it comes to network access.. So while you made a static version of libnanomsg, you still have to link in the libraries upon which libnanomsg depends.  On your platform that appears to be libpthread, and probably libresolv.  You would add those to your link line: -lpthread -lresolv right after the -lnanomsg.. Nothing I can do here -- this is the consequence of static libraries -- all dependencies must be listed when using them because static libraries have no way to record their dependencies like dynamic libraries can.. This looks to me like a problem with your toolchain.  Are you sure you can build libraries using it?  Was the /usr/local/lib/libnanomsg.a produced using the same toolchain?\nAt first glance it looks like you may be attempting to use a cross compiler.. spacing nit - space needed before closing /.\n. This was an assertion.  I'm not a windows dev... should this TODO still be dealt with?  Is the assertion truly always valid?  (If so then I agree with removing the comment.)\n. Should these buffer sizes be expressed as compile time macros somewhere (to make it easier to tune)?\n. closing comment space nit.\n. space nit.  void * \n. I'm not sure I understand the style rule here.. we have strncpy with a space after it above, but strlen without.  Do functions get a space between the name and open paren, or not?  (I prefer without.  But I prefer consistency even more.)\n. again void \n. This comment adds no practical value -- the variable names are clear enough.\n. Did you copy Martin's code?  I'm surprised to see only his copyright here, rather than the actual author's.  In fact it seems very very little of any of Martin's original code could be here -- it looks pretty much specifically new code.  Also, what keeps this code from being compiled/tested on systems that are not Windows?\n. I'd just nuke this altogether.\n. can we choose a better return code?\n. nn_fast feels wrong here.  For two reasons:\n1. We're already in an error path -- this should never be hot -- feels like premature optimization\n2. Is it the case that when in this error path, this is really the most  likely case?\nThere are indent and spacing issues as Dirkjan already noted, as well.\n. This copyright is wrong.\n. \"endpoint\". (spelling)\n. nit. Add a period at the end of the sentence.  (To match other lines in this file.)\n. The other examples single quote (with ') the named arguments.  While I'm not a big fan of whatever markup this style is, we should be consistent for now.\n. I think you should remove Martin's name -- you're the sole author of this document.\n. English wordsmithing (I guess English isn't your first language.)  Try this:\nRetrieves the last error condition for a given endpoint on the socket.  The returned value is the same as for 'nn_errno(3)' except that the error scope is limited to a specific endpoint.\n. QUESTION: What is the expected behavior if the endpoint does not exist.  I'd argue that we ought to return EINVAL.\n. seems like \"how\" is not really the right name here -- maybe \"endpoint\" ?\n. Please fix this indention.  Otherwise I'm in favor of merging this change.\n. euro vs. us english.  even though i'm in the us, please don't bother to change these.\n. This fix seems unrelated to the original bug?\n. nit: there's an extra space here after the ==\n. Doesn't this mean you can't actually set it to the documented -1 for unlimited?\n. This should probably be expressed as an nn_assert() to match the rest of the style in this test program.  By that I mean \"nn_assert(s == -1); nn_assert(errno == EAGAIN);  (or write as a single compound test)\n. To be honest, this seems rather excessive.  I'd set by default to either -1 (unlimited), or something much smaller (1 MB).  Mangos sets this to 1MB by default.\n512MB is so huge that it offers virtually no protection from abuse.\n. Well, I prefer to use specific -1 as the documented case, in case we ever want to have anything else in the future (unlikely, I know).  It will also catch incorrect attempts to set some value that is too large (via rollover).\n. I'd stick with 1MB.   Even 10MB is too big.   In some circumstances 1MB is too big.  (Imagine opening up a 1000 sockets and sending one of these to each one.  Congratulations -- you've allocated 1GB on the server.)\nFor internet facing frames, I'd choose a much smaller value < 100K I think, and also limit the number of connections overall.  We lack the ability to limit.  (The limit could be imposed per peer, but that means quite a bit more work.)\n. Yep, glad you caught that @wirebirdlabs .  I was speaking with the author about his plans for nn_serial. :-)\n. Specifically, in my earlier comments, I'd leave this annotation out.\n. I'm looking at this, and I think maybe we miss the cleanup that would occur in finish2.  Probably instead of return here, we should just go to finish2.\n. Its interesting that this error is indistinguishable from an error on the ep itself.  Is it valuable to be able to separate this case from some other -EINVAL case on the socket?\n. TCP changes already integrated,, modulo the _set_error() call above.\n. Right... these are no longer expressed to the application at all.\n. I object to this change in principle, because you're trying to achieve something that makes no sense with pub/sub.\nPUB/SUB is best effort delivery.  It doesn't tell you that the receiver(s) received it -- and indeed there could be some that receive it, and some that don't based on buffering state in the individual subscribers.\nBasically, if you're expecting to be able to flood without dropping, then you can't use a multicast protocol like this on its own.  You can augment the protocol with a backchannel that is per subscriber to notice missed messages, and replay just those messages that are missed.\nBut if you need reliable delivery DON'T USE PUB/SUB.  The only SP protocol that is \"reliable\" is REQ/REP.\nThe \"silent drop\" behavior of the client here is a design feature, not a bug.  Think of this like radio broadcast -- you put the bits out on the wire (or maybe not, if the transmit queue is too full), but you have no idea if anyone was listening or received.\nAnd frankly, if you try to fix this case, you'll quickly find that the other cases, where messages are dropped by individual pipes due to flow control for example, becomes an issue as well.  It's fundamentally not a solveable problem with just a single \"multicast\" channel.\n. @wirebirdlabs I don't think this is quite right.  It looked like it was meant to fail chunked transfers in the face of a deferred read notification to the user.  That is, we issue a recv response to the user, but we we don't wait for that to occur before issuing the CLOSE to the peer.  (Put another way, it looks like you were attempting to do the fast fail that autobahn wanted, while still waiting until you got all the chunks to issue the response to the app.)\nSince we never wait to issue a response, the behavior I've coded here should represent a \"fast-failure\" like Autobahn wants to see -- that is we close the websocket as soon as we see a failure, without waiting for the full frame to be received.\nNote that it appears that many browsers actually don't do the fast fail correctly here, particularly for mangled UTF-8, at least according tot the test results I've seen.\nThat said, yes, chunked transfers could reasonably happen.  Yes, fast failure is desirable.  No I don't think it is absolutely necessary.  But as I said, I don't think I've broken this aspect of your original behavior.\nI hope that all makes sense.\n. No.  The issue here is that transport layer has discarded the frame (and closed the connection).  We don't report these details back to the application, ever.\nThink of this as a transport level failure, rather than an application failure.\nThe other thing is that other messages could reasonably arrive, and we'd never notice any error in a real world application, except that our mangled frame got dropped.  Someone would need to look at their javascript logs to see the Close message reason, I think.  That's not unique to us either -- I think all websocket implementations are probably similar here.\n. Will fix.\n. Yep, and now I have verification that the socket option actually works. :-)\n. The right place to report this, if ever we could, would be at the sender side.  Arguably in that case we could actually capture this and report it back to the sender.  Even that might not be very satisfactory in the face of e.g. device frameworks and proxies, that are just relaying data.\nThis is all part of the design for nanomsg -- it always just works (except when it doesnt'), and never reports errors back to the application.  (Unfortunately it does crash/core on assertion failures far more often than I'd like, but that's a separate rant.)\n. Agreed with that ping and pong are kind of silly.  I think the idea was to do a midlayer keepalive replacement. \nMuch about websockets feels wonky.  The whole UTF-8 validation thing is stupid in my opinion. There is no good reason for a transport layer to be doing payload validation. \nThat said I think you did the right thing in implementing it. \nSent from my iPhone\n\nOn Oct 24, 2015, at 8:11 PM, Wirebird Labs LLC notifications@github.com wrote:\nIn src/transports/ws/sws.c:\n\n@@ -70,9 +71,9 @@\n #define NN_WS_OPCODE_UNUSED5 0x05\n #define NN_WS_OPCODE_UNUSED6 0x06\n #define NN_WS_OPCODE_UNUSED7 0x07\n-#define NN_WS_OPCODE_CLOSE NN_WS_MSG_TYPE_CLOSE\n-#define NN_WS_OPCODE_PING NN_WS_MSG_TYPE_PING\n-#define NN_WS_OPCODE_PONG NN_WS_MSG_TYPE_PONG\n+#define NN_WS_OPCODE_CLOSE 0x08\n+#define NN_WS_OPCODE_PING 0x09\n+#define NN_WS_OPCODE_PONG 0x0A\nAt the time this was developed, it was not explicitly stated whether a browser or user agent could unsolicitedly (from the perspective of app code) could PING. For this reason, I chose to defensively go ahead and aim for full RFC 6455 compliance, such that your-browser-du-jour would not tend to crash libnanomsg. Now, in 2015, it's still not any more clear. With hindsight, I would tend to criticize the existence of PING/PONG in RFC 6455, since it just kinda throws a monkey wrench into things.\n\n\u2014\nReply to this email directly or view it on GitHub.\n. It came about as I started looking at cleaning up changes to remove those functions and add the type option.  When I started testing I found that I got back a zero length frame which was NOT what should have happened.  And that led me here. \n\nSo yes I encountered specific behavior that I believed was incorrect.  I realize you did it that way on purpose but I think you've since come to agree with me that websockets should not be a special snowflake but instead behave just like any other nanomsg transport. \nSent from my iPhone\n\nOn Oct 24, 2015, at 8:04 PM, Wirebird Labs LLC notifications@github.com wrote:\nIn src/transports/ws/sws.c:\n\n\n/*  On the next recv, the connection will be failed. Why defer\nuntil the next recv? Semantically, until then, this incoming\nmessage has not been interpreted, so it's not until then that\nit could be failed. This type of pre-processing is necessary\nto early fail chunked transfers. */\n  A more direct way of talking about this modification -- did you change it in order to simplify what seemed \"wonky\" or \"wrong\", or was it specifically to address a characterized failure? Don't take this question as accusatory -- rather, it's highlighting my own immediate lack of ability to give positive, helpful review of this change, without yet having mentally spooled up again!\n\n\n\u2014\nReply to this email directly or view it on GitHub.\n. If its not evident, that\u2019s a failure in my ability to express what is\nhappening.\n\nThe recv is timing out due to no input.  Because we drop the frame (and the\nconnection) when the invalid data is first received at the bottom transport\nlayer, without ever sending anything up to the application.   (No zero\nlength frame, nor any error.  The application is entirely shielded from\ntransport errors \u2014 this is part of the design principles of libnanomsg.)\nWithout a RCVTIMEO timer, the recv doesn\u2019t timeout at all, but just blocks\nforever.  I put the timeout in so that I could detect that the frame was\ndropped without delivery.\nNow it turns out that the code is buggy here, and returns EAGAIN instead of\nETIMEDOUT.  That\u2019s a bug in the core socket handling code, and I plan to\nfix it (its a trivial change) to make it conform to the documented\nbehavior.  EAGAIN is only for reporting an empty recv queue when using\nnon-blocking I/O.\nDoes that clear it up at all?\nOn Sat, Oct 24, 2015 at 7:57 PM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nIn tests/ws.c\nhttps://github.com/nanomsg/nanomsg/pull/492#discussion_r42940349:\n\n\nopt = 500;\ntest_setsockopt(sb, NN_SOL_SOCKET, NN_RCVTIMEO, &opt, sizeof (opt));\n  +\ntest_bind (sb, SOCKET_ADDRESS);\ntest_connect (sc, SOCKET_ADDRESS);\n  +\ntest_send (sc, \"GOOD\");\ntest_recv (sb, \"GOOD\");\n  +\n/*  and the bad ... */\nstrcpy((char *)bad, \"BAD.\");\nbad[2] = (char)0xDD;\ntest_send (sc, (char *)bad);\n  +\n/*  Make sure we dropped the frame.  Apparently it comes back as EAGAIN\nrather than ETIMEDOUT.  I think this possibly a doc bug. */\n\n\nwould be at the sender side\nThis is sender-side; line 69 above.\nThat said ... I now see that sws.c does not validate that an outbound\nmessage \"claimed\" to be UTF-8 is indeed UTF-8 -- it only validates incoming\n(untrusted) messages. This seems reasonable.\nMeaning, of course, it could not return EINVAL or EPROTO without\nvalidating the claim of the application. That said ... it's still not\nevident why EAGAIN or ETIMEDOUT would be the expected error code ...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/492/files#r42940349.\n. Right.  The intention is that new test \u201ctest_drop()\u201d tests that a message\nwas dropped.  I do intend to use this in future tests. :-)\n recv_fail_with_error suggests that it gets back an error, but in this case\nits really \u201crecv_got_nothing\u201d. :-)  Which is mostly why I like\n\u201ctest_drop()\u201d.  To me at least, this is a concise description of what its\ntesting for.\n\nOn Sun, Oct 25, 2015 at 9:01 AM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nIn tests/ws.c\nhttps://github.com/nanomsg/nanomsg/pull/492#discussion_r42946368:\n\n\nopt = 500;\ntest_setsockopt(sb, NN_SOL_SOCKET, NN_RCVTIMEO, &opt, sizeof (opt));\n  +\ntest_bind (sb, SOCKET_ADDRESS);\ntest_connect (sc, SOCKET_ADDRESS);\n  +\ntest_send (sc, \"GOOD\");\ntest_recv (sb, \"GOOD\");\n  +\n/*  and the bad ... */\nstrcpy((char *)bad, \"BAD.\");\nbad[2] = (char)0xDD;\ntest_send (sc, (char *)bad);\n  +\n/*  Make sure we dropped the frame.  Apparently it comes back as EAGAIN\nrather than ETIMEDOUT.  I think this possibly a doc bug. */\n\n\nThe recv is timing out due to no input\nthe recv on which line? I just see a send on line 69.\nI now found it within the new test_drop. This is a nit/opinion, but\nperhaps that function could be renamed test_recv_fail_with_error? or\nsimilar? such function/macro could be useful in making many tests more\nconcise.\n(my misunderstanding is due to code reviews on github, where it's easier\nto overlook detail, rather than being in an IDE with richer context)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/492/files#r42946368.\n. NN_SOL_SOCKET feels like the wrong socket option for this.  Its a transport specific option, so you should define one.  Its kind of unfortunate that we need this at all, as Windows is quite different from UNIX in this regard.\n\nFor UNIX we're punting, requiring users to change the permissions of any socket after creation.  Is this possible with Windows?\n. This logic was replaced with inline calls to nn_global_hold_socket(), which includes these checks, but also puts a hold on the socket structure, preventing it from getting destroyed out from underneath us.  Basically instead of these spot checks, I'm using a much more robust reference counting system.\n. I've used this logic in numerous other code bases.  \"Hold\" means to put a reference count on it, and therefore prevent another routine from destroying the object.  hold/rele are paired.\n. Because the hold persists -- that is it extends beyond the time when when lock is released.\nThis paradigm is common in many other code bases:\ngrab lock.\nfind object.\nbump refcnt (hold the object)\ndrop the lock\n... use the object ...\ngrab lock\ndrop reference count\npossibly clean up object (we don't really do this quite the same here)\ndrop lock\n. read the comment above.  586 and 587 are not duplicated.  There are two reference counts to drop.\n(Hmm.. I should move the comment at 584 to above 581 for clarity.)\nrele is shorthand for \"release\"\n\"hold\"/\"release\"\n. FINI - \"finish\".  I could have use \"STOPPED\" here equally, although STOPPED has some other uses which may be confusing in this file.\n. Yes, but if you look carefully, you'll see that there is no \"lock\" held, only the \"hold\" on the socket structure.  So while this sanity check could be moved, the question is really one of consistency and style.  TBH I don't have a strong opinion about it, and am happy to move it if you think it helps readability.\n. Actually, the \"hold\" terminology I picked up from kernel programming, where it is incredibly common.  I don't know how else to describe what I'm doing.\n. We pass in the socket structure because we've already looked it up.  There is no need to have the fragility of a second lookup here.  This actually slightly simplifies the code, and makes it more robust and clear that I'm using a structure rather than some index into the array.\nMore to the point, the only place I use the array index (well, apart from the special statistics socket initialization bit) is when I also validate the array index and place a hold on the structure.  Everywhere else I use the structure I know that I can safely do so because I've already gotten a shared reference (hold) on the structure.\n. The other cases are NN_STATE_STOPPING, STOPPING_EP, and FINI.\nAll EBADF. :-)\n. Not very long.  Less than a second normally.  Probably 10-20 msec. \n. The global mutex is NOT held.  This is a big difference from before where it was held here. This shouldn't affect anything other than the thread calling close. \n. Readability, performance (fewer dereferences), and consistency. \n. I can do that.  Not sure it really helps readability. But maybe. \n. Good question.  We should be in the outer context. So should be safe.\n. I'm not sure its worth fixing in this test case.  You need to wait for TCP connections to be established. We lack port events to get this right and this lame delay is adequate. \n. I don't think atomic adds anything. I've been really careful to use this only under the ctx lock.  If anything adding an atomic may be misleading by drawing attention away from the real protection.\n. I don't think it needs to be atomic though. \n. So I'm adding the explicit cases along with default.  For default I put it to EBADF as well.  I'm not a huge fan of littering the code with explicit checks / assertions; in fact I think a lot of the fragility we've seen in nanomsg in the past has been the result of too 'stringent' checks on things like errnos.\nIn this case, if its not a state that I explicitly covered already, then I want to return EBADF.\n. Nope the comment is where it belongs, as I come back to this today.\n. Yep, you've got it.  I was going to comment that acquire is usually exclusive, whereas hold is more like a shared lock; although it isn't a lock at all -- its just something to keep the system from tossing the memory out from underneath us while we're using it. :-)\n. It can't really be decomposed.  Really, this is the best solution -- and its a paradigm that has been well tested and battle proven in operating system kernels for decades.\n. I have different opinions about assert()  -- its useful for documenting conditions that the programmer is certain of; external errnos don't fall into that category.\nEBADF is used only here because its the most appropriate semantic to use.  We do have EFSM already which I could use for the default case, if it really bothers you.  (My feeling is that any other states that may get added should be treated as not-ready in this case, i.e. closing or not initialized yet, therefore EBADF.)\nI don't want to create a new magic errno.  EBADF has particular semantics here -- the file handle (socket descriptor) is invalid.  (Usually because it is closed or somesuch.)\nnn_assert() needs to always be a panic stop.  Just logging & continuing makes it something much different than an assertion.  The Gnome people went that way years ago, and as a result gnome programs spew assertions like crazy -- because they assert things that clearly are false or not assertions, and yet the program continues onward.  That's abuse of assertions.\nassert() is like crashing a kernel.  Its to be used only when you've got some fundamental assumption, and if that assumption is broken then the very worst thing you can do is try to continue, because it means you have no idea what the state of the program is.\nIf asserts are firing and causing problems, then those are critical bugs that need to be fixed.  In many case we just need to remove the assertions.  (For example, handling of errnos -- instead of an assertion we should inject correct handling to deal with unexpected system errors.)\nAnyway, this is way out of scope for this change set.\n. Try increasing this to 1000.  Then what happens?\n. So the thing that would help me the most, is a bit more information about the nature of the hang.  What's stalling out?  It doesn't make sense exactly that nn_close() is hanging, and if it is I'd love to have a more complete stack trace -- including for all threads.\nGetting this on Windows is something I'm not qualified to do -- I know nothing about the Windows debugging tools, and I prefer to remain blissfully ignorant.  :-)\n. spacing nit -- space before comment closer please.\n. Actually, this can fail for a variety of reasons, I think.  Looking at the MSDN site, I see that we should call GetLastError().  We do something like this elsewhere, and indeed a few lines below with CreateFileA we do this.  So we should fix this, or at least leave the comment with TODO in place until we address it.\n. This doesn't clean up the pipe we created above.  Should it?\n. Thinking about this, a transport option that can be used for UNIX IPC calls might be nice too.  Sort of a chmod or something.   But then we should think to make sure we can express this option portably.  I'm not sure how to do that.\n. So these should be transport level options, not NN_SOL_SOCKET, as they apply to the IPC transport rather than to the socket as a whole.\n. While this asserts that you can create this security attribute, I don't see how it validates that the IPC is actually created with that.  I'm not a windows guy, so I don't understand how you could even attempt to validate that -- how can you check the permissions of an Named Pipe?  I'd really like to see that verified though.\n. These options should be defined in ipc.h.  (I'm less sure about the buffer options, but I think so, there as well.)  The handling  here in aipc.c is the right place.\n. This should be smaller. Lots smaller. \n. Why so long?\n. Not a fan of the cute message.  App may not want to advertise nanomsg consumption. And there can be security reasons to avoid self finger printing. \n. Do we seriously think this is that load dependent?  I'm doubtful. \nI'd rather fail more aggressively. I think we still don't understand the reason for the failures.  Perhaps we are spinning when we should not?\n. Add to this.  I'm gonna squash them all into one anyway. Perhaps against multiple issues. \n. That correlation note is very interesting indeed.  Maybe we are spinning or the test needs to be changed to be less sensitive to load?\n. Apparently I got this wrong for windows.\n. Yeah, that's a formatting bug in github. Go figure.\nThere's a real benefit here, which is that the stringifcation is now automated, eliminating a rather large opportunity for human error.  (The symbol names will fail a compile check if they are wrong. :-)\nThe compact representation makes it easier to see what's going on.  I understand your gripe about breaking the IDE search function, but I think the benefits outweigh the cons in this case.  (In fact, you'll still find the reference nearby in this file, because the symbols that are \"abbreviated\" are listed in full in their own entries in this array.)\n. In modern MSVC (2010 edition or later) this is true.  Older versions don't have it.  I fixed it for now, but I hate this.  If we can just state that MSVC 2010 or newer is required, that would be simpler.  (See also the __VMS hackery for OpenVMS.  Puke.)  What I don't know is whether requiring MSVC 2010 or newer will cut off an additional round of platforms (Vista or Windows 7) that would otherwise be supported.  I have tried (mostly successfully) remain blissfully unaware of Microsoft platforms up until now...\n. Turns out this is possible (I had already thought about it). Using the nn_symbol() capability, you can iterate over all symbols, and just look for the ones that are in the NN_NS_STATISTIC namespace.  So everything is discoverable.\nOffering up all of them would have been a bit trickier to do in an interface that is meant to evolve (as new stats get added, and possibly old ones deprecated).  This way we can evolve without breaking binaries due to incorrectly compiled structure sizes or somesuch.\nAnd the whole thing is discoverable without me having to invent a new API, which I love.  (Not that I really have any love of the nn_symbol() API -- but in this case it solves the problem for us.)\n. Valid point.  I think we should advise caution.  While the API itself can be considered stable, some of the statistics may be considered unstable, and relying upon their values programmatically for purposes other than visibility or debugging is at least strongly discouraged.\nThat said, this is a level of visibility that can be useful.  Imagine knowing that you could monitor connections statistic to determine when to start flooding data... etc.  I do imagine that I'd wind up using this information for the express purpose of test cases, since now we have visibility into some state that we previously lacked.  But I wouldn't want to do any of that in production.\n. In fact, I've forgotten to write a man page for this API.  Argh.  Later.\n. Btw, I apologize for the coding style screw ups.  I actually don't like the nanomsg coding style -- mostly because its different from the BSD/illumos coding style that I use everywhere else.  I occasionally make screw ups (like failing to insert whitespace before leading parenthesis.)  I'd actually love to change the style, and add some verification tools (e.g. illumos' cstyle checking program) to ensure that we are conforming to the style...  something we can discuss later.\n. Just remove this work... I'm not checking the definition of the macro anyway, and if it fails... ETOOBAD.\n. Is the definition of -DCMAKE_C_COMPILER required here?  (It doesn't pick up $CC automatically?)\n. So it turns out that while a HAVE_QNX macro was defined, nothing in the code uses it.  I'm unconvinced that QNX actually \"works\".  TBH, I'm not thrilled with this long explicit system listing.\n. Clearly we need OSX and Windows checks.  We might need one for NetBSD (see poller_kqueue.inc), but the other system checks should not be needed.\nWe do need library checks for socket and gethostbyname (nsl).  I'm inclined to believe that those should not be tied to a specific platform.\n. I don't like any of these compiler checks ... I think they serve to arbitrarily limit the source portability.  I'd remove this entire stanza.\n. Do any of the above need to be checked in a location other than libc?  I don't think so, but I'm not sure.\naccept4 and pipe2 might need GNU_SOURCE flags to be defined too.  To be honest its kind of unclear to me that pipe2() and accept4() are worth the support overhead of keeping them -- they reduce the number of system calls (eliminating an fcntl) required to establish a connection/pipe, but most systems should not have huge numbers of pipes connecting and disconnecting -- this isn't a web server with shortlived connections after all.\n. I think you may have missed this by not having the define in your test above.  Note that its unclear that this is always required -- netbsd offers at least pipe2 without this flag.\n. It strikes me that it may be time to check for C11 atomics, now that we have a standard for this... (and add references for them).\n. Better yet, lets just change win_sec_attr so it returns success (skipped) on non-Windows platforms?\n. Btw, we should carefully go through the tests to make sure that the autoconf test list is fully represented here.  I think I recall seeing some tests were missing from the CMake build.  Probably through oversight.\n. I think \"signaling\" (one l)\n. I don't understand this block at all.\n. As discussed, we should change this file to .appveyor.yml.  -- also we need to think about version numbering handling here.\n. This is cool -- getting new warnings from the build now, which we should fix.\n. Lets talk about the changes in this file -- as well as poller.inc -- previously we had this conditional logic in macros in the source files, but now you're moving it to the cmake build.  I'm not sure if that's an excellent idea.\n. I filed a bug to clean this up too.  NN_EXPORT should be extern on all non-windows systems, we can clean this crap up.\n. Just a heads up about All rights reserved.  This sentence means _nothing in modern copyright law, and hasn't since 2000 (when the last hold out to Berne -- Nicaragua -- finally signed the Berne convention.)  That's why I never list it.\nSimilarly \"(C)\" has no meaning, and never has.  Its an attempt to replace \u00a9 with an ASCII-ifcation, but even \u00a9 means nothing in the presence of the word \"copyright\" or the abbreviation \"copyr.\"  The symbolic form was intended to allow a short symbol instead of the word, rather than in addition to.  The ASCII version has never had any legal meaning whatsoever in a copyright notice, only the actual symbol or the word \"copyright\" does.\nAll of which is why my notices are always just \"Copyright  \".  (I add my email too, but that's optional.)  The  is the most recent date of publication; adding the first year of publication is also optional but carries no particular weight of law behind it.\n. All that said, the copyright notice is yours, so you can make it what you want (within limits).  The above message was mostly intended as an educational FYI.  :-)\n. Oh sheesh.  Yeah, lets take this opportunity to fix & improve rather than just \"porting\".  acc -- I forgot about that HPUX crap.  (There was also acc on SunOS 4.1.3... I'm showing my age now though...)\n. Tend to agree, but for the stuff that's easy and obvious to clean up -- the compiler testing above for example -- lets do that now.\n. This should just be a future RFE; lets have a plan to support C11 atomics, and threading too, in the future.\n. In this case, maybe rearchitecting the stuff now is something to wait\nfor; keep the existing solution used in autoconf and old cmake (which seems\nto work well enough), and we can explore alternative better ideas in the\nfuture.  This would have the benefit of reducing the scope of change\nrequired for cmake support.\nOn Mon, Apr 18, 2016 at 1:31 PM, Jack R. Dunaway notifications@github.com\nwrote:\n\nIn src/CMakeLists.txt\nhttps://github.com/nanomsg/nanomsg/pull/636#discussion_r60128764:\n\n@@ -130,10 +103,6 @@ set (NN_SOURCES\n     utils/sleep.c\n     utils/thread.h\n     utils/thread.c\n-    utils/thread_posix.h\n\nThe reason I chose this method is to prune other-platform source code from\nthe backend-generated project file -- in my case this is a Visual Studio\nSolution. By omitting, e.g., worker_posix.inc, this means when I search\nfor symbols, it doesn't return duplicates in non-relevant platforms -- only\nworker_win.inc was included and relevant. It makes the IDE experience\nbetter.\nThat said ... there's merit in understanding other platforms, even if it's\nnot relevant to your own current platform. In which case, I would prefer a\nrearchitecture of the source code to be along the lines of this:\nhttps://github.com/nanomsg/nanomsg/blob/master/src/utils/clock.c#L71-L121\nEither way ... much of this entire CMake rearchitecture is a stepping\nstone to get from where we are to where we want to be, and in the meantime,\nit's likely to carry along some cruft that can then be hit later.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/636/files/95b664f66e89dfbcc99877d3132a54b420c69cf5#r60128764\n. Neither am I.  But I have been advised by one.\n\nOn Mon, Apr 18, 2016 at 1:34 PM, Jack R. Dunaway notifications@github.com\nwrote:\n\nIn src/utils/efd.h\nhttps://github.com/nanomsg/nanomsg/pull/636#discussion_r60129203:\n\n@@ -1,6 +1,7 @@\n /*\n     Copyright (c) 2012-2013 Martin Sustrik  All rights reserved.\n     Copyright 2015 Garrett D'Amore garrett@damore.org\n-    Copyright (c) 2015-2016 Jack R. Dunaway.  All rights reserved.\n\nIANL :D\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/636/files/95b664f66e89dfbcc99877d3132a54b420c69cf5#r60129203\n. What I was saying, or suggesting, was that I'd revert this portion of the change.  I think the old stuff worked, didn't it?  (Even when applied to cmake?)\n\nMy goal is to have the changeset required to enable cmake be the smallest change we can easily do), since and then refine it going forward.\n. I'm still pretty opposed to this approach.  Part of the reason is that it will be easy for folks to think they're modifying the file list for all platforms, and only be modifying them for one of them.  I agree we can refactor to better than what we had before this change,but I don't think this part of the change set represents an improvement.\n. What's this -- I've never seen this before.\n. Is this a standard CMake test? \n. This one ought to be commented out by default -- understand its useful during development....\n. So I found this.  Its pretty sad that this exists, but I understand why.  It is indeed standard.  But the answer is to use CMAKE_THREAD_LIBS_INIT instead of explicitly putting this here, I think.  But really what is going on is the CMake people have used the magical -pthread convenience switch used in legacy environments (old Solaris for example) instead of expanding this to -lpthread (or whatever) at link time, and -D_REENTRANT at compile time.\nI suspect we ought to just blindly declare -D_REENTRANT everywhere; I'm not aware of any platform where this causes harm, but I am aware of several where it it makes things better.\n. We need this in the current work.\n. This starts a precedent I want to avoid.  The compiler flags knowledge can get really hairy -- especially with some of the flags for optimizations, different debugging formats, etc.  And there are reasonable compilers that have different flags for PIC.  E.g. SunPro uses -KPIC.  So, let's just use the cmake magic to enable this instead, please, rather than carrying this baggage around ourselves.\n. Brilliant!\n. According to CMake docs,\nCMake Error, continue processing,\n                              but skip generation\nSo I think this means that further operation inside cmake will continue,\nbut it won\u2019t actually emit a Makefile (or whatever).  This way we can check\nfor other errors too.  Am I mistaken?\nOn Fri, Apr 22, 2016 at 3:56 PM, Franklin Mathieu notifications@github.com\nwrote:\n\nIn CMakeLists.txt\nhttps://github.com/nanomsg/nanomsg/pull/665#discussion_r60813444:\n\n@@ -205,6 +207,92 @@ if (NN_ENABLE_NANOCAT)\n     target_link_libraries (nanocat ${PROJECT_NAME})\n endif ()\n+# Build the documenation\n+if (NN_ENABLE_DOC)\n-    find_program (ASCIIDOCTOR_EXE asciidoctor)\n-    if (NOT ASCIIDOCTOR_EXE)\n-        message (SEND_ERROR \"asciidoctor not found, cannot create docs\")\n-    endif ()\n\nSEND_ERROR continues execution, so the whole block below should be\nskipped if asciidoctor isn't found.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/665/files/55921246a02a8d9581fbb6e961a6aae3aadbb2c7#r60813444\n. No its real.  I fixed it.  I hate hate hate space based indentation.  8-cell tabs (with real tab characters) are soo much easier to see and use.  (This is a topic we may explore later.)\n. It was very helpful .. I can remove it now if you like.  (Problem was that I couldn't tell whether this was working or not on the VS builds because VS output sucks.)\n. originally I had a plan to make the default value of using asciidoctor depend on this.  I couldn't quite achieve this with a fatal error, so by checking it here, I can disable it.  arguably I could enclose this in an if branch, but apart from saving the time to check (few dozen microsends of the build time I think), it doesn't buy me anything else.  I prefer to keep it simple as it is for now.\n. Actually, maybe I can improve slightly, stay tuned.\n. Its tiny so far as I\u2019ve seen.  There are ways to cache the results, but\nthat adds a lot of complexity so I\u2019m going to avoid that until we see this\nis a problem.\n\nOn Mon, Apr 25, 2016 at 10:44 AM, Jack R. Dunaway notifications@github.com\nwrote:\n\nIn .appveyor.yml\nhttps://github.com/nanomsg/nanomsg/pull/665#discussion_r60955592:\n\n- GENERATOR: Visual Studio 12 2013 Win64\n   CFG: Debug\n-      VS_VERSION: 12.0\n  +install:\n-  - gem install asciidoctor\n\nHow much time does this add to the build? Probably not much, but it's\nworth monitoring.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/665/files/cb6ea68a431d182e12a7700a86e509a1fc74df9a#r60955592\n. do we need a scratch variable here?  would sizeof (void ) work equally well without the void_ret_value declaration?\n. This cast should be unnecessary.\n. Because malloc should return void ... which should auto cast to anything.\n. Is this the source of the crash?\n. The above pseudo code is wrong, since we want docs enabled by default, but don't want default options to fatal error.  So I've found and delivered a different solution to this already. :-)\n. Yes this is the right way. We're shutting down so the grab and release is fine here. \n\nSent from my iPhone\n\nOn Apr 26, 2016, at 6:10 AM, Jack R. Dunaway notifications@github.com wrote:\nIn src/core/global.c:\n\n```\n }\nnn_glock_unlock ();\n```\n+\n-    /* Make sure we really close resources, this will cause global\n-       resources to be freed too when the last socket is closed. */\n-    for (i = 0; i < NN_MAX_SOCKETS; i++) {\n-        (void) nn_close_impl (i, 1);\n-    }\n  In this loop, each iteration obtains/releases the glock. Is this semantic correct, compared to holding the glock for the entirety of looping through all sockets?\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\n. Its stil a reasonable question \u2014 the presence of the #define doesn\u2019t mean\nthat IPC is actually implemented.  Indeed, I\u2019ve some evidence that IPC\ndoesn\u2019t work quite the same everywhere \u2014 it can, for example, depend on the\nfilesystem code supporting it.  For example, I believe it doesn\u2019t work in\nall directories on QNX (or so I\u2019ve heard).  As another example, it doesn\u2019t\nwork on FAT filesystems where you need to have support for pipe special\nfiles.\n\nThat said, I think we can leave this question up to the platform code \u2014 if\nthe code compiles then that\u2019s all we can do.  If it fails at runtime,\nthen the user is going to have to work around it.\nFor the case of Windows, we don\u2019t use AF_UNIX at all, and I\u2019m happy to have\na per-platform feature test for it \u2014 Windows is such a special snowflake\nhere (with its named pipes) that it deserves special handling.\n- Garrett\nOn Tue, Apr 26, 2016 at 8:04 AM, Franklin Mathieu notifications@github.com\nwrote:\n\nIn src/transports/ipc/bipc.c\nhttps://github.com/nanomsg/nanomsg/pull/678#discussion_r61102523:\n\n@@ -168,6 +168,11 @@ static void nn_bipc_destroy (struct nn_epbase self)\n static void nn_bipc_shutdown (struct nn_fsm self, int src, int type,\n     void *srcptr)\n {\n+#if !defined NN_HAVE_WINDOWS\n\nActually, nevermind: AF_UNIX on windows is defined in winsock2.h, so we\ncan feature test with sys/socket.h.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/678/files/45c6a91b373c82f2b0235de2d9fabb362522e6e6#r61102523\n. There are compilers that do -pthread -- this flag usually sets (on Solaris) some other flags -- generally -D_REENTRANT and possibly -D_POSIX_PTHREAD_SEMANTICS, and adding -lpthread.  SunPro (legacy) had -mt for a similar purpose -- adding -lthread and adding the -D_REENTRANT.\n\nThe link-time stuff is just -lpthread, which ought to be sufficient.\n. What does \"upstream\" mean in this context?\n. While this is required for generation, do we care about actually checking this?  What happens if we just ignore the close code whether well formed or not?  (Be generous in what you accept.... )\n. TBH, I'm not sure what value passing the close code here gives.  How is this useful to the application?\n. Return statement here not needed.\n. Yay.  This is a critical stopper bug you are fixing. :-)\n. This message, if exposed to users, could be confusing.  \"Message larger than NN_RCVMAXSIZE\" might be clearer.  Or just \"message size exceeds limit\"?\n. I'd prefer to see argc, argv arguments (even if unused) to main().\n. Just a little note.  I hate the use of enclosing asterisks in block comments.  It becomes a pain to maintain them, and it looks horrible if ever used with a non-monospaced font (I know don't do that!) I used to use the same comment style when I was young, but in my years since I've learned that they add little value -- the ones on the right side are especially annoying to have to maintain.  Usually just a single multiline comment with left aligned asterisks is sufficient to catch attention -- especially if surrounded by whitespace.\n. That said, I think Martin used these block comments extensively elsewhere in the code.  They still annoy me, and I celebrate a little when I can remove them. :-)\n. So it would be wrong to give a best effort response to this, even if the reason was not valid UTF-8?\n. So lets change the wording here, because its unclear.  Perhaps say \"should already have been failed.\"\n. Ok, lets check this at some point -- I'd rather not have the burden of validating UTF-8-ishness if we can skip it.  Seems to be of very little merit here, IMO. \n. I see, this response is sent back to the far end, so its for peer consumption rather than app consumption.  Right?\n. No \"pedantic\" compiler that I'm aware of \"prefers\" an explicit return at the end of a void function.  If there is a returned value, then that's different.   (Implicit return values of zero are what compilers bitch about.)  I'd prefer to remove it, actually.\n. Yes.  The value here is \"expire\", not timeout.\n. I would be happy to make this more explicit -- a timeout of -1 is valid, and results in expire = (uint64_t)-1.  That means an infinite timeout.  This is not a place for an nn_assert().\nThe unfortunate thing (and it does work this way) is that its not obvious that assigning (int)-1 to a uint64_t results in a value of 0xffffffffffffffffULL (aka (uint64_t)-1).  A more clear way to write this, although slightly less efficient, would be to explicitly check for timeout < 0 and setting expire = (uint64_t)-1.\nIf you want me to make that change for clarity (at a tiny expense in terms of performance) I'm happy to do so.\n. This feels wrong.  What is this fixing?\n. What is unused here?  The return value?  The arguments?  Which ones?  I think you need to apply NN_UNUSED in front of specific arguments if that's what they are for.\n. Same as above.  I think NN_USED is in the wrong place.\n. maybe better to nn_assert (ctx != NULL) before the above assignment?\n. This is a logic change.  It shouldn't matter because nn_memory_error (ctx) should probably abort the program.  Maybe that needs a NORETURN (or whatever) statement?  I actually don't like adding the extra indentation here, it makes the flow harder to grok.\n. As above, probably better to assert the ctx rather than lst.  The compiler should be able to figure it out from there.\n. This might be an assert against the str at the start of the function?\n. Similar comments as above.\n. Ok, I see now.  I think this is goofy, and but its doing what was intended, because testutil.h is compiled inline and these are static functions.  So I'm fine with that for now.  We ought to fix this to be less \"weird\" in the future.  (A separate header and .c file would be more typical.)\n. As above, fine for now.\n. Ok, so the more I think about this, the more vociferously I believe this is all wrong.  We're adding in a specific check for exactly one form of error (NULL pointers).  There are a bunch of others, stemming from e.g. use-after-free, uninitialized (and hence random) pointers on the stack, pointers to objects of the wrong data type, etc. etc.\nThe analyzer that is triggering this is crap, and I'm not interested in doing runtime parameter validation for all of these pointers.  There may be specific cases where such an assertion adds value to us (by documenting an assumption that we are making which isn't otherwise immediately obvious).\nI'm not interested in doing the equivalent of adding assertions against NULL to function arguments everywhere.  You won't find libc does this (e.g. strcpy does not), and neither should we.\n. I haven't actually tried to understand the code.  Its probably dead from an earlier implementation, but I had nothing to do with it.\n. I'm withdrawing all my exceptions to this usage in this file.  This is in options.c -- so not in the mainline library, and the assertions therefore do no harm to any end users.  The need for them underscores pretty strongly to me that the options design here is somewhat sketchy, but it works for now.\n. Agreed.  I still haven\u2019t figured it out.  This is going to take time.\nOn Wed, May 11, 2016 at 4:33 PM, Jack R. Dunaway notifications@github.com\nwrote:\n\nIn src/utils/efd.c\nhttps://github.com/nanomsg/nanomsg/pull/703#discussion_r62944653:\n\n@@ -119,6 +119,7 @@ int nn_efd_wait (struct nn_efd *self, int timeout)\n     }\nfor (;;) {\n-        fd = self->r;\n\nGood catch; even if doesn't fix issue, this is a good change to keep.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/703/files/f19915e9adcbf4079825205de1c56d367ccacc07#r62944653\n. What happens with MINGW or other compilers (Borland?) on Win32 platforms?  Put another way, is the issue here the compiler (MSVC) or the platform (Windows)?  I don't know the answer, but I hope you or someone else here might.\n. does this artificially limit valid values by any chance?  (So for example, can I do cmake -DNN_ENABLE_DOC=yes today  instead of =ON ? \n. Ah, I see, you have explicit checks here. Are ON/OFF sufficient to emulate what CMake does today?\n. Huh.  I prefer with the dash, but I'm stodgy apparently:  http://grammarist.com/spelling/online-on-line/\n. The changes in README look good.  Can we push this in a separate bug fix/commit?\n. Changes in travis and appveyor are good.  Some questions pending about the CMakeLists changes though.  (See below).\n. Btw, not every platform has a working -print0 and xargs -0.  I added those to illumos fairly recently, and I don't think Solaris has it.  Since our files don't have spaces in their names, I think we can use just ordinary -print and no -0 for xargs.\n. Actually those docs say, and I quote:\n\nTrue if the constant is 1, ON, YES, TRUE, Y, or a non-zero number. False if the constant is 0, OFF, NO, FALSE, N, IGNORE, \"\", or ends in the suffix '-NOTFOUND'. Named boolean constants are case-insensitive. If the argument is not one of these constants, it is treated as a variable:\n. I'd only treat the positive cases there, and let the negative cases fall through to false if anything else (i.e. it doesn't concretely match one of the positive values)\n. This is a style change.  While I personally like having the extra explicit braces, it isn't intrinsic to this change.  We should remove this for now.  (I'm avoiding style changes to the code base, even though I hate the current style.). Please remove this -- we don't want blank lines at the end of files.. This file has only whitespace changes now.  These are not intrinsic to you changes, so lets undo this.. This is incorrect.  It is setting the SO_RCVBUF, not the TCP_NODELAY option.   I think you made a copy-pasta error.. This is almost surely incorrect.  The problem here is that we have the state machine setup and running, and a usock set up to use it as well.\nSimply freeing is inadequate here, and leads to a segfault.. As this is in initialization function, its implicitly single threaded access at this point, so no need to use an atomic to store the value.. Arguably, it would be nice to have a variant of the increment that didn't do the fetch.  The fetch operation is actually more expensive, and many times we don't need it.  (In fact, we usually don't, given that \"n\" is positive.). So the interesting thing here is that I think volatile is probably adequate.  Perhaps we should atomically decrement, but the critical thing is that at 116 we are checking against 0.  There is no way for that to be zero unless all the other threads are done.  This is true for the next test as well.\nGiven this, and given no other uses of atomics, probably we could just abandon the nn_atomic_fetch() altogether.. The point is that a read against this is cannot ever be zero if other threads are running.  I.e. this can be lockless/atomic-free.  The volatile bit is necessary to just make sure we check memory again and don't rely on cache.\nThe decrement on the other hand, is prone to races, and does need the volatile, as you rightly notice.\n. So this CMake thing is a bit different -- I'm concerned that if this doesn't work, we might wind up with a static library.   I think what you're trying to achieve here is correct, but I want to validate this.  Unfortunately, the failure mode for this if you got it wrong is that tests will just silently succeed.. This change looks unrelated.. No, by definition the semantic is only appropriate to single threaded use.  Multithreaded initialization of the same value is simply nonsensical.. Right.  That's another issue.  It could be a different commit, I suppose, which would be slightly better... I'm willing to be a bit lax on that though.. What does -e do?  It isn't defined on macOS at least..... This should be SameMajorVersion instead of AnyNewVersion I think.. This no longer has an EXPORT associated with it.  Is that correct?  I'm still trying to come to grips with the relationships within CMake here.. I stand by my request here.  MsgPack is a different project, and does not seem to follow Semantic Versioning.  We do, and are very careful to avoid bumping the major number unless we have breaking changes, which we try hard to avoid.   I believe the \"shortcomings\" you refer to are not shortcomings at all, but a feature.  The shortcomings are instead in the imported package, which seems not to place much value on semantic versioning.. ",
    "sorenriise": "Was this ever done?   I could use the (3) Service Name just about right now.\n. ",
    "fdev31": "Any update on this ?\n. ",
    "djc": "@mikeguidry says it's fixed on IRC.\n. I think this can be closed (would be nice if you referenced the fixing commit here).\n(Ideally, you would also mention issues in your commit messages.)\n. It seems to work for me, but it's possible I have extra stuff installed.\n. Closing. Feel free to reopen if you can still reproduce using latest master!\n. #175 doesn't seem related to me.\n. @snikulov can you please explain why you think so? Thanks!\n. Alright, thank you!\n. Never mind, that was only on 0.2, it isn't there on master.\n. Err, I really wanted to do a PR, sorry if this was a bit hasty.\n. Do we need to do something here before the 0.4 release?\n. Merged in b5574e93.\n. Interesting. @sustrik reported not seeing it on OS X 10.8.\n. It seems like something we could fix at some point, so no.\n. I'd be happy to have the @wirebirdlabs fix as a PR, please also squash in the indentation fix.\n. Added some comments. It would be nice if this PR could be redone with those things fixed! (Also, rebased instead of merging master.)\n. @eglimi sorry this hasn't been reviewed so far. Where does your requirement for ANSI C come from? I'd be more comfortable with adding an extra #define for compilers that don't have any inlining functionality, since not inlining can have a significant performance impact (though I'm not quite sure how important this particular instance is).\nUnfortunately @sustrik will not be able to comment soon, he'll be back in a few weeks or so.\n. I don't think I can decide if this particular instance of inlining is important, so I think we should wait for a verdict on @sustrik on that.\n. Ahhh, duh. Thanks for the clarification.\nI've split the patch into two and cherry-picked the resulting commits onto master, in 06f3e3fd and 90f643b1.\n. Perhaps you should mention this on the mailing list, as well.\n. @wirebirdlabs your ws:// transport sounds exciting, looking forward to it!\n. Thanks for that!\n. I was unable to reproduce this issue (on Linux, with autoconf-2.69). I tried the second patch first, since it is more minimal, but it caused an issue with my version of autoconf:\nconfigure.ac:32: error: possibly undefined macro: AM_SILENT_RULES\n      If this token and others are legitimate, please use m4_pattern_allow.\n      See the Autoconf documentation.\nThe first patch seems to work fine, though.\n. I'm not sure about this; the documentation about ETIMEDOUT says \"Individual socket types may define their own specific timeouts. If such timeout is hit this error will be returned.\", which makes it sound like this should only be used for e.g. SURVEYOR sockets. Perhaps the documentation should be clearer about this. Did you get EAGAIN in blocking mode?\n. Many people have been able to compile code against nanomsg (probably even many used the same tutorial), so it seems likely that there's something specific about your system that's different from what other people use. You've so far said very little about the environment in which you're trying to compile the example code (e.g. OS/distro, 32- vs 64-bits, compiler version, etc).\n. Thanks, @andreasbaumann!\n. Thanks!\n. Any progress/further insight here?\n. Okay, thanks. Are you interested in working on that suggestion?\n. I'm sorry to hear that, and sorry for the delay in processing your work.\nI will try to work my way through your pull requests in the near future.\n. Thanks!\n. @stepelu did you ever get around to trying this?\n. With automake-1.10?\n. Yup!\n. Closing as requested.\n. Yup, thanks.\n. Thanks!\n. Also, it would be nice if you can rewrite the commit message to have a moree concise first line (e.g. max 70 characters or so) and more explanation in subsequent lines.\n. Sorry for taking so long!\n. I don't think the answer should necessarily be no, but it should depend on the amount of complexity, and how well it can be squared off in its own little corner without cluttering the modern stuff.\n. Can you state that you are submitting these patches under the MIT license?\n. Thanks, merged!\n. Can you state that you are submitting the patch under MIT license?\n. Thanks! I've pushed your changes as 6db4e7d and d907795 after cleaning up the commit messages and fixing a formatting nit.\n. Thanks, merged!\n. I think it should just be in the relevant documentation section.\n. Yeah, it seems like a doc patch would be useful here.\n. Err, I think we'd need @sustrik in on this.\n. @tailhook ping?\n. Looks good to me, thanks!\n. @gdamore, thanks for digging into this. I agree with your analysis that this is not a bug.\n. @sustrik uses asserts very deliberately to flush out bugs. I don't think we should wholesale remove them unless we can show for each of them that it's not actually a bug, but reason out why it happens, and then we should enter a proper error path.\nCan we do so for each of the asserts in nn_tcpmux()?\n. That sounds fair. Should we make sure an errno is set before we return from nn_tcpmux(), then? It doesn't look like your patch does that.\n. Can you state that you are submitting these patches under the MIT license?\n. Squashed and edited the commit message little bit, committed as 12bbd3c. Thanks!\n. @ivachkov, can you help out with this?\n. Thanks!\n. Consensus achieved, sorry for my lack of feedback/follow-up. Thanks for sticking with it!\n. Thanks!\n. Thanks!\n. Merged, thanks!\n. Thanks! \n. @gdamore the use case for nn_symbol() is for language bindings, I think. Can't remember the exact way it helps right now, though...\n. Wouldn't size_t be better than ssize_t here? I'm +1 on the overall idea, though.\n. This is a pretty crazy pull request, seemingly containing a few unrelated changes and a zillion merges. Can you squash it down to something more reasonable and single-topic, please?\n. Thanks! \n. ",
    "mikeguidry": "ouch in the mix i may have pulled the master... maybe the crash was from aio2 but when i reproduced it ended up in master.. let me redo it again.. one moment\n. [New Thread 0x7f0cf8cb2700 (LWP 10060)]\nProgram received signal SIGABRT, Aborted.\n[Switching to Thread 0x7f0cf94b3700 (LWP 10059)]\n0x00007f0cfe18f425 in raise () from /lib/x86_64-linux-gnu/libc.so.6\n(gdb) bt\n0  0x00007f0cfe18f425 in raise () from /lib/x86_64-linux-gnu/libc.so.6\n1  0x00007f0cfe192b8b in abort () from /lib/x86_64-linux-gnu/libc.so.6\n2  0x00007f0cfe9b9c8d in nn_err_abort () from /usr/local/lib/libnanomsg.so.0.0.0\n3  0x00007f0cfe9b6ecf in nn_worker_routine () from /usr/local/lib/libnanomsg.so.0.0.0\n4  0x00007f0cfe9bc674 in nn_thread_main_routine () from /usr/local/lib/libnanomsg.so.0.0.0\n5  0x00007f0cff62de9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\n6  0x00007f0cfe24ccbd in clone () from /lib/x86_64-linux-gnu/libc.so.6\n7  0x0000000000000000 in ?? ()\n(gdb)\nsure enough its in aio2\n. I've come to realize this may have been an issue because of the way i was implementing nanomsg.  I have read a couple blogs posted by sustrik and realized using prioritized separate IPC connections is the correct way for what I require.  I believe creating 10 bindings, and connections under the same prioritization is just wrong whenever the infrastructure supports more complex solutions.  I am unaware if this is actually a bug or just ridiculously confusing nanomsg ...\nat this time i also didnt supply this doconnect() function: \nvoid doconnect(int sock, int count) {\n    int i;\n    char name[1024];\n    for (i = 0;i <count; i++) {\n        sprintf(name, \"ipc:///tmp/blah%d.ipc\", i);\n        nn_connect(sock, name);\n    }\n}\nI have since decided to use different PIDs with priorities for the REQ/REP's which require accessing external information (in this case, libcurl to other webservers...)\nI will be sure to reopen this if i am able to cause anymore issues as I have reimplemented, and believe I'll create a main proxy to distribute throughout nanomsg workers for the duties required....\n. oh i forgot to mention the client didnt crash..so it's just the server side.... the nginx worker thread is still being debugged by gdb w out issue\n. typedef struct _nano_pkt {\n    int type;\n    int len;\n} NanoPkt;\nIm actually having several things happening on different threads now:\nAssertion failed: 0 (/data/nanomsg/src/transports/utils/streamhdr.c:284)\nAssertion failed: pipebase->instate == NN_PIPEBASE_INSTATE_IDLE (/data/nanomsg/src/core/pipe.c:171)\nProgram received signal SIGSEGV, Segmentation fault.\n0x00007f9dd3d71fe5 in ?? () from /lib/x86_64-linux-gnu/libc.so.6\n(gdb) bt\n0  0x00007f9dd3d71fe5 in ?? () from /lib/x86_64-linux-gnu/libc.so.6\n1  0x000000000046aad4 in dfuzzpkt (type=2, _len=0x7fffdf008c2c, extra=0x1d20770, extra_size=)\nat /usr/include/x86_64-linux-gnu/bits/string3.h:52\n\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (/data/nanomsg/src/utils/queue.c:78)\nAssertion failed: sipc->state == NN_SIPC_STATE_ACTIVE (/data/nanomsg/src/transports/ipc/sipc.c:162)\nI'll get you two test programs very soon.. i understand how hard it must be to reproduce.. and I'm actually running this on a production situation (personal project so its okay to have some crashes).... so it has high traffic happening....\nI'll work on getting you the code right now which is causing these issues...\n. Okay I have a test program for you to reproduce... \nhttp://easystyle.org/nano_testcase.tgz\nlet me know if you have any problems with it... I wasnt using pthread() originally.. it was coming from nginx... but i doubt that'll make any different...\nI've only saw:\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (/home/mike/nanomsg/src/utils/queue.c:78)\nso far...\nbut the others were coming from different threads whenever I had them running separate (not using pthread.. and manually starting a few servers..)\n. in the client.. i noticed if (len) is bad.. i fixed a crash where if the server didnt respond it didnt try to memcpy by changing to if (len > 0)\n... server side still getting those errors though.. just means client wont crash due to it\n. Assertion failed: self->state == NN_USOCK_STATE_ACTIVE (/data/nanomsg/src/aio/usock_posix.inc:361)\nthis is a different one that popped up..\nif you have issues getting the test case to provide you with all of these assertions.. lmk ill try to do what i can to get it to show more\n. i wonder if it has something to do with the packet sizes being much bigger... sometimes im returning 500k-1meg... ill do my best to reproduce some of the others...\n. Have you had a chance to reproduce using: http://easystyle.org/nano_testcase.tgz ?\nYou just type make and run the server and client... I figured it was easier than posting them all on here...\n. ## I see there were 0 downloads so ill paste anyways...\nutils.h\nifndef CDBHASH\ndefine CDBHASH\nunsigned int cdb_hashadd(unsigned int h,unsigned char c);\nunsigned int cdb_hash(const char *buf,unsigned int len);\nendif\nifndef NANOMSG\ndefine NANOMSG\ntypedef struct _nano_pkt {\n    int type;\n    int len;\n} NanoPkt;\nchar _nanoreq(char fmt, ...);\nchar nanoreqlen(int _len, char fmt, ...);\nendif\nifndef BASE64\ndefine BASE64\nchar base64_decode(char bufcoded, int_ len);\nchar base64_encode(unsigned char s, int len);\nendif\nifndef LINKEDLIST\ndefine LINKEDLIST\ntypedef struct _link { struct _link next; struct _link prev; } LINK;\nLINK _l_last(LINK start);\nLINK l_link(LINK _list, LINK _obj);\nLINK l_add(LINK _list, int size);\nvoid l_unlink(LINK _l_ptr, LINK rem);\nvoid l_del(LINK _l_ptr, LINK rem);\nint l_count(LINK l_ptr);\nendif\nifndef COMM\ndefine COMM\nenum {\n    GENREPLACE_REQ,\n    GENREPLACE_RESP,\n    FINDREP_REQ,\n    FINDREP_RESP,\n    FINAL_REQ,\n    FINAL_RESP,\n    ADREPLACE_REQ,\n    ADREPLACE_RESP,\n    NONE\n};\ntypedef struct _genreplace_req {\n    unsigned long addr;\n    unsigned long addr2;\n    char iso[4];\n    int width;\n    int height;\n    char ip[16];\n} Genreplace_Req;\ntypedef struct _genreplace_resp {\n    unsigned long addr;\n    char ip[16];\n    int feed_size;\n    int ref_size;\n    int ref2_size;\n    int width;\n    int height;\n} Genreplace_Resp;\ntypedef struct _findrep_req {\n    unsigned long addr;\n    int width;\n    int height;\n    int if_done;\n} Findrep_Req;\ntypedef struct _findrep_resp {\n    unsigned long addr;\n    unsigned long addr2;\n    int width;\n    int height;\n    int feed_size;\n    int ref_size;\n    int ref2_size;\n} Findrep_Resp;\ntypedef struct _final_req {\n    unsigned long addr;\n    int width;\n    int height;\n} Final_Req;\ntypedef struct _adreplace_req {\n    unsigned long addr;\n    int url_len;\n    int ref_len;\n    int agent_len;\n} Adreplace_Req;\ntypedef struct _adreplace_resp {\n    int content_length_size;\n    int data_size;\n    int http_code;\n} Adreplace_Resp;\nendif\n\nclient.c\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ntypedef struct _nano_pkt {\n    int type;\n    int len;\n} NanoPkt;\nenum {\n    CONTACT,\n    COMPLETE,\n    EXCEPTION,\n    CONTACT_RESP,\n    COMPLETE_RESP,\n    EXCEPTION_RESP,\n    NONE\n};\nchar dfuzzpkt(int type, int _len, void extra, int extra_size) {\n    NanoPkt pkthdr;\n    char ret = NULL;\n    int msg_sock = 0;\n    int len = 0;\n    void data = NULL;\n    void out_data = NULL;\n    int out_size = 0;\n    char ptr;\n    int value=1000;\n    int prio=1;\n    char ipc[1024];\n    int sret, rret;\n```\nout_data = (void )malloc(sizeof(NanoPkt) + extra_size + 1);\nif (out_data == NULL) return NULL;\nptr = (char )out_data;\npkthdr = (NanoPkt *)ptr;\nptr += sizeof(NanoPkt);\npkthdr->type = type;\npkthdr->len = sizeof(NanoPkt) + extra_size;\nif (extra_size) {\n    memcpy(ptr, extra, extra_size);\n    ptr += extra_size;\n}\nout_size = ptr - (char *)out_data;\nif ((msg_sock = nn_socket(AF_SP, NN_REQ)) < 0) goto end;\nnn_setsockopt(msg_sock, NN_SOL_SOCKET, NN_SNDTIMEO, &value, sizeof(value));\nvalue *= 2;\nnn_setsockopt(msg_sock, NN_SOL_SOCKET, NN_RCVTIMEO, &value, sizeof(value));\nfor (prio = 1; prio < 10; prio++) {\n    sprintf(ipc, \"ipc:///tmp/blah%d.ipc\", prio);\n    nn_setsockopt (msg_sock, NN_SOL_SOCKET, NN_SNDPRIO, &prio, sizeof (int));\n    nn_connect(msg_sock, ipc);\n}\n//if (nn_connect(msg_sock, \"ipc:///tmp/dfuzz.ipc\") < 0) goto end;\nsret = nn_send(msg_sock, out_data, out_size, 0);\nlen = rret = nn_recv(msg_sock, &data, NN_MSG, 0);\n*_len = len;\nif (len > 0) {\n    ret = (char *)malloc(len + 1);\n    if (ret == NULL) return NULL; // fatal should exit...\n    memcpy(ret, data, len);\n    nn_freemsg(data);\n}\n```\nend:;\n    if (msg_sock) nn_close(msg_sock);\n    return ret;\n}\nint contact_function() {\n    char *buf = NULL;\n    int buf_len = 0;\n    int ret = 0;\n```\nbuf = (char *)dfuzzpkt(CONTACT, &buf_len, NULL, 0);\n// there is no structure for buf here.. it is sent directly to a client through a webserver...\nif (buf == NULL) {\n    printf(\"buf NULL from CONTACT request\\n\");\n    ret = -1;\n} else ret = 1;\nprintf(\"contact function = %d [buf %p len %d]\\n\", ret, buf, buf_len);\nif (buf != NULL) free(buf);\nreturn ret;\n```\n}\ntypedef struct _complete_op {\n    int operation_id;\n    int queue_id;\n    int sample_id;\n    int mode;\n    int byte;\n    int count;\n} CompleteOp;\nint report_function() {\n    char buf = NULL;\n    int buf_len = 0;\n    CompleteOp cptr = NULL;\n    int ret = 0;\n```\nif ((cptr = (CompleteOp *)malloc(sizeof(CompleteOp) + 1)) == NULL) {\n    printf(\"memory allocation error\\n\");\n    return -1;\n}\ncptr->operation_id = 1;\ncptr->queue_id = 1;\ncptr->sample_id = 1;\ncptr->mode = 0;\ncptr->byte=0;\ncptr->count=16;\nbuf = (char *)dfuzzpkt(COMPLETE, &buf_len, cptr, sizeof(CompleteOp));\nif (buf == NULL) {\n    printf(\"null buf from report complete request packet\\n\");\n    ret = -1;\n} else ret = 1;\n// it's really irrelevant.. buf is always going to be (char *)\"null\" anyways\n// then goes to client...\nprintf(\"complete function = %d [buf %p len %d]\\n\", ret, buf, buf_len);\nif (buf != NULL) free(buf);\nreturn 1;\n```\n}\ntypedef struct _exception_op {\n    int operation_id;\n    int queue_id;\n    int sample_id;\n    int mode;\n    int byte;\n    char exception_address[24];\n    char exception_code[24];\n    char newbyte[24];\n} ExceptionOp;\nint exception_function() {\n    char buf = NULL;\n    int buf_len = 0;\n    ExceptionOp cptr = NULL;\n    char *ptr;\n    int ret = 0;\n```\nif ((cptr = (ExceptionOp *)malloc(sizeof(ExceptionOp) + 1)) == NULL) {\n    printf(\"error allocating memory for structure\\n\");\n    return -1;\n}\nmemset(cptr, 0, sizeof(ExceptionOp));\ncptr->queue_id = 1;\ncptr->sample_id = 1;\ncptr->mode = 0;\ncptr->byte = 10;\ncptr->operation_id = 1;\nstrncpy(cptr->exception_address, \"0xdeadbeef\", 24);\nstrncpy(cptr->exception_code, \"c00000005\", 24);\nstrncpy(cptr->newbyte, \"0\", 24);\nif (!cptr->operation_id || !cptr->queue_id || !cptr->sample_id)\n    return -1;\nbuf = (char *)dfuzzpkt(EXCEPTION, &buf_len, cptr, sizeof(ExceptionOp));\nif (buf == NULL) {\n    printf(\"error getting response from exception req to nanomsg server\\n\");\n    ret = -1;\n} else ret = 1;\nfree(cptr);\n// sends buf to client.. nothing more to do....\nprintf(\"exception_function = %d [buf %p len %d]\\n\", ret, buf, buf_len);\nif (buf != NULL) free(buf);\nreturn ret;\n```\n}\nvoid testone() {\n    int r = rand()%3;\n```\nif (r == 0) {\n    exception_function();\n} else if (r == 1) {\n    contact_function();\n} else {\n    report_function();\n}\n```\n}\nvoid ClientStressThread(void tid) {\n    srand(time(0));\n    testone();\n    pthread_exit(NULL);\n}\nint main(int argc, char *argv[]) {\n    int ret = 0;\n    pthread_t threads[1024];\n    int cthread_ret;\n    int t;\n```\nsrand(time(0));\nfor (t = 0; t < 32; t++) {\n    cthread_ret = pthread_create(&threads[t], NULL, ClientStressThread, (void *)t);\n    if (cthread_ret) {\n        printf(\"error creating a thread... err %d\\n\", cthread_ret);\n        exit(-1);\n    }\n}\nwhile (1) {\n    testone();\n}\n```\n}\n\nserver.c\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ntypedef struct _queue {\n    struct _queue *next;\n    int id;\n    char application[25];\n    char version[25];\n    int ts;\n    char ip[16];\n    char hash[64];\n    int sample_id;\n    int byte;\n    int mode;\n    int count;\n    int complete;\n    int operation_id;\n    int timeout;\n} Queue;\nQueue *queue = NULL;\nQueue GetQueue(void irrelevant);\nenum {\n    CONTACT,\n    COMPLETE,\n    EXCEPTION,\n    CONTACT_RESP,\n    COMPLETE_RESP,\n    EXCEPTION_RESP,\n    NONE\n};\ntypedef struct _nano_pkt {\n    int type;\n    int len;\n} NanoPkt;\ntypedef struct _client_op {\n    int operation_id;\n    char application[25];\n    char version[25];\n    int byte;\n    int count;\n    int mode;\n    int queue_id;\n    int sample_id;\n    int sample_size;\n} ClientOp;\nvoid nginx_contact(unsigned char _pkt, unsigned char _ret, int ret_len) {\n    NanoPkt pkthdr = NULL;\n    Queue qptr = NULL;\n    void _ret = NULL;\n    char fake_sptr_data = \"null\";\n    int fake_sptr_data_size = 4;\n```\nqptr = GetQueue(NULL);\nif (qptr == NULL) return;\n// some stuff omitted.. irrelevant...\n// yay we have an operation.. lets get the data to the client\n_ret = (void *)malloc(sizeof(NanoPkt) + sizeof(ClientOp) + fake_sptr_data_size + 1);\nif (_ret == NULL) return;\npkthdr = (NanoPkt *)_ret;\npkthdr->type = CONTACT_RESP;\npkthdr->len = sizeof(NanoPkt) + sizeof(ClientOp) + fake_sptr_data_size;\nClientOp clientop = (ClientOp )(_ret + sizeof(NanoPkt));\nstrncpy(clientop->application, qptr->application, 24);\nclientop->operation_id = 1;\nclientop->byte = qptr->byte;\nclientop->count = qptr->count;\nclientop->mode = qptr->mode;\nclientop->queue_id = qptr->id;\nclientop->sample_id = qptr->sample_id;\nclientop->sample_size = fake_sptr_data_size;\nmemcpy(_ret + sizeof(NanoPkt) + sizeof(ClientOp), fake_sptr_data, fake_sptr_data_size);\n// qptr doesnt have to be freed... its in linked list for later\nret = (unsigned char )_ret;\n*ret_len = pkthdr->len;\nreturn;\n```\n}\ntypedef struct _complete_op {\n    int operation_id;\n    int queue_id;\n    int sample_id;\n    int mode;\n    int byte;\n    int count;\n} CompleteOp;\nvoid nginx_complete(unsigned char _pkt, unsigned char _ret, int ret_len) {\n    NanoPkt pkthdr;\n    CompleteOp cptr;\n    Queue *qptr;\n```\npkthdr = (NanoPkt *)pkt;\nif (pkthdr->len != (sizeof(NanoPkt) + sizeof(CompleteOp))) return;\ncptr = (CompleteOp *)(pkt + sizeof(NanoPkt));\n// just does some internal stuff unrelated to nanomsg...\n// still doesnt return any data either with ret/ret_len\nreturn;\n```\n}\ntypedef struct _exception_op {\n    int operation_id;\n    int queue_id;\n    int sample_id;\n    int mode;\n    int byte;\n    char exception_address[23];\n    char exception_code[23];\n    char newbyte[23];\n} ExceptionOp;\nvoid nginx_exception(unsigned char _pkt, unsigned char _ret, int ret_len) {\n    NanoPkt pkthdr;\n    ExceptionOp eptr;\n    Queue *qptr;\n```\npkthdr = (NanoPkt *)pkt;\nif (pkthdr->len != (sizeof(NanoPkt) + sizeof(ExceptionOp))) return;\n// the real app doesn't return anytrhing to ret or ret_len..\n// it was just to log reported data\nreturn;\n// nothing else in this function had much to do with nanomsg...\n```\n}\nstruct packet_types {\n    int type;\n    void (_func)(unsigned char , unsigned char , int *);\n} Commands[] = {\n    { CONTACT, &nginx_contact },\n    { COMPLETE, &nginx_complete },\n    { EXCEPTION, &nginx_exception },\n    { 0, NULL }\n};\n// generates a sample for an operation if there arent any that exist already which are not exhausted....\nQueue GetQueue(void optr) {\n    Queue *qptr = NULL;\n    int bytes = 0;\n```\n// create fake queue just for nanomsg testing...\nif ((qptr = (Queue *)malloc(sizeof(Queue) + 1)) == NULL) return NULL;\nmemset(qptr, 0, sizeof(Queue));\nqptr->operation_id = 1;\nqptr->ts=time(0);\nqptr->sample_id = 1;\nqptr->byte= 0;\nqptr->count = bytes;\nqptr->mode = 0;\nstrcpy(qptr->application, \"null\");\nstrcpy(qptr->version, \"null\");\n// usually add qptr to linked list for later use...\nreturn qptr;\n```\n}\nint listenipc(int ipc_num) {\n    void data = NULL;\n    int r_len = 0;\n    int timeout = 1000;\n    unsigned char s_data = NULL;\n    int s_len = 0;\n    int s;\n    int a;\n    int len;\n    int _time=time(0);\n    char file[1024];\n    char ipc[1024];\n    int i;\n    NanoPkt *pkthdr = NULL;\n```\nipc_num++;\nsprintf(file, \"/tmp/blah%d.ipc\", ipc_num);\nsprintf(ipc, \"ipc:///tmp/blah%d.ipc\", ipc_num);\n// initialize mysql\n//mysql_reopen();\n//Operations_Load();\n//Complete_Load();\n//Queue_Load();\n//Samples_Load();\ns = nn_socket(AF_SP, NN_REP);\nnn_setsockopt(s, NN_REP, NN_RCVTIMEO, &timeout, sizeof(timeout));\nnn_setsockopt(s, NN_REP, NN_SNDTIMEO, &timeout, sizeof(timeout));\na = nn_bind(s, ipc);\nchmod(file, 0777);\nprintf(\"Bound to IPC: %s\\n\", ipc);\n_time = time(0);\nwhile (1) {\n    s_len = 0;\n    s_data = NULL;\nlen = nn_recv(s, &data, NN_MSG, 0);\n\nif (data && ((unsigned)len >= (unsigned)sizeof(NanoPkt))) {\n    // do whatever with data here... always be sure to set s_data, and s_len\n    pkthdr = (NanoPkt *)data;\n\n    for (i = 0; Commands[i].func != NULL; i++) {\n        if (pkthdr->type == Commands[i].type) {\n            (*Commands[i].func)((unsigned char *)data, &s_data, &s_len);\n        }\n    }\n\n\n    // just in case something went wrong.. we have to return something or we will force a stall\n    if (s_data == NULL || !s_len) {\n        nn_send(s, \"NULL\", 4, 0);\n    } else {\n        nn_send(s, s_data, s_len, 0);\n        free(s_data);\n    }\n    nn_freemsg(data);\n    data = NULL;\n}\n\nif ((time(0) - _time) > 10) {\n    _time = time(0);\n    // CheckQueue();\n}\n\n}\nnn_close(s);\n```\n}\nvoid ServerStressThread(void tid) {\n    int thread_id = (int)tid;\n    srand(time(0));\n    listenipc((int)thread_id);\n    pthread_exit(NULL);\n}\nint main(int argc, char *argv[]) {\n    int ret = 0;\n    pthread_t threads[1024];\n    int cthread_ret;\n    int t;\n```\nsrand(time(0));\nfor (t = 1; t < 10; t++) {\n    cthread_ret = pthread_create(&threads[t], NULL, ServerStressThread, (void *)t);\n    if (cthread_ret) {\n        printf(\"error creating a thread... err %d\\n\", cthread_ret);\n        exit(-1);\n    }\n}\nwhile (1) {\n    listenipc(0);\n}\n```\n}\n. will do ! next time ill make as minimal/brief as possible :)\n. any idea of eta?\n. ",
    "gonzus": "I am almost sure I have the latest code. Here is what I did:\n1. I forked the nanomsg repo to my Github account, setting the default branch to be aio2.\n2. I cloned that repo to my local Win32 and Linux environment.\n3. My local environments are both up to date in regards to my Github fork; they say:\n$ git status\nOn branch aio2\nnothing to commit (working directory clean)\n1. My Github fork has a message saying \"This branch is 0 commits ahead and 0 commits behind aio2\".\nLet me ask three questions:\n1. Am I correct in believing I am up to date in both my Github fork and my local copies?\n2. If my Github fork was not up to date, how would I refresh it? I could not find a way to do a pull (not fork) from the Github page.\n3. If this the correct way (forking on Github, cloning that fork to my local environment) to work with nanomsg?\nBest regards.\n\nGonzalo Diethelm\nDCV Chile\nFrom: sustrik [mailto:notifications@github.com]\nSent: Thursday, June 27, 2013 8:07 AM\nTo: 250bpm/nanomsg\nCc: Gonzalo Diethelm\nSubject: Re: [nanomsg] inproc_lat and incproc_thr perf tests assert on Linux and Win32 (#71)\nYou may have a slightly old version of nanomsg. The latest version (aio2 branch) seems not to fail. Can you confirm?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/issues/71#issuecomment-20113790.\n\nDeclaraci\u00f3n de confidencialidad: Este Mensaje esta destinado para\nel uso de la o las personas o entidades a quien ha sido dirigido y\npuede contener informaci\u00f3n reservada y confidencial que no puede\nser divulgada, difundida, ni aprovechada en forma alguna. El uso no\nautorizado de la informaci\u00f3n contenida en este correo podr\u00e1 ser\nsancionado de conformidad con la ley chilena. \nSi usted ha recibido este correo electr\u00f3nico por error, le pedimos\neliminarlo junto con los archivos adjuntos y avisar inmediatamente\nal remitente, respondiendo este mensaje. \n\"Before printing this e-mail think if is really necesary\".\nDisclosure: This Message is to be used by the individual,\nindividuals or entities that it is addressed to and may include\nprivate and confidential information that may not be disclosed,\nmade public nor used in any way at all. Unauthorized use of the\ninformation in this electronic mail message may be subject to the\npenalties set forth by Chilean law. \nIf you have received this electronic mail message in error, we ask\nyou to destroy the message and its attached file(s) and to\nimmediately notify the sender by answering this message. \n. OK, thanks. I followed the instructions provided for libzmq at http://www.zeromq.org/docs:contributing and did a \u201cgit pull --rebase nanomsg master\u201d, that seems to have brought me up to date. I am compiling now, will report back.\n\nGonzalo Diethelm\nDCV Chile\nFrom: sustrik [mailto:notifications@github.com]\nSent: Thursday, June 27, 2013 8:29 AM\nTo: 250bpm/nanomsg\nCc: Gonzalo Diethelm\nSubject: Re: [nanomsg] inproc_lat and incproc_thr perf tests assert on Linux and Win32 (#71)\nAs for the questions, if you want to update your local copy, just do \"git pull origin\".\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/issues/71#issuecomment-20114791.\n\nDeclaraci\u00f3n de confidencialidad: Este Mensaje esta destinado para\nel uso de la o las personas o entidades a quien ha sido dirigido y\npuede contener informaci\u00f3n reservada y confidencial que no puede\nser divulgada, difundida, ni aprovechada en forma alguna. El uso no\nautorizado de la informaci\u00f3n contenida en este correo podr\u00e1 ser\nsancionado de conformidad con la ley chilena. \nSi usted ha recibido este correo electr\u00f3nico por error, le pedimos\neliminarlo junto con los archivos adjuntos y avisar inmediatamente\nal remitente, respondiendo este mensaje. \n\"Before printing this e-mail think if is really necesary\".\nDisclosure: This Message is to be used by the individual,\nindividuals or entities that it is addressed to and may include\nprivate and confidential information that may not be disclosed,\nmade public nor used in any way at all. Unauthorized use of the\ninformation in this electronic mail message may be subject to the\npenalties set forth by Chilean law. \nIf you have received this electronic mail message in error, we ask\nyou to destroy the message and its attached file(s) and to\nimmediately notify the sender by answering this message. \n. I must admit I am not sure how to make it work with my own FORK of nanomsg and a local CLONE of my fork. I just obliterated my local clone and directly cloned the 250bpm nanomsg repo. With that, all tests run on Win32.\nI will do some more testing and then close the issues.\nThanks and regards,\n\nGonzalo Diethelm\nDCV Chile\nFrom: sustrik [mailto:notifications@github.com]\nSent: Thursday, June 27, 2013 8:29 AM\nTo: 250bpm/nanomsg\nCc: Gonzalo Diethelm\nSubject: Re: [nanomsg] inproc_lat and incproc_thr perf tests assert on Linux and Win32 (#71)\nAs for the questions, if you want to update your local copy, just do \"git pull origin\".\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/issues/71#issuecomment-20114791.\n\nDeclaraci\u00f3n de confidencialidad: Este Mensaje esta destinado para\nel uso de la o las personas o entidades a quien ha sido dirigido y\npuede contener informaci\u00f3n reservada y confidencial que no puede\nser divulgada, difundida, ni aprovechada en forma alguna. El uso no\nautorizado de la informaci\u00f3n contenida en este correo podr\u00e1 ser\nsancionado de conformidad con la ley chilena. \nSi usted ha recibido este correo electr\u00f3nico por error, le pedimos\neliminarlo junto con los archivos adjuntos y avisar inmediatamente\nal remitente, respondiendo este mensaje. \n\"Before printing this e-mail think if is really necesary\".\nDisclosure: This Message is to be used by the individual,\nindividuals or entities that it is addressed to and may include\nprivate and confidential information that may not be disclosed,\nmade public nor used in any way at all. Unauthorized use of the\ninformation in this electronic mail message may be subject to the\npenalties set forth by Chilean law. \nIf you have received this electronic mail message in error, we ask\nyou to destroy the message and its attached file(s) and to\nimmediately notify the sender by answering this message. \n. It works on Win32 with latest head.\n. It works on Win32 with latest head.\n. It works on Win32 with latest head.\n. Yes, closing.\n. ",
    "mkoppanen": "Inconsistent DLL linkage comes when dllexport/dllimport don't match for the symbol. I imagine this happens because the nanomsg library exports the symbol with NN_EXPORT and the direct include in tests/symbol.c brings in the same symbol with different linkage.\nCan you try removing the include of ../src/core/symbol.c from the test/symbol.c and recompiling? \n. Does the following patch work: https://gist.github.com/mkoppanen/4376897546ccea49a099\nIt just adds forward declarations for the inline functions, but seems to fix the issue locally for me.\n. @madscientist42,\nto me autotools has always been easier when it comes to cross-compiling (mainly arm linux targets). I've been using both zeromq and nanomsg for quite a long time on arm and been compiling on Mac OS X without larger hassles.\nI started reading this: http://www.cmake.org/Wiki/CMake_Cross_Compiling and it seems that there is quite a lot involved in cross-compiling using CMake. Do I understand correctly that each new platform / toolchain requires a new target (i.e. .cmake file)?\n. @madscientist42,\nand to answer your question about platforms: Windows and Solaris (and variants) come into mind first. HP-UX and AIX are still quite common in certain industry sectors.\n. @madscientist42,\nI assume the latest one was referred to me. I wasn't implying that \"it isn't there\", rather you asked for non Linux/*BSD systems that are common in this space.\nAs for your comment on Visual Studio solution files: In the past I've noticed that managing the solution files creates a lot of unnecessary noise (when edited in Visual Studio). In addition to this you have different versions of solution files and migrations don't always go smoothly.\nAlso, the problem tends to be that Windows platform is not used by majority of the developers (which in turn causes Windows build files to be out of date if they require VS). I assume this is why CMake is used for Windows instead of the solution files.\n. ",
    "bbigras": "I got the Assertion failed: type == NN_EP_STOPPED (src/core/sock.c:751) error on Linux while doing make check but it doesn't happen every time. I had it about 2 times in 10 tries.\nUbuntu 10.04.4 LTS (32 bits)\nbbigras@ubuntu-machinage:~/nanomsg\u276d make check\nmake  tests/inproc tests/inproc_shutdown tests/ipc tests/ipc_shutdown tests/tcp tests/tcp_shutdown tests/pair tests/pubsub tests/reqrep tests/pipeline tests/survey tests/bus tests/block tests/shutdown tests/timeo tests/iovec tests/msg tests/prio tests/poll tests/device tests/emfile tests/domain tests/trie tests/list tests/hash tests/symbol tests/separation\nmake[1]: Entering directory `/home/bbigras/nanomsg'\nmake[1]: `tests/inproc' is up to date.\nmake[1]: `tests/inproc_shutdown' is up to date.\nmake[1]: `tests/ipc' is up to date.\nmake[1]: `tests/ipc_shutdown' is up to date.\nmake[1]: `tests/tcp' is up to date.\nmake[1]: `tests/tcp_shutdown' is up to date.\nmake[1]: `tests/pair' is up to date.\nmake[1]: `tests/pubsub' is up to date.\nmake[1]: `tests/reqrep' is up to date.\nmake[1]: `tests/pipeline' is up to date.\nmake[1]: `tests/survey' is up to date.\nmake[1]: `tests/bus' is up to date.\nmake[1]: `tests/block' is up to date.\nmake[1]: `tests/shutdown' is up to date.\nmake[1]: `tests/timeo' is up to date.\nmake[1]: `tests/iovec' is up to date.\nmake[1]: `tests/msg' is up to date.\nmake[1]: `tests/prio' is up to date.\nmake[1]: `tests/poll' is up to date.\nmake[1]: `tests/device' is up to date.\nmake[1]: `tests/emfile' is up to date.\nmake[1]: `tests/domain' is up to date.\nmake[1]: `tests/trie' is up to date.\nmake[1]: `tests/list' is up to date.\nmake[1]: `tests/hash' is up to date.\nmake[1]: `tests/symbol' is up to date.\nmake[1]: `tests/separation' is up to date.\nmake[1]: Leaving directory `/home/bbigras/nanomsg'\nmake  check-TESTS\nmake[1]: Entering directory `/home/bbigras/nanomsg'\nPASS: tests/inproc\nPASS: tests/inproc_shutdown\nPASS: tests/ipc\nAssertion failed: type == NN_EP_STOPPED (src/core/sock.c:751)\n/bin/bash: line 5: 15937 Aborted                 ${dir}$tst\nFAIL: tests/ipc_shutdown\nPASS: tests/tcp\nPASS: tests/tcp_shutdown\nPASS: tests/pair\nPASS: tests/pubsub\nPASS: tests/reqrep\nPASS: tests/pipeline\nPASS: tests/survey\nPASS: tests/bus\nPASS: tests/block\nPASS: tests/shutdown\nPASS: tests/timeo\nPASS: tests/iovec\nPASS: tests/msg\nPASS: tests/prio\nPASS: tests/poll\nPASS: tests/device\nPASS: tests/emfile\nPASS: tests/domain\nPASS: tests/trie\nPASS: tests/list\nPASS: tests/hash\nPASS: tests/symbol\nPASS: tests/separation\n======================================\n1 of 27 tests failed\nPlease report to nanomsg@freelists.org\n======================================\nmake[1]: *** [check-TESTS] Error 1\nmake[1]: Leaving directory `/home/bbigras/nanomsg'\nmake: *** [check-am] Error 2\nbbigras@ubuntu-machinage:~/nanomsg\u276d\n. I forgot to specify that I was using VC+ 2008 express in the bug report.\nI tried and had problems with Visual C++ 2010 express but I got rid of them by installing the SP1. It also worked with Visual C++ 2012 express.\nFor the record, here's the log with Visual C++ 2010 express (without SP1) (sorry it's in French)\n```\nD:\\nanomsg-0.1-alpha\\build>cmake ..\n-- Building for: Visual Studio 10\n-- The C compiler identification is MSVC 16.0.30319.1\n-- Check for working C compiler using: Visual Studio 10\n-- Check for working C compiler using: Visual Studio 10 -- broken\nCMake Error at C:/Program Files (x86)/CMake 2.8/share/cmake-2.8/Modules/CMakeTestCCompiler.cmake:61 (message):\n  The C compiler \"C:/Program Files (x86)/Microsoft Visual Studio\n  10.0/VC/bin/cl.exe\" is not able to compile a simple test program.\nIt fails with the following output:\nChange Dir: D:/nanomsg-0.1-alpha/build/CMakeFiles/CMakeTmp\nRun Build Command:C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\MSBuild.exe\n  cmTryCompileExec137121215.vcxproj /p:Configuration=Debug\n  /p:VisualStudioVersion=10.0\nMicrosoft (R) Build Engine, version 4.0.30319.17929\n[Microsoft .NET Framework, Version 4.0.30319.18052]\nCopyright (C) Microsoft Corporation.  Tous droits r\u00e9serv\u00e9s.\nLa g\u00e9n\u00e9ration a d\u00e9marr\u00e9 2013-08-21 10:37:23.\nProjet\n  \"D:\\nanomsg-0.1-alpha\\build\\CMakeFiles\\CMakeTmp\\cmTryCompileExec137121215.vcxproj\"\n  sur le noud 1 (cibles par d\u00e9faut).\nPrepareForBuild:\nCr\u00e9ation du r\u00e9pertoire \"cmTryCompileExec137121215.dir\\Debug\\\".\nCr\u00e9ation du r\u00e9pertoire \"D:\\nanomsg-0.1-alpha\\build\\CMakeFiles\\CMakeTmp\\Debug\\\".\n\nInitializeBuildStatus:\nCr\u00e9ation de \"cmTryCompileExec137121215.dir\\Debug\\cmTryCompileExec137121215.unsuccessfulbuild\", car \"AlwaysCreate\" a \u00e9t\u00e9 sp\u00e9cifi\u00e9.\n\nClCompile:\nC:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\CL.exe /c /Zi /W3 /WX- /Od /Ob0 /Oy- /D WIN32 /D _WINDOWS /D _DEBUG /D \"CMAKE_INTDIR=\\\"Debug\\\"\" /\n\nD _MBCS /Gm- /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Fo\"cmTryCompileExec137121215.dir\\Debug\\\" /Fd\"D:/nanomsg-0.1-alpha/build/CMakeFiles/CMakeTmp/D\nebug/cmTryCompileExec137121215.pdb\" /Gd /TC /analyze- /errorReport:queue testCCompiler.c\n    Compilateur d'optimisation Microsoft (R) 32\u00a0bits C/C++ version\u00a016.00.30319.01 pour 80x86\n    Copyright (C) Microsoft Corporation. Tous droits r\u00e9serv\u00e9s.\ncl /c /Zi /W3 /WX- /Od /Ob0 /Oy- /D WIN32 /D _WINDOWS /D _DEBUG /D \"CMAKE_INTDIR=\\\"Debug\\\"\" /D _MBCS /Gm- /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScop\n\ne /Fo\"cmTryCompileExec137121215.dir\\Debug\\\" /Fd\"D:/nanomsg-0.1-alpha/build/CMakeFiles/CMakeTmp/Debug/cmTryCompileExec137121215.pdb\" /Gd /TC /analyze- /errorRep\nort:queue testCCompiler.c\ntestCCompiler.c\n\nManifestResourceCompile:\nC:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v7.0A\\bin\\rc.exe /nologo /fo\"cmTryCompileExec137121215.dir\\Debug\\cmTryCompileExec137121215.exe.embed.manifest.\n\nres\" cmTryCompileExec137121215.dir\\Debug\\cmTryCompileExec137121215_manifest.rc\nLink:\nC:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\link.exe /ERRORREPORT:QUEUE /OUT:\"D:\\nanomsg-0.1-alpha\\build\\CMakeFiles\\CMakeTmp\\Debug\\cmTryCompi\n\nleExec137121215.exe\" /INCREMENTAL /NOLOGO kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib /\nMANIFEST /ManifestFile:\"cmTryCompileExec137121215.dir\\Debug\\cmTryCompileExec137121215.exe.intermediate.manifest\" /MANIFESTUAC:\"level='asInvoker' uiAccess='false\n'\" /DEBUG /PDB:\"D:/nanomsg-0.1-alpha/build/CMakeFiles/CMakeTmp/Debug/cmTryCompileExec137121215.pdb\" /SUBSYSTEM:CONSOLE /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:\"\nD:/nanomsg-0.1-alpha/build/CMakeFiles/CMakeTmp/Debug/cmTryCompileExec137121215.lib\" /MACHINE:X86 cmTryCompileExec137121215.dir\\Debug\\cmTryCompileExec137121215.e\nxe.embed.manifest.res\n    cmTryCompileExec137121215.dir\\Debug\\testCCompiler.obj  /machine:X86 /debug\nLINK : fatal error LNK1123: \u00dachec lors de la conversion en fichier COFF\u00e1:\n  fichier non valide ou endommag\u00da\n  [D:\\nanomsg-0.1-alpha\\build\\CMakeFiles\\CMakeTmp\\cmTryCompileExec137121215.vcxproj]\nG\u00e9n\u00e9ration du projet\n  \"D:\\nanomsg-0.1-alpha\\build\\CMakeFiles\\CMakeTmp\\cmTryCompileExec137121215.vcxproj\"\n  termin\u00e9e (cibles par d\u00e9faut) -- \u00c9CHEC.\n\u00c9CHEC de la build.\n\"D:\\nanomsg-0.1-alpha\\build\\CMakeFiles\\CMakeTmp\\cmTryCompileExec137121215.vcxproj\"\n  (cible par d\u00e9faut) (1) ->\n(Link cible) ->\nLINK : fatal error LNK1123: \u00dachec lors de la conversion en fichier COFF\u00e1: fichier non valide ou endommag\u00da [D:\\nanomsg-0.1-alpha\\build\\CMakeFiles\\CMakeTmp\\cm\n\nTryCompileExec137121215.vcxproj]\n  0 Avertissement(s)\n  1 Erreur(s)\n\nTemps \u00e9coul\u00e9 00:00:00.40\nCMake will not be able to correctly generate this project.\nCall Stack (most recent call first):\n  CMakeLists.txt:29 (project)\n-- Configuring incomplete, errors occurred!\n``\n. I was able to generate a MSVC2008 solution with thesimple-cmakebranch but I hadError: the Visual C++ Project Engine is not properly installed` when I was trying to build it.\nMy Visual C++ 2008 express installation was broken. I got rid of the error message by repairing VC and I realized that I was now able to generate a MSVC2008 solution with the master branch so I'm sorry that I wasted your time with this. I thought my installation was fine since python uses it often to build modules but I rarely use VC directly.\nI have some errors when trying to build it.\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\nIt seems stdint.h is not included in MSVC2008. See:\n- http://softwareramblings.com/2008/03/c-tr1-stdinth-still-missing-from-visual-studio.html\n- http://stackoverflow.com/questions/12970293/why-microsoft-visual-studio-cannot-find-stdint-h\nEven if I copy stdint.h from another Visual Studio version or if I download one I still have undeclared identifier errors like :\n2>..\\..\\src\\core\\symbol.c(108) : error C2065: 'ENOPROTOOPT' : undeclared identifier\nShould I open a new issue so people can find it easier?\nLog\n1>------ Skipped Build: Project: RUN_TESTS, Configuration: Debug Win32 ------\n1>Project not selected to build for this solution configuration \n2>------ Build started: Project: nanomsg, Configuration: Debug Win32 ------\n2>Compiling...\n2>tcp.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>stcp.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>ctcp.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>btcp.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>atcp.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>sipc.c\n2>ipc.c\n2>cipc.c\n2>bipc.c\n2>aipc.c\n2>sinproc.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>msgqueue.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>ins.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>inproc.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>cinproc.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>binproc.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>streamhdr.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>port.c\n2>literal.c\n2>iface.c\n2>Generating Code...\n2>Compiling...\n2>dns.c\n2>backoff.c\n2>d:\\nanomsg\\src\\aio\\../utils/clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>xsurveyor.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>xrespondent.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>surveyor.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>respondent.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>xreq.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>xrep.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>rep.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>req.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>trie.c\n2>d:\\nanomsg\\src\\protocols\\pubsub\\trie.h(27) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>sub.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>pub.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>xpair.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>pair.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>xpush.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>xpull.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>pull.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>push.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>xbus.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>Generating Code...\n2>Compiling...\n2>bus.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>priolist.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>lb.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>fq.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>excl.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>dist.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>wire.c\n2>d:\\nanomsg\\src\\utils\\wire.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>thread.c\n2>sleep.c\n2>sem.c\n2>random.c\n2>d:\\nanomsg\\src\\utils\\clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>queue.c\n2>mutex.c\n2>msg.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>list.c\n2>hash.c\n2>d:\\nanomsg\\src\\utils\\hash.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>glock.c\n2>err.c\n2>..\\..\\src\\utils\\err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n2>..\\..\\src\\utils\\err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n2>..\\..\\src\\utils\\err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n2>..\\..\\src\\utils\\err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n2>..\\..\\src\\utils\\err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n2>..\\..\\src\\utils\\err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n2>..\\..\\src\\utils\\err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n2>..\\..\\src\\utils\\err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n2>efd.c\n2>d:\\nanomsg\\src\\utils\\efd_win.inc(29) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>clock.c\n2>d:\\nanomsg\\src\\utils\\clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>Generating Code...\n2>Compiling...\n2>chunkref.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>chunk.c\n2>d:\\nanomsg\\src\\utils\\atomic.h(36) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>atomic.c\n2>d:\\nanomsg\\src\\utils\\atomic.h(36) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>alloc.c\n2>worker.c\n2>d:\\nanomsg\\src\\aio\\../utils/clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>usock.c\n2>d:\\nanomsg\\src\\aio\\../utils/clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>timerset.c\n2>d:\\nanomsg\\src\\aio\\../utils/clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>timer.c\n2>d:\\nanomsg\\src\\aio\\../utils/clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>pool.c\n2>d:\\nanomsg\\src\\aio\\../utils/clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>poller.c\n2>fsm.c\n2>d:\\nanomsg\\src\\aio\\../utils/clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>ctx.c\n2>d:\\nanomsg\\src\\aio\\../utils/clock.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>symbol.c\n2>..\\..\\src\\core\\symbol.c(108) : error C2065: 'ENOPROTOOPT' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(108) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(108) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [12]'\n2>..\\..\\src\\core\\symbol.c(114) : error C2065: 'ETIMEDOUT' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(114) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(114) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [10]'\n2>..\\..\\src\\core\\symbol.c(117) : error C2065: 'ECONNABORTED' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(117) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(117) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [13]'\n2>..\\..\\src\\core\\symbol.c(118) : error C2065: 'ECONNRESET' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(118) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(118) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [11]'\n2>..\\..\\src\\core\\symbol.c(119) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(119) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(119) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [13]'\n2>..\\..\\src\\core\\symbol.c(120) : error C2065: 'EMSGSIZE' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(120) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(120) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [9]'\n2>..\\..\\src\\core\\symbol.c(121) : error C2065: 'ENETRESET' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(121) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(121) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [10]'\n2>..\\..\\src\\core\\symbol.c(122) : error C2065: 'ENETUNREACH' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(122) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(122) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [12]'\n2>..\\..\\src\\core\\symbol.c(123) : error C2065: 'ENOTCONN' : undeclared identifier\n2>..\\..\\src\\core\\symbol.c(123) : error C2099: initializer is not a constant\n2>..\\..\\src\\core\\symbol.c(123) : warning C4047: 'initializing' : 'int' differs in levels of indirection from 'char [9]'\n2>device.c\n2>..\\..\\src\\core\\device.c(99) : error C2065: 'ENOPROTOOPT' : undeclared identifier\n2>..\\..\\src\\core\\device.c(108) : error C2065: 'ENOPROTOOPT' : undeclared identifier\n2>..\\..\\src\\core\\device.c(117) : error C2065: 'ENOPROTOOPT' : undeclared identifier\n2>..\\..\\src\\core\\device.c(126) : error C2065: 'ENOPROTOOPT' : undeclared identifier\n2>sockbase.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>sock.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>pipe.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>global.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>epbase.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>ep.c\n2>d:\\nanomsg\\src\\utils\\chunkref.h(30) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n2>Generating Code...\n2>Build log was saved at \"file://d:\\nanomsg\\build\\src\\nanomsg.dir\\Debug\\BuildLog.htm\"\n2>nanomsg - 89 error(s), 9 warning(s)\n3>------ Build started: Project: tcp_shutdown, Configuration: Debug Win32 ------\n4>------ Build started: Project: tcp, Configuration: Debug Win32 ------\n3>Compiling...\n5>------ Build started: Project: symbol, Configuration: Debug Win32 ------\n6>------ Build started: Project: survey, Configuration: Debug Win32 ------\n4>Compiling...\n5>Compiling...\n6>Compiling...\n3>tcp_shutdown.c\n6>survey.c\n4>tcp.c\n5>symbol.c\n3>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n3>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n3>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n3>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n3>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n3>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n3>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n3>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n3>Build log was saved at \"file://d:\\nanomsg\\build\\tcp_shutdown.dir\\Debug\\BuildLog.htm\"\n3>tcp_shutdown - 8 error(s), 0 warning(s)\n5>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n5>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n5>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n5>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n6>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n6>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n5>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n6>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n5>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n6>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n5>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n6>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n5>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n4>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n6>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n4>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n6>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n4>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n5>Build log was saved at \"file://d:\\nanomsg\\build\\symbol.dir\\Debug\\BuildLog.htm\"\n6>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n4>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n4>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n6>Build log was saved at \"file://d:\\nanomsg\\build\\survey.dir\\Debug\\BuildLog.htm\"\n4>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n4>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n4>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n4>Build log was saved at \"file://d:\\nanomsg\\build\\tcp.dir\\Debug\\BuildLog.htm\"\n4>tcp - 8 error(s), 0 warning(s)\n6>survey - 8 error(s), 0 warning(s)\n5>symbol - 8 error(s), 0 warning(s)\n7>------ Build started: Project: shutdown, Configuration: Debug Win32 ------\n7>Compiling...\n7>shutdown.c\n7>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n7>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n7>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n7>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n7>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n7>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n7>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n7>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n7>Build log was saved at \"file://d:\\nanomsg\\build\\shutdown.dir\\Debug\\BuildLog.htm\"\n8>------ Build started: Project: separation, Configuration: Debug Win32 ------\n9>------ Build started: Project: reqrep, Configuration: Debug Win32 ------\n7>shutdown - 8 error(s), 0 warning(s)\n10>------ Build started: Project: remote_thr, Configuration: Debug Win32 ------\n8>Compiling...\n9>Compiling...\n10>Compiling...\n9>reqrep.c\n8>separation.c\n10>remote_thr.c\n10>Compiling manifest to resources...\n10>Microsoft (R) Windows (R) Resource Compiler Version 6.1.6723.1\n10>Copyright (C) Microsoft Corporation.  All rights reserved.\n10>Linking...\n9>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n9>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n8>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n9>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n9>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n8>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n9>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n8>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n9>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n8>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n9>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n8>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n9>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n8>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n8>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n9>Build log was saved at \"file://d:\\nanomsg\\build\\reqrep.dir\\Debug\\BuildLog.htm\"\n8>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n10>LINK : fatal error LNK1104: cannot open file 'Debug\\nanomsg.lib'\n8>Build log was saved at \"file://d:\\nanomsg\\build\\separation.dir\\Debug\\BuildLog.htm\"\n10>Build log was saved at \"file://d:\\nanomsg\\build\\remote_thr.dir\\Debug\\BuildLog.htm\"\n10>remote_thr - 1 error(s), 0 warning(s)\n8>separation - 8 error(s), 0 warning(s)\n9>reqrep - 8 error(s), 0 warning(s)\n11>------ Build started: Project: remote_lat, Configuration: Debug Win32 ------\n11>Compiling...\n11>remote_lat.c\n11>d:\\nanomsg\\src\\utils\\stopwatch.h(28) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n11>Build log was saved at \"file://d:\\nanomsg\\build\\remote_lat.dir\\Debug\\BuildLog.htm\"\n11>remote_lat - 1 error(s), 0 warning(s)\n12>------ Build started: Project: pubsub, Configuration: Debug Win32 ------\n13>------ Build started: Project: prio, Configuration: Debug Win32 ------\n14>------ Build started: Project: poll, Configuration: Debug Win32 ------\n12>Compiling...\n13>Compiling...\n14>Compiling...\n12>pubsub.c\n13>prio.c\n14>poll.c\n15>------ Build started: Project: pipeline, Configuration: Debug Win32 ------\n15>Compiling...\n15>pipeline.c\n12>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n14>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n12>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n14>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n12>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n13>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n12>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n14>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n13>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n12>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n14>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n13>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n12>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n13>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n14>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n12>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n14>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n13>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n13>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n12>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n14>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n13>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n14>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n12>Build log was saved at \"file://d:\\nanomsg\\build\\pubsub.dir\\Debug\\BuildLog.htm\"\n13>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n14>Build log was saved at \"file://d:\\nanomsg\\build\\poll.dir\\Debug\\BuildLog.htm\"\n13>Build log was saved at \"file://d:\\nanomsg\\build\\prio.dir\\Debug\\BuildLog.htm\"\n12>pubsub - 8 error(s), 0 warning(s)\n13>prio - 8 error(s), 0 warning(s)\n14>poll - 8 error(s), 0 warning(s)\n15>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n16>------ Build started: Project: pair, Configuration: Debug Win32 ------\n17>------ Build started: Project: timeo, Configuration: Debug Win32 ------\n15>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n15>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n15>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n15>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n15>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n15>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n15>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n15>Build log was saved at \"file://d:\\nanomsg\\build\\pipeline.dir\\Debug\\BuildLog.htm\"\n15>pipeline - 8 error(s), 0 warning(s)\n18>------ Build started: Project: msg, Configuration: Debug Win32 ------\n17>Compiling...\n16>Compiling...\n18>Compiling...\n16>pair.c\n17>timeo.c\n18>msg.c\n19>------ Build started: Project: local_thr, Configuration: Debug Win32 ------\n19>Compiling...\n16>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n16>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n16>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n18>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n16>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n16>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n18>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n16>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n18>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n16>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n18>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n17>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n18>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n16>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n17>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n19>local_thr.c\n18>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n17>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n18>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n17>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n18>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n17>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n16>Build log was saved at \"file://d:\\nanomsg\\build\\pair.dir\\Debug\\BuildLog.htm\"\n17>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n18>Build log was saved at \"file://d:\\nanomsg\\build\\msg.dir\\Debug\\BuildLog.htm\"\n17>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n17>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n17>d:\\nanomsg\\src\\utils\\stopwatch.h(28) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n17>Build log was saved at \"file://d:\\nanomsg\\build\\timeo.dir\\Debug\\BuildLog.htm\"\n16>pair - 8 error(s), 0 warning(s)\n17>timeo - 9 error(s), 0 warning(s)\n18>msg - 8 error(s), 0 warning(s)\n19>d:\\nanomsg\\src\\utils\\stopwatch.h(28) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n19>Build log was saved at \"file://d:\\nanomsg\\build\\local_thr.dir\\Debug\\BuildLog.htm\"\n19>local_thr - 1 error(s), 0 warning(s)\n20>------ Build started: Project: local_lat, Configuration: Debug Win32 ------\n21>------ Build started: Project: list, Configuration: Debug Win32 ------\n22>------ Build started: Project: ipc_shutdown, Configuration: Debug Win32 ------\n20>Compiling...\n21>Compiling...\n22>Compiling...\n20>local_lat.c\n22>ipc_shutdown.c\n21>list.c\n22>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n21>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n21>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n22>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n21>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n22>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n21>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n22>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n20>Compiling manifest to resources...\n21>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n22>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n21>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n22>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n21>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n22>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n21>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n22>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n21>Build log was saved at \"file://d:\\nanomsg\\build\\list.dir\\Debug\\BuildLog.htm\"\n22>Build log was saved at \"file://d:\\nanomsg\\build\\ipc_shutdown.dir\\Debug\\BuildLog.htm\"\n22>ipc_shutdown - 8 error(s), 0 warning(s)\n21>list - 8 error(s), 0 warning(s)\n20>Microsoft (R) Windows (R) Resource Compiler Version 6.1.6723.1\n20>Copyright (C) Microsoft Corporation.  All rights reserved.\n23>------ Build started: Project: ipc, Configuration: Debug Win32 ------\n24>------ Build started: Project: iovec, Configuration: Debug Win32 ------\n20>Linking...\n25>------ Build started: Project: inproc_thr, Configuration: Debug Win32 ------\n23>Compiling...\n24>Compiling...\n25>Compiling...\n20>LINK : fatal error LNK1104: cannot open file 'Debug\\nanomsg.lib'\n20>Build log was saved at \"file://d:\\nanomsg\\build\\local_lat.dir\\Debug\\BuildLog.htm\"\n23>ipc.c\n24>iovec.c\n20>local_lat - 1 error(s), 0 warning(s)\n25>inproc_thr.c\n26>------ Build started: Project: inproc_shutdown, Configuration: Debug Win32 ------\n26>Compiling...\n26>inproc_shutdown.c\n24>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n24>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n24>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n23>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n24>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n23>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n24>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n23>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n24>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n23>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n24>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n24>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n23>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n23>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n23>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n23>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n25>d:\\nanomsg\\perf\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n25>d:\\nanomsg\\perf\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n23>Build log was saved at \"file://d:\\nanomsg\\build\\ipc.dir\\Debug\\BuildLog.htm\"\n25>d:\\nanomsg\\perf\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n25>d:\\nanomsg\\perf\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n25>d:\\nanomsg\\perf\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n24>Build log was saved at \"file://d:\\nanomsg\\build\\iovec.dir\\Debug\\BuildLog.htm\"\n25>d:\\nanomsg\\perf\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n25>d:\\nanomsg\\perf\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n26>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n25>d:\\nanomsg\\perf\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n26>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n25>d:\\nanomsg\\src\\utils\\stopwatch.h(28) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n26>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n25>Build log was saved at \"file://d:\\nanomsg\\build\\inproc_thr.dir\\Debug\\BuildLog.htm\"\n26>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n26>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n26>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n26>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n26>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n26>Build log was saved at \"file://d:\\nanomsg\\build\\inproc_shutdown.dir\\Debug\\BuildLog.htm\"\n26>inproc_shutdown - 8 error(s), 0 warning(s)\n24>iovec - 8 error(s), 0 warning(s)\n23>ipc - 8 error(s), 0 warning(s)\n25>inproc_thr - 9 error(s), 0 warning(s)\n27>------ Build started: Project: inproc_lat, Configuration: Debug Win32 ------\n28>------ Build started: Project: inproc, Configuration: Debug Win32 ------\n27>Compiling...\n29>------ Build started: Project: hash, Configuration: Debug Win32 ------\n30>------ Build started: Project: emfile, Configuration: Debug Win32 ------\n29>Compiling...\n30>Compiling...\n28>Compiling...\n28>inproc.c\n27>inproc_lat.c\n30>emfile.c\n29>hash.c\n30>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n30>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n30>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n30>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n30>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n30>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n30>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n29>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n30>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n29>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n29>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n29>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n27>d:\\nanomsg\\perf\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n28>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n29>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n28>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n27>d:\\nanomsg\\perf\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n29>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n28>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n27>d:\\nanomsg\\perf\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n30>Build log was saved at \"file://d:\\nanomsg\\build\\emfile.dir\\Debug\\BuildLog.htm\"\n29>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n28>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n27>d:\\nanomsg\\perf\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n29>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n28>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n27>d:\\nanomsg\\perf\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n29>d:\\nanomsg\\src\\utils\\hash.h(26) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n27>d:\\nanomsg\\perf\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n28>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n27>d:\\nanomsg\\perf\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n28>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n29>Build log was saved at \"file://d:\\nanomsg\\build\\hash.dir\\Debug\\BuildLog.htm\"\n27>d:\\nanomsg\\perf\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n28>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n27>d:\\nanomsg\\src\\utils\\stopwatch.h(28) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n28>Build log was saved at \"file://d:\\nanomsg\\build\\inproc.dir\\Debug\\BuildLog.htm\"\n27>Build log was saved at \"file://d:\\nanomsg\\build\\inproc_lat.dir\\Debug\\BuildLog.htm\"\n28>inproc - 8 error(s), 0 warning(s)\n27>inproc_lat - 9 error(s), 0 warning(s)\n30>emfile - 8 error(s), 0 warning(s)\n29>hash - 9 error(s), 0 warning(s)\n31>------ Build started: Project: domain, Configuration: Debug Win32 ------\n32>------ Build started: Project: device, Configuration: Debug Win32 ------\n31>Compiling...\n33>------ Build started: Project: trie, Configuration: Debug Win32 ------\n34>------ Build started: Project: bus, Configuration: Debug Win32 ------\n32>Compiling...\n33>Compiling...\n34>Compiling...\n31>domain.c\n32>device.c\n34>bus.c\n33>trie.c\n33>d:\\nanomsg\\src\\protocols\\pubsub\\trie.h(27) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory\n34>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n34>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n32>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n31>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n34>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n32>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n31>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n34>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n33>Build log was saved at \"file://d:\\nanomsg\\build\\trie.dir\\Debug\\BuildLog.htm\"\n32>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n34>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n31>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n32>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n34>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n31>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n34>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n32>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n31>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n34>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n32>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n31>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n32>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n31>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n31>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n32>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n33>trie - 1 error(s), 0 warning(s)\n34>Build log was saved at \"file://d:\\nanomsg\\build\\bus.dir\\Debug\\BuildLog.htm\"\n32>Build log was saved at \"file://d:\\nanomsg\\build\\device.dir\\Debug\\BuildLog.htm\"\n31>Build log was saved at \"file://d:\\nanomsg\\build\\domain.dir\\Debug\\BuildLog.htm\"\n32>device - 8 error(s), 0 warning(s)\n31>domain - 8 error(s), 0 warning(s)\n34>bus - 8 error(s), 0 warning(s)\n35>------ Build started: Project: block, Configuration: Debug Win32 ------\n35>Compiling...\n35>block.c\n35>d:\\nanomsg\\tests\\../src/utils/err.c(134) : error C2065: 'ENETRESET' : undeclared identifier\n35>d:\\nanomsg\\tests\\../src/utils/err.c(136) : error C2065: 'ENETUNREACH' : undeclared identifier\n35>d:\\nanomsg\\tests\\../src/utils/err.c(138) : error C2065: 'EHOSTUNREACH' : undeclared identifier\n35>d:\\nanomsg\\tests\\../src/utils/err.c(140) : error C2065: 'ENOTCONN' : undeclared identifier\n35>d:\\nanomsg\\tests\\../src/utils/err.c(142) : error C2065: 'EMSGSIZE' : undeclared identifier\n35>d:\\nanomsg\\tests\\../src/utils/err.c(144) : error C2065: 'ETIMEDOUT' : undeclared identifier\n35>d:\\nanomsg\\tests\\../src/utils/err.c(148) : error C2065: 'ECONNABORTED' : undeclared identifier\n35>d:\\nanomsg\\tests\\../src/utils/err.c(150) : error C2065: 'ECONNRESET' : undeclared identifier\n35>Build log was saved at \"file://d:\\nanomsg\\build\\block.dir\\Debug\\BuildLog.htm\"\n35>block - 8 error(s), 0 warning(s)\n36>------ Skipped Build: Project: check, Configuration: Debug Win32 ------\n36>Project not selected to build for this solution configuration \n37>------ Skipped Build: Project: INSTALL, Configuration: Debug Win32 ------\n37>Project not selected to build for this solution configuration \n========== Build: 0 succeeded, 34 failed, 2 up-to-date, 3 skipped ==========\n. I still got a 2>..\\..\\src\\protocols\\utils\\excl.c(46) : error C2065: 'EISCONN' : undeclared identifier but I got a commit ready.\n. I forgot to specify that with EISCONN fixed, it builds with Visual Studio 2008 express.\n========== Build: 35 succeeded, 0 failed, 0 up-to-date, 2 skipped ==========\n. I would prefer that you take a look at it since I'm not familiar with that type of stuff.\n. The patch is submitted under MIT license.\n. I ran both nanocat commands on a Linux machine and on my workstation at work.\nOn Linux, if I stop and restart the server one, the client start to receive the hello again. :)\nBut not on my workstation Windows 7 (64-bit).\nHere's the log with NN_PRINT_ERRORS=1. I restarted the server after the third 'hello'.\nserver\nC:\\Users\\bbigras> nanocat --pub --bind tcp://0.0.0.0:8861 --data hello --interval 1\nC:\\Users\\bbigras> nanocat --pub --bind tcp://0.0.0.0:8861 --data hello --interval 1\nnanomsg: socket.0: current_connections: 0\nnanomsg: socket.0: inprogress_connections: 0\nnanomsg: socket.0: current_snd_priority: 0\nnanomsg: socket.0: current_connections: 0\n(loop)\nclient\nC:\\Users\\bbigras> nanocat --sub --connect tcp://127.0.0.1:8861 --ascii\nhello\nhello\nhello\nnanomsg: socket.0: current_connections: 1\nnanomsg: socket.0: inprogress_connections: 0\nnanomsg: socket.0: current_snd_priority: 0\nnanomsg: socket.0: current_connections: 1\nnanomsg: socket.0: inprogress_connections: 0\nnanomsg: socket.0: current_snd_priority: 0\nnanomsg: socket.0: current_connections: 1\n(loop)\n. I tested 36b0c3dc92769d8b727a227b8f67963d6cc447ed with nanocat but when I restart the server I get Can't recv: Connection reset on the client. I don't know if it's intended since the last time I tested on Linux, the client was reconnecting automatically and started to receive 'hello' messages again.\nserver\nbatch\nD:\\Dev\\lib\\nanomsg>nanocat --pub --bind tcp://127.0.0.1:8861 --data hello --interval 1\nclient\nbatch\nD:\\Dev\\lib\\nanomsg>nanocat --sub --connect tcp://127.0.0.1:8861 --ascii\nhello\nhello\nhello\nhello\nCan't recv: Connection reset\n. That's perfect. Thanks.\n. I ran the two nanocat commands at the same time. If I restart the server one, the client begin again to get the 'hello' messages.\nI'll try the Go code if the Go binding module is not too out-of-date.\n. The Go code works as well.\nNote that I tested both the Go code and nanocat on Windows 10. I don't have access to a Window 7 machine anymore.\n. I think it fixed the problem.\nI have a couple of errors with tm, gmtime_r, strftime and time.\nShould I open a new issue?\nI already send a pull request for the rc that is defined more than once.\nErreur  5   error C2079: 'strtime' utilise une struct de 'tm' non d\u00e9fini   D:\\nanomsg\\src\\core\\global.c    884 1   nanomsg\nErreur  9   error C2079: 'strtime' utilise une struct de 'tm' non d\u00e9fini   D:\\nanomsg\\src\\core\\global.c    921 1   nanomsg\nErreur  10  error C2079: 'strtime' utilise une struct de 'tm' non d\u00e9fini   D:\\nanomsg\\src\\core\\global.c    957 1   nanomsg\nErreur  1   error C2086: 'int rc'\u00a0: red\u00e9finition  D:\\nanomsg\\src\\core\\global.c    190 1   nanomsg\n    17  IntelliSense\u00a0: identificateur \"gmtime_r\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    894 9   nanomsg\n    21  IntelliSense\u00a0: identificateur \"gmtime_r\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    931 9   nanomsg\n    25  IntelliSense\u00a0: identificateur \"gmtime_r\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    964 9   nanomsg\n    27  IntelliSense\u00a0: identificateur \"snprintf\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    985 23  nanomsg\n    18  IntelliSense\u00a0: identificateur \"strftime\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    895 9   nanomsg\n    22  IntelliSense\u00a0: identificateur \"strftime\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    932 9   nanomsg\n    26  IntelliSense\u00a0: identificateur \"strftime\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    965 9   nanomsg\n    16  IntelliSense\u00a0: identificateur \"time\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    893 9   nanomsg\n    20  IntelliSense\u00a0: identificateur \"time\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    930 9   nanomsg\n    24  IntelliSense\u00a0: identificateur \"time\" non d\u00e9fini   d:\\nanomsg\\src\\core\\global.c    963 9   nanomsg\n    13  IntelliSense\u00a0: impossible d'assigner une valeur de type \"void *\" \u00e0 une entit\u00e9 de type \"nn_sock *\"    d:\\nanomsg\\src\\core\\global.c    451 18  nanomsg\n    12  IntelliSense\u00a0: impossible d'assigner une valeur de type \"void *\" \u00e0 une entit\u00e9 de type \"nn_sock **\"   d:\\nanomsg\\src\\core\\global.c    211 16  nanomsg\n    14  IntelliSense\u00a0: impossible d'assigner une valeur de type \"void *\" \u00e0 une entit\u00e9 de type \"uint8_t *\"    d:\\nanomsg\\src\\core\\global.c    819 14  nanomsg\n    15  IntelliSense\u00a0: type incomplet non autoris\u00e9    d:\\nanomsg\\src\\core\\global.c    883 15  nanomsg\n    19  IntelliSense\u00a0: type incomplet non autoris\u00e9    d:\\nanomsg\\src\\core\\global.c    920 15  nanomsg\n    23  IntelliSense\u00a0: type incomplet non autoris\u00e9    d:\\nanomsg\\src\\core\\global.c    956 15  nanomsg\nAvertissement   7   warning C4013: 'gmtime_r' non d\u00e9fini(e)\u00a0; extern retournant int pris par d\u00e9faut  D:\\nanomsg\\src\\core\\global.c    895 1   nanomsg\nAvertissement   11  warning C4013: 'snprintf' non d\u00e9fini(e)\u00a0; extern retournant int pris par d\u00e9faut  D:\\nanomsg\\src\\core\\global.c    986 1   nanomsg\nAvertissement   8   warning C4013: 'strftime' non d\u00e9fini(e)\u00a0; extern retournant int pris par d\u00e9faut  D:\\nanomsg\\src\\core\\global.c    896 1   nanomsg\nAvertissement   6   warning C4013: 'time' non d\u00e9fini(e)\u00a0; extern retournant int pris par d\u00e9faut  D:\\nanomsg\\src\\core\\global.c    894 1   nanomsg\nAvertissement   2   warning C4267: 'fonction'\u00a0: conversion de 'size_t' en 'int', perte possible de donn\u00e9es    D:\\nanomsg\\src\\core\\global.c    643 1   nanomsg\nAvertissement   3   warning C4267: 'fonction'\u00a0: conversion de 'size_t' en 'int', perte possible de donn\u00e9es    D:\\nanomsg\\src\\core\\global.c    679 1   nanomsg\nAvertissement   4   warning C4267: 'fonction'\u00a0: conversion de 'size_t' en 'int', perte possible de donn\u00e9es    D:\\nanomsg\\src\\core\\global.c    778 1   nanomsg\n. I have a little bit experience with C but not much with threads.\nI'll give it a shot.\n. > Should this be closed?\nYes. There was a fix #186 in the commit but it got lost somehow.\n. Superseded by https://github.com/nanomsg/nanomsg/pull/188\n. It's weird. After a couple of times many .exe started to crash (not in the same way as on my work machine where the test would never finish).\n```\nC:\\Users\\Bruno\\nanomsg\\build [master]> ctest -V\nUpdateCTestConfiguration  from :C:/Users/Bruno/nanomsg/build/DartConfiguration.tcl\nUpdateCTestConfiguration  from :C:/Users/Bruno/nanomsg/build/DartConfiguration.tcl\nTest project C:/Users/Bruno/nanomsg/build\nConstructing a list of tests\nDone constructing a list of tests\nChecking test dependency graph...\nChecking test dependency graph end\ntest 1\n      Start  1: inproc\n1: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\inproc.exe\n1: Test timeout computed to be: 9.99988e+006\n1:\n1: This application has requested the Runtime to terminate it in an unusual way.\n1: Please contact the application's support team for more information.\n1: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n 1/29 Test  #1: inproc ...........................***Failed    2.38 sec\ntest 2\n      Start  2: inproc_shutdown\n2: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\inproc_shutdown.exe\n2: Test timeout computed to be: 9.99988e+006\n2:\n2: This application has requested the Runtime to terminate it in an unusual way.\n2: Please contact the application's support team for more information.\n2: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n 2/29 Test  #2: inproc_shutdown ..................***Failed    0.51 sec\ntest 3\n      Start  3: ipc\n3: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\ipc.exe\n3: Test timeout computed to be: 9.99988e+006\n 3/29 Test  #3: ipc ..............................   Passed    0.01 sec\ntest 4\n      Start  4: ipc_shutdown\n4: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\ipc_shutdown.exe\n4: Test timeout computed to be: 9.99988e+006\n 4/29 Test  #4: ipc_shutdown .....................   Passed    0.00 sec\ntest 5\n      Start  5: tcp\n5: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\tcp.exe\n5: Test timeout computed to be: 9.99988e+006\n5:\n5: This application has requested the Runtime to terminate it in an unusual way.\n5: Please contact the application's support team for more information.\n5: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n 5/29 Test  #5: tcp ..............................***Failed    0.33 sec\ntest 6\n      Start  6: tcp_shutdown\n6: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\tcp_shutdown.exe\n6: Test timeout computed to be: 9.99988e+006\n6:\n6: This application has requested the Runtime to terminate it in an unusual way.\n6: Please contact the application's support team for more information.\n6: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n 6/29 Test  #6: tcp_shutdown .....................***Failed    0.36 sec\ntest 7\n      Start  7: pair\n7: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\pair.exe\n7: Test timeout computed to be: 9.99988e+006\n7:\n7: This application has requested the Runtime to terminate it in an unusual way.\n7: Please contact the application's support team for more information.\n7: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n 7/29 Test  #7: pair .............................***Failed    0.21 sec\ntest 8\n      Start  8: pubsub\n8: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\pubsub.exe\n8: Test timeout computed to be: 9.99988e+006\n8:\n8: This application has requested the Runtime to terminate it in an unusual way.\n8: Please contact the application's support team for more information.\n8: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n 8/29 Test  #8: pubsub ...........................***Failed    0.38 sec\ntest 9\n      Start  9: reqrep\n9: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\reqrep.exe\n9: Test timeout computed to be: 9.99988e+006\n9:\n9: This application has requested the Runtime to terminate it in an unusual way.\n9: Please contact the application's support team for more information.\n9: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n 9/29 Test  #9: reqrep ...........................***Failed    0.20 sec\ntest 10\n      Start 10: pipeline\n10: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\pipeline.exe\n10: Test timeout computed to be: 9.99988e+006\n10:\n10: This application has requested the Runtime to terminate it in an unusual way.\n10: Please contact the application's support team for more information.\n10: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n10/29 Test #10: pipeline .........................***Failed    0.17 sec\ntest 11\n      Start 11: survey\n11: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\survey.exe\n11: Test timeout computed to be: 9.99988e+006\n11:\n11: This application has requested the Runtime to terminate it in an unusual way.\n11: Please contact the application's support team for more information.\n11: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n11/29 Test #11: survey ...........................***Failed    0.16 sec\ntest 12\n      Start 12: bus\n12: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\bus.exe\n12: Test timeout computed to be: 9.99988e+006\n12:\n12: This application has requested the Runtime to terminate it in an unusual way.\n12: Please contact the application's support team for more information.\n12: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n12/29 Test #12: bus ..............................***Failed    0.18 sec\ntest 13\n      Start 13: block\n13: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\block.exe\n13: Test timeout computed to be: 9.99988e+006\n13:\n13: This application has requested the Runtime to terminate it in an unusual way.\n13: Please contact the application's support team for more information.\n13: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n13/29 Test #13: block ............................***Failed    0.17 sec\ntest 14\n      Start 14: term\n14: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\term.exe\n14: Test timeout computed to be: 9.99988e+006\n14:\n14: This application has requested the Runtime to terminate it in an unusual way.\n14: Please contact the application's support team for more information.\n14: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n14/29 Test #14: term .............................***Failed    0.17 sec\ntest 15\n      Start 15: timeo\n15: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\timeo.exe\n15: Test timeout computed to be: 9.99988e+006\n15:\n15: This application has requested the Runtime to terminate it in an unusual way.\n15: Please contact the application's support team for more information.\n15: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n15/29 Test #15: timeo ............................***Failed    0.17 sec\ntest 16\n      Start 16: iovec\n16: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\iovec.exe\n16: Test timeout computed to be: 9.99988e+006\n16:\n16: This application has requested the Runtime to terminate it in an unusual way.\n16: Please contact the application's support team for more information.\n16: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n16/29 Test #16: iovec ............................***Failed    0.16 sec\ntest 17\n      Start 17: msg\n17: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\msg.exe\n17: Test timeout computed to be: 9.99988e+006\n17/29 Test #17: msg ..............................   Passed    0.03 sec\ntest 18\n      Start 18: prio\n18: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\prio.exe\n18: Test timeout computed to be: 9.99988e+006\n18:\n18: This application has requested the Runtime to terminate it in an unusual way.\n18: Please contact the application's support team for more information.\n18: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n18/29 Test #18: prio .............................***Failed    0.14 sec\ntest 19\n      Start 19: poll\n19: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\poll.exe\n19: Test timeout computed to be: 9.99988e+006\n19:\n19: This application has requested the Runtime to terminate it in an unusual way.\n19: Please contact the application's support team for more information.\n19: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n19/29 Test #19: poll .............................***Failed    0.17 sec\ntest 20\n      Start 20: device\n20: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\device.exe\n20: Test timeout computed to be: 9.99988e+006\n20:\n20: This application has requested the Runtime to terminate it in an unusual way.\n20: Please contact the application's support team for more information.\n20: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n20/29 Test #20: device ...........................***Failed    0.15 sec\ntest 21\n      Start 21: emfile\n21: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\emfile.exe\n21: Test timeout computed to be: 9.99988e+006\n21:\n21: This application has requested the Runtime to terminate it in an unusual way.\n21: Please contact the application's support team for more information.\n21: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n21/29 Test #21: emfile ...........................***Failed    0.16 sec\ntest 22\n      Start 22: domain\n22: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\domain.exe\n22: Test timeout computed to be: 9.99988e+006\n22:\n22: This application has requested the Runtime to terminate it in an unusual way.\n22: Please contact the application's support team for more information.\n22: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n22/29 Test #22: domain ...........................***Failed    0.19 sec\ntest 23\n      Start 23: trie\n23: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\trie.exe\n23: Test timeout computed to be: 9.99988e+006\n23/29 Test #23: trie .............................   Passed    0.00 sec\ntest 24\n      Start 24: list\n24: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\list.exe\n24: Test timeout computed to be: 9.99988e+006\n24/29 Test #24: list .............................   Passed    0.00 sec\ntest 25\n      Start 25: hash\n25: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\hash.exe\n25: Test timeout computed to be: 9.99988e+006\n25/29 Test #25: hash .............................   Passed    0.01 sec\ntest 26\n      Start 26: symbol\n26: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\symbol.exe\n26: Test timeout computed to be: 9.99988e+006\n26/29 Test #26: symbol ...........................   Passed    0.01 sec\ntest 27\n      Start 27: separation\n27: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\separation.exe\n27: Test timeout computed to be: 9.99988e+006\n27:\n27: This application has requested the Runtime to terminate it in an unusual way.\n27: Please contact the application's support team for more information.\n27: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n27/29 Test #27: separation .......................***Failed    2.32 sec\ntest 28\n      Start 28: zerocopy\n28: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\zerocopy.exe\n28: Test timeout computed to be: 9.99988e+006\n28:\n28: This application has requested the Runtime to terminate it in an unusual way.\n28: Please contact the application's support team for more information.\n28: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n28/29 Test #28: zerocopy .........................***Failed    2.38 sec\ntest 29\n      Start 29: shutdown\n29: Test command: C:\\Users\\Bruno\\nanomsg\\build\\Debug\\shutdown.exe\n29: Test timeout computed to be: 9.99988e+006\n29:\n29: This application has requested the Runtime to terminate it in an unusual way.\n29: Please contact the application's support team for more information.\n29: Address in use [156384717] (c:\\users\\bruno\\nanomsg\\src\\utils\\efd_win.inc:171)\n29/29 Test #29: shutdown .........................***Failed    2.75 sec\n24% tests passed, 22 tests failed out of 29\nTotal Test time (real) =  14.22 sec\nThe following tests FAILED:\n          1 - inproc (Failed)\n          2 - inproc_shutdown (Failed)\n          5 - tcp (Failed)\n          6 - tcp_shutdown (Failed)\n          7 - pair (Failed)\n          8 - pubsub (Failed)\n          9 - reqrep (Failed)\n         10 - pipeline (Failed)\n         11 - survey (Failed)\n         12 - bus (Failed)\n         13 - block (Failed)\n         14 - term (Failed)\n         15 - timeo (Failed)\n         16 - iovec (Failed)\n         18 - prio (Failed)\n         19 - poll (Failed)\n         20 - device (Failed)\n         21 - emfile (Failed)\n         22 - domain (Failed)\n         27 - separation (Failed)\n         28 - zerocopy (Failed)\n         29 - shutdown (Failed)\nErrors while running CTest\nC:\\Users\\Bruno\\nanomsg\\build [master]>\n```\n. I'm not familiar with locks on Windows.\nIs it possible to use gmtime_s like for \"without mingw\" https://github.com/nanomsg/nanomsg/blob/master/src/core/global.c#L85 ? It seems it's what we did for #186.\n. I think I found the problem. I'll test with the latest mingw-64 version and create a PR.\n. > It's strange because mingw claims to aim for posix level apis.\nYou were right, mingw has gmtime_r but it seems _POSIX_C_SOURCE now needs to be defined. \nIt's the case with gcc 5.1.0 and 5.2.0. _POSIX_C_SOURCE didn't need to be defined with 4.8.0 (if I remember the version number correctly).\n. > Could this actually hurt us by suppressing some features that are otherwise present?\nI have no idea.\n. ",
    "bartmeuris": "Still present on Ubuntu 12.04 LTS: (on master freshly pulled a few minutes ago)\nPASS: tests/ipc\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:816)\n/bin/bash: line 5: 30283 Aborted                 (core dumped) ${dir}$tst\n. Exactly the same problem on Ubuntu 12.04\nNote that on my system, from time to time test 4 (ipc_shutdown) succeeds, but most of the times fails. Check 9 (reqrep) and 20 (device) fail consistently.\n. ",
    "hlieberman": "Still present here, building 0.4-beta on Debian sid.\n. After investigating this more and recreating the Perl test in C, I believe that this is not actually a bug, and the problem is in the Perl XS code itself.\n. Splitting this ticket into pieces to track the different problems.\nThe test suite fails catastrophically on sparc due to dereferencing of an unaligned pointer.\nThanks to Jakub Wilk at Debian for helping to debug this.  His analysis below:\n```\n0  0xf7fa048c in nn_chunkref_size (self=self@entry=0x25351) at src/utils/chunkref.c:123\n1  0xf7fb0c9c in nn_sipc_send (self=0x25260, msg=0xffffd4dc) at src/transports/ipc/sipc.c:142\n2  0xf7f97938 in nn_pipe_send (self=0x25260, msg=msg@entry=0xffffd4dc) at src/core/pipe.c:188\n3  0xf7fa9a68 in nn_excl_send (self=0x24e38, msg=0xffffd4dc) at src/protocols/utils/excl.c:84\n4  0xf7f99470 in nn_sock_send (self=0x24ca0, msg=msg@entry=0xffffd4dc, flags=flags@entry=0) at src/core/sock.c:570\n5  0xf7f95b18 in nn_sendmsg (s=s@entry=0, msghdr=msghdr@entry=0xffffd58c, flags=flags@entry=0) at src/core/global.c:756\n6  0xf7f95d0c in nn_send (s=s@entry=0, buf=buf@entry=0x11480, len=len@entry=40, flags=flags@entry=0) at src/core/global.c:656\n7  0x00011004 in test_send_impl (line=line@entry=58, sock=sock@entry=0, data=data@entry=0x11480 \"0123456789012345678901234567890123456789\", file=0x112e0 \"tests/ipc.c\") at tests/testutil.h:112\n8  0x000109a0 in main () at tests/ipc.c:58\nThe line that triggers crash is:\n   nn_chunk_size (((struct nn_chunkref_chunk*) self)->chunk) :\n\nHere dereferencing fails catastrophically, because the pointer is unaligned (self=0x25351).\n```\n. Yup, that fixes it.  Patch will be cherry-picked into the next Debian release to go out in a couple days.  Thanks, sustrik!\n. Hey @sustrik, this was reintroduced by commit 23dfb299676243701a4128d2954ee9a123bcce60.  PR coming to fix it.\n. ",
    "jstasiak": "I can reliably reproduce it on Debian 6 and 7, the error is the same in both cases (nanomsg https://github.com/nanomsg/nanomsg/commit/d1f1d2e4b0e8f542ab927c630f8744782103e576):\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:818)\n/bin/bash: line 5: 13910 Aborted                 ${dir}$tst\nFAIL: tests/ipc_shutdown\n. ",
    "ryanbaylorkillea": "I have it on Arch (ArchBang to be precise). Line 818 of ipc_shutdown. I separated type == NN_EP_STOPPED from src == NN_SOCK_SRC_EP just to make sure that it was the type that was causing it. The version I am using is the nanomsg-0.4-beta.\nEDIT: Apparently not only was the type not right but so was the source. The type was NN_PIPE_OUT and the source was 0 which suggests that it was never initialized as this is not a possible state of the sock (according to the note at the top of sock.c).\n. ",
    "xinghc": "I have the same error with nanomsg-0.5.\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:830)\nAborted\nIt failed tests/ipc_shutdown.\nI did a quick test with https://github.com/wirebirdlabs/featherweight-nanomsg,\nthey seems fixed this issue already.\n. ",
    "masalap": "Hi,\nI had a similar problem using pubsub with tcp, where:\n- The publisher continuously sends \"large\" message (In my case, 4MB. it is necessary that the worker thread spent a significant amount of time on the sending task)\n\nThe subscribers loop:\n-- open the socket\n-- connect to the publisher\n-- receive a message\n-- close the socket\n\nI have the following assert on publisher:\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (../src/utils/queue.c:102)\nwhen nn_worker_task_term(&self->task_send); is executed, within nn_usock_term execution.\nMy problem seems to be solved adding:\nnn_worker_cancel(self->worker,&self->task_send);`\nin nn_usock_term\nThis behavior seems to confirm Garrett analysis.\nHope it can be useful to anybody.\nPietro. Aww I S\nIl 29 ago 2018 12:49, \"Dennis Klein\" notifications@github.com ha scritto:\nRebased and applied requested change.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/989#issuecomment-416909889, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AQawq31D3rRbkHaqxHfy1jIpXDb0QkdVks5uVnGvgaJpZM4WPkSl\n.\n. ",
    "jhawk28": "Have you read through server.org?\nJoshua\nOn Jul 15, 2013, at 8:17 AM, sustrik notifications@github.com wrote:\n\nBtw, to give you some context, I am not sure what is the right way to do versioning, so I was delaying the decision till the first release. Anyway, it's good to discuss the stuff with someone that actually has an opinion about the matter :)\n\u2014\nReply to this email directly or view it on GitHub.\n. Gotta love autocomplete\u2026. http://semver.org\n\nJoshua\nOn Jul 15, 2013, at 8:37 AM, sustrik notifications@github.com wrote:\n\nThe site doesn't seem to be available. What did you had in mind specifically?\n\u2014\nReply to this email directly or view it on GitHub.\n. This is a silly question, but what does it do?\n. \n",
    "bspe": "True. thanks for the reply.\n. thanks, this was my intention. \n. ",
    "mmlb": "mmendez534@gmail.com\n. ",
    "smmckay": "xmlto produces for me properly suffixed man pages (.3 and .7) rather than\nthe .man files expected by the rules. I know very little about asciidoc and\nxmlto, so I don't know for sure the reason for the discrepancy, so I wanted\nto keep that commit local. Serves me right for committing everything on\nmaster, I suppose.\nOn Wednesday, August 14, 2013, sustrik wrote:\n\nHi, What was the problem with manpage rules?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/250bpm/nanomsg/pull/92#issuecomment-22617400\n.\n. \n",
    "rcxdude": "No such device [19] (/home/rcxdude/sandbox/nanomsg/src/transports/tcp/ctcp.c:535)\n. ",
    "oswjk": "I am submitting the patch for inet_pton() implementation for Windows XP under the MIT license.\n(is it enough to state it in here? :-)\nAh, I didn't have a public email address set. That's corrected now. You can use oskari.timperi@iki.fi.\nAnd thanks for the GetQueuedCompletionStatus pointer. I'll look into that at some point.\n. I tried to have a look at this, but I'm not experienced enough on this stuff.\nI replaced the calls to CancelIoEx and GetQueuedCompletionStatusEx with their non-Ex counterparts which are available on Windows XP and got the code to compile. But of course the code does not work. It's said in MSDN that CancelIo can't be used to cancel io operations in other threads. So most of the tests hang on nn_close.\nWould there be a way to work around this limitation? I tried to google for similar things, but couldn't find any helpful examples. Could we wake up the worker thread using PostQueuedCompletionStatus and do a check or something?\n. ",
    "moteus": "inet_pton did not exists until Vista. so i think more correct ifdef:\n``` C\nif defined NN_HAVE_WINDOWS && ((_WIN32_WINNT < _WIN32_WINNT_VISTA) || (WINVER < _WIN32_WINNT_VISTA))\n// define inet_pton\nendif\n```\n. ",
    "ghost": "this problem still exists. Is there a way to hotfix the problem? \n. On a related note, git head doesn't compile on OS X maverick, auto tools is installed.\nMakefile.am:46: error: Libtool library used but 'LIBTOOL' is undefined\n. i followed those steps, same problem. then i found some receipt doing some glibtoolize magic, and i somehow got it work. dunno how. this build system is shit.\n. @gdamore Awesome - keep it up :) I hate the current build system.\n. Very sad to learn this effort is abandoned. Building nanomsg on certain OSX versions is nearly impossible.\nAutotools work? Only when it does. Sigh.\n. The path is submitted under MIT license\n. Can you describe the error you are getting ?\nWith the latest code I'm getting:\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED\n(....\\src\\core\\sock.c:816)\nI found it also mentioned at https://github.com/nanomsg/nanomsg/issues/234\nand looking into it now.\nOn 30 May 2014 19:19, sustrik notifications@github.com wrote:\n\nOK.\n\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/250#issuecomment-44669703.\n. From what I see the worker thread is processing a pipe io message while the\nendpoint is closing, the callback is forwarded to the nn_sock_shutdown fsm\nand it only expects the endpoint stop messages. Dropping messages from a\nsource different than NN_SOCK_SRC_EP while waiting for the endpoint\nshutdown could be a solution (and of course silents the assert) but I need\nto review the overall connection flow, maybe there was another mechanism\nfor dropping pending messages while the connection is closing, and it\ndidn't work as expected.\n\nOn 30 May 2014 21:20, Stan Mihai stanmihai4@gmail.com wrote:\n\nCan you describe the error you are getting ?\nWith the latest code I'm getting:\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED\n(....\\src\\core\\sock.c:816)\nI found it also mentioned at https://github.com/nanomsg/nanomsg/issues/234\nand looking into it now.\nOn 30 May 2014 19:19, sustrik notifications@github.com wrote:\n\nOK.\n\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/250#issuecomment-44669703.\n. Isn't this https://github.com/nanomsg/nanomsg/issues/75 ?\n\n\nSince it's mentioned to happen on both Windows and Linux.\nCurrently I'm having 100% reproduction rate (on Windows) and will get back\nlater today with a more detailed analysis.\nOn 2 June 2014 10:08, sustrik notifications@github.com wrote:\n\nThat's on the Solaris box, right? Note that it's a long-standing problem,\nnot a new one.\nThere are 3 possible causes:\n1. nanomsg doesn't work on Solaris\n2. nanomsg doesn't work on SPARC microarchitecture\n3. nanomsg doesn't work on very slow boxes\n\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/250#issuecomment-44807397.\n. That assert is triggered by outbound messages that are processed while the\nthe endpoint is shutting down.\nThe documentation says that they should be delivered, blocking the close\n(or shutdown) call for the NN_LINGER period.\n\nThe nn_close call is waiting for the outbound messages by waiting for all\nthe endpoints to close (though I don't yet have a clear understanding of\nhow outbound messages are processed).\nIn this time the socket fsm in in NN_FSM_STATE_STOPPING state, and the\nsocket in NN_SOCK_STATE_STOPPING_EPS.\nFrom what I understand, it should be still delivering mesages, but instead\nit asserts that the only fsm message it can get is NN_EP_STOPPED\nAlso I didn't find any implementation of the linger period.\nIs my understanding of the issue correct ?\nIf yes, I'll keep looking over how outgoing messages are processed and\nmaybe come up with a patch.\nOn 2 June 2014 11:36, sustrik notifications@github.com wrote:\n\nPossibly.\n\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/250#issuecomment-44813336.\n. tcpmux is incredibly useful, but buggy.\n\nIs there work being done in this area?\n. very very +1\n. @gdamore, I want to use it in the req/rep pattern, how it possible to implemented in cmsg API, I'm new to nanomsg but still need some hints here, to get source client ip?\n. Thanks, I'll read the code again for getting more info about who and when could increase it.\n. I forgot to mention that this happens sporadically. \n. Thanks!\n. What do you mean my reinitialize the library? A call to nn_term() in the child and create new sockets?\n. @gdamore, thanks! I will give it a try then! I am curious if there is going to be any added latency when pub subbing between processes (when a player is a moving around) -- I know there is probably something, but I wonder if it's even negligible. And I saw some benchmarks and I don't think I will ever surpass the msgs per second nanomsg provides... to be honest. \nI really wish I could just get player's connected onto the same node instance. But this is trivial without reconnecting them all the time... Much easier behind a load balancer and using ipc\n. See issue #653 as well.\n. ",
    "rafl": "I'm aware of those being POSIX error codes. The point of this ticket was to document which functions might cause errno to be set to any of those error codes, and what that means for that particular function, as is already done for many other POSIX error codes.\nExcept of course if no nanomsg function would ever result in errno set to any of these values, possibly because the error codes are only ever used internally. In that case, they probably shouldn't be made public at all (through nn_symbol, at least, but including nn.h should likely also not make them available).\n. Yes, many error codes returned from the individual nn_* functions are described in the man pages. However, the error constants I listed in the initial tickets aren't mentioned there. I'm suggesting for them to be mentioned and described in the documentation of the nn_* functions that might cause them, or made private (i.e. not listing them in nn_symbol and not defining them from nn.h), if there's no public function that could cause them to be returned.\n. I agree with your assessment.\n. ",
    "esmil": "Sure, where do I state that, in the commit message, here, or where in the source tree?\n. I sent a mail.\nBtw. all my future patches to nanomsg project are licensed under MIT license unless stated otherwise ;)\n. ",
    "tel": "I'm having trouble with autoconf on HEAD and can't spend the time pushing through it right now. I'll let you know as soon as I can test.\n. Confirm, latest trunk doesn't show this anymore.\n. Thanks!\n. ",
    "dbeck": "What happens on my computer is 'test_send (enda, \"ABC\");' in main() runs before the device1 thread has been started, so the error makes sense.\n. Thank you, Martin\nThis was my misunderstanding. I didn't realize that EP IDs are per socket.\nClosing this ticket.\n(I think the second parameter of nn_shutdown(s,how) is misleading though. eid may be a better name for the endpoint ID)\n. I may be wrong, but I thought the POSIX 'how' parameter is used for a different thing. Aren't we squeezing a different functionality into that?\n. OK. I didn't think about this interpretation. But, yes, sounds cool.\n. Will come back to your point in #114 \nI need to verify that\n. Your analysis is right. My solution to the first issue: ie 'state=2 source=27713 action=3' only hides the problem. Please don't pull this until I (or someone else) find the real solution.\n. ",
    "Amaury": "The issue occurs only using two (or more) threads. There is no thread creation in test/pipeline.c.\nHere is a little program that generates the error (on my machine, at least). If you call it with option \"-n 1\" (only one worker thread is created), it works. By default, two worker threads are created, and then it fails. If you call it with option \"-d\", there is no PUSH socket created in worker threads (only a PULL socket), and then it works.\n``` C\n/\n * Usage: ./verif [-n number] [-d]\n * -n   Number of worker threads\n * -d   Don't open socket to the Writer thread in Worker threads.\n /\ninclude \ninclude \ninclude \ninclude \ninclude \"nanomsg/nn.h\"\ninclude \"nanomsg/pipeline.h\"\ndefine ENDPOINT_WORKERS    \"inproc://threads_socket\"\ndefine ENDPOINT_WRITER     \"inproc://writer_socket\"\n// declarations\nvoid worker_loop(void param);\nvoid writer_loop(void n);\n// main function\nint main(int argc, char argv[]) {\n    int i, nbr_workers = 2, disable = 0, sock_workers;\n    pthread_t writer_tid, workers;\nwhile ((i = getopt(argc, argv, \"n:d\")) != -1) {\n    switch (i) {\n    case 'n':\n        nbr_workers = (unsigned short)atoi(optarg);\n        break;\n    case 'd':\n        disable = 1;\n        break;\n    }\n}\n// open the socket Main -> Workers\nif ((sock_workers = nn_socket(AF_SP, NN_PUSH)) < 0 ||\n    nn_bind(sock_workers, ENDPOINT_WORKERS) < 0) {\n    printf(\"ERR 1\\n\");\n    exit(1);\n}\n// create Writer thread\nif (pthread_create(&writer_tid, NULL, writer_loop, NULL)) {\n    printf(\"ERR 2\\n\");\n    exit(2);\n}\n// create Worker threads\nworkers = (pthread_t*)malloc(nbr_workers * sizeof(pthread_t));\nfor (i = 0; i < nbr_workers; i++) {\n    pthread_create(&workers[i], NULL, worker_loop, &disable);\n}\n// infinite loop\nfor (; ; ) ;\nreturn (0);\n\n}\n// Worker thread\nvoid worker_loop(void param) {\n    int disable, in_sock, out_sock, fd;\n// open the socket Worker -> Writer\ndisable = *((int*)param);\nif (!disable) {\n    if ((out_sock = nn_socket(AF_SP, NN_PUSH)) < 0 ||\n        nn_connect(out_sock, ENDPOINT_WRITER) < 0) {\n        printf(\"ERR 4\\n\");\n        pthread_exit(NULL);\n    }\n}\n// open the socket Main -> Worker\nif ((in_sock = nn_socket(AF_SP, NN_PULL)) < 0 ||\n    nn_connect(in_sock, ENDPOINT_WORKERS) < 0) {\n    printf(\"ERR 5\\n\");\n    pthread_exit(NULL);\n}\n// infinite loop\nfor (; ; ) {\n    if (nn_recv(in_sock, &fd, sizeof(int), 0) < 0) {\n        printf(\"ERR 6\\n\");\n        continue;\n    }\n}\n\n}\n// Writer thread\nvoid writer_loop(void n) {\n    int sock;\n// open the socket Workers -> Writer\nif ((sock = nn_socket(AF_SP, NN_PULL)) < 0 ||\n    nn_bind(sock, ENDPOINT_WRITER) < 0) {\n    printf(\"ERR 3\\n\");\n    exit(3);\n}\nfor (; ; ) ;\nreturn (NULL);\n\n}\n```\nI hope it will help. Good luck!  :-)\n. Ah f*%k!  The previous version of the library was installed system-wide, and it took over the locally-installed new one...\nSorry to have wasted your time.  :-/\n. ",
    "chipdude": "This patch is released under the MIT license.\n. ",
    "glycerine": "Hmm... curiously this does not seem to be OSX specific after all. I also get it on Ubuntu 12.04, Linux x86_64, with very recent gcc (4.7.2)\nme@i7:~/dev/cnet/nanomsg$ make\n  CC     src/core/ep.lo\n  CC     src/core/epbase.lo\n  CC     src/core/global.lo\n  CC     src/core/pipe.lo\n  CC     src/core/sock.lo\n  CC     src/core/sockbase.lo\n  CC     src/core/device.lo\n  CC     src/core/symbol.lo\n  CC     src/aio/ctx.lo\n  CC     src/aio/fsm.lo\n  CC     src/aio/poller.lo\n  CC     src/aio/pool.lo\n  CC     src/aio/timer.lo\n  CC     src/aio/timerset.lo\n  CC     src/aio/usock.lo\n  CC     src/aio/worker.lo\n  CC     src/utils/alloc.lo\n  CC     src/utils/atomic.lo\n  CC     src/utils/chunk.lo\n  CC     src/utils/chunkref.lo\n  CC     src/utils/clock.lo\n  CC     src/utils/efd.lo\n  CC     src/utils/err.lo\n  CC     src/utils/glock.lo\n  CC     src/utils/hash.lo\n  CC     src/utils/list.lo\n  CC     src/utils/msg.lo\n  CC     src/utils/mutex.lo\n  CC     src/utils/queue.lo\n  CC     src/utils/random.lo\n  CC     src/utils/sem.lo\n  CC     src/utils/sleep.lo\n  CC     src/utils/stopwatch.lo\n  CC     src/utils/thread.lo\n  CC     src/utils/wire.lo\n  CC     src/protocols/bus/bus.lo\n  CC     src/protocols/bus/xbus.lo\n  CC     src/protocols/pipeline/push.lo\n  CC     src/protocols/pipeline/pull.lo\n  CC     src/protocols/pipeline/xpull.lo\n  CC     src/protocols/pipeline/xpush.lo\n  CC     src/protocols/pair/pair.lo\n  CC     src/protocols/pair/xpair.lo\n  CC     src/protocols/pubsub/pub.lo\n  CC     src/protocols/pubsub/sub.lo\n  CC     src/protocols/pubsub/trie.lo\n  CC     src/protocols/reqrep/req.lo\n  CC     src/protocols/reqrep/rep.lo\n  CC     src/protocols/reqrep/xrep.lo\n  CC     src/protocols/reqrep/xreq.lo\n  CC     src/protocols/survey/respondent.lo\n  CC     src/protocols/survey/surveyor.lo\n  CC     src/protocols/survey/xrespondent.lo\n  CC     src/protocols/survey/xsurveyor.lo\n  CC     src/protocols/utils/dist.lo\n  CC     src/protocols/utils/excl.lo\n  CC     src/protocols/utils/fq.lo\n  CC     src/protocols/utils/lb.lo\n  CC     src/protocols/utils/priolist.lo\n  CC     src/transports/utils/backoff.lo\n  CC     src/transports/utils/dns.lo\n  CC     src/transports/utils/iface.lo\n  CC     src/transports/utils/literal.lo\n  CC     src/transports/utils/port.lo\n  CC     src/transports/utils/streamhdr.lo\n  CC     src/transports/inproc/binproc.lo\n  CC     src/transports/inproc/cinproc.lo\n  CC     src/transports/inproc/inproc.lo\n  CC     src/transports/inproc/ins.lo\n  CC     src/transports/inproc/msgqueue.lo\n  CC     src/transports/inproc/sinproc.lo\n  CC     src/transports/ipc/aipc.lo\n  CC     src/transports/ipc/bipc.lo\n  CC     src/transports/ipc/cipc.lo\n  CC     src/transports/ipc/ipc.lo\n  CC     src/transports/ipc/sipc.lo\n  CC     src/transports/tcp/atcp.lo\n  CC     src/transports/tcp/btcp.lo\n  CC     src/transports/tcp/ctcp.lo\n  CC     src/transports/tcp/stcp.lo\n  CC     src/transports/tcp/tcp.lo\n  CCLD   libnanomsg.la\n  CC     perf/inproc_lat.o\n  CCLD   perf/inproc_lat\n  CC     perf/inproc_thr.o\n  CCLD   perf/inproc_thr\n  CC     perf/local_lat.o\n  CCLD   perf/local_lat\n  CC     perf/remote_lat.o\n  CCLD   perf/remote_lat\n  CC     perf/local_thr.o\n  CCLD   perf/local_thr\n  CC     perf/remote_thr.o\n  CCLD   perf/remote_thr\nme@i7:~/dev/cnet/nanomsg$ make check\nmake  tests/inproc tests/inproc_shutdown tests/ipc tests/ipc_shutdown tests/tcp tests/tcp_shutdown tests/pair tests/pubsub tests/reqrep tests/pipeline tests/survey tests/bus tests/block tests/term tests/timeo tests/iovec tests/msg tests/prio tests/poll tests/device tests/emfile tests/domain tests/trie tests/list tests/hash tests/symbol tests/separation tests/zerocopy tests/shutdown\nmake[1]: Entering directory /home/jaten/dev/cnet/nanomsg'\n  CC     tests/inproc.o\n  CCLD   tests/inproc\n  CC     tests/inproc_shutdown.o\n  CCLD   tests/inproc_shutdown\n  CC     tests/ipc.o\n  CCLD   tests/ipc\ntests/ipc.o: In functionmain':\nipc.c:(.text+0x143): undefined reference to test_socket_impl'\nipc.c:(.text+0x15f): undefined reference totest_connect_impl'\nipc.c:(.text+0x173): undefined reference to test_close_impl'\nipc.c:(.text+0x18c): undefined reference totest_socket_impl'\nipc.c:(.text+0x1a8): undefined reference to test_connect_impl'\nipc.c:(.text+0x1cb): undefined reference totest_socket_impl'\nipc.c:(.text+0x1e7): undefined reference to test_bind_impl'\nipc.c:(.text+0x209): undefined reference totest_send_impl'\nipc.c:(.text+0x222): undefined reference to test_recv_impl'\nipc.c:(.text+0x23b): undefined reference totest_send_impl'\nipc.c:(.text+0x254): undefined reference to test_recv_impl'\nipc.c:(.text+0x280): undefined reference totest_send_impl'\nipc.c:(.text+0x2ac): undefined reference to test_recv_impl'\nipc.c:(.text+0x2ca): undefined reference totest_close_impl'\nipc.c:(.text+0x2de): undefined reference to test_close_impl'\ncollect2: error: ld returned 1 exit status\nmake[1]: *** [tests/ipc] Error 1\nmake[1]: Leaving directory/home/jaten/dev/cnet/nanomsg'\nmake: *** [check-am] Error 2\nme@i7:~/dev/cnet/nanomsg$ cat /etc/lsb-release \nDISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=12.04\nDISTRIB_CODENAME=precise\nDISTRIB_DESCRIPTION=\"Ubuntu 12.04.2 LTS\"\nme@i7:~/dev/cnet/nanomsg$ gcc --version\ngcc (GCC) 4.7.2\nCopyright (C) 2012 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nme@i7:~/dev/cnet/nanomsg$ \n. @mkoppanen: yes, your patch fixes it for me on both OSX and Linux.\n. p.s. the above error was with the pre issue #132 version of tests/testutil.h  However the win32 build problem persists with the #132 patch applied:\n25>c:\\users\\nanomsg\\tests\\testutil.h(44): error C2054: expected '(' to follow 'inline'\n25>c:\\users\\nanomsg\\tests\\testutil.h(45): error C2082: redefinition of formal parameter 'test_socket_impl'\n25>c:\\users\\nanomsg\\tests\\testutil.h(45): error C2143: syntax error : missing ';' before '{'\n25>c:\\users\\nanomsg\\tests\\testutil.h(59): error C2054: expected '(' to follow 'inline'\n25>c:\\users\\nanomsg\\tests\\testutil.h(60): error C2082: redefinition of formal parameter 'test_connect_impl'\n25>c:\\users\\nanomsg\\tests\\testutil.h(60): error C2143: syntax error : missing ';' before '{'\n25>c:\\users\\nanomsg\\tests\\testutil.h(73): error C2054: expected '(' to follow 'inline'\n25>c:\\users\\nanomsg\\tests\\testutil.h(74): error C2082: redefinition of formal parameter 'test_bind_impl'\n25>c:\\users\\nanomsg\\tests\\testutil.h(74): error C2143: syntax error : missing ';' before '{'\n25>c:\\users\\nanomsg\\tests\\testutil.h(87): error C2054: expected '(' to follow 'inline'\n25>c:\\users\\nanomsg\\tests\\testutil.h(88): error C2082: redefinition of formal parameter 'test_close_impl'\n25>c:\\users\\nanomsg\\tests\\testutil.h(88): error C2143: syntax error : missing ';' before '{'\n25>c:\\users\\nanomsg\\tests\\testutil.h(100): error C2054: expected '(' to follow 'inline'\n25>c:\\users\\nanomsg\\tests\\testutil.h(101): error C2082: redefinition of formal parameter 'test_send_impl'\n25>c:\\users\\nanomsg\\tests\\testutil.h(101): error C2143: syntax error : missing ';' before '{'\n25>c:\\users\\nanomsg\\tests\\testutil.h(123): error C2054: expected '(' to follow 'inline'\n25>c:\\users\\nanomsg\\tests\\testutil.h(124): error C2082: redefinition of formal parameter 'test_recv_impl'\n25>c:\\users\\nanomsg\\tests\\testutil.h(124): error C2143: syntax error : missing ';' before '{'\n. The nanomsg\\src\\aio\\usock_win.inc compilation error occurs because usock_win.inc:393 - end of file, contains two definitions of the function  nn_usock_handler(). One definition starts at line 393, and appears to be hand written. The next definitions starts at line 459 and contains a large state machine, which could be machine generated? \nStrange.\n. testutil.h can be fixed by adding the following defintion to the testutil.h before the first use of the inline keyword:\nifdef WIN32\ndefine inline __inline\nendif\nThe usock_win.inc file's first instance of nn_usock_handler at line 393 should probably be renamed nn_usock_shutdown, in comparison with the usock_posix.inc.  When I tried this everything compiled and linked without issue, however four of the tests fail, which may or may not have anything to do with the usock_win.inc repair.\n1>  The following tests FAILED:\n1>        5 - tcp (Failed)\n1>        6 - tcp_shutdown (Failed)\n1>       27 - separation (Failed)\n1>       29 - shutdown (Failed)\n1>  Errors while running CTest\n. Speculation with the intent of helping, feel free to ignore if you actually know what is going on with usock_win.inc:\nI note that the implementations of nn_usock_handler (which you can see above I'm guessing might should be nn_usock_shutdown in reality) in usock_win.inc  has diverged somewhat from the usock_posix.inc definition of nn_usock_shtudown; I venture to speculate that the usock_posix.inc might (?) be more up to date; and perhaps should be used as a basis for updating the windows version. Or not. I'm not actually reading the source very carefully. I'm just trying to test it out on windows, but with the tcp test failing at the moment, it's in a bit of a showstopper state presently.\n. Nice. After last commit, 5818f419ed25e68235d8a4d1c0c4cb1748f0741f, all 29/29 tests pass on Win32, Ubuntu 12.04, and OSX 10.6.8.\nNice job. Thank you for the quick turnaround.\n. @javalama : I don't think maverick ships with gnu libtool, only Apple libtool, so some macros are missing. \"brew install libtool\" usually fixes this for me.\n. In cases where the error represents external error conditions (from the os: disk out of space, no file handles left) or user error (requested port already occupied, malformed/unparsable ip address given) then the library should really not crash. This is because if it crashes, then it is impossible to use it as a library in an application that cannot crash on the user (for example, using it in R). In other cases, asserts are perfectly fine when they are insisting upon correct internal program logic. This allows the library logic to be corrected and improved or generalized when needed.\nAll the errno_asserts here that I've changed to returning -1 represent external conditions or user-input errors, not internal logic errors. Therefore returning -1 is the appropriate action here.\nI agree that I wish there was a more general approach to handling errors available, especially when there is more information needed than can be conveyed by errno. Howevere this particular function nn_tcpmuxd() is an initializer of a service. In this case, since it is a standalone function, I think we can safefly proceed without waiting for an entire review of the library (which is a separate issue).\n. errno_assert usage means that the error information is in errno. Each of these system calls sets errno: socket, setsockopt, bind, listen.\nI guess we could put in an assert(errno != 0) just before each return. Seems somewhat unusual style, but I'm not opposed to it if it clarifies the concern for the reader.\n. I do see that errno is not cleared before the first call to socket, so that should probably be done to avoid false positive from leftover other errors. I'll add to the pull.\n. Yes, naturally, this code in licensed under the MIT license.\n. Non-authoritative answer: not that I know of. But hey: it is open source. Jump in with a pull request and make it awesome!\n. ",
    "ipechorin": "I've sent a pull request with a fix; all the tests on my Windows 7 pass with this fix (32-bit build, Visual Studio 2010)/\n. @glycerine could you please check on OSX and Linux too (after the latest commit)?\n. At the moment the main thread of test \"tcp\" waits after 10 messages sent:\n```\n  [1] __pollsys(0xffbff968, 0x1, 0x0, 0x0, 0xff1b03ec, 0x0), at 0xff14df3c\n  [2] _pollsys(0xffbff968, 0x1, 0x0, 0x0, 0x0, 0xff329a44), at 0xff13dc20\n  [3] _poll(0xffbff968, 0x1, 0xffffffff, 0xff31f720, 0x1, 0x0), at 0xff0e4a74\n  [4] nn_efd_wait(self = 0x23d18, timeout = -1), line 49 in \"efd.c\"\n  [5] nn_sock_send(self = 0x23ca8, msg = 0xffbffa78, flags = 0), line 545 in \"sock.c\"\n  [6] nn_send(s = 0, buf = 0x12b70, len = 40U, flags = 0), line 522 in \"global.c\"\n=>[7] main(), line 164 in \"tcp.c\"\n(dbx) print i\ni = 10\n```\nWorker thread is waiting at:\n[1] __pollsys(0x23b98, 0x4, 0x0, 0x0, 0x0, 0x0), at 0xff14df3c\n  [2] _pollsys(0x23b98, 0x4, 0x0, 0x0, 0x0, 0xff142760), at 0xff13dc20\n  [3] _poll(0x23b98, 0x4, 0xffffffff, 0x29434, 0xfeee0200, 0xff0e4a74), at 0xff0e4a74\n=>[4] nn_poller_wait(self = 0xff36196c, timeout = -1), line 151 in \"poller_poll.inc\"\n  [5] nn_worker_routine(arg = 0xff361940), line 168 in \"worker_posix.inc\"\n  [6] nn_thread_main_routine(arg = 0xff3619a0), line 44 in \"thread_posix.inc\"\n. Just in case: I have access to several HP-UX machines and can compile/run any tests if you find that helpful for the library.\n. Is there any UNIX with CMake available in distribution? Probably, no.\n. Again, is there any UNIX with CMake available in distribution? I don't think so. And yeah, Linux is not UNIX; I'm concerned about AIX, Solaris and HP-UX. I don't like an idea to build CMake as a prerequisite for nanomsg...\n. ",
    "mhowlett": "just tested windows 7 -> windows 7 and there are no problems on that platform\n. the problem exists for windows 7 (client) -> ubuntu (server)\n. and there are no problems ubuntu (send) -> windows (recv). So I might take a bit of a look at this now, starting with recv on posix.\n. Yes. The client just has a long sleep at the end to stop it from exiting. \nThe expected output before the line that says \"# bytes: 127000\" are numbers counting from 0 to 126 over and over. However, most of the time on my ubuntu machine and ubuntu VM, the final lines after a certain point are just 0. This doesn't actually happen all the time, just most of the time. I think to make it happen all the time just increase the const N (number of bytes in the message).\nThe issue appears to be on the recv side of things. By placing printf's in /src/aio/usock_posix.inc/nn_usock_recv, I see that when all data happens to be received immediately, the output is as expected. However when nn_worker_execute needs to be called in that method, the message is corrupted with 0's at the end. When I tried to work that out, I realized it would take some time to get my head around what's going on in the code.\nNote: It is more convenient to change the final for loop in the server to count from N-10 to N, rather than 0 to N.\n. I was looking at this further but didn't work out the problem. I got as far as putting debugging messages in nn_usock_handler in the NN_USOCK_STATE_ACTIVE case and saw that this wasn't being called enough times, but don't know why. It didn't seem to matter how large the message was, the case was only executed 6 times (from memory) and the # bytes received into the buffer the same. Seems like some sort of buffer size problem or timeout.. \n. Awesome, seems to work now. Looking forward to giving the library a big work out tomorrow... \n. ",
    "vguerra": "Sure.. confirmed. \n. great.. thanks Martin for the fast response. \n. I do state that I submit the patch under the MIT/X11 license. \nThanks! \n. ",
    "zotbot": "With nanomsg-0.2.alpha\nThere seems to be a race condition / lockup when running perf/inproc_thr\nwhen less than ~50 packets are sent.\n(gdb) r 1000 50\nStarting program: src/nanomsg/nanomsg-0.2-alpha/perf/.libs/lt-inproc_thr 1000 50\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n[New Thread 0x2aaaab901700 (LWP 17547)]\n[New Thread 0x2aaaabb02700 (LWP 17548)]\n[Thread 0x2aaaabb02700 (LWP 17548) exited]\nmessage size: 1000 [B]\n[Thread 0x2aaaab901700 (LWP 17547) exited]\nmessage count: 50\nmean throughput: 66844 [msg/s]\nmean throughput: 534.752 [Mb/s]\n[Inferior 1 (process 17503) exited normally]\n~/src/nanomsg/nanomsg-0.2-alpha/perf$ ./inproc_thr 1 1\n\nLets try again with gdb...\n(gdb) r 1000 1\nStarting program: src/nanomsg/nanomsg-0.2-alpha/perf/.libs/lt-inproc_thr 1000 1\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n[New Thread 0x2aaaab901700 (LWP 17844)]\n[New Thread 0x2aaaabb02700 (LWP 17845)]\n[Thread 0x2aaaabb02700 (LWP 17845) exited]\n^C\nProgram received signal SIGINT, Interrupt.\n0x00002aaaab223a43 in __GI___poll (fds=, nfds=, timeout=)\n    at ../sysdeps/unix/sysv/linux/poll.c:87\n87      ../sysdeps/unix/sysv/linux/poll.c: No such file or directory.\n(gdb) where\n0  0x00002aaaab223a43 in __GI___poll (fds=, nfds=, timeout=)\nat ../sysdeps/unix/sysv/linux/poll.c:87\n\n1  0x00002aaaaace4138 in nn_efd_wait (self=, timeout=-1) at src/utils/efd.c:48\n2  0x00002aaaaacdf882 in nn_sock_recv (self=0x604540, msg=0x7fffffffe0b0, flags=) at src/core/sock.c:618\n3  0x00002aaaaacdd7e1 in nn_recv (s=, buf=0x6048a0, len=1000, flags=)\nat src/core/global.c:553\n\n4  0x0000000000400e01 in main (argc=, argv=0x7fffffffe268) at perf/inproc_thr.c:98\n(gdb) \n. ",
    "ymonster": "My case is running inproc_lat.exe with param \"1024 1024\" on win7, it will hang from time to time.\nSometimes it got result, and other time it hanged.\n. ",
    "munkhoff": "autogen.sh works for me on Mac OS 10.9.2. I have the most recent versions of the autotools packages which I built directly from source (i.e. autoconf-2.69).\n. ",
    "sroycode": "autoconf -v 2>check.txt\nsee if AM_SILENT_RULES is there\n. working now ,  yosemite with latest master\n. ",
    "marchon": "Unable to replicate this can we close this issue now?\nnanomsg marchon$ ./autogen.sh\nautoreconf: Entering directory .'\nautoreconf: configure.ac: not using Gettext\nautoreconf: running: aclocal --force -I m4\nautoreconf: configure.ac: tracing\nautoreconf: running: glibtoolize --copy --force\nglibtoolize: putting auxiliary files in.'.\nglibtoolize: copying file ./ltmain.sh'\nglibtoolize: putting macros in AC_CONFIG_MACRO_DIR,m4'.\nglibtoolize: copying file m4/libtool.m4'\nglibtoolize: copying filem4/ltoptions.m4'\nglibtoolize: copying file m4/ltsugar.m4'\nglibtoolize: copying filem4/ltversion.m4'\nglibtoolize: copying file m4/lt~obsolete.m4'\nautoreconf: running: /opt/local/bin/autoconf --force\nautoreconf: configure.ac: not using Autoheader\nautoreconf: running: automake --add-missing --copy --force-missing\nconfigure.ac:60: installing './compile'\nconfigure.ac:36: installing './config.guess'\nconfigure.ac:36: installing './config.sub'\nconfigure.ac:31: installing './install-sh'\nconfigure.ac:31: installing './missing'\nMakefile.am: installing './depcomp'\nparallel-tests: installing './test-driver'\nautoreconf: Leaving directory.'\n. Was this issue really closed as part of #175? If so can we close this issue?\n. Should we move this to a faq and close the issue? \n. Is there a consistent test case we can use for cross platform validation?\nOn Monday, June 1, 2015, gdamore notifications@github.com wrote:\n\nI'm not seeing this on 10.10.x.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/258#issuecomment-107301844.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. I do not believe this is an actionable item except for adding this information to a FAQ\n. We should profile this... \n. Does the merged change solve this problem? \n. is this issue still open? \nShall we put a comment about it in a FAQ File? \n. I'm pretty sure that will work we do it all the time. \nSent from my iPhone\n\nOn Jan 26, 2015, at 4:28 PM, Dirkjan Ochtman notifications@github.com wrote:\n@stepelu did you ever get around to trying this?\n\u2014\nReply to this email directly or view it on GitHub.\n. No compiling the library bad moving it to an older version. \n\nSent from my iPhone\n\nOn Jan 26, 2015, at 4:33 PM, Dirkjan Ochtman notifications@github.com wrote:\nWith automake-1.10?\n\u2014\nReply to this email directly or view it on GitHub.\n. It looks like this issue is dealt with should we close it? \n. A change has been merged - is this issue still open? \n. Can we please close PR #342\n\nOn Mon, Jan 26, 2015 at 2:39 PM, diffuse notifications@github.com wrote:\n\nThis issue was fixed by commit a52e25102f55ad72978c6a4691c3aeece7d18563\nOn Mon, Jan 26, 2015 at 2:31 PM, George Lambert notifications@github.com\nwrote:\n\nA change has been merged - is this issue still open?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/342#issuecomment-71522044.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/342#issuecomment-71523310.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. That was a very good catch.  We need this in the main line. \n. I think we should add this to a FAQ and close this issue. \n. You make some good points, but this article makes some interesting points\nas well.\nhttps://balexios.wordpress.com/2014/08/02/calloc-vs-malloc-memset/\nOn Wed, Feb 25, 2015 at 11:24 PM, gdamore notifications@github.com wrote:\n\nLooking at this code. I see two problems.\n1.\nrealloc() doesn't get the same zero treatment -- so if alloc_ () could\n   have a problem, so could realloc, right? (Realloc is trickier, because you\n   have to zero only the end of the after the allocation.)\n   2.\nI'd have concerns with zeroing full message contents. This allocation\n   function is used globally in lieu of malloc. While the zeroing of memory\n   for headers or other accounting structures is probably trivial, if messages\n   are rather large, this could have a rather detrimental effect on\n   performance.\nIt would be better, IMO, to try to understand where the 'uninitialized'\nuse occurs, and ensure that callers that ned to zero memory do so\nexplicitly. (Perhaps only touching the specific structure members that they\naren't otherwise overwriting.) Failing that, perhaps expose an nn_calloc()\nfor use by those callers where the clearing semantics are easier/required,\nand leave nn_alloc() for use by callers that don't require this semantic\n(specifically allocating the buffer for message payloads.)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/363#issuecomment-76120267.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. At this point - Without some type of solution - we can PROVE that there is\nrandom corruption of received messages coming out of the nanomsg library.\nI is important the we understand there are 2 underlying issues.\n1) It is presently a problem that is impacting users - and is not\nnecessarily going to be caught by our testing methodology, unless we adapt\nthat strategy to check for buffer overruns - which is exactly what the\nresult of this can be.\n2) Any solution - even one that is technically tactical rather than\nstrategic is a better condition than we have now.\nnot fixing this problem can lead to exploits like explained in this\narticle.\nhttp://www.mathyvanhoef.com/2013/02/understanding-heap-exploiting-heap.html\nOn Mon, Mar 2, 2015 at 3:29 PM, Bent Cardan notifications@github.com\nwrote:\n\nperhaps something that is not the default..\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/363#issuecomment-76810728.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. Actually - Nanomsg is passing a pointed to memory that \"IT ALLOCATED\"\nbut It did not clear the entire memory block that it allocated.\nWhen Nanomsg returns a pointed to the memory block that it has allocated -\nand passes those functions to other languages that \"EXPECT\" a null\nterminated memory block it is the library's responsibility to make sure\nthat it does not contribute to potential security holes.\nHere is an interesting technical explaination of the issues around allocs /\nreallocs and the entire are of problems.\nhttp://www.informit.com/articles/article.aspx?p=1249298\nmarchon: no. The messages are not being corrupted as I understand it. The\n\nproblem is that nanomsg transfers exactly the bytes you request. Unless\nyou insist that that transfer include a terminating zero byte (by\nincluding it in your message payload), it will not be included.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. Bent - do we still have the code that we used to debug this problem?\nThe one where we allocated the buffers - filled them with a pattern of\nbytes - and then pulled nano message off of the queue with the overwritten\nbit pattern appearing to be part of the bytes returned by the request for a\nnanomessage result?\nGeorge.\nOn Mon, Mar 2, 2015 at 3:49 PM, gdamore notifications@github.com wrote:\n\nJust to be clear, if someone proves that the problem is uninitialized\nnanomsg control structure members, then that would represent a real\nlibnanomsg bug deserving a fix. But so far what I've seen is symptomatic of\nincorrect application expectations, and the proposed \"fix\" actually doesn't\nreally fix anything at all. It pastes over the problem some (even most!) of\nthe time, but doesn't prevent the overrun cases -- because if you receive a\nmessage that is full size, and then try to blithely do string operations on\nit, you have no guarantee that the message is null terminated.\nThis is precisely analogous to using fgets(). While fgets() will not\noverrun a buffer, if the input takes as many bytes as requested (or more),\nthen the buffer isn't null terminated. The usual pattern here is to do\nsomething like this:\nbuf = malloc(n);\nfgets(buf, n-1, stdin);\nbuf[n] = 0;\nNow replace \"fgets()\" in the above with \"nn_recv\" and you have your\nsolution.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/363#issuecomment-76818202.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. gdamore you are exactly right.\nn = nn_recv(s, &buf, NN_MSG, 0);\nnewbuf = malloc(n + 1);\nmemcpy(newbuf, buf, n);\nnewbuf[n] = 0\nWould work - but shouldn't have to if we always terminate the buffer with\n\\0 appended to the nanomsg allocated buffer it solves both problems at\nonce, and I am happy with that. But expecting the library consumer to be\neducated to doing that is inconsistent with what their default assumprtion\nof behavior would be. Especially when they are NOT explicitly doing the\nallocation from their application code.\nOn Mon, Mar 2, 2015 at 4:15 PM, gdamore notifications@github.com wrote:\n\n@marchon https://github.com/marchon I do expect that your observed\nbehavior is that if you prealloc a buffer, and fill with bytes, like this:\nbuf = malloc(2048);\nmemset(buf, 'A', 5);\nbuf[10] = 0; /* ensure we don't stop printing at some point */\nn = nn_recv(sock, buf, 2048, 0);\nand then send it a message consisting solely of the single byte \"B\", the\nreceiver will get back a value that looks like \"BAAAAAAAA\". If you printf()\nthat without null terminating, its going to be ugly.\nBut in this case the fix is relatively easy:\nn = nn_recv(s, buf, 2048-1, 0);\nbuf[n] = 0;\nYou can alternatively change your malloc to be one byte larger (2049) than\nyour argument to nn_recv(). If you use NN_MSG asking the library to\nallocate a message for you, then you're going to have to copy the message\nsomewhere else like this:\nn = nn_recv(s, &buf, NN_MSG, 0);\nnewbuf = malloc(n + 1);\nmemcpy(newbuf, buf, n);\nnewbuf[n] = 0;\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/363#issuecomment-76825152.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. gdamore - in response to your post about this change \"Just to be clear, I\nremain a very strong +1 in favor of this change and have gone out of my way\nto provide detail as to the necessity.\"\nI appreciate your expertise in this area, but I do believe that you are\nwrong, and that your position while well intentioned don't represent good\nlibrary design, and this a a library after all.\nTo be more specific I believe that you are in error about the non-C\nruntimes.  \"I believe most non-C runtimes (e.g. Java, Go, Python, etc.)\nactually use length encoding rather than null termination.\"\nAccording to the Python Software Foundation (the subject matter experts)\nhave an explanation of interacting with C / C++ and it is quite clear from\nthe long explanation that strings and stream object are expected to be null\nfilled and null terminated.\nhttps://docs.python.org/3/library/ctypes.html#module-ctypes\nIf you read the link attached (summarized below); (which is talking about\ninterfacing with c via ctypes) it appears clear that the strings are\nexpected to be null terminated, and in the example the python\ncreate_string_buffer contains 3 NULL bytes in a row.\nWhile I expect that you need more than my word, do please review the other\nlinks for additional validation.  If necessary, I will continue down the\nroad of providing more examples, but it should be at this point unnecessary\nas my positions are fact based. This is not a question of what you think\nthe best practice should be - this in fact a library design issue.\nWith that in mind - our proposed change improves the situation for non-C\nprogrammers without changing any external user expectations. Anyone\ndepending on this bad behavior is barking up the wrong tree. So the\nnegative impact at best will be in the price of clearing the memory. It\nfixes more problems than it creates.\nc_wchar_p https://docs.python.org/3/library/ctypes.html#ctypes.c_wchar_p\nwchar_t * (NUL terminated)string or Nonec_char_p\nhttps://docs.python.org/3/library/ctypes.html#ctypes.c_char_pchar * (NUL\nterminated)bytes object or None\n\n\n\nfrom ctypes import *>>> p = create_string_buffer(3)            # create a 3 byte buffer, initialized to NUL bytes>>> print(sizeof(p), repr(p.raw))3 b'\\x00\\x00\\x00'>>> p = create_string_buffer(b\"Hello\")     # create a buffer containing a NUL terminated string>>> print(sizeof(p), repr(p.raw))6 b'Hello\\x00'>>> print(repr(p.value))b'Hello'>>> p = create_string_buffer(b\"Hello\", 10) # create a 10 byte buffer>>> print(sizeof(p), repr(p.raw))10 b'Hello\\x00\\x00\\x00\\x00\\x00'>>> p.value = b\"Hi\">>> print(sizeof(p), repr(p.raw))10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'>>>\n\n\n\nOn Mon, Mar 2, 2015 at 7:44 PM, gdamore notifications@github.com wrote:\n\nBtw, that NN_MSG_STR hack I suggested is not something I'd expect FFI\ncallers to use. Its really a convenience for C programmers working directly\nagainst libnanomsg, IMO. I believe most non-C runtimes (e.g. Java, Go,\nPython, etc.) actually use length encoding rather than null termination.\nI'm pretty sure C++ follows the C conventions here, but I can't think of\nany language other than C or C++ that uses or typically needs null\ntermination for correctness.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/363#issuecomment-76863794.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. https://www.securecoding.cert.org/confluence/display/seccode/EXP33-C.+Do+not+read+uninitialized+memory\nEXP33-C. Do not read uninitialized memory\nhttps://www.securecoding.cert.org/confluence/display/seccode/EXP33-C.+Do+not+read+uninitialized+memory\nUninitialized automatic variables or dynamically allocated memory has\nindeterminate\nvalues\nhttps://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions#BB.Definitions-indeterminatevalue,\nwhich for objects of some types can be a trap representation\nhttps://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions#BB.Definitions-traprepresentation.\nReading such trap representations is undefined behavior\nhttps://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions#BB.Definitions-undefinedbehavior\n (seeundefined behavior 10\nhttps://www.securecoding.cert.org/confluence/display/seccode/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_10\n and undefined behavior 12\nhttps://www.securecoding.cert.org/confluence/display/seccode/CC.+Undefined+Behavior#CCUndefinedBehavior-ub12);\nit can cause a program to behave in an unexpected\nhttps://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions#BB.Definitions-unexpectedbehavior\nmanner\nand provide an avenue for attack. In many cases, compilers issue a warning\ndiagnostic message when reading uninitialized variables (see MSC00-C.\nCompile cleanly at high warning levels\nhttps://www.securecoding.cert.org/confluence/display/seccode/MSC00-C.+Compile+cleanly+at+high+warning+levels\nfor\nmore information).\n....\nRisk Assessment\nReading uninitialized variables is undefined behavior\nhttps://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions#BB.Definitions-undefinedbehavior\nand\ncan result in unexpected program behavior\nhttps://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions#BB.Definitions-unexpectedbehavior.\nIn\nsome cases, these security flaws\nhttps://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions#BB.Definitions-securityflaw\nmay\nallow the execution of arbitrary code.\nReading uninitialized variables for creating entropy is problematic,\nbecause these memory accesses can be removed by compiler optimization.\nVU#925211 http://www.kb.cert.org/vuls/id/925211 is an example of a\nvulnerability\nhttps://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions#BB.Definitions-vulnerability\ncaused\nby this coding error.\nRule\nSeverity\nLikelihood\nRemediation Cost\nPriority\nLevel\nEXP33-C\nHigh\nProbable\nMedium\nP12\nL1\nOn Mon, Mar 2, 2015 at 8:55 PM, George Lambert marchon@gmail.com wrote:\n\ngdamore - in response to your post about this change \"Just to be clear, I\nremain a very strong +1 in favor of this change and have gone out of my\nway to provide detail as to the necessity.\"\nI appreciate your expertise in this area, but I do believe that you are\nwrong, and that your position while well intentioned don't represent good\nlibrary design, and this a a library after all.\nTo be more specific I believe that you are in error about the non-C\nruntimes.  \"I believe most non-C runtimes (e.g. Java, Go, Python, etc.)\nactually use length encoding rather than null termination.\"\nAccording to the Python Software Foundation (the subject matter experts)\nhave an explanation of interacting with C / C++ and it is quite clear from\nthe long explanation that strings and stream object are expected to be null\nfilled and null terminated.\nhttps://docs.python.org/3/library/ctypes.html#module-ctypes\nIf you read the link attached (summarized below); (which is talking about\ninterfacing with c via ctypes) it appears clear that the strings are\nexpected to be null terminated, and in the example the python\ncreate_string_buffer contains 3 NULL bytes in a row.\nWhile I expect that you need more than my word, do please review the other\nlinks for additional validation.  If necessary, I will continue down the\nroad of providing more examples, but it should be at this point unnecessary\nas my positions are fact based. This is not a question of what you think\nthe best practice should be - this in fact a library design issue.\nWith that in mind - our proposed change improves the situation for non-C\nprogrammers without changing any external user expectations. Anyone\ndepending on this bad behavior is barking up the wrong tree. So the\nnegative impact at best will be in the price of clearing the memory. It\nfixes more problems than it creates.\nc_wchar_p https://docs.python.org/3/library/ctypes.html#ctypes.c_wchar_p\nwchar_t * (NUL terminated)string or Nonec_char_p\nhttps://docs.python.org/3/library/ctypes.html#ctypes.c_char_pchar * (NUL\nterminated)bytes object or None\n\n\n\nfrom ctypes import *>>> p = create_string_buffer(3)            # create a 3 byte buffer, initialized to NUL bytes>>> print(sizeof(p), repr(p.raw))3 b'\\x00\\x00\\x00'>>> p = create_string_buffer(b\"Hello\")     # create a buffer containing a NUL terminated string>>> print(sizeof(p), repr(p.raw))6 b'Hello\\x00'>>> print(repr(p.value))b'Hello'>>> p = create_string_buffer(b\"Hello\", 10) # create a 10 byte buffer>>> print(sizeof(p), repr(p.raw))10 b'Hello\\x00\\x00\\x00\\x00\\x00'>>> p.value = b\"Hi\">>> print(sizeof(p), repr(p.raw))10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'>>>\n\n\n\nOn Mon, Mar 2, 2015 at 7:44 PM, gdamore notifications@github.com wrote:\n\nBtw, that NN_MSG_STR hack I suggested is not something I'd expect FFI\ncallers to use. Its really a convenience for C programmers working directly\nagainst libnanomsg, IMO. I believe most non-C runtimes (e.g. Java, Go,\nPython, etc.) actually use length encoding rather than null termination.\nI'm pretty sure C++ follows the C conventions here, but I can't think of\nany language other than C or C++ that uses or typically needs null\ntermination for correctness.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/363#issuecomment-76863794.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. What - this conversation is on GitHub? I thought it was the mailing list -\nI should learn how to do that.\nG.\nOn Mon, Mar 2, 2015 at 9:33 PM, Bent Cardan notifications@github.com\nwrote:\n\n@marchon https://github.com/marchon when are you going to learn how to\nuse github instead of email\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/363#issuecomment-76875743.\n\n\nP THINK BEFORE PRINTING: is it really necessary?\nThis e-mail and its attachments are confidential and solely for the\nintended addressee(s). Do not share or use them without approval. If\nreceived in error, contact the sender\nand delete them.\n. If we are going to do this here, we need to do that everywhere.  But it does make sense to me at first blush..  We can take a look at the other files to see where else it needs to be done. \n. Did not fail on a Test VirtualBox with different kernel.\n```\nAll 33 tests passed\nmake[1]: Leaving directory `/home/vagrant/nanomsg'\nroot@vagrant-debian-wheezy:/home/vagrant/nanomsg#  uname -mrs      \nLinux 3.2.0-4-amd64 x86_64\nroot@vagrant-debian-wheezy:/home/vagrant/nanomsg# uname -a  \nLinux vagrant-debian-wheezy 3.2.0-4-amd64 #1 SMP Debian 3.2.63-2+deb7u2 x86_64 GNU/Linux\nroot@vagrant-debian-wheezy:/home/vagrant/nanomsg# cat /proc/version\nLinux version 3.2.0-4-amd64 (debian-kernel@lists.debian.org) (gcc version 4.6.3 (Debian 4.6.3-14) ) #1 SMP Debian 3.2.63-2+deb7u2\n```\n. It is not the kernel version, as I have upgraded the kernel from Linux 3.2.0-4-amd64 x86_64 to Linux 3.18.0-10-exton x86_64\n```\nPASS: tests/inproc\nPASS: tests/inproc_shutdown\nPASS: tests/ipc\nPASS: tests/ipc_shutdown\nPASS: tests/ipc_stress\nPASS: tests/tcp\nPASS: tests/tcp_shutdown\nPASS: tests/ws\nPASS: tests/tcpmux\nPASS: tests/pair\nPASS: tests/pubsub\nPASS: tests/reqrep\nPASS: tests/pipeline\nPASS: tests/survey\nPASS: tests/bus\nPASS: tests/block\nPASS: tests/term\nPASS: tests/timeo\nPASS: tests/iovec\nPASS: tests/msg\nPASS: tests/prio\nPASS: tests/poll\nPASS: tests/device\nPASS: tests/emfile\nPASS: tests/domain\nPASS: tests/trie\nPASS: tests/list\nPASS: tests/hash\nPASS: tests/symbol\nPASS: tests/separation\nPASS: tests/zerocopy\nPASS: tests/shutdown\nPASS: tests/cmsg\nmake[3]: Entering directory '/home/vagrant/nanomsg'\nmake[3]: Nothing to be done for 'all'.\nmake[3]: Leaving directory '/home/vagrant/nanomsg'\n============================================================================\nTestsuite summary for nanomsg 0.5-beta-73-g2da0726\n============================================================================\nTOTAL: 33\nPASS:  33\nSKIP:  0\nXFAIL: 0\nFAIL:  0\nXPASS: 0\nERROR: 0\n============================================================================\nmake[2]: Leaving directory '/home/vagrant/nanomsg'\nmake[1]: Leaving directory '/home/vagrant/nanomsg'\nroot@vagrant-debian-wheezy:/home/vagrant/nanomsg# uname -mrs\nLinux 3.18.0-10-exton x86_64\nroot@vagrant-debian-wheezy:/home/vagrant/nanomsg# uname -a\nLinux vagrant-debian-wheezy 3.18.0-10-exton #11 SMP Fri Jan 23 17:09:14 CET 2015 x86_64 GNU/Linux\nroot@vagrant-debian-wheezy:/home/vagrant/nanomsg# cat /proc/version\nLinux version 3.18.0-10-exton (root@mate-u) (gcc version 4.9.1 (Ubuntu 4.9.1-16ubuntu6) ) #11 SMP Fri Jan 23 17:09:14 CET 2015\n```\n. It is also not an IPV6 Issues \nroot@vagrant-debian-wheezy:/home/vagrant/nanomsg# ifconfig \neth0      Link encap:Ethernet  HWaddr 08:00:27:3b:cb:67\n          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0\n          inet6 addr: fe80::a00:27ff:fe3b:cb67/64 Scope:Link\n. I dropped the Kernel Version on the initial failing machine to Linux 2.6.39.1-x86_64 and the problem persists.  I added debugging code to log the src and type value of every call to  \nstatic void nn_sock_shutdown (struct nn_fsm self, int src, int type, void srcptr)\nThese are the results -- note that only 2 calls pass the parameters  src=0 type=33988                                                                                \nand only for IPC \nbash\nroot@(none):~/nanomsg# sort run.log.error.6 | uniq -c                                                   \n      1 Assertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:833)          \n      1 /bin/bash: line 5: 15544 Aborted                 ${dir}$tst                                     \n      1 make[1]: *** [check-TESTS] Error 1                                                              \n      1 make: *** [check-am] Error 2                                                                    \n      2 src=0 type=33988                                                                                \n   4121 src=1 type=1                                                                                    \n     12 src=-2 type=2                                                                                   \n   3732 src=-2 type=-3\n. ",
    "daborg69": "Tried again.  Error message is slightly different but same result and erroring at same place in code.\nAssertion failed: 8 == NN_USOCK_STATE_ACTIVE (c:\\temp\\nanomsg-fix_156\\src\\aio\\usock_win.inc:326)\n. Getting compiler errors:\n -- nn_fsm_raise too few arguments for call\n -- fsm:  is not a member of nn_fsm\n  -- Event_error is not a member of nn_fsm\nI went to the extreme of redownloading the master zip and applying these patches and still compiler errors.\n. ",
    "egonuel": "Hi, I just applied that patch to current master (manually, as somehow git extensions said that the patch is corrupted), but the assertion still happens.\n. ",
    "norsd": "@egonuel please see issue #211 \nMay codes at there help you\n. For temporary use , I changed codes at usock_win.inc\nFrom:\n  case NN_WORKER_OP_ERROR:\n                if (nn_usock_cancel_io (usock) == 0) {\n                    usock->state = NN_USOCK_STATE_DONE;\n                    return;\n                }\nTo:\n  case NN_WORKER_OP_ERROR:\n                if (nn_usock_cancel_io (usock) == 0) {\n                        nn_fsm_raise(&usock->fsm, &usock->event_error,\n                    NN_USOCK_SHUTDOWN);\n                    usock->state = NN_USOCK_STATE_DONE;\n                    return;\n                }\n. /***********/\n/  ACTIVE state.                                                            /\n/***********/\n    case NN_USOCK_STATE_ACTIVE:\n        switch (src) {\n        case NN_USOCK_SRC_IN:\n            switch (type) {\n            case NN_WORKER_OP_DONE:\n                nn_fsm_raise (&usock->fsm, &usock->event_received,\n                    NN_USOCK_RECEIVED);\n                return;\n            case NN_WORKER_OP_ERROR:\n                if (nn_usock_cancel_io (usock) == 0) {\n                        nn_fsm_raise(&usock->fsm, &usock->event_error,\n                    NN_USOCK_SHUTDOWN);\n                    usock->state = NN_USOCK_STATE_DONE;\n                    return;\n                }\n                usock->state = NN_USOCK_STATE_CANCELLING_IO;\n                return;\n            default:\n                nn_fsm_bad_action (usock->state, src, type);\n            }\n. ",
    "snikulov": "@daborg69 @egonuel could you please check if issue still here after this fix #219 ?\n. I think you can close this issue.\n. @djc Well, because:\n- I was also observed described issue on my Windows box while ago.\n- Changes suggested by @tailhook and @norsd targeted to solve assertion was combined and merged into upstream, and it solves the issue at least for me.\n- Original submitter @daborg69 not responded for long period (perhaps it move away from nanomsg or because issue not present on latest release).\nSo I see no reason to keep it open.\n. Hi All,\nI've restored cmake build for different platforms by reverting 0d14b38 commit on branch cmake_build here https://github.com/snikulov/nanomsg.git and rebase it with latest nanomsg upstream.\nSo if anybody still interested in cmake support for nanomsg we can keep cmake build here and will see how it goes.\n. @sustrik hey, I've already done that here http://www.freelists.org/post/nanomsg/Simplifying-CMake-build,19\n. Not really. I've spent less then week to restore it. So I welcomes anybody to test it on different platforms. Now win(msvc)/linux(gcc/clang - https://travis-ci.org/snikulov/nanomsg)) tested.\n. @sustrik Can we merge my branch with cmake into mainline? It will be easy to keep it in sync. Then we'll close this issue.\n. @norsd  could you please check if issue still here after this fix #219 ?\n. Sure.\nThis patch is submitted under MIT license.\n. Looks like duplicate for #172.\n@mdre77 could you please check this issue on latest release? \nThank you.\n. Sure. This patch is licensed under MIT license.\n. @gdamore Yeah. Working on windows stuff.. @gdamore \n\nLinux code is breaking too, so there is something wrong here. Its not obvious to me what the problem is there -- it would seem to be the case that this should work from reading the code, but it was working before your change, and the issue appears to be in the chunk stuff that does use atomics.\n\nDo you mind if it was not working before? :)\nWhat if I add the option to run tests under threadsanitizer? \nWill it be useful? . @gdamore all green now.. @gdamore because I evaluating nanomsg to use in production :) \nI'll not wait for nng, sorry.\nFollowing fixes were related quality of lib and test suite.\nIf you as maintainer doesn't care, I'll not either.. Same root cause of memory leak for nn_bws_create src/transports/ws/bws.c:109. Volatile was never adequate for multithreading.\nSo atomic_fetch is better, IMHO. Or Atomic_ flag for structure, but for C11. @gdamore Unfortunately I've not found such nice addition. . @gdamore anyway this is correct.\nNN_SHARED_LIB required only for building the library. \nSo I reduced the scope of compile definition for the specific target.. @gdamore suggesting another pull request? \nFor me, it is related, because I've checked changes with thread sanitizer. \nWe have thread leak in this case.. @gdamore perhaps, but nothing to stop use it multithreaded environment. And in my opinion, it is better to have some guard for that.. ",
    "andrewstarks": "This may be a case of the tutorials being out of date. I literally copied this from Tim's blog post:\n``` c\ninclude \ninclude \ninclude \ninclude \ninclude \ndefine NODE0 \"node0\"\ndefine NODE1 \"node1\"\nint node0 (const char url)\n{\n  int sock = nn_socket (AF_SP, NN_PULL);\n  assert (sock >= 0);\n  assert (nn_bind (sock, url) >= 0);\n  while (1)\n    {\n      char buf = NULL;\n      int bytes = nn_recv (sock, &buf, NN_MSG, 0);\n      assert (bytes >= 0);\n      printf (\"NODE0: RECEIVED \\\"%s\\\"\\n\", buf);\n      nn_freemsg (buf);\n    }\n}\nint node1 (const char url, const char msg)\n{\n  int sz_msg = strlen (msg) + 1; // '\\0' too\n  int sock = nn_socket (AF_SP, NN_PUSH);\n  assert (sock >= 0);\n  assert (nn_connect (sock, url) >= 0);\n  printf (\"NODE1: SENDING \\\"%s\\\"\\n\", msg);\n  int bytes = nn_send (sock, msg, sz_msg, 0);\n  assert (bytes == sz_msg);\n  return nn_shutdown (sock, 0);\n}\nint main (const int argc, const char **argv)\n{\n  if (strncmp (NODE0, argv[1], strlen (NODE0)) == 0 && argc > 1)\n    return node0 (argv[2]);\n  else if (strncmp (NODE1, argv[1], strlen (NODE1)) == 0 && argc > 2)\n    return node1 (argv[2], argv[3]);\n  else\n    {\n      fprintf (stderr, \"Usage: pipeline %s|%s   ...'\\n\",\n               NODE0, NODE1);\n      return 1;\n    }\n}\n```\n. Wow. That was shockingly dumb of me. :) Perhaps the way it is is a litmus test for whether or not you should be playing with these libraries.\nEverything works fine now, provided that I put the command line arguments in.\nFor additional insight:\n1: User builds nanomsg.\n2: User gets tutorials.\n3: User runs tutorials with no arguments.\n4: User receives \"segfault.\"\n5a: Inexperienced user will throw up hands and assume that something is wrong with how things were installed/their os, etc.\n5b: Experienced user never saw an error because they caught the fact that there were command line arguments and would not be at all surprised to see a segfault thrown for missing them, given it is such a minimal example.\nThank you very much for your gracious reply and help.\n-Andrew\n. Done. Thank you again.\n. 1. hmm... I'd expect one ETIMEDOUT and then all EFSM thereafter, given that ETIMEDOUT signifies the end of the survey and a condition that's easily trapped/avoided.\n2. Reported where? I get all survey responses without anything being raised. Should I check nn_errno() after each receive? \nAs it is, nn_recv (sock, &buf, NN_MSG, 0); is called and then returns with -1 and nn_errno() == EFSM. So I'm not sure how I would get NN_RCVTIMEO. \nBTW: NN_RCVTIMEO or even EAGAIN is fine, since in this context, that's the only sense that EAGAIN could make.\nEDIT:\nI think I may see the issue. If a connected socket doesn't return, that's where ETIMEDOUT might come into play.\nIf this is the case, then the current behavior makes sense and I'd suggest / happily close the issue.\nI'll check..\n. Having a respondent decline to respond (but still connect) has no effect. It still returns EFSM when NN_SURVEYOR_DEADLINE passes.\nNon confusing behaviour would be:\n1: All respondents reply. An attempt to receive results in EFSM. This is a tiny pain in the butt, but that's okay. It's probably inefficient to wait for the full timeout.\n2: All / some / none of the respondents reply. NN_SURVEYOR_DEADLINE is reached. -1 is returned and errno is ETIMEDOUT (or similar). Subsequent calls result in EFSM.\n3: Some variant of the above.\n. Very sorry for the noise.\nI misunderstood your second question.\nThe answer is no, there is no need to distinguish, as far as I can tell, if you are telling me that setting NN_RCVTIMEO to the correct value would have the same effect.\nThis may all come down to a change in the documentation and a removal of NN_SURVEYOR_DEADLINE.\n. I agree that ENOPROTOOPT would be a good choice. A list would not be appropriate. If that were a feature, it should be a different call.\nAlso returning the string value, in the case that the socket is already subscribed and NULL in the case that it isn't, would be okay, as well. That might be too \"high-level\", however, and can be done easily in the binding.\nIn any case, that there will be an error on nn_getsockopt would be a helpful addition to the manual.\n. On Mon, Jan 6, 2014 at 7:54 AM, Paul Colomiets notifications@github.comwrote:\n\nI started reading this: http://www.cmake.org/Wiki/CMake_Cross_Compilingand it seems that there is quite a lot involved in cross-compiling using\nCMake. Do I understand correctly that each new platform / toolchain\nrequires a new target (i.e. .cmake file)?\nYes. Each toolchain needs .cmake file. But it's not per-project\nper-toolchain file. I.e. if you contribute .cmake file to your arm\ntoolchain package, you can build any cmake project for arm. (According to\nthe docs, I have no practical experience).\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/210#issuecomment-31649526\n.\nFor me, the issue with CMake is that it's often used in place of a proper\nVisual Studio project. So, I can make the VS Project, but once made, I\ncan't actually use it in development. For example, switching between 64 and\n32 bit should simply be a matter of selecting the target in VS. When it's a\nCMake project, that's never the case.\n\nIn Unix-like environments, things can be the same with\nM4/Automake/Whatever...\nI understand that CMake/Autotools are used for build and deployment, so\nthis is a bit off-topic. I guess I'll just say that I love me a good\n\"makefile\". I can always figure out what is going on from one of those.\n...nothing to see here... :)\n-Andrew\n. On Mon, Jan 6, 2014 at 12:22 PM, Romuald Cari notifications@github.comwrote:\n\nIf\nsomeone wants to hack on the project (how many are there ?) using the\nVisual Studio IDE, I guess that's her/his problem.\n\nI'm not sure if it's quite this simple, although your conclusion is still\nvalid and one that I'm mulling over.\nIn our process, we build for 32 and 64 bit on Windows, plus Mac and NetBSD.\nWhen we are in MS, we use the solution file to manage things and use\ngit/github for source control.\nIn this setup, building nanomsg from source and within VS is much simpler\nthan independently updating it and importing the binaries every time we\npull master. So, a VS project that is able to switch between 64 and 32 is\npretty important and also and not possible with what CMake produces.\nThat said, I have no complaints. Nanomsg is a very well-organized project\nwith very few dependencies. I simply looked over the makefile and recreated\nthe VS project from scratch. I think that backs up your assertion.\nPerhaps a potential point of difference is that I view make and gnumake\nas lingua franca --- not CMake.\nMy only request is that no matter what is done in the name of\ncross-platform management, an extremely well-documented makefile remain as\nthe center of the project. There reason is more as a benefit to the humans\namongst us than anything else.\nI also believe that it is possible that I should just give up and learn\nwhat this \"cmake\" thing is all about. :)\n-Andrew\n. This does not match my experience. I can't get your examples to work and I don't think that they should work. However, I admit that it could be a bug in my code.\nIf I subscribe to \"\", then I'm subscribing to '\\0'. If I subscribe to \"foo\", then my topic is four bytes long: foo\\0\nIf I use my example, everything works. If I use yours, it fails. I'm happy to post the code that I'm using to set options and send messages, but it's for a Lua binding, so I'm not sure that it would be helpful.\nIs there somewhere I could go to see this at play? From what I can see:\n1: If you do not precede a message with a \\0, it will not be delivered to a socket that is subscribed to \"\"\n2: If you do not include a \\0 after your topic, it will not be picked up by any socket that is subscribing to that topic. That is, to use your example in the documentation, the assert fails for me.\nHelp?\n. Ohhh... Sorry. I see. You were setting the the size of the buffer to the number of characters in the string, not to size of the string, which would include the \\0, if you took the meaning of \"string\" as \"c-string\"\nDo you think that this deserves clarification, or am I using an imprecise interpretation that I should not have used?\n-Andrew\n. I think that you are correct. I admit that C is not my primary language and it's been a long time since I was steeped in it. Since defining the buffer length means that you typically don't count the NULL character, your examples are sufficient. \nHowever, using NULL is a neat trick, which might deserve demonstration. Do you think the examples would be too long, if there were modified, like so...?\n``` C\nint pub = nn_socket (AF_SP, NN_PUB);\nint sub = nn_socket (AF_SP, NN_SUB);\nint nbytes;\nvoid *buf = NULL;\nnn_setsockopt (sub, NN_SUB, NN_SUB_SUBSCRIBE, \"foo\", 3);\n//Tricky! Notice that we're adding the NULL to the end.\n//We're using the C-string NULL as the delimiter, so we set bytes to 4.\nnn_setsockopt (sub, NN_SUB, NN_SUB_SUBSCRIBE, \"bar\", 4); \nnbytes = nn_send (pub, \"foo|Hello!\", 10);\nassert(nbytes == 10);\nnbytes = nn_recv (sub, &buf, NN_MSG, 0);\nassert (nbytes == 10);\nnn_freemsg (buf);\nnbytes = nn_send (pub, \"bar\\0Hello!\", 10);\nassert(nbytes == 10);\nnbytes = nn_recv (sub, &buf, NN_MSG, 0);\nassert (nbytes == 10);\nnn_freemsg (buf);\n//...\n```\nI'll be happy to submit this, if you think that it is clarifying. What is there may be sufficient.\n-Adrew\n. On Friday, February 13, 2015, Paul Colomiets notifications@github.com\nwrote:\n\n@earonesty https://github.com/earonesty\nAny processing of the message is going to be order of magnitude slower\ntherefore we should never benchmark a transport layer?\nWe should. But it doesn't mean we should optimize 0.1% performance\nThis is faster in zeromq only if your consumer is slower than producer\nthis happens all the time, when the producer is, itself, a consumer\nWhen producer itself a consumer there is no latency issue, it just puts\nmessage in it's own queue and it's already there when it reads queue. I'm\nnot sure what you mean\nIt's faster only for inproc, other transports should be same speed\nbut not really\nYeah, the link to #319 https://github.com/nanomsg/nanomsg/issues/319\nsays that TCP is faster than inproc. So it only supports my position\nIt's faster until you use any polling mechanism\nyuck, who polls anymore? so 1997\nWell we are from different worlds. Most my applications are multiplexing\ndifferent things in single thread. May be you misunderstand what I mean by\npolling here?\n@gdamore https://github.com/gdamore\nIf you're passing data within the same process, there are dozens of better\nways to do it than nanomgs/inproc.\nTwo points here:\n1. Inproc is useful for passing data between multiple languages (e.g. C\nand Python) inside single process\n2. It's useful as a way to use nanomsg semantics (which is complex to\nemulate even using go channels), and to scale later (e.g. easily switch\nbetween inproc and network)\nBut none of them are very performance sensitive in my opinion. First one\nusually has big overhead because of \"impedance mismatch\" between languages.\nSecond is because you will use non-inproc at production anyway.\n\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/300#issuecomment-74265172.\n\nOur plan is to use improc between Lua states, serializing with msgpack.\nAlso, we pass pointer values (gasp) that way too, but for production we'll\nswitch to passing buffers with inproc.\n. On Friday, February 13, 2015, Paul Colomiets notifications@github.com\nwrote:\n\nIn fact, case 1 seems kind of a stretch IMO; if you have two languages in\nthe same process, its probably because you have FFI and one of them is C,\nin which case you probably have a better way to move data between languages.\nI mean two languages in different threads communicating between each\nother. Useful in Python because of GIL.\nI'm not sure that making inproc with socket pipe is good idea. We probably\nshould ask @sustrik https://github.com/sustrik, as I think he had some\ngood cases for fast inproc transport from the ancient zeromq times.\n\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/300#issuecomment-74346982.\n\nThis is useful for any language that wants to mimic a message passing\npattern that is network transparent.\nFor example, Lua is not multi-threaded, but does coroutines (not really\nrelevant).\nAnyway, spolling up a second thread and passing messages inproc between\nstates is a very clean design.\nWith inproc / nanomsg, you have a familiar socket interface and message cue\nplus the possibility to implement / ad hoc other super-fast architectures\nusing bus, pub/sub, etc.\nWe would use something else, if there was too much additional\noverhead/latency.\n-Andrew\n. ",
    "diffuse": "No reason this was needed.  Just found the issue reviewing code.\n. Produced with latest rev in git: 46d735b949b88a04da5f2479c18829c72d36fb59\n. Thread 2 (Thread 0x7ffff7199700 (LWP 31028)):\n0  0x00007ffff71a851d in __lll_lock_wait () from /lib64/libpthread.so.0\n1  0x00007ffff71a411b in _L_lock_812 () from /lib64/libpthread.so.0\n2  0x00007ffff71a3fe8 in pthread_mutex_lock () from /lib64/libpthread.so.0 <-- stuck trying to acquire nn_glock_mutex\n3  0x00007ffff7b9eeb8 in nn_glock_lock () at src/utils/glock.c:63\n4  0x00007ffff7b9379c in nn_global_submit_statistics () at src/core/global.c:1126\n5  0x00007ffff7b93b9b in nn_global_handler (self=0x7ffff7ddca48 , src=1,\ntype=1, srcptr=0x7ffff7ddcaa8 <self+776>) at src/core/global.c:1289\n\n6  0x00007ffff7b98146 in nn_fsm_feed (self=0x7ffff7ddca48 , src=1, type=1,\nsrcptr=0x7ffff7ddcaa8 <self+776>) at src/aio/fsm.c:72\n\n7  0x00007ffff7b98102 in nn_fsm_event_process (self=0x7ffff7ddcb58 )\nat src/aio/fsm.c:66\n\n8  0x00007ffff7b97ebc in nn_ctx_leave (self=0x7ffff7ddc9f0 )\nat src/aio/ctx.c:63\n\n9  0x00007ffff7b9da5d in nn_worker_routine (arg=0x7ffff7ddc7e0 )\nat src/aio/worker_posix.inc:189\n\n10 0x00007ffff7ba0704 in nn_thread_main_routine (arg=0x7ffff7ddc9d8 )\nat src/utils/thread_posix.inc:35\n\n11 0x00007ffff71a1ee5 in start_thread () from /lib64/libpthread.so.0\n12 0x00007ffff78b7b8d in clone () from /lib64/libc.so.6\nAdding nn_glock_unlock() to line 1125 in ./src/core/global.c before nn_glock_lock prevents the deadlock.  It appears something isn't freeing the lock correctly. \n. This issue was fixed by commit a52e25102f55ad72978c6a4691c3aeece7d18563\nOn Mon, Jan 26, 2015 at 2:31 PM, George Lambert notifications@github.com\nwrote:\n\nA change has been merged - is this issue still open?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/342#issuecomment-71522044.\n. Looking at the patch, this should also fix the hang on tcp pipeline bug #342\n\nOn Sun, Dec 7, 2014 at 2:21 AM, bnewbold notifications@github.com wrote:\n\nOk, I fixed my 'master' and now there is only the one commit. I guess\nthat's why it's good to use pull-request-specific branches!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/346#issuecomment-65929255.\n. Patch has resolved my issue.  I support its merge as well.\n\nOn Wed, Dec 17, 2014 at 9:19 AM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nThis patch has resolved issues I've also encountered, and I support its\nmerge to trunk.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/346#issuecomment-67327799.\n. I don't think it is necessarily the best idea to implement application\nspecific features in nanomsg....\n\nYou can just do somethign similiar to this in your software:\nretry_bind:\n    port = generate_random_port();\n    service_string = \"tcp://127.0.0.1:%d\" % port;\n```\nrc = nn_bind(sock, service_string);\nif (rc < 0)\n{\n     if (rc == INUSE)\n         goto retry_bind;\n }\n```\n....\nOn Tue, Mar 10, 2015 at 10:40 AM, Bent Cardan notifications@github.com\nwrote:\n\n@amosbird https://github.com/amosbird, that scheme sounds overly\nprocedural and specific for such accommodations by library.\nbut that's just my opinion, and you may be onto something after-all.\nOne way this would make sense to me is if the random bind function somehow\nreturned which port was bound, or perhaps in the alternative, if a later\ncall to getsockopt() with level NN_TCP returned additional information\nabout the socket's connection string.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/382#issuecomment-78066943.\n. We could conditionally define size_t on OSes that are missing size_t,\n\ni.e.\nif WIN32\ntypedef SIZE_T size_t;\ntypedef SSIZE_T ssize_t;\nendif\n. Would you agree this would be a good change to make?\n. The return type should be ssize_t because nn_send/recv need to be able to\nreturn negative values on error.\nOn Tue, May 5, 2015 at 1:29 PM, Dirkjan Ochtman notifications@github.com\nwrote:\n\nWouldn't size_t be better than ssize_t here? I'm +1 on the overall idea,\nthough.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/403#issuecomment-99151752.\n. \n",
    "cheme": "Very fast, it seems ok :\n[emeric@miniFL nanomsg-hs]$ ./main\nError ENOMEM = Cannot allocate memory\nThanks a lot, I close the problem.\nJust for info, when building, the shutdown testcases fail (I don't remember if they pass yesterday).\nI notice all shutdown tests failed when I build from mainline.\n. Windows? I didn't know it was supported. I'm using a linux (arch mainstream).\nI will get a look later if/when I got time.\n2013/10/23, Paul Colomiets notifications@github.com:\n\n\nI notice all shutdown tests failed when I build from mainline.\n\nIf it's on windows then it's because of #169, that  improved shutdown tests,\nbut haven't fixed the issue for windows. There is issue #172 for it.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/nanomsg/nanomsg/issues/175#issuecomment-26933131\n. Oh sure,\n\nthe patch, is submitted under MIT license.\nSorry for the lack of introduction, my name is \u00c9meric Chevalier\n(France),  I'm currently playing a bit with haskell FFI and use\nnanomsg as as sample (still in nn.h), at best I would like to reach\nsome point where I'm able to reproduce  the ZMQ Guide first samples\nfor DHT (in haskell); but in fact I haven't already thought about how\nto replace the Router socket.\nAnd by the way, thanks for nanomsg.\n2013/10/23, sustrik notifications@github.com:\n\nCan you state that the patch is submitted under MIT license? Also, what name\nI should use as an author of the patch?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/nanomsg/nanomsg/pull/176#issuecomment-26925896\n. Yes, it may be the idea,\nanyway, the pull request is meaningless, I close it (sorry for the delay).\n. True, my test case was creating a Pub socket with Address Family AF_SP_RAW (there is no xpub). I was getting EINVAL and was expected EAFNOSUPPORT.\nThis is what did the patch, but I think it is a bit awkward :\u00a0in fact we return EINVAL in all error cases except when there is an existing domain (AF_SP when only two AF), that way when there is an existing address familly for the protocol (the protocol exists) but not the expected address familly (AF_SP_RAW) we return EAFNOSUPPORT. \n. \n",
    "tonysimpson": "Your branch fixes this issue for me and builds cleanly.\n. ",
    "TTimo": "FYI - we've built a C test case for this: https://github.com/TTimo/nanomsg/blob/99c211bbb4cc67e4fb636ef0725e8fb382d62970/tests/ipc_pub_disconnect.c\nAnd finding interesting things. The behavior above seems confirmed for TCP transport (OSX working, Windows never getting a message out of the sub after the pub disconnected). But for an IPC transport we see different failure modes between Windows and OSX (and both platforms failing the test).\n. More info here: http://www.freelists.org/post/nanomsg/Windows-IPC-pubsub-worker-routine-never-exits-after-the-pub-side-is-closed\n. refreshed the pull request against latest master code\n. Our change leaves the reconnect up to the client logic. Before the change, on Windows the client would either never return, or with NN_DONTWAIT it would never read anything, not detecting that the peer was gone.\n. Oh wow, confused the hell out of me. Looks like you guys pulled in some of the stuff I had been doing towards the named pipes support? Well I'm glad it did help a little bit..\nYeah sure, I'm fine with MIT licensing.\n. Sure is. I'm in the authors already. MIT/X11 license is fine.\n. ipc_stress failed to link without them (can't find the symbols). I realize this is part of the internal API and not meant to be exported, but not sure how to fix.\nAs far as the test itself not passing, nn_efd_wait (the NN_HAVE_WINDOWS version) is getting called but nn_efd * self seems corrupted:\nnanomsg.dll!nn_efd_wait(nn_efd * self, int timeout)  Line 71    C\n\nnanomsg.dll!nn_sock_send(nn_sock * self, nn_msg * msg, int flags)  Line 603 + 0x10 bytes    C\n    nanomsg.dll!nn_sendmsg(int s, const nn_msghdr * msghdr, int flags)  Line 755 + 0x1a bytes   C\n    nanomsg.dll!nn_send(int s, const void * buf, unsigned int len, int flags)  Line 655 + 0x11 bytes    C\n    ipc_stress.exe!client(void * arg)  Line 69 + 0x16 bytes C\n    ipc_stress.exe!nn_thread_main_routine(void * arg)  Line 30 + 0x10 bytes C\n    msvcr100d.dll!_callthreadstartex()  Line 314 + 0xf bytes    C\n\nself->r is an invalid value like '3452816845'\nI'm on IRC for a few hours if you want to discuss this more directly. \n. will do\n. updated, looks better now\n. not sure why it's still open. closing\n. Are you on Windows @metadings, or on a different platform?\n. Makes sense. That nn_dist_send doesn't depend on the protocol. It could be specific to the socket type though (pub/sub), or a problem with the IO completion port management.\n. FWIW We have a fix in our heavily modified branch off of 0.4-beta tag, and we have been working on building a clean merge request against trunk (still having difficulties there though, see https://github.com/TTimo/nanomsg/tree/issue_283)\n. The fix we put together is working fine for us in production code (e.g. it has passed QA). I had made an attempt at a merge request to upstream here, but I need to redo it (some weird things happened with git that made the first one inadequate). \n. @bennykj I extracted the code we are using in our repository and sent the pull request above to master. Can you check if that resolves your problem.\n. So that makes the protocol 'unreliable' then. It should at least return error codes when messages are getting dropped. I'm not sure how people hope to ever use this in production as is.\n. bump .. hey @sustrik, hopefully you find some time to review over the weekend .. we're trying to ramp up nanomsg under Windows and it's been a bit difficult .. so we'd like to make sure the ball keeps on rolling ..\n. Will redo this request with a correct base branch.\n. No problem, I'll resubmit as a clean commit. It's so simple that you could just write a new fix too, I'm just pointing out the issue here.\n. Replaced by https://github.com/nanomsg/nanomsg/pull/302\n. Will redo this request with a correct base branch.\n. Replaced by https://github.com/nanomsg/nanomsg/pull/303\n. @wirebirdlabs the commit you linked doesn't apply cleanly against nanomsg master. It looks like some of your changes are already in master, whereas the change is otherwise built on older code. I was able to fix the merge conflicts correctly I believe, but tcp_shutdown still has the same failure pattern that I am working around in this pull request, in nn_sock_shutdown on\nnn_assert (src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED);\n@wirebirdlabs your merged change against nanomsg master is at https://github.com/TTimo/nanomsg/tree/pull_303_internal_216_wirebirdlabs if you are interested in refining it.\n@sustrik your input would be very welcome here. I am working to submit a few more pull requests, but they in part depend on this fix.\n. I may have closed this one by mistake. It's still an issue / fix which we have in our prod code.\n. I think you misunderstood @sustrik. If you run the ipc_flood test against current nanomsg trunk on Windows, you will see that a sub is connected, and it is not getting all the messages sent by the pub, they are simply dropped.\nIt is not a semantic problem of 'no one is listening', it is an implementation bug where messages are silently never transmitted.\n. The first message goes through, the ones after that are dropped. That's how\nI know it connected.\nAlso the test is a bit contrived, but we are seeing this in production code where we know the sub is connected.\n. http://stackoverflow.com/questions/26707050/iocp-how-does-the-kernel-decide-to-complete-wsasend-synchronously-or-asynchrono\n. That was the last response from @sustrik via email:\n\" Let's add \"int txbuf\" member to nn_usock. It will be initialised to 0 and incremented with every send operation by the number of bytes sent. Also, when send completes (usock_win.inc:852) it will be decremented appropriately. That way we'll have precise idea of how much outbound data is buffered at any given moment.\nAfterwards, when sending, we can disable more sends once certain buffer limit was exceeded.\"\nNon trivial work, but it would lead to a correct fix. My patch forces a wait on send and forces the API to be synchronous.\n. No immediate plans no.\nOver the past year our group has submitted a number of pull request to correct a few significant deficiencies in the Windows support.\nMost of these patches are still sitting in the queue; I can't justify putting resources towards more nanomsg contributions in the current state of things.\n. Is there something in the nanomsg docs that clearly explains that PUB/SUB\nis unreliable? I don't think I ever ran into silent unreliable behavior\nwhen doing PUB/SUB with say, zeromq\nOn Sat, Oct 24, 2015 at 6:46 PM, gdamore notifications@github.com wrote:\n\nClosed #320 https://github.com/nanomsg/nanomsg/pull/320.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/320#event-444705239.\n. There's a pretty good explanation there:\nhttp://zguide.zeromq.org/php:chapter5#Pros-and-Cons-of-Pub-Sub\n\nAlright I learned something today. Thanks for going through through those\nold PRs :)\nTTimo\nOn Sun, Oct 25, 2015 at 10:28 AM, gdamore notifications@github.com wrote:\n\nI think the docs are deficient.\nBut yes, zeromq suffers from the same behavior. If you've not run into, it\nmay be that you've been lucky, or perhaps the data rates you push are\nlower. Also, zeromq has additional buffering, and eliminates a level of\nsystem calls, so its probably somewhat less likely to drop under load.\nNone of that changes the fact that architecturally, for both nanomsg and\nzeromq, PUB/SUB is unreliable.\nIndeed, much discussion around the \"slow-start\" problem for both zeromq\nand nanomsg is a direct consequence/allusion to this problem. If the\nprotocols were reliable, or gave notification back to the application, then\nslow-start would be a non-issue. :-)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/320#issuecomment-150934790.\n. Should patch this up too: https://github.com/nanomsg/nanomsg/commit/1ae64bb578a74bd0912698bb4771cbc6e2e69d07 - and any others like it\n. Will do. That's still on my bucket list.\n. Yeah I won't get to it. I'm not working with nn anymore.\n. Oh yeah probably a copy paste from another test case. I'll go over your code review comments and clean this up further sometimes in the next few days.\n\nThis code is only added to the cmake project files, so it should only be compiled and tested on Windows.\n. I will check, but I think it is related. Windows would silently drop messages otherwise, and we need a way to tell when it wasn't sent due to a socket with a full buffer.\n. ",
    "elektito": "Was this problem fixed? I have the same problem here on Linux. With TCP the subscriber reconnects, with IPC it doesn't. Checked with nanocat, too. I tried both the 0.8-beta release and the latest code on the master (8f873b45).\n. ",
    "meszengisser": "I would like to develop a client application example using RIOSend(), but there is no example at http://www.serverframework.com/asynchronousevents/rio/ .\nI\u00b4m trying to do the same as the tutorial does when he builds the RIOReceive() at RIOPulledUDP app.\nDoes anyone has a practical example of how to send data at RIO using RIOSend()?\n. ",
    "vinoski": "The EFSM occurs here when no responses are received before the survey deadline: https://github.com/nanomsg/nanomsg/blob/master/src/protocols/survey/surveyor.c#L238\nWhile the surveyor waits for responses, the timer expires, the surveyor state transitions from NN_SURVEYOR_STATE_ACTIVE to NN_SURVEYOR_STATE_STOPPING_TIMER and then once the timer stops transitions to NN_SURVEYOR_STATE_PASSIVE. When the check for survey-in-progress occurs again at https://github.com/nanomsg/nanomsg/blob/master/src/protocols/survey/surveyor.c#L237 , the passive state results in the code thinking there's no survey in progress, so it returns EFSM.\nTo fix this, it seems like the surveyor fsm needs to be a little smarter about tracking the fact that a survey failed, rather than just transitioning back to the passive state when the timer stops.\n. The test suite for the Erlang nanomsg driver can reproduce this assertion/abort fairly reliably:\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:828)\nAre there any imminent plans to turn the wiredbirdlabs fix into an actual pull request?\n. I've been running tests against the @wirebirdlabs fork to pick up this fix, but it hangs on pretty much every test run. Not sure why yet \u2014 I need to do some debugging to get more details. Not sure but it might be handy if just the commits for this fix were available on a branch by themselves to make it easier to isolate their effects from other changes.\n. It works much better with the global.c change reverted, but now testing has revealed the crash described below, which occurs because the original nn_assert (src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED) is no longer in src/core/sock.c:\n```\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_PROTECTION_FAILURE at address: 0x0000000100000007\n[Switching to process 30642 thread 0x3feb]\n0x000000010389e6bc in nn_list_erase (self=0x10050ce10, item=0x100852560) at src/utils/list.c:101\n101         item->next->prev = item->prev;\n(gdb) bt\n0  0x000000010389e6bc in nn_list_erase (self=0x10050ce10, item=0x100852560) at src/utils/list.c:101\n1  0x0000000103891a71 in nn_sock_shutdown (self=0x10050cc80, src=0, type=33988, srcptr=0x1008524e0) at src/core/sock.c:840\n2  0x0000000103894dcd in nn_fsm_feed (self=0x10050cc80, src=0, type=33988, srcptr=0x1008524e0) at src/aio/fsm.c:74\n3  0x0000000103894d54 in nn_fsm_event_process (self=0x100852580) at src/aio/fsm.c:66\n4  0x0000000103894a6a in nn_ctx_leave (self=0x10050ccf8) at src/aio/ctx.c:63\n5  0x000000010389bc99 in nn_worker_routine (arg=0x1038c4918) at worker_posix.inc:233\n6  0x000000010389fc9e in nn_thread_main_routine (arg=0x1038c4db0) at thread_posix.inc:35\n7  0x00007fff96179899 in _pthread_body ()\n8  0x00007fff9617972a in _pthread_start ()\n9  0x00007fff9617dfc9 in thread_start ()\nCurrent language:  auto; currently minimal\n(gdb) p item->next\n$1 = (struct nn_list_item *) 0xffffffff\n(gdb) up 1\n1  0x0000000103891a71 in nn_sock_shutdown (self=0x10050cc80, src=0, type=33988, srcptr=0x1008524e0) at src/core/sock.c:840\n840         nn_list_erase (&sock->sdeps, &ep->item);\n(gdb) p src\n$2 = 0\n(gdb) p type\n$3 = 33988\n```\nBased on the values of src and type shown here, this would have also hit the original assert if it were still present in the modified src/core/sock.c.\n. @wirebirdlabs the Stack Overflow comment is correct; poll returns events, not errors, when sockets in its pollset are closed, so this change won't help on non-Windows platforms.\n. ",
    "daniel-j-h": "If it \"looks like a bug\", then at least change the documentation or provide a warning.\nRight now the documentation says \"ETIMEDOUT will be returned\". Which is simply wrong: https://github.com/nanomsg/nanomsg/blob/6a333ae616c9dd1893c2a47e2b5a8b52b433fa77/doc/nn_survey.txt#L23-L27\nEven the nanomsg tests check for EFSM: https://github.com/nanomsg/nanomsg/blob/6a333ae616c9dd1893c2a47e2b5a8b52b433fa77/tests/survey.c#L71\nI lost a great amount of time by adhering to the specification.\n. ",
    "zugl": "Hi there.\nI've created a fix for this in PR #417. Works for me.\n. Hi there, mguijarr.\nThis issue could be related to the same problem, yes.\n. Is this ok?\n. ",
    "rbx": "Update: In case of IPC, it sometimes crashes with the following assertion:\n~/nanomsg/perf$ ./remote_thr ipc://a 1000000 100\n~/nanomsg/perf$\n~/nanomsg/perf$ ./local_thr ipc://a 1000000 100\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (src/utils/queue.c:78)\nAborted (core dumped)\n~/nanomsg/perf$\n. I am still able to reproduce this with 0.6 beta.\nUpon some further investigation, it seems that the problem comes from the sender calling nn_close() too soon after the send() call. So that the queue gets terminated before the data is sent out. Thus the receiver keeps waiting for it forever.\nI was able to fix this by introducing a sleep (for example 10 seconds) on the sender side. It allows the sender queue to finish before nn_close() is called.\nI tried to increase the NN_LINGER to 10 seconds, but strangely it didn't help at all. So perhaps the bug is with the lingering?\n. We are observing Assertion failed: self->next == NN_QUEUE_NOTINQUEUE (../src/utils/queue.c:102) in some of our use cases when sending messages larger than 1MB (exactly => 1048577 bytes).\nUsing the supplied remote_thr/local_thr benchmarks, or our own benchmarks (pub/sub or push/pull) leads to either this assertion or hangs indefinitely or significantly decreased throughput (from tens of Gb/s to Kbs/s, followed by the assertion).\nIt does not seem to be related to shut down, because in the supplied benchmarks we inserted a longer sleep before starting any shutdown calls, due to #206. \n. I was using TCP for these tests.\n. After setting NN_RCVMAXSIZE to -1 I don't see any more hangs/assertions or (significant) throughput decrease.\nYes, it would make sense if the perf utilities set this option to the value of the provided msg size argument.\nThanks for quick response!\nJust for my understanding, is it bad to have the value of this option at -1 by default?\n. ",
    "borisz": "Sure, this patch is submitted under the MIT license.\nThanks\n. ",
    "NewbiZ": "Fixed in 2be1dfd. Should be closed.\n. I don't think this really needs to be in the docs, since you should use either libtool or pkgconfig.\nAs for libtool, the libnanomsg.la is fine, but the problem seem to be that libnanomsg.pc.in does not reuse the libraries found in configure.ac.\n. - Rerun configure and reinstall nanomsg with the following patch to libnanomsg.pc.in.\n- Check that your PKG_CONFIG_PATH contains the path where libnanomsg.pc will be dropped (usuallly $prefix/lib/pkgconfig)\n- Check in $prefix/lib/pkgconfig/libnanomsg.pc that the proper -lanl flag was added to Libs and -pthread to Cflags.\n- Use $(pkg-config --libs --cflags libnanomsg) for gcc to link your program.\n- Libs: -L${libdir} -lnanomsg\n+ Libs: -L${libdir} -lnanomsg @LIBS@\n- Cflags: -I${includedir}\n+ Cflags: -I${includedir} @PTHREAD_CFLAGS@\nNot sure if that's portable for PTHREAD_FLAGS, but since pthread flags are stored in @CFLAGS@ (which we do not want in the .pc) :( this is the best worst-case I can think of.\n. Seems like something already bind 5555.\nCan you check with $ lsof -i :5555\n. This should be reopened. Tests should bind on port 0 to ensure we are not using an already used port. Will see if that's possible and add a pull request.\n. Well, I can see one case where ephemeral ports are useful: When you have a REQ/REP pattern, with long processing time for responses.\nHaving long running connections in this case is often not desirable. They use unnecessary FDs, they have to be kept alive, etc.\nIn this case I tend to bind a response socket on the client on an ephemeral port, and give it along with my request. The server will connect to it when the response is ready.\n. ",
    "rcari": "Well, that would not stop you from using autotools for these as well. I mean, modern Linux distros have CMake in their package managers and some projects might benefit from having a choice to integrate nanomsg using CMake rather than autotools. I was just wondering why only support Windows with CMake when Linux and others could also be supported as CMake is designed to be cross-platform.\n. Well, my point was that everything could be managed in a CMake-only build\nsystem. Everything would stay up to date for all platforms if CMake was the\nreference. Visual Studio solution and project files is a non-issue in my\nopinion. This is specific to an IDE and it's for the users of that IDE to\ndeal with their specific issues. On Windows, CMake can be used to generate\nNMake makefiles and build the libraries without any major problem. If\nsomeone wants to hack on the project (how many are there ?) using the\nVisual Studio IDE, I guess that's her/his problem.\nWhen it comes to cross-compiling, I guess CMake is better suited as it was\nbuilt with this problem in mind. All you have to provide is a toolchain\nfile for the target platform which usually are provided with BSPs for\nmodern hardware. No need to do hackish things in most cases.\nOn Mon, Jan 6, 2014 at 10:14 AM, Mikko Koppanen notifications@github.comwrote:\n\n@madscientist42 https://github.com/madscientist42,\nI assume the latest one was referred to me. I wasn't implying that \"it\nisn't there\", rather you asked for non Linux/*BSD systems that are common\nin this space.\nAs for your comment on Visual Studio solution files: In the past I've\nnoticed that managing the solution files creates a lot of unnecessary noise\n(when edited in Visual Studio). In addition to this you have different\nversions of solution files and migrations don't always go smoothly.\nAlso, the problem tends to be that Windows platform is not used by\nmajority of the developers (which in turn causes Windows build files to be\nout of date if they require VS). I assume this is why CMake is used for\nWindows instead of the solution files.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/210#issuecomment-31671538\n.\n. A BSP is a Board Support Package, it's usually some minimalistic Linux\ndistro custom-tailored for a specific board. It also contains toolchains\n(compiler, linker, libc, libstd++...) for cross-compiling and so on. In\nmore recent releases from major vendors it may even contain a CMake\ntoolchain file. Those files are pretty easy to write anyway (really!).\nI confirm that #80 is wrong. I cross-compile many CMake-based projects for\nembedded Linux or Android without any issues aside from providing a proper\ntoolchain file and being thorough in what I do (path to libraries, path to\nbuild-tools and so on...).\nFor a \"simple\" package like nanomsg that has very little dependencies, this\nwould be completely straightforward.\n\nOn Mon, Jan 6, 2014 at 10:31 AM, Paul Colomiets notifications@github.comwrote:\n\n@rcari https://github.com/rcari what is BSP? And can confirm that #80\n(comment)https://github.com/nanomsg/nanomsg/pull/80#issuecomment-20920440is wrong?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/210#issuecomment-31672997\n.\n. \n",
    "madscientist42": "Actually, ipechorin, CMake is a packaging item in RedHat, Fedora, Debian, Ubuntu, etc.  Sorry...not buying that one as a reason to NOT do that.\n. As for cross-compiling...  Autotools better?  Really??  Scratchbox/Scratchbox2 was developed for the express purpose of side-stepping the cross-compile problems that were found in the early days of Maemo with Autotools.  I had to ditch trying to use Thrift for Protobufs in a project (The RPC is more what many are familiar with on Thrift...) because they'd screwed up their macros and it WOULDN'T cross-compile- not even with the helpful metadata tools OpenEmbedded provides to sort those problems out.\nI honestly and fervently wish people would quit using Autotools.  It's entirely too easy to mess the build-system up compared to other solutions.  It'll work on a host system, but there's entirely too many easy ways to leak it out of the sandbox without something like Scratchbox to bail it out.\n. 1) Is there any UNIX distribution with Autotools bundled?  No.\n2) For those that don't have it as a package, you're going to have to bootstrap EITHER.\n3) How many non Linux/*BSD systems are you going to have this running on?  AIX?  Not much used anymore.  Solaris?  \nHonestly, it's a non-argument point.  If you're making Autotools a requirement, you're doing the SAME thing as if you did it with CMake.\n. In truth, it's analogous to all those M4 and Bash scripting macros you're having to write to get the tests done.  Moreover, most targets DON'T need special stuff because you're talking POSIX, etc.  \nYou only need a .cmake for anything that deviates radically from the current sets.  \nHaving said this, andrewstarks has the truth of it.  It matters little, really, so long as you can manage the macros CORRECTLY.  It's just been my personal experience that it's rather easy to botch them on Autotools and less so on CMake.  Every time I turn around and have to add something to OpenEmbedded as a build recipe for packaging, I end up having \"issues\" with about a fourth of the Autotools stuff and none with CMake- and the CMake stuff tends to be less voluminous than Autotools does.  Why do I have problems?  Because even though it purportedly takes care of cross-compilation, unless your tests account for it properly, it actually does nothing of the sort.  Unless you have something radically diffferent than a POSIX compliant system, CMake just simply works when you declare the project a CMake project in OpenEmbedded...each and every time.  If you have something else as a target, you add .cmake files to the modules, etc. path in your project.  Little different than the macros, really.  But...you have to ask yourself...what are you targeting?\nSaying it's not there as a reason not to do it?  That's when I spoke up- it's FLATLY bogus.  If you can manage it and believe it to be \"easier\" (Terse M4 macros versus an actual programmatic expression is \"easier\"?) go for it because as long as it's not broken and builds right cross-compile and host compile, it's fine.  Having said this, you use it to generate the VC++ solution file.  If you're doing that, why are you using Autotools in the first place?  Seems like a lot of work wherein you could just make the .sln file in VC++ and stick with Autotools for the POSIX stuff.  Strikes me as even MORE work than you probably want to sign off on.\n. As for Solaris: https://www.opencsw.org/package/cmake/\nSorry...again...if you're saying \"it's not there\"...you're really being misleading to say the least.  You have to bootstrap Autotools on that target as well.\n. Autotools isn't exactly designed for what we're talking about her.  It's\ndesigned to fix the GNU's perceived problems.  (Namely trying to build on a\nbunch of VERY old, VERY broken compilers and system libraries- which,\nwhile laudable, is a QUESTIONABLE concern these days...)  And then, the FSF\nthought it was the greatest thing since sliced bread and that everyone and\nhis dog should use it.  It is less useful for the problems that most\ndevelopers face.\nI'm like you.  I don't exactly like it either, but I really dislike\nAutotools.  Rather than boring the discussion here, I'll give my rant on\nStackOverflow:\nhttp://stackoverflow.com/questions/4071880/autotools-vs-cmake-vs-scons/18291580#18291580\nI'll not walk away if the project keeps Autotools- but I WILL rib the\nhell out of the lot and tell you I told you so if you do and you manage to\nbreak cross-compilation in the process...   >;-D\nThis is not just for Windows.  But for ARM, MIPS, and the like- not\neverything in that space is beefy enough to do host compilation and not\neverything (not even close) that at least this library would be for is\ngoing to be sitting on X86.  Everyone that is for Autotools has never had\nto maintain the damned thing on a complex project, or try to make it play\nright on a cross-compilation.  Scratchbox/Scratchbox2 was commissioned by\nNokia for Maemo to compensate for the problem I talk to in the rant and\nhere.  CMake was developed to replace Autotools for those reasons.  (For\nthe record, I have had to sort out all sorts of screwed up on Autotools on\nnumerous projects- a solid third of the projects do not properly care or\nwatch for stupid things that cause you to pop right out of the\ncross-compile sandbox.)  I wrote that rant when I was trying to make Thrift\ncompile in OpenEmbedded so I could add it to a target's SDK for a client.\nHad to discard it and go with something else because it just was too much\npain to FIX the blasted Autotools scripting because it was everywhere and\nmade blind assumptions to /usr/... and the like.  It's easy to make these\nmistakes because you're using a twisted mix of M4 macros and bash scripting\nto do the load lifting on everything.  That's why I really dislike it\neverywhere I go.  At least with CMake, I can readily make it behave without\nScratchbox and expect 99% of the projects that used it to have largely\ngotten it \"right\" for cross-compilation under any context.\nOn Mon, Feb 23, 2015 at 10:06 AM, Chip Collier notifications@github.com\nwrote:\n\nLate to the party here, but CMake makes it very easy to automatically\ninclude a library as an external project. It's also a build system\nsupported by several IDEs directly.\nSo I just wanted to toss a +1 in here in favor of supporting CMake\nofficially again.\nI don't exactly like using it, but it's had a net positive impact on my\nwork. I understand the arguments for autotools in regards to the interests\nof package maintainers, but I've never worked someplace that didn't require\nmanaging specific versions of packages for our builds independently of a\nplatforms available packages. For this CMake is very well suited.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/210#issuecomment-75572140.\n. \n",
    "leonpegg": "Cmake is available on Debian Ubuntu fedora etc in normal repos \n. ",
    "cjgdev": "Someone needs to come in with Scons, waf and gyp, otherwise this discussion is just going around in circles. I think every developer who values their professional integrity knows when to use the tools they are accustomed to, and also can see when those tools are less suited to the intended use-case, making it time to consider alternative tools by their relative merits. After all, we all had to learn our favourite build system at one point (and autotools at another!). I think this project really needs a build system that supports Unix, Linux and Windows sufficiently well to get at least as good coverage as other, near competitor libraries.\n. As finance institutions are mentioned specifically, it may be worth noting that Bloomberg have done away with the old tools of the past, and now rely on waf for building their core libraries, which support most platforms, including various flavours of Unix, Linux and Windows.\nWaf is written in Python, so there is an interpreter available for virtually everything (even those legacy Unix systems). It may not be as battle hardened as Autotools, but it certainly works well enough for Bloomberg which probably owns half of those legacy Unix systems still in use.\n. Autotools isn't perfect, but perhaps more importantly it doesn't match what appears to be the project requirements. My challenge to the authors and the contributors is are you able to find a better solution than that?\nI'm deliberately playing devils advocate here because I'm seeing a lot of alternatives out there that are working for a lot of different projects, and I'm not convinced that they have been evaluated carefully enough.\nMaybe it's not a big deal at all, and the Windows developers should just be glad to have any support at all. My concern is that the two systems are sufficiently different that the cost of maintaining both will outweigh the benefits.\n. Can you please specify the platform, compiler, and tag you're building from?\n. ",
    "zerotacg": "some links, note quite up to date but still might gives some hints, but in the end I'd go with how KDE decided \"who codes, decides\" :) just let the main contributors vote\nhttp://ubuntuforums.org/showthread.php?t=692692\nhttp://www.scons.org/wiki/SconsVsOtherBuildTools\nhttp://lwn.net/Articles/188693/\n. I was just going the easy way, I know cmake and there where only minor changes needed to make it build.\nI'm not quite sure what it would take to port it to autotools.\n. trying to port building to autotools as well but I get undefiend reference errors\neg:\nnanomsg/src/utils/clock.c:126: undefined reference to `__imp_nn_send'\nit seems that the lib it self is build with names without the __imp prefix\n[zero@zero:/d/work/nanomsg/nanomsg]$ nm .libs/libnanomsg.a | grep nn_send\n0000000000001230 T nn_send\n0000000000000f40 T nn_sendmsg\nhow would I make it to compile using the prefix? or not using the prefix for nanocat?\n. got a working version to build with autotools, would be nice if someone could have a look and check the changes\ncommited under MIT license\n. Tobias Peters tobias.peters@kreativeffekt.at\nthx\n. sry :D\n. should be straight forward, for autotools\npath/to/nanomsg> ./autogen\npath/to/nanomsg> ./configure\npath/to/nanomsg> make\nfor cmake I'm not sure as I use a gui tool but should be just the default cmake commands as in any other cmake base build\n. the required define should be set [1] did you check the output of ./configure?\nI just did a clean on the repository, and build it with the 3 commands stated above\nI did run the commands from bash, maybe it's not working from cmd?\nas an alternative you could still use the cmake base build which I find a bit easier and as I use QtCreator I can run it directly from the IDE\n[1] https://github.com/nanomsg/nanomsg/blob/master/configure.ac#L214\n. building with mingw64 seems to work for me, not quite sure if I mixed up the setup I got\nconfigure does detect my system as mingw32 by default\n...\nchecking build system type... i686-pc-mingw32\nchecking host system type... i686-pc-mingw32\n...\nI also get the warning for the lpOverlapped\nif I try to only build nanocat make tools/nanocat I get the same link errors as you do\ndid you try a make clean check ?\n. I'm not sure how it's supposed to be use but there is make libnanomsg.la you end up with everything you need in the .libs folder\n. I'm not quite sure but I think it is not a really a bug, as you're trying to receive on a socket but didn't give it time to establish a connection. That is why most examples use inproc as it doesn't really take time to connect as tcp does. if u take a look at the tcp example they add a nn_sleep(200) to assure the connection did complete.\nLong story short, you're responsible for ensuring to not miss messages if u depend on it. Same as with pub/sub\n. it's not hanging because tcp isn't finished connecting, it is because you are trying to receive but the bus doesn't send you anything, as it immediately did send the first message and dropped [1] it as there was no one to receive it\nif there is no timeout on the receiving side it is exactly what it should do\nimagine the bus is already running and sending out messages regularly and another socket is connecting. the bus keeps sending out messages, while it is connecting, to all others that are connected. you won't receive messages until the connection is established.\ntry starting one sending bus\n./nanocat -i 1 --data bus_send --bus -L 12345\nand as many as u like receiving ones\n./nanocat --ascii --bus -l 12345\nand notice how the first receiving ones u start get more messages as the ones joining later on\nthe socket is sending regardless if there is one listening or not (like radio) if you're not there to listen you might miss messages and if you're waiting for a message but missed the show already you can wait until eternity if there is never another message sent\n[1] https://github.com/nanomsg/nanomsg/blob/master/src/protocols/utils/dist.c#L77\n. I'm getting build errors as well on Win7 but once I include limits.h it compiles :)\nIn file included from C:\\work\\nanomsg\\nanomsg\\src\\aio\\../utils/err.h:33:0,\n                 from C:\\work\\nanomsg\\nanomsg\\src\\aio\\usock_win.inc:26,\n                 from C:\\work\\nanomsg\\nanomsg\\src\\aio\\usock.c:26:\nC:\\work\\nanomsg\\nanomsg\\src\\aio\\usock_win.inc: In function 'nn_usock_setsockopt':\nC:\\work\\nanomsg\\nanomsg\\src\\aio\\usock_win.inc:193:25: error: 'INT_MAX' undeclared (first use in this function)\n     nn_assert (optlen < INT_MAX);\n. as for the Win 8.1 issue while I was fixing the build for mingw I had to specify a windows version as mingw seemed to not set that so [1]\nthat might cause you're problem\nif (MINGW)\n        add_definitions (-DNN_HAVE_MINGW -DNN_HAVE_STDINT -D_WIN32_WINNT=0x0600)\n    endif ()\n[1] https://github.com/nanomsg/nanomsg/blob/master/CMakeLists.txt#L39\n. removing the define would make it worse I assume you should set it to the correct version not sure which one that is for win8 though\nbut still, I followed the _TRUNCATE and it is defined in _mingw.h which seems to be included from\nstdlib.h\n|-crtdefs.h\n  |-_mingw.h\nI do not see any conditions that prevent it from being defined though, could you try and investigate why it does not get defined for you?\n. kind of the same goes for your initial error as well which is defined in winsock2.h there seems to be no condition to prevent i from being defined\nfor reference, I'm using mingw482_32 with qt\n. seems not to be the case, maybe I'm just missing something\nI'm trying to setup a vm to try compiling on 8.1 and will see how that goes\n@stepelu could you give me details of your compiler setup?\nlike cmake & mingw versions etc\n. I could build it without problems with my usual qt+mingw setup on a 8.1 vm I'll look into tdm later on and see if we can do something about it\n. just a quick run on tdm gcc yields the same errors you get and it in there version of winsock2.h ADDRESS_FAMILY is not defined\n. the ADDRESS_FAMILY is just one symptom there are lots of other symbols not defined. I opened a bug on the tdm project [1] to try and get some information why it's missing. I wild guess would be they don't support newer/older/certain versions of windows api which nanomsg is using. While fixing cmake for mingw the first time around I noticed nanomsg requires vista and up, for example\n@stepelu if that's an option for you, try a different mingw distro\n[1] https://sourceforge.net/p/tdm-gcc/bugs/236/\n. Only thing that pops up when not compiling for vista is a linking error for CancelIoEx [1][2] not sure how to work around that and if there is anything else that is not compatible\n[1] https://github.com/nanomsg/nanomsg/blob/master/src/aio/usock_win.inc#L1034\n[2] http://msdn.microsoft.com/en-us/library/windows/desktop/aa363792%28v=vs.85%29.aspx\n. John from the tdm project mentions [1] that the used features are not available in the w32api version tdm is based on. You might be able to use an more up-to-date version of the w32api package/module in combination with tdm.\nIt shouldn't be to hard to implement compatibility though.\n[1] https://sourceforge.net/p/tdm-gcc/bugs/236/#e168\n. The mingw version bundled with qt works [1]\nThe API provided seems to be defined in the bundled w32api package [2]\nI'm having a hard time though to determine the version included in the different mingw installations.\n[1] https://ci.appveyor.com/project/zerotacg/nanomsg\n[2] https://github.com/nanomsg/nanomsg/issues/330#issuecomment-64259132\n. Nanomsg doesn't do techniques to hammer through NAT it's \"just\" to create a topology.\nBut you can decide the connecting side so if A is able to connect to B you can have B do the bind and A do the connect.\n. PUBSUB is only unidirectional if you want to have a back channel you would need to add another socket. You could add another PUBSUB (client PUB, server SUB) and have the clients connect their PUB to the servers SUB.\nLots of cases you want to use TCP directly instead of scalability protocols.\n. TCP without nanomsg as it does not expose the tcp socket for usage.\n. ",
    "photex": "Late to the party here, but CMake makes it very easy to automatically include a library as an external project. It's also a build system supported by several IDEs directly.\nSo I just wanted to toss a +1 in here in favor of supporting CMake officially again. \nI don't exactly like using it, but it's had a net positive impact on my work. I understand the arguments for autotools in regards to the interests of package maintainers, but I've never worked someplace that didn't require managing specific versions of packages for our builds independently of a platforms available packages. For this CMake is very well suited.\n. Why can't nanomsg just use both? I'd wager there are enough willing volunteers to maintain them equally well. \n. Big sad face for closing this. CMake makes building and using nanomsg worlds easier.\n. ",
    "gddg": "I successfully build  nanomsg  .  mac osx 10.10.2\nfirst step : \nbrew install libtool \nbrew install autoconf\nbrew install automake\n\nsecond step : check build system \nglibtool --help\nWhen reporting a bug, please describe a test case to reproduce it and\ninclude the following information:\nhost-triplet:   x86_64-apple-darwin14.1.0\n   shell:          /bin/sh\n   compiler:       clang\n   compiler flags: -g -O2\n   linker:         /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld (gnu? no)\n   version:        glibtool (GNU libtool) 2.4.5\n   automake:       automake (GNU automake) 1.15\n   autoconf:       autoconf (GNU Autoconf) 2.69\n\nok follow the << Build it >> \n. install  xcode command\nbrew install libtool \nbrew install autoconf\nbrew install automake\nglibtool --help\nsh autogen.sh\n ./configure\nmake\nmake check\n. ",
    "atif1996": "I'd love to help keep the cmake build system up to date, if you guys decide to go that route.  I work on a product that targets Mac OS and Windows, and CMake was a god send for us.\n. ",
    "JackDunaway": "I've begun to work on this with intention to upstream. Can we re-open this case? (or shall I create a new one?)\nAlso; is it worthwhile to open issues for loose-ends found in the build process while working on this?\nFor instance: the declaration of NN_USE_EVENTFD versus NN_HAVE_EVENTFD compared with their later use in the source files.\nOne might consider that NN_USE_EVENTFD is the one driving the #ifdef in code -- but indeed it's NN_HAVE_EVENTFD, while NN_USE_EVENTFD remains unused after being set in the autotools configure.ac script.\nA related consideration is the order of precedence in which these different options are chosen. Should this be done by the configure file, or the source file?\nThe autotools script prefers eventfd over pipe over socketpair: https://github.com/nanomsg/nanomsg/blob/86bc0c89957ce5c08a83179f0645dbff7b64e97a/configure.ac#L359-L367\nThe code agrees: https://github.com/nanomsg/nanomsg/blob/10a567c89e564def7f5ae01f8c3bb1dab2acfed5/src/utils/efd.c#L28-L33\nWhereas when choosing socket mulplexing strategy in the configure file: https://github.com/nanomsg/nanomsg/blob/86bc0c89957ce5c08a83179f0645dbff7b64e97a/configure.ac#L296-L300\nThe order of precedence is different in source: https://github.com/nanomsg/nanomsg/blob/9a0cb281695759fde449244b5f664ece5075d9f5/src/aio/poller.c#L27-L33\nFor clarity -- these aren't bugs, just inconsistencies that probably arose over time.\n. Continued here: #574\n. > @mdre77 wrote: \"I got another one\"\nMore details on this in Issue #269 \n. > I have approximately zero intention to work on this. That doesn't mean I'd turn down a decent implementation if one arrived (and with updated RFCs too!), but adding new transports to libnanomsg is just too hard with the current state machine architecture\n@gdamore -- would it help you as a maintainer to set a soft cap on time with no activity for outstanding feature requests before closing out? I think that feels OK. We can re-open issues that get new activity.\n. Here's the error output from a failed ipc_shutdown test:\nOverlapped I/O operation is in progress.\n [997] (c:\\users\\jack\\repo\\ftw-nanomsg\\src\\aio\\usock_win.inc:407)\n<end of output>\n. Below is the stack trace from the tcp_shutdown Assertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED error.\nThe part I'm currently debugging is when on shutdown of nn_worker_routine() why the ctx structure passed to nn_ctx_leave() has a type value of 33988 which is what ultimately causes the test to fail on line 818 of sock.c.\nI'm new to this codebase, but that type value of 33988 feels very suspicious, and it's always the same value (not random garbage). I feel like if we can trace the source of this value, it could help solve this issue -- anyone with ideas, send me a message and i'm set up to pair program/debug.\n```\n    msvcr100d.dll!_NMSG_WRITE(int rterrnum)  Line 217   C\n    msvcr100d.dll!abort()  Line 61 + 0x7 bytes  C\n    nanomsg.dll!nn_err_abort()  Line 33 + 0x8 bytes C\n    nanomsg.dll!nn_sock_shutdown(nn_fsm * self, int src, int type, void * srcptr)  Line 818 + 0x6f bytes    C\n    nanomsg.dll!nn_fsm_feed(nn_fsm * self, int src, int type, void * srcptr)  Line 74 + 0x1a bytes  C\n    nanomsg.dll!nn_fsm_event_process(nn_fsm_event * self)  Line 66 + 0x17 bytes C\n\nnanomsg.dll!nn_ctx_leave(nn_ctx * self)  Line 63 + 0x9 bytes    C\n    nanomsg.dll!nn_worker_routine(void * arg)  Line 219 + 0xf bytes C\n    nanomsg.dll!nn_thread_main_routine(void * arg)  Line 30 + 0x10 bytes    C\n    msvcr100d.dll!_callthreadstartex()  Line 314 + 0xf bytes    C\n    msvcr100d.dll!_threadstartex(void * ptd)  Line 297  C\n    kernel32.dll!762d338a()   \n    [Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]\n    ntdll.dll!773e9f72()  \n    ntdll.dll!773e9f45()  \n```\n. > * that type value of 33988 feels very suspicious*\n\nLearning more, nope, not suspicious -- this value is defined as NN_PIPE_OUT in protocol.h\n. Attempting to repro this on Linux (link to commit, same as referenced above), to no avail, but the stress test turned up another failure mode on the automated build:\nAssertion failed: self->next == NN_QUEUE_NOTINQUEUE (src/utils/queue.c:78)\n. @vinoski Have you verified that the fix passes your test suite? (it seems to work for me on Win32) If you can independently verify, I'll be glad to create an official pull request.\n. I'll work on a PR; also, today, hopefully wrapping up a first-draft WebSocket transport implementation to share (re: http://www.freelists.org/post/nanomsg/WebSocket-Transport-design-considerations)\n. @vinoski If you're testing the entire fork, the only other substantive change on this fork are two areas in global.c linked below -- as a quick test, try reverting these two changes and running again?\nAlso, this repo started off as a poky investigation building a wrapper for LabVIEW's execution system, not as a formal project meant to contrib back to core. But it's getting to the point where it should be more structured! (The wrapper is currently in a private repo)\nhttps://github.com/wirebirdlabs/ftw-nanomsg/compare/nanomsg:master...master#diff-ffbd944673c7b576b42fbe3538ca9cd2R760\n. @vinoski Ah; that assertion should indeed remain; my bad.\nTry this, since you're on Linux, I'm testing on Windows right now; take a look at the change at:\nhttps://github.com/wirebirdlabs/ftw-nanomsg/blob/1785f99bcc1d5f69596e81477a4035753c0ec5d3/src/utils/efd.c#L74\n... and notice this change was not made on the non-Windows platforms here:\nhttps://github.com/wirebirdlabs/ftw-nanomsg/blob/1785f99bcc1d5f69596e81477a4035753c0ec5d3/src/utils/efd.c#L50\nOn Windows, select() returns ENOTSOCK if the socket is closed (this was the key for enabling better multithreaded support where the socket could be closed in a thread different from a blocking I/O operation). By treating ENOTSOCK as EINTR (efd.c#L74), this allows the send/recv loops to exit cleanly in sock.c (sock.c#L684 and sock.c#L595).\nHowever, it appears poll() on non-Windows platforms do not treat closed sockets as an error:\nhttp://stackoverflow.com/questions/17692447/does-poll-system-call-know-if-remote-socket-closed-or-disconnected\nJust bouncing around ideas -- not sure if this helps, but perhaps sparks some ideas?\n. > rather than websocket, why not SSE?\n@reqshark I may be missing some context here... it doesn't seem SSE fits the required semantics for all the nanomsg scalability protocols, where as ws:// does.\n. @TTimo - I've likewise been working on this issue, and may have found a fix (linked below) -- perhaps you can give a try? Thanks!\nhttps://github.com/wirebirdlabs/ftw-nanomsg/commit/bb5d37c70800aa620391c80a30b07dcc83501e26\n. @TTimo Great! I'll look into this. Right now, I'm neck-deep in fsm's and usock's getting full Autobahn Test Suite compliance on a new ws:// transport for nanomsg.\n. This PR might effectively be handled by https://github.com/nanomsg/nanomsg/commit/7555f49e83ff414133f77e46389f8e5632eeea1f -- @TTimo , what do you think?\n. Hearty +1 for putting energy toward this!\nWhile working on a new ws:// transport, I have experienced issues transmitting headers cleanly, and have some ideas for consideration.\nIt boils down to this -- both the Scalability Protocol (SP) and Transport Protocol (TP) might need to decorate the message send by the application (the \"message body\") with arbitrary, opaque headers. Additionally, when being brokered from node to node via devices, the backtrace of these headers would need to stack and peel off conveniently.\nCurrently, the nn_msg structure looks like this: https://github.com/nanomsg/nanomsg/blob/master/src/utils/msg.h#L30-L37\nYet since the SP and the TP contain orthogonal information, one proposal is to extend the nn_msg data structure look something like this:\n```\nstruct nn_msg {\n/*  Contains transport protocol message headers. */\nstruct nn_chunkref tp_hdr;\n\n/*  Contains scalability protocol message headers. */\nstruct nn_chunkref sp_hdr;\n\n/*  Contains application level message payload. */\nstruct nn_chunkref body;\n\n};\n```\nAnother option, and this one might be my vote, is to keep transport and scalability protocol headers packed into a single hdr, but then upgrade the CMSG API (https://github.com/nanomsg/nanomsg/blob/master/src/nn.h#L279-L298) to have more convenient methods to both produce and consume the headers/backtrace.\nEach of the TP's and SP's could even optionally define convenience wrappers/macros around the CMSG API in order to give the library user convenient methods for accessing transport-specific metadata (e.g., for WebSockets, the application developer is likely interested to know information like the opcode of the message as defined by https://tools.ietf.org/html/rfc6455#section-11.8)\nThese two options of extending the nn_msg structure and/or extending the CMSG API are not mutually exclusive; it could be a little mix of both.\nThis could solve the NN_PIPE_PARSED conundrum!\nThoughts?\n. This patch is submitted under the MIT license.\n@sustrik, if/when this patch makes mainline, the next is ws:// improvement at https://github.com/wirebirdlabs/nanomsg-websocket/commit/6437448bbeb7fac6b6b117e3f249bc533f779cd9 which needs minimal additional work merging due to file renaming; feel free to cherry pick this also if you get to it before a PR.\n. > One caveat is that SP_HDR property is copied into both nn_msg.sphdr and nn_msg.hdrs\nThis is true, and brings another point for discussion focusing on the structure nn_msg.\nIt changed recently (https://github.com/nanomsg/nanomsg/commit/a934fd86d0640a6db6c5829cdee3bfeeab6e3c6d), perhaps in part due to discussion on the topic (https://github.com/nanomsg/nanomsg/issues/324#issuecomment-60641688). In that discussion, I supported a strongly-typed structure with three strong-typed fields, but in the commit, we get two strongly-typed fields and a property bag (I'm referring to nn_msg.hdrs as a property bag, since it is the catch-all for arbitrary ancillary message data).\nYour commit is a step more in the right direction than my suggestion. Because, as there grows more types of headers (differentiated by nn_cmsghdr.cmsg_level and nn_cmsghdr.cmsg_type), likewise a strongly-typed structure would have to mutate. It is A Bad Thing if the most fundamental data structure nn_msg must mutate each time the library extends!\nWhat do you think of the following structure as a new proposal for nn_msg? (based on actual experience now having used the headers):\n```\nstruct nn_msg {\n/*  Contains all SP-level, transport-level, and additional message headers. Format of this\n    buffer is a list of cmsgs as defined by POSIX (see \"ancillary data\"). */\nstruct nn_chunkref hdrs;\n\n/*  Contains application level message payload. */\nstruct nn_chunkref body;\n\n};\n```\nThis connotes the need for some handy wrappers to access these headers, since SP's would no longer have direct access to the pre-parsed header. These wrappers would be simple to develop, and prevent laborious header searching in low-level code (example: https://github.com/wirebirdlabs/nanomsg-websocket/blob/6437448bbeb7fac6b6b117e3f249bc533f779cd9/src/transports/websocket/sws.c#L392-L408)\nSuch header accessor function might look like:\n/*  Returns pointer to header data or NULL if not found. */\nvoid *nn_find_hdr (struct nn_chunkref hdrs, int level, int type, size_t *len);\nThere might exist a performance hit, but instinct says this is negligible.\nThoughts?\n. > separate field for both convenience and performance reasons\nTrue, and the tradeoff is extensibility for other ancillary data. Which is more desirable? Convenience of access to only the SP header? Or extensibility for future layers in the stack? Or the third alternative -- adding one or more layers of convenience (e.g., nn_msg.sp_hdr and nn_msg.transport_hdr and so forth), and also keeping the property-bag nn_msg.hdrs catch-all?\n. Another point for consideration: thought POSIX defines headers as being contiguous in memory, once entering our nanomsg nn_msg layer, this must not necessarily hold (which can solve the issue of shifting/copying memory). This especially makes sense as layers add/consume headers to/from the collection.\n. This PR can be closed (it was merged to master with https://github.com/nanomsg/nanomsg/commit/685f91bb94a5323a3005fc1b7e6dc090f9405773)\n. @djc thank you!\n. I don't suggest merging this PR, but can we discuss strategy moving forward in order to close out this old PR?\nAutobahn TestSuite was chosen as the industry-standard WebSocket implementation tester when I had envisioned the scope of the WebSocket transport in nanomsg to be wider than it is, but after discussions with @sustrik and @gdamore, I now agree that the WebSocket transport for nanomsg only needs to reasonably implement a subset of RFC 6455 (not nearly as complete a set as originally designed). For the most part, it should not be much more \"special\" than, say, TCP.\nThough, even after scaling back, the WebSocket transport remains \"special\" for a couple reasons:\n1) A few transport-specific features -- such as PING/PONG and chunked transfers -- are effectively handled by the transport layer in libnanomsg, but not exposed to the end-user of libnanomsg. Why do we even support these, if not exposed to the library user? Because it's unclear if browsers/user agents have the prerogative to use these features, even if not explicitly requested by client-side app code running in the browser (nominally talking about just Javascript here). By implementing these features, we can be reasonably sure that the library does not crap-out on what are reasonably modest expectations laid out by RFC-6455.\n2) The one feature that is exposed, which makes the WebSocket transport special from other transport types (TCP, inproc, ipc, etc...) is that a new socket-level option that is transport-specific enables the transport to verify that the payload of the message is valid UTF-8 -- it's been contested whether we should keep this, but I would strongly urge we do for now, since that's the encoding of the web.\nAll said -- this is just a brief history of why the Autobahn TestSuite was originally used as a departure from the established strategy of just tests written in C -- since the WebSocket transport for nanomsg was sufficiently different from other transports. The cost of this was introducing a new big dependency -- Python, in addition to Autobahn TestSuite, in addition to the other things it required. Yuck.\nThough, one new thing that nanomsg has gained since this was first developed is CI servers Travis and Appveyor, which to my understanding are easier to set up, automate, and maintain based on files in the repo.\nAll leading to a single question -- do we keep Autobahn TestSuite?\nIf yes -- we would configure Autobahn to turn off all the tests that are irrelevant (e.g., per-message compression). Additionally, probably only configure this test to run within \"official\" CI repositories, but be off by default for anyone cloning the repo and building locally (since it is non-trivial to set up, and pretty much annihilates the the spirit of minimal dependencies)\nIf no -- well, I don't have any reasons to suggest we ditch it, other than, \"it will take effort\" :-)\nAll said -- I'd like to get feedback on whether we want to keep it, then appropriately close or modify this PR so we can get it off the backlog.\n. > I didn't understand where the JSON config files were?\nCreated dynamically as part of the test (link to code): https://github.com/wirebirdlabs/featherweight-nanomsg/blob/65b8630c11fd620d50e8e0a4f2e6db9523a633fc/tests/ws_stress.c#L60-L76\n. > So your test code looks mostly good, although it uses the removed APIs.\nGood point. Now, re-glancing at the code myself for a first time in a while, it would need to change a non-trivial amount.\nFor instance, previously, ws:// sockets could parse TEXT or BINARY message types per-message, yet we have now decided (for the better, I think we all agree) that one of two protocols is set per-socket.\nAdditionally, I'm not certain where the current implementation stands on PING/PONG delivery to the application level (i.e., does libnanomsg expose these any longer? or did we encapsulate them?). But looking at the test, it clearly expects them (in addition to NN_WS_MSG_TYPE_GONE, which I know no longer exists: https://github.com/wirebirdlabs/featherweight-nanomsg/blob/65b8630c11fd620d50e8e0a4f2e6db9523a633fc/tests/ws_stress.c#L202-L207)\n. @gdamore I'm poking around with this again, bringing it up to speed with recent changes in WebSocket. Especially, in the context of ensuring shutdown behavior is clean.\nI have a hunch this test could be easy to integrate into the automated build on Travis and AppVeyor. I can do the work to make that happen.\n. This PR is superseded by https://github.com/nanomsg/nanomsg/pull/563 and will be closed once #563 is acknowledged.\n. Superseded by #565. Closing.\n. This patch has resolved issues I've also encountered, and I support its merge to trunk.\n. I like this!\n. > Err ...\nD'oh! My intention was to alert @tailhook instead of @djc since this had to do with statistics. Sorry for the false alarm @djc!\n. > It seems that delaying fsm start is ok, as long as it's ok to create sockets/endpoints before start. Which seems quite counter-intuitive (even if it's perfectly works now)\ncaveat emptor: I'm commenting on a 4mo-old pull-request with 4mo-old knowledge, not having re-wrapped my brain around all the decisions behind the original change.\nI see the argument of being counterintuitive, but in another way it remains in the spirit of how libnanomsg reserves and then later activates sockets and connections -- asynchronously.\nThat said -- I have not fully studied the effect of enqueueing messages to the libnanomsg FSM prior to it starting -- e.g., is it always OK to preload its incoming message queue prior to its handler becoming active? In a formal sense, there should be no prob with this design, and it's appeared (anecdotally) to hold true in the libnanomsg FSM implementation.\nAll things considered, I'm 100% cool with a better or more elegant solution, but in the meantime would suggest merging this patch since fixes a characterized race that manifested in production without \"appearing\" to cause other bad things to happen, as long as others can confirm bad things don't \"appear\" for them either (or ideally, could even contribute some formal tests)!! :smiley:\n. > I'm going to have to stare at this a bit.  I'm a little uncomfortable with approach but the arguments here are sound.  I would love to have more anecdotal evidence\nlegit, and agree\n. This has been working well in production for a while; merge?\n. > I need to catch up on PRs.  Will do so this week.\nSounds good.\n. @sustrik What are your thoughts on this change?\n. > Problem may be insufficient tolerance\nSometimes, but not all the time.\n\nLooking at this, we are firing up to, but not more than, 10 msec early. This looks like a possible bug in the Windows timing subsystem. We are using select() here, so can WSA select fire early?\n\nThis is indeed one distinct failure mode ...\nbut https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.113/job/7stq1bsk17bwb9h1 shows another distinct failure mode. In this test result, it appears the test got hung, then aborted by the test framework at the 30sec testing limit.\nIt's possible that this second failure (the 30sec timeout) is due to some upstream failure, say tcp_shutdown test.\n. > select() compatible semantic is IMO libnanomsg's single biggest weakness\nShall we open a new issue on this? That would be a better place to discuss. Briefly, I don't use select() on multiple nanomsg sockets, because the value proposition of a \"nanomsg socket\" already seamlessly and beautifully multiplexes N underlying sockets (endpoints). Using select() on top of M nanomsg sockets thus provides MxN sockets, which actually adds more rigidity at the application layer (e.g., I choose not to use it because I see more negative value than potential positive value).\nIf you think this feature is truly what's blocking other more real issues (e.g., tcp_shutdown), then I would be in strong favor of re-evaluating select() prior to v1.0.0. It would be helpful to have @sustrik chime in on how strongly original design goals still stand, and cross those with lessons learned since v0.1\n. @nickva -- I've likewise seen this error in the past compiling on MSVC, but as @gdamore reports, I have not seen it in quite some time since many other improvements have been made to the library.\nThis failure mode always seemed (anecdotally) to be a cascaded failure from something not working correctly upstream; most likely mutexing of a globally-shared resource.\nUnless you report otherwise, I'd likewise be inclined to close this issue as \"fixed\".\n. Cool; thanks!\n. Seems related to #269 \nMy current workaround is to ignore messages of type NN_PIPE_IN and NN_PIPE_OUT while a socket is in its final stages of shutting down -- something like this: https://github.com/wirebirdlabs/featherweight-nanomsg/blob/8516fc4285ffb3dfcf5d9e9319f1490b29d800ca/src/core/sock.c#L870-L879\n. > ignore messages of type NN_PIPE_IN and NN_PIPE_OUT\nRelated, @TTimo does similarly: https://github.com/TTimo/nanomsg/commit/518d3ebd02e0ce1a7cc77f8611afeb6c23f8bfe6#commitcomment-9266560\n. > \"Actually, binding to a random port is better, because its atomic.\"\nThis would be the only acceptable implementation. Except...\nThe reason nanomsg does not support this is by design. Just a few sources for rationale:\n- https://github.com/nanomsg/nanomsg/issues/217#issuecomment-38249958\n- https://www.freelists.org/post/nanomsg/Bind-random-port,2\n- https://github.com/nanomsg/nanomsg/issues/67#issuecomment-18535567\nI used to agree more with the desire to bind to ephemeral ports, but after 1yr or so of usage, appreciate the mentality of moving away from this. Utilizing the full URI of the resource (with WebSocket or TCPmux) is a game-changer.\nI would tend to recommend application architecture that follows the spirit of Martin's original intent, and I would tend to recommend closing this case as a \"Won't Implement\". Not 100% yet, but it's sure compelling, and has so far made our applications better!\n. @gdamore, can you provide a test case for this? Additionally, a straightforward fix? If no, perhaps this case should be closed as \"nice to have\", perhaps re-opened later based on public interest.\nPersonally, I'm willing to swallow this failure mode as an easily-detectable and debuggable application-layer failure that the library just does not yet protect against.\n. > \"not going to bother doing this for the websocket transport since I think that transport is so brand-spanking new that I don't think there are conflicting cases in deployment yet\"\nAgree.\n. Hi @stepelu -- looks like the luajit-nanomsg binding has not been updated in a while: https://github.com/nanomsg/luajit-nanomsg\nWould you consider creating an issue there to upgrade to the latest ABI of libnanomsg? Having experienced many errors during the shutdown of nanomsg socket myself, which are now all resolved in the latest libnanomsg HEAD, I'd recommend to @gdamore (libnanomsg maintainer) that this issue be resolved without further notice from @stepelu \n. Excellent; thank you!\n. Do you have ideas how to incorporate a fix into core? I have spent hours troubleshooting this issue, but without a good fix yet.\nThis is the most widespread outstanding bug in libnanomsg; many issues could be closed if this is resolved: #373, #368, #281, #269, #234, #75 -- that's just a handful of what I believe are all the same bug!\n. @reqshark, I'm still confused how HTTP/2 really maps to the spirit of nanomsg, but it remains clear and desirable to use WebSocket as a transport option for nanomsg. HTTP/2 is exciting and useful for other reasons, but doesn't feel so relevant to nanomsg.\nI agree with @gdamore's sentiments toward the ws:// implementation in nanomsg core, as I'm familiar with the implementation. During the time of its initial development, we had some brief discussions as to what/why nanomsg+websocket, just enough eek out a shippable prototype. I expected that contribution to spur additional development and thoughts from other contributors, but it came during a transition period in the nanomsg project and hasn't really continued to further develop.\nThe two biggest areas that I wish would improve with the existing ws:// transport are 1) ability to multiplex sockets based on URI resource (effectively, which could replace TCPmux), and 2) TLS for wss://\nmangos has some really cool features, and I would use it, but it's strictly limited to applications developed in Go. Ideally, its abilities could be ported to a C or Rust implementation, whose calling conventions are interoperable across most platforms and through most language's FFIs.\n. This was explicitly considered and rejected during the ws:// transport design -- see https://github.com/nanomsg/nanomsg/commit/9d01de46251ad696f84414395832a28f5914056c (there is probably additional chatter and design decisions from this era on the list and/or GitHub comments/history)\nInitially, I wanted libnanomsg to have the ability to communicate with an arbitrary, nanomsg-agnostic WebSocket peer (and for completeness, I guess this would also require a similar ability of the PAIR TCP socket to interoperate with an arbitrary TCP connection, and IPC, and...), but after hearing the reasoning from @sustrik and @gdamore et al. I now would agree it's best to not have this ability in core.\nIt's not a bad idea, just not in the spirit of core, and for this reason I'd recommend closing this case as won't implement. It might make a good auxiliary or extension library, but it's just not best suited for core.\n. :-)\n. > However, I've found in practice to prevent DoS abuses/crashes, that it makes sense to apply a firm limit in mangos, which can be altered, but defaults to rejecting messages larger than a certain size (say 1MB). I don't think libnanomsg applies any such limits (which arguably is a problem.)\nAgree with this. This, amoung a few other misbehaviors of remote endpoints, is a prime reason I would like to see a \"close handshake\" added to the nanomsg protocol to officially notify offending sockets the connection will be terminated. (here is one such conversation when developing WebSocket transport, since RFCC6455 defines a Close Handshake that could not cleanly map to nanomsg's lack of a close handshake: https://www.freelists.org/post/nanomsg/ws-transport,1)\nThe message size limit is a good idea for the reasons @gdamore outline; the Close Handshake is a good idea so that the remote endpoint does not observe radio silence when a too-large message is silently dropped by peer.\nIntroducing this new message type would break wire-level protocol with <=0.4 -- but breaking wire-level protocol is not nanomsg's key enemy right now!\n. > Certainly, we do need a way to inform the core that an endpoint is gone/closed (and indeed mangos has this as well, including notification back to the application which is actually something useful that libnanomsg lacks), but what would the purpose to a wire-level change be, vs. an internal API change?\nMy thought is the wire-level change would be just the addition of a new message type... but if you think this this could be handled without a new message type, and it seems proof of concept already exists in mangos, even better! (link to relevant mangos snippet: https://github.com/gdamore/mangos/blob/7e99876ea985abb5a94d52daefa0b5717b5cb66a/conn.go#L58-L61)\n. > QNX has free 30-day free evaluation program\nIs this particular issue #433 the one to begin the 30-day trial for the investing-developer-entity solving this issue? Or do you prefer to start this expiring timer on the next, more important issue?\nI can not and will not discredit the economics behind your own concern, because I myself understand and empathize with the barriers within we must sometimes work within using proprietary platforms. but I might suggest that the burden of the economics behind whether nanomsg run on QNX is more a QNX concern than a nanomsg concern, and for this reason, this case be closed.\nThere does exist an issue here, no doubt, and it affects you, no argument; but this open ticket might better be on the QNX issue tracking queue, where there exists (ostensibly) allocated monetary resources and guarantees to solve such problems for subscribers and customers such as yourself.\nThough, if there does not exist such budget.... then this case is still closed, and we collectively re-evaluate our decisions to rely upon proprietary \"solutions\" on \"platforms\" where money buys \"guarantees\".\n(In the off-chance that this proprietary QNX has uncovered an odd bug that could eventually affect more mainstream and open platforms, then there exists value here to keep this issue open; though, that's not obviously, or even suspiciously, the case, based on lack of other related issue reports)\n. > I don't think I can agree with your point where the issue is more a QNX concern than a nanomsg concern. With the same logic, would you think it would be a MS/Windows concern if the same issue occurred on Windows, which is a commercial, mainstream, and proprietary platform?\nIf it appears to be a problem, or even just weirdness, with the vendor's code, then it's good for the vendor to be aware and try to resolve the issue there. Now, if the vendor does not appear to be at fault, yet it's exposing some flaw in the library -- it's good for the library maintainers to have responsibility. Based on previous conversation, it felt this case fell into the former group.\nThat said, I appreciate the rest of your response. it's thoughtful and kind, and would agree to keep this case open for now, especially in the spirit of making nanomsg more robust. :-)\n. I agree. The desire to use nn_sleep() at the application layer probably has a better solution elsewhere anyway.\nOne example of a potential use for nn_sleep() at the app layer is demonstrated in a few of the tests (e.g., https://github.com/nanomsg/nanomsg/blob/master/tests/tcp.c#L126-L127) to allow \"enough time\" to elapse for nn_connect() to connect ....\n... however, this would better be suited by a new function such as nn_connect_synchronous(), which would block until it first successfully established a connection. Its interface would be identical to nn_connect(), except with an additional timeout parameter.\nUsers of this function would need to understand that when this function returns on success, downstream usage of the socket would not necessarily be \"still connected\" (e.g., same async semantics as currently would still apply).\nLikewise, depending on how nn_connect_synchronous() is designed, returning ETIMEDOUT might properly establish connection the moment after returning is async connection is to continue, or this function could be designed such that it would cease trying to connect/reconnect on initial failure (I probably support the second behavior).\ntl;dr I support not exporting nn_sleep(), but instead perhaps considering API improvements where its use at the app layer might have been desirable\n. Excellent analysis; thank you, @zakharov!\nYour fixes seem rational solutions to an acute problem.\nBack when the Close Handshake was first being discussed, I was a proponent of formalizing a Close Handshake for nanomsg generally (i.e., for all transports, not just WebSocket).\nIf I recall correctly, the reason I decided to propagate the close handshake from the peer up to the application layer is because we were defining the close handshake as an app-layer concern, not transport or socket layer concern -- yet this clearly a problem when a PUB recv's a msg!\nMy understanding is the original nanomsg spirit set forth by @sustrik was to address the need for persistent, long-term and connections (the same spirit is why binding to an ephemeral port, although technically not so much a challenging feature to add, was specifically avoided, for good reasoning when applied to persistent service endpoints). For this reason, a Close Handshake perhaps didn't make sense to pursue. Yet I've found significant value in nanomsg connecting \"short-lived, ad hoc\" endpoints (e.g., actor-oriented development for embedded control and monitoring systems), where a Close Handshake would be helpful, and perhaps others are finding enough use here to gain traction.\nPerhaps @gdamore can help further define this closing handshake protocol, perhaps in terms of how mangos accomplishes this?\n. > What I couldn't figure out is a generic mechanism to inform an application layer that there is new connection/disconnection happened\nOut of curiosity, what logic would this be triggering at the app layer? Would it be acceptable to make hello and goodbye part of your app-layer protocol?\nFor the topologies you mention (PUB/SUB and REQ/REP), it might be best to consider the app-layer unaware of the connect/disconnect events themselves, since nanomsg intentionally tries to abstract this.\n. > AppVeyor build, but it looks like it's not public yet\nAha, simply submitting PR kicked off the build here: https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.33\nIs the current link a sandbox before moving to a nanomsg domain, or do you prefer to keep that link for now?\n. > ties to a personal GitHub account rather than to a repo or to an org\nIndeed. Looks like one way to workaround this would be to register the name \"nanomsg\" as a new AppVeyor account (as per their official support: http://help.appveyor.com/discussions/questions/1154-appveyor-account-for-github-organizations), then add collaborators and/or team access.\n\nothers can start if they want to\n\nSince it's already configured to run on a PR, that's suitable without opening permissions any further. Probably best we not muck up each other's (or the official) build history with sandbox dev; it's easy enough to set up your own if you're serious.\n. > Just to expand on my last reply.  I think event loops lead you down to state machine hell.  I implemented mangos using simpler imperative style programming and I'm happy with the end result.  So I'm more likely to try to copy that design.\nAnother view: incidentally, libuv architecture is event-driven callbacks, but fundamentally, it's an abstraction of Hard Problems dealing with async, cross-platform I/O.\nGo provides the abstraction of this problem for mangos, and does it well. Though, to be fair... Go is currently not yet ready (as of pre-release 1.5, Q3 2015) for building native binaries with C calling convention. In other words, not yet able to speak lingua franca interoperable with , it's unfortunately not as accessible as C.\nI'm totally with you that Go channels provide a more elegant async solution while feeling imperative, but inverting dataflow to a callback might be a concession worth considering. In regards to \"state machine hell\", libuv manages/abstracts much of the state currently managed by libnanomsg, so the number of layers would be significantly reduced, making this concession not hurt too much. If anything, it would even be exciting to have this inversion at the library layer, such that language bindings could inject their own callbacks to provide idiomatic channels native to their language!\n. I can do some testing early this week, but if it works for @zakharov, it\nalso looks good. My only consideration that i will try to investigate is to\nensure no resources are leaked, and that a connection is entirely cleaned\nup under this condition.\n-JRD\nSent from a mobile device\nOn Jul 26, 2015, at 4:30 PM, gdamore notifications@github.com wrote:\n@wirebirdlabs https://github.com/wirebirdlabs you have reviewed this as\nwell, right?\n@zakharov https://github.com/zakharov can you rebase this down to a\nsingle commit please? (Please address the one whitespace nit I found while\nat it.) Also, the preferred way is to have a bug report and reference it as\na single line commit message of the form \"fixes # \"\nThanks.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/447#issuecomment-125042084.\n. It may be unrelated to this pull request, but this commit triggered the tcp_shutdown test to fail on all three Windows builds: https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.40\nHere is a search link that shows all Issues that mention the keyword tcp_shutdown: https://github.com/nanomsg/nanomsg/search?q=tcp_shutdown&type=Issues\n. @qbradley can you run tcp_shutdown directly and paste the failure mode (probably a stack dump)?\n. > an existing intermittent failure\nSolid analysis. See link above for issues mentioning tcp_shutdown.\n. > A pipe out or in event during shutdown is not a reason for concern, I think. We won't read or write to the pipe anyway, so we can and should ignore them.\nSeems that way... but still not quite. Ignore this assertion, and the crash moves to a more critical place -- accessing freed memory after the socket has been destroyed.\nThe underlying cause is within nn_sock_recv() and nn_sock_send() since these calls release the mutex on the socket, allowing a contentious nn_close() from a separate thread to gain the mutex and destroy the socket. By the time send/recv tries to regain the mutex, it dereferences a freed ptr :-(\nAfter spending time trying to patch this issue with a few different fixes, we're relegated to the only solid workaround -- ensure nn_close() is never called during a blocking send or recv based on usage at the framework/application layer, either through 1) guaranteeing any one socket access remains single-threaded, or 2) introducing additional mutexing at the higher layer.\nThat said, this advice is based on memory from months ago, and I'd be glad to help brainstorm new solutions.\n. Cross-linking to a related reply posted within 1 minute of this issue: https://github.com/nanomsg/nanomsg/pull/449#issuecomment-130959584\n@qbradley, it seems you are narrowing in on some of the same multi-threading locking issues I tried to chase down a while back. I'd be interested to see this issue resolved, since its resolution would resolve a sizable fraction of currently-open issues.\n. > does this problem only occur on Windows?\nIn my testing, this is definitely where it's most prevalent.\nAt one point, in a debug-and-dev session I thought I had narrowed it down to a difference in the two platforms in efd.c\nHere's the link:\nhttps://github.com/wirebirdlabs/featherweight-nanomsg/commit/679165e0a559e63c1724d5068b1e403b5eddb66f\nI don't even recall if this helped at all (and/or pushed the failure point to another location), but at worst I don't think it was headed in the wrong direction.\nAdditionally, here's a link to the total set of changes I've done toward TCP Shutdown issues -- again, these changes have not necessarily helped much (else, they'd have been PR'd), but it's at least one data point trying to help characterize where we can put effort into solving this issue: https://github.com/nanomsg/nanomsg/compare/master...wirebirdlabs:master\n. Can we get this one merged?\n. This feature is most excellent; I will certainly use it.\n. > I think this is sort of justifiable because the amount of memory that can be allocated is presumably limited by the local bitwidth, but really i'm just too lazy to create a new socket option type\nNo chance this is an issue of being too lazy. I'll posit, rather, than anyone who gripes about this limit is the one too lazy, and is making some gravely suboptimal decisions about the size of messages being sent.\nIn the future, your implementation could be upgraded if pedantic consistency with uint64_t is deemed worth it, but for now, int is an entirely reasonable choice.\n. > switched to 1MB (1024kB) as the new default max. I think this is a good balance, given that the socket will just mysteriously close for the sender end.\nThis is the reason I've desired to add a Close Handshake to the nanomsg protocol. (you can search the term \"Close Handshake\" in this repo's issues and also on the mailing list archive to see more thoughts) This is a formalized message in RFC 6455 for WebSocket, and I feel something similar would help applications using nanomsg sockets to react more sanely to the condition where a peer declares it is gone (in this case, for breaking protocol)\n. > Pushed\n:-)\n. > For whatever reason, it is yet to be merged\nPerhaps since the PR contains both a bugfix and a new feature? Both seem solid, quality work, but since coupled together makes it a bit harder for maintainers to evaluate/merge individually.\n. tl;dr -- refactor away the original issue raised by @djc here in favor of per-socket rather than per-message set/get of RFC 6455 message type.\nFurther thoughts:\nI consider this an as-yet unresolved issue brought up during the review of the WebSocket transport feature addition -- whether to expose WebSocket-specific message types defined in RFC6455 over the exported interface of libnanomsg, either thru the cmsg functions and/or thru websocket specific convenience wrappers.\nRelevant code: https://github.com/nanomsg/nanomsg/blob/master/src/ws.h#L42-L60\nThe main issue, if I recall, is the classification of such message type as being either \"transport level\" or \"application level\" concern. A compelling argument was given that WebSocket attempted to wrap L6 concerns into its L4 protocol, and so the \"bug\"  lies within the design of RFC 6455. Any way this is argued -- it's still just an unresolved issue for libnanomsg.\nI have a feeling that the reason this never came to a resolution is that it was hard to continue to scale the mindset of \"all protocols across all transports, all obeying Liskov Substitution Principle\" -- since there's definite value proposition in keeping WebSocket UTF-8 in order for libnanomsg to more easily communicate with browser clients.\nThat said -- I would probably favor refactoring the above-referenced lines to remove them, instead giving WebSocket a single transport level socket option that may be settable after constructing the socket -- Binary mode or UTF-8 mode. In practice, it's entirely reasonable to assume that any WebSocket endpoint would define an app-level messaging protocol that's strictly UTF-8 only or binary-only -- mixing/matching here feels like a terrible protocol design, and for this reason it would probably be OK to remove per-message control of message type.\n. > I found that nn_sock_shutdown solved the problem on the old version as the below ... but the current version why not?\nAs the author of that code and comment, I later found this \"patch\" pushed the failure mode to other places which turned out to be harder to diagnose and perhaps fix. In other words, that change didn't help, and maybe even made things worse.\nI didn't think this code/comment were mainlined, but if they were, it's good they're reverted.\n. Can you show a test case? I think the behavior you're seeing here may actually be describable and expected.\n. My suspicion is that this case can be closed as \"not a bug\".\n@anshumang -- my hunch is that you invoked nn_send() immediately after nn_bind(), and measured the amount of time it took to enter and return from nn_send() as 25msec.\nnanomsg behaves a bit differently than you might expect during both nn_bind() and nn_connect() -- both functions are effectively asynchronous.\nMeaning, by the time nn_bind() has returned with no error, binding has not yet actually occured.\nMeaning, the first nn_send() (or nn_recv()), if invoked immediately after either nn_bind() (or nn_connect()), is likely to incur the entire time penalty of the actual binding/connection process.\nThe first nn_send() might take 25msec, but the next one (after bind is successfully established) will be microseconds.\nHope this helps!\n. What you say is not incorrect ... but the \"no-block guarantee\" of NN_DONTWAITmight be better communicated as \"won't try twice\" versus the not-as-correct-assumption \"requires a vanishingly small amount of quasi-deterministic time\".\n. Thank you for putting effort into this -- after the original contribution, we began a brief design review, which quickly fell to the back-burner as the library sat for a while. I am 100% open to criticism and improvement here :-)\n\nusing a non-standard opcode of 0x7F\n\nThis concept idea probably ought to be blown away. We've talked here and there about this \"close handshake\" business, and I can concede that you're right that nanomsg should not implement it.\n. > Well, going back and reading section 7.1.7 again, it does seem like we are supposed to make a reasonable effort at sending the CLOSE frame. But the other frame is complete crap, and the zero length recv frame is even worse.\nThis sounds right; more correct than the original post; based on memory.\n. > The 0x7F is never transmitted over the wire. It only went to the user as the cmsg data. Attached to that zero length frame!\nOK, this is actually jiving better with my memory, but wasn't going to argue. I hope to have time soon to review your changes. :-)\n. > hangs\nIndeed -- I'm guessing it's the new test with tcp_shutdown -- are you able to see any obvious problems with that test? I don't have an environment readily available to test, but could fire up something on OS X later to troubleshoot ...\n. Here's a shot in the dark (not tested) -- is it due to https://github.com/wirebirdlabs/featherweight-nanomsg/blob/5ed04c5464ca5b3c808b8ba5589070f29a4c799b/tests/tcp_shutdown.c#L107-L109 ??\n. I tried a quick build on OS X and could reproduce the hang; commenting out referenced lines above (suppression of SIGPIPE) did not help.\nShould we open an issue and discuss further there, or continue here?\nBriefly, I feel that this is a test that should pass, and even though the proposed fix in the PR seems to work on Windows, I'm not sure yet exactly the fix for *NIX platforms.\n. I will refactor the test into a new test.\nThat said, the goal of one PR was to demonstrate 1) the problem in a test, then 2) the fix. If you prefer two separate PRs, that's cool, but just wanted to share rationale why it was originally submitted as an atomic PR.\n. Closing; this PR is supplanted by #520 based on discussion in this thread\n. > now it seems to be getting caught up on a WS timeout\nYeah, I've noticed this too. I'm seeing a similar failure mode in some code I'm working on, and have casually been checking into it this week.\nFor clarity, I'm confident that your PR here is not causing the failure, so this AppVeyor failure, @gdamore, should not gate merging this PR.\n. Shall we continue the ws.c test hang conversation over here? https://github.com/nanomsg/nanomsg/issues/505\n. > slow-joiner syndrome inherit in PUBSUB topology\nIt seems you're describing pretty well the expected behavior, which is also the observed behavior.\nJust to clarify this issue -- the problem here is not missed messages -- those are expected. The problem is the hang caused sometimes.\nSaid another way -- it should be expected that the following psuedocode would fail:\n//assume REMOTE_ADDRESS is bound and publishing\nnn_socket (NN_SUB);\nnn_connect (REMOTE_ADDRESS);\nnn_recv ();\nnn_close ();\nBut it is a bug when the library hangs indefinitely on nn_close()\n. Here are a couple links to associated failed build reports from AppVeyor:\nhttps://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.113/job/4nkqbgclrugo8t0w\nhttps://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.117/job/6cmxkj28g405aopl\nIt's reproducible by continually running the ws test until failure -- it may take half a dozen tries or so to hang here https://github.com/nanomsg/nanomsg/blob/master/tests/ws.c#L194 with the following stack:\nnanomsg.dll!nn_sem_wait(nn_sem * self) Line 122\nnanomsg.dll!nn_sock_term(nn_sock * self) Line 203\nnanomsg.dll!nn_close(int s) Line 601\nws.exe!test_close_impl(char * file, int line, int sock) Line 119\nws.exe!main(...) Line 194\nThis is on Windows.\n. So, I've figured out why this happens, and have a temporary workaround.\nI'm still understanding the root cause of why, and after that, will investigate a reasonable fix. @gdamore -- would appreciate your help here! Windows is not your self-proclaimed fave, but perhaps you have some ideas.\nThe hang happens here: https://github.com/nanomsg/nanomsg/blob/master/src/transports/ws/cws.c#L418-L419\nwith this call stack:\nntdll.dll!NtWaitForSingleObject() + 12 bytes\n[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll] \nntdll.dll!RtlInterlockedPushEntrySList() + 1191 bytes\nntdll.dll!RtlInterlockedPushEntrySList() + 811 bytes\nntdll.dll!RtlInterlockedPushEntrySList() + 853 bytes\nftw32.dll!nn_cws_handler(nn_fsm * self, int src, int type, void * srcptr) Line 419\nftw32.dll!nn_fsm_feed(nn_fsm * self, int src, int type, void * srcptr) Line 72\nftw32.dll!nn_fsm_event_process(nn_fsm_event * self) Line 66\nftw32.dll!nn_ctx_leave(nn_ctx * self) Line 63\nftw32.dll!nn_worker_routine(void * arg) Line 204\nftw32.dll!nn_thread_main_routine(void * arg) Line 30\nReplacing those two lines from cws.c with a hard-coded msg_type = NN_WS_MSG_TYPE_BINARY; seems to \"fix\" the issue.\nI'm not yet sure if that workaround actually solved a deadlock, or simply changed the timing of what otherwise remains a race condition.\nThe big question here: why does it hang on nn_epbase_getopt (&cws->epbase, NN_WS, NN_WS_MSG_TYPE, &msg_type, &sz); ??\n. It feels the simple solution is to move that option check to nn_cws_create() and cache it into a new field added to the struct nn_cws type; would still like to figure out why this is necessary ...\n. > What happens is that the epbase option lookup has to reenter the context of the state machine\nI'm not sure if you're in front of the code, but a call to nn_epbase_getopt() does not require gaining further mutex access -- you're probably thinking about getting options from a higher layer. From the layer this is currently getting hung, it's already within the context.\nIt's not getting hung on a library-level mutex here -- it's lower level than this.\n. > I have some specific ideas as to this, and I think I\u2019ll be able to fix it.\nGive me 20min longer to do some stress testing, and I'll create a PR to evaluate. The fix of moving this option check to nn_cws_create() seems to be working well so far.\n. So, AppVeyor has failed on the timeo test, and it appears that Travis (still running) is going to fail on the ws test.\nThis PR may have helped on Windows, but appears to have hurt on Linux.\n\nI have some specific ideas as to this, and I think I\u2019ll be able to fix it.\n\n@gdamore turning it over to you for now for a while\n. > See PR #516\nWill evaluate this ASAP and report back.\n. > Please let me know if for any reason it doesn\u2019t fix it for you\nIt passes both the built-in tests and our separate tests; this one is put to bed for now. thank you for your work, @gdamore!\n. Drats... failed today on AppVeyor CI with NMake: https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.137/job/t481gh3ti03m3fu1\nThough, the two builds on MSVC did pass this round, which is the environment where I do most testing: https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.137\n. > Backing out is probably not the right choice here -- it may be something we do, but ultimately we still need to fix the original bug\nAgree.\nIt's possible (likely?) a nuanced bug has arisen based on how https://github.com/nanomsg/nanomsg/commit/a896c3051f1b8a0da4fd92819cca9f102dd610e2 sorts unicast vs multicast addresses.\nMeaning, even though that step may have introduced what feels like a regression, it's definitely headed in the right direction, and should not be reverted.\n. > fails due to a block on the global lock\nInteresting. I wonder if you won't come back with a resolution along the lines of dynamically allocating each socket and using a pointer/handle to such allocations as the socket identifier rather than [0, 1023] on a global array ;-)\nRegardless the resolution, would you consider accepting this PR as-is, then building upon it, since this PR represents another type of correctness? (specifically, caching the socket type once on connect)\nStaying tuned.\n. > No, this PR cannot be accepted as is\nIn case it wasn't clear, i meant build your \"hang\" fix upon this \"correctness\" fix in the pr-for-505 branch -- not necessarily yet merging this branch verbatim. Since, this branch does not fix the hang, but it does fix another correctness bug.\n. no worries; cherry-picking from pr-for-505 will also work, if you're pretty confident in your fix. the benefit of working directly on the pr-for-505 is that if we needed to iterate, i could easily pull your changes again (wihtout having to re-cherry-pick), but this particular issue is straightforward enough i don't anticipate further back-and-forth. the joys of git, right?\n. > cherry picked on top of my fix\nThat's cool. As long as it's a bona fide cherry pick or a rebase or similar -- and not a copy and paste -- it'll be easy for me to then get back to mainline on my fork. :-)\n. > Good news. I think I've figured out this particular hang. Basically, the nn_recv() keeps looping, even though it gets interrupted, because it doesn't see the STOPPING_EPS state. This is an easy thing to fix properly\nMost excellent.\n. > Hmm... now I'm not sure\nThis summarizes my >1yr narrative on this issue.\nCurrently, it seems the most robust resolution is to do away with the statically-allocated socket table (https://github.com/nanomsg/nanomsg/blob/master/src/core/global.c#L234-L235) that requires the global mutex, instead allocating each socket ad-hoc as it is created.\nThe effective socket identifier, from the perspective of the library user -- rather than being an integer on the range of [0, NN_MAX_SOCKETS-1] -- would be a pointer to a pointer.\nThen, sockets individually can mutex themselves when appropriate, without denying service to the rest of the sockets in the loaded instance.\nThe ultimate problem with the send and recv loops in sock.c is that they release a mutex that could be destroyed by the time they try to regain the mutex: https://github.com/nanomsg/nanomsg/blob/master/src/core/sock.c#L601-L608\n. > Currently, it seems the most robust resolution\nAnother potential solution is to truly fix NN-LINGER, which currently is not even implemented.\nOne current vector that's working charmingly well is to zombify the individual socket (https://github.com/wirebirdlabs/featherweight-nanomsg/commit/cb1408979e4951e0dd0b5fe4ae4779df9b0641e1), then allowing events rolling in during this zombified period to be handled as if the socket were still active (https://github.com/wirebirdlabs/featherweight-nanomsg/commit/79e41f6f9909849b33733873be0a4b102022d4d2).\nIt seems NN_LINGER could be defined as the period in which the socket is \"closed\" until the time it is \"deallocated\" -- which decently maps to what \"zombified\" means today.\n. > break probably gazillions of consumers who've come to rely on the select() / poll() compatibility feature\nHave you verified elsewhere this feature remains a requirement? There weren't any that spoke up on: http://www.freelists.org/post/nanomsg/Use-nanomsg-sockets-with-select-on-Windows\n. > I think the fact that closing() a FD doesn't always issue a notifciation/wakeup from the efd_wait() is the problem\nThis rings a bell, when I was attempting to do some refactoring (that did not pan out) early in the year (last 5 commits on this abandoned branch: https://github.com/wirebirdlabs/featherweight-nanomsg/commits/abandoned-sock-refactor)\n. > So this is interesting... on darwin, close() of a fd does not cause POLLIN wakeups in poll(). Which is why it hangs differently on MacOS\nYou're probably way ahead, but here's a trick to overcome this, by creating a private pipe always in index 0 of the poll set: http://stackoverflow.com/questions/19133138/cancel-a-socket-poll-operation\n. > just write to the polled fd since that is already what this is supposed to be doing\nThe trick here would be ensuring you could detect the value written as a sentinel value, and not something valid from a peer. Seems risky/brittle.\n. > The hard part here is not sending the message, its actually figuring out when you can actually close the file descriptor. Because you can't close it until all reads are done, and you don't know when that is complete.\nThis plays into why it feels NN_LINGER should be fully-fleshed out as a viable resolution for this issue.\nRight now, nn_close() is a synchronous operation, and this call is where we're having all the cross-platform hanging problems. There also exists a comment in that function saying that's it's current implementation is suboptimal: https://github.com/nanomsg/nanomsg/blob/master/src/core/global.c#L576-L577\nInstead, I feel nn_close() should effectively be asynchronous. It would synchronously set the socket as being zombified, but would not yet necessarily close() the underlying FD's or free() associated resources.\nOnce the NN_LINGER period has elapsed, cleanup occurs, including throwing away all outstanding read/write buffers, then free()ing and then returning the nanomsg socket descriptor [0, NN_MAX_SOCKETS-1] to the global pool.\nThat said, at the app layer, the developer can assume that nn_close(), even though no longer a synchronous operation, the library makes the guarantee that the resources will be properly cleaned up once the linger period has elapsed. (If not, this is a library bug that needs to be fixed)\nThoughts?\n. Legit.\n\nProbably also a new NN_CLOSING state\n\nNN_LINGERING might be a good name.\n. > This whole efd nonsense is the result of trying to fake real UNIX file descriptors. I cannot say this strongly enough -- this was a substantial architectural mistake\nTo be fair, let's classify it as innovation that didn't necessarily pan out. :-)\nAnd that said, I've not seen a solid answer yet as to why we can't get rid of http://www.freelists.org/post/nanomsg/Use-nanomsg-sockets-with-select-on-Windows to eliminate complexity. Why not? \n. > The next problem is that file descriptors get reused, so your poll may wind up polling against some other file descriptor. Argh\nYep. This is also problematic at higher layers, such as framework and application -- where additional bookkeeping and mutexing is required to solve this issue -- which is what led my train of thought toward \"The effective socket identifier, from the perspective of the library user -- rather than being an integer on the range of [0, NN_MAX_SOCKETS-1] -- would be a pointer to a pointer\" as being able to solve multiple layers of problems. Foremost, the incorrectness tracked by this Github issue, and also usability/correctness of library usage at higher layers.\nAnd if not a raw pointer, at least an ID that's reasonably unique per session of the library, such as an autoincrementing integer.\n. > autoincrementing integers ... probably breaks efficient lookup\nPerhaps, but not noticeable; the most na\u00efve approach here makes socket creation time go from O(1) to O(N) worst cast on a negligible lookup that is many orders of magnitude from the actual bottleneck during socket creation. After that, a single modulo of the exposed FD still provides O(1) lookup for all other socket operations.\nGiven a bit of time, I'd like to look into this, whether those statements actually hold and are easily implemented ...\n. > NN_BASIC_CHECKS but those checks are not done carefully under the global lock\nTo expand this; NN_BASIC_CHECKS and the subsequent actions that expect the preconditions guaranteed by NN_BASIC_CHECKS are not done under the global lock.\n. > At its root, the problem is that the cmsg header for SP headers are padded to a round number of alignment units (e.g. 8 bytes). This causes bogus padding (random values really) to be inserted when the headers are copied across messages\ngit blame .... oops. (That said, prior to the change, it had been a TODO comment.)\n\nYes, this is another case where attempts to emulate POSIX compatibility hurt us\n\nI understand other's desire for POSIX compliance; personally, it's an unwelcome hurdle. The CMSG POSIX API is wretched working with.\n\nI may wind up embedding another word (length) in the SP hdr to help us here. That's probably the only way to fix it. This WILL break users who are relying on the cmsg payload for the SP header\n\nGo for it, probably. I am one user who may have to change some bit-packing assumptions in app code, but that my reasonable expectation for using a library <v1.0, yes?\nCreate a new Github issue outlining briefly the proposal for how these extra bytes as the length header would be packed. We can iterate quickly and agree on a design.\n. > prepend 32-bit integer\nPrepend to what? The SP_HDR only, or to the entire CMSG structure? Is it an octet/byte count, or a CMSG count? What's the endianness? Does the CMSG API change, or just the underlying wire protocol that the CMSG API processes and wraps? I've likely overlooked such details, or am overthinking this, but glancing thru your posts again, it's not obvious precisely what needs to change, or even precisely why a length header is the best solution to the problem that clearly does exist (opposed to say, just fixing/defining a particular header as being of uint32_t or even uint64_t length, in network order endianness). I'm very likely in favor, but cannot say for sure yet, without a little more insight into design decision.\n. > A byte count prepended to the SP_HDR which indicates the number of bytes immediately following which are in the sp header.\nOK, that's what I thought. Which brings up what seems like an obvious question -- why is this needed?\nThe struct cmsg type already tells us the length: https://github.com/nanomsg/nanomsg/blob/42977e00776b4fea279d6311fb9756d132fa952c/src/nn.h#L282\nwhich can be retrieved with the macro: https://github.com/nanomsg/nanomsg/blob/42977e00776b4fea279d6311fb9756d132fa952c/src/nn.h#L310\nEXCEPT for this problem: retrieving the length here works for deserializing what came across the wire into your own platform specific padding/alignment structure, whereas our bug is that we're using this for serializing, where it is wrong to put platform-specific padding/alignment onto the wire: https://github.com/nanomsg/nanomsg/blob/master/src/core/global.c#L863-L877\nCan't that just be fixed without having to change the wire protocol? Can't the fix be just a correction in that code, and perhaps some redefinitions of macros?\n. You're also saying there is no bug right now in these lines? https://github.com/nanomsg/nanomsg/blob/master/src/core/global.c#L863-L877\n. Argh. The whole concept of the CMSG API seems to either be 1) fundamentally flawed, or 2) so subtle and tricky that it's virtually unusable.\nIt seems you're laying out the core problem as this: there needs to be one degree of indirection between platform alignment and wire-protocol, where that one degree of indirection does not currently exist with the CMSG API as implemented.\nAdditionally, there exists at least one bug because of this.\nSince that one degree of indirection does not exist, you're proposing to encode it into the payload of SP_HDR as a length header -- a header within a header within a header within a message.\nWriting that, you see my hesitation to see this as the best fix -- is there another way?? Say, one macro to determine wire-protocol length, and another to determine how a retrieved header exists in the local address space?\n. > In retrospect this is all garbage.\nA year ago in Nov 2014 I was working with this CMSG API and had quite a few sidebar emails trying to make sense of it. This quote captures the essence of what was happening both then and now: \"the POSIX CMSG structure is TERRIBLE for usability. It's not too bad reading headers with the macros, but building up the structure is a pretty terrible developer experience\"\n\nsane way to handle this would have been to expose struct nn_msg * directly to applications. Of course, not very POSIX like. But waaaayyy simpler, and more robust. And, btw, less data copying too\n\nThis is such a fundamentally important topic. POSIX compliance as a design requirement for nanomsg. I would prefer to see it dropped, since I feel it hurts both adoption of nanomsg (since its public API is more complicated because of POSIX compliance; it acts as a hurdle/barrier to entry) and also hurts development of nanomsg (see quote above). But spiritual discussions like this are not for this thread.\n\nAnd you're right, the header within the header is kind of ugly. I could decorate the cmsg structure to add a field that holds this value\n\nThird alternative (not saying this is the best, it just \"is\") is introducing one more CMSG header field SP_HDR_LENGTH to complement SP_HDR data. For now, in the spirit of still keeping with POSIX, changing the cmsg structure shouldn't be an option. For now.\n. > I think you just restated what I proposed as the second option\nI don't think so. Rather than expanding nn_cmsghdr (https://github.com/nanomsg/nanomsg/blob/42977e00776b4fea279d6311fb9756d132fa952c/src/nn.h#L281-L285) to contain one more field cmsg_datalen, I meant to add one more header to the header list SP_HDR_LENGTH in addition to SP_HDR.\nThis way, when extracting SP_HDR, you would also extract SP_HDR_LENGTH in order to know how to populate nanomsg's internal representation the SP header.\nThat said ...\nI may have come full circle, and would probably tend to lean toward your a) as the best option.\nWonkiness has been detected, and rather than leaking wonky into other places, let's contain the wonky to where the problem is. A header within a header within a header within a message is certainly wonky; but in this case, it kinda acts as anti-wonk to cancel out wonk.\nb) is more \"sane\", but represents and attempt to bring sanity to CMSG. Perhaps it's better to agree to allow it to remain a little insane.\n. > although git only allows me to record one author. (Given the rather large amount of refactoring I did in sock.c, core.c, and the efd framework, it didn't really feel right leaving you as the primary commit author.)\nThis is acceptable; forward progress on this issue is infinitely more valuable than pristine commit history.\nI'll try to scatter a few comments in the commit in the next few minutes while you have inertia ... then a more thorough testing next few days ...\n. > 0x00007f1437505e88 in nn_sock_shutdown (self=, src=, type=, srcptr=) at src/core/sock.c:828\nBased on the source of the abort (line 828 in sock.c), I think this issue was based on an older codebase\n\nAnd? How did it go? Also, you could test v0.8\n\nHaving seen the same issue as OP reported here in https://github.com/nanomsg/nanomsg/issues/269, and now that that case is resolved, unless we hear otherwise from @panjw, I think this case can be closed as fixed.\n. Link to failure: https://travis-ci.org/nanomsg/nanomsg/jobs/91501857#L667\nIt's a stretch, but to help brainstorm: is it possible that https://github.com/nanomsg/nanomsg/blob/master/tests/ipc_shutdown.c#L82-L84 ignoring of the SIGPIPE error is now hurting us?\n. > in a VM\nIdea: drastically throttle the VM; 1 core, 1GB memory ... try to repro what are probably relatively \"low resource\" conditions on Travis.\n. Bump. This is continually failing in Travis CI -- here's the latest failure: https://travis-ci.org/nanomsg/nanomsg/jobs/123991735#L642\nThis bug should be bumped to one of the highest priorities, especially since it's still not well-understood what causes the issue.\n. Just to keep a history, here's one recent such failure: https://travis-ci.org/nanomsg/nanomsg/jobs/129835988#L741\n. > YEP. 200 Msec isn't enough. Waiting a full second works fine. Yikes, that's just very very sad. At least for people stuck on Windows\nIs this really the root cause? Surely not. Does increasing time to 1000msec (1sec) fix the issue every time reliably? If so, you might be right here, but I suspect in that case time is just masking a more precise root cause.\n. > Address already in use 98\n@gdamore and @anatol -- looks like we're converging: https://github.com/nanomsg/nanomsg/pull/551\n\nI think tests should not hardcode the port. This port can be used by some process already. It would be better to use bind with port==0 that would give a free port\n\nAgree. I would love the ability for nanomsg to choose an ephemeral port. I understand (fully?) the design decisions behind problems of service discovery and directory service being avoided by not originally allowing bind to ephemeral ports in nanomsg, but that design decision only holds for \"persistent\" services. Not all services are \"persistent\" -- one such application domain is testing.\n. Yikes; lots of syntax errors on Visual Studio 11 generator -- will fix these and commit on the same branch. That said, NMake shows the failure.\n. > Windows TCP slow start takes ~forever\nPerhaps .... but if this is the case, we would see just as many failures in this test case submitted for TCP transport as WS transport, yes?\n. Check it -- Travis reports a failure on CLang: https://travis-ci.org/nanomsg/nanomsg/jobs/92822123#L710\n. Fixed the C89 compile error and repro'd with MSVC: https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.190/job/516sh4pag3876gx0#L1547\nBy the way, @gdamore -- I've been testing all your nn_close improvements, and this PR represents the final issue remaining that I'm currently able to characterize and provide a minimal test case for -- thank you kindly for so much work flushing out all the other little shutdown issues!! Everything else is working quite well.\n. OK, we've got an NMake failure (https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.190/job/ib0e3elum2j4tufa#L692)\nAnd this time, CLang reported no error ...\n... but 6minutes in, gcc is about to fail.\nThis is definitely a problem with the WebSocket transport that periodically affects all platforms.\n. Stack trace of hang on Windows:\nntdll.dll!NtWaitForSingleObject() + 12 bytes    Unknown\n[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll] \nKernelBase.dll!WaitForSingleObjectEx() + 183 bytes  Unknown\nKernelBase.dll!WaitForSingleObject() + 18 bytes Unknown\nnanomsg.dll!nn_sem_wait(nn_sem * self=0x0047e378) Line 122  C\nnanomsg.dll!nn_sock_term(nn_sock * self=0x0047e0f0) Line 219    C\nnanomsg.dll!nn_close(int s=0) Line 591  C\nws_async_shutdown.exe!test_close_impl(char * file=0x0014a8b8, int line=100, int sock=0) Line 119    C\nws_async_shutdown.exe!main(...) Line 100    C\nws_async_shutdown.exe!__tmainCRTStartup() Line 626  C\nws_async_shutdown.exe!mainCRTStartup() Line 466 C\nand there's only 1 other thread -- an nn_worker_routine:\nntdll.dll!NtRemoveIoCompletionEx() + 12 bytes   Unknown\n[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll] \nKernelBase.dll!GetQueuedCompletionStatusEx() + 132 bytes    Unknown\nnanomsg.dll!nn_worker_routine(void * arg=0x61626b40) Line 168   C\nnanomsg.dll!nn_thread_main_routine(void * arg=0x61626b60) Line 30   C\nmsvcr120d.dll!_beginthreadex() + 417 bytes  Unknown\n. > we aren't waiting long enough for the nn_socket to bind/connect, and we're stuck waiting for that due to a left over item from the earlier invocation\nOne significant difference between TCP and WS is that TCP will attempt to rebind to and already-bound socket: https://github.com/nanomsg/nanomsg/commit/1936472d557d5b7a23768873a4b2c86a85abcab7\nComparing, since this failure mode does not seem to affect TCP transport, just WS.\n. > mangos reconnects winsock as well as TCP\nI don't really understand this statement; are you saying this specific problem is on re-using a port?\nI'm not exactly confident that port re-use is the problem here. In a separate application test suite, where I first found this bug, a similar stress test was choosing ephemeral ports rather than re-using ports.\n. > choosing ephemeral ports\nAnd before this raises more questions than answers ... it chose this ephemeral port at a higher layer than a bona fide * on nn_bind() (since libnanomsg does not yet support this), meaning there does exist a known race condition between when the port chosen and whether it's still available by the time nn_bind() was invoked. But for all intents and purposes, I think we can assume there were no collisions.\n. > Which is why you don't have it in winsock\nYou keep saying winsock. Do you mean WebSocket?\n. Of course. This thread makes a lot more sense now reading thru. Taking a look thru https://github.com/nanomsg/nanomsg/commit/1936472d557d5b7a23768873a4b2c86a85abcab7, it appears that it wouldn't be hard for me to port this to the websocket transport; unless you're already down this path, I'll take a look into this next couple days.\n. That said ... perhaps it would help to probe the statistics structure while the socket is hung? Will try this to see if anything jumps out ...\n. \n. 10 accepted_connections and 10 broken_connections would tend to indicate that aws detected the break at this line: https://github.com/nanomsg/nanomsg/blob/master/src/transports/ws/aws.c#L272\n. > brain is tired from tracing through FSM hell\nD\u00e9j\u00e0 vu and sympathy pains here, flashback 1yr ago. That said. I'll look into this issue.\n. OK, I've effectively implemented parity in WebSocket with TCP in terms of NN_RECONNECT_IVL and backoff timers.\nThis does not seem to yet help this issue, so it will be coming in as a separate PR unrelated to this hopefully later today.\nThat said, while poring over differences, there are a couple things I noticed that could potentially help both TCP and WebSocket.\nStay tuned ...\n. So ... it might appear that, unceremoniously, this is the culprit for this hang:\nhttps://github.com/nanomsg/nanomsg/blame/master/src/transports/ws/aws.c#L316\nCompare that to the corresponding lines in TCP:\nhttps://github.com/nanomsg/nanomsg/blame/master/src/transports/tcp/atcp.c#L293-L294\nI seem to recall making that change for a specific reason (it's been >1yr now, that memory is rusty) -- but it was in order to properly close the TCP connection in order to best satisfy Autobahn TestSuite.\nWithout making the best effort to shut down the connection properly, Autobahn would throw failures/warnings for its peer-under-test not performing clean shutdowns.\nSo that said ... it's not entirely clear how to move forward, but it feels like the best thing to do is tend to migrate WebSocket (https://github.com/nanomsg/nanomsg/blame/master/src/transports/ws/aws.c#L316) over to TCP (https://github.com/nanomsg/nanomsg/blame/master/src/transports/tcp/atcp.c#L293-L294), rather than the trivial vice-versa that simply seems to fully satisfy the test in this PR #551.\n@gdamore this could be related to the root cause of why it appears Windows takes >1sec to recover from some of the more brutal tests -- nanomsg may not be currently shutting down TCP in the best way possible.\n. This PR is superseded by https://github.com/nanomsg/nanomsg/pull/563 and will be closed once #563 is acknowledged.\n. Superseded by #565. Closing.\n. I'll mention again here on this thread (https://github.com/nanomsg/nanomsg/pull/520#issuecomment-156309833), I think that implementing NN_LINGER and combining the concepts of \"lingering\" and \"zombified\" as the final state NN_LINGERING will appropriately resolve this issue.\nOne of the keys is to keep send/recv operations as if the socket were still active while in this NN_LINGERING state, along the lines of: https://github.com/wirebirdlabs/featherweight-nanomsg/commit/79e41f6f9909849b33733873be0a4b102022d4d2\n. Fair enough about NN_LINGER.\nThat said ... I've been continually working in and around such shutdown problems, and I keep coming back to these lines: https://github.com/nanomsg/nanomsg/blob/master/src/core/global.c#L581-L586\nThe fact that the two nn_sock_rele (sock); are called outside of the global lock rather than inside. It feels ... fishy. Especially without the hold counter being a true atomic counter.\nAnecdotally, I'm having better results with those calls inside than out, but it's hard to say for sure, while also tracking down separate failure modes in the WebSocket transport.\nThoughts on this?\n. If a PR to kick off tests would help, lemme know; I'm at the keyboard, if you're not.\n. It might be a winner ... all CI environments passed this iteration ... time will tell after more runs. At least it feels a step in the right direction.\nI hope to be submitting a few more PR's today with WebSocket shutdown and testing improvements, and these should kick off even more tests.\n. > I hope to be submitting a few more PR's today\nWill not hit this before holiday; picking back up next week.\n. > To be honest, all of these evils come from making the socket descriptors poll() and select() usable. If not for that requirement, I could simply use ordinary synchronization primitives and be done with it.\nRemove the feature.\nNobody spoke up when you asked who's using it on the mailing list.\nThe opportunity cost of keeping it in has become far too expensive. Once the library is solid, let's consider re-inclusion.\n. OK, I may be on to something.\nThe tests that appear to continually fail are ipc_shutdown, tcp_shutdown, and device7: https://ci.appveyor.com/project/gdamore/nanomsg/build/0.8.251/job/ujpbvrpnno02a7xs#L1537\nThe red herring is when we say \"fails only on Windows\".\nFor instance, within my local dev environment in a Windows VM, these tests pass just fine.\nThe hot lead is this -- the AppVeyor environment is likely the only build environment where we have a single core.\nOn a hunch, I rebooted my local dev VM as a single core environment, and was able to repro the same test failures.\nI don't think these failures are only on Windows, but rather, only in single test environments.\n@gdamore, thoughts on this?\nThis might explain why we periodically see failures in Travis CI. The STANDARD environment has \"~2, bursted\": https://docs.travis-ci.com/user/ci-environment/  (that said ... I think we've been in the CONTAINER-BASED environment, which has \"2 cores\" ... not \"~2 cores\")\nWhereas AppVeyor explicitly has 1 core with the Open-Source (Free) environment: http://www.appveyor.com/docs/build-configuration\n. > I don't think these failures are only on Windows, but rather, only in single test environments.\nMissed a key word: \"only in single core test environments\"\n. Aha! Not precisely true, that single-core environments are the culprit for explicit failure modes.\nThey just take a stupidly long time to produce correct behavior.\nSee: https://ci.appveyor.com/project/gdamore/nanomsg/build/0.8.254/job/u0anhr7wrpbre8jg#L1543\nAssociated with this \"exorbitantly-generous\" commit: https://github.com/wirebirdlabs/featherweight-nanomsg/commit/bbd46545327fa32adf10e47dd5d693b6813bd1db\n. And that said... the one remaining failure is: https://ci.appveyor.com/project/gdamore/nanomsg/build/0.8.254/job/u0anhr7wrpbre8jg#L1585\n@gdamore -- I'm still bent on the solution to this failure looking something like this: https://github.com/wirebirdlabs/featherweight-nanomsg/commit/79e41f6f9909849b33733873be0a4b102022d4d2\nWhere, it looks like you're ooching toward the same conclusion: https://github.com/nanomsg/nanomsg/pull/562/files#diff-213d12c67883313942a42887da10c6c2R1041\n. Legit.\nre: https://github.com/nanomsg/nanomsg/issues/445\n. This is to be used in a forthcoming set of PRs for WebSocket transport improvements, including 1) backoff timers on bind/connect, 2) better shutdown behavior and a more complete RFC 6455 close handshake compliance (while remaining true to abstracting this from the nanomsg user by encapsulating this behavior in the library), and 3) re-enabling and rigging Autobahn TestSuite for integration on Travis and AppVeyor.\nThese PR's will not be ready until next week after the national holiday, but here's a link to a peek at all work done so far diffed with nanomsg head fork (caveat emptor -- some incomplete thoughts, but just wanted to push since I'll be OOO a few days):\nhttps://github.com/nanomsg/nanomsg/compare/master...wirebirdlabs:sandbox-websocket-clean-shutdown\n. This PR is superseded by https://github.com/nanomsg/nanomsg/pull/563 and will be closed once #563 is acknowledged.\n. Superseded by #565. Closing.\n. So ... thoughts on this. The current implementation of nn_term() just pulls the rug from underneath a structured application shutdown, and I cannot imagine recommending the usage of this method in a production application.\nEven in a non-production application, it's just as well to kill the process as to blanket destroy any and all active sockets, if quick-n-dirty makes more sense than taking the time to design a structured shutdown.\nAs for the use-case of shutting down a device -- the application recommendation should be to create the socket (or perhaps both sockets) in a local thread prior to passing its ownership to an async thread where the device is created to combine the two sockets.\nThis way, the application developer should always have a file descriptor to at least one socket part of the device in order to call nn_close(), which would effectively bring down the device cleanly.\nSaying the same thing from a different perspective -- the device7 test goes against best practices of creating at least one socket locally, but instead creates both sockets in the same async thread as the creation of the device: https://github.com/nanomsg/nanomsg/blob/master/tests/device7.c#L45-L51 When this best-practice is overlooked, \"needing\" (air-quotes) nn_term() in its current manifestation is contrived, and not a case we should test for or even support.\nI propose that we officially deprecate the nn_term() method immediately, and especially prior to v1.0.\n. You're right.\n. Closing this PR for now due to a new strategy for shutdown with #694. @gdamore -- feel free to reopen if necessary. Thanks!\n. Also -- it's expected that the ws_stress test will initially fail -- after verifying it fails, the first commit to roll in will be turning this test off by default to kick off the next test.\n. As expected, disabling ws_stress has enabled the tests to pass. Now, on to updating the CI specs to download/install Autobahn python package, and enable the test by default (this may not happen today... stay tuned)\n. OK, time to hang my hat up for a while, and also request some help:\nBriefly, there is a CI environment variable (https://github.com/nanomsg/nanomsg/pull/563/files#diff-354f30a63fb0907d4ad57269548329e3R7) that needs to override a defined constant in the source code (https://github.com/nanomsg/nanomsg/pull/563/files#diff-1f8bb897866ba4f42b43d5b44a42197bR42), only in the context of the CI environments.\nIt seems this task will take just a small handful of strategically-placed or modified lines somewhere in the chain between (and including) these two places, very likely delving into autoconf-land and touching configure.ac, but this is an area where I'm just not experienced.\nHelp? We're close.\n. This is nearly working on Linux. Currently, it's failing here: https://github.com/nanomsg/nanomsg/pull/563/files#diff-1f8bb897866ba4f42b43d5b44a42197bR250\nWhich is not surprising. Will have to figure out a clever way to resolve this.\n. > At the end of the day, strict autobahn conformance is one of those things that seems \"nice to have\", but not entirely necessary, provided we interoperate with other websocket implementations\nIt's not really about strict Autobahn conformance, or even strict RFC 6455 conformance -- it's about using Autobahn in order to test the code paths, especially things like chunked transfers, opening handshake compliance, what would happen if browsers/agents decide to ping ... basically a lot of things that are outside the scope of the peer's nanomsg implementation, but are discretions of the underlying transport itself.\n\nI've got some pretty mixed feelings about enabling autobahn by default\n\nIt's only enabled by default on CI environments (well, getting there...), and only if explicitly-requested if you are building from source.\n\nHaving to run sudo for the tests means that CI is going to take longer since it cannot use containers.\n\nTrue; it adds time (roughly +90sec), but once enabled, the WebSocket transport should be the most comprehensively-tested transport in libnanomsg (e.g., we don't have a fuzzer sending known-bad packets to TCP). I think the tradeoff is worthwhile for the quality.\nI would like to investigate how we can get away from needing sudo so we can move back to containerized environments, and also cache the dependencies.\n\nIts also going to make life harder for other folks\n\nIt shouldn't -- this was an important design goal when adding this test. It's opt-in only, using --enable-autobahntest=yes on the configure step.\n. @gdamore -- looks like AppVeyor configuration is currently controlled thru your web interface at https://ci.appveyor.com/project/gdamore/nanomsg rather than appveyor.yml in the repo root -- would you mind stubbing out the current settings into a new file?\nFor reference, here's the template provided by AppVeyor docs: http://www.appveyor.com/docs/appveyor-yml\n. > @gdamore -- looks like AppVeyor configuration is currently controlled thru your web interface\nThat said ... it appears the default settings for a project (looking at my own AppVeyor account) allow appveyor.yml to take precendence by default ... I'll go ahead and try committing one in the meantime...\n. It worked! @gdamore, I can take it from here for the time being (not blocked by your admin account ownership after all). Will also trace thru old build logs to recreate the proper settings.\n. @gdamore I will spend time today squashing these 62 commits into distinct, coherent PR's.\nI hope this makes your job merging much faster.\n. > Having to run sudo for the tests means that CI is going to take longer since it cannot use containers\nFYI, this may be a temporary limitation: https://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Using-sudo-isn%E2%80%99t-possible-(right-now)\n. > Why does autobahn require this?\nOnly a package installation: https://github.com/nanomsg/nanomsg/pull/563/files#diff-354f30a63fb0907d4ad57269548329e3R12\nTravis CI recommends building an executable binary, storing that to your own server (or repository), then copying it into the environment, as one solution that doesn't require sudo.\nAdditionally, that would cut appreciable time off the build.\n. > Check this\nGreat tip. I'll look into that, and trigger a build here in a minute that removes the sudo in order to observe the failure mode.\nIn the meantime, check out the latest commit -- since it may be relevant for issues you've been chasing: https://github.com/nanomsg/nanomsg/commit/d15451743ed645c4b83a23865e4e2f7164b88359\nand a link to the line number in the log of the associated failure mode: https://travis-ci.org/nanomsg/nanomsg/jobs/94521740#L877\n. Wow ... --user flag is all it took to get back to container environment -- we're back in business! No sudo, faster performance.... even Travis CI recommends this: https://docs.travis-ci.com/user/languages/python#pip\nWell, that was a freebie.\nA refreshing treat, after dealing with persnickety, mind-numbing autotools ...\n. OK, the rebasing begins -- everything is working quite well, except for two tests -- tcp_shutdown, and also device7\nThe Autobahn test has been consistently passing on both platforms, as with the ws test.\n. Superseded by #565. So long, infernal thread of autotools strife. Closing.\n. @gdamore any problems merging this one? It's hard to keep making forward progress juggling branches away from mainline.\n. So, confirmed, no, because this issue is so infrequently reproduced.\nI spent some time trying to trace out all the code paths to confirm this fix is correct, but retracing my (original) inductive reasoning in order to give you a definitive answer, I'm not 100% confident that this patch is not just masking the real problem.\nThe reasoning goes something like this:\nWhen we do observe the failure, it's clear what failed, because of the log. (link in original PR, here's a copy for convenience: Unexpected source: state=5 source=1 action=5 (../src/transports/utils/streamhdr.c:306))\nTo dereference those numbers:\nstate=5 is NN_STREAMHDR_STATE_STOPPING_TIMER_DONE\nsource=1 is NN_STREAMHDR_SRC_USOCK\naction=5 is NN_USOCK_ERROR\nHow could we have gotten to the NN_STREAMHDR_STATE_STOPPING_TIMER_DONE state? From only one location, where USOCK must have just posted the NN_USOCK_RECEIVED action: https://github.com/nanomsg/nanomsg/blob/9a0cb281695759fde449244b5f664ece5075d9f5/src/transports/utils/streamhdr.c#L227\nIs it possible that the USOCK could immediately post NN_USOCK_ERROR just after NN_USOCK_RECEIVED but before NN_STREAMHDR_SRC_TIMER posts NN_TIMER_STOPPED? Conceivably -- and if so, that would be evidenced as the assertion in this case.\nThat said ... it's hard to trace the logic between the timer and the usock to prove whether this case could definitely exist.\n. understandable. and agree.\n. > The only thing I've not been 100% certain about was whether the assertions you've included are actually true. I think they, and if they're not, it will be good to know\nPrecisely my logic as well. It's not awesome to be adding assertions rather than taking them away from the library, but it felt weird/wrong to blanket-ignore all events, without defining a reasonable subset.\n. Merge yet?\n. By the way, Travis CI has had 6 passes in a row on this branch, and AppVeyor has only failed on tcp_shutdown and device7.\nThose two tests are known to (periodically) fail at this point -- meaning, all other checks are passing, notably the tests created in this PR.\n. > resolve the conflicts\nworking on it; shouldn't take long.\n\nOriginally we talked about separating the test cases from the new state machine work you did for websocket.\n\nThe Autobahn TestSuite is a separate commit, not a separate PR. The reason putting them all in one PR is to ensure they could apply cleanly on the other, so you wouldn't have to figure out the order.\n\nreadiness\n\nReady.\n. The analysis is solid and needs to be fixed, but the patch provided should probably be refactored somehow in the library code, perhaps to the underlying socket layer. This would avoid #ifdef at such a high layer in the library code, and instead, contain such platform differences where we're already accounting for platform differences in the lower layers.\n. Said another way, the patch seems to be a solid proof-of-concept, but should be refactored into more sustainable code that fits with the existing design of the library. Thank you, @pavel-pimenov for this report! Good find.\n. With regards to the test failure: https://travis-ci.org/nanomsg/nanomsg/jobs/95899479#L1095\nThat's a late-breaking known issue that will likely be resolved shortly: https://github.com/crossbario/autobahn-testsuite/issues/55\n@gdamore if you prefer we can disable the test in the meantime by changing one line in both CI specs:\nTravis CI: https://github.com/wirebirdlabs/featherweight-nanomsg/commit/28f6c213f903d94ceb5e7754fb248a78722b6fd9#diff-354f30a63fb0907d4ad57269548329e3R13\nAppVeyor: https://github.com/wirebirdlabs/featherweight-nanomsg/commit/28f6c213f903d94ceb5e7754fb248a78722b6fd9#diff-180360612c6b8c4ed830919bbb4dd459R26\n. Merge yet?\nAs a reminder this notification still exists in the documentation THIS IS AN EXPERIMENTAL FEATURE. DO NOT USE. THE FUNCTIONALITY IS SUBJECT TO CHANGE WITHOUT PRIOR NOTICE.: https://github.com/nanomsg/nanomsg/blob/master/doc/nn_ws.txt#L19-L20\nRemoving that notice will be the cherry on top of this PR.\n. see #578\n. > I'd really like to break out the autobahn tests into a separate PR\nUnderstandable -- once #578 is mainlined, I'll clean up this PR to be only Autobahn TestSuite, fully squashed into a single commit.\nThat said -- what are options for mainlining this \"big\" dependency that optimally 1) helps the library by being run yet 2) remains transparent in order to not burden the rest of the dev process?\nLike the Documentation and also Diagrams in this repository, which are opt-in based on whether you have the additional dependencies already installed, so is this test.\nWhat about informing Travis CI and AppVeyor to only run this WebSocket test on a certain branch? Or only on PR's? Or only when tagging to create a release? (or some combination thereof)\n. > a bit unhappy\nCan you live with it? The opportunity cost here is momentum. I generally agree with the tracking policy of commits and bugs, but recent development in these commits is more of a continuation of initial development that stagnated, rather than a patch for a defect or upgrade to a stable feature (where that sort of traceability is more valuable).\n. In the spirit of forward progress, I won't argue fix-before-test order, or the value of squashing 4, but feel free to cherry pick and change commit messages up thru the third (or fourth) -- i'll be glad to clean up squashing 5+6 afterward in a new PR if it helps.\n. Closing this PR without merging since it is superseded by #578; we'll resume conversation about Autobahn integration at a later date.\n. Preparing this PR is my first priority.\n. > make it much easier to convince folks within my company to use nanomsg in the future\nExcellent!\n\nget this resolved soon\n\nSame here ... overcoming the bit of inertia mentally spooling up on this topic again, but looking good ...\n. Hi @shiva -- I'm actually working on getting this into a PR for nanomsg as early as tomorrow (Saturday) -- in the meantime, feel free to make line-item comments either in that repository or here that might help. It's been private work to this point, but you'll see stuff start to show up publicly soon.\n. > Found and fixed a few minor issues\nDiscussion continued here: https://github.com/JackDunaway/featherweight-nanomsg/pull/1#issuecomment-210697309\nWe'll loop back to this issue once that wraps up.\n. Back of the napkin calculation for nn_alloc (sizeof (struct nn_msgqueue_chunk), \"msgqueue chunk\"); in (msgqueue.c:39) does check out to 12104bytes (assuming 8byte pointer) ...\nThat said... (sinproc.c:79) indicates you're testing a version sometime prior to head -- can you reproduce this issue with the latest repository snapshot? (especially, after https://github.com/nanomsg/nanomsg/commit/18733b4161bccafaaeaa934793638909a6c05ebb)\nPlease continue to report any/all issues like this found with valgrind -- much appreciated.\n. I can verify what appears to be a similar memory leak using one of the existing tests, https://github.com/nanomsg/nanomsg/blob/master/tests/inproc.c\nDetected memory leaks!\nDumping objects ->\n{459} normal block at 0x00691F70, 12100 bytes long.\n Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD \n{450} normal block at 0x0068B6C8, 12100 bytes long.\n Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD \nObject dump complete.\nThe program '[5444] inproc.exe' has exited with code 0 (0x0).\nInvestigating a bit more ...\n. Here's a minimal test case below. The leak happens when the bound socket is closed before the connected socket.\nThis does not seem to be limited a specific scalability protocol, but it does seem to be limited to the inproc:// transport.\nNote the comment in this code -- reverse the close order of the sockets, and the leak does not happen:\n```\n    int nnbd1, con, sock1, sock2;\nsock1 = nn_socket (AF_SP, NN_REQ);\nnnbd1 = nn_bind (sock1, \"inproc://SERVER\");\nsock2 = nn_socket (AF_SP,  NN_REP);\ncon = nn_connect (sock2, \"inproc://SERVER\");\n/*  This shutdown order exhibits the leak; swap, and no leak. */\nnn_close (sock1);\nnn_close (sock2);\n\n```\n. Cool! That said, there still exists a bug here.\n@gdamore, you have a more holistic view of inproc:// right now -- any ideas?\nThe difference between the two cases above (leak, and no leak, depending on order of nn_close()), is that in the leak scenario, nn_msgqueue_init() is called 3 times and nn_msgqueue_term() is only called twice.\nHere's the call stack of the third allocation that is creating the leak:\nnn_msgqueue_init(nn_msgqueue * self=0x00f08b98, unsigned int maxmem=131072) Line 32\nnn_sinproc_init(nn_sinproc * self=0x00f08ae8, int src=1, nn_epbase * epbase=0x00f08ad4, nn_fsm * owner=0x00f08aa0) Line 80\nnn_cinproc_handler(nn_fsm * self=0x00f08aa0, int src=1, int type=6, void * srcptr=0x00f08ae8) Line 232\nnn_fsm_feed(nn_fsm * self=0x00f08aa0, int src=1, int type=6, void * srcptr=0x00f08ae8) Line 72\nnn_fsm_event_process(nn_fsm_event * self=0x00f08c54) Line 66\nnn_ctx_leave(nn_ctx * self=0x00f07e30) Line 63\nnn_ctx_leave(nn_ctx * self=0x00f06c80) Line 92\nnn_sock_stop(nn_sock * self=0x00f06c40) Line 204\nnn_close(int s=0) Line 580\nmain(...) Line 231\n. In order of the 6 commits on this PR: #579, #505, #505, #580, #581, #581.\nThe two 505's are separate commits to 1) provide test then 2) provide fix, in order that other may independently verify the bug from the fix (testing alternate fixes, etc), so there's a 2:1 commit/issue ratio here.\nThe two #581's could be squashed, but that would make fast-forwarding hard (for me) and would erase commit log history from the code review.\n. I'll try to repro on OS X -- I've not noticed it on the Travis or AppVeyor environments. Any specifics on your OS X environment that shows the failure?\n. 10.11.2 here too ... I can't get it to repro after many runs (ran 10+ times now):\n```\nTestsuite summary for nanomsg 0.8-beta-18-g7607653\nTOTAL: 40\nPASS:  40\nSKIP:  0\nXFAIL: 0\nFAIL:  0\nXPASS: 0\nERROR: 0\n============================================================================\nJack-MacBookAir13-Mid2013:featherweight-nanomsg jack$ git rev-parse HEAD\n7607653e3980b7736b145cf4abe9e4f969c61730\n```\n. > So rather than sending me a single big PR, lets take these one item at a time; yes its more work, but at least that way we can make progress\nI hear you ... but it's just too tedious trying to get this stuff in. There may still be loose ends, but these PR's absolutely tie up known issues -- and the new failure you're able to show may be new, it may be an existing issue. There's a long history of AppVeyor and Travis CI passes for all the work in this PR -- I'd strongly recommend to just get it in, and start sourcing out testing to others besides yourself.\nAgain, if for no other reason -- this library is still <1.0, and there's still a huge warning not to even use the WebSocket transport on the public website: http://nanomsg.org/v0.8/nn_ws.7.html\nOnce these commits are mainlined, it's arguable that WebSocket transport in this library is on par with the TCP transport.\nI'll look into updating the Travis CI spec to include OS X in the matrix.\n. > I\u2019m using an high end iMac 27\nI have one of those too, but never saw it when testing there either (during development).\n. Got the error, finally!\nAssertion failed: rc < 0 (tests/ws.c:225)\nThat particular part of the WebSocket test does more checks than the TCP test.\nTCP: https://github.com/nanomsg/nanomsg/blob/master/tests/tcp.c#L183-L199\nWebSocket: https://github.com/wirebirdlabs/featherweight-nanomsg/blob/pr-ws-mega-squash-3/tests/ws.c#L199-L233\nHere's the analysis -- 1) either the test is valid, and we might expect TCP to fail in the same manner if it were tested in this manner, or 2) the test is not valid, and is just subject to some inherent race condition, and the test should be improved.\nEither way ... can we still move forward with merging? Even if that part of the test is broken, it's worthwhile to see it deleted in the commit history with rationale why it was wrong (rather than squashed)\n. Closing this PR for now; it will be replaced in the near future with commits that merge cleanly.\n. Related: this branch (and others) will be pruned from the https://github.com/JackDunaway/featherweight-nanomsg repository, meaning some links above in GitHub may not work anymore.\n. It's OK to pull it out of #578 (agree with all your reasons), but it's used in #569. Let's table this one for now.\n. Would you explain?\n. What kinds of options are you wanting to set?\n. That'd be a security hole for any transport type (not just WebSocket) -- enabling a socket peer to change behavior like this.\nIf you want to be able to tune those parameters remotely, you can introduce your own application-level protocol (but it doesn't seem like a good idea)\n. Fixed with patches introduced by #695\n. I'll extrapolate here, that @gdamore meant to type \"sane\" rather than \"same\" from a mobile phone -- in other words, much closer to a compliment than a jab, in case that didn't come across @Snaipe :-)\nEven if that's not the case, I'll go ahead and say it -- much more sane indeed.\n. > Thus far, I'm sometimes having some issues with the way to deal with memory allocated by nn_recv -- the rest being gracefuly handled by the nn_term -- since it's very possible for a fork to happen while nn_recv blocks in another thread\nCan you link line numbers to some of the more problematic allocations?\n. Hi @Snaipe -- I don't have an answer, but can offer some related information.\nWhen working on bringing CMake chain up to the same capability as the Autotools build chain, I noticed something similar -- that nanomsg was not yet designed to switch back/forth to shared/static library at the configuration stage.\nHere's a commit that fixes this for Windows: https://github.com/wirebirdlabs/featherweight-nanomsg/commit/ce4c5d353b9e22f4e7f0e7620095724cc72c8b61\nThat said, would you be willing to switch to CMake instead of Autotools and submit any patches there? If so, I would greatly appreciate your help so we could mainline that work. Here are more details: https://github.com/nanomsg/nanomsg/issues/574\nAnd here's a preview of the CMake script: https://github.com/wirebirdlabs/featherweight-nanomsg/compare/pr-ws-mega-squash...wirebirdlabs:ftw-kernel#files_bucket\n. Cool! What is your timeline for needing this? I will try to create a cogent PR within the next couple days that puts together this CMake work, from which you can work.\nIf you want to start before that, feel free to cherry-pick and continue making forward progress, but be forewarned that the PR will have squashed most of those commits into a single commit (meaning, if you work from these, your branch wouldn't cleanly fast-forward from what would eventually be mainlined, though your work should be able to be cherry-picked cleanly onto mainline)\n. See: https://github.com/nanomsg/nanomsg/issues/648\n. CC'ing @gdamore for visibility to discuss this PR further, especially in the context of #641\nIt makes sense to standardize on options flag conventions. Here in #591, NN_TOOLS and NN_TESTS are introduced, and in #641 three other flags are introduced: https://github.com/nanomsg/nanomsg/pull/641/files#diff-af3b638bc2a3e6c650974192a53c7291R84\n- shall we use the NN_ prefix? I'm ambivalent, except strongly prefer a yes or no versus mixed prefixes (this, having introduced mixed prefixes myself in #591!)\n- shall we place all options near the top of the script, rather than near the code it cases? (I prefer seeing them all at the top, rather than hunting through CMakeLists.txt to discover all the options it exposes)\n- Here in #591, NN_TOOLS overlaps with ENABLE_NANOCAT introduced in #641. Again a prefix question -- ENABLE_ is somewhat of a CMake convention ... do we use it? Would the best option be NN_ENABLE_TOOLS or ENABLE_TOOLS or NN_NANOCAT or ... ? (Again, ambivalent here, except that it be uniform)\n. > not having to fix a project's cmake configuration is a big plus when the price to pay is a three character prefix\nGood point. NN_ prefix seems like it should be the standard here.\n. @gdamore, any issues here? If no, I can mainline; looks good to me.\n. fast-forward merged; thank you, @Snaipe!\n. > pull request \u5c31\u662f\u7ed9\u4e2agit\u7684\u8865\u4e01 \u6bd4\u5728\u5927\u8857\u4e0a\u78b0\u5230\u7684\u6982\u7387\u8981\u9ad8\u554a \u5c31\u4e0d\u5728\u8fd9\u513f\u6c9f\u901a\u611f\u60c5\u4e86\nAlso, to simply make it easier for @taolinke -- if the change you made is pushed to your own public fork of the nanomsg repository, a nanomsg repository owner will be able to cherry-pick your work with your permission (maintaining your attribution to the commit). The goal here is to lower the barrier for upgrades to the library, and not let git or GitHub be a barrier to those upgrades. I'd be interested to evaluate this change for my own branch, even if it doesn't make it into the trunk.\n. I would love to see this ability fleshed-out. See: http://www.freelists.org/post/nanomsg/Asynchronous-raw-sockets-in-nanomsg\nMy understanding here for this feature is adding the ability to both REQ and REP socket topologies where they maintain a table (trie? hash table?) of their outstanding requests. This would supersede the current behavior of only allowing one at a time per socket, and effectively cancelling in-flight requests if a new request is generated before the response arrives.\nSuch behavior is only currently possible by using RAW sockets, and doing the bookkeeping at the application layer. This new feature would bake-in the ability to the library.\n. > As currently Req/Rep is not working for me when one end is in C++ and the other in Go\nWould you open a new issue? This is likely unrelated, but an important thing to track. thanks!\n. Based on the abort being thrown on line 306, this appears to be an older version of libnanomsg. 1) We should look into getting the Python language bindings up to date, and 2) see if we can't upgrade the assertion helper macros (e.g., https://github.com/nanomsg/nanomsg/blob/master/src/utils/err.h#L48-L49) to include the libnanomsg library version.\n@lucasb-eyer, can you confirm which Python binding you're using, so we can see about bringing it up to date with libnanomsg? Thank you!\n. > Moving to CMAKE exclusively won't break compiling for iOS, will it?\nI will be helping upgrade to the CMake build system, but I'm not tooled up to test iOS. Would you help validate it does go smoothly once we get it into mainline?\n. Even though this issue describes intended behavior, it is one behavior that I would also like to see changed. We should keep this issue open, rather than closing it as \"works as intended\".\nI understand the rationale of the current behavior -- it's in line with the nature of the asynchronous try and retry to bind -- but it might be worthwhile to treat the very first bind as \"special\", and perform logic within nn_bind() on basic sanity checks such as this issue. I might even lean so far as wanting to block within nn_bind() until the first bind is successful (or providing a new such function, such as nn_bind_synchronous()), after which point the existing behavior of nn_bind() (and nn_connect()) continues.\n. Another welcome side effect of this would be the ease of binding to an ephemeral port, which has so far been another explicit non-goal of nanomsg. \nThe main rationale of this being a non-goal, as I understand, is that distributed service discovery is more challenging, if not impossible. This rationale is valid for many application domains, but I work in at least one domain -- embedded software -- where ephemeral ports would solve some actual pain points. Sure, ephemeral ports are not directly related to the discussion of this issue ... but a synchronous bind is perhaps the only major technical gate for a sane ephemeral port support.\n. > provided you have an out-of-band way to get information about the service address\nExactly. This constraint can hold well in embedded system design, and even turns out to be more desirable oftentimes (that's just a personal contention), compared to, say, the application space of physically distributed IP networks and the internet.\n\nhaving a hard time understanding the use case for an asynchronous nn_bind\n\nAfter a brief research, one error that bind(2) returns synchronously that libnanomsg might eventually overcome with retries is ENOMEM\nBut that's the type of situation where libnanomsg is probably not going to end up being successful anyway ... it'd be better not to queue up a retry. The application is sick, and libnanomsg retrying is only going to make things worse.\nThe other situation that could be \"fixed\" after retrying is the one reported in this issue -- EADDRINUSE.\nYet, this is the type of error that most likely is an application design flaw, where libnanomsg would serve the application developer better to throw an error.\nMost other errors for bind(2) are synchronous errors with parameter problems -- meaning, passing the same parameters will throw the same errors, where it would have been better to fail with error on the first such try.\nSo ... I think I agree, it makes sense for nn_bind() to be unconditionally synchronous.\nThat said, we'd need to thoroughly research whether name resolution (or other things) provide value for nn_bind() being async.\nAnd to stress: these considerations are only for nn_bind() only, not nn_connect(), since preconditions on these endpoint roles are not symmetrical.\n. Another positive side-effect of a synchronous bind could be, ironically, better performance: https://github.com/nanomsg/nanomsg/blob/master/tests/tcp.c#L214-L215\n. I support the proposal by @gdamore as BDFL and would likely ramp up again as a contributor if this happened.\n. This is a legitimate reason to remove a legitimate feature. It's not that the feature is useless or unused; it's that it's relative value, compared to the relative complexity/dependency it adds, combined with the fact that it would need more work to be more generally useful (e.g., tunable publishing period), makes it better to remove for now.\n. @shiva, would you be interested to look into this once we get the main CMake work mainlined?\n. Looks like these few follow-on commits are getting Travis CI to build.\nAction items:\n1. @gdamore -- turn on AppVeyor to obey appveyor.yml instead of dashboard settings\n2. @JackDunaway -- re-squash this PR -- ideally properly attributing commits by @shiva\n3. @shiva -- note this familiar failure: https://travis-ci.org/nanomsg/nanomsg/jobs/123621308#L264 and the \"fix\" the suppressed this issue: https://github.com/nanomsg/nanomsg/pull/636/commits/e9dc4e91e816a6062ac945e5cd46d4a793555e2e -- any ideas on a more sustainable fix?\n4. @gdamore -- we'll need to look into packaging and deployment on tagged commits to make sure everything works.\nI'm away for the rest of today, with limited availability chatting tomorrow (Sunday), but will be back looking into this ~40hrs from now on Monday.\n. @shiva -- if you work any more with this, begin work from this branch instead of the old one. Note though, that I'm going to try to re-do some squashes to preserve your attribution, meaning this branch will even be reset from where it current sits -- meaning any further work you do may get similarly shuffled around :-)\n. I am currently investigating why the AppVeyor builds are failing: https://ci.appveyor.com/project/gdamore/nanomsg/build/0.8.392\nIt appears that Travis CI building on Ubuntu is healthy: https://travis-ci.org/nanomsg/nanomsg/builds/123624427\nAs part of this process, I will also turn on OS X builds on Travis CI. The goal is to get as much mileage on as many platforms as possible to flush out issues, since each environment is built each time a commit is added to a PR.\nAfter sussing out issues with what could be quite a few pushes to this branch, I'll then squash all commits into a cogent PR and close this one out.\n. > if that helps, I'm using this CMakeLists.txt on my own fork\nIt's particularly helpful! -- especially that you're able to build with CMake 2.8.7 instead of CMake 2.8.12!\nBeing able to lower this requirement would reduce setup time, since 2.8.7 is what ships with the default Travis CI environment. At some point during original development of this script, I recall introducing enough features to justify the upgrade to 2.8.12 from 2.8.7, but seeing what little effort you spent to drop back to 2.8.7 seems like the way to go.\nI'll be soon cherry picking and pushing updates ...\n. > CMake 3.4 is the latest, I believe.  Are there reasons we should be using the older 2.x series?\nBrief, glossed-over answer: yes.\n. Longer answer -- based on my last in-depth technical investigation, which is now a few months dated and always a moving target, it appeared the only contending options were:\n- CMake 2.8.7 - seems this is the latest-pegged \"stable\" version in trusty and LTS linux builds, including the Travis CI environment with Ubuntu 12.04 LTS: http://packages.ubuntu.com/precise/cmake\n- CMake 2.8.12 - most up to date CMake release in the 2.x line, notably including commands to more precisely specify target properties rather than directory properties \n- CMake 3.x - a moving target (seems to be updated quite often), and not particularly accessible within the Travis CI environment, especially because Travis CI does not allow sudo privilege for containerized builds.\nThe new piece of information I'm learning today from @Snaipe is that he's successfully been back at 2.8.7, which feels definitely worth investigating, since it lowers CI build time appreciably and removes script complexity.\nAt some point, it could be worth investigating ugprading to 3.x, but at this point, 2.8.7 makes the most sense (or, 2.8.12 if it turns out that requirement remains)\n. Beginning to study and remember the differences between CMake 2.8.7 and 2.8.12 -- I'm recalling some specific issues when a project such as nanomsg is included as a static library in a parent build, where the parent build uses add_subdirectory.\nThe issues dealt with the abilities to override and also to inherit properly target settings of such sub-projects from the main project, and hinges around these changes made by @Snaipe to support 2.8.7: https://github.com/Snaipe/nanomsg/commit/2a3dc72ed15e83e507835b70967833ea557f0077#diff-95e351a3805a1dafa85bf20b81d086e6L369\n@Snaipe or others -- does this sound familiar? Is it a technical reason why 2.8.12 would be a requirement over 2.8.7, where the patch linked above precludes behavior required by add_subdirectory? At the moment, I'm continuing the technical investigation, but asking in hopes of short-circuiting the investigation ...\n. Aha ... I can answer my own question here.\nThe limitations of add_definitions compared to target_compile_options indeed boils down to inheritance of values and being able to override from higher levels.\nHowever, in CMake versions prior to target_compile_options being available -- including 2.8.7 -- you can achieve the same behavior by providing one degree of indirection between variables set at a higher layer, and target properties set at the lower (nested project) layer.\nApparently, as I was working on developing the CMake script, this pattern incidentally emerged, with the addition of this line: https://github.com/nanomsg/nanomsg/pull/636/commits/a15356b79e47e0c6ff48ba08e4dff538c7750844#diff-af3b638bc2a3e6c650974192a53c7291R86\nThe variable NN_STATIC_LIB provides that one degree of indirection that may be set upstream in a parent CMakeLists.txt. This variable is then read later: https://github.com/nanomsg/nanomsg/pull/636/commits/a15356b79e47e0c6ff48ba08e4dff538c7750844#diff-95e351a3805a1dafa85bf20b81d086e6R355 which then applies the target compile option: https://github.com/nanomsg/nanomsg/pull/636/commits/a15356b79e47e0c6ff48ba08e4dff538c7750844#diff-95e351a3805a1dafa85bf20b81d086e6R357\nAnd here's the tricky bit. The variable passed in is called NN_STATIC_LIB, and the compile option is also called NN_STATIC_LIB, but they're not the same thing. One is a CMake variable; the other is a compiler flag.\nWhen initially developing this script, in my mind I must have been realizing that this compile option needed to change based on parent project logic, and must have been trying to set it in a more direct manner. But then this degree of indirection grew around it anyway, meaning 2.8.7 available functions would suffice. The \"public data\" of the nanomsg build script is the NN_STATIC_LIB option, which then controls the \"private data\" NN_STATIC_LIB compiler flag. A parent CMake script shouldn't setting \"private data\" directly.\ntl;dr -- I think 2.8.7 will work. 2.8.12 functions that \"felt like they were required\" aren't actually because of an incidental design pattern that grew up around them, and turned out to be a little cleaner anyway.\n. > Much appreciate the efforts here to go to 2.8.7!\nThanks! Good to hear validation it's worthwhile; I see the value also, and was excited to see @Snaipe had achieved this. Seems to be passing the smoke test so far.\n. Closing; this PR is superseded by #641.\n. Note related work where I am converging toward this same goal: https://github.com/nanomsg/nanomsg/pull/636/commits/bb2d45724bcdd5c75c098bd6e6d305da0acf2104\n. Though, it appears I should change https://github.com/nanomsg/nanomsg/pull/636/commits/bb2d45724bcdd5c75c098bd6e6d305da0acf2104#diff-af3b638bc2a3e6c650974192a53c7291R179 to uint_64, and also forgo actually exporting NN_HAVE_STDINT as a symbol, and instead throw a CMake error in case the compile check fails.\n. > punt on explicit checks for stdint.h or int64\nSee: https://github.com/nanomsg/nanomsg/pull/636/commits/95b664f66e89dfbcc99877d3132a54b420c69cf5\n. Before working on a fix for this ... hang tight for #636, since it deals in part with this \"special snowflake\"\n. Relevant commit: https://github.com/nanomsg/nanomsg/pull/636/commits/a15356b79e47e0c6ff48ba08e4dff538c7750844#diff-2051e1a7c073348e8ba0043ac9b5c77cL47\n. > CMake can generate a header file\nI'm somewhat opposed to this, having looked into that feature myself in the past.\nIt's kinda neat, but it's also a little too \"magical\". This may simply be a personal view, but I prefer to draw the line of build generation system and source code at symbols -- where automatically generated new source code raises more questions than it provides answers.\nThoughts? Open for new suggestions, but I'd tend to lean against header file generation.\n. I'll take a look at the four in WS and have a PR shortly ...\n. OK, it'll take a bit longer to fix this properly and understand the ramifications of the fix.\nNot because any of these particular fixes is difficult -- but because when I compile with Warning Level 3 /W3 (the default warning level) it returns 0 warnings and 0 errors, and with /W4 we get 225 warnings, and with /Wall that number shoots to 8930 warnings.\nI'm not exactly sure yet how/why this AppVeyor environment is configured to return 11 warnings, but issues such as this are a little lower priority for the time being.\n. @gdamore -- this PR is not perfect, but it incorporates most of the feedback today from yourself, @Snaipe, and @shiva.\nI say we go ahead and mainline as long as this passes the smoke test, which gives us all the opportunity to prune our disparate branches. Further, it'll enable targeted, documented changes, rather than trying to lump them all into a single \"switchover\".\nThat said ... I'll be hands-off for long enough for you to review and merge, so feel free to make edits!\n@gdamore -- the final bit is to update your AppVeyor console to point toward .appveyor.yml (notice the leading period)\n. > I want the CMake machinery to be as simple as we can make it, because the subset of people who work on this code who understand CMake is going to be much less than the set who grok the C preprocessor\nAgree with this mostly ... the only contention is when divergence between platforms becomes so pronounced that it's better to account for the differences within CMake -- as has been done here. But I'm 100% OK with refactoring those areas first, and then judge whether they are divergent enough to conditionally include within CMake.\nThe tipping point is this -- are the frequency and expanse of #ifdef's big enough within the codebase to make the codebase sufficiently unreadable? And is the pain great enough to warrant learning a small amount of CMake to alleviate the pain? It all depends, i guess.\n\ntake this PR and run with it myself, if thats ok with you?\n\nBy all means!! Let's get it mainlined. Ideally, create new commits on top of this that individually address each issue. All the squashing and continued divergence from mainline is what made this PR so inefficient in the first place.\n. PS -- AppVeyor is having a tough time with changes here. It's possibly due to the CFG being passed in (see: https://github.com/nanomsg/nanomsg/pull/641/files#diff-11c909939117928998b102a1fff7d363R6), and possibly due to the lack of VS_VERSION being passed as a variable (see last successful build from mainline, without new .appveyor.yml changes: https://ci.appveyor.com/project/gdamore/nanomsg/build/1.0.401)\nIt does not appear related to GENERATOR being passed in. Seems to be related to either CFG or VS_VERSION.\n. > frequency and expanse of #ifdef's\nHere's the strategy I'd be happy with.\nFirst, audit all preprocessor conditionals in all the codebase, and get it to where we feel it's pretty sustainable. This also means evaluating file boundaries (e.g., with the *.inc files) -- perhaps collapsing files into one, or in other cases splitting into more than one.\nNext, once we feel the preprocessor is about as good as it could be, evaluate if/where it makes sense to deal with any burdensome complexity at the CMake level.\nAs it stands  -- we can't make decisions on what CMake should or shouldn't do, because we've not taken the time to first pay down principal on tech debt accumulated over >4yr+ of development. Once the cruft is cleared, then it's worthwhile to revisit this conversation.\n. > AppVeyor is having a tough time with changes here\nI'm going to spend some time figuring out what is wrong here on a separate AppVeyor instance, unless you've already got it figured out @gdamore ... else, stay tuned ...\n. > load on appveyor\nI have suspected this also in the past -- but yesterday's performance was interesting.\nIt seemed to fail all the time on this particular branch for this PR -- but a commit to mainline passed.\nIs your account a Pro account that runs on the 2core VM? If so, the difference is explainable, assuming AppVeyor is running master branch on the Pro hardware, and PR branches on the lower-powered free-plan.\n. AppVeyor failures are likely due to a bug in CMakeLists.txt ... I'm troubleshooting this now ...\n. @Snaipe, good tip.\nAnd back to the failures here -- it's definitely a problem in the script itself -- the test executables are not properly linking to the nanomsg shared library. The failure mode on Windows manifests as a timeout, due to an unacknowledged dialog.\nI'm looking into the most sustainable solution here for setting up the binary outputs so that they link properly. It's interesting that this failure doesn't happen on Travis ... at this time, I suspect it's a difference in the behavior of the CMake versions (2.8.7 on Travis, and 3.5.0 on AppVeyor)\n. From that log:\nAssertion failed: 8 == NN_USOCK_STATE_ACTIVE (../src/aio/usock_posix.inc:461)\n/bin/bash: line 5: 13806 Aborted                 (core dumped) ${dir}$tst\nFAIL: tests/ipc_shutdown\n. This PR is turning out to be a landing pad for testing/previewing a few nits on the README.\n. Precisely; this PR is a placeholder/queue/discussion.\n. @gdamore, would you please review these instructions and then consider mainlining? Working toward eventual replacement of autotools with CMake, this step of updating the \"official\" instructions should come prior to removing autotools, yet after we've reached some level of success with CMake -- and I feel we've reached, or are at least very close to reaching the right level of success across many platforms. Thanks!\n. I have rebased this commit just to keep it up to date and ready to merge soon.\n. Perhaps nothing further, to be honest.\nThough, there's another issue we should consider that's related to this, and that's figuring a strategy for partitioning each of the CI builds based on environment.\nFor instance, Travis CI runs Ubuntu builds and OS X builds, yet has one badge on readme called \"Linux\". AppVeyor runs Win32 and x64, yet it's arguable even these should be separated into two badges.\n. I recall ironing out some of the same issues at one point, but ended up with a simpler solution using a single line with CMAKE_POSITION_INDEPENDENT_CODE: https://github.com/featherweight/ftw-kernel/blob/master/CMakeLists.txt#L31\nThoughts between this macro, versus explicitly specifying flags? I've not studied the differences recently or deeply enough to have an opinion on what's best here.\n. > CMAKE_POSITION_INDEPENDENT_CODE\nA very brief search suggests this macro may have been added in 2.8.9 (citation needed), and therefore is not compatible with our >=2.8.7 goal.\n. I'm ambivalent on casing based on CMake version with the polyfill. Is the complexity worth it? Perhaps. The question is what CMAKE_POSITION_INDEPENDENT_CODE actually buys us beyond this one compiler flag -fPIC, especially in terms of forward compatibility and CMake's ability to smooth over subtle platform/compiler differences. (I don't know the answer to this question)\nA new point of feedback while looking at the code again ... rather than setting CMAKE_C_FLAGS, would it be better to set compile flags with set_target_properties for the library target only?\n. > I'd argue in favor of using the CMAKE flag, and basically insist that folks who want that capability have to use \"modern\" cmake.\nThis seems incredibly reasonable. I like it the best of all the options so far, actually.\n\nThe 2.8.7 goal for cmake always felt really really arbitrary to me, and we're not going to be stuck there forever.\n\nIt's not arbitrary at all, from our perspective -- it's what Travis CI ships with out of the box, because it's what Ubuntu 12.04 LTS is using. OK, perhaps it's \"somewhat\" arbitrary for us to abide by this, but at least a BIG stake in the ground -- an important service provider in our CI infrastructure depends upon 2.8.7 as a least-common denominator.\nAnother not-terrible option is to re-introduce code that downloaded CMake 2.8.12 a pre-build step. The cost here is a few lines in .travis.yml, about +15sec per build, and another potential point of maintenance/failure.\n. > delivering official pre-packaged binaries (.DEB, .RPM, etc.) using cpack to build\nHearty +1. Further, this should be a gate before 1.0, and take precedence over the \"here's how to build from source\" instructions.\n. > We have not, for example, done any analysis of what\u2019s in centos or redhat, or suse\nArguably, we have indeed done the analysis -- by omission. Those environments are not represented in the officially-supported automated CI, therefore they aren't quite as big a stake in the ground. By not officially building these environments, that alone is a statement whether they should/shouldn't be a dominant driving force for dependencies such as CMake version.\nShould they be built? I'd love to see more environments added to the automated build; continuiing to expand in this manner has flushed many unique potential issues, given a widening variety of compilers and environments.\nHow easy is it to expand here? There's http://build.nanomsg.org/waterfall, which is as successful as its maintainers' maintenance (contrasted against, the outsourced maintenance of AppVeyor and Travis).\nSo, the analysis has been done, where 2.8.7 and 2.8.12 are neck-and-neck today, both appreciably above 3.x -- but as you mention, time elapses, and it's a moving target.\n. > Here\u2019s the status of cmake in ubuntu: https://launchpad.net/ubuntu/+source/cmake\nVery true ... but again, the limitation here is Travis CI. Can we install that package without sudo in a Travis environment today? Perhaps tomorrow; but today, we can't. (Would love to be proven otherwise!)\n. One thing that should definitely happen -- if the build fails, we should skip the ctest (and everything else downstream). It's not working like this right now -- e.g., https://travis-ci.org/nanomsg/nanomsg/jobs/124774212#L384\n. && chaining might be the way to go -- here's one precedent: https://github.com/travis-ci/travis-ci/issues/1066\nSuch syntax doesn't look too bad:\n# Perform CMake backend generation, build, and test\n   - cmake -DCMAKE_BUILD_TYPE=${CONFIGURATION} ${CMAKE_OPTS} .. &&\n     cmake --build . -- -j4 &&\n     ctest --output-on-failure -C Debug -j4 ${CTEST_OPTS}\n. Cannot stress the value introduced with this commit. Introducing chaos to these tests should flush out all manners of parallel/concurrency issues.\nDoes CMake also offer the opportunity to specify number of iterations per test? And also, does it offer ability to randomize test order?\n. Closing this PR for now; superseded by https://github.com/nanomsg/nanomsg/commit/2bd0fa1a1ab0cd9fa357d72d7fa90cc57fabe03c\n. Closing this PR; work has been mainlined as separate, squashed commits https://github.com/nanomsg/nanomsg/commit/6e14fe9af0622a88312eeb2a40d578e19f73cf6c and https://github.com/nanomsg/nanomsg/commit/b5224d57d46414d789045a6c0e5dc2bb7da11351\n. The way this was effectively handled previously was using autotools: https://github.com/nanomsg/nanomsg/blob/master/Makefile.am#L587\nAlthough the current behavior of leaving behind these artifacts is messy, there may not be any equivalent port from autotools to CMake.\nThat said, with CMake performing an out-of-source build, removing these and all other build/test artifacts is as simple as git clean -xfdn or rm -rf build from the project root.\nCan you think of any actionable fixes for this issue?\n. > I think the best defaults for a messaging system are to prefer latency over throughput\nAgree.\n. I've opened a ticket with AppVeyor: http://help.appveyor.com/discussions/problems/4569-the-target-_convertpdbfiles-listed-in-a-beforetargets-attribute-at-c-does-not-exist-in-the-project-and-will-be-ignored\n. > Is it always the same stat that fails\nNo -- I've seen it fail at least at https://github.com/nanomsg/nanomsg/blob/master/tests/stats.c#L45 also, which might need to be a separate issue, since they don't appear to be exactly the same root cause (unconfirmed)\n. Importantly, are you using the -j64 flag from the original comment? This is most oftentimes what it takes to repro. --repeat-until-fail 25 is also important\n. I like this idea a lot; but as discussed on Gitter, we may be able to get away with doing it unconditionally rather than needing an env var, since it's so cheap: https://gitter.im/nanomsg/nanomsg?at=573605ce64dbdadc7debd519\n. I agree (speaking for myself and business) to past/future contributions consolidated under a blanket copyright holder 'nanomsg authors' in the source files.\nWould the license itself remain in all source files? Or would it be removed as the top block comment, replaced by a reference to this new LICENSE?\n. The intent of this PR is to provide a preview of what uncrustify will do in order to apply the current coding standard (http://nanomsg.org/development-style.html) against the current state of the codebase.\nIt is a work in progress.\nTo preview:\n1. Install asciidoctor\n2. Ensure you're working with a fresh checkout; the next step is a destructive operation\n3. From the repository root, run ./uncrustify.sh\n4. Examine the visual diff of changes made\n5. Rinse/repeat\n. Neat! Thanks, @gdamore\n. I might have another type of repro scenario related to this.\nIt seems to be triggered when the REQ takes longer to reply than the REP timeout (e.g., if the REQ recv's a message, sleep(200), then reply, where the REP timeout is 100msec). A crash happens when trying to close the REQ socket with the following trace:\n```\n    ftw32.dll!nn_chunk_getptr(void * p) Line 211    C\n    ftw32.dll!nn_chunk_free(void * p) Line 150  C\n    ftw32.dll!nn_chunkref_term(nn_chunkref * self) Line 73  C\n    ftw32.dll!nn_req_term(nn_req * self) Line 110   C\n\nftw32.dll!nn_req_destroy(nn_sockbase * self) Line 130   C\n    ftw32.dll!nn_sock_shutdown(nn_fsm * self, int src, int type, void * srcptr) Line 916    C\n    ftw32.dll!nn_fsm_event_process(nn_fsm_event * self) Line 66 C\n    ftw32.dll!nn_ctx_leave(nn_ctx * self) Line 63   C\n    ftw32.dll!nn_worker_routine(void * arg) Line 204    C\n    ftw32.dll!nn_thread_main_routine(void * arg) Line 30    C\n```\n\n@Snaipe -- can you reproduce this anecdote, and do you think it's related to your issue here? I'm in early investigation right now, and will report back findings (perhaps in a new issue if it's a separate issue).\n. PR #778 might be a minimal repro scenario or it may be a new bug -- what do you think, @Snaipe?\n. Here's a typical stack trace of the crash itself:\n```\n\nreqrep.exe!nn_fsm_feed(nn_fsm * self=0xdddddddd, int src=0xdddddddd, int type=0xdddddddd, void * srcptr=0xdddddddd) Line 82 C\n    reqrep.exe!nn_fsm_event_process(nn_fsm_event * self=0x00e955d8) Line 77 C\n    reqrep.exe!nn_ctx_leave(nn_ctx * self=0x00e8aa10) Line 91   C\n    reqrep.exe!nn_ctx_leave(nn_ctx * self=0x00e8c3c8) Line 92   C\n    reqrep.exe!nn_worker_routine(void * arg=0x00b38220) Line 219    C\n    reqrep.exe!nn_thread_main_routine(void * arg=0x00b3822c) Line 30    C\n```\n\nand here's the parallel thread that's the source of the crash:\n```\n\nreqrep.exe!nn_sem_wait(nn_sem * self=0x00e8c618) Line 122   C\n    reqrep.exe!nn_sock_term(nn_sock * self=0x00e8c388) Line 216 C\n    reqrep.exe!nn_close(int s=0x00000001) Line 531  C\n    reqrep.exe!test_close_impl(char * file=0x00b15de0, int line=0x000000ba, int sock=0x00000001) Line 120   C\n    reqrep.exe!main(...) Line 186   C\n``\n. Are you able to repro as-submitted? If not, try increasingi` beyond 100 here: https://github.com/nanomsg/nanomsg/pull/778/files#diff-dd8deeacecfc1adc4bb20193085968acR177\n. The initial push passed on both Travis and AppVeyor, but I've restarted both.\n\nOn the first retry, here's the failure demonstrated on Travis with GCC on Ubuntu (link to Travis log):\n9/42 Test #11: reqrep ...........................***Exception: Other  0.23 sec\n/home/travis/build/nanomsg/nanomsg/build/libnanomsg.so.5.0.0(+0x2f30c)[0x7f5c6460c30c]\n/home/travis/build/nanomsg/nanomsg/build/libnanomsg.so.5.0.0(nn_fsm_feed+0x46)[0x7f5c645f366a]\n/home/travis/build/nanomsg/nanomsg/build/libnanomsg.so.5.0.0(nn_fsm_event_process+0x67)[0x7f5c645f3622]\n/home/travis/build/nanomsg/nanomsg/build/libnanomsg.so.5.0.0(nn_ctx_leave+0x11c)[0x7f5c645f34aa]\n/home/travis/build/nanomsg/nanomsg/build/libnanomsg.so.5.0.0(nn_ctx_leave+0x12f)[0x7f5c645f34bd]\n/home/travis/build/nanomsg/nanomsg/build/libnanomsg.so.5.0.0(+0x1b717)[0x7f5c645f8717]\n/home/travis/build/nanomsg/nanomsg/build/libnanomsg.so.5.0.0(+0x1e508)[0x7f5c645fb508]\n/lib/x86_64-linux-gnu/libpthread.so.0(+0x7e9a)[0x7f5c643c7e9a]\n/lib/x86_64-linux-gnu/libc.so.6(clone+0x6d)[0x7f5c640f536d]\nUnexpected state: state=7 source=27713 action=5 (/home/travis/build/nanomsg/nanomsg/src/transports/inproc/sinproc.c:486)\nMASSIVE thank you to @gdamore for the new stack trace feature; test output on failure is now useful!\nFor convenience, here is a search of this repository for 27713 which is definitely going to be useful debugging this issue: https://github.com/nanomsg/nanomsg/search?utf8=%E2%9C%93&q=27713\n. 15 builds later, restarted at arbitrary times throughout the day for the past few days to try to rule out cluster utilization skewing results, and still no repro on AppVeyor.\nI'm investigating another repro scenario that's more repeatable, and perhaps even deterministic.\n@gdamore, are you able to repro on your machine?\n. I've actually just today had time to debug this, and am narrowing in on a fix, once and for all. It is currently looking promising to solve the NN_QUEUE_NOTINQUEUE as well.\nThe key points seems to be:\n1. Enable nn_mutex to be recursive (hold more than one lock if nested in the same thread)\n2. Ensure nn_fsm_raiseto is only called with a lock on its destination ctx, and finally\n3. Ensure external events in the eventsto queue are handled while the owning socket remains locked.\nStay tuned ...\n. Perhaps, but it provides the ability to solve many bugs that still plague us.\nFor that reason, I've already changed the function prototype to be void nn_mutex_init (nn_mutex_t *self, int recursive) (it used to be void nn_mutex_init (nn_mutex_t *self)), where every callsite in the codebase to nn_mutex_init sets recursive=0 except for the mutex that protects ctx objects -- it can be recursive.\nI'm still in early testing, but plan to have some more concrete commits tomorrow. This PR will remain a sandbox for testing.\n. https://github.com/nanomsg/nanomsg/pull/778/commits/2102d0616aee38d5e4d1b711526518d1af65f112 is a new test reqrep_cancellation dedicated to this bug (rather than previously tacking on to the reqrep test). Here's a link to its first repro on Travis CI: https://travis-ci.org/nanomsg/nanomsg/jobs/142891644#L829\n. Hi @a4z, thank you kindly for the detailed write-up here, but this turns out to be not a bug. Rather, it's the inherent mismatch between the API version (1.0.0 currently) and ABI version (5.0.0 currently). That mismatch is a bit confusing, and even unfortunate, but correct.\nCheck out the link from the source code that explains a bit further: https://github.com/nanomsg/nanomsg/blob/b8ec7e9c684a18e3eb144d4e16fb5dc320e80895/src/nn.h#L57\n. Re-opening ... on the other hand, having just inspected more closely and even followed your download/build procedure (on OS X), I see the output is libnanomsg.1.0.0.dylib with symlink libnanomsg.5.0.0.dylib. This itself is probably incorrect -- I would expect the 5 to be the actual output, not 1.\n. @a4z, so for clarity, you're suggesting that ABI and API should track each other exactly?\nI'll mention @gdamore here for visibility, who has a broader understanding of packaging considerations across distros. If there's an action item here, we'll definitely want to fix it!\n. @Snaipe, your analysis matches my understanding as well. @a4z has uncovered a bug indeed, just the inverse of the original report.\nAs for compound ABI versioning -- the link from nn.h source code (copied here for convenience: http://www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html) makes a case for the rational of x.y.z versioning versus an ever-incrementing counter.\n. > there are criteria that needs to be satisfied if I package and use libraries, nanomsg does not fulfil this currently\nAha -- I see this truly as the important issue that needs to be resolved. nanomsg should be able to perform for you here in an expected manner. Preventing you (and others) from making progress based on a couple numbers (assuming we can do a better job with those numbers) is insane.\nAnother potential \"root problem\" is that ABI versioning was strictly maintained well during the long pre-release alpha cycle prior to 1.0.0. It's not a problem, per se, but it does introduce a fork from the simplification of tracking ABI to API version that may not be usual for existing libraries.\nI suggest allowing @gdamore to weigh in, and then move forward with a fix.\n. Thank you for the bug report here. Although WebSocket RFC 6455 does not specify the browser behavior you're seeing, it's definitely permissible as an inherited behavior from HTTP RFC 7230 3.2.2 dealing with comma-separated header fields.\nIt seems Firefox is combining Connection: keep-alive with Connection: Upgrade to form Connection: keep-alive, Upgrade. Which could just as well be Connection: Upgrade, keep-alive, meaning matching against a static string is not a good idea.\nHaving some familiarity with this part of the code, it seems that one sustainable solution is to upgrade nn_ws_validate_value to split tokens on commas (perhaps optionally, driven by a new parameter), looking for a single token match rather than a full-value match.\nMy only concern is to open this new parsing ability insofar as to fix what is clearly a bug, yet without letting potential new fuzz get past. For this reason, does it only make sense at this point to iterate the Connection header field for comma-separated values?\n. @gdamore, thanks for the ping. I will push a PR this week; stay tuned.\n. Seems that way. What would expected behavior be? Any integer <=-1 disables? Or only -1 disables, and <=-2 returns EINVAL? I don't have strong opinions, except to choose the lesser surprising option.\n. I might tend to accept anything as <=-1 as acceptable, then changing documentation to say \"any negative integer disables the limit\"\n. Agree. When seeing this feature, this is the first priority I considered -- setting a decently robust/secure default threshold. 1MB feels acceptable, but it could be argued up to ~10MB or so. 512MB is too high a default today in 2015 :-)\n. ~~Wait a minute... see comments above. It seems lines 317-321 should be deleted.~~\nStrike that. Reveiwer's mistake just looking on Github. I incorrectly thought this was a duplicate case in the same case structure.\n. Rather, here is an example of a conventional assert for nanomsg tests: https://github.com/nanomsg/nanomsg/blob/master/tests/tcp.c#L78-L80\n. This looks very cool! But seems to have snuck in on the wrong commit :-)\n. Part of the WebSocket spec as per RFC 6455: https://tools.ietf.org/html/rfc6455#section-5.5.2\n. Expanding; even though they are part of the official RFC 6455 spec, and even though they currently exist within libnanomsg, they should probably be encapsulated within the transport layer, rather than exposed to the application layer.\nBasically, their existence, like the Close Handshake, and also message types of either Binary or UTF-8, really throw a wrench into things for this library :-\\\n. @gdamore -- I notice your change here \"more sanely\" immediately fails the peer rather than queueing the action (which would have been fulfilled in line 494 above), but this code was originally developed in order to satisfy behavior of chunked transfers.\nThis behavior was evidenced when using the full Autobahn Test Suite.\nlibnanomsg of course never uses chunked transfers, but I was defensively coding against whether a browser (or user agent) might executively decide to chunk transfer from a javascript call that otherwise appeared like a single bulk transfer. At the time, there was no clear evidence whether browsers or user agents were granted the prerogative to make such a transformation based on app-level javascript.\n(In the same vein, that is why PING/PONG existed here -- it was not evident whether browsers would have the authority to PING their peer, without having been requested to do so from client-side javascript.)\nI don't have strong opinions right now, or even hard evidence to support one way or the other whether \"chunked\" could be chosen for us outside the will of either libnanomsg or a corresponding javascript implementation, but just wanted to share some design decisions.\n. typo -- \"outbound\"\n. I agree removing these websocket-specific exported helper methods. It's much better to set message type as socket-level option :-)\n. If the UTF-8 is invalid, should this be EINVAL or even EPROTO or similar? EAGAIN and ETIMEDOUT don't make sense at all.\n. What you're saying does not sound wrong ...\n... but what I can say is that at the time, when developing this part that feels/looks wonky compared to your edit, it was done for a reason.\nNow, I cannot say if that reason was a good reason, or even if it was then, is now still a good reason -- but it was definitely to address some clever corner-case that the Autobahn fuzzer had concocted.\nOr maybe, it was to address a deficiency in the sync/async send/recv capabilities of libnanomsg vs requirements here ... I can't quite recall ... this was almost a year ago, and I'll do everything I can to mentally spool up again to match your renewed vigor here. :+1:\n(For context about the talk about the \"Autobahn\" tester, and also apparent \"lack\" of websocket testing in libnanomsg -- there exists a PR I created that provides a comprehensive RFC 6455 fuzzer and stress tester, except we debated whether this PR would be necessary for libnanomsg or not. The arguments against where 1) it introduces new dependencies, such as Python and Python packages, and 2) libnanomsg does not attempt to be, and specifically should not attempt to be, fully RFC 6455 compliant. I agree with these two arguments.)\n. > would be at the sender side\nThis is sender-side; line 69 above.\nThat said ... I now see that sws.c does not validate that an outbound message \"claimed\" to be UTF-8 is indeed UTF-8 -- it only validates incoming (untrusted) messages. This seems reasonable.\nMeaning, of course, it could not return EINVAL or EPROTO without validating the claim of the application. That said ... it's still not evident why EAGAIN or ETIMEDOUT would be the expected error code ...\n. A more direct way of talking about this modification -- did you change it in order to simplify what seemed \"wonky\" or \"wrong\", or was it specifically to address a characterized failure? Don't take this question as accusatory -- rather, it's highlighting my own immediate lack of ability to give positive, helpful review of this change, without yet having mentally spooled up again!\n. At the time this was developed, it was not explicitly stated whether a browser or user agent could unsolicitedly (from the perspective of app code) could PING. For this reason, I chose to defensively go ahead and aim for full RFC 6455 compliance, such that your-browser-du-jour would not tend to crash libnanomsg. Now, in 2015, it's still not any more clear. With hindsight, I would tend to criticize the existence of PING/PONG in RFC 6455, since it just kinda throws a monkey wrench into things.\n. > The recv is timing out due to no input\n~~the recv on which line? I just see a send on line 69.~~\nI now found it within the new test_drop. This is a nit/opinion, but perhaps that function could be renamed test_recv_fail_with_error? or similar? such function/macro could be useful in making many tests more concise.\n(my misunderstanding is due to code reviews on github, where it's easier to overlook detail, rather than being in an IDE with richer context)\n. > got back a zero length frame which was NOT what should have happened\nAha. I think I hear where you're coming from now, and probably agree with what you did here.\nAs for the zero-length message -- the payload is zero length, but the message carried information in the CMSG header about the disconnected peer. Which was the application's way of detecting the peer's \"close handshake\", yet i think we've come to the agreement that the spirit of nanomsg should not reveal this to the application layer.\n. I like the semantic of drop in the context of ETIMEDOUT. Meaning, once the EAGAIN is replaced with ETIMEDOUT in this case, the expected error would not need to be passed as a parameter -- e.g., test_drop (sb);. A function along the lines of test_recv_fail_with_error() would also pass the expected error type\n. In a nutshell, if this went away, where did it go? Briefly scanning this changeset it seems straightforward (to me), but can you say in your own words the design decision here?\n. This feels like a significant change; briefly, describe design decision?\n. The terminology \"hold\" -- it's not necessarily bad, not necessarily wrong, but a new concept at least to this codebase. Let's consider if the word \"hold\" best fits, localizes well, etc ...\n. Describing to someone who would have zero previous knowledge; why is it necessary to \"hold\" a socket on line 569 when a \"global lock\" was acquired on line 568?\n. Lines 586 and 587 are duplicated?\nAlso, what does \"rele\" mean? Can this be expanded to its full meaning?\n. This conditinal could actually remain outside the lock, since it's a gross sanity check, yes?\n. FINI -- can this be expanded? For clarity.\n. Without having tested; what are your thoughts on how long this could block?\n. Same question; how long could this take? Is it denying service to other sockets in the meantime? (i.e., by holding the global mutex? or is the global mutex not held here?)\n. Feels \"right\" replacing this line!\n. +1 for attention to detail on the style guide for nanomsg\n. There's not much the compiler can do for us here, going on pure C convention with no typedefs, but I find myself wondering ... \"what other cases are there??\"\nSaid another way ... it's hard to read this code and feel certain it's not wrong. It cannot explicitly tell me it's not wrong. Therefore, it's hard to reason whether it's correct.\n. Perhaps, explicitly enumerate all expected cases, then nn_unreachable assert on default case?\n. Is this for readability, or functionality? Either way, it looks good, but is a slight departure from the rest of the codebase.\n. It is OK to not do an atomic swap here? (i.e., is it properly MT mutexed?)\n. Using nn_sleep here is a known race condition that I wrote; it should be refactored with proper semaphore eventually.\n. Got it. I understand these terms now.\n. Assuming such gross failures on getsockopt() and setsockopt() are both 1) infrequent and 2) acceptable to take a few instructions longer to fail than failing early, consistency is more important; I'd vote to keep as you put it.\n. Sweet.\n. > Not sure it really helps readability\n100% agree, but it sorta combats unreadabilty. Where, combatting unreadability with nn_assert on a default case feels ... not awesome.\n. Atomic swap would be a helpful wrapper utility. We have atomic increment/decrement utility functions: https://github.com/nanomsg/nanomsg/blob/master/src/utils/atomic.c\n. This is another topic altogether :-\\ For now we'll let it be.\n. How about making this an atomic counter, using atomic increment/decrement? Is it possible that this alone could elimiate other mutexing? (probably not, but I have not thought through the problem; you're in the zone and could probably give a quick answer)\nCould we gain anything else from using atomic counter here, further than a pedantic semantic? Conversely, do there exist new potential bugs from not using atomic counter?\n. Seems legit. If the \"real protection\" you speak of could be decomposed into lower-level protections such as this, there's merit in considering it, but 1) that's too big a bite to take right now, and 2) it doesn't jump out as something that would be obviously successful (since it feels like the heavy-handedness of a blanket protection here is justified)\n. Sounds good.\n. Sounds good. Acquire/release feels a little more conventional, but if hold/release is kernel-speak then let's stick with it.\n. > Acquire/release feels a little more conventional\nWait a minute.... acquire/release is a different semantic than hold/release ... yes? They are not synonyms.\nAcquire/release is for mutexing; hold/release is for reference counting.\nDon't mind my comments on terminologies so much on this review; I need to just grok a bit better. At this point, it feels the code is correct and I'm needing to catch up.\n. I like this strategy.\nAnd on the record, I feel that the @sustrik design decision to put assert() all over the place was absolutely correct and has made for a better library. That's another topic ... but to tie into what you say, libnanomsg is definitely at the tipping point nearing v1.0 where assert() should no longer be sprinkled, but a run-time error code instead.\nThat said, I'd be in favor of a new error code -- say ENANOMSG or such -- whose existence in the field would be distinct from EBADF.\nThe semantic of ENANOMSG alerts nanomsg library devs that something is wrong and needs to be fixed, whereas EBADF alerts library users (application developers) that they have made a logic error.\nThis could tie in with work @TTimo pushed for long ago, turning nn_assert into a logger rather than a panic stop.\nThoughts?\n. Agree with all you say, and for clarification, I still delineate the important difference you mention between panic and logging.\nThe point I was trying to make is this -- on usage of nn_assert() currently in libnanomsg in fairly benign failure modes -- let's say a small, infrequent memory leak -- those instances would be changed to a new nn_log_failure() or such.\nFor true sanity checks, where insanity presents a grievous failure mode, nn_assert() keeps the exact same behavior as today, and remains in the codebase.\nIdeally, this is all moot, with the number of problems resolved in recent weeks!\n. Will try before fixing syntax in next commit on this PR ...\n. Tried increasing to 1000msec -- that did not help! This does not appear to be a problem with TCP slow start.\n. > We do something like this elsewhere\nfor reference: https://github.com/nanomsg/nanomsg/commit/10a567c89e564def7f5ae01f8c3bb1dab2acfed5#diff-f40426617d7b490658ad071cc19f5707R79\n. When if (self->p == INVALID_HANDLE_VALUE) is true, there's no pipe to clean up before return; seems fine as is.\n. That's an ultra-low barrier first step. Wrapped in #IFNDEF is a quick way to make it \"tunable\" externally if you wanted. Anything further, we could keep as a nice to have until someone contributes.\n. For reference, here's the nanomsg style guide for consistency: http://nanomsg.org/development-style.html\nStyle guide requires space before the open paren.\n. It's a moving target how/why this test failed, but I observed that sometimes it would pass in the 60-120sec range. It truly seems like some sort of resource contention based on limited AppVeyor systems, most likely due to the single-core.\nBasically, what we have is a test that really SLAMS the system, that works well with multiple cores, but seems to take a long, long time on single cores. Maybe the resolution here is to back off on the severity of the test. (??)\n. Agree.\n. agree; squashed into a new PR, or commit on top of this one? your choice\n. The other option here is to detect in the script whether an environment variable is set to APPVEYOR or similar (this is definitely possible) and give it more time. On an \"average\" desktop, I think we can drop this all the way to 10sec or even 5sec\n. Final note: whether or not this test passes seems correlated to the time of day and day of week the test is run. Anecdotally, it's more likely to pass during what are assumed to be \"off-peak\" hours for AppVeyor workload, and pretty much fails 100% of the time during \"busy\" hours.\n. > Do we seriously think this is that load dependent? I'm doubtful.\nFor clarity, I'm not correlating with the load of the machine, but rather the load of the AppVeyor cluster, which might conditionally provision more/less resources (this is conjecture). It's hard to draw any conclusions though -- even just 25days ago, the AppVeyor documentation went from 2cores to 1core: https://github.com/appveyor/website/commit/349b45d307045ecfed57382c9606895972f206a8\nI can repro on a Windows development VM when configuring that VM to launch with just 1 core. I have not been able to repro on a dev machine with 2+ cores.\nDo you have a dev environment in a VM you could configure to just 1 core to see if it's just a Windows problem? (I have OS X on metal, but nothing handy as a VM that could be throttled)\n. Reason is now empty. BTW -- it's fine to squash this final commit 7607653e3980b7736b145cf4abe9e4f969c61730 with 28b08fd9879edc81e40e21e9c36b16038614e207, but any further squashing 1) removes history and ability for others to cherry pick into branches and 2) makes it unecessarily hard as a contributor to then reconcile my own branches. The commits as exist make sense, where the unnecessary noise has been squashed already (compared to the first PR, which was simply used as a sandbox for its CI)\n. The break/return strategy is a little mixed here. Perhaps introduce int rc and just use breaks, with a single return at the end of the function?\nThat said ... not sure if setopt is a good idea yet, compared to say a build-time flag configuration option... thoughts?\n. This might be a multi-threading race; let's check into whether nn_glock_lock() needs to be held. Specifically -- in the if test, consider if the socket is destroyed in a parallel thread just after the test but before the next line it's guarding.\n. Going from memory here, but this might be the first use of an enum instead of a simple int in the nanomsg library here. (There exist merits for both design decisions, and it's worth considering the design decisions and precedents)\n. Again, not sure if a run-time function is better than compile-time configuration option ... do there exist use cases where it even makes sense to set at run-time?\n. > the global lock is already held\nIndeed.\n\nmake it so this function explicitely calls nn_glock_lock() then nn_glock_unlock()\n\nPerhaps not, if the semantic required here is to remain locked until the symmetric work is done also, or if there is additional initial work that needs to be done along with the call to this. That said; your mind is better wrapped around what is required right now; consider my comments at this point \"drive by\" considerations.\n\nword of warning that the global lock needs to be held\n\nComments alone are weak; thinking aloud, it would be perfect if there could be created a macro nn_assert_global_lock_held(); to capture this thought in code. That could be used a few different places, probably (notably ... pretty much anywhere the global lock is held, but especially in locations where the unlock does not immediately follow the lock in the same code block/scope)\n. Minor nit -- use nn_assert() rather than assert()\n. (Looks like this test will break on Windows compiling with MSVC)\n. This does not feel like a common use-case, which would make me lean toward the compile-time option. The cost of introducing this as a run-time option is increasing the surface area of the libnanomsg API, without a substantial ROI on the benefit.\nnn_setopt might be revisited if there existed more run-time options that added even more value to the existence of nn_setopt, but for now doesn't seem like the best option.\nIt is of course intentionally limiting to set this at compile time -- but trading flexibility for usability seems more desirable here.\n. A packaged distribution connotes some level of curation of \"best\" strategy. What would you say is the best strategy?\n. Is the lack of space between #define and NN_SYM in the source or just a rendering problem?\nAlso: generally not a fan of preprocessor breaking IDE's ability to \"Find All\" on a symbol, but it appears this one is localized and contained to this single source file, which makes it not too bad (if not, actually kinda nice). Thoughts? Seems reasonable here.\n. Yes, even without a compiler in front of me, this feels wonky; I think uint64_t is defined by <stdint.h> on Windows for MSVC compiler.\n. I don't disagree with getting stats one at a time, but to get ahead of potential question -- why did you decided that statistics can only be retrieved one at a time?\nWhat would the developer experience look like to be able to iterate through all known statistics (without needing to maintain a list of constants to the available stats)? Is there such a facility to discover all available statistics?\n. In the past, statistics have been pretty heavily marked as being for informational use only, and not intended to control program flow -- even within libnanomsg itself.\nIs this new public function, nn_get_statistic(), now officially provided in order to help steer application program flow?\nOr does it still come with the strong disclaimer \"for debugging purposes only\"?\nThe reason I ask, is this significantly affects the previous surface area of the libnanomsg API, exposing what used to be encapsulated, private data.\nI make no claim at this point whether it's good or bad, or whether the decision should be applied on a per-statistic basis.\nIt seems helpful, but those are the types of things that could later prove hurtful. At least, it's worth heavy consideration how this new ability is branded and documented.\n. Ah, the formatting issue could be this (now seeing an alternate rendering within my email client) -- is it a TAB instead SPACE?\nWhich brings up what should be a new issue -- I feel we should adopt a standard code linter with specified configuration of the linter, to lower the barrier as much as possible for contributions. A nit should never gate a contribution.\n. Win7 works perfectly fine even thru the latest-greatest MSVC 2015. Speaking as one stakeholder on this platform, if MSVC 2010 is the lowest common denominator for this particular feature (among perhaps others), I find it perfectly acceptable to make >=2010 the cutoff.\nWinXP -- I cannot speak for, because my business officially does not support this. It's >2yrs out of Microsoft's support at this point.\nFeel free to put out a call whether versions prior to MSVC 2010 should still be supported, but from my point of view, there should be no problem making >=2010 a requirement.\n. > for the express purpose of test cases .... But I wouldn't want to do any of that in production\nAh ... that's exactly what threw the flag when looking at the test case. A test case is app code ... yes? (Suppress -- or rather, cue -- religious debate ...)\nAgain, I'm still reserving judgment applying \"good\" or \"bad\" to each element of \"this particular set\" of statistics.\nThe obvious path right now is this: keep the API, since it's good, and mark it's usage as strictly informational and subject to change prior to further notice.\n. > I apologize for the coding style screw ups\nIt's a nit. Who cares? The linter (yet to be chosen); that's who.\n. Good to know; I'm taking a look through your CMake script now ...\n. I think you're correct, but recall adding this explicitly at some point in the past for a reason ... that reason may no longer hold ... for this reason, it's better to remove this line and see if it still works in all cases. It can be revisited and re-added later if it's a problem.\n. Legit.\n. I do not necessarily like the list of system checks either. Or compilers. Instead, I feel we should specifically check for features, which come and go from OS's and compilers.\nlibnanomsg should be concerned with symbols that define whether a feature exists ... not inferring whether that feature exists based on platform.\nNote that your comment here, and a few below, are simple artifacts of a straight port from autotools.\nIn this case, here is the relevant autotools portion: https://github.com/nanomsg/nanomsg/blob/master/configure.ac#L205-L231\n. Agree that we should try to move away from casing off of compiler rather than features. This section is a direct port from autotools: https://github.com/nanomsg/nanomsg/blob/master/configure.ac#L57-L141\n. A lot of this is ported directly from autotools, and could be stale. Let's try to get CMake mainlined today -- even along with cruft that is ported wholesale from autotools -- and then continue with the fine-tooth comb once mainlined.\nGood strategy?\n. > I think I recall seeing some tests were missing from the CMake build. Probably through oversight\nIt's possible, especially for tests that have been added in the past 6months. I'll do a quick audit now ...\n. The reason I chose this method is to prune other-platform source code from the backend-generated project file -- in my case this is a Visual Studio Solution. By omitting, e.g., worker_posix.inc, this means when I search for symbols, it doesn't return duplicates in non-relevant platforms -- only worker_win.inc was included and relevant. It makes the IDE experience better.\nThat said ... there's merit in understanding other platforms, even if it's not relevant to your own current platform. In which case, I would prefer a rearchitecture of the source code to be along the lines of this: https://github.com/nanomsg/nanomsg/blob/master/src/utils/clock.c#L71-L121\nEither way ... much of this entire CMake rearchitecture is a stepping stone to get from where we are to where we want to be, and in the meantime, it's likely to carry along some cruft that can then be hit later.\n. IANL :D\n. For clarity; this is working. I'm not sure exactly what you're saying here.\nI'm saying that as it's written here, it's a stepping stone from where we are to where we want to be, and it currently works with both CMake and the existing autotools. Once completely switching over to CMake, we can then begin to rearchitect source code and CMake together, without having to worry how it affects the now-gone autotools.\n. I see. That said, the number of source files touched in this commit is strictly limited to what's required based on what were discrepancies (bugs) in the previous autotools and CMake build, and changes this far don't really get into the type of refactoring we're talking about. I don't know if it would explicitly break from simply removing these changes from the commit, but it doesn't seem worth it to remove it.\n. All tests seem accounted for.\n. Agree; it's too verbose for the low amount of information it's used for. (as a comparison, printenv is as verbose, but pretty useful, and is on the borderline of keeping un-commented ... )\n. > it will be easy for folks to think they're modifying the file list for all platforms, and only be modifying them for one of them\nThis specifically is a weak argument, but I'm generally OK with removing these changes in favor of a later, more sustainable rearchitecture.\nKeep in mind though -- there are functional changes in the .h and .c files in this PR -- notably, the order of precedence into which #if a given system would fall. And the functional change within nn.h is simply to support a previously unsupported feature of CMake, and that is building nanomsg as a static lib on Windows.\n. I'm >80% sure that this -- and the question about the CMake test just above -- are a port of this code from autotools: https://github.com/nanomsg/nanomsg/blob/master/configure.ac#L237-L241\n. Definitely deferring to your expertise here; by all means, feel free to do as is fit.\n. addendum: This type of \"magic\" of expanding macros is the reason I became so fed up with autotools that I decided to invest fully into CMake. But now, seeing such \"magic\" repeated in CMake, I'm 100% inclined to see it go away in favor of something more explicit, such as a real compiler or linker flag as you suggest. Especially, if it means avoiding parsing the esoterica of the developer mailing lists to understand fully what CMAKE_THREAD_LIBS_INIT even buys us.\nOn the other hand, I respect that the compiler and linker flags and combinations thereof are sometimes made of magic anyway, and if those gods require we must chant this incantation, then I understand that too. The value proposition of macros such as this is not needing to understand that magic.\nWhere do we draw the line of our own understanding of what is needed? That's your expertise I defer to.\n. @gdamore , I expect your commit to be the next on top of this PR -- would you fix this bug? Rather than BUILD_NANOCAT this line needs to be ENABLE_NANOCAT -- or, whatever we decide the name of this option should be over on this discussion on #591 \n. @Snaipe, @gdamore, @shiva what do you think about this fix?\nIt's to resolve a linking problem on Windows that does not occur on *NIX systems. This bug is what has been causing AppVeyor to timeout and fail in all the tests on this PR.\nPresumably, this bug is manifested from a bad interaction between add_subdirectory for src/CMakeScripts.txt and this output behavior unique to MSVC: http://stackoverflow.com/questions/7747857/in-cmake-how-do-i-work-around-the-debug-and-release-directories-visual-studio-2\nIt solves the problem by dumping the output nanomsg.dll (or nanomsg.lib for static libs) into the binary location specified in the parent CMakeLists.txt -- which is incidentally where all the test executables end up.\nEven though this fix affects *NIX systems, I think it cleans up the structure of the artifacts a bit nicer (opinion), and for this reason didn't wrap this block in a if (MSVC) statement.\nThe other reason for doing it like this is to scope changes as narrowly as possible -- unlike the previous src/CMakeScripts.txt still currently in mainline that changed globally-scoped CMAKE_... variables -- https://github.com/nanomsg/nanomsg/blob/master/src/CMakeLists.txt#L24-L26\nThoughts on this patch? Any gotchas? Or a better way?\n\nAnd two semi-related ideas I had while solving this issue:\n1. collapse src/CMakeScripts.txt into CMakeLists.txt, obviating need for add_subdirectory and its scoping headaches (especially, in the bigger context of when nanomsg is a subproject of another project), or ...\n2. ... going the opposite direction, and creating two more CMakeLists.txt for both the tests and tools directory, both for overall consistency, and also to meet composability problems such as these head-on by setting precedent of best practices on how to do so.\nThoughts here?\n. It is, just not with this name. The question is whether it makes sense to keep the current flag strategy of a one-flag-per-tool basis, or to lump them all under a single TOOLS flag.\nIt's a bit moot right now, since there's just one tool -- but I now lean toward keeping per-tool enables rather than lumping.\n. Nice; this is the best of both worlds with a clean, simple syntax.\n. This raises a flag when reading the code; perhaps a comment, or even better nn_assert(), would help by explaining why an error condition results in a no-op?\n. Use of sudo here doesn't come with zero cost, falling back to standard infrastructure rather than what is reported/observed as faster container-based VM.\nIs it worth it? It seems so, especially with this new use of repeat-until-fail, which could take minutes.\nWe can configure some environments to respond quickly (<1min feedback is common in Travis on a Pull Request), and then allow additional environments configured as below to continue with more strenuous tests.\nA curiosity:\n3.5 downloaded: https://travis-ci.org/nanomsg/nanomsg/jobs/124985033#L168\n3.2 reported: https://travis-ci.org/nanomsg/nanomsg/jobs/124985033#L275\n. Wow, good call all around. I see even now that the overall test has been reported, even as these stress-testers are still cranking away. Best of all worlds.\n. Indentation? Or is this a rendering issue?\n. Should this be inside the conditional block starting at 221? In other words, don't even check if it's installed unless doc build is enabled. Then, if this is moved inside that block, a fatal error could be issued, rather than just a WARNING\n. With regards to above comment, this line could go away, as being the implicit \"success\" path ... (unless such debugging is helpful)\n. How much time does this add to the build? Probably not much, but it's worth monitoring.\n. Psuedocode, starting at line 221 below:\nIF NN_ENABLE_DOC\ncheck for asciidoctor\nif asciidoctor doesn't exist, fatal error\nELSEIF (not NN_ENABLE_DOC)\n// do nothing; no check for asciidoctor needed, since docs not requested\n. Yes; and @Snaipe, good call; I'm going to audit and see how many LocalFree need to be called ...\n. Good catch; will remove this too.\n. We need both variables for nn_getsockopt. Also, sizeof (void_ret_value) carries more semantic meaning that sizeof (void *) here.\n. > think the original author misinterpreted the doc for GetSecurityInfo and meant LocalFree(sd)\nGlad you caught this. I had drawn the same conclusion about intent, but provided the wrong fix; new commit coming soon ...\n. In this loop, each iteration obtains/releases the glock. Is this semantic correct, compared to holding the glock for the entirety of looping through all sockets?\n. That is, compared to the strategy just above this line, where the glock is held around the loop that zombifies all sockets.\n. PS -- I understand that if the glock needs to be held around the loop, then nn_close_impl would need to be refactored (to not glock), which would cascade these same considerations anywhere nn_close_impl is called.\n. Good to see the test tighten up here! If the previous pass criteria would switch between the two error codes, yet now it's just one, that seems like a step in a good direction!\n. It would be better to see not not-logic here -- and also, ideally a symbol that represents a feature, not a platform. Based on our current symbol definitions from CMake, would this be reasonable? Do we need more symbols? Or even another CMake option such as NN_ENABLE_RELEASE_PIPE  (that defaults to ON) ?\n. There must be a better way to constrain env and pass parameters to cmake and ctest; any ideas?\n. Yes, the intent was to be able to avoid duplicating the full env entry. Is it possible to introduce a new K/V pair into the matrix, say called stress_test: true or failure_allowed: true, that then becomes a definition for allow_failures? I've not used/studied Travis enough to know what options are available for specifying pattern matching for allow_failures.\n. (...searching...) This is two years outdated, but supports your current method: http://stackoverflow.com/a/20909996 Ideally, it's outdated and better now??\n. The per-job is exactly a path I was searching for. This makes the most sense, but it doesn't look like it exists right now.\nWhat about pre-processor expansion? For example, is there such a syntax where we could declare STRESSTEST=\"CONFIGURATION=Debug    CTEST_OPTS=\\\"--repeat-until-fail 25 --schedule-random\\\"\" at the top of the YML definition, and then define lines 57, 61, 66, and 67 above as $STRESSTEST? (I'm not such a pre-processor or expansion exists; just thinnking aloud)\n. To answer my own question -- it appears you've already figured out how to do this with the scripts with the & definition and * expansion -- yet I'm unable to find any documentation or similar uses of this trick on the web -- could the same concept be used for these env variables?\n. Is nn_init actually called anywhere right now? Or is this the TODO from line 323?\n. Is this valid? timeout is of type int.\n. It's not immediately clear what values <-1 would do. I believe these are prevented upstream, and if that's the case, it would make sense to insert an nn_assert (timeout == -1); here, perhaps with a comment why.\n. Agree here. I'll leave the format for now for conformance, then we can come back later and change them all in bulk.\n. Upstream logic in the currently-processing message. Not upstream in the sense of \"further up the chain\" on a block diagram of the system.\n. The Close Reason itself it optional, but if it exists, it MUST BE valid UTF-8. If it is not, RFC 6455 states that we (local socket) can immediately fail the connection without best-effort response. If it's well-formed, RFC 6455 states we must give a best-effort response. I see where you're coming from, but relaxing the spec here in this manner would be incorrect.\n. It's just RFC 6455 conformance. A well-behaved server (like this logic) should provide best-effort hints as to why it's unexpectedly closing a connection when it does, based on the malconformance mode of the client.\n. IIRC, it's something that pedantic compilers prefer; either way, it doesn't hurt to be explicit. Do you have strong opionions otherwise? Else, we'll keep it for now.\n. Good suggestion; will change.\n. Even further, this test needs the full-blown upgrade made by @Snaipe to dynamically retrieve its port. (This test predates that upgrade.) Stay tuned ...\n. Will change.\n. No, since a best-effort response is still given for all other failure modes. It's a paltry effort, but it tries at least once prior to closing the connection.\n. Also -- it's very helpful to see how all this nanomsg websocket code interacts with the Autobahn Test Suite. It's simple to run A/B tests on question about behavior like this one, since it does an excellent job of probing all corner cases.\n. That's much nicer! Also, I learned something new.\n. It's definitely wrong; it's not a good fix, but a placeholder for something that needs to be further investigated. The compiler warned of an unused assignment to rc here -- and for kevent, we don't even expect rc == 0\n. This follows the precedent set by all other functions in this file. I believe it's some artifact of how the macros are called, not these functions themselves.\n. Example of precedent: https://github.com/nanomsg/nanomsg/pull/696/files/cdcb73a7dbebfaf9bb98190baef4372df1720937#diff-650a958e586e7f65e22e0174b4bac596R186\n. Look again -- it's lst->to_free that needs the assert because it's indexed with [lst->to_free_num-1]\n. This doesn't quite work, because the thing we must guarantee is that lst is indeed non-NULL, yet it's calculated from two other function parameters.\n. Not quite enough to constrain -- see: https://github.com/nanomsg/nanomsg/pull/696/files#r62933992\n. How about just adding nn_assert (lst && lst->items);? I agree the logic change obfuscates.\n. @gdamore This looks like it may have been important at one time, but it's dead code now. I've tried to guess its intended meaning, but can't figure out anything it should obviously be. Shall we move forward with removing it?\nAsked another way, is this orphaned code that should be removed, or an unfinished thought that should be finished?\n. Good catch; even if doesn't fix issue, this is a good change to keep.\n. I cannot say with certainty, but my understanding is that this is MSVC-specific, and therefore tightening works in our favor.\nMy understanding is that MinGW64 would export all symbols; I'm not sure about Borland.\nIn this regard, MinGW64 correctness would be improved by this move (I have not confirmed this)\nThe rationale is to tighten the definition as much as possible prior to 1.0, rather than being too gratuitous.\nAlso of note: the definition for NN_EXPORT has been incorrect for a long time for NN_STATIC_LIB on MSVC. It would have been broken altogether for users prior to https://github.com/nanomsg/nanomsg/commit/5b34eb6467975ff4c444e2f8e1267bf01aba4b36#diff-2051e1a7c073348e8ba0043ac9b5c77c, and that commit was not even exactly correct (even though, it \"worked\")\n. Thank you for chiming in! My assumptions were incorrect. I'll revert back to using _WIN32\n. It's not particularly obvious why this fixes the issue; the reason is because the definition is applied prior to adding tests/tools. The reason it didn't work properly before is because this defintion only applied to the src directory -- meaning, effective only the library itself, but none of the companion executables within this project.\n. I agree removing these new symbols.\n. yes might work, but the nominal values are OFF or ON for options: https://cmake.org/cmake/help/v2.8.7/cmake.html#command:option\nSo, it might be limiting to anyone who has used non-standard boolean values, but the key here is that we're not boolean anymore -- it's an enumerated set of values.\nThe failure mode for such case mutating forward is fail-safe by throwing a fatal error with a hint.\n. ",
    "lalebarde": "Some progress here ? I have the same problem.\nI think it comes from that in configure.ac, you have: CC=\"$PTHREAD_CC\" line 234, while you need to redefine the environment variable CC (if you use cross compilation as I do):\nCC=i686-pc-mingw32-gcc ./autogen.sh\n./configure --host=i686-pc-mingw32\nSo, I assume the environment variable masks configure.ac redefinition which leads to:\nconfigure: error: No signaling supported\nI don't know how to workaround this. I don't know if I am doing something wrong (autotools are a kind of magic for me), or if configure.ac is not compatible with cross compilation or MinGW.\n. After some investigations, it looks like pthreads does not come into MinGW by default. Here is a link how to include it in your cross compiling chain. Other interesting links: Pthreads-win32, POSIX_Threads\n. pthreads-win32 added, but I don't know how to fix the autotools configuration files (may be configure.ac) for it. I have posted on stackoverflow for it.\n. ",
    "jellysheep": "Hi, I managed to build nanomsg with mingw-w64 toolchain and CMake, see [1] for patches and Arch Linux build script.\n[1] https://github.com/jellysheep/pkgbuilds/tree/master/mingw-w64-nanomsg-git\n. I think @sustrik already gave his opinion on this topic as he states here:\n\nThere's only one inline function and I think we should make it non-inlined and move it to the library.\nWould you like to do that?\n\nBut of course I don't know if he agrees with the patch.\nNevertheless a workaround is as easy as this:\n``` c\nif !defined STDC_VERSION || STDC_VERSION < 199901L\n/* Define \"inline\" keyword for pre-C99 C standard. /\n  #define inline\nendif\n```\n. ",
    "dangerousHobo": "Along with adding -lanl, I also had to add -lpthread. This was just to get one of the tests to work (pipeline.c).\n. You can't bind to the same port twice, iirc.\n. The documentation for nn_recvmsg() and nn_recv() (and nn_send...) says errno will be set to ETIMEDOUT on a timeout. The line \"Individual socket types may define their own specific timeouts\" sounds like you can specify the length of time to wait before triggering the timeout per socket. It goes on to say \" If such timeout is hit THIS ERROR will be returned.\", which was not the case. Yes, I was getting EAGAIN while in blocking mode. Looking through the code there were a few sections that could return with EAGAIN (including the timeout section). So if I get EAGAIN, how would I know it was from a timeout without this change?\n. I've noticed the examples on that site have been out of date for awhile now. \nFrom the looks of it you need to include string.h in your pipeline.c file, and add -lrt when you build.\n. I'm also curious about this. As currently Req/Rep is not working for me when one end is in C++ and the other in Go. When digging into the issue I found the exported functions. Hoping some work is be done here that may resolve my issue.\n. Support for the accept4 syscall for ARM was added in 2.6.36. syscalls(2) reports support existing in 2.6.28 but this was apparently initial support. glibc version 2.10 or newer is required (not sure about musl or ulibc). The accept4 syscall didn't exist in FreeBSD till 10.0.\n. ",
    "vseryakov": "On Linux AMI compiling static lib libnanomsg.pc does not have -lanl but detects in and use getaddrinfo_a. .la file contains -lanl.\n. in libnanomsg.pc.in changing Libs: to this solved it but i only tested in static configuration\nLibs: -L${libdir} -lnanomsg @LIBS@\n. yes, please, thank you\n. Hi,\nI agree, but how often to bind may not be just a simple forever cycle, even for case like wi-fi, my app will monitor some OS specific interface and once i know it is avail i may try the bind again. The nice thing with the bind right now is that it will remove EP on fail, thus the socket will be in pristine state until the next bind.\ni am building http://backendjs.io project and using nanomsg a lot for the backend servers this is why i am for more flexible solution where i can control the sockets in order not to bring the server down, like unbind operation would be handy in the server environment, same as disconnect.\nthanks\n. right, how i could miss it, thanks\n. on other hand after looking into ctcp.c i can see it can be possible to make similar FSM for btcp socket and use the same reconnect_ivl machinery, i can give it a try if it is not in the works yet\n. i submitted a pull request for this feature. But without a way to know what is the current state of any EP or socket it only addresses the abort part, how to deal withit requires exposing last_errno for every EP, so i can poll if my socket is bound or not and do restart or other things depending on the application.\n. Hello,\nOf course, it is under MIT or any other license you see fit, thanks\n. Hi, do i need to do anything else? just checking\n. ok, i will take a look today, i did add some stats counters but will see if i missed some\n. it looks i have added currently supported counters , except bind errors no other defines exist for binding sockets.\n. How a monitoring system would know which process failed to bind? \nIn my case i am embedding nanomsg inside node.js processes, inside the process i have no way to know if bind succeeded or not, making a connection to check seems like to complicated instead of asking for the status in the process and exit or do something, i can just call nn_shutdown for that EP and keep the process running.\n At least this is what i thought about last_errno in the EP structure, it is not used and not exposed. nn_geterrno works similar to nn_shutdown. My thought was that if nanomsg is low level library, it should not enforce jut one way but give options how i can build the system on top of it, error reporting is very important for real life systems.\nAnyway, re-binding and geterrno are not related, can be applied separately or not at all, it is up to you.\nThanks\n. can it be that messages arrive in different order?\n. yes, this is expected, bind is done in the background and it will keep trying forever, no way right now to know if it failed or not, there was a proposal to export errno function for an endpoint but it never got through\n. oops, sorry, i reused the whole repo which i used to keep track of the upstream project, will do\n. No problem, i have several more enhancements in my queue, i am building a backend system in node.js and use nanomsg for messaging, cache.... \n. during rebase/squash i messed up my local git, so recreating new pull request\n. Good point about the nn_close, this needs to be handled but i would have this merged first, then would work on ipc transport and deal with reconnect/shutdown, so we do not have multiple features/fixes in one PR.\n. This PR only about TCP case, let's not mix even if they are similar in logic. if TCP transport works fine on Windows i think this Pr can be merged.\n. can you paste the errors here please, i do have win vm but it will take some time top make it work and compile nn, maybe i can figure out the error remotely, tnx\n. just one more thing befor ei will jump into spawning win vm, can you print nn_geterror before the asserts to see the actual values. also, can you increase the sleep to a second or more to see if this is not a test race condition, i am pretty sure nn_errno and etc works the same way and i am not dealing with the errno directly. Thank you\n. the timeouts i chose completely out of the blue, because bind is happening in the background this behavior is normal. i will update the test. \n. ",
    "blutack": "I hereby state that this patch is submitted under the MIT license.\nIf it's worth adding to AUTHORS for such a trivial fix, could you pop it under Gareth Roberts, blutack at gmail please?\n. You're welcome. Nanomsg is fantastic.\n. ",
    "hnlq715": "You're absolutely right, there is something binding 5555. Everything goes well after I killed this process :)\nroot@ubuntu ~liqi/zmqrpc (master\u25cf)$ lsof |grep 5555\nexample_s 17875       root   40u     IPv4            9960679      0t0        TCP *:5555 (LISTEN)\n. This is quite considerate. I'm not sure if binding on port 0 would be acceptable, maybe we can just check if there is something binding 5555 before testing this case, and just give an warning?\n. ",
    "balboah": "I'll give it another stab this weekend.\nDo you have any other ideas of if it's related to concurrent routines\ncalling it at the same time or if the program is about to stop abruptly?\nMaybe the go bindings does something extra.\nOn Mar 18, 2014 8:21 AM, \"sustrik\" notifications@github.com wrote:\n\nI've done some more experiments and I haven't been able to reproduce.\nExact sequence of subscribes and unsubscribes would be really helpful.\n\nReply to this email directly or view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/220#issuecomment-37905402\n.\n. At least it only happened when spamming unsub/subscribe in a fast pace\nOn Mar 18, 2014 8:32 AM, \"Johnny Bergstr\u00f6m\" johnny@joonix.se wrote:\nI'll give it another stab this weekend.\nDo you have any other ideas of if it's related to concurrent routines\ncalling it at the same time or if the program is about to stop abruptly?\nMaybe the go bindings does something extra.\nOn Mar 18, 2014 8:21 AM, \"sustrik\" notifications@github.com wrote:\n\nI've done some more experiments and I haven't been able to reproduce.\nExact sequence of subscribes and unsubscribes would be really helpful.\n\nReply to this email directly or view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/220#issuecomment-37905402\n.\n. Ok.\n\n\nThe reason I ask is because it only triggered when I did 8 or more\nconcurrent requests. I didn't manage to get a problem with only one.\nBut I'll try to make a recording of the steps later this week.\nOn Mar 18, 2014 8:41 AM, \"sustrik\" notifications@github.com wrote:\n\nThis is a bug in the core library and has nothing to do with the bindings.\nAlso, it's a bug in a fully deterministic component (patricia trie\nimplementation) guarded by a mutex, so there should be no concurrency\nissues.\n\nReply to this email directly or view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/220#issuecomment-37906356\n.\n. Ok this sequence will make it crash, here is a small tool for reading the log and triggering the problem and the log file itself can be found here\n\n``` Go\npackage main\nimport (\n    \"bufio\"\n    \"flag\"\n    \"github.com/op/go-nanomsg\"\n    \"log\"\n    \"os\"\n    \"strings\"\n)\nvar logfile = flag.String(\"logfile\", \"pubsub.log\", \"Path to logfile\")\nfunc main() {\n    flag.Parse()\nsubs, err := nanomsg.NewSubSocket()\nif err != nil {\n    log.Fatal(err)\n}\nif _, err := subs.Bind(\"inproc://b\"); err != nil {\n    log.Fatal(err)\n}\nfd, err := os.Open(*logfile)\nif err != nil {\n    log.Fatal(err)\n}\n\nbuf := bufio.NewReader(fd)\nlog.Println(\"running subscribe/unsubscribe loop...\")\nfor {\n    s, err := buf.ReadString('\\n')\n    if err != nil {\n        log.Fatal(err)\n    }\n    parts := strings.Split(s, \" \")\n\n    switch parts[0] {\n    case \"subscribe\":\n        if err := subs.Subscribe(parts[1]); err != nil {\n            log.Fatal(err)\n        }\n        log.Println(\"Subscribed\", parts[1])\n    case \"unsubscribe\":\n        if err := subs.Unsubscribe(parts[1]); err != nil {\n            log.Fatal(err)\n        }\n        log.Println(\"Unsubscribed\", parts[1])\n    }\n}\n\n}\n```\nExecute with: go run test.go -logfile pubsub.log\n. awesome :+1: \n. ",
    "pipul": "yes, this patch is submitted under MIT/X11 license, how i state it? just like this?\n. Dong Fang yp.fangdong@gmail.com\n. i think this is a good design, and i may use this functionality in the future\n. Unless state otherwise, all my future patches for nanomsg project are\nlicensed under MIT license.\n. i do it, but seem has a little problem, why the date of .txt and .xml file not the same?\n. ",
    "mdre77": "Thanks!\n. I already looked through the code, to find a solution. But i was not able to find those data structures in the sources except for nn.h. Is there any information about how those headers are made up?\n. For Req-Rep i should receive the pipe identifiers followed by a request identifier in network (big) endian? What about the other protocols?\n. How about the following data strucures:\n```\ntypedef struct nn_cmsghdrItem\n{\n    size_t  cmsg_len;       // total size of the payload without level+type+len\n    int     cmsg_level;\n    int     cmsg_type;\n    char    cmsg_payload[0];    // is this portable? If not it should be left here as a comment.\n} nn_cmsghdrItem;\ntypedef struct nn_cmsghdr\n{\n    size_t              cmsg_numItems;    // number control message items\n    nn_cmsghdrItem**    cmsg_cmsgItems;   // array of control message items\n} nn_cmsghdr;\n```\nWith a proper set of methods for memory management  it could be quite usable?\nIs it worth here using chunks?\n. If wire format should be left unchanged, we have to somehow process the incoming memory chunk to something more structured. In this case it doesn't matter how it is presented to the user. That's why suggested the above. If we would use a chunk for cmsg_payload, it should fulfill the requirements: stable wire protocol, extendible user interface\n. Sure, take it as MIT. My name is Max Drechsler\n. Same here.. cross compiled on linux - without autotools.\nHere's the output for 64bit mingw (32bit mingw looks exactly the same)\nmdrechsler@ws-15:~/nanomsg-master> ./configure --host=x86_64-unknown-mingw32\nconfigure: loading site script /usr/share/site/x86_64-unknown-linux-gnu\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for x86_64-unknown-mingw32-strip... x86_64-unknown-mingw32-strip\nchecking for a thread-safe mkdir -p... /usr/bin/mkdir -p\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking how to create a ustar tar archive... gnutar\nchecking whether make supports nested variables... yes\nchecking build system type... x86_64-suse-linux-gnu\nchecking host system type... x86_64-unknown-mingw32\nchecking for a sed that does not truncate output... /usr/bin/sed\nchecking for gawk... (cached) gawk\nconfigure: nanomsg package version: Unknown\nconfigure: nanomsg ABI version: 1.0.1\nchecking for style of include used by make... GNU\nchecking for x86_64-unknown-mingw32-gcc... x86_64-unknown-mingw32-gcc\nchecking whether the C compiler works... yes\nchecking for C compiler default output file name... a.exe\nchecking for suffix of executables... .exe\nchecking whether we are cross compiling... yes\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether x86_64-unknown-mingw32-gcc accepts -g... yes\nchecking for x86_64-unknown-mingw32-gcc option to accept ISO C89... none needed\nchecking dependency style of x86_64-unknown-mingw32-gcc... gcc3\nchecking for x86_64-unknown-mingw32-gcc option to accept ISO C99... -std=gnu99\nchecking whether x86_64-unknown-mingw32-gcc -std=gnu99 and cc understand -c and -o together... yes\nchecking whether we are using ICC compiler... no\nchecking whether we are using Sun Studio compiler... no\nchecking whether we are using clang compiler... no\nchecking whether we are using HP aCC compiler... no\nchecking whether ln -s works... yes\nchecking for the pthreads library -lpthreads... no\nchecking whether pthreads work without any flags... no\nchecking whether pthreads work with -Kthread... no                                                                                                                                                            \nchecking whether pthreads work with -kthread... no                                                                                                                                                            \nchecking for the pthreads library -llthread... no                                                                                                                                                             \nchecking whether pthreads work with -pthread... no                                                                                                                                                            \nchecking whether pthreads work with -pthreads... no                                                                                                                                                           \nchecking whether pthreads work with -mt... no                                                                                                                                                                 \nchecking whether pthreads work with -mthreads... no                                                                                                                                                           \nchecking for the pthreads library -lpthread... no                                                                                                                                                             \nchecking whether pthreads work with --thread-safe... no                                                                                                                                                       \nchecking whether pthreads work with -mt... no                                                                                                                                                                 \nchecking for pthread-config... no                                                                                                                                                                             \nchecking how to run the C preprocessor... x86_64-unknown-mingw32-gcc -std=gnu99 -E                                                                                                                            \nchecking for grep that handles long lines and -e... /usr/bin/grep                                                                                                                                             \nchecking for egrep... /usr/bin/grep -E                                                                                                                                                                        \nchecking for ANSI C header files... yes                                                                                                                                                                       \nchecking for sys/types.h... yes                                                                                                                                                                               \nchecking for sys/stat.h... yes                                                                                                                                                                                \nchecking for stdlib.h... yes                                                                                                                                                                                  \nchecking for string.h... yes                                                                                                                                                                                  \nchecking for memory.h... yes                                                                                                                                                                                  \nchecking for strings.h... yes                                                                                                                                                                                 \nchecking for inttypes.h... yes                                                                                                                                                                                \nchecking for stdint.h... yes                                                                                                                                                                                  \nchecking for unistd.h... yes                                                                                                                                                                                  \nchecking netinet/in.h usability... no                                                                                                                                                                         \nchecking netinet/in.h presence... no                                                                                                                                                                          \nchecking for netinet/in.h... no\nchecking netdb.h usability... no\nchecking netdb.h presence... no\nchecking for netdb.h... no\nchecking arpa/inet.h usability... no\nchecking arpa/inet.h presence... no\nchecking for arpa/inet.h... no\nchecking for unistd.h... (cached) yes\nchecking sys/socket.h usability... no\nchecking sys/socket.h presence... no\nchecking for sys/socket.h... no\nchecking sys/ioctl.h usability... no\nchecking sys/ioctl.h presence... no\nchecking for sys/ioctl.h... no\nchecking for eventfd... no\nchecking for pipe... no\nchecking for pipe2... no\nchecking for gethrtime... no\nchecking for clock_gettime... no\nchecking for poll... no\nchecking for epoll_create... no\nchecking for kqueue... no\nchecking for getifaddrs... no\nchecking for accept4... no\nchecking for library containing getaddrinfo_a... no\nchecking for library containing socketpair... no\nchecking for library containing sem_wait... no\nconfigure: error: No signaling supported\n. I successfully tested both 64bit and 32bit windows. The only problem rises, if M$ changes the size of their socket type. We could compile time assert for the proper size:\neg:\nstatic int SOCKET_SIZE_ASSERT[ sizeof(int) == sizeof(SOCKET) ? 1 : -1 ];\nIf it matches all is fine - if not compilation will fail.\n. I guess the most portable way then should be to expose nn_fd. The last problem is that nn_getsockopt also returns that file descriptor using an integer parameter\n. I am still reading about it. Yes! It seems possible to cast safely to int. My tests proof that too.\nhttp://openssl.6102.n7.nabble.com/Sockets-windows-64-bit-td36169.html\n. Exposing nn_fd would actually only break windows x64 compatibility. For all other system 4 byte int would be used. For me either solution is fine ;)\n. Hi All, \nI got another one:\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:816)\nAre those state diagrams on the documentation page up to date?\n. ",
    "amosbird": "I've encountered this issue too. Is there any plan to amend this?\n. Great. Good to know this project is still active :)\n. This issue still exist in my Centos 6.7.\n\n. Yes.\n```\ncommit 8f9d80c73684caf3a08df41aaf8b91b96cfb06e3\nAuthor: Garrett D'Amore garrett@damore.org\nDate:   Mon Nov 16 16:43:15 2015 -0800\nfixes #212 Can't compile nanomsg with mingw on Windows\n\n```\n. @reqshark This is what I suppose to do: There will be a metadata manager that answers queries of which connection strings to be used. After a successful binding, a registration to the manager should be done in order to make socket online.\n. Ops. I misunderstood the ipc implementation. They seems to be Unix domain sockets. So is it possible to customize these sockets' permissions?\n. ",
    "kaerus": "no worries, thanks :)\n. ",
    "quinnj": "For someone new to the project with a mingw/msys2 setup, how would I go about building?\n. Hmmmm......it seemed to be working, but then I got \nIn file included from src/core/../aio/poller.h:33:0,\n                 from src/core/../aio/worker_posix.h:29,\n                 from src/core/../aio/worker.h:33,\n                 from src/core/../aio/ctx.h:29,\n                 from src/core/sock.h:29,\n                 from src/core/ep.c:27:\nsrc/core/../aio/poller_poll.h:23:18: fatal error: poll.h: No such file or direct\nory\n #include <poll.h>\n                  ^\ncompilation terminated.\nMakefile:2107: recipe for target 'src/core/libnanomsg_la-ep.lo' failed\nmake: *** [src/core/libnanomsg_la-ep.lo] Error 1\nIs it detecting my system correctly? Do I need to pass anything else to make?\n. Hmmmm.......I think it might be because I'm running mingw64? It indeed is not detecting my system correctly. Running ./configure --host mingw64 doesn't change anything, but ./configure --host mingw32 gets it to almost completely compile, with the following error at the end\n``\nIn file included from src/aio/worker.c:26:0:\nsrc/aio/worker_win.inc: In function 'nn_worker_routine':\nsrc/aio/worker_win.inc:176:13: warning: passing argument 1 of '__builtin_expect' makes integer from pointer without a cast [enabled by default]\n             if (nn_fast (entries [i].lpOverlapped)) {\n             ^\nsrc/aio/worker_win.inc:176:13: note: expected 'long int' but argument is of type 'LPOVERLAPPED'\ntools/nanocat.o: In functionnn_assert_errno':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:309: undefined reference to __imp_nn_strerror'\ntools/nanocat.o: In functionnn_sub_init':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:320: undefined reference to __imp_nn_setsockopt'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:327: undefined reference to__imp_nn_setsockopt'\ntools/nanocat.o: In function nn_set_recv_timeout':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:335: undefined reference to__imp_nn_setsockopt'\ntools/nanocat.o: In function nn_create_socket':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:346: undefined reference to__imp_nn_socket'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:352: undefined reference to __imp_nn_setsockopt'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:360: undefined reference to__imp_nn_setsockopt'\ntools/nanocat.o: In function nn_connect_socket':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:445: undefined reference to__imp_nn_bind'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:449: undefined reference to __imp_nn_connect'\ntools/nanocat.o: In functionnn_clock_init':\nC:\\Users\\karbarcca\\nanomsg/tools/../src/utils/clock.c:126: undefined reference to __imp_nn_send'\ntools/nanocat.o: In functionnn_recv_loop':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:489: undefined reference to __imp_nn_recv'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:503: undefined reference to__imp_nn_freemsg'\ntools/nanocat.o: In function nn_rw_loop':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:544: undefined reference to__imp_nn_recv'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:521: undefined reference to __imp_nn_send'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:558: undefined reference to__imp_nn_freemsg'\ntools/nanocat.o: In function nn_resp_loop':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:566: undefined reference to__imp_nn_recv'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:578: undefined reference to __imp_nn_freemsg'\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:579: undefined reference to__imp_nn_send'\ntools/nanocat.o: In function main':\nC:\\Users\\karbarcca\\nanomsg/tools/nanocat.c:643: undefined reference to__imp_nn_close'\ncollect2.exe: error: ld returned 1 exit status\nmake: *** [nanocat.exe] Error 1\n``\n. Sorry, I don't have any kind of MSVC setup or experience using it at all. I've always just used mingw64 for building anything.\n. Ah, I was thrown off by thenanocat.exeerrors, yes the library does indeed seem to build fine when I set--host ming32with configure.\nSo quick question, my use case will actually be wanting to calllibnanomsg.dll` as a shared library. Is there a make rule or configuration to get the .dll?\n. ",
    "achille-roussel": "http://lmgtfy.com/?q=mingw+poll\nhttp://stackoverflow.com/questions/1671827/poll-c-function-on-windows\nhttp://patches.libav.org/patch/837/\nI don\u2019t have a mingw platform to test it but it looks like poll is either unsupported or the include is available at a different path.\nThings you can try:\n- check if the poll.h file exists on your system, somewhere in the mingw directories\n- modify the \"#include \" directive to \u201c#include \u201d and see if it compiles, seems like some mingw version have provided poll.h under sys/poll.h (in the case that fixes the problem you could submit a patch checking for some macros that exist on mingw).\nLet us know how that goes for you.\nOn Jun 18, 2014, at 11:29 AM, Jacob Quinn notifications@github.com wrote:\n\nHmmmm......it seemed to be working, but then I got\nIn file included from src/core/../aio/poller.h:33:0,\n                 from src/core/../aio/worker_posix.h:29,\n                 from src/core/../aio/worker.h:33,\n                 from src/core/../aio/ctx.h:29,\n                 from src/core/sock.h:29,\n                 from src/core/ep.c:27:\nsrc/core/../aio/poller_poll.h:23:18: fatal error: poll.h: No such file or direct\nory\n #include \n                  ^\ncompilation terminated.\nMakefile:2107: recipe for target 'src/core/libnanomsg_la-ep.lo' failed\nmake: *** [src/core/libnanomsg_la-ep.lo] Error 1\nIs it detecting my system correctly? Do I need to pass anything else to make?\n\u2014\nReply to this email directly or view it on GitHub.\n. I removed the use of nn_atomic_inc/dec to check the reference counter value.\n. Hello Martin, would you have some time to review the last changes and discuss any other concerns you'd have about this patch?\n. Thanks, will go checkout the man page.\n. Hey Martin, did you forget to add the realloc man page before committing? I can't find it under doc/nn_reallocmsg.txt\n. Sorry about that.\n\nThis patch is indeed licensed under MIT/X11 license.\n. So you are using nn_sendmsg then doing nn_freemsg on the message you just sent?\nYou shouldn\u2019t be doing that, nn_sendmsg takes ownership of the message you sent and there\u2019s no need to free it in the program (nanomsg will take care of it).\nOr maybe I\u2019m misunderstanding your problem.\nOn Jul 10, 2014, at 4:59 AM, lcm337 notifications@github.com wrote:\n\nI'm getting assertions when using nn_freemsg. This patch creates the assert - freeing a sent message (is that correct to do?)\ndiff --git a/tests/zerocopy.c b/tests/zerocopy.c\nindex 447a2c0..a86f886 100644\n--- a/tests/zerocopy.c\n+++ b/tests/zerocopy.c\n@@ -181,6 +181,8 @@ void test_reallocmsg_pubsub ()\nnn_assert (rc == 0);\n/*  Release messages. */\nrc = nn_freemsg (p);\nerrno_assert (rc == 0); rc = nn_freemsg (p1); errno_assert (rc == 0); rc = nn_freemsg (p2);\nWith this assert on running the tests\nPASS: tests/symbol\nPASS: tests/separation\nAssertion failed: nn_getl ((uint8_t*) p - sizeof (uint32_t)) == NN_CHUNK_TAG (src/utils/chunk.c:211)\n/bin/bash: line 5: 6659 Aborted (core dumped) ${dir}$tst\nFAIL: tests/zerocopy\nPASS: tests/shutdown\nThanks!\n\u2014\nReply to this email directly or view it on GitHub.\n. You seem to be right, although as I'm reading the code it looks like this could be an issue only for debugging, the 'name' field in the nn_alloc_hdr could be overwritten with garbage, leading the debug message to output an unexpected value, and maybe crash the program.\n. \n",
    "jahrain": "I am using nn_sleep as a work around but nn_recv shouldn't hang if called prior to the tcp connection not being finished establishing. A function never returning makes it seem like a bug.\n. ",
    "panliang": "Developers can use nanomsg more easier. Simplify the src/CMakeLists.txt, no need add filename by hand.\n. If I use nanomsg as dynamic lib in my project, when i use nn_thread_init just like the tests/inproc_shutdown.c, linker error will be occur for \"can't find external symbol nn_thread_init ...\". Because the nn_thread_init is internal interface, so I must declare #include \"utils/thread.c\".That means the nanomsg library must install implement source files, not only the header files.\n. the nn_stopwatch_init, nn_sleep etc have the same situation. so i suggest to expose some important interface to user, such as about thread.\n. ok. i understood.\n. ",
    "Kosmokleaner": "Hi,\nI wasn't - but I can wait for the fix. Thx for the quick response.\nI started out with the first sample app here.\nhttp://tim.dysinger.net/posts/2013-09-16-getting-started-with-nanomsg.html\nand modified it to (.zip):\nhttp://tinyurl.com/pw3o59w\nRegarads\nMartin\nOn Wed, 07 May 2014 03:46:38 -0400, sustrik notifications@github.com\nwrote:\n\nAs for a quick fix, are you aware you can simply close the socket\ninstead of doing nn_shutdown()?\n\u00a1\u00aa\nReply to this email directly or view it on GitHub.\n\n\nUsing Opera's mail client: http://www.opera.com/mail/\n\nThis email is free from viruses and malware because avast! Antivirus protection is active.\nhttp://www.avast.com\n. ",
    "emijah": "Yes, I agree to release this patch under the MIT license.\n2014/05/30 22:45 \"sustrik\" notifications@github.com:\n\nCan you please state that the patch is submitted under MIT license?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/242#issuecomment-44651889.\n. You're very welcome.\n 2014/05/30 22:57 \"sustrik\" notifications@github.com:\nThanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/242#issuecomment-44653223.\n. \n",
    "lygstate": "I have such a intent, I am first asking is that possible?\n. I have a question udp is not reliable, should we implement it ad is\n2014\u5e747\u67088\u65e5 \u4e0a\u53488:57\u4e8e \"sustrik\" notifications@github.com\u5199\u9053\uff1a\n\nYes, there is. See the transport plugin API in transport.h header file.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/243#issuecomment-48260323.\n. @sustrik  I am looking for some support about implement IPC under windows,\nat the current time, there is a bad working version implemented, just all kinds of problem arising. I need to investigate what's happening inside.\n\nI need someone tell me about the working flow with usock_win.inc.\nHow does it creating those jobs.\n. That's good, I can re-see this issue by stress test, \n```\n    for (j = 0; j != 10000; ++j) {\n        for (i = 0; i != TEST2_THREAD_COUNT; ++i)\n            nn_thread_init (&threads [i], routine2, NULL);\n        active = TEST2_THREAD_COUNT;\n    while (active) {\n        (void) nn_send (sb, \"hello\", 5, NN_DONTWAIT);\n    }\n\n    for (i = 0; i != TEST2_THREAD_COUNT; ++i)\n        nn_thread_term (&threads [i]);\n}\n\n``\n. Permission denied [13](d:cinetwork-ipc-inprocnanomsgsrcutilsefd_win.inc:1\n91) does this means anything?\n. tcp_shutdown generate a new error reportingAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (....\\src\\core\n\\sock.c:816)`\nThe src is 0 and type is NN_PIPE_OUT\n```\n/*\n    Copyright (c) 2012 250bpm s.r.o.  All rights reserved.\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom\nthe Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\n*/\ninclude \"../src/nn.h\"\ninclude \"../src/pair.h\"\ninclude \"../src/pubsub.h\"\ninclude \"../src/pipeline.h\"\ninclude \"../src/tcp.h\"\ninclude \"testutil.h\"\ninclude \"../src/utils/attr.h\"\ninclude \"../src/utils/thread.c\"\n/  Stress test the TCP transport. /\ndefine THREAD_COUNT 100\ndefine TEST2_THREAD_COUNT 10\ndefine SOCKET_ADDRESS \"tcp://127.0.0.1:5557\"\nvolatile int active;\nstatic void routine (NN_UNUSED void *arg)\n{\n    int s;\ns = nn_socket (AF_SP, NN_SUB);\nif (s < 0 && nn_errno () == EMFILE)\n    return;\nerrno_assert (s >= 0);\ntest_connect (s, SOCKET_ADDRESS);\ntest_close (s);\n\n}\nstatic void routine2 (NN_UNUSED void *arg)\n{\n    int s;\n    int i;\ns = test_socket (AF_SP, NN_PULL);\n\nfor (i = 0; i < 10; ++i) {\n    test_connect (s, SOCKET_ADDRESS);\n}\n\nfor (i = 0; i < 10; ++i) {\n    test_recv (s, \"hello\");\n}\n\ntest_close (s);\nactive --;\n\n}\nint main ()\n{\n    int sb;\n    int i;\n    int j;\n    struct nn_thread threads [THREAD_COUNT];\n/*  Stress the shutdown algorithm. */\n\nsb = test_socket (AF_SP, NN_PUB);\ntest_bind (sb, SOCKET_ADDRESS);\n\nfor (j = 0; j != 10; ++j) {\n    for (i = 0; i != THREAD_COUNT; ++i)\n        nn_thread_init (&threads [i], routine, NULL);\n    for (i = 0; i != THREAD_COUNT; ++i)\n        nn_thread_term (&threads [i]);\n}\n\ntest_close (sb);\n\n/*  Test race condition of sending message while socket shutting down  */\nfor (int k = 0; k != 100; ++k) {\nsb = test_socket (AF_SP, NN_PUSH);\ntest_bind (sb, SOCKET_ADDRESS);\n\nfor (j = 0; j != 10; ++j) {\n    for (i = 0; i != TEST2_THREAD_COUNT; ++i)\n        nn_thread_init (&threads [i], routine2, NULL);\n    active = TEST2_THREAD_COUNT;\n\n    while (active) {\n        (void) nn_send (sb, \"hello\", 5, NN_DONTWAIT);\n    }\n\n    for (i = 0; i != TEST2_THREAD_COUNT; ++i)\n        nn_thread_term (&threads [i]);\n}\n\ntest_close (sb);\n}\nreturn 0;\n\n}\n```\n. Please don't close this issue, because it's not really fixed, but partially fixed, the demo stress test I attached doesn't appeared to be passed yet, thanks.\n. Yes, that's what I got.\n2014-05-31 2:20 GMT+08:00 Stan Mihai notifications@github.com:\n\nCan you describe the error you are getting ?\nWith the latest code I'm getting:\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED\n(....\\src\\core\\sock.c:816)\nI found it also mentioned at https://github.com/nanomsg/nanomsg/issues/234\nand looking into it now.\nOn 30 May 2014 19:19, sustrik notifications@github.com wrote:\n\nOK.\n\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/250#issuecomment-44669703.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/250#issuecomment-44682855.\n\n\n\u6b64\u81f4\n\u793c\n\u7f57\u52c7\u521a\nYours\n    sincerely,\nYonggang Luo\n. buildbot generate something alike:\n```\nPASS: tests/inproc_shutdown\nbash: line 5: 15917 Bus Error               (core dumped) ${dir}$tst\nFAIL: tests/ipc\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:818)\nbash: line 5: 15935 Abort                   (core dumped) ${dir}$tst\nFAIL: tests/ipc_shutdown\ncommand timed out: 1200 seconds without output, attempting to kill\nprocess killed by signal 9\nprogram finished with exit code -1\nelapsedTime=1353.174969\n```\n. OK. I license it.\n2014-05-30 23:21 GMT+08:00 sustrik notifications@github.com:\n\nCan you state that the patch is submitted under MIT license? I will also\nneed such statement from Timothee as his patches are part of this patchset.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/251#issuecomment-44663029.\n\n\n\u6b64\u81f4\n\u793c\n\u7f57\u52c7\u521a\nYours\n    sincerely,\nYonggang Luo\n. Wait a seconds, I need to do a rebase.\n. About scoket close, there is a place that after close the socket, doesn't specify it to INVALID_HANDLE, what's happening to it?\n```\n8bb47bace3b557e8b71647bca34cdaf31cc3d0b1\n src/aio/usock_win.inc | 23 +++++++++++++++--------\n 1 file changed, 15 insertions(+), 8 deletions(-)\ndiff --git a/src/aio/usock_win.inc b/src/aio/usock_win.inc\nindex b8e66a7..cafe6e7 100644\n--- a/src/aio/usock_win.inc\n+++ b/src/aio/usock_win.inc\n@@ -394,10 +394,21 @@ void nn_usock_recv (struct nn_usock self, void buf, size_t len)\n     wsa_assert (0);\n }\n+static void nn_usock_close(struct nn_usock self) {\n+    if (self->domain == AF_UNIX) {\n+        BOOL brc = CloseHandle(self->p);\n+        win_assert(brc);\n+    }\n+    else\n+    {\n+        int rc = closesocket(self->s);\n+        wsa_assert(rc == 0);\n+    }\n+}\n+\n static void nn_usock_shutdown (struct nn_fsm self, int src, int type,\n     void srcptr)\n {\n-    int rc;\n     struct nn_usock usock;\n usock = nn_cont (self, struct nn_usock, fsm);\n\n@@ -453,8 +464,7 @@ static void nn_usock_shutdown (struct nn_fsm self, int src, int type,\n               !nn_worker_op_isidle (&usock->out))\n             return;\n finish1:\n-        rc = closesocket (usock->s);\n-        wsa_assert (rc == 0);\n+        nn_usock_close(usock);\n finish2:\n         usock->state = NN_USOCK_STATE_IDLE;\n         nn_fsm_stopped (&usock->fsm, NN_USOCK_STOPPED);\n@@ -468,7 +478,6 @@ finish3:\n static void nn_usock_handler (struct nn_fsm self, int src, int type,\n     void srcptr)\n {\n-    int rc;\n     struct nn_usock usock;\n usock = nn_cont (self, struct nn_usock, fsm);\n\n@@ -564,8 +573,7 @@ static void nn_usock_handler (struct nn_fsm self, int src, int type,\n                     NN_USOCK_CONNECTED);\n                 return;\n             case NN_USOCK_ACTION_ERROR:\n-                rc = closesocket (usock->s);\n-                wsa_assert (rc == 0);\n+                nn_usock_close(usock);\n                 usock->s = INVALID_SOCKET;\n                 usock->state = NN_USOCK_STATE_DONE;\n                 nn_fsm_raise (&usock->fsm, &usock->event_error, NN_USOCK_ERROR);\n@@ -581,8 +589,7 @@ static void nn_usock_handler (struct nn_fsm self, int src, int type,\n                     NN_USOCK_CONNECTED);\n                 return;\n             case NN_WORKER_OP_ERROR:\n-                rc = closesocket (usock->s);\n-                wsa_assert (rc == 0);\n+                nn_usock_close(usock);\n                 usock->s = INVALID_SOCKET;\n                 usock->state = NN_USOCK_STATE_DONE;\n                 nn_fsm_raise (&usock->fsm, &usock->event_error, NN_USOCK_ERROR);\n```\n. @sustrik  It's already updated, please look at this.\n. You need to specify the correct branch to pull, at the current time it's win_pipe. \nBesides, you need to clone my repository into a clean directory, if you want to merge it locally.\n. ok  i'll rebase it latter.\n2014\u5e746\u67081\u65e5 \u4e0b\u53484:50\u4e8e \"sustrik\" notifications@github.com\u5199\u9053\uff1a\n\nHi, I've reviewed the patches. They look OK. However, there are merge\nconflicts with the current mainline. Can you resolve those? Once done, I'll\nmerge the patch.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/253#issuecomment-44772010.\n. @sustrik  That's really not so good, you call me to resolve the conflict but doesn't push the content first.\n. Then pull my repository and merge it manually. There is no conflict at the\ncurrent time unless you pushed new things\n2014\u5e746\u67082\u65e5 \u4e0b\u53481:13\u4e8e \"sustrik\" notifications@github.com\u5199\u9053\uff1a\n@lygstate https://github.com/lygstate: What content? What i see is tht\ngithub reports merge conflicts: \"We can\u2019t automatically merge this pull\nrequest.Use the command line to resolve conflicts before continuing.\"\nIs that wrong? Have you been able to merge without conflicts?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/253#issuecomment-44802560.\n. Should be branch win pipe\n2014\u5e746\u67082\u65e5 \u4e0b\u53481:52\u4e8e \"sustrik\" notifications@github.com\u5199\u9053\uff1a\nTried that. I still see conflicts. Here's one for example:\n<<<<<<< HEAD\nnn_assert (optlen < INT_MAX);\nrc = setsockopt (self->s, level, optname, (char*) optval, (int) optlen);\nif (nn_slow (rc == SOCKET_ERROR))\nreturn -nn_err_wsa_to_posix (WSAGetLastError ());\nif (self->domain == AF_UNIX)\n{\n    /* TODO: implement Named Pipe setsockopt /\n    rc = 0;\n}\nelse\n{\n    rc = setsockopt(self->s, level, optname, (char)optval, optlen);\n    if (rc == SOCKET_ERROR)\n        winerror = WSAGetLastError();\n}\n\n\n\n\n\n\n\nec51f43faf1b0db53dc56b65a92149771c32b28d\n\n\n\n\n\n\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/253#issuecomment-44803877.\n. Update the pull request again.\n. @gdamore What's the design of your new notification mechanism?\nFor inproc interproc & network. Do they using different notification mechanism?\n. @gdamore  condition variable? Do you means semaphore ?\n. I suggest to re-open this issue and put it on the table.\n. @gdamore That's looks not that hard. Can you provide a API list that need to be implemented?\nby condition variables.\n. Code update\n\n```\ninclude \"../src/nn.h\"\ninclude \"../src/pair.h\"\ninclude \ninclude \ninclude \ninclude \ninclude \nifdef _WIN32\ninclude \nelse\ninclude \nendif\nifdef _WIN32\nif defined(_MSC_VER) || defined(_MSC_EXTENSIONS)\ndefine DELTA_EPOCH_IN_MICROSECS  11644473600000000Ui64\nelse\ndefine DELTA_EPOCH_IN_MICROSECS  11644473600000000ULL\nendif\nstruct timezone\n{\n    int  tz_minuteswest; / minutes W of Greenwich /\n    int  tz_dsttime;     / type of dst correction /\n};\nint gettimeofday(struct timeval tv, struct timezone tz)\n{\n    FILETIME ft;\n    unsigned __int64 tmpres = 0;\n    static int tzflag = 0;\nif (NULL != tv)\n{\n    GetSystemTimeAsFileTime(&ft);\n\n    tmpres |= ft.dwHighDateTime;\n    tmpres <<= 32;\n    tmpres |= ft.dwLowDateTime;\n\n    tmpres /= 10;  /*convert into microseconds*/\n                   /*converting file time to unix epoch*/\n    tmpres -= DELTA_EPOCH_IN_MICROSECS;\n    tv->tv_sec = (long)(tmpres / 1000000UL);\n    tv->tv_usec = (long)(tmpres % 1000000UL);\n}\n\nif (NULL != tz)\n{\n    if (!tzflag)\n    {\n        _tzset();\n        tzflag++;\n    }\n    tz->tz_minuteswest = _timezone / 60;\n    tz->tz_dsttime = _daylight;\n}\n\nreturn 0;\n\n}\nendif\nvoid Send()\n{\n    int responder = nn_socket(AF_SP, NN_PAIR);\n    assert(responder != -1);\n    int rc = nn_connect(responder, \"inproc://test\");\n    assert(rc >= 0);\nchar buf[1024];\nunsigned long bytes = 0;\nint sz[] = { 16,32,64,96,128,160,192,224,256,384,512,768,1024 };\nint p = 0;\nfor (unsigned count = 1048576; count--;)\n{\n    unsigned len = sz[p];\n    nn_send(responder, buf, len, 0);\n    bytes += len;\n    p = (p + 1) % (sizeof(sz) / sizeof(sz[0]));\n}\nnn_send(responder, buf, 0, 0);\nprintf(\"sent %lu bytes\\n\", bytes);\nnn_close(responder);\n\n}\nvoid Receive(int receiver)\n{\n    char buf[1024];\n    unsigned long bytes = 0;\n    while (1)\n    {\n        int len = nn_recv(receiver, buf, sizeof(buf), 0);\n        if (!len)\n            break;\n        if (len < 0)\n        {\n            perror(\"nano_recv\");\n            break;\n        }\n        bytes += len;\n    }\n    printf(\"received %lu bytes\\n\", bytes);\n}\nint main()\n{\n    int receiver = nn_socket(AF_SP, NN_PAIR);\n    assert(receiver != -1);\n    int rc = nn_bind(receiver, \"inproc://test\");\n    assert(rc >= 0);\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nunsigned long t0 = tv.tv_usec + tv.tv_sec * 1000000;\n\nstd::thread receiveThread(Receive, receiver);\nstd::thread sendThread(Send);\n\nsendThread.join();\nreceiveThread.join();\n\ngettimeofday(&tv, NULL);\nunsigned long t = tv.tv_usec + tv.tv_sec * 1000000 - t0;\nprintf(\"elapsed=%.3f\\n\", t / 1000000.);\nreturn 0;\n\n}\n```\nThis can be running under both Windows/Unix.\nand the time that running under windows are:\nreceived 311022272 bytes\nsent 311022272 bytes\nelapsed=8.936\nPress any key to continue . . .\nYes, it's horribly slow.\n. @gdamore Sorry for pushing you about this issue. I know it's a very big changes to nanomsg, I am seeking for if there would be a small preview of the big picture. I'd like to disuses with you about this issue.\n. ",
    "jbenet": "UDP support would be really useful. Haven't looked into the source, but there should be easy ways to add new transports (UDP, SCTP/UDP, uTP/UDP, WebRTC, etc).\n. ",
    "aleks-f": "It is meant for a library wrapping nanomsg to avoid linker warnings. Without it, nanomsg API calls are either exported or imported; if the goal is to expose different API (e.g. C++) and hide nanomsg API, then you may not want them exported and, since nanomsg is embedded, they are not imported either, which causes LNK4217.\nEDIT: the main reason is to simplify/automate nanomsg embedding without need to edit the library code. Thinking about it, NN_NO_EXPORTS name may be more in line with the style and it should probably be explained with a comment line or two. Let me know if you want me to modify the pull.\n. The change is a simple #ifdef NO_NN_EXPORTS addition, with the previously existing defines block moved inside the #else/#endif. It looks bigger than it really is because of change in indentation of the existing lines.\n. ",
    "ramki1979": "I am getting the same warning, only difference in my case is Target: x86_64-apple-darwin12.5.0 (OS X 10.8).\n. check my log here: http://pastebin.com/VM4hFmch\n. May be this might be useful for you,\nUse nn_device, I have done the same thing in C. Check post on the same\nsubject \"REQ/REP worker example\" and community answers and the final\nworking example on pastebin.\nNote: IPC didn't worked, TCP worked.\nOn Sunday, June 29, 2014, metadings notifications@github.com wrote:\n\nThe examples I found on the internet always have one instance to REPly on\nREQuests. When I tried an example (sorry not pure C, but C#) and I spawn\nmore than 1 reply server, there is always the \"Address in use 100\"\n(currently have a nanomsg build 0.3). I also tried to use a mutex, released\ndirectly after ReceiveStream but this results in the same error.\nHow to have multiple reply services, which bind to the same port for\nrequests, but \"accept\" and work to reply on another port (so that while\nworking, the next worker can pickup following requests)?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/271.\n. Out of the four one is client code [ http://pastebin.com/GQq6vPkX ] and\nother are for server.\n\nUse the latest one [http://pastebin.com/rqpdaQmH], and as I mentioned IPC\ndin't worked and TCP worked, so Just replace \"ipc\" end-point with \"tcp\"\nend-point accordingly and\njust ignore the comments.\nOn Sun, Jun 29, 2014 at 8:27 PM, metadings notifications@github.com wrote:\n\nMessing with Google I found three pastes, but they are full of \"I tried\nhere and I'm waiting forever there\".\nhttp://pastebin.com/rqpdaQmH \"nanomsg REP/REQ example with threads\"\nhttp://pastebin.com/GQq6vPkX \"nanomsg REP/REQ example with threads client\ncode\"\nhttp://pastebin.com/j8naGfuD \"nanomsg REP/REQ example with threads\"\nhttp://pastebin.com/3JL2Y7wh \"nanomsg REP/REQ example with threads\"\nWhich do you refer to?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/271#issuecomment-47457058.\n. I have to mention that using \"nn_device\" was easy but due to some issues on\nmy OS X[ I was still new to this OS], I was not able to fix IPC end-point.\n\nLogically \"nn_device\" should be bind to the end-points. Client and Server\nworkers should connect to the \"nn-device\" respective end-points,\n but as I was not able to get IPC worked, I just tried connect on\n\"nn_device\"[even though I know It's wrong].\nI hope this will help the comment in the sample code which confuses others.\nOn Sun, Jun 29, 2014 at 9:56 PM, Ramakrishna Mallireddy \nramakrishna.malli@gmail.com wrote:\n\nOut of the four one is client code [ http://pastebin.com/GQq6vPkX ] and\nother are for server.\nUse the latest one [http://pastebin.com/rqpdaQmH], and as I mentioned IPC\ndin't worked and TCP worked, so Just replace \"ipc\" end-point with \"tcp\"\nend-point accordingly and\njust ignore the comments.\nOn Sun, Jun 29, 2014 at 8:27 PM, metadings notifications@github.com\nwrote:\n\nMessing with Google I found three pastes, but they are full of \"I tried\nhere and I'm waiting forever there\".\nhttp://pastebin.com/rqpdaQmH \"nanomsg REP/REQ example with threads\"\nhttp://pastebin.com/GQq6vPkX \"nanomsg REP/REQ example with threads\nclient code\"\nhttp://pastebin.com/j8naGfuD \"nanomsg REP/REQ example with threads\"\nhttp://pastebin.com/3JL2Y7wh \"nanomsg REP/REQ example with threads\"\nWhich do you refer to?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/271#issuecomment-47457058.\n. please ignore the comments completely and just see the code and replace ipc\nend-point with tcp endpoint.\n\n\nI have an oauth2 service running with the same code, as I don't want to\npost the complete code, there were some comments left there(I forgot to\nremove) which doesn't have any relation to nanomsg use case. sorry for\nthat, but once you remove all the comments, then its plain nanomsg example.\nIf you still confuse i.e even after removing comments from the code, then I\nstrongly suggest to read the nanomsg documentation.\nOn Sun, Jun 29, 2014 at 11:20 PM, metadings notifications@github.com\nwrote:\n\nNo it just keeps confusing, weird and annoying.\nHas anyone a working example of multiple worker threads REPlying on\nmultiple REQuest threads?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/271#issuecomment-47463354.\n. Ok, I have updated the example,\n\nhttp://pastebin.com/XfBrqXPA\nOn Sun, Jun 29, 2014 at 11:49 PM, Ramakrishna Mallireddy \nramakrishna.malli@gmail.com wrote:\n\nplease ignore the comments completely and just see the code and replace\nipc end-point with tcp endpoint.\nI have an oauth2 service running with the same code, as I don't want to\npost the complete code, there were some comments left there(I forgot to\nremove) which doesn't have any relation to nanomsg use case. sorry for\nthat, but once you remove all the comments, then its plain nanomsg example.\nIf you still confuse i.e even after removing comments from the code, then\nI strongly suggest to read the nanomsg documentation.\nOn Sun, Jun 29, 2014 at 11:20 PM, metadings notifications@github.com\nwrote:\n\nNo it just keeps confusing, weird and annoying.\nHas anyone a working example of multiple worker threads REPlying on\nmultiple REQuest threads?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/271#issuecomment-47463354.\n. \n\n",
    "drewcrawford": "This patch is submitted under MIT license\n. I'm also seeing this intermittently on Debian7 64.  \nIf there's interest from @sustrik in examining this I would be happy to build a Docker image that reproduces the problem\n. It's sort of difficult to give a straight answer because I don't know who counts as a \"user\".  What I can tell you is, a custom nn_device sees different data depending on whether one of its sockets is IPC or INPROC.  Either that shouldn't happen, or there should be some way for the device to figure out if it is going to get \"IPC-style\" data or \"INPROC-style\" data.  This PR was aimed at the second solution, but the first solution isn't a bad idea either.\nIf we're pursuing the first solution then in my opinion the situation should be resolved in favor of the test always seeing 8 bytes (e.g. with request ID) through the device, as explained more fully in the test comment.  Currently it's difficult to get an 8-byte result at all, as it only happens in one direction and only with non-IPC transport.\n. Yes that's correct.  If it helps the test in https://github.com/drewcrawford/nanomsg/commit/f4c95963836d65bfb36263a07e1afc7ac54fb9c2 sets the scenario\n. Yes.  For example if you have a device, that tries to do routing or load balancing.  For example, sending even numbered channel IDs to one location, and odd numbers to another.\n. ",
    "ya1gaurav": "Yes, I submit it under MIT Licence.\nName is Gaurav Gupta g.gupta@samsung.com\n. ",
    "reqshark": "@wirebirdlabs seeking structure is not helped by the RFC in the email you mention on freelists. \nAccording to Ilya Grigorik, there are other options for high performance browser networking, see e.g.: http://chimera.labs.oreilly.com/books/1230000000545/ch14.html\nrather than websocket, why not SSE?\n. Cool! Looking forward to that and learning more!\nSent from my iPhone\n\nOn Jun 22, 2016, at 9:57 AM, gdamore notifications@github.com wrote:\nSo I closed this issue above. I have been looking at another architecture which would move notification\nto another mechanism, and allow us to get rid of the separate system calls. That would be lots and lots faster if you don't need file descriptor notification. However, this represents a large change to huge swathes of the core of nanomsg, so it's a nanomsg 2.0 thing.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. edited my terminal output being TMI for issue comments, gisted it here\n. no longer the case\n. @djc @sustrik we need to do this anyway downstream in iOS. it cleans up the last few pieces of msgs i pull off nn_recv()\n. here's a good quote to that article's point:\n23:51 \\n (Nick Desaulniers): correctness trumps perf.\n23:53 \\n (Nick Desaulniers): since a compiler makes code transforms on your behalf...\n. null terminating a C string is way better, the larger the message envelope, the more so. \n\nbut for stable scalability purposes, calloc is a safeguard against human error.\n. the bug rears up when using iOS to receive msgs over TCP sourced from other operating systems.\nthe severity seems to depend partly on which remote nanomsg binding i'm using to send messages.\nnature of the bug: every so often msgs have garbage at the end, i.e. bad allocation type garbage.\nwhy would using calloc completely fix it? I highly doubt it's an iOS-specific issue.\n. sure do you have iOS device?\n. ok just a sec.. i'll paste it shortly\n. use this before the calloc commit\n``` bash\ninside your ios project add this\n$ git clone https://github.com/reqshark/nanomsg.ios.git\n$ cd nanomsg.ios && git checkout 9f5f0d837e && rm README.md\n```\nthe other dependency, would be something like msgevents.h:\n``` c\nifndef msg_events\ndefine msg_events\ninclude \"nn.h\"\ninclude \"poller.h\"\ninclude \ndefine NN_IN 1\ndefine NN_OUT 2\nint grc;\nint getevents (int s, int events, int timeout){\n  fd_set pollset;\n  int rcvfd;\n  int sndfd;\n  int maxfd;\nsize_t fdsz;\n  struct timeval tv;\n  int revents;\nmaxfd = 0;\n  FD_ZERO (&pollset);\nif (events & NN_IN) {\n    fdsz = sizeof (rcvfd);\n    grc = nn_getsockopt (s, NN_SOL_SOCKET, NN_RCVFD, (char*) &rcvfd, &fdsz);\n    FD_SET (rcvfd, &pollset);\n    if (rcvfd + 1 > maxfd)\n      maxfd = rcvfd + 1;\n  }\n//strictly for sending the next\n  if (events & NN_OUT) {\n    fdsz = sizeof (sndfd);\n    grc = nn_getsockopt (s, NN_SOL_SOCKET, NN_SNDFD, (char*) &sndfd, &fdsz);\n    FD_SET (sndfd, &pollset);\n    if (sndfd + 1 > maxfd)\n      maxfd = sndfd + 1;\n  }\nif (timeout >= 0) {\n    tv.tv_sec = timeout / 1000;\n    tv.tv_usec = (timeout % 1000) * 1000;\n  }\nselect (maxfd, &pollset, NULL, NULL, timeout < 0 ? NULL : &tv);\n  revents = 0;\n  if ((events & NN_IN) && FD_ISSET (rcvfd, &pollset))\n    revents |= NN_IN;\n  if ((events & NN_OUT) && FD_ISSET (sndfd, &pollset))\n    revents |= NN_OUT;\n  return revents;\n}\nendif\n```\nand then in your iOS app somewhere run this, (obviously it would be better to do it non-blocking and somwhere after UIApplicationMain). \nfor simplicity and example sake let's just do this:\n``` c\ninclude \nimport \nimport \"AppDelegate.h\"\ninclude \"nn.h\"\ninclude \"tcp.h\"\n//#include \"pipeline.h\"\ninclude \"sleep.h\"\ninclude \"pubsub.h\"\ninclude \"msg_events.h\"\nint s, r, eid;\ndefine ADDR \"tcp://202.202.202.202:5555\"\nint count = 0;\nvoid loop(void);\nint main(int argc, char * argv[]) {\n  printf(\"hey\\n\");\ns = nn_socket(AF_SP,NN_SUB);\nnn_setsockopt (s, NN_SUB, NN_SUB_SUBSCRIBE, \"\", 0);\neid = nn_connect (s, ADDR);\n  loop();\n@autoreleasepool {\nreturn UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n\n}\n}\nvoid loop(void){\n  //if descriptor is ready for i/o, getevents returns 1\n  //this informs our app when to read from the socket and allocate a new msg buffer\n  r = getevents (s, NN_IN, 10);\n  if(r == 1){\n    char *b = NULL;\n    nn_recv (s, &b, NN_MSG, 0);\n    printf(\"buffer: %s %d \\n\", b, ++count);\n    nn_freemsg (b);\n    loop();\n  } else {\n    //nn_sleep(10);\n    loop();\n  }\n}\n```\nEDIT: i moved the connect code above the first call to loop(); since that's where it was on mine, (idea is that this actually runs)\n. so you see there's not a lot of app code involved here.. it's very spare, basically the nanomsg src directory at beta 5 release\n. also one more thing, use this to set the remote connection string, in this case it would be where your pub socket lives:\n``` c\ndefine ADDR \"tcp://202.202.202.202:5555\"\n```\n. > the approach used with C language strings, may not work with strings from other languages. \nthe point of this PR is that we don't have a guarantee about the binding or who does the sending code.\nin other words, this makes it compatible with all nanomsg bindings and all send code \n. at a minimum if you're against this PR would u be in favor of doing it as a configurable socketopt? \n. perhaps something that is not the default.. \n. so cert says dont do it\n. @marchon when are you going to learn how to use github instead of email\n. perhaps #503 will help\n. clarification: NN_RCVPRIO is definitely exported by the header file, just not retrieveable by nn_symbol() without merging #375 \n. no need to run the tests on this one. \nthe symbol test's reliance on nn_symbol() is a self-fulfilling determination of inclusion, meaningless about things nn_symbol() is unaware of, i.e. anything not part of the nn_symbol_properties struct\n. this is unexpected because the subscription string is not being set correctly. instead go like this:\nc\nassert(nn_setsockopt(sub, NN_SUB, NN_SUB_SUBSCRIBE, \"topic.A\", 7) >= 0);\n. your length parameter is what value is. \nunfortunately it's a bit confusing in your code there because we're calling the socket this.binding, which corresponds with sub or sock in the code above\nalso lets move this discussion over to node-nanomsg, as it is no longer appropriate on libnanomsg.\n. Isn't that like binding to a random namespace for inproc or ipc? \nIm not seeing how that would help when its corresponding tcp socket must meet with a precise port number in its connection string.\n. @amosbird, that scheme sounds overly procedural and specific for such accommodations by the library.\nbut that's just my opinion, and you may be onto something after-all.\nOne way this would make sense to me is if the random bind function somehow returned which port was bound, or perhaps in the alternative, if a later call to getsockopt() with level NN_TCP returned additional information about the socket's connection string.\n. > port might be unavailable as another application can take it between randomization and binding...\nrandomized port unavailability scenerios requiring atomicity seem plausible to me.\nin light of the snippet above, however, I'm going to side with @diffuse on this one\n. > introducing a full HTTP server framework into libnanomsg. That doesn't seem very realistic\nlibzmq calls that a stream socket type\n. try ./autogen.sh first before ./configure\n. oh right, well i think maybe that's because it's different for windows, those system need cmake?\n. ok ya, you're definitely right. @anshumang, send a PR to fix it!\n. nice!\n. NN_SOL_HOPS\nBut use case sounds like a TCP option, so please also consider naming like NN_TCP_HOPS option \n. right, it could impact any other wire transport\nsince it's hard for me to see the option being applied to inproc or ipc, how do you draw a clear line between protocol and transport? \n. are you serious?\n\nfix the illumos kernel \n\nthat's awesome, just patch kernels when they don't work with our user-space software\n. excuse me, nevermind you probably are going to patch that kernel, just checking out the who's who section on the illumos wiki: \nhttp://wiki.illumos.org/display/illumos/Garrett+D%27Amore\n. > the implementation of websocket in libnanomsg is kind of toylike in its simplicity.\nSounds good to me! \n\nFar more likely is a full rewrite of libnanomsg with an internal design that is easier for extension (but may make other sacrifices, which make it harder to embed in certain implementations such as OS kernels, for example).\n\nSmall is beautiful. Compatibility is better than purity. Simplicity is better than anything.\n\nThat said, I wouldn\u2019t rate the likelihood of even that at very high, since as far as I know I\u2019m the only one likely to undertake such an endeavor, and I don\u2019t exactly have a surplus of time on my hands.\n\nFair enough.\n\nI think that its rather premature to make such a prediction.  websocket\u2019s exists to offer a binary protocol to application developers, for use in the browser.  Its unclear to me that the same semantics are directly available with HTTP/2 that websockets gives.  They may be. There are also discussions afoot about layering websockets on top of HTTP/2, but I can\u2019t see that any consensus has been reached on that yet.\n\nHTTP operates under semantic obligation to close the response after the last fragment. I'm hesitant to say close the TCP connection since proxy servers started implementing keep-alive and that's widely used.\nContrast that pattern with websocket: \n\nwebsockets exist to offer a binary protocol to application developers, for use in the browser.\n\nTrue, it's a two-way messaging pattern that seems consistent with scalability principles/protocols/patterns we see in nanomsg.\nBut that's just section 8 of the HTTP/2 draft! :rocket: :rocket: \nFurther into section 8, push requests are defined as essentially the semantic inverse of the GET/POST style.  HTTP/2 ushers in a new two-way messaging protocol native to the TCP connection. \nOf course the header format and framing designs are not the most attractive aspect of the protocol, but in HTTP/2 I see it as a minimal, albiet ugly, semantic requirement to bi-directional TCP sockets.\n. > I\u2019m hopeful for the future of HTTP/2, but I\u2019m also not ready to spend a bunch of time heading off without having some idea where the destination lies. - Garrett\nI can understand that, save time, you might be interested to check these out first: \n- https://github.com/bradfitz/http2\n- https://github.com/Jxck/http2\nand one my favorites of the implementations I've seen so far: https://github.com/h2o/h2o \n. > Further into section 8, push requests are defined as essentially the semantic inverse of the GET/POST style. \nI must have been interpreting Section 8.2.1,  Push Requests:\nServer push is semantically equivalent to a server responding to a\n   request; however, in this case that request is also sent by the\n   server, as a PUSH_PROMISE frame.\n\nHTTP/2 ushers in a new two-way messaging protocol native to the TCP connection.\n\nNO it does\u2019t.  See above.\n\n\nOK that's absolutely right. That is not where HTTP/2 ushers in the async bi-directional specifications. Server push requests are not the right comparison to that type of two-way communication, like websocket. \nBut the HTTP/2 Streams might be:\nStream DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response payloads. see, e.g. 6.1\nSo after re-reading the sections on push requests/responses, I completely agree with you here:\n\nIf you read the details of Server push, you\u2019ll see that it is still intended for caching purposes, and indeed the client is given some control over whether server pushes should be used or not.  (SETTINGS_PUSH_ENABLE).\n\nAnd I would agree with you further on this point, but for the Stream Data Spec:\n\nSo, it would be a mistake, IMO, to assume that it semantically is anything at all like a free-form binary protocol with completely asynchronous messaging.  (In HTTP request/responses are synchronous, in the sense that you don\u2019t get a server response until after you\u2019ve asked for a request.)\n\nThe initial impression I had and description of Push Request you're responding to was certainly a mistake of understanding on my part. Moreover, at this point I think the idea of PUSH_PROMISEs are akward distortions of the HTTP request/response practices and definitions, at best.\n\nIf you want bidirectional communication within a browser/web semantic, we have websocket.  We don\u2019t need HTTP/2.\n\nFrom this perspective, Websocket looks simpler and more straightforward, so I guess time will tell whether the HTTP/2 streams end up replacing them. \nOK.. now that we've cleared that up, I'd like to return to the first point you made, because there was something very interesting there having less to do with HTTP/2 standards track and more to do with libnanomsg and it's ability to support additional extensions or modularity:\n\nthe implementation is toylike enough to meet the requirements of websocket from an RFC standpoint, but totally miss the point.  That said, it would be non-trivial to do much more within libnanomsg, because of libnanomsg\u2019s design constraints. \n\n@gdamore, where do you see design constraints? Where are they the worst? And more importantly how can we improve these areas of the library? Is there a specific layer or convention, encumbering further extension/modular development?\n. what about a generic non-peer socket type? issue #397\n. I think it'd be way easier than implementing the full ws type\n. @wirebirdlabs makes sense to me too, especially after my conversation with @gdamore yesterday\n. +1 please rebase/squash\n. cool thanks, ya git commit --amend is a better way to push it up. \ni'll just rebase my fork if submit any other PRs in the future\n. allow me to explain how i \"rebase my fork\"\ngithub's advice on syncing your fork with upstream master is sometimes dead wrong.\ndepending on the state of git commit history I'd say people are better off not following that help page, so instead of doing what it tells us: git fetch upstream && git checkout master && git merge upstream/master, I would say it's more appropriate to rebase off upstream branches:\nbash\n$ git fetch upstream\n$ git rebase upstream/master\n. +1\n. ping @gdamore, can we add the link for iOS?\n. thx @gdamore, cheers :cocktail:\nalso i was planning to ping you and @djc on cutting the beta-6 release soon\n. @kristianlm what OS are you using?\n. @BTCDDev if MinGW supports kernel multiplexing strategies or anything else in the vicinity that aligns with POSIX syscalls and the windows detection mechanisms in nanomsg attempt to employ winsock equivalent operations I could imagine unpredictable results in that environment. \nI am curious about other people's experience attempting to combine MinGW with nanomsg.\nunfortunately i don't understand enough low level windows system to provide a more helpful response here. personally, I can just say when programming for windows I try to stick to the windows compilers microsoft recommends using like the community edition visual studio. usually nanomsg works pretty well there, at least the beta-5 tag has been stable. \nAlso I'm not really sure where things are with master branch and windows\n. :+1: \n. +1\nlibuv's eventloop, or maybe ae\n. that's interesting. hadn't thought about it in those terms. \nlow level event loop programming is much context/reference passing... it's a valuable exercise, because it makes one appreciate normal return values\n. > it would even be exciting to have this inversion at the library layer, such that language bindings could inject their own callbacks to provide idiomatic channels native to their language!\nI agree. all of node.js' system i/o uses the libuv state machine handles so when binding to libnanomsg from node, it was was a natural (practically idiomatic) implementation fit to defer to that library to manage the need for a cross-platform I/O multiplexing strategy. \nHaving such a consistent and complete async interface available between calls to nn_recv() or nn_send is necessary to do this right for node.js. And doing that gave us unexpected results in terms of where we were on network performance. Nanomsg AF_SP sockets over TCP gave us more than an order of magnitude higher performance when comparing equal buffers exchanged over Node.js' net library.\nif anyone is interested in verifying and measuring these results, checkout the perf pkg on npm or this github repo \nSo ya pretty good stuff and @wirebirdlabs, you might be interested to peek at our libuv implementation: https://github.com/nickdesaulniers/node-nanomsg/blob/b60a5130f7acbc03bacba57faf33212f88d0194a/src/node_nanomsg.cc#L226-L330 \nif you do end up taking a look there, just try to avert your eyes from all the ugly C++ surrounding it. \n. > We won't be using libuv unless someone else wants to do the work. That would create different C++ requirements.\nlibuv is written in C.\n\nI feel libmill is going the wrong way -- still trying to \"fake out\" concurrency using hackery\n\nConcurrency by message passing is real. Sending messages over co-routines may avoid context switches into kernel space (syscalls) we otherwise incur using the thread and mutex. \n\ninstead of just relying on reasonable platform threading APIs\n\nReasonable to me means selecting the best possible concurrency model for the situation. I wouldn't rule out Libmill on the basis of its ability to provide a meaningful concurrency framework for Linux and OS X. IMO, lack of windows support is the reason to reject it (if we're talking about nn_thread_routine)\n. @gdamore what's NN_UNUSED for?\n. so maybe it's not a bug in gecko? https://bugzilla.mozilla.org/show_bug.cgi?id=1216237\nstrange that we got it working w/ webkit..\nbtw are there any examples of how to implement this stuff a browser? here's what we did to get it to work on the node binding: https://github.com/nickdesaulniers/node-nanomsg/blob/master/examples/ws/index.html\n. I'll update shortly, this morning\n. ok I rebased the commit with a reference to the bug report and revised the PR subject to match\n. BTW the first go around i saw appveyor build pass. \nnow it seems to be getting caught up on a WS timeout \n. thanks for the confirmation @wirebirdlabs, indeed downstream we've experienced some of those idiosyncratic WS timeouts, even on travis CI\n. I don't think we're looking at bugs necessarily. \nI mean our travis timeouts are classic slow-joiner syndrome.\nAlso just because we call nn_connect() over TCP doesn't mean that we've established anything but an eid or how, endpoint identiftier \n. thanks @gdamore for merging/fixing my commits! :sunglasses:  \nbut you know, emojis are cool for commits sometimes, and yea @wirebirdlabs this PR is history\n. that makes sense, the first line links/ref to the matter, without having to open a dot dot dot\n\n. On the node binding we started seeing TCP timeouts in our tests back in September, which I attribute then to slow-joiner syndrome inherit in PUBSUB topology, especially where millisecond-level deliveries hinge on connection ordering. That's a good recipe for hanging indefinitely, since publishers could send off a message before the TCP CONNECTION is established by the subscriber. \nMoreover, when using nn_connect(), especially over TCP, it's my understanding that the return value (whether or not it blocks) represents the endpoint, not the fact that the handshake between server and client has been completed\nJust think about it, PUB SUB was designed so that a publisher could begin sending messages long before any subscribers come along to recv, so missed messages with that pattern are just part of it.\nI've also noticed a lot of round-about dily-dallying in the nn_sock_recv() loop, the usock.c file. Recalculation of deliberate timeouts and other potential back-offs might be overkill for the purpose of a recv operation. gentlemen, correct me if I'm wrong there please. \n. oh i just referenced the wrong file in this discussion, so please ignore that, what I was trying to express was a bit of weariness toward the way NN_RCVMAXSIZE operates, see https://github.com/nanomsg/nanomsg/commit/9a0cb281695759fde449244b5f664ece5075d9f5:\n\n/*  Message header was received. Check that message size is acceptable by comparing with NN_RCVMAXSIZE; if it's too large, drop the connection. */ \n\nthis code comment replaced: \n\n/*  Message header was received. Allocate memory for the message. */\n. yea I've been seeing the hang bug on iOS, after starting to update to beta 7. But it could be unrelated, I'm still investigating... \n. btw earlier I was apprehensive about NN_RCVMAXSIZE, very suspicious of its ability as a default to abruptly close connections--that was not sitting well with me.  \n\nAfter reading this email exchange: \nhttp://www.freelists.org/post/nanomsg/issue-with-received-message-size,1\nUnfortunately I'll have to completely flip flop: it's appropriate and necessary for the library! NVM!\n:fish: :fish: :fish: :fish: \n. @gdamore, getting back to your point about async i/o and threads, \n\nI just set up a blocking thread (goroutine) that attempts to read on every socket\n\na go-routine sounds like a good option, but that's only mentioning the benefit. I'm wondering what's the trade-off, in terms of libnanomsg (AFAIK the goroutines are light), but for the library what's the overhead on the system for blocking threads? I assume some coordination and inter-thread communication must happen for the details of all new and old sockets getting watched... \nI suppose a thread could be tuned for different scenarios, with scheduling priority? The last thing I want is a blocking call running upwards of 100% on a core or CPU. Then again if we set a NICE(1) level too low could the system fall behind on I/O that could have been done?\n. Thank you! I need a better understanding of how blocking IO works.\n\nWhen it is waiting for the IO to complete it is not running but sleeping\n\nthat sounds like it could add up to a lot of waking up and going back to sleep in between periods of I/O\n\nFor nanomsg there will be some small overhead in terms of locking and context switching but that will still be far less than what we pay today\n\nWell if that's true then I'm excited about nanomsg 1.0! :tada: \n. > I've been doing this kind of thing for decades now.  (I am a kernel developer after all.) \n@gdamore, I'm aware that you're the illumos kernel author, and I appreciate the opportunity to get real answers on some of these things\n\nTrust me \n\nDefinitely. Sorry if these are remedial topics, I'm equal opportunity clueless over any given discussion or area of the library.. and thanks for helping me figure it out!\n. yes, but i'm finding it odd that OSX would be unaffected, versus the breaking iOS behavior\n. @gdamore it's not easy to reproduce. The error is inconsistent and most of the time it works as expected.\nI was looking at two scenarios over IPv4 localhost, i.e. msgs sent over an address of 127.0.0.1:5555 and connecting to a publisher on my local network, so that was an address of 10.0.1.2:4444\n. > I\u2019m not sure you have debugging allocators available to you (particularly ones with red-zone areas, e.g. the ability to detect writes beyond the allocated area, use after free, etc.), but if you do, you might want to run your code through it.\nI'm using apple's LLDB to detect any bad memory access\n\njust falling victim to heap corruption caused by an error somewhere else in your code. \n\nthat could be what's going on, at any rate, here's my iOS connect code:\n``` objective-c\ninclude \"nn.h\"\ninclude \"tcp.h\"\ninclude \"ws.h\"\ninclude \"pubsub.h\"\ninclude \"sleep.h\"\ndefine ADDR \"ws://10.0.1.2:4444\"\nint s = nn_socket (AF_SP, NN_SUB);\nint r = nn_setsockopt (s, NN_SUB, NN_SUB_SUBSCRIBE, \"\", 0);\n  if(r > -1){\n    printf (\"subscriber socket set\\n\");\n  } else {\n    printf (\"error setting subscription socket: %d\\n\", r);\n    // return 1;\n  }\n//bind and connect sockets\n  nn_connect (s, ADDR);\n  nn_sleep (10);\n```\nanother machine with public address 10.0.1.2 publishes websocket msgs over 100ms interval, and it's working fine, they're all being received as expected.\nclose the issue if you like, but i'd like to keep it open in case I repro at some point later on this week\n. i watched appveyor pass, updated the commit and got a WS timeout. \nunfortunately this doesn't fix #505 \n. So I'll need to take a closer look at what's actually happening here and report back those findings\n. well I'm using IP address numbers, not named interfaces, so apprently I'm not bypassing this code.\nI'm taking a look at the call stack right now and I'll update with some more information shortly \n. update the macros so this change only applies to windows\n. well, come on let's face it, the systems are different, they've been designed to behave differently, whether intentionally or not is another issue.\n\nThat way leads to spaghetti and a more difficult to support code base.\n\nclearly articulated code comments go a long way to combat that type of thing, but of course you're right.\n. changing those URLs could cause build system breakage if people are depending on a different URL address format \n. yea looks like you've been doing this since beta-06 anyway the URL links are,\nhttps://github.com/nanomsg/nanomsg/releases/download/0.7-beta/nanomsg-0.7-beta.tar.gz\nhttps://github.com/nanomsg/nanomsg/releases/download/0.6-beta/nanomsg-0.6-beta.tar.gz\nhttp://download.nanomsg.org/nanomsg-0.5-beta.tar.gz\nhttp://download.nanomsg.org/nanomsg-0.4-beta.tar.gz\n... etc\n. IPC may not be supported out of the box on iOS. After doing a little research I found:\n-  unlink() before bind is actually the idiomatic approach to IPC\n- apple iOS restricts file permissions, like read/write to the app's private directory\n. thanks for the info on unlink before bind! That's good to know.\nwon't fix is understandable POSIX IPC has been completely warped on iOS. However, it is indeed possible to make it work\n. and also you'll need to force push back to your branch after the git rebase -i\n. on the browser-side of the connection, is there a way to configure nanomsg features?\n. sure, let's say i set up an NN_PAIR or some other socket type. \nOn the browser-side, setting no options, I'm actually able to get msgs into a web browser's JavaScript like this:\n``` js\n      var ws = new WebSocket('ws://127.0.0.1:7789', [\n      // see the rfc on sp websocket mapping:\n      // raw.githubusercontent.com/nanomsg/nanomsg/master/rfc/sp-websocket-mapping-01.txt\n        'pair.sp.nanomsg.org'\n      ]);\n      ws.onopen = function open() { ws.send('Ping'); }\n      ws.onerror = function error(err) { console.log(err); }\n      ws.onmessage = function message(e) {\n        var reader = new FileReader();\n        reader.addEventListener('loadend', function() {\n          document.querySelector('span').textContent = reader.result;\n        });\n        reader.readAsText(e.data);\n      }\n```\nWould any socket options I set on the other end pass-through or is there any plan to be able to set options from the browser-side? Does that make sense?\n. btw, when i say \"get msgs into a web browser's JavaScript \" I also mean send msgs back! :+1: \n. Really just NN_RCVMAXSIZE, for larger data sets or images bigger than 1024kB..\nBut at some point if NN_SNDBUF or NN_RCVBUF could improve perf I would want to set those\n. Ok I could see that, thanks!\n. > Is the behaviour of nn_term well defined when the underlying threads are already dead (or rather 'not existing') ? It might be better to simply clean up the resources rather than trying to notify and join the dead threads.\nthat's exactly what it does, it's like nn_close() on steroids\n\nThe only issue I see would be to have a thread doing some blocking I/O while owning a lock. --  this would make fork() an excruciatingly slow operation\n\ninteresting notion, i never thought of that particular angle, but I knew fork() was slow.\nOK my opinion on the subject... having a set of initialized processes running for task absorption before hand is one thing.. they're already setup. but needlessly making high latency calls to fork and exec because it's already too late... that's something different. there's a prohibitive amount of upfront startup latency associated with new process or fork spinup.. so do it early if u have to\nand don't do it again during end-user application experience lifecycles\n. heh, @wirebirdlabs i didnt even read \"same\" until you wrote that\n. Yes but I thought linger was designed to be only a simpler interface to UNIX socket option SO_LINGER:\n\nWhen enabled, a close(2) or shutdown(2) will not return until all queued messages for the socket have been successfully sent or the linger timeout has been reached.  Otherwise, the call returns immediately and the closing is done in the background.\nWhen the socket is closed as part of exit(2), it always lingers in the background.\n. @djc \n\nreview?\n. one of the windows machines seems to be timing out on a device test, looks unrelated IMO\n. thanks @djc! \nnow that will help us downstream expose libnanomsg websocket options to node.js :droplet:\n. Moving to CMAKE exclusively won't break compiling for iOS, will it?\n. > I will be helping upgrade to the CMake build system, but I'm not tooled up to test iOS. Would you help validate it does go smoothly once we get it into mainline?\nYes definitely, I'll be closely tracking that.\nFWIW here's the current working shell script i use: https://gist.github.com/reqshark/20c38286d332f1bdf7605908f05c0b86 \n\nI'm almost certain that CMake knows about iOS natively these days\n\nOK thanks guys, good to hear :)\n. when msgs are few and far between endpoints, low latency delivery between send and recv I/O is ideal.\n\nWhy do you think keepalive has anything to do with wakeup?\n\nI use the term wakeup to describe additional time spent recognizing the need for I/O, for long running idle subscribers. In that case, I've used an interval of small sz msgs to reduce what I call wakeup latency\n\nKeepalives are handled in the kernel generally, and do not pass up to the application. Their purpose is to ensure that a minimal amount of traffic is seen on otherwise idle TCP connections.\n\nWhile that sounds very efficient to me, I would be willing to sacrifice resources required to process additional traffic on an otherwise idle TCP connection, if that is the cost of immediate transport I/O for the rare and infrequent msg recv--IMO a suitable resource allocation and expense. \n. > Better if your app needs this that you do a heartbeat in the application code itself\nwell yeah, that's what i end up doing.\n\n..making sure that both TCP Nagle is disabled and any interrupt moderation at the NIC is turned off.\n\nI set tcpnodelay option for the use case, but I didn't know about interrupt moderation at the NIC.. I'm going to have to do some research now.\n\nBtw what are your latency requirements?\n\nUnfortunately, we deploy across today's lowest performing networks.. often deep into last mile DSL\nSo while writing said interval solves the application problem well, I thought my user land experience might be common to a few others, and without question improved by a library socketopt. \n\nsounds like a new message type. \n\nI disagree, I think it's a TCP transport option.\n\nI'm not in favor of this. It would add substantial complexity\n\nlet's not add complexity to an area already rife with it, I'm just about ready to drop the issue, unless other people using the library might find it useful too.\n. thanks @gdamore!\n. > might even lean so far as wanting to block within nn_bind()\n+1, optionally blocking bind and connect calls for TCP would be nice\n. you mean websocket right\n. sure, but tests extend documentation beyond coding example.. they detail your and other author assumptions, intent about the API and how it should be used\n. ok thanks for the explanation, that makes sense\n. @gdamore this is great! wow, cool msg control headers. Thank you! \n:)\n. yea i wouldn't even try to add poller.c to the list of files for compiling on windows\n. nice catch @museghost!\nwhile ctest -G Debug . works only on unix, it seems ctest -C Debug . works on both platforms :)\n. yea i was hesitant at first because i thought you developed on osx, but it happens on both my macs.\nwhat happens when you run ctest -G debug; or ctest -C debug; ?\n. here's the isolated test output:\n``` go\nStart testing: Jun 20 19:44 PDT\n\n41/42 Testing: reqttl\n41/42 Test: reqttl\nCommand: \"/Users/bent/nanomsg/build/reqttl\" \"5900\"\nDirectory: /Users/bent/nanomsg/build\n\"reqttl\" start time: Jun 20 19:44 PDT\nOutput:\n\nFailed bind to \"tcp://127.0.0.1:5900\": Address already in use [48] (/Users/bent/nanomsg/tests/reqttl.c:71)\n\nTest time =   0.10 sec\n\nTest Failed.\n\"reqttl\" end time: Jun 20 19:44 PDT\n\"reqttl\" time elapsed: 00:00:00\n\nEnd testing: Jun 20 19:44 PDT\n```\nlooks like i might need SO_REUSEADDR, what do you think?\n. oh nevermind, sorry i needed sudo permissions to open AF_SP_RAW\nwhen i run the test with sudo it passes\n. to me it feels more like EADDRINUSE but yea it's also EACCESS\n. > port 5900 shouldn't require sudo to bind to -- unless it's a port of a known OS X service?\ni agree with you, it's not a sudo/permissions thing\nsudo would only make sense if all AF_SP_RAW sockets required sudo\nso it seems more like a port use issue, since now without using sudo i see the test pass...\n. > If that's the only issue, we can just change the base port.\nRFB uses 5900 by default https://en.wikipedia.org/wiki/RFB_protocol\n```\nPort Scan has started\u2026\nPort Scanning host: 127.0.0.1\n Open TCP Port:     22          ssh\n Open TCP Port:     88          kerberos\n Open TCP Port:     5900        rfb\n Open TCP Port:     31083\n Open TCP Port:     31084\n\nPort Scan has completed\u2026\n```\n. thanks @Snaipe!\n. I pass my own buffers\n. I would profile their removal and confirm the performance benefit first\n. it would be a shame to muck up git blame on account of style. Style changes should only happen as far as need demands changes to operative logic\n. fair enough\n. That's interesting to raise the idea of a nanomsg socket being compatible with a different socket protocol at the same endpoint address. > What you probably want is to be able to reuse the TCP port, which can be done with another qualifying element (such as a path component for a URI in websocket). Allowing multiple protocols / sockets to share a single TCP port number is definitely in the cards; sharing the entire address is not.\n@gdamore yea, that makes sense a lot more sense, I just thought that idea was interesting mostly out of curiosity, certainly not based on any real use case. Keep in mind that (probably for reasons of security), socket network API calls are not implemented for web browser JavaScript. \nThat means many of this library\u2019s system headers will not be accessible by the emscripten compiler, and therefore I would expect emscripten to throw a bunch of compiler errors if your application code tries to include Nanomsg headers or lib symbols. Hmm, that\u2019s an interesting anecdote, I didn\u2019t realize emscripten succeeded in mapping POSIX network calls to websocket. \nHeh well... full disclosure: I tried to do that a couple years ago so it sounds like maybe it\u2019s possible now! :)\nCan the emscripten linker actually translate a compiled network library\u2019s symbols back to websocket? . \n\nEmscripten supports libc networking functions but you must limit yourself to asynchronous (non-blocking) operations. This is required because the underlying JavaScript networking functions are asynchronous.\n\n-- from the wiki\nyea their limitation statement the C networking API is extremely vague. \ni gave up trying to make emscripten work with nanomsg some time ago. I never got it to work and even spent a good all nighter or two trying, things might have changed since then, but I kinda doubt it. browser functionality is accessed through the Web APIs defined by the Web Platform\nyou would think that consortium, whose user interface and fundamental runtime is etched into request/response cycles over remote networks would be more keen on socket protocols. what are opcode's PING and PONG for? Are they used for the handshake?\n. unhyphenated removes a character without meaning, so ya I'm gonna have to vote for online\n. ",
    "metadings": "Sure... hello Microsoft ;) I'm really glad and impressed how easy you made it to compile, the bad is I'm on x86 with VS2010 and that doesn't have a cross-compiler (afaik). My machine is also just not built for virtualization and the like.\nThanks for your work! I'm working with and for the C# binding NNanomsg.\nI currently made my polling Listener loop like this\ncsharp\n  while (!cancellor.IsCancellationRequested)\n  {\n    nanoListener.Listen(TimeSpan.FromMilliseconds(250));\n  }\nwhich can be cancelled using cancellor.Cancel().\nHowever the nn_device doesn't have a timeout, so I can just spawn a Thread which has to be aborted, or it is being terminated using nn_term. \nWhat about a timeout for nn_device's, just like nn_poll, too? nn_term is like kill, but how about just terminating single devices, either using a handle, a returncode like a socketId, or with a timeout to poll, which I can cancel every while?\n. Messing with Google I found three pastes, but they are full of \"I tried here and I'm waiting forever there\".\nhttp://pastebin.com/rqpdaQmH \"nanomsg REP/REQ example with threads\"\nhttp://pastebin.com/GQq6vPkX \"nanomsg REP/REQ example with threads client code\"\nhttp://pastebin.com/j8naGfuD \"nanomsg REP/REQ example with threads\"\nhttp://pastebin.com/3JL2Y7wh \"nanomsg REP/REQ example with threads\"\nWhich do you refer to?\n. It's weird trying to bind and connect around. It should be easier.\nIt should be that we spawn some REP workers, all binding on one port and when a REQ comes in, the first REP is dispatched and the next worker is going to wait on the next REQ. Just like in HTTP, port 80 is just a door in and answers go another door out.\nWait: I'm really impressed how easy it was to compile nanomsg-0.4-beta (sadly I'm just on Win x86)!\nI'm now going to bind myself on a walk around the city, I hope someone starts a connect. ARGH\n. No it just keeps confusing, weird and annoying.\nHas anyone a working example of multiple worker threads REPlying on multiple REQuest threads?\n. Yeah, also had some issues because of MemoryStream Seek, WriteTo, Flush and Close resulting in nonsense exceptions.\nNow it's doing a good job, so far I can see. Thanks for your help!\nIt is now as follows:\n1. Create a RAW REP Socket, bind it to port 4444.\n2. Create a RAW REQ Socket, bind it to port 4445.\n3. Create and start a thread for the device to combine both sockets.\n4. Create and start worker threads, with REP sockets, which connect to 4445.\n5. Create client threads, with REQ sockets, which connect to 4444.\nA bit of confusing is also the difference in (NNanomsg) SendStream/SendStreamImmediate and ReceiveStream/ReceiveStreamImmediate: The *Immediate methods are using NN_DONTWAIT, and I ended up using these methods inside of polling callbacks (receiving the REQuest, receiving the REPly), and the non-Immediate methods when I'm sending the REQuest, sending the REPly.\nNow I'm just missing a nn_device which takes a timeout, so I can poll and break without having to kill it using NN.Term.\nAlso have a look for the example: https://github.com/mhowlett/NNanomsg/issues/14#issue-36810377\n. Yes, I've got that exception very rarely and at random too (have a REQ connecting to a device (REP RAW to REQ RAW) with workers connecting REP to the device over inproc.\nI'm on Win7 x86 with nanomsg 0.4-beta.\n. It's a bit weird: after nn_term an nn_poll'ing worker gets a POLLIN event, tries to receive and then terminates with EINVAL. After that, the next worker trying to nn_poll terminates with EPERM.\n. I also see PUB/SUB dropping many messages.\nNot just inproc but also tcp. inproc is better, with a Thread.Sleep(128ms) it's even better, but it drops some messages too. No error, nn_send returns valid int sentBytes...\n. Yes, I'm running Win7 x86 with VS2010\n. Man this is so cool. When do you think this can be thrown into the wide wild world?\nI'm just discovering the difference in bind (passive, one waiting on sth.) and connect (active, many awaiting sth.), which to say can be applied to any? or all? of the protocols.\nI think this knowledge will be crucial to understand nanomsg!\n. Well I'm not a fluent C'itizen, actually by reading libraries like these I'm warming up with it.\n. Hey Martin,\nI wonder which IDE you use, or are you working in just-a-good editor?\nTrying to compile on ubuntu amd64, it looks like it finally did, but I'm not really sure about which .so file I've got - is it 64bit, that libnanomsg.so.0.2.0 in the .lib folder?\nIs there a separate .pdb or .mdb symbols file, or is --enable-debug being built into the binary? \nHow do you compile a 32bit binary on a 64bit system, and where is that file being built to? \nWhat I've tried was like this askubuntu answer (1), but that file had just ~300KB, compared to ~1,4MB file when I didn't export these vars before configure and make. Is this answer (2) or this stackoverflow answer (3) the way to go? I just installed gcc-multilib, do I also need g++-multilib?\n. > I'm working from command line.\nLuke: NOOOOoooooooo.....\n\nYou can install it using 'sudo make install'. \n\nJust want the library for now.\nWhich host/build-types do you recommend? I'm now using ./configure --enable-debug --build\n- x86_64-pc-linux-gnu \n- and i686-pc-linux-gnu \nwith make -B which both result in a libnanomsg.so.0.2.0 ~626,9KB ...\nWell I see line numbers say nothing... The aborting assert is in these lines:\n``` C\nwhile (1) {\n    /*  Wait for network events. */\n    rc = poll (pfd, 4, -1);\n    errno_assert (rc >= 0); // here the program aborts because of EINTR\n    if (nn_slow (rc < 0 && errno == EINTR))\n        return -1;\n    nn_assert (rc != 0);\n\n```\nHow to solve this?\n. Now I did it like this:\n``` C\nwhile (1) {\n    /*  Wait for network events. */\n    rc = poll (pfd, 4, -1);\n    if (nn_slow (rc < 0 && errno == EINTR))\n        continue;\n    errno_assert (rc >= 0);\n    nn_assert (rc != 0);\n\n```\nBut now the EINTR aborts in these lines (nn_device_mvmsg):\n``` C\n    rc = nn_recvmsg (from, &hdr, flags);\n    if (nn_slow (rc < 0 && nn_errno () == ETERM))\n        return -1;\n    errno_assert (rc >= 0); // here\n// device->nn_device_rewritemsg ...\n\nrc = nn_sendmsg (to, &hdr, flags);\nif (nn_slow (rc < 0 && nn_errno () == ETERM))\n    return -1;\nerrno_assert (rc >= 0); // and here likely too\n\n```\nAny thoughts? \nI don't get it, being not sure what I'm doing at all. Now I'm also checking for EINTR in mvmsg, returning -1 (instead of continue or goto again), but this just distributes the one errno up to my mono program. No matter how often I retry, it just doesn't work. \nWhy? What should I look for?\n```\nNative stacktrace:\n/usr/bin/mono() [0x4b73d8]\n/lib/x86_64-linux-gnu/libpthread.so.0(+0x10340) [0x7fb307805340]\n/lib/x86_64-linux-gnu/libc.so.6(gsignal+0x39) [0x7fb307465f79]\n/lib/x86_64-linux-gnu/libc.so.6(abort+0x148) [0x7fb307469388]\n/home/metadings/---/x64/libnanomsg.so(nn_err_errno+0) [0x7fb304117ca5]\n/home/metadings/---/x64/libnanomsg.so(nn_device_mvmsg+0x109) [0x7fb304132097]\n/home/metadings/---/x64/libnanomsg.so(nn_device_oneway+0x30) [0x7fb304131f72]\n/home/metadings/---/x64/libnanomsg.so(nn_device_entry+0xb69) [0x7fb304131b11]\n/home/metadings/---/x64/libnanomsg.so(nn_custom_device+0x2a) [0x7fb304130f7d]\n/home/metadings/---/x64/libnanomsg.so(nn_device+0x27) [0x7fb304130fa6]\n[0x403cb16e]\n\n```\nHoly backspace, I'm looking in the wrong procedure. \nNo way. Don't get it. Hope you have a hint, I'm out now. \n. I made a remake of device.c in managed code...\n1. Device Setup: RAW REP \"frontend\", RAW REQ \"backend\", both sockets polling IN | OUT\n   (pollset revents start with 2, 0)\n2. Replier Setup: REP connecting to backend, polling IN (device pollset is 2, 2)\n3. Requestor Setup: REQ connecting to frontend\n4. Requestor sends REQ, going to poll IN (device pollset is 3, 2)\n5. Device receives frontend IN, sends to backend\n6. Replier receives REQ, sends REP (device pollset is 2, 3)\n7. Device receives backend IN, sends to frontend\n8. Requestor never receives the REP, just loops with poll returning EINTR\n9. After 30s Device is repeating (5.) with the original message.\n(POLLIN = 1) and|or (POLLOUT = 2)\nAny ideas?\nSearching google for \"poll EINTR\", the 2. result is EINTR and What It Is Good For\nFeel free to tell me if you're getting upset with me, for example because (just) mono is my problem?\n. Abandoning the polling for IN and OUT states by using nested whiles to send/receive receive/send, it is running into never ending errno EFSM, with and without DONTWAIT. The device has often to be restarted because of EINTR. Sorry that I can't help in C, this is driving me crazy.\nWhat I made in C is the following tests/device_adv.c, which should represent my program and the test passes, so I think now it's definitively an issue in combination of nanomsg + mono runtime... \nDo you think this should(/can) be solved?\n``` C\ninclude \"../src/nn.h\"\ninclude \"../src/reqrep.h\"\ninclude \"testutil.h\"\ninclude \"../src/utils/attr.h\"\ninclude \"../src/utils/thread.c\"\ndefine SOCKET_ADDRESS_A \"inproc://a\"\ndefine SOCKET_ADDRESS_B \"inproc://b\"\ndefine MESSAGES_TO_TRY 5\nvoid device1 (NN_UNUSED void *arg)\n{\n    int rc;\n    int deva;\n    int devb;\n/*  Intialise the device sockets. */\ndeva = test_socket (AF_SP_RAW, NN_REP);\ntest_bind (deva, SOCKET_ADDRESS_A);\ndevb = test_socket (AF_SP_RAW, NN_REQ);\ntest_bind (devb, SOCKET_ADDRESS_B);\n\n/*  Run the device. */\nrc = nn_device (deva, devb);\nnn_assert (rc < 0 && nn_errno () == ETERM);\n\n/*  Clean up. */\ntest_close (devb);\ntest_close (deva);\n\n}\nvoid worker1 (NN_UNUSED void arg)\n{\n    int rc;\n    int sock;\n    / int interval = -1; /\n    / struct nn_pollfd pfd [1]; /\n    int retry = MESSAGES_TO_TRY;\n    / char buf [3]; */\n/*  Initialise the socket. */\nsock = test_socket (AF_SP, NN_REP);\ntest_connect (sock, SOCKET_ADDRESS_B);\n\n/*  Initialise the pollset *\npfd [0].fd = sb;\npfd [0].events = NN_POLLIN | NN_POLLOUT; */\n\n/*  receive */\nwhile (retry > 0) {\n    test_recv(sock, \"ABC\");\n\n    /*  send */\n    while (1) {\n\n        test_send(sock, \"CBA\");\n        break;\n    }\n\n    --retry;\n}\n\n/*  Clean up. */\ntest_close (sock);\n\n}\nint main ()\n{\n    int sock;\n    struct nn_thread thread1;\n    struct nn_thread thread2;\n    int retry = MESSAGES_TO_TRY;\n/*  Start the device. */\nnn_thread_init (&thread1, device1, NULL);\n\n/*  Start the REP worker. */\nnn_thread_init (&thread2, worker1, NULL);\n\n/*  Do REQ work */\n\n/*  Initialise the socket. */\nsock = test_socket (AF_SP, NN_REQ);\ntest_connect (sock, SOCKET_ADDRESS_A);\n\n/*  send */\nwhile (retry > 0) {\n    test_send(sock, \"ABC\");\n\n    /*  receive */\n    while (1) {\n        test_recv(sock, \"CBA\");\n\n        break;\n    }\n\n    --retry;\n}\n\ntest_close(sock);\n\n/*  Cleanup */\nnn_term();\n/* nn_thread_term(&worker1); */\nnn_thread_term(&thread1);\n\nreturn 0;\n\n}\n``\n. moving 'bug777.c' into 'inproc_noclose.c'.... Just to move namesbug777(toinproc_noclose.c) andbug328(topair_tcp.c).. Well, I thought it is bad, if you have abuilddirectory with new commandsbug328,bug777.\nI don't know about bugids, where are these bugids defined?. well... Should I name themissue*.c`?. ",
    "walkr": "I'm getting the exact same error when trying to start a bunch of servers in rapid succession.\nThey are all running on different tcp endpoints.\nSometimes they do start, but most of the time I get the error, namely: \"Unexpected source: state=1 source=1 action=1 (src/aio/timer.c:141)\"\nI'm running OS X Mavericks, btw, and nanomsg 0.4-beta.\n. I've just tested on OS X Yosemite with nanomsg 0.6-beta and it looks like it is not a problem anymore.\nHere are the tests I've used: nanoservice-start-tests\nCheers\n. ",
    "errzey": "I am submitting this patch under the MIT license. :)\n. ",
    "lcm337": "No. That is the clarification I was missing.\nThis zero copy term seems to be banded about by a few libraries and always confuses me. I'm going to think of it as YouCopy!\nThanks for the reply.\n. ",
    "jchedstrom": "Seeing this on ARMv7 (Zybo development board) running Ubuntu 12.04, Kernel 3.14. \nNanomsg package version 0.5-beta-73-g2da0726\nipc_shutdown check only failed first time. Tried 5 times afterwards which passed.\nsrc=0 type=33988\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (src/core/sock.c:830)\n/bin/bash: line 5: 30712 Aborted                 ${dir}$tst\nFAIL: tests/ipc_shutdown\n. ",
    "ddway2": "i have the same behavior on linux debian with nanomsg 0.4 in IPC mode. Packet are dropped in flood mode\n. After somes tests, i can clarified my behavior:\n- when i used 1 subscription (tag), IPC flood work fine\n- when i used 2 or more subscriptions, IPC flood drop some packet\n. For information, issue #320 not resolve problem\n. Hi\nSorry for waiting, i need some time to make a good example\nIn my context, i have 2 sub connected to one publish. I used polling mode to retreive data from sub socket.\n/*\n    Copyright (c) 2012 250bpm s.r.o.  All rights reserved.\n```\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom\nthe Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n```\n*/\ninclude \"../src/nn.h\"\ninclude \"../src/pair.h\"\ninclude \"../src/pubsub.h\"\ninclude \"../src/ipc.h\"\ninclude \"testutil.h\"\ninclude \"../src/utils/attr.h\"\ninclude \"../src/utils/thread.c\"\ndefine SOCKET_ADDRESS \"ipc://test_subscribs.ipc\"\ndefine BATCH_SEND 1000\nint sub1;\nint sub2;\nint s;\nint done = 0;\nstruct nn_pollfd pfd [2];\nvoid routine(NN_UNUSED void arg)\n{\n    int rc;\n    int expected_count = 0;\n    void buf = NULL;\n```\nwhile ((expected_count < BATCH_SEND) && (done == 0)) {\n    rc = nn_poll(pfd, 2, 1000);\n    nn_assert(rc >= 0);\nif (rc > 0) {\n    if (pfd[0].revents & NN_POLLIN) {\n        rc = nn_recv(pfd[0].fd, &buf, NN_MSG, NN_DONTWAIT);\n        while(rc >= 0) {\n            nn_freemsg(buf);\n            ++expected_count;\n            rc = nn_recv(pfd[0].fd, &buf, NN_MSG, NN_DONTWAIT);\n        }\n\n        if (rc < 0)\n        {\n            printf(\"Error: %d\\n\", errno);\n        }\n    }\n    if (pfd[1].revents & NN_POLLIN) {\n        rc = nn_recv(pfd[1].fd, &buf, NN_MSG, NN_DONTWAIT);\n        while(nn_recv(pfd[1].fd, &buf, NN_MSG, NN_DONTWAIT) > 0) {\n            nn_freemsg(buf);\n            ++expected_count;   \n            rc = nn_recv(pfd[1].fd, &buf, NN_MSG, NN_DONTWAIT);\n        }\n    }\n}\n\n}\nnn_assert(expected_count == BATCH_SEND);\n```\n}\nint main ()\n{\n    int pub;\n    int rc;\n    int counter;\n    int i;\n    int recv_tmp;\n    int recv_expect;\n```\nstruct nn_thread thread;\npub = test_socket (AF_SP, NN_PUB);\ntest_bind (pub, SOCKET_ADDRESS);\nsub1 = test_socket (AF_SP, NN_SUB);\nchar tag0 = 0;\nchar tag1 = 1;\nrc = nn_setsockopt (sub1, NN_SUB, NN_SUB_SUBSCRIBE, &tag0, 1);\nerrno_assert (rc == 0);\nsub2 = test_socket (AF_SP, NN_SUB);\nrc = nn_setsockopt (sub2, NN_SUB, NN_SUB_SUBSCRIBE, &tag1, 1);\nerrno_assert (rc == 0);\npfd[0].fd = sub1;\npfd[0].events = NN_POLLIN;\npfd[1].fd = sub2;\npfd[1].events = NN_POLLIN;\ntest_connect (sub1, SOCKET_ADDRESS);\ntest_connect (sub2, SOCKET_ADDRESS);\n/ Wait for connection to establish. /\nnn_sleep (10);\nnn_thread_init(&thread, routine, NULL);\ncounter = 0;\nfor (i=0; i<BATCH_SEND; i++) {\n    if (i==BATCH_SEND-1) {\n        / Wait before sending the last one. /\n        nn_sleep (50);\n    }\nchar buf[4];\nbuf[0] = (counter % 2) & 0xFF;\nbuf[1] = 'A';\nbuf[2] = 'B';\nbuf[3] = 'C';\n\nrc = nn_send (pub, buf, 4, 0);\nnn_assert (rc == 4);\ncounter++;\n\n}\nnn_sleep(5000);\ndone = 1;\nnn_thread_term(&thread);\n// recv_expect = 0;\n// for (i=0; i<BATCH_SEND / 2; i++) {\n//  rc = nn_recv (sub1, &recv_tmp, sizeof(recv_tmp), 0);\n//  nn_assert (rc == sizeof(recv_tmp));\n//  / Before fix, would only see first and last message. /\n//  nn_assert (recv_expect == recv_tmp);\n//  recv_expect++;\n// }\n// recv_expect = 0;\n// for (i=0; i<BATCH_SEND / 2; i++) {\n//  rc = nn_recv (sub2, &recv_tmp, sizeof(recv_tmp), 0);\n//  nn_assert (rc == sizeof(recv_tmp));\n//  / Before fix, would only see first and last message. /\n//  nn_assert (recv_expect == recv_tmp);\n//  recv_expect++;\n// }\ntest_close (sub1);\ntest_close (sub2);\ntest_close (pub);\nreturn 0;\n```\n}\n. ",
    "bennykj": "We have the same issue. We are trying to implement an MJPEG server with the image capture module communicating with the HTTP module via nanomsg.\nImage capture is fast and sends data at a higher rate, byt HTTP module is slow.  We are seeing partial JPEG frames at the client. I think nanomsg is dropping some packets..\nDo you have a fix for this we can test?\n. ",
    "dcharbon": "I ran into this with exact same error message and abort. The cause was creating a REP socket bound to the inproc url, creating a REQ socket connected to that inproc url, shutting down and closing the REP socket, then creating a new REP socket bound to the same inproc url.\nThe fix - make sure that any connected REQ sockets were closed before binding a new REP socket to that address. It's the REQ socket aborting due to the unexpected state of the newly bound REP socket to that address, not the REP socket failing on bind.\n. ",
    "baxtersa": "Just an FYI, this appears to be the same issue I was seeing in the crash for #411.  This specific issue should be fixed by pull request #416  if anyone is still interested and wants to check it out.\n. Addressed by pull request #409 \n. Thanks for the feedback.\nDiscarding the reliance on ASCII strings, how would you feel about messages prepended with the size of the following binary stream?  Would you contend that it's the user's responsibility to construct the data in that way and not nanomsg's?\nI obviously wouldn't want to change the wire protocol for the existing message types, but maybe a more self describing nn_iovec struct that kept an array of buffer lengths for each iov would allow additional information to be sent with the message so that there's enough information on receive to decompose the single squished buffer into its components.\nSuch a message could still be exchanged with peers using fixed size iovs, but would allow the flexibility I'm trying to accomplish with this pull request.\n. @gdamore , if you could, let me know if this is a more promising path to go down.  I'd like to be able to work something out, but if this is a hopeless endeavor I'll stop pursuing it as a pull request and bring it into my project's code.\nIf you agree with the potential benefits and think it's worth spending more time on, I'll add some more tests and protection on the nn_recvmsg side against reading bogus buffer sizes.\n. > Btw, what is really your motivation here?\nMy motivation is my intuition about the ease of use of this API.  It seems natural to me that if you can send a message via multiple vectors, you should be able to receive the message in the same format as which it was sent (and without having to know the length of the incoming vectors or alternatively having to reallocate/copy).\n\n(In other words, why and how is splitting the data into fixed sized \u201cportions\u201d useful to you?)\n\nWe're trying to use nanomsg to send commands across instances of our application.  We think it would be convenient to be able to send discretized messages containing a variety of metadata and potentially multiple data buffers as separate vectors.  This would eliminate the need in client code to parse an unknown bitstream for metadata tags and could ease debugging of receiving such messages.\n. Should this be implemented for ipc transport as well?  It's a similar connection-base transport where a failed bind attempt still tries to reconnect in the background, correct?\nAlso, I've cherry-picked this pull-request into some local code, and I get crashes if the first bind fails and then I call nn_close on the socket because even with this nn_geterror function, there's no way to shut down the reconnect timer in the background.  Is that perhaps worth implementing alongside this function?  Was this pull-request intended to address issue #404?\n. Sounds good to me.  I'm going to look into the nn_close crash locally and see how far I can get on a fix.  I'd welcome any and all help though, as this is my first dive into nanomsg's fsm logic :).\n. Thanks @vseryakov !  This seems to be working.\nI've got ipc transport working, so once this is merged I'll open up a pull-request for that.\n. As I commented in #413 , this doesn't seem to be working on Windows.  Are you already looking into this?  I'm getting started on trying to figure this out for IPC now.\n. I have a separate pull request open for IPC transport, so I agree with only dealing with TCP logic here.  But unfortunately it looks like TCP isn't working on windows.  Once it is, I say we merge some things.\n. The error isn't too enlightening as to what the problem is.  We're failing \nnn_assert(nn_geterror (sc, rc) != 0);\non line 130 of the tcp.c test file.  Disabling that assert, we seem to still fail the other nn_assert (nn_geterror (,) _) tests you've added.  It seems like Windows Socket errno gets set differently than Unix errno.  If I had to guess, I'd start looking at usock_win.inc, because that's where the low level system calls live, but that's just a hunch.\n. Well, good news is changing the sleep time to a 1500 milliseconds seems to fix this issue for tcp.  Bad news is 1500 milliseconds is a long wait, and this doesn't seem to fix the issues with my separate ipc pull request.  If you could change those sleep times for this pull request this should be ready to merge.\n. TCP does, but @vseryakov has an open pull request #410 that addresses that transport.  I don't know about ws or tcpmux as I'm tracking the most recent beta release with some cherry-picked commits, not master.\n. Before we merge this in, it looks like this and #410 fail on windows due to some os differences in how they set errno's for named pipes.  I'm not familiar with Windows system calls at all, but I'm starting to look into it myself.  If you're more familiar I'd gladly appreciate the help.  I'll comment on the TCP pull request as well.\n. Sorry, looks like those inproc changes are whitespace issues.  I'll make the change when I have time to get around to it, don't know how soon that will be though as I'm getting close to a release at work.\n. Not a problem.  Even if this doesn't get merged this week, if I could get some feedback that would be great.\n. TCP takes time for the connection to finish.  If you're not waiting long enough, you can start sending messages before anyone is fully connected, leading to dropped messages and the appearance that nanomsg is broken.  If you look at the tcp tests, they're littered with nn_sleep() calls after binds and connects before any send/receive calls.  Try sleeping for a couple hundred milliseconds after respondent3 connects and see if that fixes your issue, it did for me locally.\n. Would it be possible to get a backtrace on the nn_fsm_isidle assertion failure?  Is that the fsm of the tcp socket's retry timer?\n. You may want to cherry-pick the commits from open pull-request #410\nhttps://github.com/nanomsg/nanomsg/pull/410/commits.  For whatever\nreason, it is yet to be merged, but should address this crash.  We have it\ncherry-picked into our fork and it is the correct fix for the issue.  Maybe\nit got missed in the 0.6 beta release?\n- Sam\nOn Mon, Sep 21, 2015 at 12:30 PM, Roland Young notifications@github.com\nwrote:\n\nI can reliably trigger an abort in nn_shutdown by running two instances of\na server program, where one instance binds to a port and waits and the\nother instance tries to bind to the same port and then disconnects.\ninclude \ninclude \ninclude \"nn.h\"\ninclude \"pubsub.h\"\nint portclash(const char *url, int delay)\n{\n    int sock = nn_socket(AF_SP, NN_PUB);\n    if (sock < 0)\n    {\n        fprintf (stderr, \"Failed to create nanomsg socket. Errno: %d\\n\", errno);\n        return 1;\n    }\n    int eid = nn_bind(sock, url);\n    if (eid < 0)\n    {\n        fprintf (stderr, \"Failed to bind nanomsg socket to %s. Errno: %d\\n\", url, errno);\n        return 1;\n    }\n    printf (\"Bound to %s, eid = %d\\n\", url, eid);\n```\nusleep(delay * 1000);\nif (sock >= 0 && eid >= 0 && nn_shutdown(sock, eid) < 0)\n{\n    fprintf (stderr, \"Failed to shut down nanomsg socket. Errno: %d\\n\", errno);\n    return 1;\n}\nprintf (\"Finished OK\\n\");\nreturn 0;\n```\n}\nint main(const int argc, const char **argv)\n{\n  if (argc == 2)\n    return portclash(argv[1], 5000);\n  else if (argc > 2)\n    return portclash(argv[1], atoi(argv[2]));\n  else\n  {\n    fprintf (stderr, \"Usage: portclash url [delay_millis]\\n\");\n    return 1;\n  }\n}\nThe program is run like this portclash tcp://*:7070 250\nIf I start one copy of this program with the default delay of 5 sec and\nthen start another on the same url with a delay of 250ms (say), the second\nwill crash with the following traceback:\nProgram terminated with signal 6, Aborted.\n0  0x000000353f230265 in raise () from /lib64/libc.so.6\n(gdb) where\n0  0x000000353f230265 in raise () from /lib64/libc.so.6\n1  0x000000353f231d10 in abort () from /lib64/libc.so.6\n2  0x00000000004073a9 in nn_err_abort () at src/utils/err.c:33\n3  0x0000000000405f54 in nn_timer_term (self=0x1b942ba8) at src/aio/timer.c:62\n4  0x0000000000413b91 in nn_btcp_destroy (self=) at src/transports/tcp/btcp.c:205\n5  0x000000000040dde6 in nn_ep_term (self=0x1b9427a0) at src/core/ep.c:88\n6  0x0000000000405775 in nn_sock_handler (self=, src=, type=,\nsrcptr=<value optimized out>) at src/core/sock.c:927\n\n7  0x0000000000405976 in nn_ctx_leave (self=0x1b9425b8) at src/aio/ctx.c:63\n8  0x00000000004046e7 in nn_sock_rm_ep (self=0x1b942540, eid=1) at src/core/sock.c:533\n9  0x00000000004025e6 in nn_shutdown (s=, how=) at src/core/global.c:685\n10 0x0000000000401c8b in portclash (url=0x7fff1d0b6845 \"tcp://*:7070\", delay=250) at portclash.c:24\n11 0x0000000000401d33 in main (argc=3, argv=0x7fff1d0b5038) at portclash.c:38\nMy impression is that the retry timer associated with a btcp object is\nused for two purposes, only one of which is consistent with the assumption\nin nn_btcp_destroy that if the btcp state is IDLE then it is safe to call\nnn_backoff_term\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/463#issuecomment-142035375.\n. Yea, that could be it. It would be worth splitting up so that the bugfix\nand feature can get merged if that's all it takes, this seems like a pretty\nbad crash to have hanging around when we have a fix just sitting there. Is\nthat something I can take care of (even though they aren't my commits) or\nsomething a maintainer (@gdamore?) needs to do?\n\nOn Mon, Sep 21, 2015 at 1:09 PM, Wirebird Labs LLC <notifications@github.com\n\nwrote:\nFor whatever reason, it is yet to be merged\nPerhaps since the PR contains both a bugfix and a new feature? Both seem\nsolid, quality work, but since coupled together makes it a bit harder for\nmaintainers to evaluate/merge individually.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/463#issuecomment-142044934.\n. We can add some more checks in here to assert things such as iov->iov_len == NN_MSG before we read the length prefix, or ensuring that our accumulated iov_len's aren't > our total chunk size.\n. \n",
    "mocksoul": "duplicate of https://github.com/nanomsg/nanomsg/issues/235\n. ",
    "eglimi": "Hi Martin,\nSure, I'll create a pull request.\n. I moved the code into global.c. I hope this is the right place.\nAlso, I tried to add a test case for the control information, but couldn't get the code to run. Is there a complete example how to use the nn_cmsg?\nBut I wanted to submit the PR for review even without the tests.\n. Hi @sustrik\nhas this change a chance of being merged? I can always refactor it if required. Thanks!\n. @djc Thank you for the quick reply.\nI'm currently working on an application for a satellite that uses a framework which is ANSI C. I use nanomsg for the testing infrastructure only, so strictly speaking there is no requirement for ANSI C for this particular part. However, since I compile the test application together with some parts of the framework, I wanted to stick with ANSI C.\nSince it seems that this is the only part of nanomsg which is not ANSI C, I thought it might be good to change that.\nI understand that inlining can be a performance improvement. But I assumed it is ok for this function, since many other functions which are used more often are not inlined as well.\nLet me know what your decision is and if I can help with anything. Thank you.\n. ",
    "rektide": "You'd better post the ZMQ version too.\nAlso, in your Receive, try using NN_MSG to have nanomsg do the allocation for you. It could help, could avoid needing to copy into buf. I'd also like to compare between your 4K max send size and a run that only sends 1K (256 ints).\n. ",
    "wuz73": "Here is the zmq version:\n\n#include \"../include/zmq.h\"\n#include <cstdio>\n#include <unistd.h>\n#include <cstring>\n#include <cassert>\n#include <pthread.h>\n#include <sys/time.h>\nvoid* Send(void* context)\n{\n    void *responder = zmq_socket(context, ZMQ_PAIR);\n    zmq_connect(responder, \"inproc://test\");\n    char buf[1024];\n    unsigned long bytes = 0;\n    int sz[] = { 16,32,64,96,128,160,192,224,256,384,512,768,1024};\n    int p =0;\n    for (unsigned count = 1048576; count--;)\n    {\n    unsigned len = sz[p];\n        zmq_send(responder, buf, len, 0);\n    bytes += len;\n    p = (p+1) % (sizeof(sz)/sizeof(sz[0]));\n    }\n    zmq_send(responder, buf, 0, 0);\n    printf(\"sent %lu bytes\\n\", bytes);\n    zmq_recv(responder, buf, sizeof(buf), 0);\n    zmq_close(responder);\n    return NULL;\n}\nvoid* Receive(void* receiver)\n{\n    char buf[1024];\n    unsigned long bytes = 0;\n    while (1)\n    {\n        int len = zmq_recv(receiver, buf, sizeof(buf), 0);\n    if (!len)\n        break;\n    if (len < 0)\n    {\n        perror(\"zmq_recv\");\n        break;\n    }\n    bytes += len;\n    }\n    printf(\"received %lu bytes\\n\", bytes);\n    zmq_send(receiver, buf, 0, 0);\n    return NULL;\n}\nint main ()\n{\n    void *context = zmq_ctx_new();\n    void *receiver = zmq_socket(context, ZMQ_PAIR);\n    zmq_bind(receiver, \"inproc://test\");\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    unsigned long t0 = tv.tv_usec + tv.tv_sec * 1000000;\n    pthread_t th;\n    pthread_create(&th, NULL, Receive, receiver);\n    Send(context);\n    void* ret;\n    pthread_join(th, &ret);\n    gettimeofday(&tv, NULL);\n    unsigned long t = tv.tv_usec + tv.tv_sec * 1000000 - t0;\n    printf(\"elapsed=%.3f\\n\", t/1000000.);\n    return 0;\n}\n\n. ",
    "dwillims": "Please can someone nanomsg-wise comment on this?\n. Michelp, modifying wuz73's nanomsg example to model the semantics of the zeromq version does not seem change the outcome.  The difference was only in what happened after all the messages are sent and received.\nHere's the modified nanomsg verion I ran:\n  https://gist.github.com/dwillims/67798df7ec1cdfbca690\nI get \nzmqTest - elapsed time around 0.55s\n  nanoTest - elapsed time around 2.45s.\nTo rectide, I don't see where any message is 4k bytes. 1024 bytes is the largest as I read the code.  As a test, I reduced the maximum size to 256 bytes.  \nc++\nint sz[] = { 16,32,64,96,128,160,192,224,256 }; // ,384,512,768,1024};\nResults roughly as follows:  \nzmqTest - elapsed time around 0.45s\n  nanoTest - elapsed time around 2.45s.\nzmqTest slightly quicker, nanoTest about the same.  I interpret this to mean that the elapsed time for nanoTest is dominated by message overhead, not content size.\n. Interestingly, changing the transport to tcp results is a much closer race.  I replaced \"inproc://test\" with \"tcp://127.0.0.1:1234\" in both and got the following approximate results:\nzmqTest: 0.7s\nnanoTest: 0.8s\nA much closer finish, but zmq still comes out slightly in front.\n. ",
    "michelp": "These example don't look like they are doing the same thing to me.  The zmq version of Send() calls zmq_send and zmq_recv  and Receive() calls zmq_recv then zmq_send.  The NN versions do not follow this same pattern.\n. ",
    "bishophu": "still, by comparing zeromq4.0.5 and nanomsg0.5 using perf/local_thr or perf/local_thr with tcp://127.0.0.1, nanomsg is way slower than zeromq on OS X 10.10.\n. ",
    "earonesty": "@tailhook \n- Any processing of the message is going to be order of magnitude slower\n  - therefore we should never benchmark a transport layer?\n- This is faster in zeromq only if your consumer is slower than producer\n  - this happens all the time, when the producer is, itself, a consumer\n- It's faster only for inproc, other transports should be same speed\n  - but not really\n- It's faster until you use any polling mechanism\n  - yuck, who polls anymore? so 1997\n. ",
    "Downchuck": "I think message size is the big issue in this benchmark; in most cases where there's a high volume of messages, there's an opportunity to batch beyond a few hundreds bytes.\n. And in the case of the person posting the bug report, there's more than a second of added latency, as there is no batching in place.\n. ",
    "Moore123": "Conform transmission speed with nanomsg NN_REQ/NN_REP mode, obviously slow than 0mq.\n. ",
    "AleXoundOS": "Any updates on this?\n. Thank you.\n. ",
    "MaroShim": "I think the original title is better. google search shows this issue for nanomsg, but current title is misleading...\nwuz73 changed the title from Performance issues of inproc with NN_PAIR to Nanomsg an order of magnitude slower than zmq on 16 Aug 2014\n. ",
    "yjh0502": "Yes, but library should not call abort() when caller cannot control the condition. In this case, there is no way to prevent nanomsg to call abort().\nHere's related thread on mailing list: http://www.freelists.org/post/nanomsg/Abort-on-recoverable-error,4\n. ",
    "dbabits": "thanks, but no, it didnt help.\nstill segmentation fault.\nAs to examples on that site, that  site is linked to under \"Documentation\" tab of nanomsg website, under \"Tutorials\", so for all intents and purposes it is official nanomsg documentation.\nIt doesn't help nanomsg's case that the examples dont even compile, and after some effort at that-dont run.\n. thank you, will try tomorrow\n. ",
    "andreasbaumann": "A #include <string.h> is missing, hence the warnings about strlen.\nThe libc.h is indeed not necessary.\nOn ArchLinux I get:\n\ngcc -g -o reqrep.o -c reqrep.c\ngcc -lnanomsg -o reqrep reqrep.o\n\n\n./reqrep node0 ipc:///tmp/reqrep.ipc &\n./reqrep node1 ipc:///tmp/reqrep.ipc\nSegmentation fault (core dumped)\n\ngdb shows:\n\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0xb75bb556 in __strlen_sse2_bsf () from /usr/lib/libc.so.6\n(gdb) bt\n#0  0xb75bb556 in __strlen_sse2_bsf () from /usr/lib/libc.so.6\n#1  0x08048849 in node1 (url=0xbfcaccee \"ipc:///tmp/reqrep.ipc\", msg=0x0) at reqrep.c:27\n#2  0x0804898e in main (argc=3, argv=0xbfcaaea4) at reqrep.c:42\n(gdb) up\n#1  0x08048849 in node1 (url=0xbfcaccee \"ipc:///tmp/reqrep.ipc\", msg=0x0) at reqrep.c:27\n27        int sz_msg = strlen (msg) + 1; // '\\0' too\n(gdb) p msg\n$1 = 0x0\n\nSo argv[3] is null. Thus node1 should be called with a 3rd parameter:\n\n./reqrep node1 ipc:///tmp/reqrep.ipc hello\nNODE1: SENDING \"hello\"\nNODE0: RECEIVED \"hello\"\n\nThen things work. :-)\n. ",
    "kristianlm": "Actually, when I think of it - that patch is probably quite intrusive as it introduces Linux-specifics. The problem is that my un.h looks like this, with no definition of sa_family_t.\nThis patch works too, which may be a better candidate:\ndiff\ndiff --git a/src/transports/ipc/ipc.c b/src/transports/ipc/ipc.c\nindex 26ffb07..552ba13 100644\n--- a/src/transports/ipc/ipc.c\n+++ b/src/transports/ipc/ipc.c\n@@ -36,6 +36,7 @@\n #if defined NN_HAVE_WINDOWS\n #include \"../../utils/win.h\"\n #else\n+#include <sys/socket.h>\n #include <sys/un.h>\n #include <unistd.h>\n #endif\n. haha of course! pick any license you like :)\n. @mardistal that depends on your Android setup, really. We're building Android from scratch (aka aosp) which builds all Android.mk files by itself.\nIf I remember correctly, it's the same with NDK apps: Android.mk files under ./jni/ will get built in.\n. Oh, that makes sense. I was trying to experiment with nanomsg to measure performance for fun. So I wanted to say \"don't wait between sending requests\" and I misunderstood the semantics. I'll make my own client in C to measure throughput.\nThanks!\n. explicitly setting linger options does not help. but indeed, sleeping 1ms before closing the socket seems to help:\nclient.c\n``` c\ninclude \ninclude \ninclude \ninclude \ninclude \nint main(int argc, char *argv) {\n  int sock = nn_socket(AF_SP, NN_PUSH);\n  char msg = argv[2];\nint linger = 10000;\n  nn_setsockopt (sock, NN_SOL_SOCKET, NN_LINGER, &linger, sizeof (linger));\nint endpoint = nn_connect(sock, argv[1]);\nint bytes = nn_send(sock, msg, strlen(msg), 0);\n  // printf(\"%d \", bytes);\n  // usleep(1000); //<-- this fixes the problem\n  nn_close(sock);\n  nn_shutdown(sock, endpoint);\n}\n```\n. Hm, I just re-tried with 0.6-beta and it's still the same behaviour. I'm running Arch Linux:\n$ uname -a\nLinux kth 4.1.6-1-ARCH #1 SMP PREEMPT Mon Aug 17 08:52:28 CEST 2015 x86_64 GNU/Linux\nI don't know what might help you guys find out what's wrong. An strace perhaps? Here's an strace of a successful transmission:\nbash\n$ strace ./client ipc:///tmp/nn 0\nexecve(\"./client\", [\"./client\", \"ipc:///tmp/nn\", \"0\"], [/* 43 vars */]) = 0\nbrk(0)                                  = 0x8fb000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"tls/x86_64/libnanomsg.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"tls/libnanomsg.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"x86_64/libnanomsg.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"libnanomsg.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"/usr/local/lib/tls/x86_64/libnanomsg.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nstat(\"/usr/local/lib/tls/x86_64\", 0x7ffd53715670) = -1 ENOENT (No such file or directory)\nopen(\"/usr/local/lib/tls/libnanomsg.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nstat(\"/usr/local/lib/tls\", 0x7ffd53715670) = -1 ENOENT (No such file or directory)\nopen(\"/usr/local/lib/x86_64/libnanomsg.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nstat(\"/usr/local/lib/x86_64\", 0x7ffd53715670) = -1 ENOENT (No such file or directory)\nopen(\"/usr/local/lib/libnanomsg.so.0\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\240\\367\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=1243464, ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fc9be8ac000\nmmap(NULL, 2383016, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fc9be446000\nmprotect(0x7fc9be489000, 2093056, PROT_NONE) = 0\nmmap(0x7fc9be688000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x42000) = 0x7fc9be688000\nclose(3)                                = 0\nopen(\"tls/x86_64/libc.so.6\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"tls/libc.so.6\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"x86_64/libc.so.6\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"libc.so.6\", O_RDONLY|O_CLOEXEC)   = -1 ENOENT (No such file or directory)\nopen(\"/usr/local/lib/libc.so.6\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=287008, ...}) = 0\nmmap(NULL, 287008, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fc9be865000\nclose(3)                                = 0\nopen(\"/usr/lib/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0000\\7\\2\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=1991416, ...}) = 0\nmmap(NULL, 3815984, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fc9be0a2000\nmprotect(0x7fc9be23d000, 2093056, PROT_NONE) = 0\nmmap(0x7fc9be43c000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19a000) = 0x7fc9be43c000\nmmap(0x7fc9be442000, 14896, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fc9be442000\nclose(3)                                = 0\nopen(\"tls/x86_64/libanl.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"tls/libanl.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"x86_64/libanl.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"libanl.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"/usr/local/lib/libanl.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"/usr/lib/libanl.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\0\\17\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=14912, ...}) = 0\nmmap(NULL, 2109928, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fc9bde9e000\nmprotect(0x7fc9bdea1000, 2093056, PROT_NONE) = 0\nmmap(0x7fc9be0a0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7fc9be0a0000\nclose(3)                                = 0\nopen(\"tls/x86_64/librt.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"tls/librt.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"x86_64/librt.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"librt.so.1\", O_RDONLY|O_CLOEXEC)  = -1 ENOENT (No such file or directory)\nopen(\"/usr/local/lib/librt.so.1\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"/usr/lib/librt.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0\\240!\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=31672, ...}) = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fc9be864000\nmmap(NULL, 2128856, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fc9bdc96000\nmprotect(0x7fc9bdc9d000, 2093056, PROT_NONE) = 0\nmmap(0x7fc9bde9c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x7fc9bde9c000\nclose(3)                                = 0\nopen(\"tls/x86_64/libpthread.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"tls/libpthread.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"x86_64/libpthread.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"libpthread.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"/usr/local/lib/libpthread.so.0\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nopen(\"/usr/lib/libpthread.so.0\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0@a\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=146608, ...}) = 0\nmmap(NULL, 2213008, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fc9bda79000\nmprotect(0x7fc9bda91000, 2093056, PROT_NONE) = 0\nmmap(0x7fc9bdc90000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x17000) = 0x7fc9bdc90000\nmmap(0x7fc9bdc92000, 13456, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fc9bdc92000\nclose(3)                                = 0\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fc9be863000\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fc9be862000\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fc9be861000\narch_prctl(ARCH_SET_FS, 0x7fc9be862700) = 0\nmprotect(0x7fc9be43c000, 16384, PROT_READ) = 0\nmprotect(0x7fc9bdc90000, 4096, PROT_READ) = 0\nmprotect(0x7fc9bde9c000, 4096, PROT_READ) = 0\nmprotect(0x7fc9be0a0000, 4096, PROT_READ) = 0\nmprotect(0x7fc9be8ad000, 4096, PROT_READ) = 0\nmunmap(0x7fc9be865000, 287008)          = 0\nset_tid_address(0x7fc9be8629d0)         = 15449\nset_robust_list(0x7fc9be8629e0, 24)     = 0\nrt_sigaction(SIGRTMIN, {0x7fc9bda7ebe0, [], SA_RESTORER|SA_SIGINFO, 0x7fc9bda89d60}, NULL, 8) = 0\nrt_sigaction(SIGRT_1, {0x7fc9bda7ec70, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0x7fc9bda89d60}, NULL, 8) = 0\nrt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0\ngetrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0\nbrk(0)                                  = 0x8fb000\nbrk(0x91d000)                           = 0x91d000\neventfd2(0, O_CLOEXEC)                  = 3\nfcntl(3, F_GETFL)                       = 0x2 (flags O_RDWR)\nfcntl(3, F_SETFL, O_RDWR|O_NONBLOCK)    = 0\nepoll_create1(EPOLL_CLOEXEC)            = 4\nepoll_ctl(4, EPOLL_CTL_ADD, 3, {0, {u32=3194534320, u64=140504459688368}}) = 0\nepoll_ctl(4, EPOLL_CTL_MOD, 3, {EPOLLIN, {u32=3194534320, u64=140504459688368}}) = 0\nrt_sigprocmask(SIG_BLOCK, ~[RTMIN RT_1], [], 8) = 0\nmmap(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7fc9bd278000\nmprotect(0x7fc9bd278000, 4096, PROT_NONE) = 0\nclone(child_stack=0x7fc9bda77ff0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fc9bda789d0, tls=0x7fc9bda78700, child_tidptr=0x7fc9bda789d0) = 15450\nrt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0\nwrite(3, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8)         = 8\nfutex(0x7fc9be68b7e0, FUTEX_WAKE_PRIVATE, 1) = 1\nuname({sysname=\"Linux\", nodename=\"kth\", ...}) = 0\neventfd2(0, O_CLOEXEC)                  = 5\nfcntl(5, F_GETFL)                       = 0x2 (flags O_RDWR)\nfcntl(5, F_SETFL, O_RDWR|O_NONBLOCK)    = 0\nsocket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC, 0) = 6\nfcntl(6, F_SETFD, FD_CLOEXEC)           = 0\nfcntl(6, F_GETFL)                       = 0x2 (flags O_RDWR)\nfcntl(6, F_SETFL, O_RDWR|O_NONBLOCK)    = 0\nsetsockopt(6, SOL_SOCKET, SO_SNDBUF, [131072], 4) = 0\nsetsockopt(6, SOL_SOCKET, SO_RCVBUF, [131072], 4) = 0\nconnect(6, {sa_family=AF_LOCAL, sun_path=\"/tmp/nn\"}, 110) = 0\nwrite(3, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8)         = 8\nfutex(0x7fc9be68b7e0, FUTEX_WAKE_PRIVATE, 1) = 1\nwrite(3, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8)         = 8\nsendmsg(6, {msg_name(0)=NULL, msg_iov(1)=[{\"\\0SP\\0\\0P\\0\\0\", 8}], msg_controllen=0, msg_flags=0}, MSG_NOSIGNAL) = 8\nrecvmsg(6, {msg_name(0)=NULL, msg_iov(1)=[{\"\\0SP\\0\\0Q\\0\\0\", 2048}], msg_controllen=0, msg_flags=0}, 0) = 8\nwrite(3, \"\\1\\0\\0\\0\\0\\0\\0\\0\", 8)         = 8\nfutex(0x8fc5b8, FUTEX_WAKE_PRIVATE, 1)  = 1\nfutex(0x8fc5b8, FUTEX_WAIT_PRIVATE, 2, NULL) = 0\nsendmsg(6, {msg_name(0)=NULL, msg_iov(2)=[{\"\\1\\0\\0\\0\\0\\0\\0\\0\\1\", 9}, {\"0\", 1}], msg_controllen=0, msg_flags=0}, MSG_NOSIGNAL) = 10\nfutex(0x8fc5b8, FUTEX_WAKE_PRIVATE, 1)  = 0\nexit_group(0)                           = ?\n+++ exited with 0 +++\nI presume the problem is the client process that exits before nanomsg's background threads gets to complete their tasks.\n. Ah, thanks for explaining that out to us. We could switch to req/rep for our particular use-case here.\nSo - no delivery guarantuees for pipeline. I'm not able to derive that based on the information in http://nanomsg.org/v0.6/nn_pipeline.7.html. Is there an overview of the different delivery guarantuees that I'm missing or have I misunderstood nanomsg purpose completely?\n. Hmmm, strange, I can't get that working:\nme@host build$ make html man\nmake: *** No rule to make target 'html'.  Stop.\nme@host build$ git describe --always\n1.0.0-37-gc1b5caf\nDo I need to pass anything else into cmake ..?. ",
    "mardistal": "How did you compile he mk file ?\n. ",
    "sweisgerber-dev": "Older example:\nhttps://github.com/RPetrov/nanomsg-android/blob/master/app/jni/Android.mk. ",
    "localhost": "Yes, the patch is submitted under the MIT license.\n. ",
    "stepelu": "It does, we're making progress. Not yet successful though:\nScanning dependencies of target nanomsg\n[  1%] Building C object src/CMakeFiles/nanomsg.dir/core/ep.c.obj\n[  2%] Building C object src/CMakeFiles/nanomsg.dir/core/epbase.c.obj\n[  3%] Building C object src/CMakeFiles/nanomsg.dir/core/global.c.obj\nZ:\\sp\\Dropbox\\Prj\\repo\\nanomsg\\__build\\src\\nanomsg-0.4-beta\\src\\core\\global.c: In function 'nn_global_submit_errors':\nZ:\\sp\\Dropbox\\Prj\\repo\\nanomsg\\__build\\src\\nanomsg-0.4-beta\\src\\core\\global.c:992:54: error: '_TRUNCATE' undeclared (first use in this function)\n                 len = _snprintf_s (curbuf, buf_left, _TRUNCATE,\n                                                      ^\nZ:\\sp\\Dropbox\\Prj\\repo\\nanomsg\\__build\\src\\nanomsg-0.4-beta\\src\\core\\global.c:992:54: note: each undeclared identifier is reported only once for each function it appears in\nsrc\\CMakeFiles\\nanomsg.dir\\build.make:99: recipe for target 'src/CMakeFiles/nanomsg.dir/core/global.c.obj' failed\nmingw32-make[2]: *** [src/CMakeFiles/nanomsg.dir/core/global.c.obj] Error 1\nCMakeFiles\\Makefile2:1334: recipe for target 'src/CMakeFiles/nanomsg.dir/all' failed\nmingw32-make[1]: *** [src/CMakeFiles/nanomsg.dir/all] Error 2\nMakefile:146: recipe for target 'all' failed\nmingw32-make: *** [all] Error 2\n. Windows 8.1 + TDM-GCC.\n. @zerotacg: tried removing -D_WIN32_WINNT=0x0600 but it made no difference, still getting undeclared _TRUNCATE.\n. Thank you for checking this. The reason I'm using TDM-GCC is that I want to avoid mingw-related DLL dependencies. I know you can pass options to mingw to get static linking, but I have not found a way to achieve this consistently independently of the build system used (cmake, make, automaker, batch sripts...).\nRegarding the dependency on Vista, is version 1.0 of nanomsg supposed to support WindowsXP?\n. For what is worth, I moved to Visual Studio 2015.\nI feel your pain, thanks for your work.\nOn 18 Nov 2015 17:47, \"gdamore\" notifications@github.com wrote:\n\nArgh. So mingw is problematic. Its this weird mutant that is neither\nWindows nor POSIX. Aargh.\nIts looks like I'm going to have to actually install this stupid beast to\ndebug it properly, since I can't seem to get anyone else to provide\nreasonably correct PRs for it. Grrrr....\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/330#issuecomment-157797205.\n. The plain version yes, it is.\nOn 18 Nov 2015 17:53, \"gdamore\" notifications@github.com wrote:\nVisual Studio was the right choice. I think its free, yes?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/330#issuecomment-157800283.\n. I'd be happy to help but I'm not familiar at all with this build system. Would you mind proposing a patch that I can try and report back?\n. configure: creating ./config.status\nconfig.status: creating Makefile\nconfig.status: creating libnanomsg.pc\nconfig.status: executing depfiles commands\nconfig.status: executing libtool commands\nCDPATH=\"${ZSH_VERSION+.}:\" && cd . && /bin/bash /mnt/hgfs/sp/Dropbox/Prj/repo/nanomsg/__build/src/nanomsg-0.4-beta/missing aclocal-1.14 -I m4\n/mnt/hgfs/sp/Dropbox/Prj/repo/nanomsg/__build/src/nanomsg-0.4-beta/missing: line 81: aclocal-1.14: command not found\nWARNING: 'aclocal-1.14' is missing on your system.\n         You should only need it if you modified 'acinclude.m4' or\n         'configure.ac' or m4 files included by 'configure.ac'.\n         The 'aclocal' program is part of the GNU Automake package:\n         <http://www.gnu.org/software/automake>\n         It also requires GNU Autoconf, GNU m4 and Perl in order to run:\n         <http://www.gnu.org/software/autoconf>\n         <http://www.gnu.org/software/m4/>\n         <http://www.perl.org/>\nmake: *** [aclocal.m4] Error 127\n\nUnfortunately I can get only get version 1-10 of automake on this old distro via the package manager. Is there another way to test this?\n. I'll give it a try this weekend and report back.\n. I haven't. I've put up a reminder for it, I will update by the beginning of\nnext week.\nOn 26 Jan 2015 21:28, \"Dirkjan Ochtman\" notifications@github.com wrote:\n\n@stepelu https://github.com/stepelu did you ever get around to trying\nthis?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/331#issuecomment-71541899.\n. @gdamore thanks for looking into this! The distribution is Ubuntu 8.04 LTS over which I have manually installed a recent gcc (4.8.3). Yes, CMake is available. I am using this vintage distro as linking to an old version of libc results in universal binaries: the compiled nanomsg library will run on every Linux distribution which is no more than 10 years old (verified with the LSB app checker).\n. @gdamore also, I am unsure about how to test @sustrik suggestion (6/11/2014), should I just use a modern distro, modify configure.ac, run make dist, transfer the resulting directory structure to the ancient distro, and try again?\n. I recently upgraded my vintage distribution to Ubuntu 10.04LTS and where the problem is not present anymore. \nI don't thing it's worth keeping this issue open, please close it if you agree.\n. urther testing revealed that surrounding nn_close() with print statements in socket.__gc() solved the issue.\nIt thus seems that the problem manifest itself only if multiple socket connections are closed in rapid succession via nn_close(). Is anyone else experiencing similar issues?\n. Sorry for the delay, I will try with v0.7-beta shortly and update you.\n. Sorry for the very late reply.\nI confirm that the mentioned issues does not seem to appear anymore in the latest release.\n. @wirebirdlabs -- I have cretated an issue as suggested for the LuaJIT binding: nanomsg/luajit-nanomsg#14\n\nCan you please assist there with the API changes? \nIs it correct that nn_tcpmuxd, nn_poll, and nn_reallocmsg have been added and that the remaining functions have not changed? \nThanks\n. This on Windows7/64, with nanomsg 0.8beta compiled for x86.\n. ",
    "zedalaye": "I just tested with a fresh install of TDM-MinGW64 and latest CMake 3.40 and, sorry, but it don't work:\n```\nW:\\OpenSource\\ZeroMQ\\nanomsg\\build>\"c:\\Program Files (x86)\\CMake\\bin\\cmake.exe\"\n-G \"MinGW Makefiles\" ..\n-- The C compiler identification is GNU 5.1.0\n-- Check for working C compiler: C:/TDM-GCC-64/bin/gcc.exe\n-- Check for working C compiler: C:/TDM-GCC-64/bin/gcc.exe -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: W:/OpenSource/ZeroMQ/nanomsg/build\nW:\\OpenSource\\ZeroMQ\\nanomsg\\build>mingw32-make\nScanning dependencies of target nanomsg\n[  0%] Building C object src/CMakeFiles/nanomsg.dir/core/ep.c.obj\n[  1%] Building C object src/CMakeFiles/nanomsg.dir/core/epbase.c.obj\n[  1%] Building C object src/CMakeFiles/nanomsg.dir/core/global.c.obj\nW:\\OpenSource\\ZeroMQ\\nanomsg\\src\\core\\global.c: In function 'nn_global_submit_counter':\nW:\\OpenSource\\ZeroMQ\\nanomsg\\src\\core\\global.c:1071:9: warning: implicit declaration of function 'gmtime_r' [-Wimplicit-function-declaration]\n         gmtime_r (&numtime, &strtime);\n         ^\nW:\\OpenSource\\ZeroMQ\\nanomsg\\src\\core\\global.c: In function 'nn_global_submit_errors':\nW:\\OpenSource\\ZeroMQ\\nanomsg\\src\\core\\global.c:1174:23: warning: implicit declaration of function '_snprintf_s' [-Wimplicit-function-declaration]\n                 len = _snprintf_s (curbuf, buf_left, _TRUNCATE,\n                       ^\n[  2%] Building C object src/CMakeFiles/nanomsg.dir/core/pipe.c.obj\n[  2%] Building C object src/CMakeFiles/nanomsg.dir/core/poll.c.obj\n[  3%] Building C object src/CMakeFiles/nanomsg.dir/core/sock.c.obj\n[  3%] Building C object src/CMakeFiles/nanomsg.dir/core/sockbase.c.obj\n[  4%] Building C object src/CMakeFiles/nanomsg.dir/core/symbol.c.obj\n[  4%] Building C object src/CMakeFiles/nanomsg.dir/aio/ctx.c.obj\n[  5%] Building C object src/CMakeFiles/nanomsg.dir/aio/fsm.c.obj\n[  6%] Building C object src/CMakeFiles/nanomsg.dir/aio/poller.c.obj\n[  6%] Building C object src/CMakeFiles/nanomsg.dir/aio/pool.c.obj\n[  7%] Building C object src/CMakeFiles/nanomsg.dir/aio/timer.c.obj\n[  7%] Building C object src/CMakeFiles/nanomsg.dir/aio/timerset.c.obj\n[  8%] Building C object src/CMakeFiles/nanomsg.dir/aio/usock.c.obj\n[  8%] Building C object src/CMakeFiles/nanomsg.dir/aio/worker.c.obj\nIn file included from W:/OpenSource/ZeroMQ/nanomsg/src/utils/err.h:33:0,\n                 from W:\\OpenSource\\ZeroMQ\\nanomsg\\src\\aio\\worker_win.inc:27,\n                 from W:\\OpenSource\\ZeroMQ\\nanomsg\\src\\aio\\worker.c:26:\nW:\\OpenSource\\ZeroMQ\\nanomsg\\src\\aio\\worker_win.inc: In function 'nn_worker_routine':\nW:/OpenSource/ZeroMQ/nanomsg/src/utils/fast.h:27:38: warning: passing argument 1 of '__builtin_expect' makes integer from pointer without a cast [-Wint-conversion]\n #define nn_fast(x) __builtin_expect ((x), 1)\n                                      ^\nW:\\OpenSource\\ZeroMQ\\nanomsg\\src\\aio\\worker_win.inc:176:17: note: in expansion of macro 'nn_fast'\n             if (nn_fast (entries [i].lpOverlapped)) {\n                 ^\nW:/OpenSource/ZeroMQ/nanomsg/src/utils/fast.h:27:38: note: expected 'long int' but argument is of type 'LPOVERLAPPED {aka struct _OVERLAPPED }'\n #define nn_fast(x) __builtin_expect ((x), 1)\n                                      ^\nW:\\OpenSource\\ZeroMQ\\nanomsg\\src\\aio\\worker_win.inc:176:17: note: in expansion of macro 'nn_fast'\n             if (nn_fast (entries [i].lpOverlapped)) {\n                 ^\n[  9%] Building C object src/CMakeFiles/nanomsg.dir/utils/alloc.c.obj\n[  9%] Building C object src/CMakeFiles/nanomsg.dir/utils/atomic.c.obj\n[ 10%] Building C object src/CMakeFiles/nanomsg.dir/utils/chunk.c.obj\n[ 10%] Building C object src/CMakeFiles/nanomsg.dir/utils/chunkref.c.obj\n[ 11%] Building C object src/CMakeFiles/nanomsg.dir/utils/clock.c.obj\n[ 11%] Building C object src/CMakeFiles/nanomsg.dir/utils/closefd.c.obj\n[ 12%] Building C object src/CMakeFiles/nanomsg.dir/utils/efd.c.obj\n[ 12%] Building C object src/CMakeFiles/nanomsg.dir/utils/err.c.obj\n[ 13%] Building C object src/CMakeFiles/nanomsg.dir/utils/glock.c.obj\n[ 14%] Building C object src/CMakeFiles/nanomsg.dir/utils/hash.c.obj\n[ 14%] Building C object src/CMakeFiles/nanomsg.dir/utils/list.c.obj\n[ 15%] Building C object src/CMakeFiles/nanomsg.dir/utils/msg.c.obj\n[ 15%] Building C object src/CMakeFiles/nanomsg.dir/utils/mutex.c.obj\n[ 16%] Building C object src/CMakeFiles/nanomsg.dir/utils/queue.c.obj\n[ 16%] Building C object src/CMakeFiles/nanomsg.dir/utils/random.c.obj\n[ 17%] Building C object src/CMakeFiles/nanomsg.dir/utils/sem.c.obj\n[ 17%] Building C object src/CMakeFiles/nanomsg.dir/utils/sleep.c.obj\n[ 18%] Building C object src/CMakeFiles/nanomsg.dir/utils/thread.c.obj\n[ 18%] Building C object src/CMakeFiles/nanomsg.dir/utils/wire.c.obj\n[ 19%] Building C object src/CMakeFiles/nanomsg.dir/devices/device.c.obj\n[ 19%] Building C object src/CMakeFiles/nanomsg.dir/devices/tcpmuxd.c.obj\n[ 20%] Building C object src/CMakeFiles/nanomsg.dir/protocols/utils/dist.c.obj\n[ 20%] Building C object src/CMakeFiles/nanomsg.dir/protocols/utils/excl.c.obj\n[ 21%] Building C object src/CMakeFiles/nanomsg.dir/protocols/utils/fq.c.obj\n[ 22%] Building C object src/CMakeFiles/nanomsg.dir/protocols/utils/lb.c.obj\n[ 22%] Building C object src/CMakeFiles/nanomsg.dir/protocols/utils/priolist.c.obj\n[ 23%] Building C object src/CMakeFiles/nanomsg.dir/protocols/bus/bus.c.obj\n[ 23%] Building C object src/CMakeFiles/nanomsg.dir/protocols/bus/xbus.c.obj\n[ 24%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pipeline/push.c.obj\n[ 24%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pipeline/pull.c.obj\n[ 25%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pipeline/xpull.c.obj\n[ 25%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pipeline/xpush.c.obj\n[ 26%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pair/pair.c.obj\n[ 26%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pair/xpair.c.obj\n[ 27%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pubsub/pub.c.obj\n[ 27%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pubsub/sub.c.obj\n[ 28%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pubsub/trie.c.obj\n[ 29%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pubsub/xpub.c.obj\n[ 29%] Building C object src/CMakeFiles/nanomsg.dir/protocols/pubsub/xsub.c.obj\n[ 30%] Building C object src/CMakeFiles/nanomsg.dir/protocols/reqrep/req.c.obj\n[ 30%] Building C object src/CMakeFiles/nanomsg.dir/protocols/reqrep/rep.c.obj\n[ 31%] Building C object src/CMakeFiles/nanomsg.dir/protocols/reqrep/task.c.obj\n[ 31%] Building C object src/CMakeFiles/nanomsg.dir/protocols/reqrep/xrep.c.obj\n[ 32%] Building C object src/CMakeFiles/nanomsg.dir/protocols/reqrep/xreq.c.obj\n[ 32%] Building C object src/CMakeFiles/nanomsg.dir/protocols/survey/respondent.c.obj\n[ 33%] Building C object src/CMakeFiles/nanomsg.dir/protocols/survey/surveyor.c.obj\n[ 33%] Building C object src/CMakeFiles/nanomsg.dir/protocols/survey/xrespondent.c.obj\n[ 34%] Building C object src/CMakeFiles/nanomsg.dir/protocols/survey/xsurveyor.c.obj\n[ 34%] Building C object src/CMakeFiles/nanomsg.dir/transports/utils/backoff.c.obj\n[ 35%] Building C object src/CMakeFiles/nanomsg.dir/transports/utils/dns.c.obj\n[ 35%] Building C object src/CMakeFiles/nanomsg.dir/transports/utils/iface.c.obj\n[ 36%] Building C object src/CMakeFiles/nanomsg.dir/transports/utils/literal.c.obj\n[ 37%] Building C object src/CMakeFiles/nanomsg.dir/transports/utils/port.c.obj\n[ 37%] Building C object src/CMakeFiles/nanomsg.dir/transports/utils/streamhdr.c.obj\n[ 38%] Building C object src/CMakeFiles/nanomsg.dir/transports/utils/base64.c.obj\n[ 38%] Building C object src/CMakeFiles/nanomsg.dir/transports/inproc/binproc.c.obj\n[ 39%] Building C object src/CMakeFiles/nanomsg.dir/transports/inproc/cinproc.c.obj\n[ 39%] Building C object src/CMakeFiles/nanomsg.dir/transports/inproc/inproc.c.obj\n[ 40%] Building C object src/CMakeFiles/nanomsg.dir/transports/inproc/ins.c.obj\n[ 40%] Building C object src/CMakeFiles/nanomsg.dir/transports/inproc/msgqueue.c.obj\n[ 41%] Building C object src/CMakeFiles/nanomsg.dir/transports/inproc/sinproc.c.obj\n[ 41%] Building C object src/CMakeFiles/nanomsg.dir/transports/ipc/aipc.c.obj\n[ 42%] Building C object src/CMakeFiles/nanomsg.dir/transports/ipc/bipc.c.obj\n[ 42%] Building C object src/CMakeFiles/nanomsg.dir/transports/ipc/cipc.c.obj\n[ 43%] Building C object src/CMakeFiles/nanomsg.dir/transports/ipc/ipc.c.obj\n[ 43%] Building C object src/CMakeFiles/nanomsg.dir/transports/ipc/sipc.c.obj\n[ 44%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcp/atcp.c.obj\n[ 45%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcp/btcp.c.obj\n[ 45%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcp/ctcp.c.obj\n[ 46%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcp/stcp.c.obj\n[ 46%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcp/tcp.c.obj\n[ 47%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcpmux/atcpmux.c.obj\n[ 47%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcpmux/btcpmux.c.obj\n[ 48%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcpmux/ctcpmux.c.obj\n[ 48%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcpmux/stcpmux.c.obj\n[ 49%] Building C object src/CMakeFiles/nanomsg.dir/transports/tcpmux/tcpmux.c.obj\n[ 49%] Building C object src/CMakeFiles/nanomsg.dir/transports/ws/aws.c.obj\n[ 50%] Building C object src/CMakeFiles/nanomsg.dir/transports/ws/bws.c.obj\n[ 50%] Building C object src/CMakeFiles/nanomsg.dir/transports/ws/cws.c.obj\n[ 51%] Building C object src/CMakeFiles/nanomsg.dir/transports/ws/sws.c.obj\n[ 52%] Building C object src/CMakeFiles/nanomsg.dir/transports/ws/ws.c.obj\n[ 52%] Building C object src/CMakeFiles/nanomsg.dir/transports/ws/ws_handshake.c.obj\n[ 53%] Building C object src/CMakeFiles/nanomsg.dir/transports/ws/sha1.c.obj\n[ 53%] Linking C shared library ..\\libnanomsg.dll\nCMakeFiles\\nanomsg.dir/objects.a(global.c.obj):global.c:(.text+0x2026): undefined reference to gmtime_r'\nCMakeFiles\\nanomsg.dir/objects.a(global.c.obj):global.c:(.text+0x2232): undefined reference togmtime_r'\nCMakeFiles\\nanomsg.dir/objects.a(global.c.obj):global.c:(.text+0x23f8): undefined reference to `gmtime_r'\ncollect2.exe: error: ld returned 1 exit status\nsrc\\CMakeFiles\\nanomsg.dir\\build.make:2643: recipe for target 'libnanomsg.dll' failed\nmingw32-make[2]:  [libnanomsg.dll] Error 1\nCMakeFiles\\Makefile2:1675: recipe for target 'src/CMakeFiles/nanomsg.dir/all' failed\nmingw32-make[1]:  [src/CMakeFiles/nanomsg.dir/all] Error 2\nMakefile:159: recipe for target 'all' failed\nmingw32-make: ** [all] Error 2\n```\n. Windows 7 Professional (French, up to date but running in VirtualBox). nanomsg is built using Visual Studio 2013 Update 5 (and CMake 3.4.0)\n. ",
    "zshipko": "I have been thinking about setting up an OpenBSD build server for a couple other things.  I'll let you know when I get around to setting that up.\nWhat version of autoconf/automake is recommended?  I'm using autoconf-2.69 and automake-1.8 and get this error:\nMakefile.am:45: Libtool library used but LIBTOOL is undefined\nI don't use autotools much, is this a variable I need to provide?\n. Nevermind, got it. I'll let you know if it works in a second\n. Yep, that did it - thanks.\n. ",
    "bnewbold": "I rebuilt with today's master (1ae64...) and the problem persists. I experimented a bit more and the client seems to always stop receiving messages 10 seconds after it starts, regardless of when the server process starts sending messages. Eg, if the client is started first and the server ~7 seconds later, the client will only received ~3 seconds worth of messages. If the server is started >10 seconds after the client, the client receives no messages.\nI also tested using nanocat (nn_sub -l3333 --ascii) and the 10-seconds-until-SUB-failure behavior is the same.\n. I've reduced this to a short tests/tcp_long.c:\n``` C\nint main ()\n{\n    int s1, s2;\n/*  Test > 10 second failure (OS X specific) */\ns1 = test_socket (AF_SP, NN_PAIR);\ntest_bind (s1, SOCKET_ADDRESS);\ns2 = test_socket (AF_SP, NN_PAIR);\ntest_connect (s2, SOCKET_ADDRESS);\nnn_sleep (100);\ntest_send (s1, \"ABC\");\ntest_recv (s2, \"ABC\");\ntest_send (s2, \"123\");\ntest_recv (s1, \"123\");\nnn_sleep (1000 * 12);   // 12 seconds\n//nn_sleep (1000 * 2);    // 2 seconds\ntest_send (s1, \"ABC\");\ntest_recv (s2, \"ABC\");\ntest_send (s2, \"123\");\ntest_recv (s1, \"123\");\ntest_close (s1);\ntest_close (s2);\n\nreturn 0;\n\n}\n```\nThe test runs fine with a 2 second sleep, but hangs forever with a 12 second sleep.\n. I think i've traced this down the the nn_timer_start() call on line 1265 of src/core/global.c:\nif (global->print_statistics || global->statistics_socket >= 0)\n                {\n                    /*  Start statistics collection timer. */\n                    nn_timer_start (&global->stat_timer, 10000);\n                }\nIf I change the timer value from 10000 (10 seconds), the time-to failure changes.\n. With patch accepted, closing this issue.\n. I will state that here: I submit this patch, and all future submitted patches to the nanomsg software project, under the MIT License.\nShould I add a statement to the commit message as well?\n. Hrm, it looks like my following patches got added to this pull request. I'll fix that.\n. Ok, I fixed my 'master' and now there is only the one commit. I guess that's why it's good to use pull-request-specific branches!\n. Did this stall?\n. I just came across this same section of code. Just staring at it, I think there should be a nn_msg_term(msg) when there is no such pipe.\nI got here because, despite the comments in source, it seems crazy to me not to return some sort of error code in either condition, but particularly lacking an EINVAL for invalid peer ID (aka, when the headers are just plain wrong/empty).\n. From RFC 3484 (http://www.ietf.org/rfc/rfc3484.txt):\n\"Well-behaved applications SHOULD iterate through the list of addresses returned from getaddrinfo() until they find a working address.\"\nIt looks like the reply is getting free'd immediately, and it would take a refactor to iterate through options.\nI would support just going with the first address replied for now and opening a new issue as a task to re-implement the correct way.\n. Created an issue (#460) with example code, and added a \"fixes\" line to commit message.\n. I updated the first line of the commit message to match convention, and checked to confirm that the counters get updated correctly:\nnanomsg: socket.0: established_connections: 2\nnanomsg: socket.0: accepted_connections: 0\nnanomsg: socket.0: dropped_connections: 0\nnanomsg: socket.0: broken_connections: 1\nnanomsg: socket.0: connect_errors: 87\nnanomsg: socket.0: bind_errors: 0\nnanomsg: socket.0: accept_errors: 0\nnanomsg: socket.0: messages_sent: 0\nnanomsg: socket.0: messages_received: 33\nnanomsg: socket.0: bytes_sent: 0\nnanomsg: socket.0: bytes_received: 363\nnanomsg: socket.0: current_connections: 1\nnanomsg: socket.0: inprogress_connections: 0\nnanomsg: socket.0: current_snd_priority: 0\n. Pushed changes:\n- removed nn_serial.txt (oops!)\n- refactored tests/tcp.c to follow style of other tests. Added test that \"-2\" as a value is invalid.\n- switched to 1MB (1024kB) as the new default max. I think this is a good balance, given that the socket will just mysteriously close for the sender end.\n- reworked stcp.c code a bit to use \"opt\" and \"opt_sz\" temporary variables; seemed cleaner this way.\n- fix the -1/-2 value check\nI'll send an email to the list, as the new max size could be counter-intuitive to folks (\"why isn't my 3MB message going through if TCP payload header is uint64_t long?). Should I also update the, eg, nn_recv and nn_recvmsg man pages?\n. I just pushed one more small change:\n-                    if (opt >= 0 && size > opt) {\n+                    if (opt != -1 && size > opt) {\nNow, when checking, the option must explicitly be -1 for TCP to allow any message size (instead of just any negative number). This complements the earlier change that negative numbers below -1 could be reserved for some other purpose.\n. Pushed\n. I don't think this would address the core of your problem (nn_fsm_isidle), but did you try tuning the NN_*BUF and NN_LINGER parameters?\nhttp://nanomsg.org/v0.6/nn_setsockopt.3.html\nIn particular, a longer LINGER might help with your socket shutdown and needing to send a confirmation. Your inclusion of a \"finished' marker sounds more robust though.\n. I agree it would be nice to not need dependencies installed when building, but I started with the user-facing install docs (README) and found it confusing and counter-intuitive that man pages were not installed when installing from source following the instructions. If they were somehow installed without reformatting then perhaps we could leave the mention out of the README.\nShould we commit the formatted manpages in the repo (like with txt/xml under ./rfc/) so they can still be installed? That doesn't seem like a great option.\n. I've updated this patch to only add directions to doc/README (it doesn't touch the top-level README).\n. This was a typo, good catch. Should be (val < -1). I think \"negative but not -1\" should be reserved and thus an EINVAL. I'll fix and also add a test.\n. ",
    "VictorLaskin": "I have the same issue with BUS protocol (so its not protocol specific) (MacBookPro 13, Yosemite 10.10.1)\n. ",
    "wttw": "The code isn't mine, it's an import from the GNU autoconf-archive project.\nThe m4 script is GPL with a waiver allowing unlimited use of the output. The output is MIT-compatible (and as it's just an update of an existing file with the same license it makes no change to the projects license state).\n. ",
    "ksvasan": "I've tried the same code in python also, and it behaves the same way. Works while debugging both publisher and subscriber and not when run from the command line. No idea if this could be a problem with API. People with the required knowledge kindly answer.\n. ",
    "ivachkov": "Yes. I am perfectly happy those changes to adhere to the main project's license.\n. Is this Debian? What version? \nWill test on the latest stable version of Debian and update ... \n. Do we consider this closed or additional work is required?\nP.S. Thanks @x-yuri \n. ",
    "yoink00": "Yes, I am.\nOn 26 Jan 2015 19:02, \"Dirkjan Ochtman\" notifications@github.com wrote:\n\nCan you state that you are submitting the patch under MIT license?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/pull/353#issuecomment-71516714.\n. \n",
    "eldondev": "In doing more testing, it looks like repeated pubs to a tcp socket on linux drop messages. I am seeing the following:\nRun in one shell:./nanocat  --sub --bind tcp://127.0.0.1:1234 -A\nRun in the other shell while [ 1 ] ; do a=$(($a+1)); cat <(echo $a \" \" ) <(date) <(uuidgen) | tee /dev/stderr | ./nanocat --pub --connect tcp://127.0.0.1:1234 -F- ; sleep 0.1 ; done\nIn my testing, on 50-60% of the packets would be received by the sub socket. Is this expected?\nWhen I replace pub with push, and sub with pull, I receive all messages. If it is useful, I can publish a docker container which demonstrates this behavior.\n. ",
    "vbmithr": "For the TCP transport, using an interface name to bind fails when the chosen interface has more than one address (V4 or V6) assigned to it (easy to figure out from the sourcecode).\nIMO, the semantic of using an interface name should be clearly defined, or not available at all.\n. On 31/05/2015 20:43, gdamore wrote:\n\nAll that said, I think that probably we ought to consider enabling v6 by\ndefault.\n\nThank for the explanations! :)\n\nVincent\n. ",
    "dsouzae": "Any reason why you do not want to use nn_poll?  \nI was able to change your example code to use nn_poll and it \"waits\" till node0 is up before sending.\nAfter reading the nanomsg code, the nn_getsockopt NN_SNDFD is actually returning the fd of an eventfd fd.  Which is probably not want you want. \n. I re-looked at the source code for nn_poll, and your code is almost right.  \nChange all occurrences of POLLOUT to POLLIN and your code should work.\n. ",
    "dv1": "nn_poll can be used with SP sockets only. I was using poll() with a pipe socket as well. I could create a dummy SP socket instead of the pipe, sure. But if you are right, then NN_SNDFD is useless! I mean, it is  supposed to be usable with select/poll/kqueue/epoll etc., isn't it? If it cannot be used for that purpose, then what is it good for?\n. Hah, indeed, it works! EAGAIN no longer occurs.\nBut perhaps this should be mentioned in the documentation, since it is not intuitive. I  mean, if I am watching a send FD, I immediately think I need to use POLLOUT (or the equivalent in select/kqueue/etc.), since I'll write to the associated SP socket. But instead, you are always supposed to poll for reading on the send FD.\n. ",
    "cbandy": "It should close when the docs are done, I think.\n. ",
    "mguijarr": "My 2 cents: it is clearly stated in the documentation that file descriptors should be checked\nfor readable state, either for RCVFD or SNDFD. Quote from the documentation for nn_getsockopt (emphasis is mine):\n\nNN_SNDFD\nRetrieves a file descriptor that is readable when a message can be sent to the socket. The >descriptor should be used only for polling and never read from or written to. The type of the option >is same as the type of file descriptor on the platform. That is, int on POSIX-complaint platforms and >SOCKET on Windows. The descriptor becomes invalid and should not be used any more once the >socket is closed. This socket option is not available for unidirectional recv-only socket types.\nNN_RCVFD\nRetrieves a file descriptor that is readable when a message can be received from the socket. >The descriptor should be used only for polling and never read from or written to. The type of the >option is same as the type of file descriptor on the platform. That is, int on POSIX-complaint >platforms and SOCKET on Windows. The descriptor becomes invalid and should not be used any >more once the socket is closed. This socket option is not available for unidirectional send-only >socket types.\n\nSo I guess the issue could be closed.\n. Is it linked with PR #417 ?\n. +1\n. Thanks for the great work.. ",
    "nickva": "Possibly related:  zerocopy.c fails in line 51 (req=test_socket(AF_SP_RAW, NN_REQ)).\nWith stack trace leading down to same nn_socket_init() -> nn_efd_init()  and local vars as similar values like in emfile.c failure above (rc=119, i=0, etc)\n. Yap let's close it.\n. ",
    "jnicholls": "LGTM\n. I think this thread has gone on long enough.  The bottom line is \u2013 coming from an expert's point of view \u2013\u00a0@gdamore is completely spot on with regards to everything said here, and you should close this issue and move on to more important things :)\n. ",
    "nickdesaulniers": "Some confusing here seems to be around whether the way \"strings\" are represented in C are the canonical form of strings in all other languages, when whether that is true or not is wholly orthogonal and irrelevant to nanomsg's protocol, which does not call for C style strings.\nIf you want a C style string from a message received from nanomsg, you must copy the message into a new buffer with length + 1 and explicitly null terminate it.  Nanomsg is more of a binary protocol than a text based protocol, so sending additional bytes for null termination is unnecessary.  If the raw bytes you sent should be treated by the receiver as a C style string, it's on the receiver or sender to handle null termination at the application level, not libnanomsg binding level.\nSorry for not letting sleeping dogs lie. :cold_sweat: :fearful: \n. I'm not sure if this symbol was left out on purpose or mistakenly?\n. indeed, needs a strlen(topic).  Thanks Bent!\n. cool thanks!\n. I started hacking up a test case, but I can't repro.  Let me take a close look at our library.\n```c\ninclude \"../src/nn.h\"\ninclude \"../src/pair.h\"\ninclude \"testutil.h\"\nint main ()\n{\n    int s = test_socket (AF_SP, NN_PAIR);\n    const char* msg = \"hello\";\n    const size_t len = strlen(msg) + 1;\n    nn_term ();\n    nn_send (s, msg, len, 0);\n    test_close (s);\n    return 0;\n}\n```\ndoes not reproduce the abort. sorry, the abort is coming from libuv:\n```sh\n\u279c  node-nanomsg git:(nanomsg_upgrade) gdb node\n(gdb) b abort\n(gdb) r test/standalone/term.js\nThread 1 \"node\" hit Breakpoint 1, __GI_abort () at abort.c:51\n51  abort.c: No such file or directory.\n(gdb) bt\n0  __GI_abort () at abort.c:51\n1  0x00000000015bc330 in uv__io_poll (loop=loop@entry=0x228e7c0 ,\ntimeout=0) at ../deps/uv/src/unix/linux-core.c:245\n\n2  0x00000000015abc56 in uv_run (loop=0x228e7c0 , mode=UV_RUN_ONCE)\nat ../deps/uv/src/unix/core.c:362\n\n3  0x0000000001384309 in node::Start(uv_loop_s, int, char const const, int, char const const*) ()\n4  0x000000000137de20 in node::Start(int, char**) ()\n5  0x00007ffff6b63830 in __libc_start_main (main=0x92e2b0 , argc=2, argv=0x7fffffffdf48,\ninit=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, \nstack_end=0x7fffffffdf38) at ../csu/libc-start.c:291\n\n6  0x000000000092fef1 in _start ()\n```. ",
    "x-yuri": "Actually, I'm trying to backport it from jessie to squeezy. And yes, debian.\n. See how I fixed this and other issues.\n. Yep, I believe you can close the issue.\n. Well, tcp apparently fails because of a demon running on port 5555.\n. ",
    "dreamjet": "I have got the idea.\n. ",
    "ricki": "Same issue here. In my case, eth0 has three AF_INET6 entries. A link local fec0::/10, a Teredo tunneling 2001::/32, and the default unicast address, which should be preferred over the others acording to RFC 6724.\n. ",
    "raniervf": "I think this not a really nanomsg issue.\nI discovered this issue occurs only when debugging with Windbg.\nOne better research is needed, to find out why.\n. No, occurs with and without thread, but only with TCP protocol.\nWith IPC protocol with thread or not, work without GPF.\nI believe that is Windbg problem.\n. ",
    "maxux": "Okay, found the problem. It's just that the socket is close too early and data are not sent. By slowing the shutdown, everything works. Sorry.\n. ",
    "asafyish": "We are also trying to use pub/sub and it seems to be inefficient - sending the message to all subscribers and doing the filtering on the subscriber side.\nFrom http://nanomsg.org/v0.5/nn_pubsub.7.html\n\"Since the filtering is performed on the Subscriber side, all the messages from Publisher will be sent over the transport layer.\"\nObviously, this is not what we were expecting.\n. Does it mean that setsockopt in node-nanomsg is not working correctly ?\njs\nSocket.prototype.setsockopt = function (level, option, value) {\n    return this._protect(nn.Setsockopt(this.binding, level, option, value));\n};\nNo length parameter...\n. ",
    "anshumang": "I added an autoreconf -i between 3 and 4.\n.....\n3. Go to the root directory of the package.\n4. ./configure\n......\n. Yes @reqshark I ran autoreconf to generate the configure script. I raised this issue because the README doesn't mention this.\n. There's a separate 'Build it on Windows' section..\n. @reqshark  PR submitted ! Closing the issue...\n. @wirebirdlabs  I will try to post my testcase....it's kind of messy to extract from the application. @gdamore It creates a problem to use a separate thread if there's a need to do a bunch of sends inside a short span of time. If this is of any help, I tried with zeromq and came across the same issue !\n. ",
    "mikalankes40": "Program terminated with signal 9, Killed.\n0 0xff1de4a8 in __pollsys () from /lib/libc.so.1\n1 0xff1ce190 in _pollsys () from /lib/libc.so.1\n2 0xff174b34 in poll () from /lib/libc.so.1\n3 0x0001a5ec in nn_poll (fds=0xffbfd628, nfds=3, timeout=5500) at src/core/poll.c:174\n4 0x00017948 in many ()\n5 0x00018638 in main ()\n. It seems that we only get a crash when we send the array of socket descriptors (fds[ ]) to nn_poll() having a socket descriptor value of 17 or higher...\n. Just to clarify. Sending fds = [5,8,11,14], i.e., four socket descriptors with the highest value of 14 is OK.\nHowever, sending fds = [5,8,11,14,17] will cause a crash in __pollsys().\n. ``` C\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \"nn.h\"\ninclude \"pubsub.h\"\ndefine MAX_NUM_OF_CONNECTED 30\ndefine LOOP_COUNTER 30\nint my_connect(int sock, const char *url) {\nint i, connect_success;\n\nconnect_success = 0;\n\nfor (i = 0; i < 20000; i++) { // Try to connect for maximum 20 seconds\n\n    if (nn_connect(sock, url) < 0) {\n\n        usleep(1000); // Wait for 1 ms and try again\n    }\n    else {\n\n        connect_success = 1;\n        break;\n    }\n}\n\nif (connect_success == 0) {\n\n    printf(\"nn_connect failed: %s\\n\", strerror(errno));\n    return -1;\n}\n\nreturn 0;\n\n}\nint main(int argc, char *argv[]) {\nstruct timespec ts1;\nint rc, i, j, bytes, nr_of_inout_sockets;\nchar buf[50], *buffer;\nstruct nn_pollfd items[MAX_NUM_OF_CONNECTED];\nint c_sock[MAX_NUM_OF_CONNECTED], s_sock[MAX_NUM_OF_CONNECTED];\n\nif (argc < 3) {\n\n    printf(\"\\n\\nUsage: %s SEND|RECV <URLS>\\n\\n\\\n    Example: %s SEND tcp://127.0.0.1:8880 tcp://127.0.0.1:8881 tcp://127.0.0.1:8882\\n\\n\",\n    argv[0], argv[0]);\n    return 0;\n}\n\nnr_of_inout_sockets = argc-2;\n\nif (strcmp(argv[1], \"RECV\") == 0) {\n\n    i = 2;\n    for (j = 0; j < nr_of_inout_sockets; j++) {\n\n        c_sock[j] = nn_socket(AF_SP, NN_SUB);\n        assert(c_sock[j] >= 0);\n\n        assert(nn_setsockopt(c_sock[j], NN_SUB, NN_SUB_SUBSCRIBE, NULL, 0) >= 0);\n\n        assert(my_connect(c_sock[j], argv[i]) >= 0);\n\n        items[j].fd = c_sock[j];\n        items[j].events = NN_POLLIN;\n\n        i++;\n    }\n\n    while (1) {\n\n        rc = nn_poll(items, nr_of_inout_sockets, 5000);\n\n        if (rc < 0) {\n\n            printf(\"nn_poll failed in 'main()': %s\\n\", strerror(errno));\n            break;\n        }\n\n        if (rc == 0) {\n\n            printf(\"Bailing out from 'nn_poll()' loop in 'main()'\\n\");\n            break;\n        }\n\n        for (j = 0; j < nr_of_inout_sockets; j++) {\n\n            if (items[j].revents & NN_POLLIN) {\n\n                bytes = nn_recv(items[j].fd, &buffer, NN_MSG, 0);\n\n                assert(bytes >= 0);\n\n                if (bytes > 0) {\n\n                    printf(\"(%s) Incoming: '%s'\\n\", argv[j+2], buffer);\n                    nn_freemsg(buffer);\n                }\n                else {\n\n                    printf(\"(%s) Got 0 bytes???\\n\", argv[j+2]);\n                }\n            }\n        }\n    }\n}\nelse if (strcmp(argv[1], \"SEND\") == 0) {\n\n    i = 2;\n    for (j = 0; j < nr_of_inout_sockets; j++) {\n\n        s_sock[j] = nn_socket(AF_SP, NN_PUB);\n        assert(s_sock[j] >= 0);\n\n        assert(nn_bind(s_sock[j], argv[i]) >= 0);\n\n        i++;\n    }\n\n    for (i = 0; i < LOOP_COUNTER; i++) {\n\n        for (j = 0; j < nr_of_inout_sockets; j++) {\n\n            clock_gettime(CLOCK_REALTIME, &ts1);\n            sprintf(buf, \"%ld:%ld\", ts1.tv_sec, ts1.tv_nsec);\n            //printf(\"Sender publishing t-stamp: %s\\n\", buf);\n            bytes = nn_send(s_sock[j], buf, strlen(buf)+1, 0);\n            assert(bytes == (strlen(buf)+1));\n        }\n\n        sleep(1);\n    }\n\n    printf(\"Sender out...\\n\");\n}\nelse {\n\n    printf(\"\\n\\nUsage: %s SEND|RECV <URLS>\\n\\n\\\n    Example: %s SEND tcp://127.0.0.1:8880 tcp://127.0.0.1:8881 tcp://127.0.0.1:8882\\n\\n\",\n    argv[0], argv[0]);\n    return 0;\n}\n\nreturn 1;\n\n}\n```\n. Thx for your help!\nI got the crash when I tried more than say 4 or 5 sockets, i.e., I ran something like:\n``` bash\n!/bin/bash\n./pubsub SEND tcp://127.0.0.1:8880 tcp://127.0.0.1:8881 tcp://127.0.0.1:8882 tcp://127.0.0.1:8883 tcp://127.0.0.1:8884 tcp://127.0.0.1:8885 & sender=$!\n./pubsub RECV tcp://127.0.0.1:8880 tcp://127.0.0.1:8881 tcp://127.0.0.1:8882 tcp://127.0.0.1:8883 tcp://127.0.0.1:8884 tcp://127.0.0.1:8885 & receiver=$!\nsleep 40\nkill $sender $receiver\n```\nI don't know how to check if it is a 32 or 64 bit build. How do I build Nano in 64 bit mode then?\n. We are using Oracle Solaris. When built with 64-bit then it worked!! However, we are still dependent on the 32-bit version since nanomsg must be linked together with 32-bit applications... Any idea why 32-bit does not work?\n. Hi again. We used the memory debugger tool dbx and got this memory fault after a lot of struggle:\n\n``` C\nWrite to unallocated (wua) on thread 2:\nAttempting to write 4 bytes at address 0x98ed0\n    which is just past heap block of size 64 bytes at 0x98e90\nThis block was allocated from:\n        [1] nn_poller_init() at 0x22b08\n        [2] nn_worker_init() at 0x1b9e4\n        [3] nn_socket() at 0x17740\n        [4] main() at 0x16c84\nt@2 (l@2) stopped in nn_poller_add at 0x00022bb8\n0x00022bb8: nn_poller_add+0x0020:       st       %i1, [%g3 + %g2]\n```\n\nThe memory bug is connected to the struct pollfd *pollset variable in the file poller_poll.h:\nC\n31: struct nn_poller {\n32:\n33:     /* Actual number of elements in the pollset. */\n34:     int size;\n35:\n36:     /* Index of the event being processed at the moment. */\n37:     int index;\n38:\n39:     /* Number of allocated elements in the pollset. */\n40:     int capacity;\n41:\n42:     /* The pollset. */\n43:     struct pollfd *pollset;\nThis variable is allocated to an incorrect size (too small) in the functions nn_poller_init() and nn_poller_add(). The correct allocation size is shown below in the diff:\n``` C\n poller_poll.inc\n--- poller_poll_MODIFIED.inc\n**\n 31,37 \n    self->index = 0;\n    self->capacity = NN_POLLER_GRANULARITY;\n    self->pollset =\n!       nn_alloc (sizeof (struct pollfd ) * NN_POLLER_GRANULARITY,\n            \"pollset\");\n    alloc_assert (self->pollset);\n    self->hndls =\n--- 31,37 ---\n    self->index = 0;\n    self->capacity = NN_POLLER_GRANULARITY;\n    self->pollset =\n!       nn_alloc (sizeof (struct pollfd) * NN_POLLER_GRANULARITY,\n            \"pollset\");\n    alloc_assert (self->pollset);\n    self->hndls =\n***\n 59,65 ***\n      self->capacity *= 2;\n      self->pollset = nn_realloc (self->pollset,\n\n!             sizeof (struct pollfd *) * self->capacity);\n          alloc_assert (self->pollset);\n          self->hndls = nn_realloc (self->hndls,\n              sizeof (struct nn_hndls_item) * self->capacity);\n--- 59,65 ---\n      self->capacity *= 2;\n      self->pollset = nn_realloc (self->pollset,\n\n!             sizeof (struct pollfd) * self->capacity);\n          alloc_assert (self->pollset);\n          self->hndls = nn_realloc (self->hndls,\n              sizeof (struct nn_hndls_item) * self->capacity);\n```\nAllocating the size of pointers instead of the size of the data-structure will result in a too small memory allocation which in turn results in memory corruption when this allocated memory is accessed in the function nn_poller_add() in poller_poll.inc:\nC\n69:    /* Add the fd to the pollset. */\n70:    self->pollset [self->size].fd = fd;\n71:    self->pollset [self->size].events = 0;\n72:    self->pollset [self->size].revents = 0;\nThis bug will not be as visible in 64bit mode compared to 32 since the crash occurs when using >4 socket descriptors in 32bit and >8 socket descriptors in 64bit mode. The bug does not appear in Linux since the default polling mechanism in Linux is epoll, while the only mechanism available in Solaris is poll.\n. Thx. No you can commit the change, I don't mind the credits.\n. ",
    "romanoved": "Ok. But my question was not so clear, sorry. The point is that these constants are no suitable NN_NS_ * namespace (required for nn_symbol_info). Should I define something like NN_NS_POLL for this?\n. Yes, it works as expected.\n. The following python sample describes the conception (python binding from https://github.com/romanoved/nanomsg-python).\nThere are 2 independent processes, client and server; start with python nanomsg_reqpep.py server and python nanomsg_reqpep.py client\nProblems occurs when client return from poll before the response delivered.\nFor 32 random bit messages: slow memory leak in client process.\nFor 32 random bit messages: positive probability to get response for (one of) previous request while a new request have been already done (bad_reply in debug print like 4727 rps; [('total', 497), ('timeout', 259), ('polled', 239), ('bad_reply', 5)])\nFor more than 32bit messages: positive probability for abort with message Assertion failed: nn_getl ((uint8_t*) p - sizeof (uint32_t)) == NN_CHUNK_TAG (src/utils/chunk.c:211)\n``` python\n!/usr/bin/python\ncoding: utf-8\nimport sys\nimport time\nimport threading\nimport random\nfrom collections import defaultdict\nimport nanomsg\nserver_addr = 'ipc://./server'\ndevice_addr = 'inproc://inproc'\nclass EchoWorker(threading.Thread):\n    def init(self):\n        threading.Thread.init (self)\n        self.daemon = True\n        self.sock = nanomsg.Socket(nanomsg.REP)\n        self.sock.connect(device_addr)\ndef run(self):\n    while 1:\n        req = self.sock.recv()\n        time.sleep(0.001 + random.random() * 0.008)\n        self.sock.send('reply_to:' + req)\n\ndef server_main():\n    proxy_sock_req = nanomsg.Socket(nanomsg.REP, domain=nanomsg.AF_SP_RAW)\n    proxy_sock_req.bind(server_addr)\nproxy_sock_rep = nanomsg.Socket(nanomsg.REQ, domain=nanomsg.AF_SP_RAW)\nproxy_sock_rep.bind(device_addr)\n\ndevice = nanomsg.Device(proxy_sock_req, proxy_sock_rep)\n\necho_workers = [\n    EchoWorker()\n    for i in xrange(40)\n]\n\nfor worker in echo_workers:\n    worker.start()\n\ndevice.start()\n\nclass Stat(object):\n    def init(self, print_cnt):\n        self.print_cnt = print_cnt\n        self.lock = threading.Lock()\n        self.stat = defaultdict(int)\n        self.total = 0\n        self.ts = time.time()\n    def call(self, _id):\n        with self.lock:\n            self.stat[_id] += 1\n            self.total += 1\n            if self.total == self.print_cnt:\n                ts = time.time()\n                print int(self.total/(ts-self.ts)), 'rps;', sorted(self.stat.iteritems(), reverse=True)\n                self.stat = defaultdict(int)\n                self.total = 0\n                self.ts = ts\nclass SpeakerWorker(threading.Thread):\n    def init(self, stat):\n        self.stat = stat\n        threading.Thread.init(self)\n        self.daemon = True\n        self.sock = nanomsg.Socket(nanomsg.REQ)\n        self.sock.connect(server_addr)\n    self.poll = nanomsg.Poll()\n    self.poll.register(self.sock.fd, nanomsg.POLLIN)\n\ndef run(self):\n    while 1:\n        self.stat('total')\n        req = str(random.getrandbits(32))\n        self.sock.send(req, flags=nanomsg.DONTWAIT)\n\n        poll_result = self.poll.poll(5)\n\n        if poll_result:\n            self.stat('polled')\n            rep = self.sock.recv(flags=nanomsg.DONTWAIT)\n            if rep != 'reply_to:' + req:\n                self.stat('bad_reply')\n        else:\n            self.stat('timeout')\n\ndef client_main():\n    stat = Stat(1000)\nspeaker_workers = [\n    SpeakerWorker(stat)\n    for i in xrange(10)\n]\n\nfor worker in speaker_workers:\n    worker.start()\n\nfor worker in speaker_workers:\n    worker.join()\n\nif name == 'main':\n    usage = '{} server|client'.format(sys.argv[0])\n    if len(sys.argv) != 2:\n        print usage\n    elif sys.argv[1] == 'server':\n        server_main()\n    elif sys.argv[1] == 'client':\n        client_main()\n    else:\n        print usage\n```\n. Alas, I can not find documentation page describing assumed invariant: \"if we send a new message, the previous is automatically canceled\".\nIn fact, the above is a non-standard usage of the request/reply model, but that is exactly what is required.\n. Its not Python FFI, just python C API: https://github.com/romanoved/nanomsg-python/blob/master/_nanomsg_cpy/wrapper.c . It is good point that the problem can be in binding, but for send/recv function everything seems evidently. Of course, C example is preferred, but it will take some time. I'll do it at one of these days, mb tomorrow.\nThen. RAW mode used only on \"server\" endpoint (and no problem with server at all, including possible problems with inproc and other), but the problem on \"client\". The reduced version (below) of \"client\" without stats and code of \"server\":\n``` python\n!/usr/bin/python\ncoding: utf-8\nimport time\nimport threading\nimport random\nimport nanomsg\nserver_addr = 'ipc://./server'\nclass SpeakerWorker(threading.Thread):\n    def init(self):\n        threading.Thread.init(self)\n        self.daemon = True\n        self.sock = nanomsg.Socket(nanomsg.REQ)\n        self.sock.connect(server_addr)\n    self.poll = nanomsg.Poll()\n    self.poll.register(self.sock.fd, nanomsg.POLLIN)\n\ndef run(self):\n    while 1:\n        self.stat('total')\n        req = str(random.getrandbits(32))\n        self.sock.send(req, flags=nanomsg.DONTWAIT)\n\n        poll_result = self.poll.poll(5)\n\n        if poll_result:\n            rep = self.sock.recv(flags=nanomsg.DONTWAIT)\n            if rep != 'reply_to:' + req:\n                print 'bad_reply', req, rep\n\ndef client_main():\n    speaker_workers = [\n        SpeakerWorker()\n        for i in xrange(10)\n    ]\nfor worker in speaker_workers:\n    worker.start()\n\nfor worker in speaker_workers:\n    worker.join()\n\nif name == 'main':\n        client_main()\n```\n. For a simple pure C client the leak disappears. I will consider this python binding in more detail.\nBut the rest issues holds:\nFor <=18 random bytes messages: positive probability to get response for (one of) previous request while a new request have been already done (see assert(!strncmp(req_buf, rep_buf+prefix_size, msg_size));)\nFor more than 18 bytes messages: positive probability for abort with message Assertion failed: nn_getl ((uint8_t*) p - sizeof (uint32_t)) == NN_CHUNK_TAG (src/utils/chunk.c:211)\nPrevious statement about 32bit messages was wrong (len(str(random.getrandbits(32)))!=32).\nThe client send requests to server which responds with \"prefix+request\" in 0.001 + random.random() * 0.008 seconds. It is possible to use python code above (python nanomsg_reqpep.py server), because server side works exactly as expected.\n``` c++\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nstatic const char* server_addr = \"ipc://./server\";\nint speaker_worker(void* thread_arg)\n{\n    size_t i = 0;\n    struct nn_pollfd poll_s;\n    size_t msg_size = 32;\n    int poll_rv = 0;\nconst char* prefix = \"reply_to:\";\nsize_t prefix_size = strlen(prefix);\n\nchar req_buf[msg_size];\nchar rep_buf[msg_size + prefix_size];\n\nint sock = nn_socket (AF_SP, NN_REQ);\nassert (sock >= 0);\n\npoll_s.fd = sock;\npoll_s.events = NN_POLLIN;\npoll_s.revents = 0;\n\nassert (nn_connect (sock, server_addr) >=0 );\nfor (;;)\n{\n    for (i=0; i<sizeof(req_buf); ++i)\n        req_buf[i] = rand ();\n\n    assert(nn_send(sock, req_buf, sizeof(req_buf), NN_DONTWAIT) == sizeof(req_buf));\n\n    assert((poll_rv = nn_poll(&poll_s, 1, 5)) >= 0);\n\n    if (poll_rv)\n    {\n        assert(nn_recv(sock, rep_buf, sizeof(rep_buf), NN_DONTWAIT) == sizeof(rep_buf));\n        assert(!strncmp(prefix, rep_buf, prefix_size));\n        assert(!strncmp(req_buf, rep_buf+prefix_size, msg_size));\n    }\n    putchar('\\n');\n}\n\nreturn 0;\n\n}\nint main(int argc, const char * argv[])\n{\n    int n_threads = 10;\n    int i;\n    pthread_t tid[n_threads];\nfor (i=0; i<n_threads; ++i)\n    assert(pthread_create(&(tid[i]), NULL, &speaker_worker, NULL) == 0);\nfor (i=0; i<n_threads; ++i)\n    assert(pthread_join(tid[i], NULL) == 0);\n\n}\n```\n. Last 2 assertions (including nn_getl) happen in C client as well as in python.\nFor the server side also there is no dependence on the language.\n``` c++\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nstatic const char server_addr = \"ipc://./server\";\n//static const char device_addr = \"inproc://device\";\nstatic const char* device_addr = \"ipc://.device\"';\nconst size_t max_msg_size = 10240;\nint echo_worker(void thread_arg)\n{\n    const char prefix = \"reply_to:\";\n    size_t prefix_size = strlen(prefix);\nint sock = nn_socket (AF_SP, NN_REP);\nassert (sock >= 0);\n\nassert (nn_connect (sock, device_addr) >=0 );\n\nchar msg_buf[prefix_size + max_msg_size];\nmemmove(msg_buf, prefix, prefix_size);\nchar* msg = msg_buf + prefix_size;\n\nfor (;;)\n{\n    int recv_r = nn_recv(sock, msg, max_msg_size, 0);\n    assert (recv_r >= 0);\n    usleep((int)(1000.*(1 + 8 * rand() / RAND_MAX)));\n    assert(nn_send(sock, msg_buf, prefix_size + recv_r, 0) == prefix_size + recv_r);\n}\n\nreturn 0;\n\n}\nint main(int argc, const char * argv[])\n{\n    int n_threads = 40;\n    int i;\n    pthread_t tid[n_threads];\nint sock_server = nn_socket (AF_SP_RAW, NN_REP);\nassert (sock_server >= 0);\n\nassert (nn_bind (sock_server, server_addr) >=0 );\n\nint sock_device = nn_socket (AF_SP_RAW, NN_REQ);\nassert (sock_device >= 0);\n\nassert (nn_bind (sock_device, device_addr) >=0 );\n\nfor (i=0; i<n_threads; ++i)\n    assert(pthread_create(&(tid[i]), NULL, &echo_worker, NULL) == 0);\n\nnn_device (sock_server, sock_device);\n\n}\n```\n. I dont understand you. AF_SP sockets, not AF_SP_RAW, used with nn_send/nn_recv functions in workers both on the client side and on the server side. There is only place where raw sockets created for nn_device, but I dont directly deal with them. Moreover, nn_recv returns correct size of request which includes no headers and no other additional information.\n. I work with C variant of \"client\" and \"server\" indeed.\nThe problem is pretty well reproduced on ubuntu 10.04 and 12.04.\nBut on 14.04, this construction seems to be working (no abort on nn_getl) after replacing device_addr = \"ipc://.device\" to device_addr = \"inproc://device\"; otherwise for some message size threre is a corrupted message at client's point of view (wrong size - 4 extra bytes - with shifted and truncated response).\n. I try with 0.5-beta from http://nanomsg.org/download.html and with the latest version from github.\nI was able to perform some tests on mac os 10.10.2 (indeed, it was necessary to fix the obvious bugs that gcc ignores). On linux assertion raises immediately or on the ~ first thousand of requests. Stack trace will be in the following message.\nWith device_addr = \"ipc://./device\"' it rises no assertion but there is no requests without timeout. with device_addr = \"inproc://device\" it can fail (on assert(!strncmp(req_buf, rep_buf+prefix_size, msg_size));) after 3 .. 10 minutes (and i set msg_size = 5001). With start server, start client, break client, start client it is possible to reproduce assertion on nn_getl, bot nondeterministically and after a significant wait.\n. nn_device doesn't work through ipc or tcp both on linux and temporally available mac os, actually no message received in server's echo_worker.\nWhen i build executable with -g to get core dump then it needs some time to reproduce (on linux) nn_getl assertion.\n``\n[New LWP 28216]\n[New LWP 28217]\n[New LWP 28219]\n[New LWP 28220]\n[New LWP 28218]\n[New LWP 28224]\n[New LWP 28214]\n[New LWP 28212]\n[New LWP 28222]\n[New LWP 28215]\n[New LWP 28221]\n[New LWP 28223]\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nCore was generated by./nanomsg_client'.\nProgram terminated with signal SIGABRT, Aborted.\n0  0x00007fe47aa8a0d5 in raise () from /lib/x86_64-linux-gnu/libc.so.6\nThread 12 (Thread 0x7fe475e3e700 (LWP 28223)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 8, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 8\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 11 (Thread 0x7fe476e40700 (LWP 28221)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 4, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 4\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 10 (Thread 0x7fe479e46700 (LWP 28215)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 9, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 9\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 9 (Thread 0x7fe47663f700 (LWP 28222)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 5, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 5\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 8 (Thread 0x7fe47b697700 (LWP 28212)):\n0  0x00007fe47ae1b148 in pthread_join () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n1  0x0000000000400cdb in main (argc=1, argv=0x7fffafcff038) at nanomsg_client.c:62\n    n_threads = 10\n    i = 0\n    tid = <error reading variable tid (frame address is not available.)>\n    __PRETTY_FUNCTION__ = \"main\"\n\nThread 7 (Thread 0x7fe47a647700 (LWP 28214)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 0, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 0\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 0\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 6 (Thread 0x7fe47563d700 (LWP 28224)):\n0  0x00007fe47ab47a23 in epoll_wait () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b047628 in nn_poller_wait () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x00007fe47b04c14e in nn_worker_routine () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n3  0x00007fe47b04ef70 in nn_thread_main_routine () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n4  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n5  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n6  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 5 (Thread 0x7fe478643700 (LWP 28218)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 2, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 2\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 4 (Thread 0x7fe477641700 (LWP 28220)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 3, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 3\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 3 (Thread 0x7fe477e42700 (LWP 28219)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 7, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 7\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 2 (Thread 0x7fe478e44700 (LWP 28217)):\n0  0x00007fe47ab3b9d3 in poll () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47b043265 in nn_poll () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n2  0x0000000000400b07 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:38\n    i = 23\n    poll_s = {fd = 1, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 1\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n3  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n4  0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n5  0x0000000000000000 in ?? ()\nNo symbol table info available.\nThread 1 (Thread 0x7fe479645700 (LWP 28216)):\n0  0x00007fe47aa8a0d5 in raise () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n1  0x00007fe47aa8d83b in abort () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n2  0x00007fe47b04d6c9 in nn_err_abort () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n3  0x00007fe47b04cac6 in nn_chunk_getptr () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n4  0x00007fe47b04c8fd in nn_chunk_size () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n5  0x00007fe47b04ce1e in nn_chunkref_size () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n6  0x00007fe47b0410ee in nn_recvmsg () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n7  0x00007fe47b0408c1 in nn_recv () from ./nanomsg_build/lib/libnanomsg.so.0\nNo symbol table info available.\n8  0x0000000000400b49 in speaker_worker (thread_arg=0x0) at nanomsg_client.c:42\n    i = 23\n    poll_s = {fd = 6, events = 1, revents = 1}\n    msg_size = 23\n    poll_rv = 1\n    prefix = 0x400e0f \"reply_to:\"\n    prefix_size = 9\n    req_buf = <error reading variable req_buf (frame address is not available.)>\n    rep_buf = <error reading variable rep_buf (frame address is not available.)>\n    sock = 6\n    __PRETTY_FUNCTION__ = \"speaker_worker\"\n\n9  0x00007fe47ae19e9a in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0\nNo symbol table info available.\n10 0x00007fe47ab4738d in clone () from /lib/x86_64-linux-gnu/libc.so.6\nNo symbol table info available.\n11 0x0000000000000000 in ?? ()\nNo symbol table info available.\n``\n. I only played with message size and usage of NN_DONTWAIT flag in client, with device_addr and debugging printing in server. So conceptually it is the same code that posted above.\n. The code posted above reproduce problem on linux. If you want its with exact changes for mac os than i can post in only on next work day, ie on monday - now i have no a\u0441\u0441ess to it.\nBut there are all changes (as i remember):\n  add include phtread.h\n  change return type of thread function\n  set msg_size to 1000 and to 5001 - reproduced with both\n  unsuccessfully try to change inproc to tcp or ipc - nn_device does not work with them\n. In these cases I saw extremely low CPU utilization in server process. And nothing was printed when I replacedassert (recv_r >= 0)to something likeprintf(\"recv_r %d\\n\", recv_r);`.  That's no messages resieved in server echo_worker's for loop.\n. What do you mean by fine work? The client works independently from server, and in case of server down it just wait for poll timeout for all messages. But it is not the expected behavior while server enabled.\n\nIs it possible that this is slow start? I.e. your client has to wait until both the server and the client are connected before sending requests...\n\nWhat is the best way to check it? Although I think it is unlikely, because device_addr used only in server process.\nAnd about reproduction of behavior. I'm confused.. Right now I have no open VPS to show the behavior under linux and have no direct access to mas os to check code. In this case, I can not think of anything better than to wait until next week. I'll try to think of something. At least, for not to waste time in vain.\n. To all of that above. I commit here a \"test button\", it should be compiled under the mac without patches . You cat run it with make test. Printing dots is a bad way because dot is printed even in the case of undelivered message, so the committed variant counts events separately. Actually, I on this I got (except of make output) nn_recv(sock, rep_buf, sizeof(rep_buf), NN_DONTWAIT) != sizeof(rep_buf): 5015 != 5011. Please try it with different device_addr and msg_size.\nNext I'll try it without nn_device node. Conceptually, this is only possible simplification.\n\nYou're welcome to see if you can figure it out.\n\nUnfortunately, I started with that. At the moment I understand the general scheme, but some places are baffle me. But really, if you can not reproduce the said case, then all that remains for me is to try to deal with it with my own hands. Especially that the title of this issue has been resolved (as unrelated to the library) and the problem with inproc is going to be solved.\n\nMany many people are using libnanomsg without difficulty\n\nIs they used nanomsg in similar manner (mean, have undelivered messages as a regular case)?. There is less problems when I wait any message to be delivered. And, if we were talking about, it was surprising for me that there is no option timeout in nn_send/nn_recv symbols.\n. Yes, it works through PAIR protocol without fails. But this is not applicable for me. Strictly speaking, the following model is required:\nClient sends non-blocking requests to set of sokets (asynchronously realizing actual sending of data) and wait in poll for results. Client must finish all operations before global dynamic timeout exceeded. Next, each of these sockets associated with nn_device and resends request to poll of stateless worker (each has its own type of workers). Without any tricks, worker can works longer than timeout (I tried to model it in posted programs), which follows to described problems.\nFor these reasons, I do not see a way to follow the advice about not to use NN_DONTWAIT (there is no managed time in client which can be spent to wait for slow requsts).\nNow, as a workaround I include information about timeout to request and use separate process which reply to timeouted requests that works good enough in practice. So, are there any advice for using nanomsg for this case? Or is the reason that why I want strange? Generally speaking, I'm going to write my own bicycle, but found nanomsg which description does not contradict with the possibility of required implementation.\n. > I think you're misusing req/rep. Generally they are intended to be synchronous for a given socket. You can use poll and dontwait to multiplex work amongst several sockets but you don't want to use multiple sends per socket.\nI don't wand to do multiple sends per socket, but I want to cancel current message and send new. Implicitly, this option is available, because of the existence NN_SNDTIMEO/NN_RCVTIMEO (or is it also bad to get fail on nn_recv with preset NN_RCVTIMEO and then send new message to the same socket? but in the last case this model becomes far less applicable in practice). And since my dynamic timeout it seems redundantly to call nn_setsockopt on each send.\n. Of course. Moreover, I think it makes sense to formulate founding bug in new issue - title of this can be misleading - and close this as not related with nanomsg library directly. Should I do it?\n. I still think that an original problem (memory leak) was at python level, where some bugs have been fixed. Unfortunately, the original (blow-up) example has been lost, and the given in issue shows no difference after patch from #385 applied. I see in details later.\nBy the way, is there any news about the nn_recv/nn_send fails?\n. ",
    "anbhole": "faced the same problem implementing nn_poll using JNI. would +1 for it.\n. ",
    "thelinuxlich": "For reference, something that builds on HTTP/2:\nhttp://www.grpc.io/\n. Actually I think it is a competitor\n. ",
    "smcduck": "I don't know how to usr irc, so i came here.thanks a lot.\n. ",
    "kaixianghu": "sorry, can you elaborate more on the requirement of one socket/ep bounding to a specific address?\nif i want to use req/rep pattern to distribute workloads among multiple rep workers, should i not have each worker to bind and connect to the same address where req ep will send message to?\n. maybe i am missing something, isn't rep endpoints workers? and they need to bind to the socket, whereas req endpoints are clients that connect to it?\n. ",
    "killkrt": "Hi @gdamore ,\nI'm creating a cross-platform project (that depends also on nanomsg) and I would like to keep my build process as simple as possibile, so in order to avoid putting switches in my CMakeLists.txt to manage OS X, Linux and Win in different way I would prefer to use the same approach for all the platforms. Since I've seen that nanomsg supports CMake build only for Windows, I've opt for using autogen for all the platforms.\nThanks.\n. ",
    "rgeary1": "Stack trace below.  Looks like the worker thread has returned but the message isn't being received by the main thread :\n(gdb) bt\n0  0x00007fdca3e29c8d in poll () from /lib64/libc.so.6\n1  0x00007fdca4732ed9 in nn_efd_wait (self=self@entry=0xb4e734, timeout=timeout@entry=-1) at ../src/utils/efd.c:48\n2  0x00007fdca472e316 in nn_sock_recv (self=0xb4e660, msg=msg@entry=0x7fffebcfe970, flags=flags@entry=0) at ../src/core/sock.c:671\n3  0x00007fdca472ba3e in nn_recvmsg (s=s@entry=0, msghdr=msghdr@entry=0x7fffebcfea20, flags=flags@entry=0) at ../src/core/global.c:878\n4  0x00007fdca472bd28 in nn_recv (s=s@entry=0, buf=buf@entry=0xb4ea80, len=, flags=flags@entry=0) at ../src/core/global.c:724\n5  0x0000000000400fce in main (argc=, argv=) at ../perf/inproc_lat.c:107\n(gdb) i threads\n  Id   Target Id         Frame\n  2    Thread 0x7fdca3d34700 (LWP 21605) \"lt-inproc_lat\" 0x00007fdca3e35833 in epoll_wait () from /lib64/libc.so.6\n`* 1    Thread 0x7fdca4b5d700 (LWP 21591) \"lt-inproc_lat\" 0x00007fdca3e29c8d in poll () from /lib64/libc.so.6\n(gdb) thread 2\n[Switching to thread 2 (Thread 0x7fdca3d34700 (LWP 21605))]\n0  0x00007fdca3e35833 in epoll_wait () from /lib64/libc.so.6\n(gdb) bt\n0  0x00007fdca3e35833 in epoll_wait () from /lib64/libc.so.6\n1  0x00007fdca472f4e4 in nn_poller_wait (self=self@entry=0x7fdca4960a44 , timeout=10000) at ../src/aio/poller_epoll.inc:186\n2  0x00007fdca4731da0 in nn_worker_routine (arg=0x7fdca4960a00 ) at ../src/aio/worker_posix.inc:176\n3  0x000000000040122d in nn_thread_main_routine (arg=) at ../perf/../src/utils/thread_posix.inc:35\n4  0x00007fdca40f952a in start_thread () from /lib64/libpthread.so.0\n5  0x00007fdca3e3522d in clone () from /lib64/libc.so.6\n(gdb)\n. Replacing \"inproc://inproc_lat\" with \"ipc://inproc_lat\", I can trigger the same hang, but it's less common.  It's repeatable if you call it 100 times\n. I've traced the problem to this code in sock.c\n/*\n     *  Double check if pipes are still available for receiving\n     */\n    if (!nn_efd_wait (&self->rcvfd, 0)) {\n        self->flags |= NN_SOCK_FLAG_IN;\n    }\nWhen it hangs, the nn_efd_wait call is returning -ETIMEDOUT.  I haven't understood enough of sock.c to know how the flags work here.\n. ",
    "bsanlang": "I have define SOCKET_ADDRESS \"tcp://127.0.0.1:8555\". But it can not receive anything.\n. That's ok! Thank you baxtersa.\n. ",
    "whatacold": "I can't reproduce this issue with the newest master branch code.\nMaybe you should try it with the newest code?\n. ",
    "krafczyk": "I'm getting exactly the same issue.\nFor me, the first example returns:\n0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 \n 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39 \n 40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59 \n 60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79 \n 80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 \n100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 \n120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 \n140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 \n160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 \n180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199\nThe second example gives me:\n1   2   3   6   7   8   9  10  11  12  13  15  16  17  18  19 \n 20  21  23  24  25  26  27  28  29  30  31  32  34  35  36  37  38  39 \n 40  41  42  43  44  45  50  51  52  56  58  59 \n 60  61  62  63  64  65  67  68  69  70  71  73  74  75  76  77  78  79 \n 80  81  82  83  84  85  86  87  88  92  93  95  96  97  98  99 \n100 101 103 104 105 106 108 109 110 112 113 114 115 116 117 118 119 \n120 121 123 124 125 126 127 129 131 132 133 134 135 136 137 138 139 \n140 141 142 143 145 146 147 148 149 153 157 158 \n160 161 164 169 175 177 181 185 186 187 188 190 191 192 195 196 199\nI have precisely the same suspicion as @kristianlm as to why the messages aren't getting through even with NN_LINGER set.\nI have a similar program where I tried to sleep before shutting down the socket. This seemed to work every time.\nI also tried to sleep after calling nn_shutdown and before exiting, but this didn't work.\nI'm on Arch as well.\nLinux Wagner 4.2.2-2-custom #1 SMP PREEMPT Sat Oct 3 23:05:46 CEST 2015 x86_64 GNU/Linux\n. ",
    "henrywoo": "I am using c++11's thread.\n. Sorry I could not find this function\n. Problem solved. Thanks.\n. ",
    "jaybny": "damn.. sad to say, i need to move on from nanomsg... i need to launch in 40 days... have 1000s of line of code. cant believe mangos is leaving us behind.. maybe someone should write an alternate implementation of Mangos in C? \n. If you get it started, I can help..\nOn Jul 16, 2015 2:42 PM, \"gdamore\" notifications@github.com wrote:\n\n(I figure such a project would take something on the order of 1-2 man\nweeks, for me (Garrett weeks?). It may take another developer considerably\nlonger if they don't come with my background in mangos and C.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/432#issuecomment-122111431.\n. \n",
    "skyformat99": "very very +n. Other people also found the same problem, the link:\nhttps://github.com/nanomsg/nanomsg/pull/852\nWhen can fix it ?  thx :)\n. ref the Writing custom protocol for nanomsg:\nhttp://vitiy.info/writing-custom-protocol-for-nanomsg/\n. Change too much momentum, against such changes,\nand affect compile process on the Linux under.\nSimple processing method:   copy stdint.h  to include folder of VS2008.\n. By setting the tag (resp. u.ref[0]) to 0, Were it to do so, it easily would have made a memory leak\u3002\n. nn_fsm_bad_action\nnn_fsm_bad_source\nThese two functions are different\u3002\ud83d\ude04. This PR has been modified too much, not good. \nAnd it has to do with the version of GCC, \nwhich is bad for embedded development and supports the author's point of view.. What is a good way to solve it?. @wcyangg \nquestion point   \uff1e\uff1e   \u3010that prints the error code?\u3011\u3002\nso\uff0c Please add rc return value\u3002. create thread own nanosock in each child thread.. ok. ",
    "minyang": "QNX has free 30-day free evaluation program, although I'm not sure if nanomsg has any plan to officially support QNX.  I'm actively using nanomsg on QNX and it has been working great.  My use case is rather simple (mostly \"req-res\"-based data exchange), though.  Will report later if any other issue comes up.\np.s. I am really enjoying using nanomsg and love its lightweight, simple, and structured design.  Thanks a lot for developing and releasing such a nice package!\n. @gdamore I'm afraid that the IPC problem still exists with the version that I tested, AFAIK.\n@wirebirdlabs Just as a clarification, I reported the issue purely based on my personal interests wishing nanomsg be more complete in terms of cross-platform support, because I like nanomsg.  Especially, its lightweight, simple, but efficiency and scalability-oriented design is what I really like.\nI understand your concerns from the developer resource's perspective and you made valid points.  However, I don't think I can agree with your point where the issue is more a QNX concern than a nanomsg concern.  With the same logic, would you think it would be a MS/Windows concern if the same issue occurred on Windows, which is a commercial, mainstream, and proprietary platform?\nIt looks to me that nanomsg tries to support multi-platforms and I just wanted to bring the issue up to you.  Again, this issue started entirely based on my personal interests.  As I said in my previous comment, my use case is quite simple and I do not use any feature relying on IPC -- no problem with me.  Whether or not nanomsg has a plan to support QNX is totally up to nanomsg -- no question.  Also, it's totally up to you if this should be closed or not.  I'm just trying to be helpful.  On my spare time, I might try to look more into this issue if this issue remains open later.\n. As just an end-user of nanomsg, can't agree more with you @gdamore, especially in terms of usability, functionality, and cross-platform support.  Let me see if I can look into the issue a bit more, including the path issue that you suggested.\np.s. By the way, I love Apple... ;)\n. OK, I looked into a bit more yesterday.  Here are a bit of updates:\n- I got ipc_shutdown and separation working after updating IPC address from ipc://test.ipc to ipc:///tmp/test.ipc (explicit use of /tmp).  Yes, @gdamore, your previous guess was correct!\n- IPC itself seems to work -- using a simple tutorial example, I was able to exchange messages via IPC protocol.  What was failing was the ipc unit test.  Inipc, the first part -- send/recv of 40 byte messages -- worked fine, but the following tests failed (e.g., sending large payloads (10000 bytes) one time and sending small payloads (3 bytes)).  I checked out a log file with my own debug messages, and it looks like something crashed or so (only partial messages were printed out).  From make check's point of view, this failed test looked as if it hanged.\nI was too tired yesterday to narrow down which line of code cause the issue.  Hopefully, I'll have more energy tonight or this weekend.\n. No, my build directory was just a local folder under my home, and I did all my testing on the same host.\nOne question, is it a normal or expected behavior where make check hangs if one of unit tests crashes (e.g., abort, exit)?  I see two different behaviors: a) hangs (in case of ipc) and b) graceful handling, i.e., tests failed with coredump, moving on to the next test, and failure reports.\n. Sounds like there have been lots of activities going on here.  Glad to hear that nanomsg has been updated a lot!  Sure, let me give it a shot with either git tip or Release 0.9 -- I'd be happy to try it out.\n. This item was off my mind for a while \u2014 thanks for getting back to the issue.\nGreat to know that 1.0.0 has been finally released.  Please give me a few days \u2014 I\u2019ll follow up on this during this holiday.\n\nOn Nov 22, 2016, at 8:52 PM, gdamore notifications@github.com wrote:\nAny news on this? We have long ago released 1.0.0... absent any concrete info one way or the other, I'll probably close this.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/nanomsg/nanomsg/issues/433#issuecomment-262418002, or mute the thread https://github.com/notifications/unsubscribe-auth/AB9jAIH_vUgYe5CYv6koOUdiMqyWko0Uks5rA5xsgaJpZM4Fc4GF.\n. Last time I ran master on QNX (a couple months ago), QNX didn't seem to be supported by nanomsg.  I saw NN_HAVE_QNX is defined, but it wasn't actually used/implemented at that time.\n\nWith a bit of quick hacks on src and cmake (atomic add, semaphore, qnx-recognition, etc), I was able to compile the release 1.0.0 on QNX, but couldn\u2019t get all the test apps working.  Some worked and some others didn\u2019t -- crashed.\nI couldn't follow up recent changes, but am wondering if there are some recent changes on this end?. ",
    "zakharov": "I just tested commit cdd9d98f2c2e46cc9435694458d124254cfea104 , the one before \"fixes #421 warnings emitted by clang for websocket transport\". Everything used to work fine.\n. I apologize, this was a problem of javascript code. Nanomsg req/req with websockets works fine.\nPub/sub gives an assert error when browser disconnects, because xpub receives a message (may be it is a closing code), but this problem was before. I will trace it properly and open another issue.\nbest regards,\nAlexey\n. In fact we are also using nanomsg for control and monitoring systems. What I couldn't figure out is a generic mechanism to inform an application layer that there is new connection/disconnection happened. \n. Ok. I submitted pull request.\n. > Out of curiosity, what logic would this be triggering at the app layer? Would it be acceptable to make >hello and goodbye part of your app-layer protocol?\n\nFor the topologies you mention (PUB/SUB and REQ/REP), it might be best to consider the app-layer >unaware of the connect/disconnect events themselves, since nanomsg intentionally tries to abstract this.\n\n\"Hello and Goodbye\" message from the client and its id. In my app clients subscribe for certain updates and sometimes do not unsubscribe properly in this case I would like to stop fetching data which nobody is interested in.  \nSomething like PortEvents(), which Garrett mentioned, would be great.\nbest regards,\nAlexey\n. +1\n. Should be compare-and-swap operation instead.\n. ",
    "jbulow": "+1\n. ",
    "zhaozg": "releate with https://github.com/nanomsg/nanomsg/issues/450 ?\n. When I run VS debug it, it show block in efd.c \n```\n    [\u5916\u90e8\u4ee3\u7801]\n    [\u4e0b\u9762\u7684\u6846\u67b6\u53ef\u80fd\u4e0d\u6b63\u786e\u548c/\u6216\u7f3a\u5931\uff0c\u6ca1\u6709\u4e3a ntdll.dll \u52a0\u8f7d\u7b26\u53f7]    \n\nnanomsg.dll!nn_efd_wait(nn_efd * self, int timeout) \u884c 69  C\n    nanomsg.dll!nn_sock_recv(nn_sock * self, nn_msg * msg, int flags) \u884c 671   C\n    nanomsg.dll!nn_recvmsg(int s, nn_msghdr * msghdr, int flags) \u884c 878    C\n    nanomsg.dll!nn_recv(int s, void * buf, unsigned int len, int flags) \u884c 724 C\n    inproc_thr.exe!main(int argc, char * * argv) \u884c 103    C\n```\n\n```\nelif defined NN_HAVE_WINDOWS\nint nn_efd_wait (struct nn_efd *self, int timeout)\n{\n    int rc;\n    struct timeval tv;\nFD_SET (self->r, &self->fds);\nif (timeout >= 0) {\n    tv.tv_sec = timeout / 1000;\n    tv.tv_usec = timeout % 1000 * 1000;\n}\n\n69 HERE==>    rc = select (0, &self->fds, NULL, NULL, timeout >= 0 ? &tv : NULL);\n    wsa_assert (rc != SOCKET_ERROR);\n    if (nn_slow (rc == 0))\n        return -ETIMEDOUT;\n    return 0;\n}\nelse\n```\n. Sorry, this bug not fixed,\ninproc_thr.exe 100 100 will not continue sometimes.\n. Hi @taolinke, can you give a PR for this \n. \u719f\u4eba\uff0c\u54ea\u4f4d\u554a @taolinke \n. pull request \u5c31\u662f\u7ed9\u4e2agit\u7684\u8865\u4e01 \u6bd4\u5728\u5927\u8857\u4e0a\u78b0\u5230\u7684\u6982\u7387\u8981\u9ad8\u554a \u5c31\u4e0d\u5728\u8fd9\u513f\u6c9f\u901a\u611f\u60c5\u4e86\nPR: https://help.github.com/articles/using-pull-requests/\n. @anJava \u8bf7\u4e0d\u8981\u5728\u8fd9\u91cc\u8ba8\u8bba\u4e0e nanomsg \u65e0\u5173\u7684\u95ee\u9898, \u53e6\u5916\u5173\u4e8e opensecp \u8868\u793a\u62b1\u6b49, \u56e0\u4e3a\u6211\u8fd8\u6ca1\u6709\u5f00\u59cb\u5177\u4f53\u7684\u7814\u7a76\uff0c \u4f60\u53ef\u4ee5\u5230 https://github.com/zhaozg/openscep/issues \u8fd9\u91cc\u628a\u78b0\u5230\u7684\u95ee\u9898\u8d34\u51fa\u6765\uff0c\u4e5f\u8bb8\u65e0\u6cd5\u5bfe\u4f60\u7684\u95ee\u9898\u4f5c\u51fa\u7acb\u5373\u54cd\u5e94\uff0c\u4f46\u662f\u6211\u6709\u65f6\u95f4\u7684\u5316 \u4f1a\u53bb\u770b\u4e00\u4e0b\u7684\n. ",
    "qbradley": "I will try to repro and will report back. When I built the RUN_TESTS project locally all tests passed. If it is an intermittent failure I'll also see if it fails without my changes.\n. I ran tcp_shutdown.exe 10 times. It passed 5 times and failed 5 times as follows:\nsrc=0 type=33988\nAssertion failed: src == NN_SOCK_SRC_EP && type == NN_EP_STOPPED (C:\\Users\\qbrad_000\\dev\\nanomsg\\src\\core\\sock.c:830)\nThen I reverted my changes and ran tcp_shutdown.exe 10 times. It passed 7 times and failed 3 with the same error.\nMore than likely this is an existing intermittent failure. Just in case my change increases the likelihood of its occurrence I'll try and dig a little deeper in the tcp_shutdown.exe failure.\n. I made some progress reducing the complexity of the repro. Modifying main of tcp_shutdown.c as follows still repros:\n``` c\nint main ()\n{\n    int sb;\n    struct nn_thread thread;\n/*  Test race condition of sending message while socket shutting down  */\n\nsb = test_socket (AF_SP, NN_PUSH);\ntest_bind (sb, SOCKET_ADDRESS);\n\nnn_thread_init (&thread, routine2, NULL);\nnn_atomic_init(&active, 1);\n\nwhile (active.n) {\n    (void) nn_send (sb, \"hello\", 5, NN_DONTWAIT);\n}\n\nnn_thread_term (&thread);\nnn_atomic_term(&active);\n\ntest_close (sb);\n\nreturn 0;\n\n}\n```\nAlthough sometimes it takes many tries to fail.\n. The assert is because a NN_PIPE_OUT event is received after the socket has started stopping.\nI think this is a bad assert that assumes only endpoint events will be received after shutdown.\nThis failure is not windows specific. I get the same failure runningn the ipc_shutdown on ubuntu.\nA pipe out or in event during shutdown is not a reason for concern, I think. We won't read or write to the pipe anyway, so we can and should ignore them.\n. I have updated my branch with a proposed fix.\nWhat I meant by ignoring was to not continue with execution but return from the handler. There is no work to do for a pipe event when in the stopping state.\nThe subsequent code should only be executed for an event originating from the endpoint when in the stopping state.\nI added an assert and a comment to make what I believe to be the correct intention of the code more clear.\nLet me know what you think.\n. Ok. I changed fail_msg to uint8_t[] and tested compilation and tests on ubuntu.\n. ",
    "woodstock23": "Yes, thanks, I already tried up to 4MB NN_*BUF and up to 6 seconds NN_LINGER, but it is difficult to tell anything due to the intermittent crashes. My current workaround is stable enough, so I will wait with further tests for a version which survives the tcp_stress.\n. I tried a bit, but was not able to reproduce this assertion failure today. Maybe it depends on the release build.\n. ",
    "rolandyoung": "I can reliably trigger an abort in nn_shutdown by running two instances of a server program, where one instance binds to a port and waits and the other instance tries to bind to the same port and then disconnects.\n``` c\ninclude \ninclude \ninclude \"nn.h\"\ninclude \"pubsub.h\"\nint portclash(const char *url, int delay)\n{\n    int sock = nn_socket(AF_SP, NN_PUB);\n    if (sock < 0)\n    {\n        fprintf (stderr, \"Failed to create nanomsg socket. Errno: %d\\n\", errno);\n        return 1;\n    }\n    int eid = nn_bind(sock, url);\n    if (eid < 0)\n    {\n        fprintf (stderr, \"Failed to bind nanomsg socket to %s. Errno: %d\\n\", url, errno);\n        return 1;\n    }\n    printf (\"Bound to %s, eid = %d\\n\", url, eid);\nusleep(delay * 1000);\n\nif (sock >= 0 && eid >= 0 && nn_shutdown(sock, eid) < 0)\n{\n    fprintf (stderr, \"Failed to shut down nanomsg socket. Errno: %d\\n\", errno);\n    return 1;\n}   \nprintf (\"Finished OK\\n\");\nreturn 0;\n\n}\nint main(const int argc, const char **argv)\n{\n  if (argc == 2)\n    return portclash(argv[1], 5000);\n  else if (argc > 2)\n    return portclash(argv[1], atoi(argv[2]));\n  else\n  {\n    fprintf (stderr, \"Usage: portclash url [delay_millis]\\n\");\n    return 1;\n  }\n}\n```\nThe program is run like this portclash  tcp://*:7070 250\nIf I start one copy of this program with the default delay of 5 sec and then start another on the same url with a delay of 250ms (say), both will report \"Bound to tcp://*:7070, eid = 1\", but the second will crash with the following traceback:\n```\nProgram terminated with signal 6, Aborted.\n0  0x000000353f230265 in raise () from /lib64/libc.so.6\n(gdb) where\n0  0x000000353f230265 in raise () from /lib64/libc.so.6\n1  0x000000353f231d10 in abort () from /lib64/libc.so.6\n2  0x00000000004073a9 in nn_err_abort () at src/utils/err.c:33\n3  0x0000000000405f54 in nn_timer_term (self=0x1b942ba8) at src/aio/timer.c:62\n4  0x0000000000413b91 in nn_btcp_destroy (self=) at src/transports/tcp/btcp.c:205\n5  0x000000000040dde6 in nn_ep_term (self=0x1b9427a0) at src/core/ep.c:88\n6  0x0000000000405775 in nn_sock_handler (self=, src=, type=,\nsrcptr=<value optimized out>) at src/core/sock.c:927\n\n7  0x0000000000405976 in nn_ctx_leave (self=0x1b9425b8) at src/aio/ctx.c:63\n8  0x00000000004046e7 in nn_sock_rm_ep (self=0x1b942540, eid=1) at src/core/sock.c:533\n9  0x00000000004025e6 in nn_shutdown (s=, how=) at src/core/global.c:685\n10 0x0000000000401c8b in portclash (url=0x7fff1d0b6845 \"tcp://*:7070\", delay=250) at portclash.c:24\n11 0x0000000000401d33 in main (argc=3, argv=0x7fff1d0b5038) at portclash.c:38\n```\nMy impression is that the retry timer associated with a btcp object is used for two purposes, only one of which is consistent with the assumption in nn_btcp_destroy that if the btcp state is IDLE then it is safe to call nn_backoff_term\n. Thanks @baxtersa for pointing out #410. As far as I can see, the second and third commits in that PR address the issue I encountered. I will try to confirm this and submit a minimal PR shortly.\nThis will not address any remaining problems with TCP support on Windows, but I agree that, as far as possible, a bug fix PR should address a single bug.\n. See pull request #468\n. ",
    "europelee": "Hi, I found the problem only happen when tested on virtual machine,\nbut when i add nn_sleep before test_close, then the problem was solved, as below:\n    sb = test_socket (AF_SP, NN_PUB);\n    test_bind (sb, SOCKET_ADDRESS);\nfor (j = 0; j != TEST_LOOPS; ++j) {\n    for (i = 0; i != THREAD_COUNT; ++i)\n        nn_thread_init (&threads [i], routine, NULL);\n    for (i = 0; i != THREAD_COUNT; ++i)\n        nn_thread_term (&threads [i]);\n}\nnn_sleep(200); // it solved the problem.\ntest_close (sb);\nbut it is still needed a root cause analysis. \n. ",
    "evadot": "I'm closing this PR.\nAs you said peeking in the payload is easy.\nIt was a rookie mistake for me to wanted to add this functionnality :)\n. ",
    "Yoshi325": "\ncmake-3.4.0-rc3-win32-x86\nnanomsg-0.7-beta\nMicrosoft Visual Studio Community 2015 Version 14.0.23107.0\n\nUpdating cmake resolved \"The C compiler identification is unknown\" error, but did not resolve the LNK1000 error.\nAny input on how I can resolve them?\n. Unfortunately all the solutions I can find along those lines are for older versions of the OS, Linker, or Visual Studio.\nFor example, https://support.microsoft.com/en-us/kb/826326 has this:\n```\nArticle ID: 826326 - Last Review: 10/25/2005 18:30:00 - Revision: 1.3\nApplies to\nMicrosoft Visual C++ .NET 2002 Standard Edition\n```\nAnd http://stackoverflow.com/questions/2001289/how-to-resolve-fatal-error-lnk1000-internal-error-during-incrbuildimage has this:\nI am trying to recompile solution file for memcached project on Windows 7 64 bit with Visual Studio 2008 and got the following error:\nAs I've gone further and further down the google rabbit hole, all I've been able to find are resolutions for old product versions.\nCan you share any further details about the AppVeyor VS14 configuration you were able to compile it on?\n. I can't seem to locate the .appveyor.yml file.\nI will try running the build again and compare it to the recent builds on AppVeyor. \nA couple of interesting notes:\nEnvironment: GENERATOR=Visual Studio 11 2012, VS_VERSION=11.0\n```\ncmake --version\ncmake version 3.3.2\nCMake suite maintained and supported by Kitware (kitware.com/cmake).\ncmake ..\n-- Building for: Visual Studio 14 2015\n-- The C compiler identification is MSVC 19.0.23026.0\n-- Check for working C compiler using: Visual Studio 14 2015\n```\nIt seems that AppVeyor and CMake don't line up, but it still builds fine.\nAlso, AppVeyor addes this step (which isn't noted in the README):\ncall \"C:/Program Files (x86)/Microsoft Visual Studio %VS_VERSION%/Common7/Tools/vsvars32.bat\"\n. ",
    "panjw": "thans ,the problem have be fix \n. thanks ,i test it by 0.7 first\n. ",
    "fovecifer": "I have the same issue, the device will plus 4 bytes data in the header of response.\nIn my demo code, the client should receive \"Hello World!\" which size is 12 but it receive \"\ufffd\ufffd\ufffd\ufffdHello World!\" which size is 16. \n. @keshav105  no.\nActually I think this is made by my code before you open this issue.\nbut now, you have this issue too, so I think this maybe a bug of nanomsg.\n. ",
    "keshav105": "Hello,\nDid you find out the reason behibd it??\n. yeah this problem is there with nn_device() also..  here nn_device2() i am using to just stop the device using an extra parameter. so there is no issue in nn_device2() call..\nNOTE: This code is working fine when trying with INPROC connection in place of TCP between proxy and server.\n. Thank you \n. What you have suggested  have tried already but it didnt work.\nPlease find the code below what i have used.\nclass NNHTest : public ::testing::Test\n{\npublic:\n    nn_helper_t proxy_st ;\n};\nstruct info_my_param_t\n{\n    int       sock1;\n    int   sock2;\n};\nstatic void * loop_device_test( void* args )\n{\n    int rc;\n    struct info_my_param_t * imp = (struct info_my_param_t *) args ;\n    rc = nn_device ( imp->sock1, imp->sock2 );\n      printf(\"value of nn_device rc = %d\\n\", rc);\nreturn NULL;\n}\nTEST_F(NNHTest, StopDeviceTest )\n{\n    int rc ,nnbd, con;\n//device\n```\nint sock1 = nn_socket ( AF_SP_RAW , NN_REP );\nprintf(\"value of sock1 = %d\\n\", sock1);\nnnbd = nn_bind ( sock1 , \"tcp://127.0.0.1:6699\" );\nprintf(\"value of nnbd = %d\\n\", nnbd);\nint sock2 = nn_socket ( AF_SP_RAW , NN_REQ );\nprintf(\"value of sock2 = %d\\n\", sock2);\ncon = nn_connect ( sock2 , \"tcp://127.0.0.1:6799\" );\nprintf(\"value of con = %d\\n\", con);\n```\n//device loop start\n```\nstruct info_my_param_t imp ;\nimp.sock1 = sock1 ;\nimp.sock2 = sock2 ;\nstruct info_my_param_t ptr = (struct info_my_param_t )memdup( (char*)&imp, sizeof(struct info_my_param_t) )  ;\nrc = pthread_create( &proxy_st.threadid, NULL, loop_device_test, ptr  );\nprintf(\"value of pthread_create rc = %d\\n\", rc);\nsleep(1);\n```\n//closing sock1\n    rc = nn_close(imp.sock1);\n    printf(\"value of nn_close(imp.sock1) rc = %d\\n\", rc);\n//closing sock2\n    rc = nn_close(imp.sock2);\n    printf(\"value of nn_close(imp.sock2) rc = %d\\n\", rc);\n//joining main thread\n    pthread_join( proxy_st.threadid, NULL);\n}\nOUTPUT:\nkeshav@keshav-Latitude-E6540:~/clone/BD/Test/Shared/Core$ ./ubuntuRelease64/test-static \n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from NNHTest\n[ RUN      ] NNHTest.DeviceTestReqResp\nvalue of sock1 = 0\nvalue of nnbd = 1\nvalue of sock2 = 1\nvalue of con = 1\nvalue of pthread_create rc = 0\nvalue of nn_close(imp.sock1) rc = 0\nvalue of nn_close(imp.sock2) rc = 0\nNote : its hanging here\n. But its not working in the case of TCP also. As already mentioned its hanging.\n. Hiii .. I am using the version 0.8 only... As you told i will try it and let you know.. thanks .\n. So you mean to say, you are able to reproduce this issue in Linux ??\n. Okay.. the test case what i have wrote it was hanging all times i tried. i will try it once more and update you.\n. okay. as mentioned this issue is not with TCP connection, please take a look. \n. Hii, As you (  wirebirdlabs  ) asked . i tried to reproduce the issue with latest code.\nPlease find below.\nkeshav@keshav-Latitude-E6540:~/clone/BD/Test/Shared/Core$ valgrind --leak-check=full ./ubuntuDebug64/test-static --gtest_filter=NNHTest.WorkerReqResp -dverbose\n==17484== Memcheck, a memory error detector\n==17484== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\n==17484== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info\n==17484== Command: ./ubuntuDebug64/test-static --gtest_filter=NNHTest.WorkerReqResp -dverbose\n==17484== \nNote: Google Test filter = NNHTest.WorkerReqResp\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from NNHTest\n[ RUN      ] NNHTest.WorkerReqResp\nvalue of sock0 = 0\nvalue of nnbd1 = 1\nvalue of sock1 = 1\nvalue of nnbd2 = 1\nvalue of sock2 = 2\nvalue of con = 1\n[       OK ] NNHTest.WorkerReqResp (141 ms)\n[----------] 1 test from NNHTest (158 ms total)\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test case ran. (205 ms total)\n[  PASSED  ] 1 test.\n==17484== \n==17484== HEAP SUMMARY:\n==17484==     in use at exit: 12,104 bytes in 1 blocks\n==17484==   total heap usage: 1,539 allocs, 1,538 frees, 200,287 bytes allocated\n==17484== \n==17484== 12,104 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==17484==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==17484==    by 0x50A791: nn_msgqueue_init (msgqueue.c:39)\n==17484==    by 0x4FA6A4: nn_sinproc_init (sinproc.c:80)\n==17484==    by 0x4F9AF0: nn_cinproc_create (cinproc.c:71)\n==17484==    by 0x4F6BE4: nn_ep_init (ep.c:72)\n==17484==    by 0x4ED572: nn_sock_add_ep (sock.c:523)\n==17484==    by 0x4EAE35: nn_connect (global.c:707)\n==17484==    by 0x43EB66: NNHTest_WorkerReqResp_Test::TestBody() (nn_helper.cpp:1830)\n==17484==    by 0x4B1E35: void testing::internal::HandleSehExceptionsInMethodIfSupported(testing::Test_, void (testing::Test::)(), char const) (in /home/keshav/clone/BD/Test/Shared/Core/ubuntuDebug64/test-static)\n==17484==    by 0x4AD0C1: void testing::internal::HandleExceptionsInMethodIfSupported(testing::Test_, void (testing::Test::)(), char const) (in /home/keshav/clone/BD/Test/Shared/Core/ubuntuDebug64/test-static)\n==17484==    by 0x494DA4: testing::Test::Run() (in /home/keshav/clone/BD/Test/Shared/Core/ubuntuDebug64/test-static)\n==17484==    by 0x49557F: testing::TestInfo::Run() (in /home/keshav/clone/BD/Test/Shared/Core/ubuntuDebug64/test-static)\n==17484== \n==17484== LEAK SUMMARY:\n==17484==    definitely lost: 12,104 bytes in 1 blocks\n==17484==    indirectly lost: 0 bytes in 0 blocks\n==17484==      possibly lost: 0 bytes in 0 blocks\n==17484==    still reachable: 0 bytes in 0 blocks\n==17484==         suppressed: 0 bytes in 0 blocks\n==17484== \n==17484== For counts of detected and suppressed errors, rerun with: -v\n==17484== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\nkeshav@keshav-Latitude-E6540:~/clone/BD/Test/Shared/Core$\n. Thank you. i tried and its working.\n. Hello Garrett D'Amore,\nwe are using nn_poll API in our project so could you please guide how to use NN_SNDFD and NN_RCVFD socket options in place of nn_poll ??\n. Thank you. please let us know when you introduce the new wrapper for nn_poll , we are dependent on it.\n. ",
    "anatol": "And here is infor for the stuck ipc_stress test\n``\n[anatol@arch extra-x86_64]$ ps ax | grep ipc_stress\n 1197 pts/2    S+     0:00 /bin/sh -c p='tests/ipc_stress'; \\ b='tests/ipc_stress'; \\ case $- in *e*) set +e;; esac; srcdirstrip=echo \".\" | sed 's|.|.|g'; case $p in ./*) f=echo \"$p\" | sed \"s|^$srcdirstrip/||\";; *) f=$p;; esac; { mgn= red= grn= lgn= blu= brg= std=; am__color_tests=no; if test \"X\" = Xno; then am__color_tests=no; elif test \"X\" = Xalways; then am__color_tests=yes; elif test \"X$TERM\" != Xdumb && { test -t 1; } 2>/dev/null; then am__color_tests=yes; fi; if test $am__color_tests = yes; then red='?[0;31m'; grn='?[0;32m'; lgn='?[1;32m'; blu='?[1;34m'; mgn='?[0;35m'; brg='?[1m'; std='?[m'; fi; }; srcdir=.; export srcdir; case \"tests/ipc_stress.log\" in */*) am__odir=echo \"./tests/ipc_stress.log\" | sed 's|/[^/]*$||';; *) am__odir=.;; esac; test \"x$am__odir\" = x\".\" || test -d \"$am__odir\" || /usr/bin/mkdir -p \"$am__odir\" || exit $?; if test -f \"./$f\"; then dir=./; elif test -f \"$f\"; then dir=; else dir=\"./\"; fi; tst=$dir$f; log='tests/ipc_stress.log'; if test -n ''; then am__enable_hard_errors=no; else am__enable_hard_errors=yes; fi; case \"  \" in *[\\ \\?]$f[\\ \\?]* | *[\\ \\?]$dir$f[\\ \\?]*) am__expect_failure=yes;; *) am__expect_failure=no;; esac;   /bin/sh ./test-driver --test-name \"$f\" \\ --log-file $b.log --trs-file $b.trs \\ --color-tests \"$am__color_tests\" --enable-hard-errors \"$am__enable_hard_errors\" --expect-failure \"$am__expect_failure\"   --    \\ \"$tst\" \n 1204 pts/2    S+     0:00 /bin/sh ./test-driver --test-name tests/ipc_stress --log-file tests/ipc_stress.log --trs-file tests/ipc_stress.trs --color-tests no --enable-hard-errors yes --expect-failure no -- ./tests/ipc_stress\n 1205 pts/2    Sl+    0:00 /build/nanomsg/src/nanomsg-0.8-beta/tests/.libs/lt-ipc_stress\n 1321 pts/1    R+     0:00 grep ipc_stress\n64193 pts/2    S+     0:00 /bin/sh -c set +e; bases='tests/inproc.log tests/inproc_shutdown.log tests/ipc.log tests/ipc_shutdown.log tests/ipc_stress.log tests/tcp.log tests/tcp_shutdown.log tests/ws.log tests/tcpmux.log tests/pair.log tests/pubsub.log tests/reqrep.log tests/pipeline.log tests/survey.log tests/bus.log tests/async_shutdown.log tests/block.log tests/term.log tests/timeo.log tests/iovec.log tests/msg.log tests/prio.log tests/poll.log tests/device.log tests/device4.log tests/device5.log tests/emfile.log tests/domain.log tests/trie.log tests/list.log tests/hash.log tests/symbol.log tests/separation.log tests/zerocopy.log tests/shutdown.log tests/cmsg.log tests/bug328.log'; bases=for i in $bases; do echo $i; done | sed 's/.log$//'; bases=echo $bases; \\ log_list=for i in $bases; do echo $i.log; done; \\ trs_list=for i in $bases; do echo $i.trs; done; \\ log_list=echo $log_list; trs_list=echo $trs_list`; \\ make  test-suite.log TEST_LOGS=\"$log_list\"; \\ exit $?;\n64202 pts/2    S+     0:00 make test-suite.log TEST_LOGS=tests/inproc.log tests/inproc_shutdown.log tests/ipc.log tests/ipc_shutdown.log tests/ipc_stress.log tests/tcp.log tests/tcp_shutdown.log tests/ws.log tests/tcpmux.log tests/pair.log tests/pubsub.log tests/reqrep.log tests/pipeline.log tests/survey.log tests/bus.log tests/async_shutdown.log tests/block.log tests/term.log tests/timeo.log tests/iovec.log tests/msg.log tests/prio.log tests/poll.log tests/device.log tests/device4.log tests/device5.log tests/emfile.log tests/domain.log tests/trie.log tests/list.log tests/hash.log tests/symbol.log tests/separation.log tests/zerocopy.log tests/shutdown.log tests/cmsg.log tests/bug328.log\n[anatol@arch extra-x86_64]$ sudo strace -f -p 1205\nProcess 1205 attached with 3 threads\n[pid  1205] futex(0x7efe960c29d0, FUTEX_WAIT, 10318, NULL \n[pid  1229] epoll_wait(4,  \n[pid  1224] restart_syscall(<... resuming interrupted call ...>^CProcess 1205 detached\nProcess 1224 detached\n \nProcess 1229 detached\n[anatol@arch extra-x86_64]$ sudo gdb -p 1205\nGNU gdb (GDB) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.html\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-unknown-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\nhttp://www.gnu.org/software/gdb/bugs/.\nFind the GDB manual and other documentation resources online at:\nhttp://www.gnu.org/software/gdb/documentation/.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\nAttaching to process 1205\nReading symbols from target:/build/nanomsg/src/nanomsg-0.8-beta/tests/.libs/lt-ipc_stress...(no debugging symbols found)...done.\nReading symbols from target:/build/nanomsg/src/nanomsg-0.8-beta/.libs/libnanomsg.so.4...(no debugging symbols found)...done.\nReading symbols from target:/usr/lib/libpthread.so.0...(no debugging symbols found)...done.\n[New LWP 1229]\n[New LWP 1224]\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/usr/lib/libthread_db.so.1\".\nReading symbols from target:/usr/lib/libc.so.6...(no debugging symbols found)...done.\nReading symbols from target:/usr/lib/libanl.so.1...(no debugging symbols found)...done.\nReading symbols from target:/usr/lib/librt.so.1...(no debugging symbols found)...done.\nReading symbols from target:/lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.\nwarning: Target and debugger are in different PID namespaces; thread lists and other data are likely unreliable\n0x00007efe9687b70d in pthread_join () from target:/usr/lib/libpthread.so.0\n(gdb) info threads\n  Id   Target Id         Frame \n  3    Thread 0x7efe960c2700 (LWP 1224) \"lt-ipc_stress\" 0x00007efe965af18d in poll () from target:/usr/lib/libc.so.6\n  2    Thread 0x7efe8f7fe700 (LWP 1229) \"lt-ipc_stress\" 0x00007efe965b8733 in epoll_wait () from target:/usr/lib/libc.so.6\n* 1    Thread 0x7efe96ef0700 (LWP 1205) \"lt-ipc_stress\" 0x00007efe9687b70d in pthread_join () from target:/usr/lib/libpthread.so.0\n(gdb) thread apply all bt\nThread 3 (Thread 0x7efe960c2700 (LWP 1224)):\n0  0x00007efe965af18d in poll () from target:/usr/lib/libc.so.6\n1  0x00007efe96aaa15d in nn_efd_wait () from target:/build/nanomsg/src/nanomsg-0.8-beta/.libs/libnanomsg.so.4\n2  0x00007efe96aa538e in nn_sock_recv () from target:/build/nanomsg/src/nanomsg-0.8-beta/.libs/libnanomsg.so.4\n3  0x00007efe96aa272a in nn_recvmsg () from target:/build/nanomsg/src/nanomsg-0.8-beta/.libs/libnanomsg.so.4\n4  0x00007efe96aa2a98 in nn_recv () from target:/build/nanomsg/src/nanomsg-0.8-beta/.libs/libnanomsg.so.4\n5  0x00000000004010e6 in server ()\n6  0x000000000040103d in nn_thread_main_routine ()\n7  0x00007efe9687a4a4 in start_thread () from target:/usr/lib/libpthread.so.0\n8  0x00007efe965b813d in clone () from target:/usr/lib/libc.so.6\nThread 2 (Thread 0x7efe8f7fe700 (LWP 1229)):\n0  0x00007efe965b8733 in epoll_wait () from target:/usr/lib/libc.so.6\n1  0x00007efe96aa6514 in nn_poller_wait () from target:/build/nanomsg/src/nanomsg-0.8-beta/.libs/libnanomsg.so.4\n2  0x00007efe96aa8f24 in nn_worker_routine () from target:/build/nanomsg/src/nanomsg-0.8-beta/.libs/libnanomsg.so.4\n3  0x000000000040103d in nn_thread_main_routine ()\n4  0x00007efe9687a4a4 in start_thread () from target:/usr/lib/libpthread.so.0\n5  0x00007efe965b813d in clone () from target:/usr/lib/libc.so.6\nThread 1 (Thread 0x7efe96ef0700 (LWP 1205)):\n0  0x00007efe9687b70d in pthread_join () from target:/usr/lib/libpthread.so.0\n1  0x00000000004015df in nn_thread_term ()\n2  0x0000000000400ed2 in main ()\n```\n. Tests are still failing at HEAD\nPASS: tests/trie\n./test-driver: line 107: 34450 Aborted                 (core dumped) \"$@\" > $log_file 2>&1\nFAIL: tests/ws\nPASS: tests/pubsub\nPASS: tests/device4\n./test-driver: line 107: 34522 Aborted                 (core dumped) \"$@\" > $log_file 2>&1\nFAIL: tests/tcpmux\n[anatol@arch tests]$ cat ws.log \nAddress already in use [98] (src/transports/ws/bws.c:379)\nFAIL tests/ws (exit status: 134)\n[anatol@arch tests]$ cat tcpmux.log \nAssertion failed: ssz == 1 (src/devices/tcpmuxd.c:198)\nFAIL tests/tcpmux (exit status: 134)\nI think tests should not hardcode the port. This port can be used by some process already. It would be better to use bind with port==0 that would give a free port http://stackoverflow.com/questions/5895751/a-bind-with-a-port-of-zero-will-bind-you-to-a-free-port-is-this-portable\n. > The tests CANNOT be run in parallel; that is, you cannot run a bunch of tests together at the same time.\nThanks for the clarification. In this case it worth putting it to the build system. Make has .NOTPARALLEL option that might be useful here.\n. ",
    "kostyay": "Thanks, I will look at it.\nAnd yeah, we switched to TCP for now.\n. @gdamore here, take a look https://github.com/nanomsg/nanomsg/pull/557\n. @gdamore \nI made the fixes as you asked.\nPlease have a look.\nAs for the test I tried to improve it abit.\nI will check tomorrow how its possible to query a pipe for its security attributes and improve the test.\n. How do I merge all the commits into a single one?\n. @gdamore \nIt took me a while to figure this out but I wrote a good tests that verifies the pipe was created with the proper security descriptor.\nI also squashed the commits so everything should be ready to go now.\n. Any chance for a merge? Its been 8 days now since I fixed everything and no review :(\n. Thanks :)\n. Is it ok if they will be still defined in sock.h and the processing will be done in sock.c?\nI'm not familiar with the project structure that much.\n. ",
    "pavel-pimenov": "VC++ 2013 + PVS Studio (static code analyzer)\nhttp://www.viva64.com/en/d/0137/\nSOCKET csd;\ncsd = accept(nsd, (struct sockaddr *) &sa_client, &clen);\nif (csd < 0)\n  ....\nThe accept function in Visual Studio header files returns a value that has the unsigned SOCKET type. That's why the check 'csd < 0' is invalid since its result is always false. The returned values must be explicitly compared to different constants, for instance, SOCKET_ERROR:\nif (csd == SOCKET_ERROR)\n. ",
    "pakozm": "I have done a similar implementation some months ago (for plain Lua without LuaJIT) https://github.com/pakozm/xemsg\nI have changed the name to avoid confusion with other nanomsg Lua implementations.\n. ",
    "memeplex": "Fine, but the point was decoupling routing and sending, not providing history or playback at all! I've detailed my point if view in the mailing list together with a relatively simple change (not too different of what zmq already has implemented). I would have liked to discuss it a bit more. Martin recognized a valid use case but I'm not sure if this issue would be the right one.\n. Btw reqrep is missing the topic routing part, so I'm forced to implement it on top of reqrep or pushpull, so it's not that ideal, that was more or less the entire point, but I don't want too repeat myself here, I've already written too much in the list :)\n. There was a large exchange in the mailing list, I've written a couple of long posts there. The main point was to provide a gauge on confidence and risk aversion of the sender regarding reliability of the receivers by means of a timeout, as a general mechanism defaulting to fully unrealiable in the cases of pub and rep, and to fully reliable in other kind of sockets. I will be glad if you read the posts.\n. I think that's because you're putting the question in terms of absolute reliability including an ack while I'm just talking about dropping vs blocking behavior which in practice may be enough for more controlled use cases. Here are some relevant posts;\nhttp://www.freelists.org/post/nanomsg/Generalizing-pubsub-distribution,3\nhttp://www.freelists.org/post/nanomsg/Generalizing-pubsub-distribution,6\nhttp://www.freelists.org/post/nanomsg/Generalizing-pubsub-distribution,9\nhttp://www.freelists.org/post/nanomsg/Generalizing-pubsub-distribution,16\nhttp://www.freelists.org/post/nanomsg/Generalizing-pubsub-distribution,18\n. All in all it can be summarized to the fact that I think that blocking broadcasting/pub may have similar role than blocking push, and that the 1 vs n dimension is pretty orthogonal to the blocking vs dropping dimension, although I do recognize both the difficulty introduced by partial publication and the different emphasis of the standard use cases for push and for pub. Mainly I find uncomfortable the inability to reuse the great topic routing implementation you have in my own use case.\n. @nivan22 there is long and detailed description of my use case in the links above, and a short description of another one by Isaac also.\n. @gdamore thank you very much for your answer, I really meant it. It's difficult for me to figure out what people will begin to believe since I've no experience as a library writter in this field. All I could say is that I expect push to block while I'm not expecting it to be fully reliable, thus this doesn't confuse me and I understand that going reliable will imply changing pushpull for reqrep; this level of understanding zmq and nanomsg are already demanding from their users. If I'm pushing too fast I know for sure I will be losing messages and some kind of backpressure is in order, so I rely on the infinite timeout default or set some positive timeout; this level of flexibility zmq and nanomsg are already providing to their users. Maybe this could be extended to pub, but as far as the scenario of choice for pub is characterized as \"lots of potentially unreliable subs\", and not just \"n subs\", it's clear to me the danger of blocking and that this concern will dominate. Now consider this set of requirements:\n1. I want to route using topics.\n2. I want to eventually block because my producer is too fast.\n3. I know my consumers are just right, I'm not paranoid about them, I've developed them and can fix them in any case.\nSurely I can implement that on top of normal pipelines and some kind of simple routing protocol (which will imply some type of announcement, heartbeating, etc.). As I see it I still want a part of the pub semantic, and this part is as round or squared as round or squared is my hole number 1 above. Now I do understand your concerns as a library designer and maintainer, and I do understand that the SP idea is not to address vacuous generalizations but concrete albeit general use cases.\nWould your suggestion of NN_WEAKEST_LINK be for any interested SP to comply or just for pub? For example, what about rep?\nDon't hold your breath for a PR (I don't expect you will in this case, anyway :) ), but eventually I will realize I'm wrong or tackle this.\n. Isn't rep always dropping?\n. Good point.\n. ",
    "ruipacheco": "While I can't contribute to the code I'd like to express my support for this change.\n. ",
    "shiva": "I'd be glad to help out here. Is there a branch or repo that I can contribute to?\n. @Snaipe Thanks. Will do\n. @gdamore @JackDunaway Cool. I will drop my effort around this. This is going to make it much easier to convince folks within my company to use nanomsg in the future. Will to help get the PR done if I can help.\n. @JackDunaway I was playing with ftw-kernel on featherweight-nanomsg, (https://github.com/JackDunaway/featherweight-nanomsg/commit/4bf526d863fac563a71522845a94e526ae8d9cce) and attempting to build using cmake. \nIs this the one we are trying to make the PR from? It has a couple of issues. (small issues with cmake_check_include, and undefined vars NN_PACKAGE_VERSION)\nHow do we want to get going on this? I can fork off your branch, and provide commits if that works.\n. @JackDunaway sweet! will do so.\n. @JackDunaway  Found and fixed a few minor issues. See https://github.com/JackDunaway/featherweight-nanomsg/pull/1\n. @gdamore Would you need cmake support for this? eventually?\n. @JackDunaway Absolutely! \n. don't fret too much about attribution. Do what you need to get it in.\nI'll fork again and continue to work on it. \nWill get back on the other issue in a couple of days.\n. +1 to trying to go 2.8.7. \nAlthough most folks in open-source, and those using cmake for personal use tend to be on latest greatest, most production environments (cough large co cough) tend to use older more stable cmake versions due to stability issue with cmake itself. Further, it is harder to justify upgrading build tools, just to adopt one library. Much appreciate the efforts here to go to 2.8.7!\n. > 1. @shiva -- note this familiar failure: https://travis-ci.org/nanomsg/nanomsg/jobs/123621308#L264 and the \"fix\" the suppressed this issue: e9dc4e9 -- any ideas on a more sustainable fix?\n@JackDunaway This commit (https://github.com/shiva/cmakeify-nanomsg/commit/8159d2166d0b8a5849ba7c04d1b2e14486952ebb), calculates the version, and guarantees a value for  NN_PACKAGE_VERSION. At least, that was the intention.\nIf this is not working as expected, I can troubleshoot more. Let me know.\n(Note: I just noticed that I hadn't used my github identity for my commits and hence had to re-write history. You can safely ignore my commits now that you have squashed all of them into your PR branch.)\n. I use uncrustify to automate and fix formatting. \nhttp://uncrustify.sourceforge.net/\nWhatever formatting you choose, there is going to be someone who doesn't like one thing or another. I'd recommend, automating it and making it part of the commit process. \nFor example: https://github.com/shiva/fun/blob/d025d7a0455b493b310a8c023cabd3d8192b8e1b/git-commit-hooks/pre-commit-uncrustify\nThis way, the delta in the commit history doesn't have whitespace changes mixed with actual functional changes.\n. ",
    "Snaipe": "@shiva I'd say check out wirebirdlabs' work on his CMake configuration for a start. I based my own cmake work on it, it's a good start.\n. > I think nn_term in the child is probably the best approach.\nIs the behaviour of nn_term well defined when the underlying threads are already dead (or rather 'not existing') ? It might be better to simply clean up the resources rather than trying to notify and join the dead threads.\n\nThe other thing is that fork() can occur at any time, so we'd have to be sure that we can acquire the locks -- all of them. I'm concerned of a potential for deadlock here. Probably not a problem, since we don't fork from inside the library...\n\nThis shouldn't be a problem indeed. The atfork handler is run on the thread calling fork(), and all the mutex locks/unlocks are done on threads owned by nanomsg.\nThe only issue I see would be to have a thread doing some blocking I/O while owning a lock. -- this would make fork() an excruciatingly slow operation -- however, I am not familiar enough with the internals to know that, and a quick look through src/aio/worker_posix.inc seems to indicate that it wouldn't happen.\n. I just realized that the pull request for this issue has been opened afterwards: #590.\n. I'm having troubles fighting the library where all (or almost all) termination functions expect the state to be valid.\nThis makes it hard to force nanomsg to simply \"give up\" when there is nothing that could be done to restore the state to a valid one.\nThis seems unlikely to be done right now, but maybe the validity checks should be decoupled from the actual destructors -- this way, upon normal termination the library code would call those validity checks, while leaving an internal way to give up and destroy everything without aborting the user process.\nHowever, this could lead to a lot of code duplication, which would hurt the general hygiene of the source code.\n. Another issue I noticed comes from the behaviour of the file descriptors returned by kqueue(2): those are not inheritable in children, meaning that close(2)'ing them is an error.\nIn a nutshell, this makes all forks immediately die because during the force-cleanup process, a file descriptor returned by kqueue gets closed, close returns -1, and nanomsg aborts because errno is EBADF.\nI am hesitating if I should yet again duplicate the cleanup code and make a closefd_unsafe function, even as a short-term solution.\n. To address the problem mentioned in my two above comments, I added a cleanup parameter to convey the intent of the destruction function. This has led to a lot of changes on the codebase, and while current behaviour is maintained with no fork strategies, there could be a few failure points that may hit users of the reset fork strategy on some protocols/transports.\nI am going to add a more complete test for fork, over multiple transports and protocols.\nThe second thing that should raise the confidence that everything works as expected would be to add OS X builds to the travis configuration (this should speed up the development process as well for future PRs).\n. Seeing that there were almost 1400 changed lines over almost all sources, I decided to try another approach for this fix: Instead of immediately clean up with forceful/unsafe variants of *_term functions, I restore the library to a valid state by resurrecting the worker and the poller and locking the library in a more stable state before forking, before simply calling nn_sock_stop and nn_sock_term on all sockets.\nThis approach is much less intrusive on the existing codebase and has the distinct advantage of using the \"normal\" cleanup provided by the library rather than trying to hack through all destructors because all of them expect a valid state.\nThis works quite well on my end, tested with a heavy workload on a ipc+reqrep setup over Linux and OS X. I expect it to work everywhere since this approach is much more general than the old one, but I'll throw in some more tests to make sure.\n. @gdamore I'd say it roughly has the same effect. The new approach simply restores nanomsg to an idling state before terminating the library, while the old approach tried to terminate it while it was in an invalid state.\n. Ah, thanks for clarifying, I was a bit confused here. :)\n. > First off, I don't think we should ever support the notion of libnanomsg sockets \"crossing\" a fork boundary. That is, I think all nn_sockets should be considered to be \"illegal\" in a post-fork situation -- automatically closed, with no access to the socket permitted in the child process.\nThis is the behaviour introduced by the PR. There is just no way to sanely resume socket work in the child after a fork, so we just bail by briefly reviving any worker threads to only process termination events and calling a synchronous version of nn_term().\n\nGiven that, I think a reasonable course of action would be to simply close() any file descriptors that were open in the child, and to toss any state, ignoring mutexes altogether. Probably a single global variable can be used to assist the worker threads, that will get errnos if they were running, to notice that they are in a child and need to just bail. (This should only be a concern on systems like Solaris or illumos, where forkall() or forkallx() or legacy fork() semantics are in play, and all threads are duplicated in child. POSIX semantics only allow a single thread to be created in the child on fork.)\n\nThe gist of what the PR does is:\n1. During prefork, it tells the worker thread to go into a paused state. The worker then processes the work queue until it's empty, then waits on a condition variable. We also lock all global/socket/thread mutexes.\n2. During postfork:\n   1. In the parent, the condition variable is signaled and the worker resumes its work. All mutexes locked during prefork are unlocked.\n   2. In the child, we destroy the mutex & condition variable the (now dead) worker thread was waiting on. Then, a \"dumb\" worker thread gets spawned in place of the dead one to process any postfork event before resetting, all mutexes locked during prefork are unlocked, and the library gets terminated.\n\nThe interesting bit here is dealing with allocations. I'm not sure how to make fork not leak resources (memory) -- more consideration is needed.\n\nThus far, I'm sometimes having some issues with the way to deal with memory allocated by nn_recv -- the rest being gracefuly handled by the nn_term -- since it's very possible for a fork to happen while nn_recv blocks in another thread.\nWhat first comes to mind to fix this would be to register the newly allocated message to a list somewhere, then remove it when the function is done with it. The child would then iterate through this list and free each block.\nA cleaner solution would be to make all allocations in a memory pool, either by using something like talloc or implementing one ourselves. This would assert that no leaks would be possible during a fork, ever, since we will be able to simply destroy the pool and any nodes associated with it.\n. @JackDunaway \nFor nn_recv: https://github.com/nanomsg/nanomsg/blob/master/src/core/global.c#L953\nFor nn_send: https://github.com/nanomsg/nanomsg/blob/master/src/core/global.c#L809\nBoth allocate a chunkref that may get lost in limbo if another thread forks.\n. The PR works but is not ready for merging. There are a few points to address, mainly:\n1. Make the whole thing simpler\n2. Address potential leaks when using nn_recv or nn_send in a multithreaded context\n. This seems fair. A CMake setup would be easier to deal with on my end, so I see no issue switching to it at the moment.\n. I can wait a couple of days, no worries.\n. ~~This does not fix the intent of the original line, which was to zero-fill the security attributes.~~\n~~A proper fix would be memset (self->sec_attr, 0, sizeof (SECURITY_ATTRIBUTES)); (or with sizeof (*self->sec_attr)), and introducing a null check.~~\nEdit: actually, nevermind. It makes no sense to zero-fill self->sec_attr, as it cannot be set at this point.\nThis line should be self->sec_attr = NULL.\n. @JackDunaway When I started using cmake, I didn't prefix my options with anything and went with the ENABLE_FOO convention, but as I started working with dependencies, it turns out that not prefixing options with anything results in more of a problem than anything.\nThe fact is, even though people should be using cmake's ExternalProject_Add to build dependencies, they often end up doing add_subdirectory on the project root for many reasons (mainly because ExternalProject is a hassle to use by itself, doesn't reuse caches, and almost doubles the build time due to mid-build reconfigurations). In that situation, not adding prefixes to options may lead to conflicts (although you may argue that something like ENABLE_NANOCAT is very unlikely to be a source of conflicts).\nAgain, this is more of a preference more than anything, but not having to fix a project's cmake configuration is a big plus when the price to pay is a three character prefix.\n. I think that some messages are dropped on the way. The test should probably be written with the reqrep protocol rather than pubsub, since there are no guarantees that a message will ever arrive with this protocol.\n. Reading the contents of ipc_stress.c, I see that no count (or even variable, for that matter) is shared between threads. In fact, the code for atomics is not even used in this test (excluding the #include-ed atomic.h and atomic.c). Are we talking about the same test?\n. Nevermind all that, I think that this issue might be a duplicate of #546, which is already fixed. Did you try the tests on master?\n. > I'm not really set up to pull from github for my build environment, instead using the packaged tarballs as they become available.\nYou could always download the packaged source of the current master branch\n\nDo you have any idea when the 0.9 tarball will be released?\n\nNo idea. The new project maintainer still has not been decided since Garrett D'Amore stepped down, so you might have to wait a little while.\n. Atomic variables are only used by allocated message chunks for reference counting purposes, and there are no direct writes to the inner value, so the current code should be quite safe as it is. I agree that it lacks a proper nn_atomic_get_and_set function, but there are currently no uses for it.\n. That would defeat the whole purpose of having lock-free atomics, which is why a synchronization mutex is only used as a last-resort fallback if there are no CAS primitives on the current platform. The \"volatile\" is only here to force the value to be fetched each time when accessed, so we don't have to write a nn_atomic_get function.\n. @ID-Rocketeer There should be a button right below the thread\n. @gdamore from my tests nanomsg can be compiled with mingw-w64, which has better overall support for new windows functionalities. mingw can imho be dropped, but mingw-w64 should be supported.\n. @chrisheller I'm using my own fork where I'm explicitely deactivating tests and utilities, but on the top on my head I don't remember having issues. What version are you compiling?\nEdit: actually, nevermind: I'm using cmake with wirebirdlabs's cmake configuration, so of course I had no issue...\n. Just recalled that #585 existed. Closing off.\n. @JackDunaway if that helps, I'm using this CMakeLists.txt on my own fork to build nanomsg on Linux, OS X and Windows (MSVC + MinGW-w64), without any timeouts.\n. > Thanks! Good to hear validation it's worthwhile; I see the value also, and was excited to see @Snaipe had achieved this. Seems to be passing the smoke test so far.\nGlad to help. Quite a few number of my users are still stuck with 2.8.7, so being able to build nanomsg with it was a requirement. Nice to see it being integrated in the main repository!\n. It might be worth noting that CMake can generate a header file appropriately defining NN_EXPORT for this: https://cmake.org/cmake/help/v2.8.7/cmake.html#module:GenerateExportHeader\n. By the way, If appveyor builds are slow to start (which seems to be the case reading the build times), you should open a ticket on their support channel. I had issues with it (37 minutes builds where 7 minutes of which were actual work), and they upgraded my environment for free. Now, all of my builds start instantly and are performing quite fast.\n. As you mentioned, it's mostly a compatibility issue. I could set CMAKE_POSITION_INDEPENDENT_CODE iff cmake >= 2.8.9, and fallback to the current -fPIC check otherwise, though.\n. > Travis won\u2019t stay at 2.8.7 forever, and 12.04 LTS is was released in 2012 \u2014 thats four years ago. It has another year until EOL, but 14.04LTS is now two years old and 16.04LTS is due out tomorrow.\nFair enough. I would argue that Travis is probably the most popular CI service out there, so 2.8.7 compatibility was a huge convenience for the majority of users that build nanomsg from source, but Travis also has a switch to use their beta 14.04 LTS worker instead of the default 12.04 LTS one, so it still should be possible to use the CMAKE switch.\nIn that case, there is no need to merge this. CMAKE_POSITION_INDEPENDENT_CODE is mostly meant to be passed as an option at configure time directly -- adding another round of indirection is unecessary.\n. @fertesta No, you can't use any function from nanomsg before a call to exec() yet. You can use it normally after the call though.\n. @gdamore Builds gets processed ~~6 by 6~~ Edit: Actually, 5 by 5 (except for OS X ones), so It shouldn't matter here. I can remove RelWithDebInfo if you don't plan to release binaries with debug symbols, or Release if you don't care about release binaries without those symbols.\n. Also, if speed is a problem, I could allow failures on all OS X builds and put a fast_finish: true in the matrix, since they are the ones mostly slowing the build down.\nOf course, the main issue being that if OS X builds fail, the build still gets reported as passing (if the linux builds are passing).\n. @JackDunaway regarding your comment about aborting if any command fails, I tried inserting a set -e, but it seems to mess up with the build results (with the job marked as errored rather than failing), so it seems that in order to abort the script early, you need to either put your actual build commands in a script with set -e, or group everything as one sh -ec, or chain everything with &&.\n. @JackDunaway there's --repeat-until-fail <n> to repeat each test n times, and --schedule-random to randomize them.\n. duplicate of #663 -- closing\n. @gdamore unlinking the socket file after a listener closes is an accepted way of doing unix domain programming (some people do so before the bind() to avoid getting an \"Address already in use\", and I think this is what nanomsg is currently doing).\nNow, I'm not a fan of leaving sockets files all over the place, because I'm currently using ipc to bind to \"ipc://<name>_<pid>.sock\" to allow multiple instances of my application to run in parallel (which after a few ctest runs floods the current directory with socket files), and without ephemeral port binding using a tcp transport wouldn't be as straight forward.\n. I am in a similar situation. What I did was to setup a reverse REQ/REP (The server is REP, the workers are REQ). When a worker has information to communicate upstream, it sends a message to the server, and the server responds with some kind of ACK message (Either OK or an error status). This solves the problem of lingering regardless of the transport and has the advantage of providing basic error handling.\n. @keshav105 both options return a pollable file descriptor. Just use it as you would with a normal socket (poll, epoll, ...)\n. The go package is probably using the Autotools generator, which still references glock\n. Don't leave the default install directory with CMake -- this depends on your platform/distro defaults, and it's better to explicitely specify the install directory yourself: cmake -DCMAKE_INSTALL_PREFIX=/usr/local ...\n@gdamore perhaps -DCMAKE_INSTALL_PREFIX should be specified by default to /usr/local or /usr in the installation instructions.\n. @gdamore The symbol is available, it's just ifdef'ed out because _WIN32_WINNT is defined to something lower than 0x600 by MSYS2's cmake.\nIt can be visible on appveyor itself when calling C:\\msys2\\usr\\bin\\cmake instead of C:\\Program Files (x86)\\CMake\\cmake.exe.\n. See https://msdn.microsoft.com/en-us/library/aa383745(v=vs.100).aspx and https://msdn.microsoft.com/en-us/library/6sehtctf.aspx\nExplicitely setting a WINNT version is encouraged when targetting specific features.\n. To add more info since the situation described above is approximative, here's the log of a reproduction of the bug with 5 clients (4 process + 1 for the child sink) and 10 messages per client. I would have liked to be able to reproduce it with even less verbosity, but this seems to be the best that I can provide at the moment.\nThe above log was obtained with a slightly modified version of the example linked in the first post\nIt is also interesting to note that the return value of that nn_recv is -1, with errno set to EFSM.\n. > I have not been able to reproduce inside my Windows 8.1 VM. Which makes debug hard. Doing anything inside Windows is a substantial PITA. Any chance at repro using POSIX code?\nI've only been able to see it on Windows 10 -- on POSIX (and admitedly earlier versions of Windows) this works flawlessly. The problem might not come from REQ/REP per-se, but I haven't been able to reproduce with other protocols either.\n\nLooking at the code, I don't see a likely problem. What is interesting is your windows code is calling \"spawn\" -- I'm not familiar with the Windows process model -- do these processes share anything in common with their parent (ala fork)?\n\nIn the sample above, the created children have the same semantics as children that were spawned with fork+exec on POSIX -- although they don't share anything more than standard streams.\n\nAn experiment you could add would be to add a mutex to the hash table and see if that solves the problem.\n\nWill try that on my second round of tests.\nThe origin itself is hard to pinpoint. I suspect it might be caused by an implementation detail of the Windows-specific usock code that somehow impacted the REQ/REP code. Again, I'm not sure if this also impacts other protocols as I've only been able to spot it for REQ/REP. I'm also not sure if this impacts all transports, but so far it's reproducible with TCP and IPC.\n. After a second round of tests, I can confirm that locking the hash table did not help; I'm still having those assertions.\nI'm not sure how the locking would have helped though. The children run in their own address space, so one of them crashing shouldn't have left the hash table of the server in an inconsistent state -- unless the fact that handle_child_terminated is threaded is the problem?\n. I'm not using nn_realloc in the self-contained example, is nn_chunk_realloc or similar used internally?\n. I'm not sure. In my example, there is no crash per-se, it's just that nn_recv on the REQ side fails with EFSM when the REP socket crashes. However, the fact that, in your example, a crash happens on the REQ side because the cancellation queue misbehaves might correlate the two issues. Maybe. Again, I'm really not sure, and I can't exactly test it right now, but if it's reproducible on appveyor only it's a good start.\n. After a bit of digging with samples, I'm managing to have nn_recv fail with EINTR on those specific cases, which is a bit weird since I did not trigger this condition before, but I'm left wondering if this is a programming error on my end or a windows-specific edge case.\nIn the meantime I'm going to try retrying the operation on EINTR.\n. Okay, retrying on EINTR loops indefinitely. It seems that once one of the client crashes the others are stuck in this EINTR condition.\n. Further research shows that https://github.com/nanomsg/nanomsg/blob/ad74d1a42cc24368999e938b01d327748f700871/src/utils/efd.c#L158 is triggered when the condition happens (with rc == ENOTSOCK. Incidentally, rc can never be EINTR according to nn_err_wsa_to_posix), which makes in turn nn_sock_recv return -EINTR.\nFinally, some progress!\n. Okay, I found what caused this.\nIt turns out that this isn't a nanomsg bug, but a race condition in how the library was used within multiple threads. RegisterWaitForSingleObject would spawn a new thread for each dead child to collect its status. In the self-contained example, send_payload would be called, which would in turn call nn_send then nn_recv on a REQ socket.\nThe issue becomes apparent when two threads try to do these operations without an additional layer of synchronization. The \"bug\" I reported was only the manifestation of the following sequence of operations:\n1. [thread#1] nn_send on REQ\n2. [thread#2] nn_send on REQ, cancels first nn_send\n3. [thread#1] nn_recv on REQ, gets ack from 2nd nn_send\n4. [thread#2] nn_recv on REQ, no pending request so return with errno = EFSM\nI can't believe it took me that long to realize that requests did not queue and that it was a stupid race condition.\n. iirc array variables are nonstandard, and dash was made to strictly comply to the POSIX shell specification without any extension\n. Oh. It seems that Visual Studio is trying to link against the dynamic link version of the library -- mostly because NN_STATIC_LIB isn't defined in your user build, which in turn prepend __declspec(dllimport) to all functions.\n@gdamore, what's your stance on this? Should the user always define NN_STATIC_LIB in their user build with a static nanomsg, or should nanomsg install a config.h header that provides that definition conditionally?\n. The simplicity you speak of with the sqlite3 build system is an illusion.\nConsider why cmake was made in the first place: to provide a platform-agnostic build system whose main goal is to define a consistent lifecycle that checks, builds, and tests.\nHow do you test for features? How do you test for functions? How do you test for ABIs ? sqlite3 tells you to define the appropriate -DHAVE_XXX macro, as if it solves the underlying problem -- it doesn't, because not all features can have a fallback, and if so it just moves the problem to the user and platform maintainer. Nanomsg and almost all serious cross-platform library projects doesn't use cmake (or autotools) for show, they have to because you can't make assumptions when working with different platforms.\nOkay, to be perfectly honest, I wasn't very fair with my last paragraph -- sqlite3 do test for features with a ./configure, and probably generates a config.h that then gets bundled inside the amalgamation. However, that doesn't mean that this is still that much of a good idea ultimately, precisely because sqlite3 and nanomsg have different requirements and it just isn't fair to compare them at this level.\nsqlite3 needs to be bundled in a lot of different situations, with different features enabled within the same platform. The traditional \"one size fits all\" model doesn't make sense for them, so they provide an amalgamation so that people can build their own flavor. On the other hand, nanomsg doesn't really have significant parts to disable or enable, it just does checks for platform features.\nComing back to my initial statement, the simplicity that would be provided by a nanomsg amalgamation is an illusion, because using nanomsg in any project is just as simple:\nbash\ngcc foo.c -lnanomsg\nI don't see what's wrong with the model you speak of. Just build the library with -DNN_STATIC=ON, or install the relevant nanomsg package, and link to the produced static library. You just don't have to do anything else.\n. It's still weird that the error returns \"Address already in use\" -- API should probably set errno to EACCESS.\n. Now that I think about it, port 5900 shouldn't require sudo to bind to -- unless it's a port of a known OS X service?\nMaybe sudo allows the port to be reused, but it really shouldn't be allowed to do so. What happens if you change the base port in the cmake config to something higher (and run w/o sudo)? If that's the only issue, we can just change the base port.\n. Ideally we should be using an ephemeral port for tests, but since it's not yet supported, I propose a little fix to use port 49200 and higher, since it's in the reserved private range and will guarantee to not conflict with anything else.\n. Fixed the PR to use 12100+\n. The first thing you need to do is to define a cmake cross compilation toolchain, as follows:\n(assuming that your system is linux & that your toolchain is installed at /usr/arm-linux-gnueabihf)\n``` cmake\nSET(CMAKE_SYSTEM_NAME Linux)\nSET(CMAKE_SYSTEM_PROCESSOR arm)\nSET(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)\nSET(CMAKE_FIND_ROOT_PATH /usr/arm-linux-gnueabihf)\nSET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nSET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nSET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\n```\nSave that as a .cmake file, like arm-toolchain.cmake for instance.\nThen, you follow the normal build instructions while specifying the path to the toolchain file:\nbash\n$ mkdir build && cd $_\n$ cmake -DCMAKE_TOOLCHAIN_FILE=../arm-toolchain.cmake ..\n$ make\nThis should do it.\n. I'll try to reproduce this crash using separate processes.\n. I don't fully understand your problem, but if this is about the fact that nanomsg may lose messages rather than you asking how to multithread some code, then it's likely that you're using a protocol other than REQREP. All protocols except for REQREP does not guarantee delivery of the underlying message.\n. ABI and API version numbers never had the requirement to be equal -- it's even a mistake to have them follow each other tbh, as it makes it more difficult for everyone involved (package maintainers, distro maintainer, and users).\nFurthermore, ABI versions can't go back, switching from 5.x to 1.x would potentially break older packaging dependencies (although one might argue that because earlier ABI versions were tied to beta releases, it matters less). Don't do it.\nThe filename of the shared object should only contain the ABI version, though, not the API, so having libnanomsg.1.0.0.dylib instead of libnanomsg.5.0.0.dylib here is wrong.\n. Also, as a side note, having a compound ABI version is weird, if not unconventionnal: usually it's just an integer that increases with any ABI change, there is no notion of \"major\", \"minor\", or \"patch\". Maybe it would be better for nanomsg to simply switch to that ABI version format.\n. > As for compound ABI versioning -- the link from nn.h source code (copied here for convenience: http://www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html) makes a case for the rational of x.y.z versioning versus an ever-incrementing counter.\nFollowing this convention then makes a point that the VERSION property in cmake isn't actually the API version but the complete ABI version (i.e. NN_ABI_VERSION), and that SOVERSION should be set to NN_VERSION_CURRENT.\n. A more permanent solution would be to add /usr/local/lib to a file in /etc/ld.so.conf.d/.\n. @gdamore installing everything under /usr/local is the default behaviour when using cmake without -DCMAKE_INSTALL_PREFIX=/usr, and there are a lot of linux distros (Ubuntu being one) that do not add /usr/local/bin in the path or /usr/local/lib in the dynamic linker path.\nI would perhaps recommend using the above cmake flag in the build instructions to avoid the issue for \"non-cmake-fluent\" users.\n. I don't think this fixes anything. Rather, this conflicts with the documentation. Includes should be <nanomsg/nn.h>, not <nn.h>.\n. @kroggen you need to source vsvars64.bat when building x64 executables. I would suggest you duplicate the nmake matrix entry to do just that (or add platforms: [32, 64] and substitute %PLATFORM% when sourcing the vsvars).\nAs for deploying, perhaps take a look at my own config: first, create a tarball with the installed contents and then deploy it on github. You'll need a deploy token for the second part though, so you won't really be able to do that yourself.\n. The errors you are getting are there because you cannot assume the place where nanomsg.dll is built with cmake (it depends on the generator). Install the project to a known directory beforehand and zip that directory (which is what this line and this line were doing)\n. Building the docs in on by default (provided you have asciidoctor installed on your system), so just ./configure or mkdir build && cd build && cmake .. and run make html man.. Those are just tests, the binaries are not installed on the target system. The bug IDs refer to past github issues, in this case #328 and #777. If the problem is about polluting the build directory with seemingly unrelated binaries, I'd suggest putting the binaries produced by add_libnanomsg_test into a test subdirectory.. I don't think that the filename of github-generated tarballs can be changed. :/. Wouldn't it be better to add that to the gh-pages branch?. In the current usage, the global lock is already held -- see src/utils/fork.c:42, but I agree that it's not immediately apparent. Should I add a word of warning that the global lock needs to be held, or should I make it so this function explicitely calls nn_glock_lock() then nn_glock_unlock()?\n. I was thinking about a build time flag, but I'm not sure about how this should be handled for packaged distributions. Do we assume that everyone wants NN_FORK_RESET (or the current behaviour) as the \"best\" fork strategy?\n. One could want to set the strategy to NN_FORK_RESET, then reset it to NN_FORK_NONE in the child after fork, notably if the child itself forks then execs as the runtime cost of resetting the library could be non-negligible.\nOther than that, I agree that most if not all the usage of this function would be once and at the start.\n. I did not add it to the CMake tests for this reason, as it is really only relevant to run it on posix. Should I put some guards on the file checking against NN_HAVE_WINDOWS to short circuit the logic?\n. There really is no best strategy I'm afraid.\nThe current behaviour (aka NN_FORK_NONE) is fast and useful for children that call exec() after fork, while NN_FORK_RESET forces a reset of the library, can sometimes be fairly slow (and might even be slower one day if nanomsg implements multiple workers in the poller), and should really be a last-resort solution.\nI was thinking of introducing a 3rd strategy after the initial work was done, that would give up on all pending I/O events and tasks in the child, effectively leaving the current opened sockets in a valid, non-working state. Admitedly, this could be more versatile than the two strategies introduced by this commit, but I wouldn't qualify it \"better\" in its own sense.\n. I did this to avoid incrementing the value of NN_FORK_MAX_ if another value was to be added, but I can use macro definitions instead.\nI'm curious, though -- what is the rationale of not using enums originally? I was led to believe that integral constants should generally be represented as enums because of the type information they convey, but I certainly am not aware of everything that led to these design decisions.\n. This needs a hook inside the endpoint to release all of its resources at once without caring about safely terminating.\n. Same as the endpoints, this needs a hook inside the socket base to release everything. The destroy function simply fails because it checks that the state is valid, which cannot happen during a fork, before terminating.\n. Right. I'm going to revert 4331b77 and introduce a configure option to set the fork strategy, but what should I make the default? The current behaviour?\n. FYI, 'gcc' is aliased to clang/llvm on OS X workers, if you really want gcc, you need to specify gcc-4.8 for instance (I don't remember if it is installed by default, but you can still install it through brew)\n. CC is already picked up by cmake IIRC\n. @JackDunaway Aaah, I haven't thought of that solution. What I usually do for my projects is to add the runtime output directory to the PATH (or install the library files in a known subdirectory and add the bin/ directory to the path, which is what I currently do to in a project where I need to build and link multiple cmake dependencies). This has the advantage of working regardless of the layout and number of targets that I create.\nI would be in favor of having multiple CMakeLists. When I started using CMake, I thought that having one CMakeLists per subdirectory was dumb, but now that I manage larger projects, I kind of see the point: the main CMakeLists gets easily cluttered and harder to read the more you add to it. This is mostly a question of aethetics and readability, more than functionality.\n. You could have both. I am currently bundling nanomsg inside a project, and passing -DNN_TOOLS=OFF to disable all tools would be more convenient than specifying a list of -DNN_ENABLE_XXX=OFF (and update it if any tool gets added in the future). I agree that this is very far fetched since there is only nanocat, though.\nOn a complexity standpoint, adding a NN_TOOLS option with specific NN_ENABLE_XXX options isn't doing much: You'd just have to specify the default value of every NN_ENABLE option with ${NN_TOOLS}.\n. Right -- speed is a problem, which is why I set those two tests in allow_failures, and set fast_finish to true. This has the effect that fast, container-based builds determine the global result of the test, and doesn't undermine the ability to get builds results fast -- slower builds can work in the background without clogging the job queue.\n. SEND_ERROR continues execution, so the whole block below should be skipped if asciidoctor isn't found.\n. I think the original author misinterpreted the doc for GetSecurityInfo and meant LocalFree(sd)\n. I used the same test as the matching unlinking code below to be consistent, but you're right: it should definitely be inside a feature test rather than a platform test.\nThere is currently no cmake check to see if unix domain sockets are supported, other than supposing that all platforms other than windows support them. Maybe a separate commit should address this specific issue, but checking for availability of domain socket is not as trivial as checking for AF_UNIX, because windows actually provide a definition of it without using it in practice.\n. Actually, nevermind: AF_UNIX on windows is defined in winsock2.h, so we can feature test with sys/socket.h.\n. Following the current CMakeLists.txt, this is going to have -lpthread rather than -pthread. I don't think it matters in practice though (I've never seen any pthread linker flag other than -lpthread), but it might be desirable for compliance/portability of user programs.\n. I'm not sure to get what you're saying, are you asking if there's a way to avoid duplicating the full env entry?\nIf so, I don't think it's currently possible unfortunately. I originally added a ALLOW_FAIL=yes variable in both builds and put it as a condition for allowed failures, but it wasn't recognized. It seems you have to put the whole environment array as a condition.\nWhat I could do, in fact, is cheat a little. I could specify a compiler: gcc-failure key in both jobs, then re-export CC as gcc rather than gcc-failure, and use the compiler key as the condition.\nThis is unfortunate hackery for what should be normal behaviour.\n. > Is it possible to introduce a new K/V pair into the matrix, say called stress_test: true or failure_allowed: true, that then becomes a definition for allow_failures?\nAFAIK, no -- hence the hack using compiler.\nIt might be interesting to submit an issue ticket on travis-ci to ask for such a feature, or even better, to allow for a per-job allow_failure: true key.\n. Oh, right. Those are named yaml anchors, and you could in fact define two anchors for the env keys.\nEffectively, the result would be:\n``` yml\n  # Sporadic failure builds\n    - compiler: gcc\n      env: &env_sporadic_dbg CONFIGURATION=Debug    CTEST_OPTS=\"--repeat-until-fail 25 --schedule-random\"\n      install: install_cmake35\n      cache: cache_homedir\n    - compiler: gcc\n      env: &env_sporadic_rel CONFIGURATION=Release  CTEST_OPTS=\"--repeat-until-fail 25 --schedule-random\"\n      install: install_cmake35\n      cache: cache_homedir\nallow_failures:\n    - env: env_sporadic_dbg\n    - env: env_sporadic_rel\n```\nSounds good enough?\n. This would actually break mingw-w64 (& non-msvc in general) builds because NN_EXPORT isn't defined to __declspec(dllimport)/__declspec(dllexport) on non-msvc compilers anymore. CMake solves this problem when generating an export header, but I would rather have it leave NN_EXPORT as a conditional of _WIN32, not NN_HAVE_MSVC (or maybe let it use __attribute__((dllimport)) on GNU compilers).\nWindows is a special case, but it should be safe to assume that if a compiler on windows doesn't support something like __declspec(dllimport), shared library aren't going to work anyway.\n. Couldn't the call to xargs be replaced by an -exec  uncrustify -l C -c .uncrustify.cfg --replace --no-backup {} \\;?\n. ",
    "xor-gate": "Hi guys, i started working yesterday to support linux for the CMake build system at PR #616 \nWith some effort this could easily be extended for *BSD (Free/Net/Dragonfly etcetera).Ans as @Snaipe suggests some of this cmake code could be migrated from wirebirdlabs' work.\n. I will fully support your work \ud83d\udc4d \n. Good work all \ud83d\udc4d \n. @josephsmeng you are right, i have improved this (https://github.com/nanomsg/nanomsg/pull/616/commits/0bdc4de14c32fbf20b977398562d493d21f95406) and also platform checks are now way better. Now it uses poll2 syscall if it exists.\n. I leave this now as-is because it seems some people already tried to integrate cmake for cross-platform. Probably this can be a good base to have full cross-platform support on QNX,OSX,Solaris etc.\n. Looking good, I think people are in deep trouble when uint64_t is not defined nowadays...\n. CPack works great, it is very easy and reliable to build debian packages with it I use it in production.\n. It is nice to have deliverables for common used versions (E.g Debian 8), I use this in production to generate debian packages with CPack and works like a charm. If there is any help needed for debian I could assist but probably we would need some infrastructure (if we want this automaticly).\n. You must first configure cpack with setting CPACK_* variables and after that load cpack with include(CPack). After OS detection you could dispatch to different CPACK_ variable config files (debian, rpm, windows).\nAs example where I create a PHP module debian package:\nhttps://github.com/xor-gate/cmake-by-example/blob/master/find-php/example/CMakeLists.txt#L23-L35\n. ",
    "mascojames": "Any more information that could be provided here? Is this issue being worked or planned on being worked? Seems like the issue is known and could be fixed. I'd really like my unit tests on my components that use nanomsg to be leak free, this is the only one I haven't been able to get rid of....\n. Makes sense. Thanks for the reply!\n. Yes I am using the released 1.0.0 version of nanomsg. I guess that is acceptable that Windows and Linux behave differently in that aspect (nn_bind).\n. Using nanomsg 1.0.0, I have used nanomsg 0.8 and 0.6 in the past successfully on this hardware with a similar software build. I'll try reverting back to 0.8 tomorrow and see if that works, try to narrow down the issue.\nJust grabbed a stacktrace of the assertion failure:\n0  __GI_raise (sig=sig@entry=6) at /usr/src/debug/glibc/2.24-r0/git/sysdeps/unix/sysv/linux/raise.c:58\n1  0xb6773620 in __GI_abort ()  at /usr/src/debug/glibc/2.24-r0/git/stdlib/abort.c:89\n2  0xb6f74d08 in nn_err_abort () from target:/usr/lib/libnanomsg.so.5.0.0\n3  0xb6f75da0 in nn_queue_item_term () from target:/usr/lib/libnanomsg.so.5.0.0\n4  0xb6f71e48 in nn_usock_term () from target:/usr/lib/libnanomsg.so.5.0.0\n5  0xb6f85968 in nn_atcp_term () from target:/usr/lib/libnanomsg.so.5.0.0\n6  0xb6f860a8 in ?? () from target:/usr/lib/libnanomsg.so.5.0.0. Just to let you know I tried 0.9 and 0.8 and both had to same error. I must have a misconfiguration somewhere, I'll try playing around with the sock opts. . I set NN_RCVMAXSIZE to a higher value on my receiving side and that seems to prevent the assertion on the other end, however I would suspect that this is a bug if the subscribing side can take down the publishing side..",
    "anton-povarov": "Sorry for necroing this, but while the leak is not dependent on messages sent, it is dependent on the number of connects. Each connect adds leaked memory.\nThe pattern i was using with inproc is:\n- start server, it's alive for the lifetime of the program\n- new threads are spawned to handle user requests\n- request handling threads connect to server, perform their work, close the socket and die.\nthe result is that memory keeps growing forever, held by \"msgqueue chunk\" -s.\nwhile this can be worked around with just having connected socket alive forever, aren't multiple requesting threads going to step on each other's toes?\nas per doc:\nhttp://nanomsg.org/documentation-zeromq.html\n\nIn nanomsg, both REQ and REP support cancelling the ongoing processing. Simply send a new request without waiting for a reply (in the case of REQ socket) or grab a new request without replying to the previous one (in the case of REP socket).\n\nfull reproduce: https://gist.github.com/anton-povarov/22971249e311f5382feddee6e918d22d\n(building nanomsg with NN_ALLOC_MONITOR clearly shows the details).\nwhat can i do to fix / work around this?. ",
    "edw": "My man pages say 0.7-beta.\n. That shouldn't be a problem.\n. Hahaha! I'm updating the Homebrew formula and the build is hanging on make -j1 check.\n. OK, that was an adventure. Anyway, the man page for nn_recv now lists ETIMEDOUT, and nn_errno returns ETIMEDOUT, but I would argue that the man page is misleading in that it says that types of sockets are free to define their own timeout mechanism, whereas the nn_getsockopt man page says that setting NN_SNDTIMEO or NN_RCVTIMEO to a non-negative setting will cause an EAGAIN error.\nAlso, according to the nn_getsockopt man page,NN_SNDTIMEO and NN_RCVTIMEO seem to be defined for all socket types, which is different than the nn_recv man page's position that timeouts are (exclusively) a socket-type specific concern.\n. Also the nn_getsockopt man page, which erroneously says EAGAIN when it should say ETIMEDOUT.\n. I'm doing a blocking recv on a socket with a timeout set. I get ETIMEDOUT as you say. The getsockopt man page says I should get EAGAIN:\n\nNN_SNDTIMEO The timeout for send operation on the socket, in milliseconds. If message cannot be sent within the specified timeout, EAGAIN error is returned. Negative value means infinite timeout. The type of the option is int. Default value is -1.\nNN_RCVTIMEO The timeout for recv operation on the socket, in milliseconds. If message cannot be received within the specified timeout, EAGAIN error is returned. Negative value means infinite timeout. The type of the option is int. Default value is -1.\n. \n",
    "gwicksted": "@gdamore I don't think @charlie-x is referring to the use of the Windows API so much as the use of memset itself.\nThe memset function is being passed a reference (&) to a pointer (self->sec_attr) but the number of bytes of memory to set to 0 is sizeof (SECURITY_ATTRIBUTES) which is possibly != sizeof(void*)\nYou should just be able to drop the & assuming sec_attr is a pointer and it is of the type SECURITY_ATTRIBUTES\n. Stack screenshot:\n\n. Yes. I agree completely - just cloned ZMQ and it failed 2 tests before hanging the same way.\nOdd that this has never happened before - I suppose the tests are stressing something just the right way.\nClosing ticket.\n. ",
    "grodtron": "What is the status of this PR? Is it likely to be addressed at some point in the future?\n. After a bit more research, this seems to be the same underlying issue already discussed in #582 , but use in Python multiprocessing.Processs is another real life use case where its necessary to use nanomsg after fork()\n. ",
    "stevenhoving": "Yes, you are correct... I will prep a new pr tomorrow.\n. ",
    "taolinke": "My platform is centos 5.9, kernel is linux 2.6.18_x64\n. i have solved the problem by changing the source of src/aio/usock_posix.inc.\nif anyone who want the change. tell me.\nmy email is zz1126wnx@gmail.com\n. \u8001\u8d75.....\nOn Thu, Jan 21, 2016 at 2:49 PM, George Zhao notifications@github.com\nwrote:\n\nHi, may you give a PR for this\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/592#issuecomment-173476106.\n. @zhaozg \u5f20\u948a....\uff0cPR\u662f\u4ec0\u4e48\u4e1c\u4e1c\uff0c\u4e0d\u77e5\u9053\u54ce\n. The version is nanomsg-0.8-beta,not only NN_PUSH in tcp ,but also NN_PUB,like this:\n09:52:43.714940 IP 192.168.167.1.3336 > 192.168.167.11.43367: Flags [P.], seq 146:292, ack 1, win 114, options [nop,nop,TS val 51947767 ecr 51\n908718], length 146\n        0x0000:  4500 00c6 463e 4000 4006 2496 c0a8 a701  E...F>@.@.$.....\n        0x0010:  c0a8 a70b 0d08 a967 5a1e 3dae 2bef e178  .......gZ.=.+..x\n        0x0020:  8018 0072 d016 0000 0101 080a 0318 a8f7  ...r............\n        0x0030:  0318 106e 0000 0000 0000 008a 3746 3235  ...n........7F25\n        0x0040:  4541 4334 2d34 4641 342d 3434 4136 2d38  EAC4-4FA4-44A6-8\n        0x0050:  3039 412d 3333 3443 3946 4636 3137 3045  09A-334C9FF6170E\n        0x0060:  0009 7b22 7673 6d74 7970 6522 3a31 2c22  ..{\"vsmtype\":1,\"\n        0x0070:  7673 6d69 6422 3a22 3746 3235 4541 4334  vsmid\":\"7F25EAC4\n        0x0080:  2d34 4641 342d 3434 4136 2d38 3039 412d  -4FA4-44A6-809A-\n        0x0090:  3333 3443 3946 4636 3137 3045 222c 2274  334C9FF6170E\",\"t\n        0x00a0:  7970 6522 3a31 2c22 7265 7175 6573 7469  ype\":1,\"requesti\n        0x00b0:  6422 3a22 5461 7373 5265 706f 7274 6572  d\":\"TassReporter\n        0x00c0:  3030 3030 227d                           0000\"}\n09:52:43.714944 IP 192.168.167.1.3336 > 192.168.167.11.43367: Flags [P.], seq 146:292, ack 1, win 114, options [nop,nop,TS val 51947767 ecr 51\n908718], length 146\n        0x0000:  4500 00c6 463e 4000 4006 2496 c0a8 a701  E...F>@.@.$.....\n        0x0010:  c0a8 a70b 0d08 a967 5a1e 3dae 2bef e178  .......gZ.=.+..x\n        0x0020:  8018 0072 d016 0000 0101 080a 0318 a8f7  ...r............\n        0x0030:  0318 106e 0000 0000 0000 008a 3746 3235  ...n........7F25\n        0x0040:  4541 4334 2d34 4641 342d 3434 4136 2d38  EAC4-4FA4-44A6-8\n        0x0050:  3039 412d 3333 3443 3946 4636 3137 3045  09A-334C9FF6170E\n        0x0060:  0009 7b22 7673 6d74 7970 6522 3a31 2c22  ..{\"vsmtype\":1,\"\n        0x0070:  7673 6d69 6422 3a22 3746 3235 4541 4334  vsmid\":\"7F25EAC4\n        0x0080:  2d34 4641 342d 3434 4136 2d38 3039 412d  -4FA4-44A6-809A-\n        0x0090:  3333 3443 3946 4636 3137 3045 222c 2274  334C9FF6170E\",\"t\n        0x00a0:  7970 6522 3a31 2c22 7265 7175 6573 7469  ype\":1,\"requesti\n        0x00b0:  6422 3a22 5461 7373 5265 706f 7274 6572  d\":\"TassReporter\n        0x00c0:  3030 3030 227d                           0000\"}\n09:52:43.715038 IP 192.168.167.11.43367 > 192.168.167.1.3336: Flags [.], ack 292, win 1453, options [nop,nop,TS val 51910270 ecr 51947767], length 0\n        0x0000:  4500 0034 2886 4000 4006 42e0 c0a8 a70b  E..4(.@.@.B.....\n        0x0010:  c0a8 a701 a967 0d08 2bef e178 5a1e 3e40  .....g..+..xZ.>@\n        0x0020:  8010 05ad 7fd6 0000 0101 080a 0318 167e  ...............~\n        0x0030:  0318 a8f7                                ....\n09:52:43.715042 IP 192.168.167.11.43367 > 192.168.167.1.3336: Flags [.], ack 292, win 1453, options [nop,nop,TS val 51910270 ecr 51947767], length 0\n        0x0000:  4500 0034 2886 4000 4006 42e0 c0a8 a70b  E..4(.@.@.B.....\n        0x0010:  c0a8 a701 a967 0d08 2bef e178 5a1e 3e40  .....g..+..xZ.>@\n        0x0020:  8010 05ad 7fd6 0000 0101 080a 0318 167e  ...............~\n        0x0030:  0318 a8f7                                ....\n. it's the network problem.\n. Thanks for your reply.\nIs that mean i can not use functions like popen  or system, or i can't\nrun nanomsg in a forked child process?\nIs nanomsg-1.0 fork friendly?\nOr is there a way i can avoid it?\nOr is there any relative resource i can find to know what's going on?\nBTW,i am still using nanomsg-0.8-beta,and i do have a fork scheme to \ncheck if parent is alive or not.\nIf parent die,child will replace it and be the parent.\nAfter that the child will fork another child to monitor itself.\nBut all fork operations are at the beginning.\nLike this:\n\nbeparent:\n        sleep(1);\n        daemon(1,0);\n        //keep server alive\n        ppid = getpid();\n        pid = fork();\n        if(pid == 0) {\n                if(dogdog(ppid) == PARENT_IS_DIE) {\n                        //if found parent die, replace it.\n                        goto beparent;\n                }\n        }\nthen continues.\n. ",
    "anJava": "@zhaozg :\u4f60\u597d\uff0c\u5728\u4e48\uff0c\u6211\u662f\u4e0a\u6d77\u7684\u4e00\u4e2a\u521a\u5de5\u4f5c\u7684\u7a0b\u5e8f\u5458\uff0c\u770b\u5230\u4f60\u4e0a\u4f20\u4e86openscep\u7684\u4ee3\u7801\uff0c \u6211\u60f3\u5b89\u88c5openscep\u670d\u52a1\uff0c\u53ef\u662f\u5b89\u88c5\u4e0d\u4e0a\uff0c\u60f3\u8bf7\u6559\u4e00\u4e0b\uff0c\u8fd9\u662f\u6211\u7684qq\uff1a870963566\uff0c\u975e\u5e38\u611f\u8c22\uff01\uff01\n. ",
    "ID-Rocketeer": "Additional information regarding this hang. I have determined that this hang only occurs if I have the unit tests for code I'm developing are executing in a near-infinite loop while nanomsg is built/tested. My test are not yet at the point of exercising any nanomsg code, so there is no chance of direct interference with namomsg's self-tests. Some tests are mutli-threaded, but I never appear to have more than three threads running in the process, so I wouldn't expect that to hang in the nanomsg stress test.\n. Further update. My tests do not have to be running for the hang to occur. It seems like it may make it more likely to happen, but I execute the following command without anything else running on my system the tests will hang within just a couple of iterations.\ncount=0; while tests/ipc_stress; do echo $((++count)); done\n. The blocked state consistently has three running threads:\n$ ps -fLlp 8900\nF S UID        PID  PPID   LWP  C NLWP PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD\n0 T user      8900  1771  8900  0    3  80   0 - 212587 signal 14:40 pts/0   00:00:00 /sandbox/lib/nanomsg/nanomsg-0.8-beta/host/tests/.libs/lt-ipc_stress\n1 T user      8900  1771  8914  0    3  80   0 - 212587 signal 14:40 pts/0   00:00:00 /sandbox/lib/nanomsg/nanomsg-0.8-beta/host/tests/.libs/lt-ipc_stress\n1 T user      8900  1771  8923  0    3  80   0 - 212587 signal 14:40 pts/0   00:00:00 /sandbox/lib/nanomsg/nanomsg-0.8-beta/host/tests/.libs/lt-ipc_stress\n. Attached gdb to another hung execution. Here are the back traces for the threads:\n```\n(gdb) attach 11441\nAttaching to program: /sandbox/lib/nanomsg/nanomsg-0.8-beta/host/tests/.libs/lt-ipc_stress, process 11441\nReading symbols from /sandbox/lib/nanomsg/nanomsg-0.8-beta/host/.libs/libnanomsg.so.4...done.\nLoaded symbols for /sandbox/lib/nanomsg/nanomsg-0.8-beta/host/.libs/libnanomsg.so.4\nReading symbols from /lib64/libanl.so.1...(no debugging symbols found)...done.\nLoaded symbols for /lib64/libanl.so.1\nReading symbols from /lib64/librt.so.1...(no debugging symbols found)...done.\nLoaded symbols for /lib64/librt.so.1\nReading symbols from /lib64/libpthread.so.0...(no debugging symbols found)...done.\n[New LWP 11463]\n[New LWP 11455]\n[Thread debugging using libthread_db enabled]\nLoaded symbols for /lib64/libpthread.so.0\nReading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.\nLoaded symbols for /lib64/libc.so.6\nReading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.\nLoaded symbols for /lib64/ld-linux-x86-64.so.2\n0x0000003aee40822d in pthread_join () from /lib64/libpthread.so.0\nMissing separate debuginfos, use: debuginfo-install glibc-2.12-1.132.el6_5.2.x86_64\n(gdb) info threads\n  3 Thread 0x7f7492284700 (LWP 11455)  0x0000003aee0df333 in poll () from /lib64/libc.so.6\n  2 Thread 0x7f74883f9700 (LWP 11463)  0x0000003aee0e9153 in epoll_wait () from /lib64/libc.so.6\n* 1 Thread 0x7f7492286700 (LWP 11441)  0x0000003aee40822d in pthread_join () from /lib64/libpthread.so.0\n(gdb) back\n0  0x0000003aee40822d in pthread_join () from /lib64/libpthread.so.0\n1  0x0000000000400f1f in nn_thread_term (self=) at ../tests/../src/utils/thread_posix.inc:69\n2  0x00000000004011de in main (argc=, argv=) at ../tests/ipc_stress.c:153\n(gdb) thread 2\n[Switching to thread 2 (Thread 0x7f74883f9700 (LWP 11463))]#0  0x0000003aee0e9153 in epoll_wait () from /lib64/libc.so.6\n(gdb) back\n0  0x0000003aee0e9153 in epoll_wait () from /lib64/libc.so.6\n1  0x00007f74924bcf82 in nn_poller_wait (self=0x7f74926ec444, timeout=-1) at ../src/aio/poller_epoll.inc:176\n2  0x00007f74924bfd88 in nn_worker_routine (arg=0x7f74926ec400) at ../src/aio/worker_posix.inc:177\n3  0x0000000000400d7d in nn_thread_main_routine (arg=) at ../tests/../src/utils/thread_posix.inc:35\n4  0x0000003aee4079d1 in start_thread () from /lib64/libpthread.so.0\n5  0x0000003aee0e8b5d in clone () from /lib64/libc.so.6\n(gdb) thread 3\n[Switching to thread 3 (Thread 0x7f7492284700 (LWP 11455))]#0  0x0000003aee0df333 in poll () from /lib64/libc.so.6\n(gdb) back\n0  0x0000003aee0df333 in poll () from /lib64/libc.so.6\n1  0x00007f74924c090c in nn_efd_wait (self=, timeout=-1) at ../src/utils/efd.c:51\n2  0x00007f74924bb089 in nn_sock_recv (self=0x7f748c001df0, msg=0x7f7492283d90, flags=) at ../src/core/sock.c:745\n3  0x00007f74924b7fdd in nn_recvmsg (s=, msghdr=0x7f7492283e40, flags=0) at ../src/core/global.c:947\n4  0x00007f74924b82eb in nn_recv (s=, buf=, len=, flags=) at ../src/core/global.c:770\n5  0x0000000000400e83 in server (arg=) at ../tests/ipc_stress.c:82\n6  0x0000000000400d7d in nn_thread_main_routine (arg=) at ../tests/../src/utils/thread_posix.inc:35\n7  0x0000003aee4079d1 in start_thread () from /lib64/libpthread.so.0\n8  0x0000003aee0e8b5d in clone () from /lib64/libc.so.6\n(gdb) print active\n$1 = {n = 0}\n(gdb) thread 2\n[Switching to thread 2 (Thread 0x7f74883f9700 (LWP 11463))]#0  0x0000003aee0e9153 in epoll_wait () from /lib64/libc.so.6\n(gdb) print active\n$2 = {n = 0}\n(gdb) thread 1\n[Switching to thread 1 (Thread 0x7f7492286700 (LWP 11441))]#0  0x0000003aee40822d in pthread_join () from /lib64/libpthread.so.0\n(gdb) print active\n$3 = {n = 0}\n(gdb) \n```\nIt appears the server is still anticipating a message without anyone expecting to send one. I've not fully analyzed the test code but this suggests to me that there is a race condition with regard to the server checking the atomic variable.\n. Actually, I think the issue is the setting of atomic.n in the main thread. Since it doesn't use any sort of phtread synchronization mechanism to modify the variable there is no assurance of when the value will update in the server thread. The server thread's access to the variable is suspect for the same reason. This is what I'm assuming for the moment, but I've not confirmed it yet. I thought the goal of nanomsg was the same as that of zeromq in that it was supposed to be the only synchronization mechanism one needs, but in the case of tests of the messaging system I believe that external synchronization is still necessary.\n. Yeah, I'm looking at the code in atomic.c and it looks like there really should be nn_atomic_get() and nn_atomic_set() functions to atomically access the variable in those locations. That way the mutex would properly be taken and released, forcing the synchronization of the value across the threads.\n. With the addition of those operations the internal structure of the atomic variable should be hidden in atomic.c to prevent direct access to the value of the variable as is being done in the test.\n. I agree this appears to be a duplicate. Not sure why I didn't find that previous issue before I opened this one. Hopefully they added the mutex on Linux/pthreads and the accessor functions I described, or there are probably still going to be issues. All accesses to the atomic variable need to be through functions that force the value to be synchronized across threads, which generally means a mutex.\nI'm not really set up to pull from github for my build environment, instead using the packaged tarballs as they become available. Do you have any idea when the 0.9 tarball will be released?\n. OK, I just looked at the code in github for the test and see that they have eliminated the atomic (though not the include) and agree the test should pass.\nI'm concerned though with the nn_atomic type. It would appear that on my platform it is still going to permit unsynchronized access to the value of the variable, since it doesn't appear to use a mutex to force synchronization of the value across multiple threads. I've seen other code on my target that failed when we were only using volatile variables and the way the old test was failing supports that it is indeed an issue.\n. But there still needs to be forced synchronization across threads (or there is no need for an atomic at all) and I don't believe such protection is provided by \"volatile\" on my platform. I'm working up a small test of that at this time.\n. OK, I see now that my platform should be using the _sync... operations and have proven they work on my platform, so I'll close this issue as duplicate.\n. Hmmm, how do I close the issue?\n. ",
    "AlexanderZh": "Thank you for fast reply! \u041e\u043a, I'll not use inproc. \nBut what about ipc for example? As I've mentioned above in (2) there is a similar problem. After adding for loop and some printf for diagnostics as follows:\nC\n...\nk_max = atoi (argv [4]);\n    int k;\n    for(k=0; k<k_max; k++)\n    {\n        s = nn_socket (AF_SP, NN_PAIR);\n...\n    for (i = 0; i != count; i++) {\n            nbytes = nn_recv (s, buf, sz, 0);\n            if(nbytes != (int)sz)\n                printf(\"got %d instead of %d\\n\", nbytes, (int)sz );\n            assert (nbytes == (int)sz);\n        }\n...\nI get the following output  (last argument 100 is k_max in for loop) :\nbash\n$./perf/local_thr ipc:///tmp/test123 1024 1000 100\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 228050 [msg/s]\nthroughput: 1868.186 [Mb/s]\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 202429 [msg/s]\nthroughput: 1658.298 [Mb/s]\ngot 0 instead of 1024\nlt-local_thr: perf/local_thr.c:75: main: Assertion `nbytes == (int)sz' failed.\nAborted (core dumped)\nAfter several loops 0 bytes are received instead of 1024.\nAs for tcp the output is:\nbash\n$ ./perf/local_thr tcp://127.0.0.1:5555 1024 1000 100\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 214546 [msg/s]\nthroughput: 1757.561 [Mb/s]\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 327011 [msg/s]\nthroughput: 2678.874 [Mb/s]\nmessage size: 1024 [B]\nmessage count: 1000\nthroughput: 286697 [msg/s]\nthroughput: 2348.622 [Mb/s]\ngot 1024 instead of 0\nlt-local_thr: perf/local_thr.c:70: main: Assertion `nbytes == 0' failed.\nAborted (core dumped)\nSometimes 1024 bytes are received instead of 0 bytes and sometimes vice versa. Does that mean that the order of messages is not preserved between sender and receiver? And is it the intended behaviour?\n. ",
    "lucasb-eyer": "Sorry, currently too busy with other things. I'll indeed let you know in the future if it still happens, thanks for the feedback!\n. It indeed seems fixed in HEAD. I was using the nnpy bindings, sorry for having missed that question.\n. ",
    "chrisheller": "Yes, mingw-w64 is what was being used.  That works for building both 32 bit and 64 bit versions of nanomsg. \nThere was one error about nn_sleep not being defined when linking tcpmuxd though.  I think that it is some libtool related issue in our environment,  but hadn't spent much time in tracking that down. We just disabled building tcpmuxd since we aren't using it. \n@Snaipe did tcpmuxd build OK for you?\n. ",
    "wavesoft": "Looking into the errors reported by CI tests...\n. Hi all, just a heads-up regarding the new changes:\n- For semantical correctness I changed nn_chunkref_getchunk to only get the chunk and I introduced nn_chunkref_popchunk to get the chunk and reset the reference.\n- I also added a test for the nn_chunk_alloc_ptr function that I introduced\nI am looking forward to your feedback :smile: \n. Summarising all the updates, including the original commits and the modifications ever since:\nChangelog\n\nFIX: Making sure nn_chunkref_mv clean-ups the source after moving data to destination.\nFIX: Introducing the nn_chunkref_popchunk to semantically differentiate from nn_chunkref_getchunk. The first should reset the chunk reference after returning/creating the referred chunk, while the latter should keep it unharmed.\nADD: Introducing nn_chunk_alloc_ptr to allocate zero-copy messages from existing data + user-provided deallocator function. \nADD: Adding user pointer in struct nn_chunk, passed to the chunk de-allocator function.\nADD: Adding nn_chunk_replace_free_fn that that allows replacing of the free function of a chunk. This combined with the user pointer allows chaining of free functions.\nADD: Adding nn_chunk_deref that must be used in order to receive the pointer to the chunk. This either returns the base address to the chunk data, or the pointer the chunk carries.\nADD: Adding nn_chunk_reset that resets the contents of the chunk to it's original state (ex. removing empty space) and optionally hard-replace the size of the chunk. This is particularly useful for allocating a chunk only once and re-using it.\n. I made an important decision that I wanted the potential users of this function to know: \n\n\n:warning:  Please do not use this function inside the transport or protocol!\n\nLet me elaborate on this: If you allocate a message using nn_chunk_alloc_ptr and pass it to the pipebase receive function, the user will end-up with a pointer to a pointer and not to the data. This means that the following code won't work:\n``` c\nvoid *buf = NULL;\nnbytes = nn_recv (s, &buf, NN_MSG, 0);\n/ ERROR: buf is a pointer to a pointer (void) not pointer to data! /\nprintf( \"Data: %s\\n\", buf );\n/ This would work, but this breaks the API, since the user does not\n   know if buf is a data pointer or a pointer to a pointer /\nprintf( \"Data :%s\\n\", ((char*)buf));\n```\nChangelog\n\nADD: Merged #620 in order to avoid relying on nn_chunk_alloc_ptr in the transport in order to allocate page-aligned memory.\n. I could not find the reason why this is here. It looks that when somebody calls nn_chunkref_getchunk the internal reference is just released. This makes no sense, since there is no other way to get the internal chunk and there might be more than one call needed.\n. I am trying to reuse as much as possible from the original chunk structure, with the smallest memory impact possible.\n\nIn order to differentiate a classic chunk vs a pointer chunk I could have used two approaches:\n- Introduce a type field in the nn_chunk structure (adds an extra byte in memory)\n- Use a different tag (needs an extra tag check, but requires fewer tests in order to get the underlying pointer)\n  I chose the second.\n. ",
    "lukepg": "Ok, thank you very much for the response. By TCP do you mean without NanoMsg or TCP provided by a NanoMsg through a wrapper (if such thing exists)?\n. Ok, thank you very much for the helpful responses.\n. ",
    "Qix-": "Could have sworn this built \ud83c\udf68 Just a sec.\n. ",
    "josephsmeng": "the author of these CMake files seems like adding a space after each commands, so I think maybe it would be better for as to do the same for the consistency. some lines does not obey this rule, like the install command from the src/CMakeLists.txt, I think you can fix this in your pulls. thanks for your codes.\n. why don't you just right your own script for the make process then use the generated static library header file? I don't think this is nanomsg's job for this.\n. ",
    "saulthu": "+1, optional synchronous bind/connect would be helpful in my case\n. ",
    "mojoTX": "I'm working on a commercial product, and we're seriously considering using nanomsg as our core messaging platform. Naturally if we did use the library, we would actively contribute back, but the lack of activity was one of our concerns.\nIt's been my observation that most successful open-source projects DO have a strong \"BDFL\" type leader that delegates as needed.\n. ",
    "nxtreaming": "remove +1\nOn Thu, Apr 14, 2016 at 2:56 AM, gdamore notifications@github.com wrote:\n\nThe tcpmux transport was an experiment, but ultimately it turns out not be\nvery useful given the websocket transport.\nTCP mux also has portability problems, and really to be useful requires\nroot privilege (so it runs on port 1), which makes it mostly useless for a\nlarge number of scenarios. The websocket transport doesn't suffer from this\nproblem at all.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/621\n. On Fri, Oct 13, 2017 at 2:45 AM, Alejandro Cort\u00e9s notifications@github.com\nwrote:\nI'm using the libnanomsg.a and I have undefined symbols too, I think we\nhave the same problem.\n[ 50%] Linking CXX executable iadlsrv\n/usr/local/lib/libnanomsg.a(dns.c.o): In function nn_dns_start':\ndns.c:(.text+0x50e): undefined reference togetaddrinfo_a'\n/usr/local/lib/libnanomsg.a(dns.c.o): In function nn_dns_notify':\ndns.c:(.text+0x5ee): undefined reference togai_error'\n/usr/local/lib/libnanomsg.a(dns.c.o): In function nn_dns_shutdown':\ndns.c:(.text+0x7a6): undefined reference togai_cancel'\ncollect2: error: ld returned 1 exit status\nCMakeFiles/iadlsrv.dir/build.make:96: recipe for target 'iadlsrv' failed\nmake[2]:  [iadlsrv] Error 1\nCMakeFiles/Makefile2:67: recipe for target 'CMakeFiles/iadlsrv.dir/all'\nfailed\nmake[1]:  [CMakeFiles/iadlsrv.dir/all] Error 2\nMakefile:127: recipe for target 'all' failed\nmake: *** [all] Error 2\nlibnanomsg.so works just perfect, the static version is the problem\n\n\ntry to link the \"Ws2_32.lib\" as well.\n\nany idea?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/908#issuecomment-336229852,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AC9tC6aLOevsMaQC5HDE1i91YAxcl1gcks5srl48gaJpZM4P2GdE\n.\n. \n",
    "netxray": "thanks! The problem has been resolved. \n. ",
    "BillMcCroskey": "Yes, using Mangos for Go.  Most packets are much under the 576.  Might try the time delay as a quick fix.  Longer solution might be to fire up a process on the first one that sits on the socket and then the command-line facing half posts IPC to the service and then command a shutdown as needed at end.\nThanks!\n. Typo - I meant Receiving OF published messages\n. I got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\nThe other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv.  The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory.  Valgrind will also show the nanomsg library as leaking.  It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1].  It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults.  I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part.  It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n. Also note that the GoLang Mangos routines used in a similar fashion produce the same leak per packet.\nThat is nn_sendmsg with scatter array on the Pub and nn_recv on the Sub.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n. Ipc to a file point in /tmp.\nPub on one end, Sub on the other.  Send with nn_sendmsg on Pub, receive with nn_recv on Sub.\nI\u2019d have to set up a small project as my small program has too much internal content.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm.\n. Found the issue, you can close the topic.\nThe buffer being filled was a char * and not a void *.  The change fixed the leak.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm.\n. No\nFrom: gdamore [mailto:notifications@github.com]\nSent: Friday, August 26, 2016 11:50 AM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nso not a nanomsg bug then?\nSent from my iPhone\n\nOn Aug 26, 2016, at 8:26 AM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote:\nFound the issue, you can close the topic.\nThe buffer being filled was a char * and not a void *. The change fixed the leak.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com%3cmailto:nanomsg@noreply.github.com>>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com%3cmailto:Bill.McCroskey@Crown.com>>; Author author@noreply.github.com<mailto:author@noreply.github.com<mailto:author@noreply.github.com%3cmailto:author@noreply.github.com>>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org>>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com>>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242773453, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiumGjym2SydoXSJjxgeAsgkVgerCnks5qjws2gaJpZM4JtcKm.\n. False hope, it sill leaks\nFrom: gdamore [mailto:notifications@github.com]\nSent: Friday, August 26, 2016 11:50 AM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nso not a nanomsg bug then?\nSent from my iPhone\n\nOn Aug 26, 2016, at 8:26 AM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote:\nFound the issue, you can close the topic.\nThe buffer being filled was a char * and not a void *. The change fixed the leak.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com%3cmailto:nanomsg@noreply.github.com>>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com%3cmailto:Bill.McCroskey@Crown.com>>; Author author@noreply.github.com<mailto:author@noreply.github.com<mailto:author@noreply.github.com%3cmailto:author@noreply.github.com>>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org>>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com>>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242773453, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiumGjym2SydoXSJjxgeAsgkVgerCnks5qjws2gaJpZM4JtcKm.\n. We are on an old version of nanomsg and will upgrade to latest and repeat test.\nThe main thing I need to get working is nn_recvmsg with nonomsg allocating the buffer.  Following the guild, I can\u2019t get it to work.\nWe will try it first on a newer version.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm.\n. I  got it working.  I got the nn_recvmsg working, but the root of the problem was not passing a pointer to a void * on the receive in that case.\nNo leaks on the \u2018C\u2019 side.  I\u2019ll have to look at the GoLang side.  It is possible to leak faster than the garbage collection \u2013 seen in two applications.\nThanks!\nFrom: gdamore [mailto:notifications@github.com]\nSent: Saturday, August 27, 2016 11:09 AM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nthat should work fine. you do have to free the message yourself though once you are done with it.\ntry writing the smallest program you can that reproduces the problem.\nnote that there is no difference on the wire if you use gather to send a message from different chunks so that should not have any effect on the receive side.\nSent from my iPhone\n\nOn Aug 26, 2016, at 12:55 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote:\nWe are on an old version of nanomsg and will upgrade to latest and repeat test.\nThe main thing I need to get working is nn_recvmsg with nonomsg allocating the buffer. Following the guild, I can\u2019t get it to work.\nWe will try it first on a newer version.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com%3cmailto:nanomsg@noreply.github.com>>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com%3cmailto:Bill.McCroskey@Crown.com>>; Author author@noreply.github.com<mailto:author@noreply.github.com<mailto:author@noreply.github.com%3cmailto:author@noreply.github.com>>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org>>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com>>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242922506, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiukoI42QIKQylIAKMArqNlJix8tP7ks5qkFLvgaJpZM4JtcKm.\n. Further checks still show a leak\u2026 I\u2019ll setup a small program to run it down or try V1.0\nFrom: gdamore [mailto:notifications@github.com]\nSent: Saturday, August 27, 2016 11:09 AM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nthat should work fine. you do have to free the message yourself though once you are done with it.\ntry writing the smallest program you can that reproduces the problem.\nnote that there is no difference on the wire if you use gather to send a message from different chunks so that should not have any effect on the receive side.\nSent from my iPhone\n\nOn Aug 26, 2016, at 12:55 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote:\nWe are on an old version of nanomsg and will upgrade to latest and repeat test.\nThe main thing I need to get working is nn_recvmsg with nonomsg allocating the buffer. Following the guild, I can\u2019t get it to work.\nWe will try it first on a newer version.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com%3cmailto:nanomsg@noreply.github.com>>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com%3cmailto:Bill.McCroskey@Crown.com>>; Author author@noreply.github.com<mailto:author@noreply.github.com<mailto:author@noreply.github.com%3cmailto:author@noreply.github.com>>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org>>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com>>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242922506, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiukoI42QIKQylIAKMArqNlJix8tP7ks5qkFLvgaJpZM4JtcKm.\n. Working on getting V1.0.0 working, but found what is going on with 0.4beta:\nOn a sub side of a socket, any program leaks memory when there is more than one topic running on the bus and your subscription covers only one of the topics on the bus.\nThat was why it worked sometimes and would break at times.\nNanocat leaks the same under that condition. Macat leaks all the time.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Saturday, August 27, 2016 11:09 AM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nthat should work fine. you do have to free the message yourself though once you are done with it.\ntry writing the smallest program you can that reproduces the problem.\nnote that there is no difference on the wire if you use gather to send a message from different chunks so that should not have any effect on the receive side.\nSent from my iPhone\n\nOn Aug 26, 2016, at 12:55 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com> wrote:\nWe are on an old version of nanomsg and will upgrade to latest and repeat test.\nThe main thing I need to get working is nn_recvmsg with nonomsg allocating the buffer. Following the guild, I can\u2019t get it to work.\nWe will try it first on a newer version.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author author@noreply.github.com<mailto:author@noreply.github.com>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com>> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the sender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but use htop and watch the task receiving and it will show memory leakage on resident memory. Valgrind will also show the nanomsg library as leaking. It is a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the buffer.\nI coded up a receive with nn_recvmsg and got it working with stack allocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was trying to get out of segment faults. I must not have the structures set up right to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator part. It seems that I should get one element allocated and it should parse out kind of like the data from the nn_recv when I pull it out of the hdr structure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com%3cmailto:nanomsg@noreply.github.com>>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com%3cmailto:Bill.McCroskey@Crown.com>>; Author author@noreply.github.com<mailto:author@noreply.github.com<mailto:author@noreply.github.com%3cmailto:author@noreply.github.com>>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds tragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org<mailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@damore.org>>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey notifications@github.com<mailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com<mailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:notifications@github.com>>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242569876, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242612508, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-242922506, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiukoI42QIKQylIAKMArqNlJix8tP7ks5qkFLvgaJpZM4JtcKm.\n. Yes, I just use them for test, but I was trying to see if I could get a different code base to produce the same result in the same situation.\nGoLang routines build from mangos leak in the same pattern of subscribe to one topic when two are on the bus.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Monday, August 29, 2016 12:41 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nAh, that is useful information. I can try to confirm this, and if so, a\nfix should be straight-forward.\nnanocat and macat are really test programs \u2014 its unsurprising that they\nleak in variety of situations; I wouldn\u2019t use them in long-running\nsituations. That said, we should find and fix any leaks that may exist.\nOn Mon, Aug 29, 2016 at 9:36 AM, BillMcCroskey notifications@github.com<mailto:notifications@github.com>\nwrote:\n\nWorking on getting V1.0.0 working, but found what is going on with\n0.4beta:\nOn a sub side of a socket, any program leaks memory when there is more\nthan one topic running on the bus and your subscription covers only one of\nthe topics on the bus.\nThat was why it worked sometimes and would break at times.\nNanocat leaks the same under that condition. Macat leaks all the time.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Saturday, August 27, 2016 11:09 AM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author \nauthor@noreply.github.commailto:author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nthat should work fine. you do have to free the message yourself though\nonce you are done with it.\ntry writing the smallest program you can that reproduces the problem.\nnote that there is no difference on the wire if you use gather to send a\nmessage from different chunks so that should not have any effect on the\nreceive side.\nSent from my iPhone\n\nOn Aug 26, 2016, at 12:55 PM, BillMcCroskey notifications@github.com<\n<mailto:notifications@github.com%3c%0b> mailto:notifications@github.com>> wrote:\nWe are on an old version of nanomsg and will upgrade to latest and\nrepeat test.\nThe main thing I need to get working is nn_recvmsg with nonomsg\nallocating the buffer. Following the guild, I can\u2019t get it to work.\nWe will try it first on a newer version.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 10:49 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:\n<mailto:nanomsg@noreply.github.com%3cmailto:%0b> nanomsg@noreply.github.commailto:nanomsg@noreply.github.com>>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:\n<mailto:Bill.McCroskey@Crown.com%3cmailto:%0b> Bill.McCroskey@Crown.commailto:Bill.McCroskey@Crown.com>>; Author author@noreply.github.com<mailto:\n<mailto:author@noreply.github.com%3cmailto:%0b> author@noreply.github.commailto:author@noreply.github.com>>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\ni need your code to diagnose properly. which transport is this?\nSent from my iPhone\n\nOn Aug 25, 2016, at 5:57 PM, BillMcCroskey notifications@github.com<\n<mailto:notifications@github.com%3c%0b> mailto:notifications@github.commailto:notifications@github.com%3cmailtonotifications@github.com%3cmailto:notifications@github.com%3cmailto:\nnotifications@github.commailto:notifications@github.com>> wrote:\nI got it unblocked.\nARM Cortex-A8 CPU.\nI might have a small app to duplicate it, but the basic setup is the\nsender runs a scatter array with two elements:\nFirst element is a structure with two fields\n1. 40 char string that holds the packet topic\n2. Uint32_t count of next field\n   The other scatter array has the serialized string data.\n   That goes in a nn_sendmsg sent on a Pub socket\nTry to receive on a Sub socket with nn_recv. The packet receives, but\nuse htop and watch the task receiving and it will show memory leakage on\nresident memory. Valgrind will also show the nanomsg library as leaking. It\nis a per packet leak.\nI suspected the nn_recv was not pulling all the content out of the\nbuffer.\nI coded up a receive with nn_recvmsg and got it working with stack\nallocated buffers for the iov[0] and [1]. It ran with no leaks.\nNext up, I was trying to get it to allocate on the nn_recvmsg and was\ntrying to get out of segment faults. I must not have the structures set up\nright to get it to allocate.\nIt\u2019s hard to guess the max packet, so I\u2019d like to use the allocator\npart. It seems that I should get one element allocated and it should parse\nout kind of like the data from the nn_recv when I pull it out of the hdr\nstructure.\nIf I can get the nn_recvmsg call going, I think I have it working.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Thursday, August 25, 2016 6:52 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:\n<mailto:nanomsg@noreply.github.com%3cmailto:%0b> nanomsg@noreply.github.commailto:nanomsg@noreply.github.com%nanomsg@noreply.github.com%3cmailto:nanomsg@noreply.github.com%25\n3cmailto:nanomsg@noreply.github.com>>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:\n<mailto:Bill.McCroskey@Crown.com%3cmailto:%0b> Bill.McCroskey@Crown.commailto:Bill.McCroskey@Crown.com%3cmailto:BillBill.McCroskey@Crown.com%3cmailto:Bill.McCroskey@Crown.com%3cmailto:Bill.\nMcCroskey@Crown.commailto:McCroskey@Crown.com>>; Author author@noreply.github.com<mailto:\n<mailto:author@noreply.github.com%3cmailto:%0b> author@noreply.github.commailto:author@noreply.github.com%author@noreply.github.com%3cmailto:author@noreply.github.com%25\n3cmailto:author@noreply.github.com>>\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI wonder why OpenDNS is blocking nanomsg.org though?? That sounds\ntragic!\nOn Thu, Aug 25, 2016 at 3:47 PM, Garrett D'Amore garrett@damore.org\n<mailto:garrett@damore.org%0b> garrett@damore.org<mailto:garrett@damore.org%3cmailto:garrett@\n<mailto:garrett@damore.org%3cmailto:garrett@damore.org%3cmailto:garrett@%0b> damore.orggarrett@damore.org%3cmailto:garrett@damore.org%\n<mailto:garrett@damore.org%3cmailto:garrett@damore.org%25%0b> 3cmailto:garrett@damore.org%3cmailto:garrett@damore.org>>>> wrote:\n\nThis seems like a bug. Can you provide a minimal implementation that\nreproduces this behavior?\nOn Thu, Aug 25, 2016 at 12:54 PM, BillMcCroskey \nnotifications@github.commailto:notifications@github.com<mailto<mailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:\nnotifications@github.com%3cmailto:notifications@github.com<mailto<mailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:\nnotifications@github.com%3cmailto:notifications@github.com%3cmailtomailto:notifications@github.com%3cmailto:notifications@github.com%3cmailto:\nnotifications@github.com%3cmailto:notifications@github.commailto:notifications@github.com%3cmailto:notifications@github.com>>>>\nwrote:\n\nTypo - I meant Receiving OF published messages\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#\nissuecomment-242515390,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/\n<https://github.com/notifications/unsubscribe-auth/%0b> ABPDfRmiv5Hkx15iwVv1G3IwS5MIrEOpks5qjfL5gaJpZM4JtcKm>\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/\n<https://github.com/%0b> nanomsg/nanomsg/issues/797#issuecomment-242569876>, or mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/ASTiunngtBljx_IAjK-\n2jMNggSNQgTCtks5qjhySgaJpZM4JtcKm>.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/\n<https://github.com/%0b> nanomsg/nanomsg/issues/797#issuecomment-242612508>, or mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/\nASTiuo2fGHwlgBXz9zIRVJi4nPw6phwtks5qjlQygaJpZM4JtcKm>.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/\n<https://github.com/%0b> nanomsg/nanomsg/issues/797#issuecomment-242922506>, or mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/\nASTiukoI42QIKQylIAKMArqNlJix8tP7ks5qkFLvgaJpZM4JtcKm>.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243178338,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfbzyl5-Tf2Yd_dU4vXybnABaFOJYks5qkwqEgaJpZM4JtcKm\n.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243179445, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTium9X4fS52eGVJVPim2Id-J4R5DeSks5qkwt-gaJpZM4JtcKm.\n. nanocat --sub --connect-ipc /tmp/Pub_bus.ipc  -A --subscribe My.Data.One\nSend from the pub side two topics.  My packets are 40-byte topic region (set to length 40 in socketopt), 4-byte length of the data field, the data field of serialized data (variable length).\nFrom valgrind:\n==4118== 32,268 bytes in 213 blocks are definitely lost in loss record 34 of 34\n==4118==    at 0x4833CC0: malloc (vg_replace_malloc.c:291)\n==4118==    by 0x4880307: nn_chunk_alloc (in /usr/lib/libnanomsg.so.0.2.0)\nFrom: gdamore [mailto:notifications@github.com]\nSent: Monday, August 29, 2016 1:03 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nAnd I see almost exactly the same logic in nanomsg xsub.c:\n```\nrc = nn_trie_match (&xsub->trie, nn_chunkref_data (&msg->body),\nnn_chunkref_size (&msg->body));\n\nif (rc == 0) {\nnn_msg_term (msg);\n\ncontinue;\n\n}\n```\nI want to know how you demonstrated the leak? I am going to try to reproduce myself with nanocat (and perhaps macat).\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243185765, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiunos4E_MesCOTG_RCnByWZMvLFxQks5qkxDIgaJpZM4JtcKm.\n. Unless you use the \u2013i 1 on nanocat, you can\u2019t get it to stay on the bus and send.  I\u2019m having a hard time getting a shell script to do what the program does.\nThe leak is continuous and per packet.  Watching the \u201cRES\u201d field in htop will show what valgrind is reporting.\nI\u2019d have to make up a small program.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Monday, August 29, 2016 1:35 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nSo, I can't see a leak using nanocat. I'm using a single subscriber with about 200 publishers, but I'm subscribing to messages from only about 11 of them. They each publish a message at one second intervals. This is using the TCP transport on MacOS X.\nNote that I do see a fixed size increase per socket (not per message) that I've connected. That's normal and expected behavior as there are data structures per connected TCP stream.\nIts possible that a single message is \"leaked\", but its definitely not continuous. (I'm not verifying with vgrind or anything like that, just watching the process looking for increasing heap growth. I'm not seeing any of that.) I would be far less concerned about leaking a small amount of resources just a single time (e.g. a buffer leak at start up), provided that memory consumption does not grow over time/usage.\nIf you can write a shell script that demonstrates the leak, and describe how you are verifying that such a leak exists, it would be useful.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243194933, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuqTnRaN14Q4izltaZI660i8BR-Vsks5qkxg4gaJpZM4JtcKm.\n. The loss is on maintained connections that never drop the channel.\nI have some small packet encoders that generate messages.  On those, I had to connect, delay at least 50mS, send, delay at least 50mS, then disconnect to get data on for testing packet based handling.  If you don\u2019t do that, not all subscribers get the data, I think this is why you need the \u2013I on nanocat \u2013 must be link control under the hood.\nThe loss showed up once I got two subscription topics running on the bus on the maintained links.\nA request goes to the server on a pipeline, then the data is streamed to the clients on a sub bus.  Two clients hit a server for their request.  Each client is looking for its subscription for the data.\nI\u2019ve not looked at the nanomsg code, but my mental model is that the subscription is a filter before the receive \u2013 each client should never even see the other packets from the other subscription, yet it seems there is impact.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Monday, August 29, 2016 4:59 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nI will have to download valgrind to test\u2026 I did use the -i flag to nanocat.\nI wonder if the problem is that packets are getting lost when you\ndisconnect? That actually makes more sense to me as a potential area of\nconcern.\nOn Mon, Aug 29, 2016 at 10:40 AM, BillMcCroskey notifications@github.com<mailto:notifications@github.com>\nwrote:\n\nUnless you use the \u2013i 1 on nanocat, you can\u2019t get it to stay on the bus\nand send. I\u2019m having a hard time getting a shell script to do what the\nprogram does.\nThe leak is continuous and per packet. Watching the \u201cRES\u201d field in htop\nwill show what valgrind is reporting.\nI\u2019d have to make up a small program.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Monday, August 29, 2016 1:35 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com<mailto:nanomsg@noreply.github.com>\nCc: Bill McCroskey Bill.McCroskey@Crown.com<mailto:Bill.McCroskey@Crown.com>; Author \nauthor@noreply.github.commailto:author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nSo, I can't see a leak using nanocat. I'm using a single subscriber with\nabout 200 publishers, but I'm subscribing to messages from only about 11 of\nthem. They each publish a message at one second intervals. This is using\nthe TCP transport on MacOS X.\nNote that I do see a fixed size increase per socket (not per message) that\nI've connected. That's normal and expected behavior as there are data\nstructures per connected TCP stream.\nIts possible that a single message is \"leaked\", but its definitely not\ncontinuous. (I'm not verifying with vgrind or anything like that, just\nwatching the process looking for increasing heap growth. I'm not seeing any\nof that.) I would be far less concerned about leaking a small amount of\nresources just a single time (e.g. a buffer leak at start up), provided\nthat memory consumption does not grow over time/usage.\nIf you can write a shell script that demonstrates the leak, and describe\nhow you are verifying that such a leak exists, it would be useful.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/\n<https://github.com/%0b> nanomsg/nanomsg/issues/797#issuecomment-243194933>, or mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/\nASTiuqTnRaN14Q4izltaZI660i8BR-Vsks5qkxg4gaJpZM4JtcKm>.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243196547,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfe2BXb-tpNCdUf2P_POa9zGGpl8Lks5qkxl_gaJpZM4JtcKm\n.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243253960, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiuvP8PwWs_TxtKTLewrv3tVVPsurEks5qk0f5gaJpZM4JtcKm.\n. Running 0.4beta right now, trying to get the build of v1.0.0 working (another developer).\nThe actual running processes don\u2019t do the wait, just the command line test encoders (for software unit test).\nFor all receives, I pass a pointer to a void ptr and size NN_MSG for it to allocate and then call the nn_freemsg to release the buffer.  Nothing is held from the buffer.\nI\u2019m using various sockets such as NN_Bus, NN_Pipe, NN_Sub.  NN_Sub is the only case of this problem.  Nothing else leaks.\nPerhaps this issue is fixed in V1.0.0?\nYes, I expect the filtering to be client side.  The question is, if every packet comes to the client, do I need a way to deallocate the ones that did not go through the subscription?  I am in the non-blocking mode, I read the socket down to empty to get a -1 on count.  The other topics don\u2019t come though the filter with subscription, so other than at your layer, how would one delete them?\nFrom: gdamore [mailto:notifications@github.com]\nSent: Monday, August 29, 2016 5:54 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nYour mental model is close to the right semantic, but absolutely wrong in terms of what happens under the hood.\nUnder the hood, every client subscriber receives every message (provided enough queue room exists), but the ones they aren't interested in are discarded (see the snippet from above in xsub.c) -- basically we do client side filtering rather than server side. (There are some really really strong reasons why we do it this way, and that's not going to change anytime soon.)\nA 50 ms delay after connect is typical -- this is because it takes time for all the setup in the underlying plumbing to be complete -- though it sounds excessive for IPC. (For TCP its typical.)\nI'm astonished you're seeing lots of leaked messages -- what version are you using? I've not been able to see that even while sending several hundred messages per second (both with discard of 90%, and no discarding) -- but this was with nanocat.\nIf you're allocating your own messages, you do need to be careful to make sure that you're not holding an extra reference to the message in your application. The best way to do this IMO is to use NN_MSG to ask for the framework to provide you with the message, which than can be tossed with nn_msg_term() once you are done with it.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243269277, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiujUf7XHnSK8HU-gy2BdACma-bUG2ks5qk1TkgaJpZM4JtcKm.\n. OK, we will get V1.0.0 running.  Our build of it ran into an issue during the nn_bind on a connection (I\u2019d have to look-up what protocol it was on).\nAt least it sounds like a root cause has been located, so I\u2019ll quit debugging my code and get the update running.\nI was trying to get some features/functions running when I ran into this, so I\u2019ll retest when we get on V1.0.0 and let you know.\nFrom: gdamore [mailto:notifications@github.com]\nSent: Monday, August 29, 2016 6:26 PM\nTo: nanomsg/nanomsg nanomsg@noreply.github.com\nCc: Bill McCroskey Bill.McCroskey@Crown.com; Author author@noreply.github.com\nSubject: Re: [nanomsg/nanomsg] Receiving up published messages (#797)\nThere was a known leak affecting xsub, which was fixed nearly two years ago: d265c74https://github.com/nanomsg/nanomsg/commit/d265c745977b273fcb219c529a3b6874e8ae1d67\nThis leak did exist in 0.4. So yes, you need to update. Until you do that, I'm not going to spend more time on this. (0.4 was released in January of 2014!!)\nThat said, you obviously have no way to handle messages you don't receive, nor are you expected to. The library should take care of them for you. If there is indeed a verifiable leak happening in new code, that would be a bug. I've not been able to see such behavior.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/nanomsg/nanomsg/issues/797#issuecomment-243276644, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ASTiumOaSj6PbvmeIjL9RSZnZ7w-nxIRks5qk1xygaJpZM4JtcKm.\n. ",
    "Chasx": "Ok, and what is the best way to fix this? I tried the first example (pipeline) on http://tim.dysinger.net/posts/2013-09-16-getting-started-with-nanomsg.html and this also shows the problem when starting a couple of 'node1's'. Would it suffice to just add a 'sleep' before 'return nn_shutdown (sock, 0);' or is there a better way?\nEdit: and does 'inproc' linger?\n. ",
    "Crest": "Deleting a (ident, filter) pair from a kqueue can't fail if the (ident, filter) pair has been registered with the kqueue.\nA kevent(2) call can't block if the eventlist is NULL. The call can only be interrupted if the eventlist not NULL. Even if kevent(2) is interrupted by a signal the changelist ist processed before the signal handler is called.  This can be confusing because most system calls require the exact same arguments to retry the system call after EINTR while kevent(2) expects the caller to provide an empty change list to retry only the blocking part after of the kevent(2) call was interrupted by a signal.\n. Kqueue supports disabling and (re-)enabling events on a queue without allocating resources (it just toggles a flag in the already allocated structure tracking the event inside the kernel). That way an application can (temporarily) disable an event source without risking failure e.g. if you accept(2) an incoming connection on a socket and the protocol requires the server to receive first you register both filters (EVFILT_READ and EVFILT_WRITE) on the new socket but disable the write filter until you have something to send. That way you fail early and there is no need to handle allocation errors in the rest of the API.\n. Nanomsg doesn't have to worry about FreeBSD < 10.0 because FreeBSD 9.3 is the only still supported FreeBSD release without accept4() and it will reach EoL status by the end of this year. It would be nice of nanomsg to compile (and work) on FreeBSD 9.3 until than because it simplifies my life as port maintainer.\n. FreeBSD doesn't claim to have accept4() unless it has a working accept4().\n. @gdamore: Thank you. BSD sytle(9) code is much easier to read even if it breaks git blame.\n. Yes you're missing something. The nanomsg design implements a set of common communication patterns. A general rule of thumb is that applications shouldn't create new nanomsg sockets after they're initialised. Of course the nanomsg library creates multiple TCP or unix domain sockets at runtime to implement the abstraction offered by the nanomsg sockets.\nUsing multiple nanomsg sockets can simplify you application logic, but it forces you to use multiple ports/paths for your bound sockets or use the experimental WebSocket transport which multiplexes multiple nanomsg sockets through a single TCP port.\nIf all communication is initiated by the client a single REP socket in the server is enough. You can either authenticate every request or perform a (multistage) handshake e.g. provide the client with a HMAC protected token. I would separate the session management into its own service.\nIf you need a backchannel from your server to the client things get messier. A common solution is a PUB socket in the server but iirc nanomsg doesn't filter subscriptions in the server. And workarounds like long-poll requests don't work with the stateful REQ-REP socket abstraction. This a limitation of the nanomsg implementation. The REQ-REP scalability protocol could handle this long poll requests, but would require application support in the form of timeouts and retires creating some traffic to keep all the buggy middleboxes encountered on the internet happy.\n. ",
    "har07": "Hi Garrett, Thx for the fast response.. anyway.. the nanomsg 0.9 installer had an error, there are no file glock.c and glock.h in the src/utils/ so i use the 0.8 version which still have those files.. probably need to update the 0.9 installer..\nthe pkg_config_path i resolve with add the environment variable after the 0.8 installation success.. running like a charm..\nYeah, i will consider to use mangos.. thx a lot!\n. Hi Garrett,\nI try to do the cmake build as suggested.. run ldconfig still not solve the problem.. i found that the 0.8 build create files in /usr/local/lib and the 0.9 cmake create /usr/local/lib/x86_64-linux-gnu/ so i copy the file from dir x86_64.. to .. and copy & rename the x86.../pkgconfig/nanomsg.pc to ../pkgconfig/libnanomsg.pc..\n. ",
    "farell": "thanks a lot!\n. ",
    "etosan": "Just confirming, it now works on my dash based, and FreeBSD  systems. Great job. Thanks! \n. ",
    "sailfish009": "Hi, i had same problem, solved it by follow.\n////////////////////// sample.cpp +25\ninclude \"../include/nn.h\"\ninclude \"../include/pair.h\"\ninclude \"../include/utils/attr.h\"\ninclude \"../include/utils/err.h\"\ninclude \"../include/utils/thread.h\"\ninclude stddef.h\ninclude assert.h\ninclude stdlib.h\ninclude string.h\npragma comment(lib,\"nanomsg.lib\")\npragma comment(lib,\"Ws2_32.lib\")\npragma comment(lib,\"wsock32.lib\")\n//////////////////////nn.h +366\nif 1\n//static\nint nn_socket(int domain, int protocol);\nint nn_close(int s);\nint nn_setsockopt(int s, int level, int option, const void optval,\n  size_t optvallen);\nint nn_getsockopt(int s, int level, int option, void optval,\n  size_t optvallen);\nint nn_bind(int s, const char addr);\nint nn_connect(int s, const char addr);\nint nn_shutdown(int s, int how);\nint nn_send(int s, const void buf, size_t len, int flags);\nint nn_recv(int s, void buf, size_t len, int flags);\nint nn_sendmsg(int s, const struct nn_msghdr msghdr, int flags);\nint nn_recvmsg(int s, struct nn_msghdr *msghdr, int flags);\ninclude \"utils/thread.h\"\n//typedef void (nn_thread_routine)(void);\n//void nn_thread_init(struct nn_thread self, nn_thread_routine routine, void arg);\n//void nn_thread_term(struct nn_thread *self);\nstruct nn_stopwatch {\n  uint64_t start;\n};\nvoid nn_stopwatch_init(struct nn_stopwatch self);\nuint64_t nn_stopwatch_term(struct nn_stopwatch self);\nelse\n// shared\nNN_EXPORT int nn_socket (int domain, int protocol);\nNN_EXPORT int nn_close (int s);\nNN_EXPORT int nn_setsockopt (int s, int level, int option, const void optval,\n    size_t optvallen);\nNN_EXPORT int nn_getsockopt (int s, int level, int option, void optval,\n    size_t optvallen);\nNN_EXPORT int nn_bind (int s, const char addr);\nNN_EXPORT int nn_connect (int s, const char addr);\nNN_EXPORT int nn_shutdown (int s, int how);\nNN_EXPORT int nn_send (int s, const void buf, size_t len, int flags);\nNN_EXPORT int nn_recv (int s, void buf, size_t len, int flags);\nNN_EXPORT int nn_sendmsg (int s, const struct nn_msghdr msghdr, int flags);\nNN_EXPORT int nn_recvmsg (int s, struct nn_msghdr *msghdr, int flags);\nendif\n//////////////////////global.c +986\nvoid nn_stopwatch_init(struct nn_stopwatch *self)\n{\n  LARGE_INTEGER time;\nQueryPerformanceCounter(&time);\n  self->start = (uint64_t)(time.QuadPart);\n}\nuint64_t nn_stopwatch_term(struct nn_stopwatch *self)\n{\n  LARGE_INTEGER tps;\n  LARGE_INTEGER time;\nQueryPerformanceFrequency(&tps);\n  QueryPerformanceCounter(&time);\n  return (uint64_t)((time.QuadPart - self->start) * 1000000 / tps.QuadPart);\n}\n. today, i rebuilt nanomsg with follow modification.\ninclude \"utils/thread.h\"\n//typedef void (nn_thread_routine)(void);\n//void nn_thread_init(struct nn_thread self, nn_thread_routine routine, void arg);\n//void nn_thread_term(struct nn_thread *self);\n. snip.\n. My mistake.\nreimplementation code works fine!\nsorry for the waste your time.\n. ",
    "flyingdove": "just add NN_STATIC_LIB in preprocessor flags in your project. ",
    "Cthutu": "It's super complicated, hard to maintain and doesn't work well with non-cmake projects.  It's also a confusing build system to use.  We use premake for our projects.  I am considering removing nanomsg and replacing it with boost::asio just purely because I can integrate the source code into our build environment more easily.\nThe reason I updated in the first place because the version I was using had a bug where nn_recv returned EAGAIN in blocking mode (contradicting the documentation) and not ETIMEDOUT.  I was hoping the latest might have fixed that but now I can't even compile it.\n. Yes, thank you.  I realised this eventually.  It would be nice if\nplatform-specific files were in different directories (e.g. posix, windows).\nOn Tue, 21 Jun 2016 at 02:13 Bent Cardan notifications@github.com wrote:\n\nyea i wouldn't even try to add poller.c to the list of files for\ncompiling on windows\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/767#issuecomment-227349659,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAVRxt5rr4R4kXeIzpRSLF3HHADE8vrSks5qN4D5gaJpZM4I0c-K\n.\n. \n",
    "forrestthewoods": "Making a library as easy to use as possible is definitely a responsibility of a library! The easier a library is to integrate into existing projects that have existing build pipelines the more the library will be used.\nLook at SQLite. The amalgamated source code is literally four files. One of them 6.9 megabytes large and 197,000 lines long. But it's very, very easy to drag and drop into any existing codebase no matter what build system it uses.\nNanomsg doesn't have to go so far as to amalgamate. But it is tedious to add to an existing project. Especially if that project is cross platform. Nanomsg isn't inherently complex. It's make system isn't that complex either. But it does generate projects in such a way that makes adding nanomsg source code into an existing build pipeline unnecessarily tedious. (In my opinion.)\n. For reference my background is video games. When often means a Windows dev environment targeting release on PC (Win/Mac/Linux) and/or console (Xbox, Playstation, Nintendo) and/or mobile (iOS, Android). Which means my line of thinking is often from a very different perspective than much of the open source community. (An often times wrong or under-informed perspective! But one sometimes worth 2 cents.)\n\ndirect inclusion in SOURCE form into other projects is not a design goal.\n\nSure. My personal belief is to always include all dependencies. Tracking down dependencies can be a colossal pain in the ass. Particularly when working outside of a Linuxy ecosystem. \nFor things to \"just work\" it's best to include everything a project needs in that project.\n\nConsider why cmake was made in the first place: to provide a platform-agnostic build system whose main goal is to define a consistent lifecycle that checks, builds, and tests.\n\nI wholeheartedly agree. I'm not suggesting cmake be removed from nanomsg. But I am saying that developers who use nanomsg have their own platform-agnostic build systems which define checks, builds, and tests. A good citizen expects that it will be integrated into other systems and doesn't make that more complicated than necessary.\n\nany kind of ability to just drop in source (eg via a single C file) would either require a script to build a platform specific version of that C file or for the user to provide definitions explicitly instead of auto generating them.\n\nI would most definitely NOT generate platform specific C files. I would enable users to drop in source and provide definitions explicitly. That doesn't mean force them to. Most current users of nanomsg are probably quite content with cmake. Great! But many potential users might prefer to drop source into their pre-existing build pipelines and feed in the appropriate defines.\nI don't think nanomsg is far off from supporting this. It's actually quite close! To compile full source on Windows in a freshly created Visual Studio project only a few steps are required. Add a few defines, link an extra pair of windows libs, and delete poller.c.\nIf poller.c were appropriately wrapped with defines then all a source drop would need is defines and lib links (on windows). Files such as worker_posix.h aren't a problem as worker.c is already define switched by platform.\nAn amalgamated file would potentially \"just work\" pending other conflicts. I've not tried to produce one yet. I've also not tried to compile a full source drop on non-windows platforms. They may need one or two define switches similar to poller.c.\nIn summary, Nanomsg is very close to supporting direct inclusion. It may also be very close to supporting amalgamation. I personally believe that both of these things are worth supporting because it enables more developers to more easily use Nanomsg on more projects.\n. User error.\nMy code had a bind/connect mismatch. The demo code had a timing error. Sleep(1) isn't enough for Windows batch. \nSorry for wasting your time.\n. ",
    "takuyozora": "Because it wasn't the right way to fix it, I get lot of invalid read now. I think that it a part of the structure is used later (by a fsm event reaction I guess) so it can't be freed to soon, but it isn't freed at all if we don't change anything.\nI've opened an issue : #774\n. It seems that the same problem occurs when a socket fail to connect.\nc\nint rc = nn_connect(socket, \"tcp://8.8.8.8:8888\"); // Or whatever address which is unable\nassert(rc < 0);\nnn_close(socket);\nResult : \nc\n26: ==14349== 2,496 bytes in 1 blocks are definitely lost in loss record 28 of 29\n26: ==14349==    at 0x4C29BBE: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n26: ==14349==    by 0x5985562: nn_alloc_ (in /usr/lib/libnanomsg.so.0969988-dirty)\n26: ==14349==    by 0x599ED46: nn_ctcp_create (in /usr/lib/libnanomsg.so.0969988-dirty)\n26: ==14349==    by 0x59A1A42: nn_tcp_connect (in /usr/lib/libnanomsg.so.0969988-dirty)\n26: ==14349==    by 0x5979869: nn_ep_init (in /usr/lib/libnanomsg.so.0969988-dirty)\n26: ==14349==    by 0x597E111: nn_sock_add_ep (in /usr/lib/libnanomsg.so.0969988-dirty)\n26: ==14349==    by 0x597BFE2: nn_global_create_ep (in /usr/lib/libnanomsg.so.0969988-dirty)\n26: ==14349==    by 0x597AF94: nn_connect (in /usr/lib/libnanomsg.so.0969988-dirty)\n...\n. Fixed by #852, issue can be closed. I really think that it's the 1.0 version : https://www.archlinux.org/packages/community/x86_64/nanomsg/\n. Ok for this one ! Thank you.\nc\n10: ==15945== HEAP SUMMARY:\n10: ==15945==     in use at exit: 1,144 bytes in 21 blocks\n10: ==15945==   total heap usage: 286 allocs, 265 frees, 83,078 bytes allocated\n10: ==15945== \n10: ==15945== LEAK SUMMARY:\n10: ==15945==    definitely lost: 0 bytes in 0 blocks\n10: ==15945==    indirectly lost: 0 bytes in 0 blocks\n10: ==15945==      possibly lost: 0 bytes in 0 blocks\n10: ==15945==    still reachable: 1,144 bytes in 21 blocks\n10: ==15945==         suppressed: 0 bytes in 0 blocks\nHave you fix the #774 ? (Yes, I hate memory leaks)\n. I confirm that the PR fix my issue #774\nThanks for that !. ",
    "hwanren": "I think the cppcheck report matches with the valgrind report w.r.t. nn_alloc_:\n\n\n\n. ",
    "Parakleta": "I thought about it some more and as the simplest solution I have just changed the hdrsize = nn_chunk_hdrsize() to use instead the difference (uint8_t*)*chunk - (uint8_t*)self and then when updating the chunk instead of nn_chunk_getdata(new_chunk) use instead (uint8_t*)new_chunk + hdrsize.\nThis is the simplest semantic correction but overlooks potential savings in consolidating the dead space, but then attempting to consolidate the dead space may turn out to be a case of premature optimisation if it's only ever small.\n. ",
    "sangli00": "I mean,nanomsg buffer can't take over all nn_send msg. if i send so much msg ,nn_recv can't first time dispose  this msg, I again send msg is error. but now, I think use multi thread dispose msg, nn_recv fast  clean buff and dispose msg.\n. ",
    "a4z": "good decision  @JackDunaway ,  you might also consider to rethink the API  ABI split, which is .. at least very special, and yes, I know about naming shemas, also tose from libtool.\nI also guess that changing the API without the ABI and vice versa is not even possible, \nbut anyway \nI think, if you want ever official packages of nanomsg see in distributions this version / abi mix needs to be fixed, \nthe so name must match the MAJOR.MINOR concept, than someone can make a rpm nanomsg-1_0\nthe pachlevel for binary compatible changes, \nso  nanomsg-1_0-0 will be updated with  nanomsg-1_0-1 if the ABI is compatible (which requires a compatible API),\nthe next package can than be nanomsg-1_1 (with a changed API that generates a new ABI) and be installed alongside the nanomsg-1_0\nas additional  reference:\nhttps://en.opensuse.org/openSUSE:Shared_library_packaging_policy\nI am pretty sure that package linter will reject nanomsg-1_0 with a soname 5.0.0, and this not just on openSUSE distros but also others that do those kind of checks.\n. Hi @JackDunaway and @Snaipe \nhere some additional info to this topic: \nthis is all availalbe public elsewhere also, but here as a summary.\nthe ABI number is relevant, you might want to update the library without require recompile all apps linked against.\nthis can be done as long as you are ABI compatible.\nthat is why the ABI number should be MAJOR.MINOR.\nand the library, with API number, is  MAJOR.MINOR.PATCH_LEVEL,\nwhere MAJOR.MINOR can stay the same as long as the API stays ABI comatible ,\nfor internal changes, that do not break the ABI, you assign a new PATCH_LEVEL.\nwhat means basically no changes in the public interface, simplified, otherwise, ABI compatibility is hard.\nNote: if you change public interface (API) and think you stay ABI compatible, use a checker, like http://lvc.github.io/abi-compliance-checker/ to ensure that you are.\nsome references/examples:\nhttps://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html\n(is c++ since I am more a C++ guy, look at the breaking changes and check the naming, note they use no minor numbers)\nor, an other example, \n/usr/lib/libsqlite3.so -> libsqlite3.so.0.8.6\nwith a SONAME libsqlite3.so.0\nand just an other sample from any random lib on my system\n```\ncyrus-sasl-lib-2.1.23-15.el6_6.2.i686 : Shared libraries needed by applications which use Cyrus SASL\nRepo        : local-rhel-i386-workstation-6\nMatched from:\nFilename    : /usr/lib/libsasl2.so.2.0.23\n```\nand\nobjdump -p /usr/lib/libsasl2.so.2.0.23 | grep SONAME\n  SONAME               libsasl2.so.2\nmake this for all libs on your system, do you find a pattern in MAJOR.MINOR.PATCH_LEVEL , MAJOR.MINOR and package names?\nNote that a lot of libraries do not care about MINOR numbers in fact, so theoretical 2 numbers, ABI_VERSION.IMPLEMENTATION_VERSION (to not use major/minor/..) could be enough, but major/minor/patch is used and gives more flexibility, the only decision you have to make is if you put minor into the ABI or not, this is handled individual by the software.\nAnd please note that I talk about Linux, BSD might have slightly adopted conventions in their usage, so possible this is why MINOR is often not in the ABI for a lot of packages, but I would have to look that up. \nin short, I would suggest:\n- use the naming as suggested and used by all other packages or something very similar, \n- fix the #define NN_VERSION_CURRENT since it has no meaning currently, you do not have that many ABI depended installations currently \n- stay as close to existing conventions to make the live of people that what to help, eg through building packages, as easy as possible.\nbut anyhow,\nI do not want to force you to do anything you absolutely do not want.\nso for me it is realy OK if you do however you want.\nBut there are criteria that needs to be satisfied if I package and use libraries, nanomsg does not fulfil this currently, some would say that is a bug, some would call it personal taste,  and if in doubt, I trust the package linter which works proven over years for thousands of packages ;-) \n. ",
    "majklik": "Yes, this diff is a bit stupid solution but opens the door for me at this moment and show the place of the problem in the source code. :-)\nI agree that correct way is parse the header parameters and looks for the \"upgrade\" keyword.\nWell, I looked on this part (nn_ws_handshake_parse_client_opening() ) and I\u00a7m seeing two next possible similar problematic points:\na) Upgrade: header\nThe client can include multiple values among which server can select. For example the client can send \"Upgrade: TLS/1.1, WebSocket\" to indicate in the place request for switching to wss. NanoMsg do not supports TLS now so correct reaction is to switch only to WS with \"Upgrade: websocket\" in actually implemented way.\nb) (a bit theoretic) Sec-WebSocket-Protocol: header\nAgain, the client can include multiple protocols and server select which accept and answer only with it. This can be used for detecting which type of nanomsg socket implement the server.\n. ",
    "jiazhang0": "Will fix the CI build failure in V2. Closed.\n. ",
    "kroggen": "Hi Garrett,\nI can't use it because my mini-pc has not enough disk space to compile it from source. I already tried it. apt-get don't work as it is an old linux release.\nI am currently using the nanomsg 0.8.\nBut I will try to use the autotools files from https://github.com/nanomsg/nanomsg/commit/cb127489776d17c9d289d6d68584b4edaa9348b0\nThank you for your response and the hard work on nanomsg.\n. Here is one idea:\nOne installer with 2 options:\nOption 1: For end-user\nIt installs just the nanomsg.dll in the Windows system folder. Nothing more.\nOption 2: For developers\nIt installs all the files in a selected folder, including:\nnanomsg.dll\nnanomsg.lib\nnn.h and other include files\nOne question we need to answer is if the shared library will depend on MSVCRT or not. Compiling with Visual Studio will make it depend on MSVCR100.DLL (or another version). I guess that using Visual Studio we cannot make it depend on MSVCRT.DLL, which is already shipped with all Windows. Maybe compiling with GCC.\nOr then make it stand-alone. It will be a bit bigger in size but no dependencies on a C run-time library.\nThe key is to make it useful for ourselves to have the library when we are using computers that do not have Visual Studio installed.\n. I was with the same doubt. Maybe it is not needed. Just an installer for developers would be sufficient.\n. Well, if we don't need to put the DLL into the system folder, then we don't even need an installer. Just the files in a zip folder would do the job.\n. And the build can be automated via AppVeyor to minimize future work on new releases.\nBut I don't know exactly how to configure the .appveyor.yml file to copy the compiled files to the GitHub releases. And it should be added a Release build as now there are only Debug builds there.\n. Hi!\nI am trying to implement it via AppVeyor but I can't make it to work.\nThe builds are here: https://ci.appveyor.com/project/kroggen/nanomsg\nMy forked config file is here\nI don't know how to produce binaries for both 32 and 64 bits using the cmake.\nAnd I cannot make AppVeyor create the artifact that it needs to upload to GitHub releases.\nI am reading the appveyor.yml reference\nAny ideas?\n. Thank you @Snaipe !  I will try.\n. Sorry guys, I give up!\nI cannot create a simple zip file and set as an artifact! It keeps showing errors with the variables.\nI hope you can continue this.\nCheck the changes I've made in the appveyor.yml file\nI tried :\ncmd: set archive = nanomsg-$(RELEASE_NAME)-windows-$(PLATFORM).zip\ncmd: echo \"%archive%\"\ncmd: 7z a \"%archive%\" nanomsg.dll nanomsg.lib src*.h\nAnd it does not work. I tried %archive% (without the quotes), \"$(archive)\", $(archive)... and no one worked...\nI also tried with PowerShell and got only errors...\nI cannot handle these variables.\n. Although the documentation describes the nn_errno() function on its own page, it does not encourage its usage on other pages.\nEven in the nn_strerror page it shows an usage without the nn_errno() function.\nI guess it could be: nn_strerror(nn_errno()) instead of nn_strerror(errno)\nOr am I missing something here?\nI know it is required just for Windows. So don't take this so seriously. Just a comment.\n. This is giving 404:\nhttp://nanomsg.org/v1.0.0/nn_term.3.html\n. Guys, I need to share this with you.\nI am the developer of litereplica and it uses nanomsg.\nWe (I and the litereplica users) were having errors going on and the debug showed that the problem was with nanomsg.\nIt occurred only with the TCP transport, not with IPC.\nAt some point the connection was broken and nanomsg did not made the reconnection. I could check it with netstat.\nA customer from a company was asking to remove the nanomsg because of this.\nOnly after dozen of days I realized the problem:\nThe sender was sending a message with a size of ~1.4MB and the nanomsg has a limit on the received message size (I did not know about this).\nI almost gave up and let nanomsg aside.\nSo here is my questions: should it have this limit as the default? If yes, what about having something wrote about this in the nn_send documentation page?\n. Thank you for the clarification!\n. But the 2 previous commands worked:\ncmake ..\ncmake --build .\nAnd your .travis.yml does not contain the suggested command for installation:\nsudo cmake --build . --target install\nIt was working on travis in the previous releases.. I found that it is related to this issue:\nhttps://github.com/travis-ci/travis-ci/issues/9113\nSo intead of\nsudo cmake --build . --target install\nwe must use\nsudo -E cmake --build . --target install\nor\nsudo env \"PATH=$PATH\" cmake --build . --target install\nBut only the last one worked.. ",
    "museghost": "Hi, could you check LD_LIBRARY_PATH indicates the library directory (i.e. /usr/local/xxxx) ?\nI assume that it was caused by the environment variable in your shell configuration.\n. If so, please set $LD_LIBRARY_PATH with the location where the libnanomsg.so.5.0.0 .\n. ",
    "jockchou": "[root@jockchou ~]# echo $LD_LIBRARY_PATH\nnothing!!!\n. Ok. I Get, Thank U...\n. ",
    "james-lawrence": "linger doesn't work with ipc (the operating systems don't support it!) -- and is never guaranteed in any event.\nthat is not what the documentation says at all though.\nNN_LINGER is documented as a generic socket level option which makes it not specific to a transport.\nsee: http://nanomsg.org/v1.0.0/nn_setsockopt.3.html\nSets the value of the 'option'. The 'level' argument specifies the protocol\nlevel at which the option resides. For generic socket-level options use\n_NN_SOL_SOCKET_ level. For socket-type-specific options use socket type\nfor 'level' argument (e.g. _NN_SUB_). For transport-specific options use ID of\nthe transport as the 'level' argument (e.g. _NN_TCP_).\nNN_LINGER also EXPLICITLY calls out close in its documentation.\nNN_LINGER\n    Specifies how long the socket should try to send pending outbound messages after nn_close() have been called, in milliseconds. Negative value means infinite linger. The type of the option is int. Default value is 1000 (1 second).\nthe issue is more the document says one thing, and the code base is doing the complete opposite. Its compounded by the fact I didn't find any reference to NN_LINGER actually being used within the code base. but I'll grant that may just be my infamiliarity with the code.\nso given that NN_LINGER is a generic socket option, and that it explicitly says on nn_close it'll wait for the specified time for a message to be delivered. The minimum I'd expect it to block and attempt the messages being sent until NN_LINGER is up or all messages are delivered.\nnn_connect() isn't guaranteed to have actually established a connection\nthis is kind of immaterial, I'd be fine if the connections were failing completely and it attempted to deliver the messages for the specified nn_linger period, but that isn't what is happening.\nBut better is simply not to close the socket -- opening and closing the socket for each message imparts quite a high per-message overhead, and is not a recommended pattern unless you have some one-shot use case.\nthats great and I agree but it has nothing to do with the issue.\nIf you want to be absolutely certain that your message was received by the other end, use REQ/REP\nI don't want to be absolutely certain, I want it to behave according to the specification.\nnote: I'm actually willing to put some of the effort into helping code this, though it'll be a slow burn as I have a few personal projects on my plate, and havent actively written any c code in years. =)\n. imo it should be removed from the general socket options long term then. since it doesn't apply to them all. though likely that will be a painful thing to do since its already been exposed.\n. =) said that a couple times now. =P I've been looking as well. heh\n. I don't believe that is true unless nanomsg queues messages... just because transport 'could' support it doesn't mean they ever will. as a result i'd agrue it shouldn't be exposed as a general option unless its an activate goal of nanomsg to get every transport to support it. but anyways thats a detail, and as long as the documentation is clear about the limitations I don't particularly care. I was more annoyed I used it expecting behaviour as documented only to find the exact opposite. =)\n. It is a programmer error to rely upon linger actually doing anything\nthen it is the most pointless option ever and should be removed, if a programmer can't even rely on it to keep attempting to deliver the message within the provided window (per documentation). =)\n. ",
    "mrhubbs": "An arm 7 (cortex a8 processor), using GNU tools and libraries.\n. I'm sorry, can't see the forest for the trees.  Linux. Kernel version 2.6.  It's an embedded system.\n. Yes. I would not have expected that. I verified that errno was set to not implemented after the accept4 call.  Googling \"accept4 not implemented\" returns a number of hits. Here is one: http://lists.busybox.net/pipermail/uclibc-cvs/2011-September/029878.html\nThe system I'm working on uses busybox. I'm not sure if that makes a difference.\n. ",
    "crayfishuk": "It's dependent on asciidoctor being installed. If you uninstall it, it won't try to build the docs.\n. ",
    "ichilver": "It's installed via apt-get from archive.ubunutu.com, trusty repository.\nRunning asciidoctor --version says its 0.1.4\n. apt-get upgrade\napt-get upgrade-dist\nStill running version 0.1.4 on Ubuntu 14.04\n. ",
    "jdowner": "Just wanted to leave some information here for anyone else who encounters this problem. I am on ubuntu 14.04 and nanomsg isn't a package that I can install directory from apt-get. So I have added it as a submodule of the project I am working on. To disable the documentation from running by default, I added,\nset(NN_ENABLE_DOC Off CACHE INTERNAL \"\")\nadd_subdirectory(nanomsg)\nto the top-level CMakeLists.txt.. ",
    "mdcb": "Ok!\n. ",
    "zwxf": "@gdamore Hi:\n    From you comment, i found Pair is peer 2 peer, if i want a peer connect to multi peer does means need multi thread? any another ways to achieve star-like topology?\n    Best regard!\n. OOK\uff0cIt seems works, but leafs should bind a address and hub should connect to all leafs, so if i want add more leafs should compile the hub again(can not sepatate two part individually),may be NNG is a good choice, otherwise my code is running in the embeded system(IXM6UL linux platform), So NNG may be a good chioce, Last question, is NNG Stable enough for now?\n    thanks! hopefor you reply. . ",
    "bizzard4": "I can reproduce very easily on my VM using Ubuntu 16.04 same on my t2.small Amazon Ubuntu machine.\nNow if I add a small sleep(1) just before shutdown it seem to make thing work. That would fit with what you said, because my process was exiting just after sending. I can use this as a temporary workaround for my measurement. \nIn a real scenario, I guess it would be possible to implement a simple solution to that.\n. Also, my code using only Unix domain socket work properly. The only difference is that the socket is created using blocking. While in nanomsg socket is created non-blocking.\n. ",
    "edufschmidt": "Thanks for the quick reply! We are looking forward to this new design, and are eager to help on any specific task you have on this direction. Meanwhile, I guess we'll stick with our implementation using nn_poll, which is available in the Tangle repo in case you wanna take a peek at it. I think the issue can be closed now :)\n. ",
    "kuncao": "now device infor is \nint s1 = nn_socket (AF_SP_RAW, NN_REQ);\nnn_bind (s1, \"tcp://10.120.229.120:5555\");\nint s2 = nn_socket (AF_SP_RAW, NN_REP);\nnn_bind (s2, \"tcp://10.120.229.120:5556\");\nint sd=nn_device (s1, s2);\nserver \nint s =nn_socket(AF_SP, NN_REP),\nnn_connect(s,\"tcp://10.120.229.120:5555\")\nclient deployed on 10.120.93.142\nint s =nn_socket(AF_SP, NN_REQ),\nnn_connect(s,\"tcp://10.120.229.120:5556\")\nthe client send message can cannot receive reply from server\n. the following codes could run:\ndevice:\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nvoid OnExit(int sig)\n{\n    std::cerr << \"Exiting on ^C \" << sig << std::endl;\n}\nint main(int argc, char *argv[])\n{     \nint s1 = nn_socket (AF_SP_RAW, NN_REP);\nstd::cerr << \"s1 value is : \" << s1<< std::endl;\nnn_bind (s1, \"tcp://10.120.96.194:5555\");\nint s2 = nn_socket (AF_SP_RAW, NN_REQ);\nstd::cerr << \"s2 value is : \" << s2<< std::endl;\nnn_bind (s2, \"tcp://10.120.96.194:5556\");\nint sd=nn_device (s1, s2);\nstd::cerr << \"after nn_device init : \" << sd<< std::endl;\n    //return 0;\n}\nserver:\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nint main(int argc, char argv[])\n{ \n   int sz_msg = sizeof(\"world\") + 1; \n   int sock = nn_socket(AF_SP, NN_REP); \n   int endid=nn_connect(sock,\"tcp://10.120.96.194:5556\"); \n while (1) \n   {\n    char buf = NULL;\n    int bytes = nn_recv (sock, &buf, NN_MSG, 0);\n    int sz_d = sizeof(\"world with device\") + 1; \n     bytes = nn_send(sock,\"worldi with device\", sz_d, 0);\n    nn_freemsg (buf);\n    }\n   nn_shutdown (sock, endid);\n   nn_close(sock);\n }\nclient:\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nvoid OnExit(int sig)\n{\n        std::cerr << \"Exiting on ^C \" << sig << std::endl;\n}\nint main(int argc, char argv[])\n{     \n  int sz_string = sizeof(\"hellojack\") + 1; // \n  char buf = NULL;\n  int bytes = -1; \n  int sock = nn_socket (AF_SP, NN_REQ);\n  //assert (sock >= 0);\n  int endid=nn_connect (sock,\"tcp://10.120.96.194:5555\") ;\n   bytes = nn_send (sock, \"hellojack\", sz_string, 0);\n   bytes = nn_recv (sock, &buf, NN_MSG, 0); \n  std::cerr << \"client recieve data is : \" << buf<< std::endl;\n   nn_freemsg (buf);\n   nn_shutdown (sock, endid);\n   nn_close (sock);\n}. thanks  gdamore.. your device is exiting main.  you need to pause there without exiting.  pause() is a good unix function for this.\n\nI add pause in my c++  code,but it seem  to I have to use control +c twice to shutdown device,without pause(),only once  control +c to shutown the device.\n-------------------with pause()test begin --------------------------------\nszv1000082629:/home/nanoprorpc/nanorpc # ./device_server\ns1 value is : 0\ns2 value is : 1\n^CExiting on ^C control c\nafter nn_device init : -1\nafdadf\nadfsasdf\nwd\n  ddd\n^CExiting on ^C control c\n-------------------with pause() test end--------------------------------\nafdadf and other letters is to verify the device can be shutdown after pause()\n-------------------without pause() test begin--------------------------------szv1000082629:/home/nanoprorpc/nanorpc # ./device_server\ns1 value is : 0\ns2 value is : 1\n^CExiting on ^C control c\nafter nn_device init : -1\n-------------------without pause() test end--------------------------------\nmy code:\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nvoid OnExit(int sig)\n{\n        nn_term();//this is added by jackcao at 20161123\n                  // to term the socket s1 s2 \n                  //and may term other socket created by nanomsg in this server\n        std::cerr << \"Exiting on ^C \" << \"control c\" << std::endl;\n}\nint main(int argc, char *argv[])\n{\nsignal(SIGINT, OnExit);     \nint s1 = nn_socket (AF_SP_RAW, NN_REP);\nstd::cerr << \"s1 value is : \" << s1<< std::endl;\nnn_bind (s1, \"tcp://10.120.229.120:5555\");\nint s2 = nn_socket (AF_SP_RAW, NN_REQ);\nstd::cerr << \"s2 value is : \" << s2<< std::endl;\nnn_bind (s2, \"tcp://10.120.229.120:5556\");\nint sd=nn_device (s1, s2);\nstd::cerr << \"after nn_device init : \" << sd<< std::endl;\n//pause();\nreturn 0;\n}. ",
    "florint1": "This seems to have been addressed before in https://github.com/nanomsg/nanomsg/issues/770\nWindows users need to execute \"ctest -C Debug .\" instead of \"ctest -G Debug .\"\nREADME file should probably be updated to include this distinction!. ",
    "andrew-buckley": "Great, thanks. Hi @gdamore, just wanted to check if this is still on track to be checked in. \nThanks again. . @damonbarry if you would also like to see the status of this. ",
    "clearday4": "I found that nn_allocmsg() is called again after nn_send().\nclose the issue ^^. We are testing on x86_64 Redhat linux. \nAnd the nanomsg document mentioned that the NN_IPV4ONLY option can be used for both IPv4 nad IPv6 address.\nThe url we used for the test is :\n\"tcp://172.190.0.3:21584\"\nWe disabled the NN_IPV4ONLY option and try to nn_connect with IPv4 address.\n. The problem is to disable IPV4_ONLY option for using a dual stack,\nAssertion occurs at nn_send after IPv4 address connect.\nAn assertion should not occur at this time.\nIt is critical issue that may affect the other users, therefore please consider urgent patch.\n. ",
    "Tangerino": "Thanks.\nAll threads quit without problem.\nThe device itself does not.\nThat\u2019s the reason I\u2019ve called nn_term.\nAre you telling me that if all other sockets get closed, the devices will return?\nCarlos\nOn Dec 12, 2016, 10:38 +0100, gdamore notifications@github.com, wrote:\n\nI'd avoid using nn_term() actually. If you're going to just exit, then just do so.\nnn_term tries to drain sockets, and so forth, and it may have errors in this situation with nn_device(). I can look at it later, but its not a huge priority for me. Its much preferable for callers to keep track of their sockets, and directly close those sockets...\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Without the use of nn_term I get this\n\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_mvmsg+0xed)[0x7f0ef2386319]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_oneway+0x29)[0x7f0ef2386214]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_entry+0xa6d)[0x7f0ef2385edc]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_custom_device+0x2a)[0x7f0ef2385444]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device+0x27)[0x7f0ef238546d]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x4e84fe]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x40ff3b]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x408ea4]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f0ef1dad830]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x4078b9]\nInterrupted system call [4] (/home/carlos/Desktop/projects/nanomsg/src/devices/device.c:299)\nRUN FINISHED; Aborted; core dumped; real time: 3s; user: 0ms; system: 10ms\n. This is my code.\nThe other threads have no time to close anything, they just die.\nThe nn_device never returns\nvoid broker(void) {\n\u00a0 \u00a0 log(\"%s\", \"Broker thread running\");\n\u00a0 \u00a0 int to = _newDeviceSocket(AF_SP_RAW, NN_PUB, subPort);\n\u00a0 \u00a0 if (to >= 0) {\n\u00a0 \u00a0 \u00a0 \u00a0 int from = _newDeviceSocket(AF_SP_RAW, NN_SUB, pubPort);\n\u00a0 \u00a0 \u00a0 \u00a0 if (from >= 0) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log(\"%s\", \"Broker thread active\");\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int rc = nn_device(from, to);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log(\"%s\", \"Broker is quiting\");\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (rc == -1) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 rc = nn_errno();\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (rc != EBADF) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log(\"Broker is quiting - %s\", nn_strerror(nn_errno()));\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 nn_close(from);\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 \u00a0 \u00a0 nn_close(to);\n\u00a0 \u00a0 }\n\u00a0 \u00a0 dipLog(\"%s\", \"Broker thread ended\");\n}\nCarlos\nOn Dec 12, 2016, 21:33 +0100, gdamore notifications@github.com, wrote:\n\nThis is weird. nn_device() starts a thread that runs. I\u2019m not sure why\nyou\u2019d get a panic. Are you just calling exit()? or is there something\nelse going on here?\nYou should be able to close either socket used with nn_device and have the\nwhole thing shut down. (You should probably close both sockets). This\nshould work even without nn_term().\nOn Mon, Dec 12, 2016 at 8:38 AM, Carlos Tangerino notifications@github.com\nwrote:\n\nWithout the use of nn_term I get this\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_mvmsg+0xed)[0x7f0ef2386319]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_oneway+0x29)[0x7f0ef2386214]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_entry+0xa6d)[0x7f0ef2385edc]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_custom_device+0x2a)[0x7f0ef2385444]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device+0x27)[0x7f0ef238546d]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x4e84fe]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x40ff3b]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x408ea4]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f0ef1dad830]\n/home/carlos/Desktop/projects/dipapp/dist/Debug/GNU-Linux/dipapp[0x4078b9]\nInterrupted system call [4] (/home/carlos/Desktop/\nprojects/nanomsg/src/devices/device.c:299)\nRUN FINISHED; Aborted; core dumped; real time: 3s; user: 0ms; system: 10ms\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/854#issuecomment-266480286,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABPDfXj9eRj8kBYfwlpuTPpivZw8lcrzks5rHXiVgaJpZM4LKJnr\n.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I tried also to call nn_close from outside and it also blocks and do not return, nothing helps.\nI may have more information on the path for the error. After running valgring I got this\n\n\n[N] 14 13:52:34 (src/rest.c/restd:247) Rest Server thread ended\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_mvmsg+0xed)[0x5a57319]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_oneway+0x29)[0x5a57214]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device_entry+0xa6d)[0x5a56edc]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_custom_device+0x2a)[0x5a56444]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_device+0x27)[0x5a5646d]\n./dist/Debug/GNU-Linux/dipapp[0x4ebd4d]\n./dist/Debug/GNU-Linux/dipapp[0x413778]\n./dist/Debug/GNU-Linux/dipapp[0x408f39]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x5ebe830]\n./dist/Debug/GNU-Linux/dipapp[0x4078b9]\nInterrupted system call [4] (/home/carlos/Desktop/projects/nanomsg/src/devices/device.c:299)\n==52761== \n==52761== Process terminating with default action of signal 6 (SIGABRT)\n==52761==    at 0x5ED3428: raise (raise.c:54)\n==52761==    by 0x5ED5029: abort (abort.c:89)\n==52761==    by 0x5A541DA: nn_err_abort (in /usr/local/lib/libnanomsg.so.5.0.0)\n==52761==    by 0x5A57374: nn_device_mvmsg (in /usr/local/lib/libnanomsg.so.5.0.0)\n==52761==    by 0x5A57213: nn_device_oneway (in /usr/local/lib/libnanomsg.so.5.0.0)\n==52761==    by 0x5A56EDB: nn_device_entry (in /usr/local/lib/libnanomsg.so.5.0.0)\n==52761==    by 0x5A56443: nn_custom_device (in /usr/local/lib/libnanomsg.so.5.0.0)\n==52761==    by 0x5A5646C: nn_device (in /usr/local/lib/libnanomsg.so.5.0.0)\n==52761==    by 0x4EBD4C: internalBrokerThread (broker.c:199)\n==52761==    by 0x413777: dipBrokerRun (dip.c:368)\n==52761==    by 0x408F38: main (dipapp.c:98)\n. Hey, does this problem will be handled?. No update on many threads, Is this repo dead?. ",
    "martinlindhe": "Okay, a documented usage of nmake would also be of interest.. ",
    "batitous": "Thanks for your support, I will read the RFCs and include the necessary backtrace on REQ/REP socket: \nIs the file \"nanomsg/src/protocols/reqrep/req.c\" can help me to understand the request id and extra headers needed on REQ / REP ?\n(Sorry about the empty zip file)\nIssue closed, all informations is on the RFCs !. ",
    "scubadriver": "agree with crule42 and second comment of gdamore. Abort is a killer. Imagine Apache or Firefox aborts on connection failures or timeouts.\nAs for asserts, in Windows dev world for example, ASSERT usually a DEBUG build feature and in release builds it is NoOp.\nSo, even there is an assert(), the next line usually (unless you super tired at 5am) an if() statement checking the error and return whatever error.\nMy 2c anyway.\n. ",
    "bill1600": "Sorry.  Tests passed in my environment (Fedora 19).\n. Will resubmit later.. Don't commit this.  I just need to use travis to test.. Tests pass.  This is ready to be merged now.. OK. I will remove the debug.. Removed debug. Should be able to merge now.. OK, I undertand.\nI will clean it up a resubmit as a new PR.. Will resubmit clean.. Our plan was to transition to NNG at some point.\nI could keep delving into the issue on the legacy version, but maybe the smarter way of spending my time is to try out NNG immediately in compatibility mode.. ",
    "crule42": "[shrug]  It's your repo. \nI have a requirement to run Visual Studio 2008 and wanted to use the library. Thought others might want the capability also. \nAs far as simply copying stdint.h to the Visual Studio directory, that's fine for a one-off machine, but having to remember to constantly do that for new machines is not worth the hassle when it can be accomplished as part of a self-contained library.  The way this was implemented it also compiles fine under linux.\nVisual Studio 2012 is not free. It's only free for non-commercial use which is not my case.\nI can remove the pull request if that's what you want. Just let me know.. ",
    "deepakprabhakara": "Thanks @gdamore. I am using nanomsg 1.0, however I am not seeing this anymore so not sure if I can get a predictable test to reproduce it. Will post back if I progress further on this.. Excellent, thank you.. ",
    "g19fanatic": "Provide a patch here... #873 . ",
    "seschwar": "In the meantime you could link to web.archive.org's copy of the article.. ",
    "thisco-de": "Sorry, can you please be a little more specific on what you mean by saying \"unconditionally\"? Perhaps the context from which I am looking at this piece of code it is a bit to narrow, but as far as I understand it, the tag as well as the pointed to address get copied to dest. By setting the tag (resp. u.ref[0]) to 0, this semantically would be equivalent to \"there is no data\", shouldn't it? nn_chunkref_getchunk does exactly the same thing.. I really have to say I am sorry for not giving any answers on this issue, as I first became too busy writing the project I based on nanomsg during the first half of the year and had a lot of other things in mind during the last week.\nHowever, as far as I remember, it was exactly the semantic meaning of 'mv', which caused me some headache while implementing my project, until I digged deeper into the implementation after getting your feedback. I cannot really tell anymore, how I circumvented the problems I had while implementing the protocol for my project (you are right, nn_msg_msg() is not in the public interface, but you have to deal with it, when writing new protocols).\nSoon I also noticed your re-implementation of nanomsg in nng, hence the issue was already of the table from my anyway. Hence, thanks for taking the time to research the issue and give me feedback. Looking forward to use nng in my projects some day! :+1: . Simply think of two indepentent components where one has to check whether the other has already attached data to it or not. For the sake of a concrete example, take an implementation of a transport that might conditionally attach data or not (resp. different transport, such that some attach data others do not) and the protocol has to check for this. The TCP transport, for instance, does not nullify the data member after initialization (cf. nn_stcp_init), which - according to your argumentation - it should, if I got you right. However, I do not see the point in not describing the state of the object explicitly/accurately at initialization time (i.e. there is no data attached) and by this taking potentially error-prone assumptions out of the game entirely. For what reason? To save a single instruction?. ",
    "SG7": "I have the following setup: \n macOS Sierra \n Version 10.12.5\niMac (27-inch, Mid 2010)\n  Model Name:   iMac\n  Model Identifier: iMac11,3\n  Processor Name:   Intel Core i7\n  Processor Speed:  2.93 GHz\n  Number of Processors: 1\n  Total Number of Cores:    4\n  L2 Cache (per Core):  256 KB\n  L3 Cache: 8 MB\n  Memory:   16 GB\n  Processor Interconnect Speed: 4.8 GT/s\nDeveloper Tools:\n  Version:  8.3.3 (8E3004b)\n  Location: /Applications/Xcode.app\n  Applications:\n  Xcode:    8.3.3 (12175.1)\n  Instruments:  8.3.3 (62125)\nI followed the installation procedure. \nThese are some more relevant results:\n1) compilation went well\n-- The C compiler identification is AppleClang 8.1.0.8020042\n-- Check for working C compiler: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc\n-- Check for working C compiler: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc -- works\nWith only one warning:\n[ 47%] Building C object src/CMakeFiles/nanomsg.dir/transports/ws/sws.c.o\n/Users/SG/Documents/code/TTC/nanomsg/nanomsg-master/src/transports/ws/sws.c:782:51: warning: implicit conversion from 'int' to 'char' changes value from 136 to -120\n      [-Wconstant-conversion]\n    self->fail_msg [0] = NN_SWS_FRAME_BITMASK_FIN | NN_WS_OPCODE_CLOSE;\n1 warning generated.\n[ 49%] Linking C shared library ../libnanomsg.dylib\n[ 49%] Built target nanomsg\n2) tests went well:\n100% tests passed, 0 tests failed out of 43\nTotal Test time (real) =  16.19 sec\n3) target install could not finish.\ncmake --build . --target install\n-- Install configuration: \"\"\nCMake Error at cmake_install.cmake:31 (file):\n  file cannot create directory: /usr/local/include/nanomsg.  Maybe need\n  administrative privileges.\nmake:  [install] Error 1\n. *Since nn_poll is broken in so many ways, it should be fixed ASAP or removed from nanomsg library.\nnn_poll, at surface, seems to be a silver bullet, convenience function allowing to wait for a message on many sockets with a specified timeout.\nThis is far from the truth. The function only works on a sunny day and it is NOT a replacement for nn_recv.\nCase study:\n//***\n// A.  nn_recv is used only\n//***\nStart a consumer application:\n1) open (client) NN_PAIR socket, NN_RESPONDENT socket or NN_SUB socket. \n2) Connect the opened socket by nn_connect to a url.\n3) Configure a socket to be a blocking one with a timeout (optional but recommended)\n// timeout on a receive socket\nint socket_receive_option(int fd, int timeout)\n{\n    int ret = nn_setsockopt (fd, NN_SOL_SOCKET, NN_RCVTIMEO, &timeout, sizeof (timeout) ) \n    if(ret < 0)\n    {\n        printf(\"socket_receive_option failed %d %s \\n\", nn_errno(),  nn_strerror (nn_errno ()) );\n    }\n    return ret;\n} \n//\n//...\n  socket_receive_option(sock, 5000);\n//...\n4) Wait for the messages in the loop:\nwhile (1)\n{\n      char *buf = NULL;\n      int bytes = nn_recv (sock, &buf, NN_MSG, 0);\n       if (bytes >= 0)\n       {\n            printf (\"RECEIVED YOUR MESSAGE!\\n\");\n            nn_freemsg (buf);\n      }\n      else\n      {\n            printf (\"Timeout errno=%d %s\\n\", nn_errno (), nn_strerror (nn_errno ()) );\n            sleep(5);\n      }\n}\nBehaviour: \na) The timeout on the input socket is obeyed:\nYour consumer program will print the following message: \nTimeout errno=60 Operation timed out\nevery 10 seconds.\n5) Now, start producer application with: NN_PAIR (server), NN_SURVEYOR or NN_PUB.\nSend a message every few seconds on the same URL as expected by consumer.\nb) The server will be noticed:\nYour consumer applications will START RECEIVING messages and printing:\nRECEIVED YOUR MESSAGE!\n//****\n// B. nn_poll is used\n//****\nNow let us try consumer application with with nn_poll.\nDo not execute step 3) which is setting a timeout for a socket.\n4) Wait for the message in a new loop like this: \n```\nint wait_for_message(char *debug_msg, int fd, int timeout_ms)\n{\n    // function returns:\n    // 0 if there is no message\n    // < 0 error\n    // 1 message is waiting\nstruct nn_pollfd items[1];\n\nitems[0].fd = fd;\nitems[0].events = NN_POLLIN;\n\n//***************************************************************************************\nint  nr_of_ready_inputs = wait_for_messages(debug_msg, items, sizeof(items) , timeout_ms);\n//***************************************************************************************\n\nreturn nr_of_ready_inputs;\n\n}\nint wait_for_messages(char *debug_msg, struct nn_pollfd polls[], int polls_size , int timeout)\n{\n    //struct nn_pollfd {\n    //  int fd;\n    //  short events;\n    //  short revents;\n    //};\n// Each entry in the array represents an SP socket to check. events field specifies which events to check for.\n\nint rc;\n//***************************************\n rc = nn_poll(polls, polls_size, timeout); // wait for message till set timeout ms sec, return number of sockets ready for read (or write if configured)\n//***************************************\n\n// Upon successful completion, the number of nn_pollfds structures with events signalled is returned.\n// In case of timeout, return value is 0. In case of error,\n// -1 is returned and errno is set the one of the values below:\n//  NN_POLLIN\n//  Check whether at least one message can be received from the fd socket without blocking.\n//\n//  NN_POLLOUT\n//  Check whether at least one message can be sent to the fd socket without blocking.\n\nif (rc < 0) {\n    //print_time_stamp(\"\",\"\");\n    printf(\" %s nn_poll failed: errno=%d %s\\n\",\n    debug_msg,\n    nn_errno (),\n    nn_strerror (nn_errno ()));\n    //print_my_pid(1);\n\n    switch (nn_errno ())\n    {\n        case EPERM: //! not defined in the nanomsg doc for nn_poll\n            printf(\" EPERM:'nn_poll': %d\\n\", nn_errno ());\n        break;\n        case EBADF: // Some of the provided sockets are invalid.\n            printf(\" EBADF:'nn_poll': %d\\n\", nn_errno ());\n    break;\n    case EINTR: // The operation was interrupted by delivery of a signal before the message was sent.\n        printf(\" EINTR:'nn_poll': %d\\n\", nn_errno ());\n    break;\n    case ETERM: // The library is terminating.\n        printf(\" ETERM:'nn_poll': %d\\n\", nn_errno ());\n        break;\n    default:\n        printf(\" This errno is not defined for 'nn_poll': %d %s\\n\", nn_errno (), nn_strerror (nn_errno ()) );\n    break;\n    }\n\n    return rc;\n  }\n\nif (rc == 0) {\n    // this is a normal timeout!!!\n    // PrintTimeStamp(\"\",\" No data from 'nn_poll()' loop \\n\");\n    return 0;\n}\n\nreturn rc; //  Upon successful completion, the number of nn_pollfds structures with events signalled is returned.\n\n}\n```\n```\nwhile (1)\n{\n        char *buf = NULL;\n   //****************************************************************\n   int nr_of_ready_inputs =  wait_for_message(\"CLIENT\", sock, 5000);\n   //****************************************************************\n\n    if (nr_of_ready_inputs == 0)\n    continue; // timeout or error rc > number of events waiting\n\nif (nr_of_ready_inputs < 0) // timeout is ignored!\n{\n       printf (\"Error errno=%d %s\\n\", nn_errno (), nn_strerror (nn_errno ()) );\n       sleep(5); \n       continue;\n}\n\n    int bytes = nn_recv (sock, &buf, NN_MSG, NN_DONTWAIT);\n\n    if (bytes >= 0)\n    {\n        printf (\"RECEIVED YOUR MESSAGE!\\n\");\n        nn_freemsg (buf);\n    }\n    else\n    {\n        printf (\"Error errno=%d %s\\n\", nn_errno (), nn_strerror (nn_errno ()) );\n        sleep(5);\n    }\n\n}//while\n```\nBehaviour: \nThe BAD\nThe nn_poll will ignore 5000 timeout. nn_poll immediately returns with the error:\nnn_poll failed: errno=1 Operation not permitted \nThe UGLY\nEven if your producer (server) will come online the nn_poll will NOT NOTICE IT!\nThe consumer will never start receiving messages! \n. Thank you for taking look at the issue. Only first entry regarding behaviour for bad file descriptor is correct. The second entry suffered catastrophic error: sizeof(items) is totally incorrect.\n\nI'm pretty sure you're seeing bad stack corruption as a result of this error. \n\nI agree. Invalid file descriptors in inflated by mistake structure caused the error being return by nn_poll. That made nn_poll unusable, even though the first entry had a valid descriptor. \nThat actually exposed an issue with nn_poll. If nn_pollfails for any reason it cannot indicate the fact that some sockets are actaully ready to receive/send.  \nIt may be better to extendstruct nn_pollfd by new struct member to indicate the error condition per fd. Otherwise any broken fd invalidates the whole nn_pollwork all together.\nNew structure:\n   struct nn_pollfd {\n     int fd;\n     short events;\n     short revents; // may have NN_POLL_ERROR \n     int error; // keeps the errno \n    };\nIn this new scenario nn_poll would return after the timeout with 0 or sooner with number of ready sockets for read/write. reventscould use NN_POLL_ERROR flag to indicate the problem for a given fd entry.. After termination a PUB socket with nn_termalso non-blocking send will return EBADF. \n\nerrno=9 Bad file descriptor\n\nThat makes sense since socket is no longer valid.. Thanks!\nSimilarly, in the same setting \nnn_send (0, in_msg, 1000, 1);\nfails in the same manner:\n```\nInvalid argument [22] (/tmp/nanomsg-20160926-28652-1s6epum/nanomsg-1.0.0/src/utils/mutex.c:89)\nSignal: SIGABRT (signal SIGABRT)\n0   libnanomsg.5.0.0.dylib              0x00000001000a1cd7 nn_mutex_lock + 37\n1   libnanomsg.5.0.0.dylib              0x000000010009a11e nn_sendmsg + 58\n2   libnanomsg.5.0.0.dylib              0x000000010009a0de nn_send + 58\n```. My team did some investigation  into nanomsg's behaviour when using an invalid socket. These are the conclusions: \na) The behaviour is different for Mac and Linux.  \nb) The difference stems from the pthread library provided by apple vs the pthread library on linux.\nOn Mac:\nWhen given a valid socket, in 'utils/mutex.c' pthread_mutex_unlock()returns 0. This value works properly with nanomsgs error function errnum_assert().\nHowever, when given an invalid socket (such as 0)pthread_mutex_unlock() returns 22. The error function cannot deal with this value and accesses memory improperly. \nOn Linux:\npthread_mutex_unlock() returns a value that results in nano_msg error function working properly 'errnum_assert()' for both invalid and invalid sockets. \n. I am posting a fully automated testing program, to demonstrate the memory problem on the server side.\nCompile program and start with option -p.\nThe algorithm:\nProgram spawns PIPE PULL server and starts spawning PIPE PUSH clients. After the spawn the client is killed and a new one is started. Server runs forever and only one client is connected at any given time. \n(Note: In my case (macOS 10.12.5), the operating system(?) allows only 435 spawns(!) and program terminates when it cannot spawn anymore. If someone knows, why I get only limited number of spawns, please let me know!)\nThe program:\n```\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude    // for poll\ninclude  // for getrusage(...)\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ndefine url \"tcp://127.0.0.1:5555\"\nextern char **environ;\ntypedef struct example\n{\n    char buf[1024];\n    int buflen;\n    char my_name[15];\nunsigned int i;\nunsigned int counter;\npid_t process;\nint debug;\n\nint argc;\nchar  **argv;\n\nlong int initial_memory;\nstruct rusage r_usage;\n\n}PROGRAM_DATA;\n//           PIPELINE\nint ReportMemoryUsage(PROGRAM_DATA *p)\n{\n    // report program memory usage on the screen everytime it changes, in case there are leaks\n    getrusage (RUSAGE_SELF, &(p->r_usage) );\nif (p->r_usage.ru_maxrss != p->initial_memory)\n{\n    long t = 0;\n    time(&t);\n\n    p->initial_memory = p->r_usage.ru_maxrss;\n    ++p->counter;\n\n    fprintf(\n            stderr,\"%s **** %s: counter= %d  m= %d Memory used: %ld bytes ****\\n\",\n            strtok( ctime(&t), \"\\n\"),\n            p->my_name,\n            p->counter, // counter\n            p->i, // message\n            p->initial_memory\n    );\n}\nreturn 0;\n\n}\nint server (PROGRAM_DATA *p)\n{\n    int sock = nn_socket (AF_SP, NN_PULL);\n    poll (NULL, 0, 200);\n    assert (sock >= 0);\n    assert (nn_bind (sock, url) >= 0);\n    poll (NULL, 0, 200);\np->i = 0;\n\nwhile (1)\n{\n    ReportMemoryUsage(p);\n\n    ++(p->i);\n\n    int bytes = nn_recv (sock, p->buf, sizeof(p->buf), 0); // receive\n\n    assert (bytes >= 0);\n    if(p->debug)\n        printf (\"SERVER: nr=%d RECEIVED <%s>\\n\", p->i, p->buf);\n}\n\nreturn 0;\n}\nint client (PROGRAM_DATA *p)\n{\n    int sock = nn_socket (AF_SP, NN_PUSH);\n    assert (sock >= 0);\npoll (NULL, 0, 80);    // COOL DOWN\nassert (nn_connect (sock, url) >= 0);\n\npoll (NULL, 0, 120);    // COOL DOWN\n\np->i = 0;\n\nwhile(1)\n{\n    //ReportMemoryUsage(p);\n\n    ++(p->i);\n\n    sprintf(p->buf, \":%ld                                                              %d\\n\", time(0), p->i);\n\n    p->buflen = strlen (p->buf) + 1; // '\\0' too\n    if(p->debug)\n        printf (\"CLIENT: SENDING <%s>\\n\", p->buf);\n\n    int bytes = nn_send (sock, p->buf, p->buflen, 0);\n\n    assert (bytes == p->buflen);\n\n    poll (NULL, 0, 1000);\n}\n\nreturn nn_shutdown (sock, 0);\n\n}\nint run_process(PROGRAM_DATA p, char str)\n{\n    //pid_t pid;\n    char *argv[] = {p->argv[0], str, NULL};\n    int status;\nstatus = posix_spawn(&(p->process), p->argv[0], NULL, NULL, argv, environ);\n\nif (status == 0) {\n\n    if(p->debug)\n        printf(\"Child pid: %i\\n\", (p->process) );\n\n} else {\n    fprintf(stderr,\"posix_spawn: %s\\n\", strerror(status));\n}\n\nreturn status;\n\n}\nunsigned int\nrandr(unsigned int min, unsigned int max)\n{\n    // M + rand() / (RAND_MAX / (N - M + 1) + 1)\n    double scaled = (double)rand()/RAND_MAX;\nreturn (max - min +1)*scaled + min;\n\n}\nint spawner (PROGRAM_DATA *p)\n{\n    pid_t spawnerPid = getpid();\n    pid_t serverPid;\nint ret = run_process(p,\"-s\"); // start server\n\nif (ret != 0)\n{\n    free(p);\n    printf(\"spawner: could not start server! Make sure that port is available for binding! Exit!\\n\");\n    return -2;\n}\n\nfprintf(stderr,\"Once program is done, make sure to kill spawner: <%u> and server: <%u> \\n\", spawnerPid, p->process );\n\nserverPid = p->process; // remember servers' pid\n\npoll (NULL, 0, 500);\n\nwhile(1)\n{\n    ReportMemoryUsage(p);\n\n    ++(p->i);\n\n    // 1. spawn the process\n    ret = run_process(p,\"-c\"); // start client\n\n    if(ret != 0)\n        break;\n\n    // 2. wait\n    poll (NULL, 0, randr(250,350));\n\n    // 3. kill client\n    ret =\n            kill(p->process, SIGINT); // SIGUSR1);\n    poll (NULL, 0, 100);\n}\n\nfprintf(stderr,\"'spawner' terminates after %d spawns. due to 'posix_spawn' problems.\\n\",p->i);\n\n// cleanup:\n// kill server\n\nkill(serverPid, SIGINT); // SIGUSR1);\npoll (NULL, 0, 100);\n\nfree(p);\nreturn -1;\n\n}\nint main (int argc, char argv)\n{\n    int rc;\n    PROGRAM_DATA p = (PROGRAM_DATA ) calloc(1, sizeof(PROGRAM_DATA)) ; // create object structure\n    if(!p) {\n        return -1;\n    }\nif (argc < 2) {\n    fprintf (stderr, \"Usage: %s -s for server or -c for client (default) \\n\", argv[0]);\n    exit (EXIT_FAILURE);\n}\n\np->argc = argc; // number of input line parameters\np->argv = argv; // vector of input line parameters\n\nif (strcmp (argv[1], \"-s\") == 0) {\n    strcpy(p->my_name,\"server\");\n    rc = server (p);\n} else {\n    if (strcmp (argv[1], \"-p\") == 0) {\n        strcpy(p->my_name,\"spawner\");\n        rc = spawner (p);\n    }\n    else{\n        strcpy(p->my_name,\"client\");\n        rc = client (p);\n    }\n}\nexit (rc == 0 ? EXIT_SUCCESS : EXIT_FAILURE);\n\n}\n// STEPS\n// 1. start program with -p option.\n// 2. It will start server and starts spawning and killing clients.\n```\nThe output should look similar to:\n// first run:\n```\narch -e DYLD_LIBRARY_PATH=/Users/SG/Library/Caches/AppCode2016.3/DerivedData/Build/Products/Debug -e DYLD_FRAMEWORK_PATH=/Users/SG/Library/Caches/AppCode2016.3/DerivedData/Build/Products/Debug -x86_64 /Users/SG/Library/Caches/AppCode2016.3/DerivedData/Build/Products/Debug/syscom_t -p\nOnce program is done, make sure to kill spawner: <9685> and server: <9686> \nWed Jul 19 21:06:22 2017 * server: counter= 1  m= 0 Memory used: 897024 bytes \nWed Jul 19 21:06:22 2017 * spawner: counter= 1  m= 0 Memory used: 749568 bytes \nWed Jul 19 21:06:23 2017 * server: counter= 2  m= 1 Memory used: 954368 bytes \nWed Jul 19 21:06:23 2017 * spawner: counter= 2  m= 1 Memory used: 815104 bytes \nWed Jul 19 21:06:23 2017 * server: counter= 3  m= 2 Memory used: 974848 bytes \nWed Jul 19 21:06:23 2017 * server: counter= 4  m= 3 Memory used: 987136 bytes \nWed Jul 19 21:06:24 2017 * server: counter= 5  m= 4 Memory used: 995328 bytes \nWed Jul 19 21:06:24 2017 * server: counter= 6  m= 5 Memory used: 1007616 bytes \nWed Jul 19 21:06:25 2017 * server: counter= 7  m= 6 Memory used: 1015808 bytes \nWed Jul 19 21:06:27 2017 * server: counter= 8  m= 12 Memory used: 1019904 bytes \nWed Jul 19 21:06:29 2017 * server: counter= 9  m= 18 Memory used: 1028096 bytes \nWed Jul 19 21:06:33 2017 * server: counter= 10  m= 28 Memory used: 1048576 bytes \nWed Jul 19 21:06:36 2017 * server: counter= 11  m= 35 Memory used: 1052672 bytes \nWed Jul 19 21:06:37 2017 * server: counter= 12  m= 37 Memory used: 1056768 bytes \nWed Jul 19 21:06:59 2017 * server: counter= 13  m= 90 Memory used: 1060864 bytes \nWed Jul 19 21:08:59 2017 * server: counter= 14  m= 387 Memory used: 1064960 bytes \nWed Jul 19 21:09:01 2017 * server: counter= 15  m= 391 Memory used: 1069056 bytes \nWed Jul 19 21:09:10 2017 * server: counter= 16  m= 412 Memory used: 1073152 bytes \nposix_spawn: Resource temporarily unavailable\n'spawner' terminates after 435 spawns. due to \u2018posix_spawn' problems.\nProcess finished with exit code 1\n```\n// second run:\nOnce program is done, make sure to kill spawner: <10150> and server: <10151> \nWed Jul 19 21:10:47 2017 **** server: counter= 1  m= 0 Memory used: 913408 bytes ****\nWed Jul 19 21:10:47 2017 **** spawner: counter= 1  m= 0 Memory used: 749568 bytes ****\nWed Jul 19 21:10:47 2017 **** server: counter= 2  m= 1 Memory used: 983040 bytes ****\nWed Jul 19 21:10:47 2017 **** spawner: counter= 2  m= 1 Memory used: 786432 bytes ****\nWed Jul 19 21:10:47 2017 **** server: counter= 3  m= 2 Memory used: 991232 bytes ****\nWed Jul 19 21:10:48 2017 **** server: counter= 4  m= 3 Memory used: 995328 bytes ****\nWed Jul 19 21:10:48 2017 **** server: counter= 5  m= 4 Memory used: 1015808 bytes ****\nWed Jul 19 21:10:48 2017 **** server: counter= 6  m= 5 Memory used: 1019904 bytes ****\nWed Jul 19 21:10:50 2017 **** server: counter= 7  m= 8 Memory used: 1036288 bytes ****\nWed Jul 19 21:10:51 2017 **** server: counter= 8  m= 11 Memory used: 1040384 bytes ****\nWed Jul 19 21:10:54 2017 **** server: counter= 9  m= 20 Memory used: 1048576 bytes ****\nWed Jul 19 21:10:55 2017 **** server: counter= 10  m= 21 Memory used: 1052672 bytes ****\nWed Jul 19 21:10:58 2017 **** server: counter= 11  m= 28 Memory used: 1056768 bytes ****\nWed Jul 19 21:11:02 2017 **** server: counter= 12  m= 39 Memory used: 1060864 bytes ****\nWed Jul 19 21:11:04 2017 **** server: counter= 13  m= 43 Memory used: 1064960 bytes ****\nposix_spawn: Resource temporarily unavailable\n'spawner' terminates after 435 spawns. due to 'posix_spawn' problems.\nProcess finished with exit code 1\n//third run:\n```\nOnce program is done, make sure to kill spawner: <10607> and server: <10608> \nWed Jul 19 21:17:22 2017 * server: counter= 1  m= 0 Memory used: 913408 bytes \nWed Jul 19 21:17:22 2017 * spawner: counter= 1  m= 0 Memory used: 757760 bytes \nWed Jul 19 21:17:22 2017 * server: counter= 2  m= 1 Memory used: 937984 bytes \nWed Jul 19 21:17:22 2017 * spawner: counter= 2  m= 1 Memory used: 811008 bytes \nWed Jul 19 21:17:22 2017 * server: counter= 3  m= 2 Memory used: 950272 bytes \nWed Jul 19 21:17:23 2017 * server: counter= 4  m= 3 Memory used: 983040 bytes \nWed Jul 19 21:17:23 2017 * server: counter= 5  m= 4 Memory used: 1003520 bytes \nWed Jul 19 21:17:23 2017 * server: counter= 6  m= 5 Memory used: 1007616 bytes \nWed Jul 19 21:17:24 2017 * server: counter= 7  m= 7 Memory used: 1028096 bytes \nWed Jul 19 21:17:26 2017 * server: counter= 8  m= 12 Memory used: 1036288 bytes \nWed Jul 19 21:17:31 2017 * server: counter= 9  m= 23 Memory used: 1040384 bytes \nWed Jul 19 21:17:51 2017 * server: counter= 10  m= 72 Memory used: 1044480 bytes \nWed Jul 19 21:17:56 2017 * server: counter= 11  m= 86 Memory used: 1052672 bytes \nWed Jul 19 21:18:07 2017 * server: counter= 12  m= 112 Memory used: 1056768 bytes \nposix_spawn: Resource temporarily unavailable\n'spawner' terminates after 435 spawns. due to 'posix_spawn' problems.\nProcess finished with exit code 1\n```\nHTH. Thank you for you insight.  You were 100% right! The observed problem was caused by zombies which where growing till OS refused to spawn them. \nSG$  ps aux | grep 'Z'\nUSER               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND\nSG               23462   0.0  0.0        0      0   ??  Z     5:52pm   0:00.00 (syscom_t)\nSG               23461   0.0  0.0        0      0   ??  Z     5:52pm   0:00.00 (syscom_t)\nSG               23460   0.0  0.0        0      0   ??  Z     5:52pm   0:00.00 (syscom_t)\nSG               23459   0.0  0.0        0      0   ??  Z     5:52pm   0:00.00 (syscom_t)\nSG               23458   0.0  0.0        0      0   ??  Z     5:52pm   0:00.00 (syscom_t)\nSG               23457   0.0  0.0        0      0   ??  Z     5:52pm   0:00.00 (syscom_t)\n...\nTo sum up:\n1) The observed \"memory leak\" was due to the growing number of zombie processes. \n2) Using waitpid()did not change anything, the problem existed since\n kill(p->process, SIGINT);was leaving zombies behind.\n4) The proper clean up was obtained by signal(SIGCHLD, SIG_IGN);  issued after the kill(p->process, SIGINT); . That removed the memory growth.\nConclusion: Client can connect and die without causing memory leak on the server side. \nNevertheless, \n- every connected live client DOES bump memory up on the server side by 4k. That is understandable and I do not consider it a problem.   \n/Users/SG/Library/Caches/AppCode2016.3/DerivedData/Build/Products/Debug/syscom_t -p\nOnce program is done, make sure to kill spawner: <23898> and server: <23901> \nMon Jul 24 18:16:44 2017 **** server: counter=     1  m=          0 Memory used: 913408 bytes ****\nMon Jul 24 18:16:44 2017 **** spawner: counter=     1  m=          0 Memory used: 761856 bytes ****\nMon Jul 24 18:16:44 2017 **** server: counter=     2  m=          1 Memory used: 962560 bytes ****\nMon Jul 24 18:16:44 2017 **** spawner: counter=     2  m=          1 Memory used: 827392 bytes ****\nMon Jul 24 18:16:44 2017 **** server: counter=     3  m=          2 Memory used: 983040 bytes ****\nMon Jul 24 18:16:45 2017 **** server: counter=     4  m=          3 Memory used: 987136 bytes ****\nMon Jul 24 18:16:45 2017 **** server: counter=     5  m=          4 Memory used: 995328 bytes ****\nMon Jul 24 18:16:45 2017 **** server: counter=     6  m=          6 Memory used: 1015808 bytes ****\nMon Jul 24 18:16:46 2017 **** server: counter=     7  m=          8 Memory used: 1032192 bytes ****\nMon Jul 24 18:16:46 2017 **** server: counter=     8  m=         11 Memory used: 1036288 bytes ****\nMon Jul 24 18:16:46 2017 **** server: counter=     9  m=         14 Memory used: 1040384 bytes ****\nMon Jul 24 18:16:47 2017 **** server: counter=    10  m=         16 Memory used: 1044480 bytes ****\nMon Jul 24 18:16:47 2017 **** server: counter=    11  m=         21 Memory used: 1052672 bytes ****\nMon Jul 24 18:16:47 2017 **** server: counter=    12  m=         25 Memory used: 1060864 bytes ****\nMon Jul 24 18:16:48 2017 **** server: counter=    13  m=         29 Memory used: 1064960 bytes ****\nMon Jul 24 18:16:48 2017 **** server: counter=    14  m=         33 Memory used: 1069056 bytes ****\nMon Jul 24 18:16:49 2017 **** server: counter=    15  m=         39 Memory used: 1073152 bytes ****\nMon Jul 24 18:16:49 2017 **** server: counter=    16  m=         44 Memory used: 1077248 bytes ****\nMon Jul 24 18:16:49 2017 **** server: counter=    17  m=         50 Memory used: 1081344 bytes ****\nMon Jul 24 18:16:50 2017 **** server: counter=    18  m=         55 Memory used: 1085440 bytes ****\nMon Jul 24 18:16:50 2017 **** server: counter=    19  m=         61 Memory used: 1089536 bytes ****\nMon Jul 24 18:16:50 2017 **** server: counter=    20  m=         68 Memory used: 1093632 bytes ****\nMon Jul 24 18:16:51 2017 **** server: counter=    21  m=         76 Memory used: 1097728 bytes ****\nMon Jul 24 18:16:51 2017 **** server: counter=    22  m=         82 Memory used: 1101824 bytes ****\nMon Jul 24 18:16:51 2017 **** server: counter=    23  m=         90 Memory used: 1105920 bytes ****\nMon Jul 24 18:16:52 2017 **** server: counter=    24  m=         99 Memory used: 1110016 bytes ****\nMon Jul 24 18:16:52 2017 **** server: counter=    25  m=        108 Memory used: 1114112 bytes ****\nMon Jul 24 18:16:52 2017 **** server: counter=    26  m=        117 Memory used: 1118208 bytes ****\nMon Jul 24 18:16:53 2017 **** server: counter=    27  m=        125 Memory used: 1122304 bytes ****\nMon Jul 24 18:16:53 2017 **** server: counter=    28  m=        136 Memory used: 1126400 bytes ****\nMon Jul 24 18:16:53 2017 **** server: counter=    29  m=        145 Memory used: 1130496 bytes ****\nMon Jul 24 18:16:54 2017 **** server: counter=    30  m=        155 Memory used: 1134592 bytes ****\nMon Jul 24 18:16:54 2017 **** server: counter=    31  m=        166 Memory used: 1138688 bytes ****\nMon Jul 24 18:16:55 2017 **** server: counter=    32  m=        177 Memory used: 1142784 bytes ****\nMon Jul 24 18:16:55 2017 **** server: counter=    33  m=        188 Memory used: 1146880 bytes ****\nMon Jul 24 18:16:55 2017 **** server: counter=    34  m=        200 Memory used: 1150976 bytes ****\nMon Jul 24 18:16:56 2017 **** server: counter=    35  m=        211 Memory used: 1155072 bytes ****\nMon Jul 24 18:16:56 2017 **** server: counter=    36  m=        225 Memory used: 1159168 bytes ****\nMon Jul 24 18:16:56 2017 **** server: counter=    37  m=        238 Memory used: 1163264 bytes ****\nMon Jul 24 18:16:57 2017 **** server: counter=    38  m=        251 Memory used: 1167360 bytes ****\nMon Jul 24 18:16:57 2017 **** server: counter=    39  m=        262 Memory used: 1171456 bytes ****\nMon Jul 24 18:16:57 2017 **** server: counter=    40  m=        278 Memory used: 1175552 bytes ****\nMon Jul 24 18:16:58 2017 **** server: counter=    41  m=        291 Memory used: 1179648 bytes ****\nMon Jul 24 18:16:58 2017 **** server: counter=    42  m=        306 Memory used: 1183744 bytes ****\nMon Jul 24 18:16:58 2017 **** server: counter=    43  m=        321 Memory used: 1187840 bytes ****\nMon Jul 24 18:16:59 2017 **** server: counter=    44  m=        336 Memory used: 1191936 bytes ****\nMon Jul 24 18:16:59 2017 **** server: counter=    45  m=        352 Memory used: 1196032 bytes ****\nMon Jul 24 18:16:59 2017 **** server: counter=    46  m=        367 Memory used: 1200128 bytes ****\nMon Jul 24 18:17:00 2017 **** server: counter=    47  m=        384 Memory used: 1204224 bytes ****\nMon Jul 24 18:17:00 2017 **** server: counter=    48  m=        402 Memory used: 1208320 bytes ****\nMon Jul 24 18:17:01 2017 **** server: counter=    49  m=        417 Memory used: 1212416 bytes ****\nMon Jul 24 18:17:01 2017 **** server: counter=    50  m=        436 Memory used: 1216512 bytes ****\nMon Jul 24 18:17:01 2017 **** server: counter=    51  m=        454 Memory used: 1220608 bytes ****\nMon Jul 24 18:17:02 2017 **** server: counter=    52  m=        472 Memory used: 1224704 bytes ****\nMon Jul 24 18:17:02 2017 **** server: counter=    53  m=        490 Memory used: 1228800 bytes ****\nMon Jul 24 18:17:02 2017 **** server: counter=    54  m=        509 Memory used: 1232896 bytes ****\nMon Jul 24 18:17:03 2017 **** server: counter=    55  m=        528 Memory used: 1236992 bytes ****\nMon Jul 24 18:17:03 2017 **** server: counter=    56  m=        547 Memory used: 1241088 bytes ****\nMon Jul 24 18:17:03 2017 **** server: counter=    57  m=        567 Memory used: 1245184 bytes ****\nMon Jul 24 18:17:04 2017 **** server: counter=    58  m=        587 Memory used: 1249280 bytes ****\nMon Jul 24 18:17:04 2017 **** server: counter=    59  m=        608 Memory used: 1253376 bytes ****\nMon Jul 24 18:17:04 2017 **** server: counter=    60  m=        629 Memory used: 1257472 bytes ****\n- The fact that connected live client causes server to allocate 4k memory to service the connection is not a concern to me.  \n\n\nMy understand of posix_spawn is that it should prevent any cross contamination between clients regardless of nanomsg being fork-safe or not.\n\n\nI am closing the issue since there is NO memory leak caused by the disconnected dead clients. . Could you post the code for your case?. This are the steps to get a static library: (Linux)\n1)  Download nanomsg stable from:\u00a0https://github.com/nanomsg/nanomsg/1.0.0.zip.\n2) Extract zip file.\n3) Rename nanomsg-1.0.0 to nanomsgsrc.\n4) Delete 1.0.0.zip\n5) Create destination folder beside just-unpacked source folder. You should\u00a0now have two folders side by side:\u00a0nanomsgsrc\u00a0and\u00a0nanomsglib.\u00a0\n6) Switch current directory to source folder (nanomsgsrc\u00a0).\n7) Create a directory named\u00a0build\u00a0and switch into this new\u00a0directory.\u00a0\n8) Run command:\u00a0cmake .. -DMAKE_INSTALL_PREFIX=../../nanomsglib/ -DC_BUILD_TYPE=Debug -DNN_STATIC_LIB=1\nDMAKE_INSTALL_PREFIX describes the compilation destination, DC_BUILD_TYPE describes the build type (In this case Debug), and DNN_STATIC_LIB sets the output to static library.\n9) Run command:\u00a0cmake --build && ctest -C Debug.\n10) Run:\u00a0cmake --build . --target install\n\nYou will now have the static library and include files within the\u00a0destination\u00a0folder. The static library will be found at:\u00a0nanomsglib/lib64/libnanomsg.a ,\u00a0and the include files will be found at:\u00a0nanomsglib/include.\n\nOr you can use the  following script:\n!/bin/bash\nDownload nanomsg library 1.0 stable\nwget https://github.com/nanomsg/nanomsg/archive/1.0.0.zip\nExtract from archive and delete archive\nunzip 1.0.0.zip && rm 1.0.0.zip\nRename source file\nmv nanomsg-1.0.0    nanomsgsrc\nCreate destination folder\nmkdir nanomsglib\nSwitch into nanomsgsrc folder\ncd nanomsgsrc\nCreate build directory and switch into it\nmkdir build && cd build\nCompile\ncmake .. -DCMAKE_INSTALL_PREFIX=../../nanomsglib/ -DCMAKE_BUILD_TYPE=Debug -DNN_STATIC_LIB=1\ncmake --build .\nctest -C Debug .\ncmake --build . --target install\n. Just make sure that you terminate a string on send.\nThis\nnn_send(nn_sock_req_, strContent, nContentLen, 0);\nmay rather look like:\nnn_send(nn_sock_req_, strContent, nContentLen+1, 0);\nOn Thu, Nov 2, 2017 at 10:21 AM, DyncKevin notifications@github.com wrote:\n\nin my project, i use req/rep and pub/sub\nand i use code \"nn_recv(nn_sock_req_, &msg, NN_MSG, 0)\" like this to recv\ndata,\nbut i found when i print msg out, it will be messy code sometimes, like\nthis \" \"SysMsg\":[]}}Q\\261\ufffd \"\n\"Q\\261\" is messy code.\nat first it appear occasionally, after i check my code i found i forget\nadd nn_freemsg.\nbut after i add nn_freemsg, this issue appear every time.\nwho can tell me, what's my problem.\nthe following is the main code about nn_sock_req_\nnn_sock_req_ = nn_socket(AF_SP, NN_REQ)\nnn_send(nn_sock_req_, strContent, nContentLen, 0);\nint rc = nn_recv(nn_sock_req_, &msg, NN_MSG, 0);\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/927, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABVzVG_FrrEdTeGKtVGR7E89CXKU-9e3ks5syc_PgaJpZM4QPwqw\n.\n. @wcyangg If you post a test program I can try it on Win10 with VS2015.. Well, this is similar issue to https://github.com/nanomsg/nanomsg/issues/890. . nanomsg supports nonblocking send as well as nonblocking receive.\nCheck: http://nanomsg.org/v1.1.2/nn_recv.html . Socket options are set by nn_setsockopt  function\nhttp://nanomsg.org/v1.1.2/nn_setsockopt.html. To see some simple examples how nanomsg can be used  go to http://nanomsg.org/gettingstarted/index.html . Make sure to send a terminating 0 for the string.\n\nint result = nn_recv (sock, &buf, NN_MSG, 0);\nnn_send(sock, buf, strlen(buf), 0);  // strlen(buf) +1\nOn Mon, Jan 22, 2018 at 1:55 PM, brian crabtree notifications@github.com\nwrote:\n\nI'm attempting to get a basic echo working and have reduced the code to\nthe bare minimum:\ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \ninclude \nint echo(int sock)\n{\n  char *buf = NULL;\n  int result = nn_recv (sock, &buf, NN_MSG, 0);\n  if (result > 0)\n    {\n      printf (\"RECEIVED \\\"%s\\\" len: %d\\n\", buf, strlen(buf));\n      nn_send(sock, buf, strlen(buf), 0);\n      printf (\"SEND \\\"%s\\\"\\n\", buf);\n      nn_freemsg (buf);\n    }\n  return result;\n}\nint main (const int argc, const char **argv)\n{\n  if (argc > 1) {\n    int sock = nn_socket (AF_SP, NN_PAIR);\n    assert (sock >= 0);\n    assert (nn_bind (sock, argv[1]) >= 0);\nint to = 100;\nassert (nn_setsockopt (sock, NN_SOL_SOCKET, NN_RCVTIMEO, &to, sizeof (to)) >= 0);\nto = NN_WS_MSG_TYPE_TEXT;\nassert (nn_setsockopt (sock, NN_WS, NN_WS_MSG_TYPE, &to, sizeof (to)) >= 0);\n\n\nwhile(1)\n    {\n        echo(sock);\n        sleep(0.1);\n    }\n\n}\n  else\n  {\n      fprintf (stderr, \"Usage: pair \\n\");\n      return 1;\n  }\n}\nand then execute with test-echo ws://*:5555\nI'm pairing with a very basic javascript based on\nhttps://codepen.io/matt-west/pen/tHlBb\nbut have changed the necessary line:\nvar socket = new WebSocket('wss://192.168.1.26:5555',['pair.sp.nanomsg.org\n']);\n\nSymptom:\nSending a packet such as \"123\" is echoed correctly but then a shorter\npacket \"a\" is seen by nanomsg as \"a23\" (and it then echos this back to the\njavascript). This happens reliably but unpredictably, not just with these\nlengths of packet but the issue is length identification which can lead to\ngarbage in the packet. I suspect something is going on with nn_recv()\nI've checked netstat and the javascript side does seem to be sending the\ncorrect data.\nAny ideas where I should look next? Thanks.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/943, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABVzVFgG-S3T-uznHKlHPxR0aOstOxMGks5tNNmWgaJpZM4Rodk8\n.\n. Introduce a small delay (10-100 ms) after opening the port and see if\nproblem goes away.\n\nOn Wed, Nov 14, 2018 at 8:56 AM Volodymyr Lisivka notifications@github.com\nwrote:\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/1005, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABVzVD3ce7z5LYWRDnMqU-sOh7Y0ITEiks5uvCEIgaJpZM4YdyoJ\n.\n. \n",
    "vl409": "ok, this makes sense. I suspected something like that, given the fact that there indeed can be anything behind the scenes of socket interface. It is true that messages can be lost at any point (before or after leaving host) and you have to live with this and program retransmits or whatever. \nBut why ignore local errors? It is strange to expect something to happen if you even failed to send something to network (or at least pass it to the operating system's socket buffer).\nWith survey, this means almost always doubling timeout, since you don't retry until you realized that no response arrived in deadline interval.\n. ",
    "l4l": "Hm, it seems that arch-one didn't updated. I tried the same code with the 5cc0074 and b7fd165 builds - works fine (at least sanitizer don't blame)\nDon't really understand how to determine the version, because the pkgconfig states 1.0.0 version without the commit in the arch repo.. ah, that was the package of the stable version (0969988)\nThat is my fault, sorry. ",
    "lab313ru": "For example you just want to check packet type. And if this packet should be parsed, you may read it. Else, you may leave it in socket so another thread will be able to read and parse that packet.. ",
    "itssofluffy": "If we are looking at this would it also be possible to look at nn_poll and subscriber sockets, if a message is received that you are not subscribed to nn_poll will return a false positive (i.e. a message is waiting) but when nn_recv is executed it drops the message as it hasn't been subscribed too.. @gdamore fair do's... as the base library author i was expecting exactly the answer you've given, but as an api writer the MSG_PEEK would provide me with a solution within my api to the false positive on nn_poll as you could check the subscription against your own internal list of subscriptions and drop the message if required.. No that's a good call, the base library on this type of function shouldn't really have any kind of knowledge of the socket type that it's operating on, i have a solution in mind (from my api's point of view) to solve this issue, looking forward to the shape of things to come as in the shape of libnng!. ",
    "urdh": "I wrote and tested (manually observing traffic in Wireshark) the patch for work but reimplemented it at home, that's how the error snuck in there.\nIt would perhaps be appropriate to have a unit test that inspects the socket options (or something), but I'm not familiar with the nanomsg unit tests, and I don't see any obvious way to do that.. Fixed.. ",
    "vladfi1": "Forgot to add that the memory leak only happens once I run sub.py.. This was fixed by setting the max receive size on the subscriber side to -1 (unlimited).. ",
    "wangke1970": "on pubsub   \n        void *bufs = nn_allocmsg (12, 0);\n        memcpy (bufs, \"Hello world!\", 12);\n        rc = nn_send (fdpub,&bufs,NN_MSG, 0);\n/usr/local/lib/libnanomsg.so.5.0.0(+0x1c050)[0x7f23fa80c050]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_chunk_free+0x18)[0x7f23fa80be28]\n/usr/local/lib/libnanomsg.so.5.0.0(nn_freemsg+0x18)[0x7f23fa8007bd]\n./pub[0x400b3c]\n./pub[0x400b70]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f23fa447830]\n./pub[0x400939]\nAssertion failed: nn_getl ((uint8_t*) p - sizeof (uint32_t)) == NN_CHUNK_TAG (/home/wang/nanomsg-1.0.0/src/utils/chunk.c:211)\nAborted (core dumped)\n   void *bufs = nn_allocmsg (12, 0);\n    memcpy (bufs, \"Hello world!\", 12);\n    rc = nn_send (fdpub,&bufs,1000, 0);\n\nis ok\n. thinks. ",
    "arossert": "So this is a mistake in the documentation?\nWe should expect EBADF in this scenario?. This is not what I'm getting, look at this code:\n```\nint sock = nn_socket(AF_SP, NN_PAIR);\nnn_bind(sock, \"inproc://a\");\nstd::thread t( {\n    sleep(2);\n    nn_term();\n});\nchar buf[1000];\nint res = nn_recv(sock, buf, sizeof(buf), 0);\nif (res < 0) {\n    cout << nn_errno() << \": \" << nn_strerror(nn_errno()) << endl;\n}\nt.join();\n```\nI would expect to get ETERM on the blocking nn_recv but this is the output:\n\n9: Bad file descriptor. \n",
    "bou6": "\nYou\u2019ve never opened even one socket, so the library isn\u2019t initialized at all\n\nI find the fact of initialising the library by opening a socket not very good (Just a point of vue).\nI suggest to : \n1- Add a function to the library nn_init for example that calls nn_global_init and inside nn_global_init we can initialize the mutex. \n2- Add also a state variable in the nn_global struct to track the state of the library, for better debugging what\u00b4s going on, this said we can not avoid an undefined behaviour if the application calls nn_recv before nn_init. To avoid this we can initialize the mutex using the static initializer : \nstatic struct nn_global self {.lock = PTHREAD_MUTEX_INITIALIZER};\n. I want to help you in this subject. OK, why exactly ? could you please explain further . ",
    "promethe42": "\nsocket network API calls are not implemented for web browser JavaScript.\n\nEmscripten has POSIX sockets to WebSockets bindings.\nI already developped a Linux C socket program that builds with Emscripten and runs in the browser.\nI'm actually using it in production for a C/C++ app that runs in JavaScript in the browser and on Android/iOS/Linux/Windows/OSX.\nOf course I'll have to make sure I exclude all problematic files from the the source list.\nBut I'm used to doing exactly that when working with Emscripten.\nI'm \"pretty sure\" I can get the relevant stuff in nanomsg (sockets and the WebWorker IPC thing I want to add) to build with Emscripten.\nPS : I will probably create another issue for the Emscripten socket support.. I'm pretty sure I have to add platform (Emscripten) specific stuff here:\nhttps://github.com/nanomsg/nanomsg/tree/master/src/transports/ipc\nBut I don't know where to start.... Yes non blocking POSIX sockets work. They actually work pretty well IMHO.\nAnyway... that's one thing.\nWhat's with the IPC thing?\nAs detailed in my first post, the Emscripten API has:\n somekind of FD (the worker handler)\n passes char data to that worker\n has a C function pointer callback mechanism to listen to the char* sent by the other proc (/worker)\nAny chance I can get it to work by adding some platform specific code into the existing IPC code?\nAFAIK the existing code has platform specific (Windows Pipe/POSIX IPC sockets) code already, right ?. > i dont understand why you would need to treat ipc any different than tcp. its still just a socket.\nI'm trying to built support for WebWorkers. And the closest thing in nanomsg IMHO is IPC since WebWorkers are considered just like a different process.\nSo I'm asking how I could add support for WebWorkers to nanomsg though the Emscripten API.\nWhether it's IPC or something else. As long as it works and it's transparent.... > So WebWorkers don't share address space or any kind of global data?\nNope. The whole API is in my original post.\nIt's really two separates processes with a socket like messaging API (at least that's the Emscripten API).\nSeparate workers/processes is important to me so that it can be a completely separate module that can't interfere with the actual app. Those modules are actually expected to be written by 3rd parties.\n\nImplementing a new port for nanomsg is probably a mistake, IMO.\n\nI don't want to \"port\" nanomsg. I just want it to support a new platform.\nIt supports the Windows and POSIX APIs, and I'd like it to support the Emscripten API. Especially on the IPC side.\n\nyou might want to have a look at libnng\n\nWhat is the relation between libnng and nanomsg?\nIs the purpose of libnng to make it easier to support more platforms/transports?. So if I try to build nanomsg using Emscripten, it might \"just work\" if my app uses non blocking sockets?. > It might!\nThat's a good start!\nNow if I want to use not the socket transport, but the IPC transport.\nWhat are the required POSIX functions?. ",
    "kangseung": "here is run picture https://github.com/kangseung/nanomsgquestion/blob/master/wrong%20picture.png\nhow can change maxrcvsize option ?  T^T  i try to change it but it doesn't work.   please watch my codes\nI upload some codes\n1.\nhttps://github.com/kangseung/nanomsgquestion/blob/master/jsclient.cpp\n(this->socket in https://github.com/kangseung/nanomsgquestion/blob/master/jssocket.cpp)\nI press button  call this function onPressReqHistoryChart() and this->socket.send(json); and json = this->socket.recv(); blocking.   and I think it works correct.\n\nin server\nhttps://github.com/kangseung/nanomsgquestion/blob/master/main.cpp\n\nI receive message and call this function \n```\nelse if (msg_head == \"reqHistoryChartData\")\n{\n    my_logger->info(\"reqHistoryChartData\");\n    jsreply.publishHistoryChartData(&socket);\n }\n```\nhttps://github.com/kangseung/nanomsgquestion/blob/master/JSReply.cpp\n void JSReply::publishHistoryChartData(JSSocket *socket) \nsend a very long message, then main.cpp while(true) will receive  duplicate message  and call jsreply.publishHistoryChartData(&socket); again and send message again.\nclient will never receive any message and blocking forever.\nhttps://github.com/kangseung/nanomsgquestion/blob/master/jssocket.cpp\n`JSSocket::JSSocket(int domain, int protocol) :socket(domain,protocol)\n{\n    int queue_length =100010241024;\n    this->socket.setsockopt(NN_SOL_SOCKET, NN_RCVBUF, &queue_length, sizeof(queue_length));\nthis->socket.setsockopt(NN_SOL_SOCKET, NN_SNDBUF, &queue_length, sizeof(queue_length));\n\n/*if (protocol == NN_PUB)\n{\n    int queue_length = 900000000;   \n    this->socket.setsockopt(NN_SOL_SOCKET, NN_RCVBUF , &queue_length, sizeof(queue_length));\n}\nelse if (protocol == NN_SUB)\n{\n    int queue_length = 900000000;\n    this->socket.setsockopt(NN_SOL_SOCKET, NN_SNDBUF, &queue_length, sizeof(queue_length));\n}*/\n\n}`\nI don't know this buffer code  write correct?\nhelp me thank you  T^T. I am thinking...\nif I divide the long message how to send many times by req reply mode?\nI only can use publish subscribe mode to send many times messages?. Finally, I use publish subscribe divide long message.. ",
    "sreedhaa": "Thank you for the quick response, will switch-over to release build.. I still hit this assert even after switching over to release build. I am passing -DCMAKE_BUILD_TYPE=Release to cmake build and making sure that err.c is compiled with NDEBUG option.\nLooking at the code, nn_assert invokes abort() directly and not via assert(). So including NDEBUG shouldn't  make any difference. What am I missing?. \nIn addition, I was hitting an additional assert. I believe following assert also needs to be removed (from the context of STOPPING_TIMER_ERROR state)?\nhttps://github.com/nanomsg/nanomsg/blob/master/src/transports/utils/streamhdr.c#L265\n. I have opened issue #914 to track the second assert failure. Thanks for fixing these.. ",
    "davesliu": "BTW, there is no \"break\" for each  \"case\" & \"default\" in this nn_cws_handler  function.. if their is no \u201cbreak\u201d,the function nn_fsm_bad_action will be executed muti times..... @skyformat99\nSorry.\nYes, both the nn_fsm_bad_action & nn_fsm_bad_action will be executed .... ",
    "JPGygax68": "Thank you, Garret, for this detailed and very helpful answer!\nThe situation is therefore as I suspected; I indeed discovered for myself\nthat implementing such a thing was less fun that I thought it would be, and\nthe end result turned out not to be very reliable in the end, even with all\nthe effort I spent.\nI do think however that it could be done based on your design (I didn't\nknow a successor was in the works already).\nI really appreciate your insights and calculations about bandwidth,\nlatency, and jitter, as those are indeed the things I'm concerned about. I\nsuspect I do not absolutely need zero-copy, and that the gain in stability\nwill more than make up for any lost microseconds. The biggest contributor\nto latency will still be TCP over the LAN (yes TCP - I was surprised that\nthe increase in latency was negligible, especially considering there was no\nother easy way to compensate for lost packets).\nI also agree that zero copy remains of interest though. As a bit of\nbackground, my use case is actually a case of a 32-bit (Windows)\napplication that is exhausting its address space while being too big and\ncomplex (and heterogeneous: Fortran and C++) to just easily switch over to\n64-bit. I decided to try and use a \"satellite process\" to offload the work\nof muxing and sending the video stream over the network (using the FFmpeg\nlibrary). The implementation seems shaky, but works in principle; and I do\nbelieve there is more potential to this satellite process idea: done right,\nit could serve as the basis for complex interactions between large and\nheterogeneous software components, each of which would benefit from full\nprotection by the OS (a bit like browsers protect individual tabs, come to\nthink of it).\nThanks again, and best wishes!\nOn Wed, Sep 27, 2017 at 12:56 AM, gdamore notifications@github.com wrote:\n\nnanomsg does not today implement any kind of shared memory transport.\nThere were designs intended to make this possible via the IPC, but we've\njust never gotten around to it (and shared memory turns out to be really\nhard to do right in a general purpose networking stack because you have to\nmanage resources allocation and deallocation properly -- the latter being\nfairly hard to get right in a non-racy manner.)\nA good question, however, is whether you really need shared memory\ntransports. The loopback TCP is surprisingly fast, and IPC is available as\nwell; modern CPUs copy data actually pretty darned quickly.\nIf you assume zero compression, and want to encode 4K video streams\n(24-bit color) at 60Hz, you need something like 17Gb/s. A naive run using\n256K message sizes over TCP on my laptop macbook pro gets about 18 Gb/s.\nLarger message sizes have better perf... using 2MB messages I get about 20\nGb/s. Using UNIX domain sockets I get about 30 Gb/s. These are single\nthreaded numbers (1 thread sending, one thread receiving) -- reproduce the\nresults from using the local_thr and remote_thr utilities btw.\nThat's for throughput, and it indicates the sustained performance you have\nto provide to be jitter free. Of course, there is also latency, but the\nlatency you will get over this kind of session is so small as to be\nunnoticeable by humans. (Typically we don't notice audio latencies until\nthey reach up to about 30-40 ms. I'm not sure what the video tolerances\nare, but I suspect that they are similar, or even more tolerant. For\nexample, most gaming platforms can tolerate latencies of more than 50-60 ms\nbefore even the best players notice.\nIn the future, we may provide a true zero copy transport for nng (the\nsuccessor to nanomsg, but having a compatible API) -- there are use cases\nlike yours, and others (high speed storage) which would benefit from\nreduced data copies and higher throughput.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/902#issuecomment-332359492,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAwiiCmZkKnCQnmnF2ltegUKAt2oS06yks5smYEZgaJpZM4Pk2c2\n.\n. I wasn't familiar with the term - thanks for that.. Thanks again, I may give this a try!\n. \n",
    "simonzhangsm": "TCP are old and low throughput. ",
    "ComputationalAdvertising": "Doesn't nanomsg support running on high speed networks with RDMA? nanomsg has zero-copy function. Is it necessary to use RDMA interface to run on high speed network? @gdamore @simonzhangsm . @bou6  In support of RDMA, do you already have a solution? . ",
    "mdbs99": "\nI'm not aware of a Pascal or Delphi binding. It probably would not be hard to make one.\n\nThere are tools that convert the most C header to Pascal.\n\nWe do use API calls that are not available on Windows XP and 2003\n\nUnfortunately, my clients (some of them) are still using this Windows version to run some systems that I built.\n\nIPC on Windows works using named pipes. (Note that mangos -- the go version -- does not support this yet, but its on the TODO.) I'm not familiar with WM_COPYDATA -- I believe we just use normal byte oriented ReadEx and WriteEx on Windows, using Windows named pipes.\n\nI've already seen some implementation that using this approach on Windows and pipes on Linux.\nAbout IPC I just want to use on the same machine.\nNanomsg looks like simpler than ZeroMQ, for example, and I would like to use it. But I need to consider its features and restrictions.\nI will research more about my options.\nIf you want, you can close this issue. Thank you.. @gdamore \nIn time, I would say that I don't use the newest Delphi nowadays because its price. Yeah, it's insane.\nI migrated from Delphi to Free Pascal / Lazarus many years ago, but I still have some old projects that was coded in Delphi 7 (the most stable an classic version ever).\n\nThere's Free Pascal. not sure how portability across versions is.\n\nIf would you like to take a look at Object Pascal, that is the way to do: Free Pascal. It can compile in almost all OS, like C does.\nThere is a tool (well, there are others) to create bindings for C here.\nA curiosity for you is that the compiler is coded in Pascal. The previous version compiles the new one.\nThanks for your time.. ",
    "fuine": "@gdamore Thanks for a quick fix - great work :). ",
    "Raymond-Sun": "I am on X86-64, windows 10, intel i5 4770.. ",
    "bitmage": "It should be cleaned up now.  Sorry about that.. ",
    "DyncKevin": "@SG7  thank you for your quick reply.\ni know a string need to be ended by '\\0'\nbut the server side is running with NodeJS, the msg nn_recv is not from my 'nn_send', but from nodejs server.\nand i print out char code on nodejs side, there is no messy code in the end.\nwhen nn_recv, how i know the server reply with '\\0'\nas the following log shows\n(MsgSyncer.cpp:79): ++++++++++++++MsgSyncer::DoRepReq LOG msg strlen is:531, msg:{......\"Content\":\"\u521a\u624d\u5403\u4e0d\u9971\",\"Seqn\":135,\"STime\":1509672393389}}],\"GroupMsg\":[],\"FcMsg\":[],\"SysMsg\":[]}}\n(MsgSyncer.cpp:79): ++++++++++++++MsgSyncer::DoRepReq LOG msg strlen is:311, msg:{......,\"SysMsg\":[]}}eqn\":135,\u0478\nthese are two nn_recv logs from same file, \"MsgSyncer.cpp:79\", the first log is a right and normal log, but the second, notice, at the end, appear \"eqn\":135\" which had appear in the first log\nwhat should i do ? thanks\n. @gdamore thank you for your reply and advise\nbecause i used node-nanomsg on nodejs side, so i had thougth nanomsg had solved this kind of issues. I know it's my problem, i will have a try on cJSON.\nthank you very much!. @gdamore @SG7 \nthe issue had solved. it's my problem\ni just use the data 'msg' nn_recv and forget the return value msg length\nso when i pass msg to another method, i just pass 'msg' without msg length\ni did't write c-code for a long time, i forget this.\nthank you for yours time again!. ",
    "wcyangg": "nanomsg version : 1.1.2. @SG7 \n`\nchar REPAddress = \"tcp://127.0.0.1:45010\";\nchar REQAddress = \"inproc://aTest\"\nvoid deviceThread()\n{\n    int rc;\n    int devf;\n    int devg;\n/*  Intialise the device sockets. */\ndevf = nn_socket(AF_SP_RAW, NN_REP);\nnn_bind(devf, REPAddress);\ndevg = nn_socket(AF_SP_RAW, NN_REQ);\nnn_bind(devg, REQAddress);\n\n/*  Run the device. */\nrc = nn_device(devf, devg);\n\n/*  Clean up. */\nnn_close(devg);\nnn_close(devf);\n\n}\nvoid workThread()\n{\n    int sock;\n    int endpointId;\n    sock = nn_socket(AF_SP, NN_REP);\n    endpointId = nn_connect(sock, REQAddress);\n    while (server->m_Running) {\n        char buf = (char)nn_allocmsg(128, 0);\n        int bytes = nn_recv(sock, &buf, NN_MSG, 0);\n        if (bytes <= 0) {\n            break;\n        }\n        nn_send(sock, buf, strlen(buf), 0);\n        nn_freemsg(buf);\n    }\n    nn_shutdown(sock, endpointId);\n    nn_close(sock);\n}\nvoid Start(int workCount)\n{\n    thread dev(deviceThread, this);\n    for (int i = 0; i < workCount; i++)\n    {\n        thread work(workThread, this);\n        work.detach();\n    }\n    dev.join();\n}\n`. @gdamore \nsome examples in source code use \"test_send\" function like this : \ntest_send(endg, \"REPLYXYZ\");\ndefine test_send(s, d) test_send_impl (FILE, LINE, (s), (d))\nstatic void NN_UNUSED test_send_impl (char file, int line,\n    int sock, char data)\n{\n    size_t data_len;\n    int rc;\n    data_len = strlen (data);\n    rc = nn_send (sock, data, data_len, 0); // the same way to send message\n    if (rc < 0) {\n        fprintf (stderr, \"Failed to send: %s [%d] (%s:%d)\\n\",\n            nn_err_strerror (errno),\n            (int) errno, file, line);\n        nn_err_abort ();\n    }\n    if (rc != (int)data_len) {\n        fprintf (stderr, \"Data to send is truncated: %d != %d (%s:%d)\\n\",\n            rc, (int) data_len,\n            file, line);\n        nn_err_abort ();\n    }\n}\n. @skyformat99 \ninternal assert fail. no rc value.\nwindows GetLastError() return 10054. ",
    "benghopy": "Can I using the fcntl function to set the nanomsg socket to noblock?. Ok, I will try this way, and if I have any questions about how to using the nanomsg, I will asking on the emailing list.\nThaks a lot!. ",
    "likeprogrames": "i didn't call nn_bind.. ",
    "devdimager": "Hi, I would like use nanomsg under Windows OneCore. I was not able to load nanomsg.dll, i assume because dependencies. ws2 are supported in OneCore, but not shure regarding advapi32.dll.. ",
    "tleacmcsa": "Dang, ok.  Thanks.. Yeah, it makes sense.  Thanks for the reply!. ",
    "tehn": "Thanks for the response.\nI've tried this, but it also doesn't address the primary issue which is the packet length corruption of incoming packets from javascript. The problem can be seen in nn_recv() as the packet is printed (with errors showing) before it's echoed back with nn_send:\nprintf (\"RECEIVED \\\"%s\\\" len: %d\\n\", buf, strlen(buf));\nYour suggestion ensures proper line endings for packets sent to the js from c, which I haven't had any problem with.. Solved.\nnn_recv() gets confused if the message doesn't have a trailing \\0\nThis was a problem with the javascript (I added an explicit \\0), so whatever server is used at wss://echo.websocket.org doesn't care about \\0\nThank you and sorry for the noise.. You are entirely correct, thank you for clarifying. I misread the return value from nn_recv() as being a success/fail flag and not the length of the data received, which would've cleared everything up right away. Thanks again.. ",
    "douglascordeiro": "Keep a track on each client is not a issue for me, I would need to do this anyway as this system will work with subscribe. But How I get pipe id in order to do the association and then call the send for a specific pipe?\n. ",
    "wenq1": "So cool!. Reopening to ask a side question. The answer means that stream reading is in a separate thread and signaled back to the user-defined main thread via the fd (nn_getsockops (nn_recv))? How is this fd only 'signaling' but not 'readable'? Even eventfd needs to be read so that EPOLLIN won't be triggered next time. ",
    "SEFIROT-GmbH": "handle leak still persistent in 1.1.3\nadding this line fixed the problem:\nsrc\\core\\sock.c:238:    nn_sem_term (&self->relesem);\n. ",
    "lilianmoraru": "Things like add_definitions (-pthread) should probably also be switched to:\ntarget_compile_definitions(... PUBLIC ...)\nand linking in this particular case?:\n```\nfind_package(Threads) - \"Threads::Threads\" not available in this version?\ntarget_link_libraries(... PUBLIC pthread)\n```. ",
    "qsodev": "find_package(Threads) together with \n~~~\nif(THREADS_HAVE_PTHREAD_ARG)\n    add_definitions (-pthread)\nendif()\nif(CMAKE_THREAD_LIBS_INIT)\n    target_link_libraries (${PROJECT_NAME} \"${CMAKE_THREAD_LIBS_INIT}\")\nendif()\n~~~\nas it is defined in src/CMakeLists.txt works correctly. I am not sure what target_compile_options handles differently compared to add_definitions. I am not a cmake expert..\nBut the auto generated cmake config files contain the pthread dependency. In case of Debug build:\n~~~\n...\nImport target \"nanomsg\" for configuration \"Debug\"\nset_property(TARGET nanomsg APPEND PROPERTY IMPORTED_CONFIGURATIONS DEBUG)\nset_target_properties(nanomsg PROPERTIES\n  IMPORTED_LINK_INTERFACE_LIBRARIES_DEBUG \"anl;rt;pthread;nsl;-lpthread\"\n  IMPORTED_LOCATION_DEBUG \"${_IMPORT_PREFIX}/lib64/libnanomsg.so.5.1.0\"\n  IMPORTED_SONAME_DEBUG \"libnanomsg.so.5\"\n  )\n...\n~~~\nSo a project using find_package(nanomsg) target_link_libraries(some_target nanomsg) will also have -lpthread linker option added automatically.\nIs there something wrong with that? It seems correct to me.\n. NN_STATIC_LIB definition is now added implicitly to depending targets when using the static library. ",
    "arencour": "Another Fault offset\n\n. Nanomsg is unmanaged library in our C# application. If you attach debug version of the library I can try to repeat error with it.. Unfortunatly for users it is normal conditions. Their other applications sometimes close these internal connections. We recommend them to remove suspicious application, but sometimes such applications not found in the list of installed programs.. ",
    "acviex": "@gdamore You're right. The cause of runtime error in this (Windows) case is \nwsa_assert (rc != SOCKET_ERROR); in function void nn_efd_unsignal (struct nn_efd *self) in file efd_win.inc. This assert makes Windows to finish application, because rc = 10054 or connection reset by peer. I think the better solution for this situation is recreate connection instead killing application.\nAdditional:\nA stacktrace for this error:\nvoid nn_efd_unsignal (struct nn_efd *self)\nstatic void nn_sock_onleave (struct nn_ctx *self)\nvoid nn_ctx_leave (struct nn_ctx *self)\nint nn_sock_recv (struct nn_sock *self, struct nn_msg *msg, int flags)\nint nn_recvmsg (int s, struct nn_msghdr *msghdr, int flags)\nint nn_recv (int s, void *buf, size_t len, int flags)\nvoid nn_efd_unsignal (struct nn_efd *self) contains wsa_assert that calls abort() and terminates the app.. ",
    "chickenkiller": "I updated the description.\nCalling asciidoctor means ruby is installed on the machine... Maybe it's worth rewriting this script in ruby for better portability ? I can do it if you want.. I rewrote my P/R entirely to use a Ruby script, which IMHO will be more portable across platforms.. No worries, I thought afterwards that you would not like a ruby script. Forget it.\nPS. I was generating on Linux, not Windows. You also probably know that bash is not the default shell on MacOS, and as such, maybe it's worth using the same interpreter on all platforms. Can I suggest you these:\n\nswitch the shebang line to use bash explicitely\nuse the -e option for echo command, since it is mandatory for the script to run successfully under bash\nfix the typo on the frontmatter variable which you mispelled on line 52\nfix the aargs variable initialization at the loop start\n\nI fixed all these previously (except the explicit bash invocation) because actually the current script is not functional under bash. A 'git diff' after calling it shows that the frontmatter are incorrectly formatted and that non-manpage documentation is rendered using the manpage backend which is not what you expect.\nCan I suggest a P/R again so that the generation works under Linux at least?\n. -e enables interpretation of backslash-escape sequences, like the \\n in the frontmatter. Under linux/bash, without this flag, the frontmatter results in such a line:\n````\nversion: 1.1.2\\nlayout: default\n````\nIf the 'echo' command behaves differently on macos, maybe the solution is to keep the frontmatter in 2 variables and 'echo' them one after the other to avoid the \\n escaping problem.. ",
    "ras0219-msft": "We'd be happy to accept a PR for nanomsg!. ",
    "RobotixDK": "Hi, thanks for the replies. However setting NN_HAVE_LINUX for Android\ndidn't do the trick.\nThis NNG, will it be nanomsg compliant? And do you know if anyone's looking\ninto Unity/c# support here?\n2018-03-16 21:53 GMT+01:00 gdamore notifications@github.com:\n\nOk, reading the NDK, it's just Linux with an abbreviated set of compatible\nlibraries, and a custom libc (bionic). The libc appears to support the\nnecessary things we need, including pthreads APIs, epoll, and eventfd. So\nit really should just be a matter of duplicating the Linux logic in the\nCMakeLists.txt to apply to Android as well.\nI don't have an NDK handy to validate this with, but if you are able to do\nso, I'd be happy to accept a PR.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/nanomsg/nanomsg/issues/958#issuecomment-373841914,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AdYUfOqWv28UlDLztwKuEIsT5ROMGU_Aks5tfCZNgaJpZM4SuY5s\n.\n. We parked the idea of using nanomsg or nng, due to lack of crossplatform Unity support. So currently using ZMQ.\n\nThanks,\nRasmus \nSendt fra min iPhone\n\nDen 1. jun. 2018 kl. 15.36 skrev gdamore notifications@github.com:\nI can probably knock this out today if there is need (meaning if you still want old nanomsg instead of NNG.)\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "ZhitongLei": "I would like to use NNG in my benchmark, it sounds great. Beyond that, I will try something like the reactor pattern: worker threads get new inbound request from queue instead of being spawned on a single socket. . ",
    "songmaotian": "@gdamore sorry, but how to change the size? I grep, but can't find the macro.. @gdamore I write a code\nif (nn_setsockopt(sock, NN_SOL_SOCKET, NN_RCVMAXSIZE, &size, sizeof(size)) < 0) {\nto set NN_RCVMAXSIZE, but the program received a segment fault.. ",
    "xoyojank": "I met a similar problem. I tried to set NN_SNDBUF/NN_RCVBUF/NN_RCVMAXSIZE to 8MB/8MB/8MB or 8MB/8MB/-1, sometimes the application freezed, sometimes the next send failed with EAGAIN. . what's the size you set?. ",
    "weihu8687": "I see the same problem as I want to send/recv a 6MB file. after call \nif (nn_setsockopt(sock, NN_SOL_SOCKET, NN_RCVMAXSIZE, &size, sizeof(size)) < 0) {}\nit works, and I don't see the segment fault.. I set to 6MB, doesn't try bigger setting.. ",
    "DaneSpiritGOD": "@gdamore Yes,it is on C# and Windows 7\nMain Thread\n```\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    // TODO: dispose managed state (managed objects).\n                    _socket?.Shutdown(_endpoint);\n                    _socket?.Dispose();\n                    abortWokerThread();\n                }\n            // TODO: free unmanaged resources (unmanaged objects) and override a finalizer below.\n            // TODO: set large fields to null.\n\n            disposedValue = true;\n        }\n    }\n    const int ThreadAbortAndJoinTime = 1000;\n    private void abortWokerThread()\n    {\n        if (_workerThread == null || !_workerThread.IsAlive) return;\n        _workerThread?.Abort();\n        if (_workerThread.Join(ThreadAbortAndJoinTime))\n            _workerThread = null;\n        else\n            throw new WorkerThreadCannotAbortImmediatelyException();\n    }\n\n`Loop Thread Core function`\n        public static ReceivedBuffer ReceiveFrom(NanomsgSocketBase socket)\n        {\n            if (socket == null || socket.SocketID < 0) throw new ArgumentNullException(nameof(socket) + \" is null.\");\n        var zero = IntPtr.Zero;\n        int num = Interop.nn_recv(socket.SocketID, ref zero, Interop.NN_MSG, (int)SendRecvFlags.NONE);\n        if (num < 0) throw new NanomsgPlusException($\"{nameof(ReceiveFrom)}\", true);\n        return new ReceivedBuffer(zero, num);\n    }\n\nprotected override void WorkerThreadLoop()\n        {\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        var signal =ReceivedBuffer.ReceiveFrom(socket);\n                        if (signal == null) continue;\n                        OnGotMsg(signal);\n                    }\n                    catch (Exception ex) when (!(ex is ThreadAbortException))\n                    {\n                        _log.Error(ex.Message);\n                    }\n                }\n            }\n            catch (ThreadAbortException)\n            {\n                _log.Info(\"Img Worker is aborted successfully.\");\n            }\n        }\n```\nIf I not nn_close the socket,the loop thread is blocked and will not exit even wheni invoke the function Thread.Abort().\nIn addition,Thread.Abort() is managed function which throws a ThreadAbortException in the loop thread that I can catch.Normally, the thread will not crash if i write like this.\n. @gdamore thanks for your answer.\nThe matter in \"tcp\" is different from \"ipc\" mode in my practice.\nAnd i will try your method.. ",
    "avistel": "Fair enough. I'll withdraw.. ",
    "codypiersall": "Do you think it makes sense to move the Support section nearer the top?  I would guess most people aren't reading that far down in the README.. ",
    "codecov[bot]": "Codecov Report\n\nMerging #979 into master will increase coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #979      +/-\n==========================================\n+ Coverage    78.9%   78.91%   +<.01%   \n==========================================\n  Files         148      148            \n  Lines       11498    11498            \n==========================================\n+ Hits         9073     9074       +1   \n+ Misses       2425     2424       -1\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/core/global.c | 80.08% <0%> (\u00f8) | :arrow_up: |\n| src/transports/tcp/tcp.c | 94.11% <0%> (+2.94%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update eac025a...d415160. Read the comment docs.\n. # Codecov Report\nMerging #980 into master will decrease coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #980      +/-\n=========================================\n- Coverage   78.91%   78.9%   -0.02%   \n=========================================\n  Files         148     148            \n  Lines       11498   11497       -1   \n=========================================\n- Hits         9074    9072       -2   \n- Misses       2424    2425       +1\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/utils/sem.c | 93.33% <\u00f8> (\u00f8) | :arrow_up: |\n| src/transports/tcp/tcp.c | 91.17% <0%> (-2.95%) | :arrow_down: |\n| src/core/global.c | 80.04% <0%> (-0.05%) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d415160...ef4123f. Read the comment docs.\n. # Codecov Report\nMerging #1006 into master will increase coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster   #1006      +/-\n=========================================\n+ Coverage   78.89%   78.9%   +0.01%   \n=========================================\n  Files         148     148            \n  Lines       11497   11499       +2   \n=========================================\n+ Hits         9070    9073       +3   \n+ Misses       2427    2426       -1\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/core/global.c | 80.08% <0%> (+0.08%) | :arrow_up: |\n| src/utils/efd.c | 90% <0%> (+10%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1749fd7...e40de97. Read the comment docs.\n. \n",
    "PooyaEimandar": "\nNote that req protocol cannot receive until\nyou have first sent a message\n\nThanks. ",
    "jiangrzh": "thank you for your response !\nI was test the nanomsg-1.14, and also test the nng, but it's seems the result is not well too:\n```bash\n-bash-3.2$ ctest .\nTest project /export/home/jiangrz/dev/nng/build\n      Start  1: aio\n 1/75 Test  #1: aio ..............................   Passed    0.40 sec\n      Start  2: base64\n 2/75 Test  #2: base64 ...........................   Passed    0.01 sec\n      Start  3: bufsz\n 3/75 Test  #3: bufsz ............................   Passed    0.02 sec\n      Start  4: device\n 4/75 Test  #4: device ...........................   Passed    0.22 sec\n      Start  5: errors\n 5/75 Test  #5: errors ...........................   Passed    0.01 sec\n      Start  6: files\n 6/75 Test  #6: files ............................   Passed    0.01 sec\n      Start  7: httpclient\n 7/75 Test  #7: httpclient .......................Timeout  60.05 sec\n      Start  8: httpserver\n 8/75 Test  #8: httpserver .......................   Passed    0.95 sec\n      Start  9: idhash\n 9/75 Test  #9: idhash ...........................   Passed    0.04 sec\n      Start 10: inproc\n10/75 Test #10: inproc ...........................   Passed    0.84 sec\n      Start 11: ipc\n11/75 Test #11: ipc ..............................   Passed    1.05 sec\n      Start 12: ipcperms\n12/75 Test #12: ipcperms .........................   Passed    0.02 sec\n      Start 13: ipcwinsec\n13/75 Test #13: ipcwinsec ........................   Passed    0.02 sec\n      Start 14: list\n14/75 Test #14: list .............................   Passed    0.01 sec\n      Start 15: message\n15/75 Test #15: message ..........................   Passed    0.01 sec\n      Start 16: multistress\n16/75 Test #16: multistress ......................   Passed   30.09 sec\n      Start 17: nonblock\n17/75 Test #17: nonblock .........................   Passed   15.03 sec\n      Start 18: options\n18/75 Test #18: options ..........................   Passed    0.01 sec\n      Start 19: pipe\n19/75 Test #19: pipe .............................   Passed    0.35 sec\n      Start 20: platform\n20/75 Test #20: platform .........................   Passed    0.31 sec\n      Start 21: pollfd\n21/75 Test #21: pollfd ...........................   Passed    0.37 sec\n      Start 22: reconnect\n22/75 Test #22: reconnect ........................   Passed    2.93 sec\n      Start 23: resolv\n23/75 Test #23: resolv ...........................Timeout  10.01 sec\n      Start 24: scalability\n24/75 Test #24: scalability ......................   Passed    0.12 sec\n      Start 25: sha1\n25/75 Test #25: sha1 .............................   Passed    0.02 sec\n      Start 26: sock\n26/75 Test #26: sock .............................   Passed    0.33 sec\n      Start 27: synch\n27/75 Test #27: synch ............................   Passed    0.25 sec\n      Start 28: tcp\n28/75 Test #28: tcp ..............................Timeout 180.02 sec\n      Start 29: tcp6\n29/75 Test #29: tcp6 .............................   Passed    0.02 sec\n      Start 30: transport\n30/75 Test #30: transport ........................   Passed    0.02 sec\n      Start 31: udp\n31/75 Test #31: udp ..............................   Passed    0.07 sec\n      Start 32: url\n32/75 Test #32: url ..............................   Passed    0.02 sec\n      Start 33: ws\n33/75 Test #33: ws ...............................   Passed    1.17 sec\n      Start 34: bus\n34/75 Test #34: bus ..............................   Passed    0.23 sec\n      Start 35: pipeline\n35/75 Test #35: pipeline .........................   Passed    0.36 sec\n      Start 36: pair1\n36/75 Test #36: pair1 ............................   Passed    3.54 sec\n      Start 37: pubsub\n37/75 Test #37: pubsub ...........................   Passed    1.04 sec\n      Start 38: reqctx\n38/75 Test #38: reqctx ...........................   Passed    0.24 sec\n      Start 39: reqpoll\n39/75 Test #39: reqpoll ..........................   Passed    0.72 sec\n      Start 40: reqrep\n40/75 Test #40: reqrep ...........................   Passed    0.08 sec\n      Start 41: reqstress\n41/75 Test #41: reqstress ........................   Passed   30.06 sec\n      Start 42: respondpoll\n42/75 Test #42: respondpoll ......................   Passed    1.33 sec\n      Start 43: survey\n43/75 Test #43: survey ...........................   Passed    2.68 sec\n      Start 44: surveyctx\n44/75 Test #44: surveyctx ........................   Passed    0.13 sec\n      Start 45: surveypoll\n45/75 Test #45: surveypoll .......................   Passed    1.33 sec\n      Start 46: compat_block\n46/75 Test #46: compat_block .....................   Passed    0.22 sec\n      Start 47: compat_bug777\n47/75 Test #47: compat_bug777 ....................   Passed    0.12 sec\n      Start 48: compat_bus\n48/75 Test #48: compat_bus .......................   Passed    0.23 sec\n      Start 49: compat_cmsg\n49/75 Test #49: compat_cmsg ......................   Passed    0.02 sec\n      Start 50: compat_msg\n50/75 Test #50: compat_msg .......................   Passed    0.04 sec\n      Start 51: compat_iovec\n51/75 Test #51: compat_iovec .....................   Passed    0.02 sec\n      Start 52: compat_device\n52/75 Test #52: compat_device ....................   Passed    0.62 sec\n      Start 53: compat_pair\n53/75 Test #53: compat_pair ......................   Passed    0.02 sec\n      Start 54: compat_pipeline\n54/75 Test #54: compat_pipeline ..................   Passed    0.07 sec\n      Start 55: compat_poll\n55/75 Test #55: compat_poll ......................   Passed    0.36 sec\n      Start 56: compat_reqrep\n56/75 Test #56: compat_reqrep ....................   Passed    0.70 sec\n      Start 57: compat_survey\n57/75 Test #57: compat_survey ....................   Passed    3.02 sec\n      Start 58: compat_reqttl\n58/75 Test #58: compat_reqttl ....................   Passed    0.25 sec\n      Start 59: compat_shutdown\n59/75 Test #59: compat_shutdown ..................   Passed    0.04 sec\n      Start 60: compat_surveyttl\n60/75 Test #60: compat_surveyttl .................   Passed    0.25 sec\n      Start 61: compat_tcp\n61/75 Test #61: compat_tcp .......................Timeout  60.02 sec\n      Start 62: compat_ws\n62/75 Test #62: compat_ws ........................Timeout  60.02 sec\n      Start 63: compat_options\n63/75 Test #63: compat_options ...................   Passed    0.02 sec\n      Start 64: cplusplus_pair\n64/75 Test #64: cplusplus_pair ...................   Passed    0.11 sec\n      Start 65: inproc_lat\n65/75 Test #65: inproc_lat .......................   Passed    0.87 sec\n      Start 66: inproc_thr\n66/75 Test #66: inproc_thr .......................   Passed    0.51 sec\n      Start 67: nngcat_async\n67/75 Test #67: nngcat_async .....................   Passed    4.03 sec\n      Start 68: nngcat_ambiguous\n68/75 Test #68: nngcat_ambiguous .................   Passed    0.02 sec\n      Start 69: nngcat_need_proto\n69/75 Test #69: nngcat_need_proto ................   Passed    0.01 sec\n      Start 70: nngcat_dup_proto\n70/75 Test #70: nngcat_dup_proto .................   Passed    0.02 sec\n      Start 71: nngcat_help\n71/75 Test #71: nngcat_help ......................   Passed    0.03 sec\n      Start 72: nngcat_incompat\n72/75 Test #72: nngcat_incompat ..................   Passed    0.05 sec\n      Start 73: nngcat_pubsub\n73/75 Test #73: nngcat_pubsub ....................Failed    4.68 sec\n      Start 74: nngcat_recvmaxsz\n74/75 Test #74: nngcat_recvmaxsz .................Failed    2.10 sec\n      Start 75: nngcat_unlimited\n75/75 Test #75: nngcat_unlimited .................Failed    2.64 sec\n89% tests passed, 8 tests failed out of 75\nTotal Test time (real) = 487.74 sec\nThe following tests FAILED:\n          7 - httpclient (Timeout)\n         23 - resolv (Timeout)\n         28 - tcp (Timeout)\n         61 - compat_tcp (Timeout)\n         62 - compat_ws (Timeout)\n         73 - nngcat_pubsub (Failed)\n         74 - nngcat_recvmaxsz (Failed)\n         75 - nngcat_unlimited (Failed)\nErrors while running CTest\nand my focus is on tcp: \n-bash-3.2$ dbx ./tcp \nFor information about new features see help changes'\nTo remove this message, putdbxenv suppress_startup_message 7.9' in your .dbxrc\nReading tcp\nReading ld.so.1\nReading libmtmalloc.so.1\nReading librt.so.1\nReading libnsl.so.1\nReading libsocket.so.1\nReading libc.so.1\nReading libaio.so.1\nReading libmd.so.1\n(dbx) run 5555\nRunning: tcp 5555 \n(process id 4627)\nReading libc_psr.so.1\n^Cdbx: warning: Interrupt ignored but forwarded to child.\nt@1 (l@1) signal INT (Interrupt) in __lwp_park at 0xffffffff7e6d8b9c\n0xffffffff7e6d8b9c: __lwp_park+0x0010:  ta       %icc,0x0000000000000040\n(dbx) where\ncurrent thread: t@1\n=>[1] __lwp_park(0x0, 0x0, 0x0, 0x1, 0x0, 0xffffffff7e800200), at 0xffffffff7e6d8b9c \n  [2] cond_sleep_queue(0x1002d0c68, 0x1002d0c50, 0x0, 0x4, 0x16bf80, 0xffffffff7e10d740), at 0xffffffff7e6d219c \n  [3] cond_wait_queue(0x1002d0c68, 0x1002d0c50, 0x0, 0x0, 0x0, 0x0), at 0xffffffff7e6d2388 \n  [4] cond_wait_common(0x1002d0c68, 0x1002d0c50, 0x0, 0x1002d0c54, 0x16bab4, 0x0), at 0xffffffff7e6d2810 \n  [5] cond_wait(0x1002d0c68, 0x1002d0c50, 0x0, 0x1cc4, 0x1c00, 0x0), at 0xffffffff7e6d290c \n  [6] _pthread_cond_wait(0x1002d0c68, 0x1002d0c50, 0x2, 0x0, 0x0, 0xffffffff7e84a300), at 0xffffffff7e6d2948 \n  [7] nni_plat_cv_wait(0x1002d0c68, 0x0, 0xffffffff7e84a300, 0x100143dfc, 0xffffffff7e800200, 0x2), at 0x1000226e8 \n  [8] nni_task_wait(0x1002d0c50, 0x0, 0x100454ce0, 0x1, 0x1002d0c68, 0x1002d0c18), at 0x100020424 \n  [9] tcptran_listener_init(0x100454c10, 0x1002d0a80, 0x1003d3108, 0x10014db90, 0x0, 0x0), at 0x100028da0 \n  [10] nni_listener_create(0xffffffff7fffe858, 0x1003d3108, 0x10003cd18, 0x1002d06c8, 0x0, 0x100454bd8), at 0x10001a47c \n  [11] nng_listen(0x0, 0x10003cd18, 0x0, 0x0, 0x92ea, 0x92ea), at 0x1000152ec \n  [12] conveyMainImpl(0x0, 0xffffffff7fffeb30, 0xffffffff7e84a300, 0xffffffff7e84bf04, 0xffffffff7ffff236, 0x0), at 0x100011bd8 \n  [13] conveyMain(0x2, 0xffffffff7fffec18, 0xffffffff7fffeb30, 0x100143e50, 0x3b9aca00, 0x1033a7663475c0), at 0x1000148ec \n(dbx) \nit's looks like tcp test timeout with a deadlock?\n. and this is the backtrace for nanomsg-1.14:\n-bash-3.2$ pwd\n/export/home/jiangrz/dev/nanomsg-1.1.4/build\n-bash-3.2$ dbx tcp\nFor information about new features see help changes'\nTo remove this message, putdbxenv suppress_startup_message 7.9' in your .dbxrc\nReading tcp\nReading ld.so.1\nReading libmtmalloc.so.1\nReading libnanomsg.so.5.1.0\nReading librt.so.1\nReading libnsl.so.1\nReading libsocket.so.1\nReading libc.so.1\nReading libgcc_s.so.1\nReading libaio.so.1\nReading libmd.so.1\n(dbx) run 5555\nRunning: tcp 5555 \n(process id 4668)\nReading libc_psr.so.1\n^Cdbx: warning: Interrupt ignored but forwarded to child.\nt@1 (l@1) signal INT (Interrupt) in __pollsys at 0xffffffff7e4dc740\n0xffffffff7e4dc740: __pollsys+0x0004:   ta       %icc,0x0000000000000040\n(dbx) where\ncurrent thread: t@1\n=>[1] __pollsys(0xffffffff7fffe788, 0x1, 0x0, 0x0, 0x0, 0x0), at 0xffffffff7e4dc740 \n  [2] _pollsys(0xffffffff7fffe788, 0x1, 0x0, 0x0, 0x0, 0x0), at 0xffffffff7e4cb4f0 \n  [3] _poll(0xffffffff7fffe788, 0x1, 0xffffffffffffffff, 0x0, 0x0, 0x0), at 0xffffffff7e470f70 \n  [4] nn_efd_wait(0xfffffffffffffff7, 0xffffffffffffffff, 0xffffffff7fffe938, 0xffffffff7ee3eec4, 0xffffffff7dd00200, 0x100290170), at 0xffffffff7ed17350 \n  [5] nn_sock_send(0x1002900c8, 0xffffffff7fffe8f0, 0xffffffffffffffff, 0xffffffffffffffff, 0x100290140, 0xfffffffffffffff5), at 0xffffffff7ed11f10 \n  [6] nn_sendmsg(0x28, 0xffffffff7fffea10, 0x0, 0x10, 0x1002900c8, 0xffffffff7ee3ee00), at 0xffffffff7ed0f760 \n  [7] nn_send(0x0, 0x100002fe8, 0x28, 0x0, 0xffffffff7f004000, 0x0), at 0xffffffff7ed0f908 \n  [8] main(0xffffffff7fffeaec, 0xffffffff7fffeb80, 0x1, 0x100002fe8, 0x5a, 0x100103800), at 0x100001ff8 \n(dbx) \n\u00b7\u00b7\u00b7\n. I dont think the tcp test is timeout for ipfilter or any another security extensions. because the timeout was happen on the \"batch transfer test\".\nwhen i add some prints in the code like:\nc\n    /*  Batch transfer test. */\n    printf(\">>>>>>>>>>>>>>>>>>\\n\");\n    for (i = 0; i != 100; ++i) {\n        test_send (sc, \"0123456789012345678901234567890123456789\");\n        printf(\"<<<<<<<< #%d\\n\", i);\n    }\n    for (i = 0; i != 100; ++i) {\n        test_recv (sb, \"0123456789012345678901234567890123456789\");\n    }\nThe output was:\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<<<<<<<< #0\n<<<<<<<< #1\n<<<<<<<< #2\n<<<<<<<< #3\n<<<<<<<< #4\n<<<<<<<< #5\n<<<<<<<< #6\n<<<<<<<< #7\n<<<<<<<< #8\n<<<<<<<< #9\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntimeout happen at the 10th test_send.. I have try to reduce the looping times to 10, the test was passed!\nC\n    /*  Batch transfer test. */\n    printf(\"send >>>>>>>>>>>>>>>>>>\\n\");\n    for (i = 0; i != 10; ++i) {\n        test_send (sc, \"0123456789012345678901234567890123456789\");\n        printf(\"<<<<<<<< #%d\\n\", i);\n    }\n    printf(\"recv >>>>>>>>>>>>>>>>>>\\n\");\n    for (i = 0; i != 10; ++i) {\n        test_recv (sb, \"0123456789012345678901234567890123456789\");\n        printf(\"<<<<<<<< #%d\\n\", i);\n    }\noutput:\nbash\n-bash-3.2$ ./tcp 10005\nsend >>>>>>>>>>>>>>>>>>\n<<<<<<<< #0\n<<<<<<<< #1\n<<<<<<<< #2\n<<<<<<<< #3\n<<<<<<<< #4\n<<<<<<<< #5\n<<<<<<<< #6\n<<<<<<<< #7\n<<<<<<<< #8\n<<<<<<<< #9\nrecv >>>>>>>>>>>>>>>>>>\n<<<<<<<< #0\n<<<<<<<< #1\n<<<<<<<< #2\n<<<<<<<< #3\n<<<<<<<< #4\n<<<<<<<< #5\n<<<<<<<< #6\n<<<<<<<< #7\n<<<<<<<< #8\n<<<<<<<< #9\n-bash-3.2$\nit's possible blocking by some buffer size\uff1f. Thank you !\nWe also try NNG on solaris.\nAnd we found the problem is really related to the send buffer size of the Solaris OS.\nwhen we increasing the send buffer size by ndd command\uff0cthe looping times was extend to 75.\nbut it is no idea to point out how many buffer size is fit to solaris. \ud83d\ude02 . ",
    "dennisklein": "\nI think the AnyNewerVersion needs to change. \n\nI replied to your in-line comment, if you confirm again, that you wish this parameter to be changed, I will of course change it.\n\nI presume you've tested this with importing the package as well?\n\nYes, the code is based on what we successfully use in our projects for quite a while (on various Linux and MacOS platforms). And I specifically tested this PR on my machine (Fedora 28) when installing to (and importing from) system-path /usr/local and non-system-path $HOME/nanomsg. Both worked for me.. If you are curious, you can find more comprehensive and authoritative information on CMake package layout and the CMakePackageConfigHelpers module.. Rebased and applied requested change.. Any updates here?. It is definitely your decision, what it should be, I am not familiar with the version semantics of nanomsg, but consider the following example:\nThe msgpack project also decided to use SameMajorVersion and if I want to express in my project, that I need version 2.1.5+ and that msgpack is required, I ended up writing this code:\ncmake\nif(NOT msgpack_FOUND)\n  find_package(msgpack 3.0.0)\n  if(NOT msgpack_FOUND)\n    find_package(msgpack 2.1.5 REQUIRED)\n  endif()\nendif()\nYou can see, that I will need to modify this code for every major release of msgpack.\nWhile I agree with you that choosing SameMajorVersion is semantically more correct, I would recommend against it, because of the shortcomings of the find_package command on the user end.. Yes, the EXPORT property is only needed when installing targets for which an export set should be generated and installed (a file written in cmake that lists all exported targets and is meant to be imported by the consumer).\nNext to the export sets, you can have these two special top-level files in your CMake package. *-config.cmake is meant to export all sorts of information that might be useful to your user (main entry point). *-config-version.cmake implements how  the user-supplied version (e.g. find_package(nanomsg 1.1.4)) is evaluated. In this PR I use the standard implementation shipped with CMake (it relies on the CMake built-in operator VERSION_GREATER|EQUAL|LESS). But if you wanted to implement a custom order on your versions, you could replace the call to write_basic_package_version_file(...) with your own file.\nI tested that the default version handling implementation from CMake works with all possible NN_PACKAGE_VERSIONs, They can have the format 1.1.4 or 1.1.4-3-g45h5kj5 or 1.1.4-3-g45h5kj5-dirty as far as I could see.. ",
    "lobocv": "Looks like NNG contexts may take a lot of this headache away. \nMy plan is to change my middleman to use nng instead of nanomsg. Client and GoLang database services won't have to change.\nI very much appreciate your time Garrett, thank you!. ",
    "gonzalovinas": "Plus, received message has 9 more data-bytes filled with zeroes... before actual payload... also .. wondering whats the purpose.. \nI couldn't find any doc on this... maybe should I refer to zeromq's spirit?\nThanks in advance . ",
    "GuiRCN": "Thanks for your answer.\nI use tcpdump eth0 my port on the Linux where my subscriber app deployed. When the publisher crashed, \nI receive a series of FIN packets from the publisher machine, but return nothing to it. The tcp connection remains flagged as ESTABLISHED which should be CLOSE_WAIT. It looks like the FIN packets were dropped by TCP/IP stack for some reason. \nToday I set SO_KEEPALIVE in my subscriber app, and the reconnect behavior can correctly perform now.\n-- GuiRCN . ",
    "363568233": "\nI would need to have more information here. Can you provide a snippet of your code, how you're sending?\n\nbasic  IPC REQ_REP   nn_send and nn_recv   blocking mode    . The server has just closed, then this error occurred on the client.   Just  once appeared,.     boost::shared_ptr pack((char*)je_malloc(pack_size), je_free);\n    if (!pack)\n    {\n        return error_bad_alloc;\n    }\nchar error_msg[128];\nif (!encode(pack.get(), pack_size, g_uuid.c_str(), g_group_uuid.c_str(), operation, key, value, value_size, error_msg, sizeof(error_msg)))\n{\n    return error_encode;\n}\n\n//send\nif (-1 == nn_send(sock, pack.get(), pack_size, 0))\n{\n    return error_ipc_send;\n}\n\n//recv\nbool ret = 0;\nif (-1 == nn_recv(sock, &ret, sizeof(ret), 0))\n{\n    return error_ipc_recv;\n}\n\nif (!ret)\n{\n    return error_ipc_rep_req;\n}. Today,  this problem reappeared once .  The client send msg and recv reply success, but when I use \"Ctrl + C\" shutdowm the server, the client crash because of the assertion.\n\nAssertion failed: !self->pipesendbuf   file: nanomsg-1.1.5\\src\\aio\\usock_win.inc : 413. I changed my code, there are two socket... Oh, I find setting socket option NN_SURVEYOR_DEADLINE can decrease the wait time, but I think that the surveyor mode is not suitable for my situation,   I want to high-efficiency pub sub with respond, but testing req and rep mode is not high-efficiency,  could you give me some advices? Please.. The Bus mode is only to local level (within a single machine or within a single LAN).\nNow, I'm going to use the req-rep multiple sockets. \nThere is another question,  nanomsg can't get remote endpoint's IP?  the same as zmq?\nIt's only get remote ip within data.. I want to compile my exe  link static library all. Because I would run it  in different versions of GCC. I find a explanation: \nglibc uses libnss to support a number of different providers for address resolution services. Unfortunately, you cannot statically link libnss, as exactly what providers it loads depends on the local system's configuration.\n. I add NN_STATIC_LIB in preprocessor flags in my project, but  error LNK1120:  unresolved external \n _AcceptEx@32. AcceptEx is in Mswsock.lib, so I add   #pragma comment(lib,\"Mswsock.lib\") in my code,  It's ok.  Am I right to do this?. set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fPIC ${NN_WARN_FLAGS} ${NN_COVERAGE_FLAGS}\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fPIC ${NN_WARN_FLAGS} ${NN_COVERAGE_FLAGS}\")\n. ",
    "derick-schoonbee": "Oups.. need move this to the 'nng' project and not 'nanomsg'.. ",
    "gmd20": "There is a bug in my program,  too many fds are opened but never being fclosed,  so at some point it reaches the \"max open file limit\" and accept4 always return -1 (errno -24). \ntext\n    /*  Some errors are just ok to ignore for now.  We also stop repeating\n        any errors until next IN_FD event so that we are not in a tight loop\n        and allow processing other events in the meantime  */\n    if (nn_slow (errno != EAGAIN && errno != EWOULDBLOCK\n        && errno != ECONNABORTED && errno != listener->errnum))   // errno ==  listener->errnum == -24 at this line\n    {\n        listener->errnum = errno;\n        listener->state = NN_USOCK_STATE_ACCEPTING_ERROR;\n        nn_fsm_raise (&listener->fsm,\n            &listener->event_error, NN_USOCK_ACCEPT_ERROR);\n        return;\n    }\n.  . ",
    "vlisivka": "Small delay (5, 10, 50, 500ms) makes no difference in loss ratio.. @gdamore I already posted test case with nanocat. This bug is hard to reproduce. I'm lucky that I can reproduce it using nanocat.. I noticed that variant with nanocat does not trigger problem on Yocto/armv7 with custom kernel right now. Test case triggers problem on Fedora-28 and MacOS El Capitan. I'm surprised, because we found this problem on Yocto, but I was unable to reproduce it on Fedora using C code.\n. When --delay 1 option is added, nanocat hangs on 2-4 invocation:\n[vlisivka@apollo5 download]$ ./test-nanomsg-first-msg-lost-bug.sh\n+ (( I=0 ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n+ (( I++ ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n+ (( I++ ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n+ (( I++ ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n^C\n[vlisivka@apollo5 download]$ ./test-nanomsg-first-msg-lost-bug.sh\n+ (( I=0 ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n+ (( I++ ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n^C\n[vlisivka@apollo5 download]$ ./test-nanomsg-first-msg-lost-bug.sh\n+ (( I=0 ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n+ (( I++ ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n+ (( I++ ))\n+ (( I<100 ))\n+ nanocat --push --connect-ipc /tmp/pull-socket.ipc --data 123456 --delay 1\n^C\n[vlisivka@apollo5 download]$ uname -a\nLinux apollo5 4.18.16-200.fc28.x86_64 #1 SMP Sat Oct 20 23:53:47 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux. First, to clarify, I'm professional developer with 20 years of experience. I completed more than 30 projects and used more than 20 languages over two decades. I'm PhD in Computer Science. Blah blah blah. I just trying to say that I'm experienced enough.\nI this test case, I'm not trying to test nanomsg under high load. I'm just trying to catch rare bug, so I need to do lot of repetitions.\nI tried --delay 1 option at work, and nanocat hanged at 10th call. I killed it, then installed nanocat-debuginfo and nanocat-debugsource packages to debug nanocat with gdb. Unfortunately, I'm unable reproduce this hang after 3+ thousands of repetitions, while I was able to reproduce it at home 3 times in a row. I use Fedora 28 both at home and at work. I will try to reproduce problem again. Hangs are easier to debug than random message drops.\nAs I see, --delay 1 option does not help me: only about 80% of first messages are delivered at average.\nI suspect \"use of uninitialized value\" bug, compiler optimizer bug, or kernel bug (e.g. recent fixes for Meltdown). I will try to find source of this bug when I will have free time because it affects me.\n--receive-timeout option for listening nanocat is added for clean shutdown of nanocat. It can be removed and nanocat can be killed instead, so TIMEOUT variable will be unnecessary. However, good test case should be clean, without killing of processes, because it will test abnormal path instead of normal path of work.. I know who you are, and I respect your work. It's why I'm asking for your help. I just trying to say that you can trust me when I say that test script works as intended and contains no errors.\nI tried to use valgrind, ltrace, strace with following results:\n\nwhen nanocat client is ran under valgrind, no errors are found and 100% of messages are delivered each time.\nunder ltrace and strace, 96-100% of messages are delivered, i.e. error rate drops by order of magnitude.\n\nI modified test script to catch missed message early and stop, so I can inspect output of ltrace and strace. \nI see no deviations in ltrace -f output for both cases, when message delivered and when it's not.\nOutput of strace -f for nanocat client  is long and interleaved, but, as I see, all reads and writes are ended successfully in both cases, so data is transmitted to pipe.\nI will try more tools tomorrow.\nCurrently, I suspect that it may be caused by time adjusting (maybe I have very bad HW clock which need constant adjustments?), so it may affect clock_gettime(). I will try to use Linux specific clock, e.g. CLOCK_MONOTONIC_RAW or CLOCK_BOOTTIME.. ",
    "webbery": "It seems not easily to use for developer. Here is the link about boost.fiber in boost.asio.\n. ",
    "Slzde": "today\uff0ci find that if it nn_send without interval \uff0cit will recv only one msg\uff0cit is a bug\uff1f why \uff1f \ntest between process  pub/sub. emmm\u3002\u3002i'm sorry to give you a bad experience.\nand i will submit my general code\nhttps://paste.ubuntu.com/p/SdCcNnqpfV/\nmaybe you should use VPN to visit the website. I don't know\n. ok\uff5e  i get it\u3002\nthank you \u3002\nI am sorry to disturb you. \nthanks  again\uff0c. yes  thank you'\n. ",
    "jzaicn": "Thanks for your reply, it may have been my fault. Sorry for bothering.\nIt seems that using bus socket in the ipc socket will lose some messages.. ",
    "kavikumarN": "Hi thanks for the reply. I have tried NNG too. But the emscripten doesnt support Cmake Ninja. with Nanomsg i have used typical build system ie., \"emcmake cmake nanomsg\"  to build. No tests were run successfully. . yes, i have tried with nng,nanomsg and zeromq to build with emscripten environment. It fails to run as a c /c++ binding. Now i am trying to run zeromq externally from node binding, although it works but i would like to execute it from c/c++ environment.. ",
    "Fidelin50": "Thank you!. Yes, you are rigth but when i compile  library with the toolchain (TrueStudio), it gives more errors.\nThe doubt I have is the following.\nWhat code do I have to take to compile the library? The src of github?\n. "
}