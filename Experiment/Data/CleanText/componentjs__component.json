{
    "tj": "ah thanks :D\n. https://github.com/component/registry\n. meh fuck it just adapt the existing thing\n. low priority (GITHUB ADD PRIORITIES BACKK))\n. actually yeah hahaha so do I :D\n. that's the case for me with a few as well, I just clued in that I'm already using index.js for other reasons so I'll definitely need to add this soon. Unfortunately it does add a bit more complication to the require() implementation since we can't actually just \"rename\" it to index.js internally because relative paths will fail, but oh well\n. i'd like as little magic as possible personally, so you would still reference the main script in scripts, and then tell component which one is the \"main\". Originally I had thought of just having \"main\" default scripts to an array with itself inside etc but that's just extra stupid junk to explain and to implement if you're building the tools, it's easier to just say scripts must always be defined\n. done\n. they're not namespacing like GH so closing this\n. suggestion from Patrick Mueller that I like was to explicitly state the registries in your root component.json etc instead of a dotfile\n. yeah that would be pretty cool\n. yeah that's what my gut says, oauth is really lame haha, it would be nice definitely, but it's also pretty GH specific, whereas the \"username/project\" portion is still specific but trivial to set up with only a file server\n. -1 to git urls though, we aren't even doing git clones, just fetching the files directly it's muuuuch faster\n. ah cool, yeah basic would be much more reasonable\n. it would just be precedence:\njs\nregistries: ['http://localhost:3001', 'http://localhost:3002']\n\"ui/dialog\" does 3001 have it? nope check 3002, nope check github\n. the side effect of \"magically\" doing it that way with simple precedence is that say for example you were using component/calendar and you wanted to fix or add something quickly, you could simply pull it down to your local file server, make the changes, and automatically anything using component/calendar in your batch of components would get these changes\n. yeah slight overhead for sure, it should be pretty minimal but i'll have to try it out with a few and see how it is, we can also implement https://github.com/component/component/issues/47 which will speed things up even more so it might not be a big deal\n. I dont think so, at very worst just name it something weird / specific like mycompany/tip\n. it's ugly but otherwise there will be require() collisions, from what I can think of it's either that or we fight over names and set up yet-another registry for no reason haha. Tough call.. we can see how things go with \"name\" being whatever you like but I can definitely see issues with this\n. we need to figure this one out early though before all hell breaks loose later haha\n. hahaha yeah, we could use a registry for referencing names only, no file stuff like npm but just register your name and then you're screwed if you want to use that same name. Then we can grab tags etc from the github API so no need to store all of that in the registry\n. Another example, since things like this will definitely spawn. With a registry you may have:\ntip\ndialog\nbootstrap-tip\nbootstrap-dialog\netc, without:\ncomponent/tip\ncomponent/dialog\nbootstrap/tip\nbootstrap/dialog\neffectively the same thing. Another problem though however is say for example you have some\nrepo named visionmedia/page.js and you want require('page') to work you'd have to change \nthe repo name... not so good\n. another possibility is that we emulate nested \"node_modules\" when doing the require.register(name, callback) calls. This would mean that you can have component/tip and bootstrap/tip as deps, however both are required using require('tip'), basically expanding to require('./deps/tip'). These would basically act like symlinks, the code for each \"tip\" itself would only be present once\n. yeah that's true, that would be a weird edge-case\n. k added that to the require implementation. If it's not available in the \"./deps\" pseudo dir it'll fail so the builder will have to expose deps that way\n. the user wont see that anyway, it could be ./components or whatever we want, even something ugly like __deps__ would separate better for debugging haha\n. personally I dont find most of the package.json fields all that useful anyway, personally I dont care who wrote it (author / contributors etc), if it's good code I'll use it. We likely wont even need the version field, keywords + description would be nice for search, name we'll need because for example visionmedia/page.js might want the name \"page\", or \"foo/popover-component\" may want \"popover\". repository prop is no good for us here either. Some people might not like having two files but I dont think it's the end of the world really, at least it's easy at a glance to say hey ok I can install that thing\n. reading both is a little messy I think. I'm fine with going with package.json as long as we can come up with some conventions that dont step on existing uses, and dont have really lame names haha\n. ah I see. Yeah that would be reasonable, in general though I think one solution is better than more options, even if it means we always use \"component\": in package.json\n. yeah I guess the issue we're talking about isn't really much of an issue haha, copy / paste and you're done.  Maintaining a \"version\" in each is really the only annoyance, and that's pretty minor. We could definitely grab package.json contents for component create . or sth\n. one async call what?.. versions change.. even if you grabbed this info the first time you still have to maintain it\n. no one said it was hard, but it's additional work and relatively pointless, it's just an extra thing we have to document and expect other implementations to do\n. well I think we've generally reached a consensus, at least until someone has a strong argument one way or the other. I'll close this for now\n. good call\n. hmmm I sort of feel like if it's private and local that it should be checked into the SCM. For example at LearnBoost we have ./node_modules and ./lib, where ./lib contains regular node modules but they are specific to our app. There's little benefit in \"installing\" those from elsewhere on the disk IMO, at least I can't think of anything.\n. yeah npm link is pretty handy, can't disagree with that\n. component likely wont have \"global\" installs so we cant have link, but https://github.com/component/component/issues/26\n. +1\n. https://github.com/component/component/issues/6\n. haha yeah +1, I'll go through an humanize the more common errors\n. closing for now, we can get more specific as we go\n. yeah that part really depends on the app I suppose. Most apps I've worked on really had no more than 2 or 3 distinct sets of assets, differing say for an \"admin\" section and public facing site, so I dont think that will really be a huge issue, we'll have to see\n. closing for now, I'll detail some different patterns in the readme hopefully soon (or on a site)\n. aliasing is 100% necessary, no way around that, but I think if we need two separate builds there's something wrong with the application, or we need some way to facilitate this better, there should pretty much never be a time to require from outside a component\n. I dont disagree that multiple builds should be a possibility, but I think it would be best to have N \"boot\" components, each with their own deps so that you're never require()ing top-level\n. hmmm should be able to do for example component build --name homeand regular component build as examples of two, however yeah you would need two component.json files, one for each \"page\". largely it's a non-problem between loading scripts after content and gzip, plus you could always have facebook-primer style js that initialises crucial things before the rest is loaded\n. our js before/after gzip:\n1.2M    public/build.js\n260K    public/build.js.gz\nso it's less than a jpeg\n. the thing is that your app should be comprised of components, nothing but components. so you'll never really have ../ requires at all, because your app component(s) will have their own dependencies, thus you'll just do require('jquery'). It's not super clear without docs etc but I'll try and write some up and do a few more screencasts soon to make things easier. Basically you think of your app as components, not just using components, this gets into the fundamental flaw of rails-style infrastructure, where you use modularized deps, but your app itself is monolithic and tightly coupled\n. try require('underscore') and require('backbone') the verbose names with - are the \"root\" level ones but you'll never actually need to require those, they're aliased as \"underscore\" and \"backbone\" for within your component only (so they dont conflict with say documentcloud/underscore vs visionmedia/underscore, that sort of idea\n. hmm can you gist the build.js file?\n. ``` js\nrequire.alias(\"component-jquery/index.js\", \"pomodoro-watch/deps/jquery/index.js\");\nrequire.alias(\"solutionio-countdown/index.js\", \"pomodoro-watch/deps/Countdown/index.js\");\nrequire.alias(\"component-underscore/index.js\", \"solutionio-countdown/deps/underscore/index.js\");\nrequire.alias(\"solutionio-backbone/index.js\", \"solutionio-countdown/deps/backbone.js/backbone.js\");\nrequire.alias(\"solutionio-backbone/index.js\", \"solutionio-countdown/deps/backbone.js/index.js\");\nrequire.alias(\"component-underscore/index.js\", \"solutionio-backbone/deps/underscore/index.js\");\n```\nhmmm seems to be aliasing fine, require() should get those, not sure where pomodoro-watch is coming from\n. ill have to look at it later, but yeah you should never need to use ../\n. yup if you watch my screencast it kinda explains why the root component needs the prefixes. It's simple but kinda confusing to explain, you can get around it by having a root-level component and do require('boot') or require('app'), but in short it's because aliases are only set up for components and their deps\n. no worries! that just means I haven't explained it well enough, no big deal. some diagrams or something might help, it's a little weird until the aliasing part makes sense\n. for any specific commands? build could use more verbosity, install is reasonable I think but wouldn't hurt to add some more\n. closing for now we can add to specific commands\n. havent really been necessary so far, maybe we're not complex enough\n. nvm\n. ah that's not good!\n. f76e37c\n. fuck it, use bundledDependencies \n. what's a \"soft\" dep?\n. ohh we dont want that! extending is obscure / bad\n. in general I agree with @shtylman but part of me also feels that if you API changes it's technically a different lib, especially since these components are all so small, if you got the API so wrong that it needs big changes chances are it's quite different, but that of course would still happen from time to time. I love \"\" at this point in time simply because the entire project is in flux but since we wont be querying which versions are available you'll only have the choice of \"\" or an explicit \"n.n.n\" no \"n.x\" etc\n. haha yup, easier to trust yourself. We wont have duplicates at all, component will just be in an error state and warn you if there are conflicts that need resolution, I dont even really want to entertain the idea of dups. We can just check if the semver stuff is out of range and warn\n. closing this for now, pretty minor and until we have the linter I dont want to go change 100+ components haha\n. yeah this stuff is excluded for now, things get a bit more opinionated when it comes to serving files, we'll have to figure out some reasonable defaults but for example we just iterate files and serve them using res.sendfile() so they stay where they are, but there's a lot ofways to handle this\n. would be a fun proof of concept but meh\n. yup definitely one of the issues. Our app has regular node modules in ./node_modules and our private ones in ./lib and we use NODE_PATH, but since everything in our ./lib right now are components we'll eventually need to migrate over to component.json and have a similar lookup path mechanism\n. need some tests still but this sort of idea should work now:\n$ COMPONENT_PATH=../components\n$ component build\nwith\njson\n\"bundled\": [\"foo\", \"bar\"]\nI really want to change bundled though I dont like that name at all, local ? i dont know\n. hmm if you're running component build in that app dir COMPONENT_PATH=ui should be fine\n. and then say bundled [\"foo\", \"bar\"] where those are ui/{foo,bar}\n. hmm that should be fine still, I only did one quick test, I'll add some real tests later tonight\n. make is just a default for create, you dont actually need it, it's just a great tool. I'd be really surprised if windows didn't have some kind of make implementation\n. if there's something comparable we can add a flag to component-create down the road\n. personally I dont want to get into that because it's a separate concern really, I dont want to write a whole build system, npm doesn't even handle that, actually I dont think any js 'build\" tools handle targets correctly\n. hmm! not good, is the which() call returning anything? (in bin/component)\n. hmm i dont have a windows vm so i wont be able to reproduce but i'll see what i can do\n. the customfds just let you change the stdio file descriptors, so that the component-* commands in this case use the same stdin, but I think since node abstracts away FDs they want you to just pipe() shit around\n. @Raynos cool I'll have to check that out\n. damn maybe we just need to add which() back then, I have zero windows knowledge, I figured you guys had a PATH alternative\n. seems like something core should be taking care of in some way or another, seeing as the whole point of all this windows stuff is to have \"transparent\" compatibility\n. yeah it's pretty annoying, I'd rather ditch windows all together than have to deal with a bunch of junk that node is supposed to take care of\n. yeah our exec() is more like system()\n. I think windows is fail :D haha but yeah, I'm fine with it as long as we can minimize the amount of hacks within our source, at very least moving that sort of stuff to npm\n. @ForbesLindesay did you try which() after this new stdio option?\n. isaac's \"which\" module is like the which command, gives you a full path for an executable, he's got a bunch of windows handling stuff in there. I originally removed that because this is quite a bit faster but fails on windows I guess, I'm just wondering if we add which back to resolve the bin, and then spawn if it'll be fine\n. going with your patch until node resolves this or we have some other alternative that works, thanks!\n. full name should be fine, that's something that will have to be part of the \"spec\" so it's not going anywhere\n. im not sure what those ones look like\n. oh, I'm not a fan of that style of markdown, the underline thing is really annoying compared to #\n. what we currently have is fine. component-create(1) is meant for any empty dir, we could maybe havecomponent-initto create the component.json in an existing dir\n. hmm yeah we could at very least support./, or at least warn, even though it's a tiny \"feature\" I'd still like to support fewer things in favour of us all doing the same thing, otherwise it's just one more thing to add to the spec, I'd like to keep that as minimal as possible \n. closing for now, I don't disagree on stripping./but we'll see how many people end up doing this :D if it becomes an issue I'll go ahead and add this part\n. @ForbesLindesay yup :D that's the plan, should be pretty cool. We could possibly even detect if they're using say.classList` directly and suggest that they use the \"classes\" component\n. that would be cool too, component/lint could house all that stuff, whatever we want really I suppose haha\n. @adamsanderson cool! a command would be great too, I was thinking more of a script that works off of http://component.io/components/all and opens issues on github fixing things etc haha, but yeah a command-line tool would be great\n. haha nice, I use the words from the description as well so that's usually enough but keywords dont hurt.\nright now there's only http://component.io/components/search/ui for search queries and http://component.io/components/all. I'll remove the /components/ prefix soon\n. sweet ill have a look soon \n. haha yup, 4 or 5 max maybe, or we can prompt continuation if it's over that\n. I will only personally continue publishing the ones I have been to npm for the next maybe month or so until we migrate over, though it's not super difficult to maintain both so I might just continue pushing to npm as well, we'll see, you're stuck with gross -component suffixes for npm though unfortunately (in most of the cases at least, some are fine, color-picker and a few were not taken)\n. Classes is in npm, but sure if you want to rewrite them that's fine by me\n. That's one reason I prefer the gh namespace model, no collisions ever I don't have to name it classy classify classes-component haha, ya pkg managers suck :( \n. You don't use usernames in code, just as deps, you still require tip or dialog etc\n. to me it's a pretty decent win using github:\n- no extra credentials to maintain\n- more stable\n- faster\n- name things whatever you want\n- still require them as you would with npm\n- immediately obvious where a package resides when you see it as a dep\n. @Raynos they're aliased to pseudo ./deps dirs, so one component requiring component/tip could require('tip'), and another could require foobar/tip in the same way. You couldn't use both in the same component, but if they're named the same it's 99% likely that you wouldn't want or need that anyway. I almost wish npm did it this way, could rid a lot of the stupid ambiguous names in there\n. there's no advantage to using npm, I do not want to prefix / suffix everything either, sorry but npm is a no-go there's several advantages to not using npm and none for using it, other than the fact that node people already use it which is a pretty poor \"advantage\". Hell why not use gem(1) ?? let's just use brew?\n. I dont feel the need to repeat my reasoning over and over, there's literally no advantage to using npm other than for node folks who feel that it already is important, any other ecosystem would say the same about their package manager. Component(1) is faster, has search that works, requires no secondary credentials like npm does to manage, solves the namespacing problem elegantly, private \"registries\" are as easy to set up as a file server. What does npm get you? nothing but ambiguity, hmm which packages are components, who knows, have fun filtering them all. People from other environments would complain about npm just as you're complaining about not using npm, it's no different than me forcing you to use gem(1). I like npm, I'm not bashing it or anything, it just makes very little sense to use for this sort of thing.\n. this argument is not going anywhere, I'm not going to use npm sorry it makes no sense to me\n. I'll continue to publish some to npm with the ugly -component suffix, closing.\n. I agree / understand that everyone would see it as a frustration as node users, and npm is great dont get me wrong I'm just coming at it from a different point of view, I'd like to make the thing as environment agnostic as possible. Right now of course the only implementation is using node anyway, but eventually if people like it they'd easily have \"native\" versions of component(1). There's almost no argument for or against npm, they're both convenient and inconvenient for different reasons. I wanted to even broader originally but my use of common-js kind of screws that over, lots of people will prefer AMD etc.. so for now I'm just building what I personally want in a dev environment, it wont be for everyone\n. yeah we're pretty screwed as far as things like emitter-component and emitter goes, Guillermo has been using a lot on the server/client as well and needs to do the same try/catch dance, no way around that with npm's namespacing really. I've had this issue with a few as well, set and set-component etc. The main problem with browserify IMO is that you really have to rely on polyfills, and even then there's a good chance what you're using wasn't designed for the browser and will have strange failures or edge-cases, or just a bad browser related API, I dont think that's the right way to go personally.\n. I dont think it's that simple personally, but if it's working for you go nuts! Nothing wrong with that\n. i've mentioned them many times, I'm not discussing that part anymore. As for using them in npm yeah I guess you could have something like you mentioned, though you probably wouldn't want to call it require if you're mixing and matching require stuff with -component stuff\n. even if the only reason was simply that this project has nothing to do with node, that's enough of a reason for me\n. sure? that doesn't bother me at all, if it's a client-side project I'll use it in the browser, if it's node then I'll use mocha(1)\n. yeah that part is not super easy right now, but since they're designed for the browser they should be tested in browser(s) or phantomjs etc. I do use mocha and node to test a few of the more simple ones but that breaks down with deps like you found. I dont think this is really a component specific issue, it's more or less the same issue any non-node environment faces\n. in the future I'd love to normalize all component testing with a test-swarm type of tool, but that's definitely not on the immediate list of things to do\n. not really sure anyone will do this... uber low priority\n. yeah depending on the theme these can look pretty bad but it's not a big deal, will close for now\n. extra +1, ill do this as a separate thing though, it's a bit opinionated for component(1), but definitely, can barely work today because of the npm downtime\n. https://github.com/component/component-mirror\n. typo\n. very little affect on things right now, closing but we can re-open once we have MILLOINS OF COMPONENTS\n. 32% faster, just need to implement the real deal\n. HIGH PRIORITY </wishes-github-kept-that-shit-what-the-hell>\n. -1 from me becauuuuse this would typically be deployment thing, which is super ad-hoc\n. yeah tough call.. ideally we try to stay away from english etc but obviously that's not alway possible haha. I guess each component just needs to expose maybe an object containing the strings uses so they can be swapped, or we can try to get everyone using something like https://github.com/component/t, tough call. As long as they can easily be replaced then the application can handle the rest\n. there wont be anything integrated, probably best that we just provide some option(s) per component.  Maybe we just do stuff like:\njs\nexports.strings = {\n  category: 'Category',\n  ...\n}\nand reference those. There wont be mustache or anything built in but I wrote https://github.com/visionmedia/minstache to have super light-weight stand-alone view functions that we can compile beforehand\n. yeah that works, I think this part will be pretty ad-hoc, what we do is loop through out component.json files, grab the filenames and set up matching routes with express and res.sendfile(), definitely more than one way to solve this portion\n. I originally created rework for the css manip stuff, I'll try out a few things at least as reasonable defaults. This does get a bit more complicated depending on how you use components\n. even a simple regexp would do we dont really need rework for that part but i had other things in mind for the future. just need to figure out the least leaky abstraction possible for this\n. by default in --dev this will prefix urls with ./ so that they work with file://, and without --dev they will not be prefix so you'll end up with urls like /my-component/images/maru.png, and I added --prefix url for cases like /public/my-component/images/maru.png depending on your serving technique\n. well you wont want to PUT the data to a cdn each time you change something in dev, that would be a separate build when you're deploying. if you disable url rewriting with component they simply wont point to the correct files, but nothing else changes\n. looks like they have a similar urls, the only part that might not work ATM fetching the \"raw\" file data, that would have to match github too currently: https://github.com/component/component/blob/master/lib/Package.js#L48\n. https://github.com/component/component/blob/master/lib/Package.js#L84\n. this is low priority for now but perhaps in the future we can provide some sort of mapping so that alternative sites like this can \"just work\"\n. @godfryd it's not github centric, urls are just urls, anything can have the same simple set of username/project urls, this is just low priority that's all\n. closing for now, we likely wont support url-mapping out of the box but there's multiple registry support now so it would be easy to proxy to a service like this\n. hmmmMmmMmM tough call, we're juuust getting components started so 0.8.x+ might be fine but this is small so I'll pull and we can remove when the next node comes out\n. fixed\n. yeah we need a different command for setting up component.json, component init or sth\n. maybe we should just tweak create like you say, looks a little weird component create . but meh haha relatively the same code anyway. We could also grab some info from package.json if it's present, description / keywords\n. that's a nice thing about components, fork and change the username and you're done, vs renaming to jquery2 in npm or something and changing your code, but yeah I'll have to update sometime soon\n. not really, it's only annoying for things like jquery that may not adopt component.json etc, the rest is a walk in the park, jquery is the exception here not the rule\n. yeah and a lot are not commonjs anyway so they rewrite x-browser boilerplate over and over and over\n. somewhat of a meh from me, I really don't want to special-case node or npm in any way, most that work with node require changes anyway to become x-browser compatible, not something I'm overly concerned about really, adding one file wont kill anyone, and if they dont want to add it forking doesn't really harm much either\n. added\n. no.. this is staying, it's not useless at all, I'd rather not require('component-*') every time \n. everyone complains lol that's a terrible convention\n. all namespacing is codesmell IMO, ruby, c++ etc are all brutal for this\n. eventually that wont matter, everything I'm using jquery for internally right now will be replaced pretty soon\n. by default it's using \"name\" but i added --standalone [name]\n. cool :) I will try and review this after work\n. @deedubs added basic auth support to component(1) yesterday\n. we'll have to come up with use-cases as we go along, we could beat it with a stick forever trying to nail down use-cases that may not even exist\n. yeah tough call.. I always want the default remote to be github, however we could maybe do:\njson\n{\n  \"remotes\": [\n    {\n      \"url\": \"http://localhost\",\n      \"auth\": {\n        \"user\": \"someone\",\n        \"pass\": \"something\"\n      }\n    },\n    {\n      \"url\": \"https://github.com\",\n      \"auth\": {\n        \"user\": \"mygithub\",\n        \"pass\": \"accountstuff\"\n      }\n    }\n  ]\n}\nit would add an extra layer of indirection but i guess basic auth creds for non-private repos doesn't make sense either so this should be ok\n. actually I guess https://my:creds@github.com would be fine haha\n. cool man! I'll try and review this tomorrow or monday. IMO we should go with either user:pass or the normalized object one instead of both. We could reduce \"remotes\" to an array of urls at that point, though I'd worry about that being a bit leaky, so I'm sort of leaning towards the object\n. refactored a few things, im still not happy with some of component-install but we can clean that up later\n. doesn't necessarily have to be, I can route with nginx, might as well leave that part as-is for now\n. might actually leave this as-is for now\n. yup it does cascade ATM, tough call, you might be right maybe it makes more sense to not cascade that option, I can't think of an immediate case where that would cause issues to change\n. yeah I agree with you guys, I'll adjust this\n. maybe we should force the name arg, I can see us having to point this out in the future quite a bit haha\n. made it required\n. i have to add some hooks into https://github.com/component/builder.js still to allow for this sort of thing\n. yeah for public stuff transpilers should rarely be used, if they are then they should be compiled\n. i had to remove this because of editor or os bugs, I didn't look into it too much but basically it was triggering the install at all times on osx for me at least\n. yeah that was my guess, textmate does strange things haha, i'll leave this open for now because otherwise I agree this would be nice\n. nope hahaha, just going to add it so i remember to figure out what was going on\n. yup im going to try and make the bins basically just the output formatting and move the rest into ./lib\n. im not against symlinks (I use npm link at times as well), but I do think it's an anti-pattern. App-specific components belong as part of your app, others should be tested well enough that they dont need to be linked to your app for testing\n. closing for now, we can do a full rewrite some day when time is plentiful haha\n. +1 other is getting too large\n. that wiki page is mined so we need them all on one page, but the note at the top should be enough, people will still use backbone etc until we have more things ready like component/dom and so on\n. closing for now, we can come up with more categories as we go along\n. im not concerned about bower, it does suck that we have two formats going but oh well i guess we just can't use those libs\n. closing for now, not much we can do about that unfortunately\n. @bitmage bower components wouldn't work anyway, our stuff uses commonjs theirs are just regular globals so dependencies would all fail etc\n. it doesn't do anything, we dont want that sort of stuff, they're usually poorly written and have deps on other globals so it's a bit hopeless \n. in general though this would be bad practice. it's so tempting to say have enumerable be an optional dep of Set:\njs\ntry {\n  require('enumerable')(Set.prototype);\n} catch (err) {\n  // ignore\n}\nso if you want an enumerable set you just simply add it as a dep to your app, along with set, however this sort of \"global\" mutation is really an anti-pattern, as tempting as it is this promotes delocalization and should be frowned upon in general. that being said, for things like fallbacks (json / json-fallback) this is a very nice simple solution.\nnote to self: document this in wiki\n. why doesn't try/catch work? Fundamentally it's odd to support numerous things, I think that's a bad pattern that we should attempt not to do but there are definitely some cases for it, fallbacks mostly. Even if you just choose one selector engine to favour it's not much of a problem since components are smaller it's not much overhead\n. yeah true good point that works, doesn't need to be so magical\n. yup :)\n. closing, mostly a non-problem now \n. @beaubrewer do you have a component.json in the directory you're executing that in?\n. you need a ./component.json to do the build, component install [names...] isn't really all that useful in practice, much like npm install foo isn't, list the deps in ./component.json\n. it may even be worth removing [names ...] all-together actually\n. even npm's install with a list of names is silly really, it's never useful\n. (beyond installing executables). our case is definitely different since we need to perform builds. we could go ahead and build straight from a readdir() but there's really no reason not to just list them in a component.json\n. hmm weird ill look into this\n. weird it's definitely there:\nredis 127.0.0.1:6379> SMEMBERS word:autoscale-canvas\n1) \"component/autoscale-canvas\"\nredis 127.0.0.1:6379> SMEMBERS word:canvas\n 1) \"component/autoscale-canvas\"\n 2) \"component/rounded-rect\"\n 3) \"component/convolve\"\n 4) \"component/simplify\"\n 5) \"component/thumb\"\n...\n. ah i think i know\n. fixed\n. damn offenders! haha, need to write a linting tool that will send pull-requests to these libs\n. yup this is definitely on the list\n. ef85f97\n. https://github.com/component/component/commit/934cc2c2683559a537c6efd8f55e9e2ec1ef775d\n. yup I'll try and do this soon since the project is nearly \"ready\". We have over 300 in production already, private + the public ones here and many more to come. As far as component life-cycle that's all up to the component, there will not be any \"first class\" support for such things but there's no reason the js couldn't handle these things\n. component itself isn't even concerned with that sort of implementation detail, that's part of why they're so attractive though you really just do whatever you want. More opinionated concepts like ui component composition etc can live in higher level components, but \"base\" components like say component/{calendar,tip,popover,dialog} etc should not be coupled with any higher level concepts or frameworks. That's what I'm trying to get away from, to me it's bad practice to couple with ember, backbone, jquery, etc, we should just be sharing javascript\n. closing for now, i've got a bunch of doc stuff to do later\n. we do but you wouldn't have to, i'll document all this stuff when we're closer to a 1.0\n. this has been fixed recently, 0.5.0 should be fine\n. i'd like to minimize this sort of thing since there are endless ways we could install components, easy enough to fork like we've done at component/jquery etc\n. it is over http right now, but more implicit instead of absolute urls so we're not coupled with github\n. meh\n. cool! maybe what we should do is grab the readme as part of the wiki -> search population, and expose those via component.io\n. yeah i'll need to fix this for search haha, that explains why all the stars went away. not really a component issue though, just use your github creds with basic auth\n. ah haha yeah that sounds about right\n. yeah I think there will be a surprisingly small number that conflict at the minor level. supporting both wouldn't be a huge stretch, we'd just have to change module.register() calls to include the major number and alias accordingly\n. I'm somewhat meh when it comes to semver, often in patch-level bugs change the behaviour of your application because you code around them, but I would like to at least support the 1.x sort of syntax, the rest is pretty useless. It should be pretty easy to implement though we just have to start storing the component dirs as <user>-<repo>-<version> and query the repo's tags. \n. most of the options are silly IMO, a little duplication until resolved is better than a lot of broken apps. It's extremely tempting to disallow even 1.x and similar, it's easy for your application to break even with a patch-level change, it may regress, or you may have coded around the bug previously in which case your app may regress. If anything I think x and ~ would be all I really want to support but it'll likely use node-semver anyway we'll see, it does get annoying to maintain explicit versions\n. no matter how much you try and follow semver there's always things you'll get wrong, regressions happen, even if your release promises a bugfix it may introduce other bugs :D \n. yeah we'll have to add it at some point\n. it would be easier to implement after the registry migration though \n. semver resolution being on the server would simplify things quite a bit, otherwise we'll have to make a lot of api calls to github to fetch the versions etc. I contacted Github to see how they felt about projects using them as a registry and they're not too fond of it, but they didn't mention any explicit restrictions\n. going to leave this for now, removing a prop from the json isn't enough to warrant an extra command, if it ends up doing more in the future we can revisit\n. still messed, node + auth is being really weird\n. terrorist !! haha jk\n. i suppose this is still useful if you use --save\n. component install something could also just create the ./component.json if it doesn't exist, and then --save could be removed since that would just be the default behaviour\n. @avetisk for installation? we have prompts for component-create(1) already, but for installation you have to add stuff to ./component.json, but I need to tweak component-install to do that stil\n. we've already dealt with that, if you look at the js generated there are aliases so that when a component has the ambiguous dep of \"tip\" it's aliased to \"component-tip\" or \"someone-tip\" as defined in the component.json\n. yup I've got an open issue to append the version so we can fix these, but yeah you're right aliases will need them too\n. as far as public api goes this whole thing needs refactoring\n. done :) MIT, as always\n. ah I see, that sounds good. i suppose the spec needed it too anyway since it's intellectual property\n. license would be nice for search output as well via --license to opt-in to listing those\n. i've added a generous default of MIT haha :) they'll have to opt-out if they want to change, the readme's stated MIT as well already anyway. later the linter will send pull-requests to ones that do not have this field\n. havent tried it lower than .8 so ill mark it there\n. added\n. no vector ATM just the quick png \n. yeah it's just arial, I dont have any fonts on this machine yet hahaha, I would have played around with others\n. uploaded assets to https://github.com/component/component/downloads\n. way out of scope IMO, we shouldn't be concerned with things like that\n. that will just have to be annoying forks for now, but that's not the kind of thinking I have. I'm thinking more long-term, not how can we bypass weird things for now, more the utopian view of when people opt-in to component themselves. This way we focus on what really matters, not intermediate annoyances, this will produce a better project\n. are you on the latest component(1)?\n. it should set up a fake \"index.js\" alias to that lib/async.js\n. oh nvm it is setting up the alias, that's what the last one is\n. yeah SRC / DST\n. just compile in the Makefile etc, and add the resulting files to component.json\n. none of mine personally, in small components templates are typically small enough that just html works fine, and css is simple enough that regular css is fine. though this for example translates the HTML into a .js file that can be used https://github.com/component/tip/blob/master/Makefile#L5\n. ill add more docs to this soon hopefully\n. haha nevaaa\n. @kelonye nope, you make smaller components so they only have a few files, no need to make the app a single component. I'll add an example app tonight\n. local components go in \"local\": [\"foo\", \"bar\"]\n. yeah I think someone mentioned that yesterday, that's a bug ill check this out right away\n. 0.7.0 has some fixes for this, install and build will now respect COMPONENT_PATH\n. re-open if there are any other issues\n. I'd like to get all of them working more or less anywhere eventually, and weed out old browsers as we go, but APIs should remain identical either way. We have cases like json where you can opt-in to older shit with json-fallback since it's reasonably large\n. closing for now\n. oops, missed that thanks\n. added a mention here https://github.com/component/component/wiki/F.A.Q\n. added a mention of contre as well, looks sweet! I need to try it out\n. yup definitely\n. I dont want to add any github specific workarounds\n. you can use local to utilize any number of private components, private github repos, or a custom component server which could even implement what you're discussing if you wanted\n. meh for now\n. I'm pretty anti min-file, it's pretty useless to ship with those in a repo these days. I was going to create a component-release(1) a while ago but I use git-release as well and find it's not bad personally, it also has a hook that you can use for other mundane things that you happen to have per repo, or have it invoke a make dist etc. Github should do tarballs for you as well, I've never done any of that manually.\nAs far as stand-alone builds go, there's definitely no harm in including them in the repo/tarballs, but in the future we'd like to have the component.io site auto-fetch / auto-build these for people who want to consume them that way. \n. \"component(1) SHOULD ultimately have a lot of knowledge of npm, jam, require.js etc\" that's not true, I'd like to ignore them completely everywhere possible, because I dont believe in those solutions. I agree that --standalone needs to facilitate AMD etc but that's about it\n. haven't started yet :D haha but yup I'll make it open-source in this org. Deferring that sort of thing will definitely help keep components clean. As far as --standalone goes there's https://github.com/component/component/issues/66\n. sweet deal, keep in mind we're probably going to be really strict about n.n.n being strictly digits, so the leading v for tags might disrupt things a bit in the future, I definitely want to stay away from npm's nutso semver implementation it's pretty complex for something that should be really simple\n. actually it may not matter much since we have to fetch the list of tags regardless, leading non-digits are easy enough to strip, but then you'd have to specify \"v1.2.3\" for deps which is kinda weird\n. no way around that really, globals suck, we're trying to get rid of them, but you cant really have both unless we introduce stupid noConflict junk but I dont want that. Other than doing --standalone which wraps everything in a function I cant think of much you could do\n. by default ./components is in the lookup path but that's it, so that's more or less the default COMPONENT_PATH, as far as separating local ones into other dirs it doesn't matter really, ./lib, ./client whatever you like. I've been using ./client personally\n. I dont like opinionated defaults. export COMPONENT_PATH=lib in your profile, simple as that. The one thing I would consider is putting it in the root component.json file, since it's effectively required for your app at that point, but the env var would remain\n. what do you mean?\n. yeah tough call, added an issue (https://github.com/component/component/issues/137) for support in the component.json instead, that might be a better way to go than the env var, and like @timoxley mentioned then you dont need to prefix stuff if you're not setting it in your shell session\n. yeah not relevant for local, we'll need a --local flag or something because there's a couple things we can leave out\n. already decided long ago not to add any adhoc template engine support in, so they must be compiled. with the builder you'll be able to integrate your own auto-template stuff in but for public components they must be compiled. as for conventions you can definitely do whatever you like, the create command cant really do much there because if you name the template dialog.html and it compiles to dialog.js you have a conflict, so I just went with template.html, but either way doesn't bug me. previously we didnt support \"main\" so we had no choice but to do index.js however we could adjust that now\n. editors that don't search via dirname suck though, we dont want java-style my-app-super-dialog-style.css\n. yeah i know the pain, i use textmate as well, the search is terrible i just use search / ack / spot instead\n. closing for now, im still in the middle for this haha, not sure there is a right answer i find index.js handy sometimes and annoying sometimes too :s \n. just onward would be fine, time-wise probably just daily would be more than enough. It would just be cool to look at a line graph a few months from now and see how growth is\n. actually ill just make it a generic stats script that dumps to disk and chuck that on my linode\n. library focus is definitely more important than size, but it would still be interesting to track, even if just later for graphs ets\n. yeah those will go away with time, we just have to extract everything that jquery does into components\n. closing for now. filesize isn't really the main concern, gzip squashes pretty much anything but complexity is certainly a concern but not every component can really be judged by size, definitely a nice-to-have so we can re-open once we've hit a 1.0 and got everything rolling\n. closing for now, shouldn't be a huge deal really, as long as we're outputting an error on 404s it's all good\n. hmm we must be able to exec a specific file on windows, without this you cant use component(1) unless globally installed\n. loading them with require() isnt the same as invoking them with proper args etc\n. going to close but only because component shouldn't even have to worry about this\n. we could always use work-arounds for now like your win-spawn module, that sort of idea, that we can weed out once node core is not a mess\n. just part of --standalone so it automagically works with other envs, global / commonjs / amd etc\n. I dont think it's necessary personally, removing it from disk doesn't matter much and it's easy to just edit the json file to remove a dep, otherwise we'd need to add every json maniupation possible as a command\n. closing for now but if it ends up doing more than just editing later we can add it\n. -1 from me, I still want to pretend node doesn't exist. We've also been annoyed by -component in npm, but there's no reason we should be tweaking components to fix npm's fault. a try/catch works fine though it is ugly. Recent npm supports name/proj as deps though BTW that might help a bit\n. it doesn't have anything to do with node, npm's namespacing issue is its own deal, we need to keep things focused\n. the lack of symmetry does bug me a bit but yeah, currently at least all you would ever have version-wise is *, which doesn't make a ton of sense since component doesn't have to install anything, I dont foresee local being used for anything other than app-specific components checked into the repository\n. awesome idea! at very worst if we cant get that going a link is definitely a must\n. maybe github is respecting:\nCache-Control: private\nContent-Disposition: inline; filename=\"passing.png\"\n. hahaha sexay. I'm excited to see the graphs in a few months from now we're going pretty steady, seems to be around 3-5 per day\n. not sure why my count says {\"count\":328,\"timestamp\":1354602373311,\"authors\":56}\n. hmm some of the must not be getting into redis due to errors or something, because it shows we have less, do component search | grep url | wc -l. Yup I have graphs already\n. closing now that we have the badge, we could add a wiki page with some Media links for logos/badges/etc\n. I actually really dont like how it ends up looking on component.io haha.. redundent logos is kinda meh.. a much much smaller travis-style badge would be fine there but right now it looks kinda silly unless we remove those from the dom\n. badge might not make sense really anyway, not sure people will get what the number is unless it's spelled out, im kinda meh about it ATM haha\n. agreed! I'll add the link before I forget\n. thanks for the batch thing, I never noticed. next release should have this fixed between builder/component\n. i dont really want to facilitate that sort of thing, using git is just an implementation detail\n. nvm just realized this doesnt matter, you couldn't have models/user.js and views/user.js anyway if they both had the same \"name\"\n. so far I cant think of a real reason to add this over rm -fr components\n. we already have paths for this, and the todo example uses it to point out ./client\n. though lookup might be a nicer name\n. yeah we have a similar setup and find it confusing at times as well. we could either a) just not do that, b) allow paths in any component.json or c) allow relative paths like \"local\": [\"./client/whatever\"]. paths at any level would result in cleaner component.jsons but with so many lookup paths in the system it could get pretty ugly / confusing if you type the wrong thing etc\n. closing for now, doc / examples will come\n. need to think on this some more, it might be better to just do \"local\": [\"./client/boot\"] etc and lookup boot's deps relative to its dirname, tough call. full paths is annoying when you have many, but more explicit\n. yea the only downside is the verbosity but it's probably worth avoiding the ambiguity. This would prevent users from having say ./{controllers,models,views} though \n. another alternative if we're going with relative paths would be the somewhat obvious:\n``` json\n{\n  \"name\": \"myapp\",\n  \"dependencies\": [\n    \"some/foo\": \"*\",\n    \"some/bar\": \"1.0.0\",\n    \"user\": \"./lib/user\",\n    \"admin\": \"./lib/admin\",\n    \"login\": \"./lib/login\",\n    \"signup\": \"./lib/signup\"\n  ]\n}\n```\nthis shouldn't really make anything more or less complex, about the same, but they would have to start with ./\n. yeah that's true, lack of / could imply that, though the array is less redundant but it looks a bit better to use the existing object (even though i made it an array there hahahah...)\n. yeah for sure, you dont have to currently either. It would be lame doing ../foo for deps though I'm still not a huge fan of that\n. one thing im thinking about is whether or not the left-hand name should be used over the component.json's name. For example if you have \"user\": \"./user/view\" mapped, if it should use the ./user/view/component.json name or \"user\". That leads to another problem though, when a user starts nesting things they need to know that you still need component.json files, they still have to be \"real\" components, this may not be obvious, and slightly awkward really\n. @gjohnson a few people have been using it that way, kinda \"reaching inside\" a module for namespacing, rather than say user-view. I can't think of too many reasons personally not to just have a flat list but most people seem to like regular traditional MVC stuff, it would be nice to at least facilitate it. For the flat-list approach paths are pretty ugly \"user\": \"../user\" etc.\nI dont see a lot of reason to have nested components at the moment, because you might as well just add those scripts/stylus to the parent's component.json, they're private to that component anyway. I'll try and mess with some more structuring possibilities soon and see which pattern works out best\n. yeah we do that with a lookup path for ./lib\n. not personally, we just have one big flat list. If it's specific to say login then we just have a few script/css/whatever files in lib/login/*, but those are all still just the one login component. Heavy nesting is definitely where lookup paths fail, I'd rather not have lookup paths and something else, we could have both if we need to but that's definitely not ideal\n. the nested .paths thing is a bug but we just haven't fixed it yet since I'm not sure which direction to go yet, appending lookup paths to traverse a really nested app is definitely not a good thing\n. mostly just a time issue right now, but it definitely seems like we need to cater to both people who want to nest things, and people who want to modularize things in a linear fashion. I might have some time for this tomorrow\n. @eldargab thanks for the input. With recent changes in the builder lookup paths are a bit less scary for now at least. Now when a non-root component specifies \"paths\" they affect that single component only, so other components will not accidentally resolve to \"paths\" specified in other components.\nI'm not a huge fan of node's nesting to be honest, it's actually completely unnecessary, it would be more convenient and easier to implement if node used a project-level dir with <pkg>-<version> like we do, but I know what you're getting at as far as implying that ./components are always require()able. Plus most applications don't check node_modules into git\n. @eldargab yeah that's why originally I was leaning more towards using .local (or paths in the deps, whatever) to be more explicit about the path relative to that component, getting rid of lookup paths all together. Keep in mind though that even if you have say:\n- lib\n  - my-component\n    - more-stuff\n      - foo\n      - bar \n    - component.json\n  - another-component\nand my-component/component.json has paths: ['more-stuff'] only it will check ./more-stuff, not another-component for example, the lookup paths are scoped to the single component. Effectively it would be the same as doing local: ['./more-stuff/foo' ,'./more-stuff/bar'], just saves a bit of typing so it's not really worth it\n. the other alternative is implying those .locals like browserify does via hacky static analysis, but that would only work for non-public components \n. Personally I still prefer a flat list personally, it helps a lot for the asset url rewriting since they need unique names but we can try and tackle that later for nesting.\n. It would be great if we could some how hit a nice medium between the flexibility of regular node/browserify with non-unique names (though that gets confusing as well..) but with the modularity of components for assets and everything else. Our components are structured around features more than anything else, so if you remove a component from ./lib you're effectively removing an entire feature, all associated model-like things etc are within there\n. If they're used anywhere else we make them their own component, but things like say \"settings\" has its own views/rest stuff/styles, if we remove it other than a single require() in our boot script it's just gone. We dont really use models since it's a bit of an anti-pattern when it comes to modularity.\nYeah I know what you mean, it's two-fold IMO, there's a certain elegance in just having a flat list of canonical modules, no special-casing, no digging around, but it can be annoying I suppose. I dont use the dir tree in my editor at all so it doesn't bother me but it would if I was using that to locate a file.\nIt would be nice to facilitate node-style when you want it, if they could co-exist that would be great. I'm not 100% satisfied with this approach for those cases but it certainly beats having a mess of ./views / ./models / ./styles ./assets that slowly get less and less mirrored. Need to think on that some more.\n. dup\n. I do kinda agree that it would be much less difficult to wait a bit and then do automated pull-requests, than to try and undo what we've done in the meantime. slow and steady wins the race! haha. closing for now since we have the other related badge-ish one, in general definitely a good idea, even if we just have the badge link to component/component\n. good point, I agree, the links are probably overlooked\n. there are links in the readme, and $ component wiki opens it up if you're editing the page regularly. This will definitely be easier when the site is up\n. ohh I see, yeah good call, forgot that you can even do that for an org\n. it looks like cloudhead's less site haha. I'm not 100% on replicating github's readmes to a site, personally I dont it useful at all on npmjs.org for example, still cool though. I think we can probably do some pretty cool stats on there and searching stuff for people who are scared of the terminal. Could be a little while though I probably wont have time to start it for at least a month or so. I definitely wont leave out the idea of replicating the readmes though, I can only speak for myself but lots of people might prefer searching for components via the web instead of the CLI\n. i dont think we should go throwing .standalone in component.json files, I'd maybe just default it to camelcased name otherwise allow the consumer to choose a name since that part doesn't really matter\n. closing since we have a component.io repo now\n. tough call, the main reason im tempted to have a more component-centric CI or version of a CI server is mostly because I dont want to go add a github hook to 200+ repos, and it would give us the control to choose which browsers are being tested so people who want to use the component can actually see what it supports\n. yup! that'll come, ive got https://github.com/component/component/issues/124\nwith my cryptic title haha. most of it's there just undocumented, and some things need to be moved out of the bins. logging etc will remain in the bins though\n. so is ours currently, we only support tags and * as well. It'll slow things down to grab versions we'll have to query GH and couple with another of their urls which kinda sucks but oh well. The only semver thing im interested in supporting really is ~, everything else is pretty useless\n. closing for now I'll leave #124 open \n. added a note at the bottom about scope \n. if node's every actually works I'll consider it some day, it's a massive unnecessary PITA from what I've experienced with jade / ejs / stylus\n. going to close this because you can a) use a simple exec() in middleware etc to do this on-request, or use the builder to offset the exec overhead\n. im open to it, it would make things easier for people, but there's a lot of reworking I'd like to do to really lower the learning curve\n. added a warning for now, quick fix\n. I like the general direction of testling CI but yeah I mean we can make it look 10000x better and it's not a difficult thing to pull off with saucelabs, we will need the component build step capabilities anyway, not sure if the testling thing is open source or not we would have to add that in and make it pretty haha, I dont care how we do it as long as it does the builds and looks nice\n. they gave me one already for components\n. yeah sure! fire me an email and I'll send the details, they just wanted mentions / feedback in return\n. closing for now, not directly related to this repo\n. haha yeah i noticed this too, definitely a +1\n. think this was fixed\n. the windows stuff should be addressed as a separate pull. Though I thought @ForbesLindesay's win-spawn should take care of this\n. his module should fix that problem\n. yeah there's support for json we just haven't added a json thing to the component.json yet, other text stuff will have to be just converted to js like the html thing\n. @weepy yup, once component-convert supports arbitrary stuff you'll be able to use whatever with require(). I'm even tempted to remove json since there's not really any real use-cases, js objects are fine\n. ah I see. there may be something we can do with that in the future but for now I'd prefer to keep require() simple and focused to js only, so whatever can be converted to js is fine. assuming that html: [file, file] etc are require()able would be reasonably leaky, since they could be ejs templates etc\n. is it really a super useful use-case though? from my work with node at least, when I used to add exports.version =... it was useful exactly 0% of the time haha, just some silly convention I went with just in case it would be useful but it never was\n. we'll make these plugins like the \"template\" one in component/component.io (which will be their own repos soon)\n. for pure convenience we can consider subcommands or adding them as deps to builder similar to connect middleware being bundled\n. oh weird, good to know\n. yeah I guess the worst would be a cease and desist notice, I'll re-open if we get an angry email :D haha\n. I'm not against it buttt we get around this (for js at least) with the source url stuff instead of adding hundreds of script tags, though you could readdir() \n. hmm I have no problems developing in this env, but I see what you mean. I'm not a huge fan of this approach because it forces the developer to implement a few things just go get started, something out of the box would be much nicer if we can do without. Why not just use debugger to set break points?\n. web inspector definitely does it correctly, I didn't check firefox, FF is the last browser we test in haha it's kind of the reject that barely works\n. because firefox sucks haha :p \n. we dont have --save anymore, it's implied for component install since it's useless to install without it being in your ./component.json\n. yeah haha not sure why i had that, my bad\n. closing for now\n. nope, we've had this discussion before a few times. We're doing everything we can to keep component simple for several reasons, but this is not an important feature because if you need a glob to make it convenient, you have way too many files in a component\n. if you want to build the whole app as one giant component (bad idea IMO) you can still do it, we're just not adding globbing because it's an anti-pattern\n. may re-open this if people keep wanting to build monolithic apps instead of modular ones, seems like a lot people are kinda confused by the idea\n. Realized the other night too that this would actually bring up a lot of confusion because globs flat out wouldn't work for public components since we can't pre-compute them on publish, so it would only be usable for the apps themselves. It's definitely a documentation problem right now\n. well it needs require in order to function, it's wrapped though the outside world does not have access to it, and it wouldn't make much sense to use require separately\n. cool ill see if i can review this soon\n. does too much IMO, some things are kind of nice but I don't think they'll get a ton of use, too much for core at least, otherwise we're pretty much just re-invented ln. As for deps go we don't append -<version> yet but when do (and before I suppose) I'd probably just clobber those too, since linking is usually just for some quick debugging\n. @clintwood it just shells out to component-CMD so anything that is installed with that name will work (even if it's not in core). I'll have to pull this down and take a better look \n. I've got a branch in the works that will allow users to customize the output, though I wouldn't be a fan of making it ugly out-of-the-box, this does suck haha\n. actually, on second thought isn't this really just an issue with your term styling? I mean it's cyan and gray, so if those show up as nothing to that theme at all, then that's a little... odd.. closing for now\n. I would do it, but LAMP is such a PITA to set up\n. for drupal/wordpress it would be sweet to have an admin page thing that lists the components and you just click a checkbox to install\n. overkill probably but most drupal people don't really code much. We mostly just need to offer the build portion like middleware so the builds \"just work\"\n. open issues on the repo themselves please\n. ohhh because it's a fork, my bad\n. it's not part of the json currently because it doesn't really describe the package in any way. The only real use-case for it at the moment is something like component build --standalone superagent --out . to produce files at ./ instead of ./build etc. There's definitely very limited use for it\n. fair enough, the main reason I dont want everything build related in json, for example --dev etc, is because I dont want it to become like npm in regards to effectively replacing makefiles or similar, that's not its job, especially when it's as simple as:\nbuild:\n  @component build --out vendor/component\n. oh you mean putting the component.json file in ./vendor as well? you could:\nbuild\n  @cd vendor && component build --out component\nsomething like that\n. I'm all ears, just always playing devils advocate to keep things simple\n. @ForbesLindesay you should have access to https://github.com/component/component.io now, we can iterate in there\n. I haven't looked at your source yet, I did want to build it with components, I've got a design somewhat finished (just the pixelmator doc)\n. sure yeah it looks fine to me\n. anything I can reproduce? I'll try and make -v more useful in the near future haha\n. closing for now\n. the best you could do really is wrap your entire app as one component, so that require()s all resolve etc. That's the thing about global vars, they just kinda, suck in general, no way around that really, or you could require() at the root level like require('component-tip') etc but then you have the prefixes\n. github.com/component/builder.js\n. not sure what brunch does tho so im no help there, but it could use builder to add this to its build step\n. I see, yeoman doesn't make any sense to me but fair enough! if you need an example component-build(1) is what uses the builder\n. or just use the builder, using the builder or make would be as simple as https://github.com/component/todo/blob/master/server/build.js\ngrunt is lame too, the builder will facilitate compilation in the near future, things like .coffee files etc will \"just work\", not out of the box, because there's a silly number of them but we'll facilitate that sort of logic\n. it's going to allow you to take your app components and do whatever you want with them, auto-compile templates etc, no generators or anything like that, it's not some boilerplate thing, just hooks for app-level integration, not a lint runner etc, that's what Make and friends are for\n. what are these directive things? I'm not familiar, but yea you're right, component is more of a platform, things like meteor / angularjs could be comprised of components in the future. In a lot of ways neither project makes sense really, why they're so coupled, who knows\n. oh I see, yeah I mean you could do that with anything really, doesn't have anything to do with angular you could write a component to do the same easily instead of bloatware.\n. then they wont look pretty and indented :( haha\n. add would be a lot better, we can leave wiki to open it haha\n. oh wait I have add as an alias of install ATM, but we can remove that, or maybe component register? \n. meh for now, not worth the maintenance burden in core, but even if it's installable via npm install component-register etc it'll still work\n. tough call, it's kind of another one of those easy to avoid things by just not having weird conventions, same with say require('some_thing') vs require('some-thing'), it's just convention to use -\n. famous last words haha, until all those one line fixes add up and create a mess. im not disagreeing that it's lame but I'd rather see how things play out than to run around fighting edge-cases, if this ends up being a huge common thing we wont have much choice\n. oh weird yeah it think you're right\n. or maybe .repo was once lowercased in there\n. doesn't matter to me\n. I guess because github isn't case sensitive so it just goes ahead thinking things are fine, with that in mind I kinda agree now, because if you can install it without a 404, it should work with that name as well\n. the js builder will facilitate this sort of thing shortly, but no not really, npm would be better since compilation is done on the server end\n. hmm I haven't seen this on the component end, if it's there it's there, the 404 shouldn't lie as long as the paths are correct in the component.json\n. closing for now\n. yup that's what this will be https://github.com/component/component/issues/104\n. you have to run --stand-alone from the component's directory, and the name given to the flag is what you want on window.\n. it should build / wrap the deps in as well\n. ohh yeah it's just for \"the\" component itself and everything it requires, not spitting out all the deps onto window, but dont worry about duplicate deps etc, gzip takes care of that\n. plus that's why component exists really, to make managing all of that much more enjoyable and efficient, --standalone is kind of a last resort opt-in of terrible old ways haha\n. you can specify lookup paths in your component.json\n. like an array :p I added an example\n. i dont get it\n. I guess but I dont really see the use-case for it, component will never be optimized for global window usage, that's an anti-pattern I dont really want to facilitate more than we already have, standalone is just meant to give a standalone build of a specific component for the developer to allow people stuck in old ways, not really a tool for building an app\n. that's not how you use it, for example if I'm working on component/dialog, and want people to be able to use it without component(1), I just run:\n$ component build -s Dialog\nso people can use it without the system, the name passed to -s is what's on the left-hand side, the require is what is taken from component.json\n. +1\nit's probably from dialog or one of the other early UI ones, but dont worry about that too much that's just impl details that will eventually go away\n. \n. lol at overlay using jquery... really need to go back and fix these\n. the convention is that authors split opinionated styling into \"themes\", so it's more of an author issue if you're having issues overriding a bunch of things\n. yeah like dialog etc just has enough to not look messed up, and then themes like github.com/component/aurora-calendar and github.com/component/aurora as an aggregate etc\n. sure.. there's always going to be some issues with unscoped css, but it's largely a non-problem, IMO this is more an author issue, write with reasonable specificity and keep things pretty void of opinions \n. styles I dont think will be a huge deal, but it may be more helpful for templates\n. https://github.com/component/component-graph\n. damn yeah that's a good point I guess, if you're going to check builds in for deploys to other platforms then I agree copying is what we'll need to do, hopefully it doesn't become too slow, at very worst we could check mtimes of the files and avoid excessive copying\n. nah I'd rathe skip the extra docs / explanations for more flags, no reason to have both really if we can make it reasonable for dev/prod in one go. I'll have to try it out and see how it is, most assets are pretty small so it shouldn't be too big of a deal, we could possible utilize the --dev flag if necessary and imply --symlink \n. @btknorr for now you could do component build in a different branch and check in the files, I'd recommend that over building on the remote anyway, much less of a hack\n. yup you're right, my bad, I dont make sense today\n. fd7d3bf\n. windows?\n. oh nope usr/local, hmm wtf, seems like npm isn't installing the sub-commands for some reason, double check by doing:\n$ npm install -g npm\n$ npm cache clear\n$ npm install -g component\n. good call\n. @dotherightthing that's not how you update node :p that's the n package\n. npm supports user/repo syntax now (sorta), so you would have to have a package.json but otherwise it does work, still not a bridge I'm too concerned about personally, a very large percentage of our components are browser-only, not something i want to get into\n. @MatthewMueller we should try using the GH syntax with component/model's package.json deps and see how that goes, it should be pretty seamless\n. I think with npm it's:\njson\n\"dependencies\": {\n  \"set\": \"component/set\"\n}\nnot sure how you get the version in there, # maybe\n. best part of that too is you avoid all the authentication stuff!! double win\n. and the discoverability in npm goes out the window\n. @jhnns it's a little hard to describe actually, but the thing is everything in npm-land (or component-land) is nice and modular, until it gets to your application. Then suddenly everyone just uses a weird awkward tree of modules and does all these weird relative requires. To me why does the true modularity stop at the app level? What's so special or different about the app? An app is just a series of private modules, that should otherwise be identical to those in npm IMO, first class.\nHOWEVER I do agree that this ups the learning curve, I need to think on it some more and see if we can compromise to facilitate both styles \n. @Nami-Doc not sure what you mean, can you gist an example?\n. why not have (something like):\n./account\n  ./validator.js\n  ./controller.js\n  ./view.js\n  ./account.css\n  ./component.json\netc, that's sort of what I mean by why do we build our applications rails-style, while we build our communities modular\n. @MatthewMueller that problem goes away if I rename that back though no? I guess it's still difficult for packages that you want in the registry, with names like enchilada we know all the names are really exhausted at this point haha and event-component2 even.. haha.. yikes\n. The names people have been giving things are pretty ridiculous lately but I don't see how npm can get around that now, I don't care much about things being in both places personally, the only things I have \"ported\" from npm to component is the odd utility or two. I think creative naming is great for things that actually have a creative aspect, stuff like fleet etc, but simple utilities shouldn't really need to be named emitter-component, events-component-2, uid2, better-assert, uid-util, etc. There are certainly pros and cons to our approach, like @Raynos mentioned it's not like you have to say \"use tj's uid\" or \"use guillermo's uid\", but I definitely prefer the freedom this approach gives you. I dont think npm compatibility is a huge deal, the lame try/catch approach is ugly but it works for now, I don't want to \"revert\" to a non-scoped registry just for that. Using npm's newer github-style support is working pretty well, you just don't get the perks of being in the registry (or the bad parts like managing the ownership etc). npm has been around for a lot longer I dont think it would make much sense for npm to change in that respect unless it was beneficial regardless of components.\n. If you're happy with names like enchilada or falafel all the power to you, the point is we have the choice.\n. If you're happy with npm, use npm, there's nothing \"wrong\" with npm really, just things we feel could be different so we're going that route, there's certainly no reason to ditch it if you have no issues. For us this means many things including:\n- an obvious / canonical location for browser related libs\n- knowing these libs are designed explicitly for the browser (aka they actually work, no .forEach shims etc)\n- better discoverability\n- no need for redundant ownership management that github already provides us\n- no cache headaches\n- no name collisions\n- nicer search\netc. \n. @MatthewMueller s3 on the client is completely different than on the client, that's the case with a lot of this code, we literally use maybe 5 things from npm.\nThe solution is pretty simple, if you don't want to use it, don't, if you don't like the npm experience, use something else like components. I don't want the ambiguity of poorly written server code that can be hacked into working on the browser. Using one for the client and one for the server also helps make it extremely clear which dependencies belong where, vs going into your code to see what you happen to require() on the client.\nThe isomorphic argument is fine, no reason you can't still do that, we just publish to both, one with a stupid name, one with the name we actually want. I would actually prefer if a lot of our server code was less like our client code, node could be much better without all the callbacks, but it is what it is, we do end up sharing a lot of utilities and our database related code but not using npm doesn't get in the way of that at all for us.\n. thanks anyway!\n. c43bf2605e34538fbafc2727438cd74ac1c1da6d\n. yeah might as well!\n. squashed / merged, thanks!\n. hmm mixed feelings on this, only because the dev stuff could easily just be a script tag in whatever the example page / test page is\n. true true good point, I'll think on this a bit. if we end up using relative paths for local modules (instead of locals: []) development: would inherit this as well so you could then do:\njson\n\"development\": {\n  \"something\": \"./test/whatever\"\n}\n. what I mentioned there is related to https://github.com/component/component/issues/152\ndefinitely some tradeoffs. lookup paths are more flexible and less redundant but less clear and introduce two new json properties\n. still thinking on that stuff, if it has no version, and no path (if we used lookup paths) it would be something like \"user\": \"\" which is a little odd\n. yeah the \"/\" wouldn't be meaningful so that's kinda strange\n. we'd also need to decide what portion of the path is included, ex would you require('./test/whatever') or require('./whatever') etc, neither are obvious really IMO, I think people would be expecting different things there depending on their case\n. yeah true that should be fine\n. I wouldn't call it difficult at all, I do it all the time, this would make it a bit more commonjs-like of course, but certainly  not much less difficult\n. was this one resolved? not sure I understood the question but let me know if it's closable\n. oh I see you want to bypass the cache, -1 from me, mostly for parity with node\n. hmm I have never used npm deprecate, doesn't make sense IMO, a command to check latest versions would be more useful I think, we can't really decorate releases with extra info since we have no database. I'd never go back and deprecate all 100+ releases of Express 1.x for example\n. meh it's such an edge-case, one we cant really facilitate without introducing a database anyway, going to close for now\n. @markreg not ATM nope, while I wouldn't rule out blobbing forever we're not getting into that right now, chances are your component is too large if adding a few filenames manually becomes unwieldy \n. yeah we have roughly ~500 between pub/priv components, component is wayyyy too new though I dont think there's much out there really using it yet live at least\n. let's reopen in a few months :D \n. currently that's just how we store them on disk as directories, that's about it, it's just an implementation detail really but  if we have someone who happens to have a hyphen in their username we can revisit, hyphen in the project name wont matter\n. yup it's still needed for ours ATM, I dont want to go all nuts with auto-discovery stuff\n. thanks! nice fix\n. oh lame :(\n. sourcemaps are huge PITA too, I guess we could have a --no-source-url flag or something :s haha\n. a lot more work for no gain really, if you're using coffeescript or something sure, but I sure wouldn't bother with js\n. I guess, I dont find it to be a problem without\n. what's wrong with explicit? :( haha\n. while I agree I have to say no for now because just like I dont think npm(1) should be a Makefile, I dont think component should go down the road of being a json editing tool. The exceptions in my mind would be things that we're doing anyway, like component-install has to download the dep anyway so it's all good to install it, component-rm or similar mayyyyybe but I dont see a huge point right now, that's a lot lower traffic. Also since we use git-style sub-commands you can npm install component-add and it will work\n. in general I'd like to do that with most of them first, put them in npm and if they're really well received and not buggy then add them to core\n. in production you still wouldn't want a large number of scripts, it is certainly a balancing act between the number of parallel sockets in use, and the size of the files themselves, generally it's not an issue at all. Measure for your application specifically before jumping to conclusions. Component does build a single file right now but that's not restricted by the \"spec\", it could be any number of files, that's just the simple thing to do for now since most scripts are well below the size of a single image\n. what if it's only strict in a past sense? it's hard to tell if things will or will not work for the unstable branches of node, IMO best we just document it as being tested with 0.8.x in the readme\n. well in general that's bad practice really, it indicators you're not testing something properly at its origin, however we will eventually likely have a link command similar to npm's, or you can symlink yourself for now\n. #181\n. just do manual symlinks for now, the command wont be much different than that really\n. component/todo has a few branches with some different directory structures. You can do it any number of ways, for example ./user/{model,view,routes} ./user-model,./user-view,user-profile-view blah blah. I'm still discovering what works best myself, however rails-style MVC directories are definitely my least favorite, there's nothing I'm 100% happy with yet, but in general the rails style is about as anti-modularity as you get\n. closing for now, I agree we need more docs etc, the project is still very alpha though so I'll keep these issues out for now\n. merged @jeremyworboys's PR, thanks again! not sure how I wrote it to disallow this haha..\n. will review sometime today looks good though! thanks\n. great! thanks man\n. this is really complicated when it comes to CSS, for js it doesn't really matter but even giving precedence to one component or another wont solve the CSS precedence issue, for that reason I'll close for now but it's certainly something we all need to keep in mind, I'm not sure that there really is a good solution, weighting goes downhill fast\n. correcto, if weights end up conflicting you're in trouble. It may help a bit but I think it's leaky from the start, Drupal did this (maybe still does?) when I was doing that many years ago, and it ended up being pretty awkward, sort like how z-index has no context \n. my bad, thanks!\n. hmm yeah tough call, personally I'd never not use github as the last remote, but when I do use custom remotes I put  github first since that's well above the average for me. We could leave it out all-together but that seems a little odd to me\n. closing for now, I think github as the implicit final check is definitely the 90+% use-case\n. you could set up an npm script or make target if you want, or auto-build on request like component/component.io does in middleware for example\n. -1 from me, I didn't want to get into any auto-munging of existing libs\n. I dont mind it personally, most existing libs are kinda not great anyway but maintaining a fork or two isn't the end of the world. Depends how up to date you want to be I guess, I haven't updated jquery in like half a year and it's fine. Stuff like backbone doesn't really fit the mold of component anyway, even most stand-alone js libs dont fit the mold too well because they inline all the x-browser code over and over again\n. FWIW jquery is and anti-pattern, just a crutch for now until we get enough solid x-browser components going\n. woah.. weirddd, force published over it\n. hmm I'll try and take a look at this soon. In the meantime what's wrong with basic auth over https?\n. I don't really think it's any worse than hosting your code with a service like GitHub, which isn't so bad anyway\n. I'm not against it but I think we should move the util related stuff out so there's less to maintain here since it's not really related. Or JSON instead of netrc would be cool with me, less new config languages the better\n. cool yeah sounds good to me\n. SGTM, not a big deal as long as we document some examples so people dont have to go hunt around for syntax\n. just need to find some time to review :D should be soon\n. looks great thanks man\n. damn, well that's lame\n. I definitely wouldn't parse it every time regardless, that's a bit wasteful\n. haha yeah sorry I really need to get what we have up soon\n. haha yeah I went to put it up on sunday but the box is giving me some strange issues with the app for some reason, here's the strace. I haven't looked into it much yet but apparently node itself isn't even executing\nhttps://gist.github.com/visionmedia/6d39d11fc8e71764c856\n. fixed, didn't notice, I should set up some alerts haha... some day \n. ah yup, thought i did\n. 0.11.1\n. IMO flight is just a lib really, so you could easily do the same thing as a component in our land if you really wanted to, our stuff is abstract enough that it doesn't matter. In my experience I don't find this model good or bad really, it's pretty \"meh\", sometimes it's a great idea to abstract with events, sometimes not so much\n. the themes should usually be completely separate components that you install, so that the component itself has really limited styling. As far as overriding html etc there's no canonical way to do that with components, but the javascript in the component itself could define whatever it wants, .setTemplate() blah blah\n. +1\n. wahoo\n. we use a builder in js-land for our app so the setup is a bit more magical\n. +1 that would be nice for search output too with --verbose or something, then you can just cmd+click the links in Terminal (not sure if it works in iterm2)\n. I think we have this same thing discussed somewhere else, maybe component.io\n. if you prefer creating non-modular apps component isn't a good fit right now, I would stick with browserify or something\n. meh we should remove 0.6 from the travis thing IMO with 0.10.x coming soon\n. yup! that would be great, windows may be an issue but we can detect that if necessary. Ideally the bulk of this goes in some npm module so we can keep component itself free of unrelated bugfixes etc\n. im not really up on the whole licensing thing, too much legal junk for me, but whatever is the most liberal gets a +1 from me, I've just always used MIT\n. I've never heard of any constraints with MIT either so they're both fine AFAIK, I just wanted a default so the dev will at least see it and remember to change it if necessary\n. you can always fork stuff as well, it doesn't really have to be our forks\n. but I'll try and update it tomorrow\n. yup it was never up, soon though\n. that's an npm error, it has nothing to do with component. Of course you type that in the terminal, where else would you type it? If you're going to be a troll don't bother. Component is alpha software, more documentation will come, but we're not going to dumb things down to the level of \"open Terminal.app and write this and press enter\" that's just stupid\n. FWIW you can install the node binary without compiling with this one-liner, or use the installer like @btknorr mentions, or something like n/nvm/nave\n$ (cd /usr/local && \\\n    curl -L# http://nodejs.org/dist/v0.8.15/node-v0.8.15-darwin-x86.tar.gz \\\n    | tar -zx --strip 1) \\\n   && npm install -g component \\\n   && printf \"installed component(1) %s\\n\" $(component --version)\nThey typically assume users have node available already because well, who wants to repeat those docs all the time? Ruby and other communities don't hand-hold like that either. It's typically enough to say you'll need node installed, at which point the person goes to nodejs.org and follows their documentation.\n. npm breaking has nothing to do with component though, that stack trace is clearly an npm-specific error, something with your specific install is messed up\n. because standalone makes no sense, that's what we're trying to get away from, appeal isn't the goal, better dev experience is the goal\n. where's this?\n. ah, yes, we should change that, wrong repo ill move the issue over\n. that's @retrofox's bot, we could probably persist it on the linode i have if we need to\n. :smiling_imp: \n. boom, added for now, if it ends up super leaky with options we can remove it later, but it should be ok for the average use-case. Thanks @nickjackson\n. im definitely not against it, this sort of thing falls apart as soon as options are involved though which does get tricky. At that point it's best to just use the js API, plus if you're building a reasonable size app it's much faster to use middleware and the builder directly than component-build\n. doh, just made a change there, will fix\n. https://github.com/component/component/issues/47\nwe should definitely get this in soon\n. bit hacky as well but it should work https://github.com/component/component/commit/f535c655f3c29e80cd1f3682f1b94191cc7df75c\n~50% faster installs as well since we usually have a lot of duplicates\n. yeah that whole thing needs a bit of a rewrite to become more lib-ish but it works for now. A lot of the ./bin/* logic needs to go into the lib as well\n. @MatthewMueller what sort of breakage are you getting? i haven't had issues on my projects but maybe i don't have enough deps or something\n. just an oversight, we can definitely change window\n. fixed\n. it's totally your call, if it's not worth creating separate themes per component you definitely don't have to do that, but that's what I'd recommend as far as public stuff goes. This one only has two so it's not a great example but you can then create a more convenient aggregate component for people who are using all/most of them https://github.com/component/aurora/blob/master/component.json\n. without some sort of preprocessing you just dont haha :D but you can use whatever you want as long as it compiles down to css (for public stuff at least), we use rework for private stuff there's no manual compile step\n. definitely a few ways you could do it, as far as a dev env goes it doesn't really matter too much, the pre-processing will be more inconvenient to people contributing regardless. So you could even just assume in dev that ../mystuff-vars/index.less exists and pull those in, the end result is always a pre-compiled .css or two\n. not that i know of, that would be cool though\n. @Nami-Doc not all of bootstrap though, as logical components\n. haha yeah syncing sucks, but I mean the vast majority of bootstrap things we already have as components, dialogs, popovers, tips, etc. Other than the skin itself there's not a lot we don't have\n. I think a big thing in general is minimizing the sharing between components, otherwise they're not really all that modular. As far as how they're compiled it can be pretty much whatever you want, they dont have to be in the .styles array for example you could have .sass which is a bit easier as a plugin since you dont have to .removeFile() but I've been re-using .templates and .styles and just using .styl / .jade extensions\n. weighting for css related modules is definitely something we'll have to figure out though, we have some problems with this as well even without a preprocessor involved\n. there's still the .files array for arbitrary \"unofficially supported\" files\n. Jade is just the same way really, include/extend dont work on the client anyway (I wouldn't use them even if they did). We don't have any server-side views though, right now we have stuff like lib/user-api lib/file-api etc but we're going to move all those out into a different repo and plunk it at api.ourapp\n. I'd chuck most of these in .files for now until we have real reasons for first-class support, I don't have a need for require('foo.md') etc personally\n. I do what @yields does, but you could have for example onload = require('myapp') and in the myapp component do module.exports = function(){ stuff onload }\n. thanks!\n. hmmm yeah this should be fine, I'll leave it open for now\n. thanks!\n. and the wiki url is for sure correct? we completely remove the data from redis each 15 minutes so it should mirror what's there\n. actually you know what, we dont remove them all! I lied haha, we should though, not sure how I missed that, I was leaving some keys in for stats etc so there's no flushdb right now\n. fixed, the search index and components are removed first\n. bower doesn't support these components, but nope we don't have any concept of a peer dependency at the moment, but in almost every case you don't really need it unless the person is bumping major often\n. I'm hesitant because we may eventually need to couple with more github routes, namely the tags for implementing the rest of semver. They could be proxied without changing component, I'd definitely prefer that but I know that's annoying\n. supporting multiple things and elegant are two different things IMO, it's not like it's hard to implement, you just have to pick and choose what is worth supporting. I dont use those sites so it's obviously easy for me to say no haha, but my concern is just when we introduce the versioning portion, otherwise I'd be down\n. damn, ok fair enough haha, it feels slightly leaky to me as an abstraction but I'll merge for now and see how it goes. One change I think we'll have to make just to make it a bit less leaky in the long-term when we have more mapping to do, is to pass objects:\njs\n{ \n  remotes: {\n    \"http://whatever\": {\n      \"files\": \"/{name}/{version}/{file}\",\n      \"versions\": \"/{name}/versions\"\n    }\n  }\n}\nblah blah, but even then we really need more flexibility than json can provide I think. Once we introduce semver support we'll have to query the github api for the tags\n. @silvinci we just need to get a list of tags available so that we can apply the semver logic \n. hmm well that would work if you had it as a dep in a component.json, once you have more than one dep you'd want that anyway so im not sure it would be worth ditching the username prefix for that\n. not ATM, I'll try and finish my CI soon as well\n. yeah they definitely shouldn't be coupled, and I totally agree about the badge, I wouldn't want three different badges going on the site haha that would look brutal\n. I don't really see a compelling reason to change it personally, at least MIT is something I've heard of haha\n. hmm maybe\n. that would explain why the test is failing, limbo merge!\n. should be fixed\n. the remotes[0] thing is fixed in https://github.com/component/component/commit/3957b24dbc876c37ccc6c6209b7c6db3db758fe1\n. I think we should almost get rid of --out, it's not really useful\n. closing for now but we can all discuss stuff in #299\n. something weird keeps killing it, added mon(1) finally so it should stay up\n. we can chuck it in a Batch and set the .concurrency() that'll help a bit\n. thanks man\n. ah sorry I should have specified for install only\n. I dont think we should go looking for problems, I've never seen anyone use ./components, I dont think that's a big deal\n. right now you'd have to use a lookup path and local to expose it as a normal require() but at that point you might as well really just add it to scripts\n. hmm I can't think of any reason for this ATM, especially since coffee etc should be pre-compiled. Other than node addons I've never used them in npm\n. I still think it's weird personally, it would be fine for internal use as a team I suppose but certainly not the ideal way to compile things in development either. Doing it with the js builder would allow changes at runtime without re-installing etc. As for public components it definitely doesn't make sense to compile on their end IMO\n. closing for now but we can revisit later\n. seems ok now for me\n. hmm yeah interesting point, for now I would say to just fork, namely because if we start overriding things from the outside of package definitions it could get pretty confusing for everyone including other team members. IMO as soon as someone needs to fork it's a project off on its own, but I definitely can agree with this being a pain in the ass. One alternative would be to use an intermediate remote and download your upload instead of component/upload even when it requests component/upload. Using a remote gives you all the power you could ever want in terms of redirecting/overriding things \n. agreed!\n. we should probably kill the whole dir just in case one or two of the files has downloaded but not all\n. yup, that whole thing will be rewritten eventually but might as well put it in there for now\n. hmm it should, I use Batch all over the place, haven't seen that behaviour\n. oh damn nice find, that's definitely a bug\n. (fixed that)\n. im not a huge fan of fs-extra since it has a lot of other unrelated things but we have as a dep in builder as well so it'll do for now\n. yeah that would be cool i think im only using rimraf in their as well, can't remember\n. @bergie hmm that's odd I pretty much never have issues with github\n. sadface :(\n. not something I've toyed with personally, we have almost 1mb of source for our app now and (pre-gzipped) and it's still snappy on mobile but it would be interesting to investigate this a bit\n. actually looks like this wouldn't help us at all since we require() everything up front at the top\n. closing for now\n. component/component isn't a component :p\n. deps aren't installed globally so yup you have to call $ component-ls from within a project\n. done! 0.14.0\n. I always kind of wonder why people go to google first though, we have resources and links in the readme/wiki, there isn't much out there other than that really :p but I'm sure over time people will start calling it \"componentjs\" or similar. Node had the same problem and it's fine\n. we definitely have a lack of guides etc right now but that's something we should tackle here and on the site as well\n. sure but like I said it's really no different than node becoming \"nodejs\" instead of something ambiguous, I'd rather not rename it\n. haha have your pick :D componentjs component.js component.css-js-assets-other-stuff\n. why? you can't even produce a build without having them listed in component.json\n. I dont get why your app would have a ./components dir but no component.json, IMO what we have now is unexpected, similar to how not adding the component you install with component-install(1) to the component.json file would be strange, you can't do anything with the component otherwise\n. how do you build the app with no ./component.json? component-build(1) doesn't know which deps to traverse otherwise. I'm not arguing either, just trying to understand, any opinion is fair :D it's just my job to go with my gut and  if people have different opinions to try and figure out why they are different and if those use-cases are valid\n. Oh I see you're using a different builder. I have lots of apps with no boot related code in the root dir but the component.json is, fair enough I suppose I'll leave this for now\n. @bmcmahen yeah that's not how it's going to stay, we need to add -<version> to the dirs, I was just amazed how far you could get without it so I haven't bothered yet but it needs to be done. For deployment it's obviously not ideal at all to have multiple versions but it's something we need to facilitate at very least (and heavily warn)\n. @alessioalex I dont think we need to nest like npm does, the main benefit there is that symlinking for npm link becomes super trivial, but it complicates a lot of other things more than they need to be (IMO). A simple ./components at the project root is fine:\n./components\n  ./component-emitter-1.0.5\n  ./component-emitter-2.0.0\n  ./yields-sortable-1.0.0\nthat sort of thing\n. think i fixed this already in the builder but need to confirm\n. just going to switch the flag name but ill merge thanks!\n. should be fixed\n. yup we'll have to really soon to avoid conflicts with semver stuff #104 \n. wonder if we should make it a full url just in case people host it on their blog or similar instead of a branch\n. hmm every Error should have a .message, if not this should be fixed in node core\n. forgot to close this haha ls does show versions but com ls --remote or something (--latest? not sure) with the coloring like you mention would be sweet in core\n. we should maybe add links to @yields' app in the search output with a flag so you can investigate size/deps etc really easily\n. thanks!\n. sounds good I'll try and tag some of them soon or add a milestone\n. meh not any faster \n. we'll get there, another 200 components or so and we'll have pretty much every base covered. Closing for the same reasons @ianstormtaylor mentioned, we need to focus on making our core system more robust and growing the ecosystem of components. One thing I'd definitely like, and I think a lot of people would be interested in contributing to even just as a learning experience, would be to have \"wish list\" wiki page. I'll start one and we can jot down lists of things we'd like to have\n. https://github.com/component/component/wiki/Wish-list cant actually think of anything right now hahah, I had some on my phone before but I think I deleted that list\n. It's not as bad as it sounds, starting from scratch is really refreshing and good for a community at times, you get higher quality this way. Any component can be compiled down to AMD or stand-alone globals so that part isn't an issue. I have no interest in pulling in old code personally. I want to focus on an ecosystem of quality, that might not work for everyone, and that's fine.\n. oh shit, hmm yea either we are handling res.status improperly or they 200\n. yeah that blows it's been lame today haha, once github is back I'm going to verify that https://github.com/component/component-mirror still works. in the future we could consider using this or similar to produce a public mirror \n. this could just be process.env.HOME || process.env.HOMEPATH, but it should be submitted in the netrc lib's issue queue\n. more descriptive titles / descriptions please :p, but we have an issue for removing the prefix already so ill close this one\n. We have a legacy system built on npm, so unfortunately we're forced to publish them there for now, until we migrate to component(1) for our main application, which means lots of gross -component namespacing\n. @razic yeah personally I'll stop when we start using the real component(1) instead of our old thing. Component is for client-side code/assets, so it wouldn't make sense to add Ruby etc. It could be possible to add server components to say a login component that has a user interface etc but the chance that it supports the server backend you are using is pretty small, it could be incompatible with that version of sinatra/rails/express/django etc, there's just way too many\n. fixed :D thanks\n. hmm a test would be good if possible, locals were not influenced by the parent's .paths before this? should be\n. test doesn't pass (missing component.json) but ill take a look\n. still fails for me, there's no component.json:\nSyntaxError: /Users/tj/projects/component/test/fixtures/local/component.json: Unexpected end of input\n    at Object.parse (native)\n    at Object.Module._extensions..json (module.js:475:27)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Module.require (module.js:362:17)\n    at require (module.js:378:17)\n    at loadConfig (/Users/tj/projects/component/bin/component-install:246:12)\n    at Object.<anonymous> (/Users/tj/projects/component/bin/component-install:71:12)\n    at Module._compile (module.js:449:26)\n    at Object.Module._extensions..js (module.js:467:10)\n. well this is causing me more work than just fixing it haha, usually people run their own tests first :p\n. damn, still missing the other ones, master has !test/fixtures/**/component.json in the .gitignore now so it should be less annoying that way, but \"direct\" and the other two are missing for me as well\n. hahaha that can't be too easy, thanks man\n. component-install <pkg> will do this if it hasn't been added already (I have an issue open for the * issue). As for updating I was thinking maybe a flag for component-ls to compare but that's another issue\n. yeah I'll write a little node thing soon instead of using cron\n. haha crap, i should probably stop restarting and actually look at the error\n. too lazy for now, restarted haha ...\n. @MatthewMueller try -v, we should maybe just make that the default\n. I like it, especially at the app-level but I don't want to promote being over-paranoid about filesize either haha, some people take it way too far and try to drop deps for really silly things. Other than that I'm +1\n. does this need \"type\": as well? seems like everyone else is patching like that\n. that's what I love about component, can't not know where the repo lives haha\n. haha yeah sorry I had to change devDependencies it bugged me too much :D. Sounds decent though\n. this will be nice for search $ component search model --plugins or $ component search model --extensions, whatever. I think \"extends\" is my favorite, but that sort of sounds like monkey-patching, reads ok I think:\njson\n{\n  \"extends\": {\n    \"component/model\": \"*\"\n  }\n}\n. I definitely agree that in general extending other things is bad practice (even through modules via .use() etc), but some cases can't really be avoided, or they're very specific to some other modules (rework plugins for example).\n. +1 from me although low priority\n. hahaha, I think I have them as unions right now so the more you type the more results you may get, I should probably change that to an intersection \n. hmm interesting!\n. even with multi-line strings I'd probably still stick them in separate files for organization and proper highlighting personally. I definitely agree that html is a really really common use-case for any engine if you're not pre-compiling functions, I'm willing to bake that in, as far as making the others available as strings that gets a bit tricky I guess. Do we classify them with something (contrived) like \"strings\": [\"foo.jade\"] or leave them as \"jade\": [\"foo.jade\"], or do all \"templates\": [\"foo.jade\", \"bar.html\"] become available as strings? Exposing all \"templates\" would probably be what I would go for personally\n. I'm still on the fence, I definitely think our current annoying method is more elegant, auto-magically stringifying templates into require()ables at the spec level is a little weird. It's always tough when convenience == less elegance, but I feel the pain :D haha. I think a big help would be improving the builder's API / documentation / potentially built in-plugins ala Connect\n. it's just magical in the sense that we'd be special-casing the one property (.templates or whatever) to have a unique behaviour. might as well try it out though, we're still pre-1.0 so we can tear it out ;D haha. I'm +1 \n. 0.17.0 should have templates with @anthonyshort's builder patch. It may end up a little leaky for those who want to pre-build functions on the server, but those plugins could pull out the \"foo.html\" js generated and replace it with the pre-compiled template. If it ends up being horrible for some reason we can re-visit :D \n. +1\n. removed that chunk it was pretty outdated\n. changed! thanks\n. yeah an entire walkthrough of a small app would be great. I fear that people get confused if content doesn't live on the homepage though. It's almost like people ignore the readme/wiki all together and get confused just because it doesn't happen to have much of a website yet. I'd hate to inline a guide like that in the readme haha, I'm all for writing on on medium or similar and linking to that but hopefully people wont miss it if we put it near the top of the readme, later maybe migrate it to component.io\n. removed dead link\n. if you're going to de-AMDify why use AMD in the first place (just curious)? but we do have build hooks in place, ATM they're more abstract than browserify's but we'll improve that api later: https://github.com/component/builder.js#builderhookname-fn\ni'll add a better example, the jade one is a bit of a weird case\n. as far as adding specific support for them in JSON I think that's too leaky personally, hard to express the same options you can with regular js closures that just take arguments\n. simpler css example: https://github.com/component/builder.js/blob/master/examples/transpile-css/index.js, basically just hook into certain points of the build, inspect the configuration, do whatever you want\n. /me is still on 0.8.x :(\n. doesn't make any sense to me, not sure why npm did it that way\n. we could maybe check for ~/.gitconfig:\n[github]\n    user = visionmedia\n. little overkill maybe\n. woah wtf.. \n. sounds like streams aren't as backwards compatible as they should be\n. should be fixed now\n. I'd prefer not to so we don't couple with github's api too much, but we'll need to query for versions right away anyway. I'm +1 if we just write a little abstraction layer to keep Github slightly decoupled\n. hahah oh man.. streams are such a disaster, I'll try and take a closer look at this soon and see wtf is up\n. thanks for looking into it, really appreciate it! superagent is dying for a rewrite and better test coverage one of these days\n. for now we could probably get away with .set('Accept-Encoding', '') or something, definitely would like to get this fixed but yeah fuck node :D \n. yup, I switched back to regular old node http for now, but now we don't have unzip support. Haven't had time to look into the superagent issue\n. -1 from me personally, I don't think \"Releases\" is applicable to any of my projects, just creates more work in most cases, but I can see how it would be great for projects that need to cross-compile binaries etc.\n. kinda yeah but we currently request each file individually instead of a tarball, that may change in the future though\n. sounds like a bug to me, it shouldn't hurt anything but not ideal\n. stream all the things. will look at this tonight\n. im just going to remove the stream bullshit from superagent, I'll patch this pretty soon with regular http/https\n. damn, i forget why i removed it now hahah.. 85690cd\n. We do have way too many in Other, but we can adjust that as we go\n. we should still add some kind of warning as well, but thanks!\n. it's just really low priority \n. nah wont worry about it for now 0.6 is pretty old but if we only need a few small patches im fine with that\n. low priority but +1\n. totally, me too, definitely need to do this very soon, I have an issue open for it though\n. so what if npm doesn't... they don't function without a component.json, so IMO it makes sense to add them. If you're doing something completely different then yeah of course it'll be a bit weird, but that's to be expected if you're changing the format\n. thanks!\n. haha nope, we should remove -o for install\n. we have an issue open for this in component/builder.js\n. we might support wildcards if/when we get to having a registry, so we can normalize on publish\n. not sure what fetching component.io with phantom has to do with components themselves really, but single-page apps are definitely a bit weird with phantom\n. oh right hahaha shit\n. I get it with 0.11.7 as well, haven't looked into the cause at all but definitely not good to be hitting assertions in core haha\n. it's not public but it shouldn't be changing any time soon\n. totally, we need to add some real content to the site\n. rad, thanks!\n. hmm that's not good, we should open an issue in the netrc repo if there has been a regression\n. oh I see, forgot that I commented that out. superagent has some race conditions in later versions of node, once we fix those we'll be good, and component will be fast again (missing gzip right now)\n. feel free to try and figure out that bug :s but I think if we uncomment that stuff I have in component, and do .set('Accept-Encoding', 'identity') we should be fine, maybe try that\n. easier to just use n.n.n, I don't want to get too loose with tag requirements, I know it's a seemingly small thing but it makes other stuff more complex\n. you can but not with ~ ATM, I'd prefer if people stuck with n.n.n so everything is consistent\n. we don't have an entry point to place the validation logic :( that's the one downside of a non-registry, we could do it on install though\n. I don't have a problem with the keyword searches personally, especially since our packages can have meaningful names unlike npm haha, makes that a little easier, I think npmjs.org is fine though it's just the CLI that is crazy slow. I think ours has a bug where the name is not included (or split on -) right now but that's fixable\n. there's an npm \"open\" package we could use actually\n. derp :( yeah it used to work\n. thanks!\n. just needs a rebase, seems weird though, let me know if it's an issue with 0.11.8 \n. it mostly just works as a side-effect haha it's not actually by design so I wouldn't rely on it but you can use for it now\n. +1\n. ? need more info\n. I think it was half-added to builder haha. I'd add \"json\": I think. My only \"rule\" so far is that user-defined things that don't really touch public-component-land like sass, stylus, coffeescript etc go in scripts/styles, because they have to be translated anyway at the app level. Otherwise for ease of programming I'd definitely say its own key. Even with stylus etc those could have easily been there own keys but that's up to the user I guess.\n. my only complaint is that it adds an additional concept for almost no gain, I can see people being like huh what how does this magical auto-require() thing work, is it immediate, on load, blah blah.\n\n. yeah it totally could be, that's just my convention to keep most of the app in ./lib\n. @ask11 nice! I like the abbreviation haha :D I'm not against having a support registry that grabs everything from github for when it's down etc, but I'd like to try and keep the UX of our current non-registry the same. I really enjoy not having to publish to a separate thing and maintain ownership etc\n. we could simplify that part too with github's api I'm sure we could check for projects with component.json and auto-check them for you. As far as handling erroneous commits like say someone initializes a project without the .repo prop we could use a component bot to open issues or even do the pull-requests for you. The only downside to doing that vs something like component publish is that it would make things like globbing more difficult \n. haha yeah I've been aliasing as \"com\" but c8 is cooler, little annoying to type maybe, but I have no great ideas for names right now. \nmaybe for publishes we just have some hooks so you can pre-transform css etc, most modules don't really need it anyway I suppose, small amounts of css usually.\nES6 module support compiled from our current commonjs wil be 99% necessary if we're ever going to migrate completely over to ES6 modules, and then maybe the bot can send pull-requests but even for me going through 300+ components would take quite a while. Eventually we'll just use ES6 modules but that's obviously a little far-future for now, maybe a year or two but we should be prepared\n. I'd like to have it so you just oauth and it pulls over all existing components that you've written, and all the versions so you don't have to go back through the tags to publish or anything like that\n. I think it might be too edge-casey personally. You could always have a tiny script that wraps what component gives you in a closure so it doesn't conflict, I don't think too many people would need it baked in\n. yeah I don't think that's bad, I don't like introducing a new flag but maybe this should just be the default anyway\n. yeah for how things are right now we would have to double the requests to support both\n. yeah not having a publish step sucks for that sort of thing, but that could be built on top. Maybe we make com publish == git tag <n.n.n.> etc, doesn't have to be a registry I suppose, people could still get around it by doing manual git stuff I guess but if we didn't explain it they would think they have to use it :p haha\n. yeah tags is definitely the lame part, wouldn't be hard to go the registry route, it would be nice to do it in a way that maybe works in tandem with github so you don't need to manage two accounts, if your org has access to pkg A then all those users can publish to it etc, I hate maintaining that with npm\n. yeah oauth through github would be cool\n. I like that you can look at component.json and know exactly where the projects came from, and where to find them on github, plus Go does this sort of thing and that's a huge mess for deployment. If bitbucket, github, or any personal sites are down then you're fucked, doing our own registry mirrored from github or something would probably be the best bet\n. @sankargorthi yeah that should definitely be a consideration when building this thing\n. thanks man! it should be fun, I know we could do a lot of really cool stuff on the client end with dep graphs and crazy d3 graphs of the entire system. I'm not 100% sure on the registry-side transformations but I think we'll pretty much have to use it to migrate to ES6 modules since there's so much existing code, could be super powerful too though, stuff like opt-in registry-side image optimization, opt-in css prefixing (really dont want to ever look at prefixes again haha), probably lots more that I can't think of right now\n. @darsain yeah I'd love to write it in a way that the registry itself has orgs etc, but you can import everything over from github / bitbucket etc, and a simple API so we can write a smaller version for private registries that don't need big riak clusters etc\n. yeah definitely, though I don't think last commit dates are helpful, just because something is \"inactive\" doesn't mean it's abandoned, often those packages are more robust than others\n. what I did is assign node's to \"node(package)\" and require is just components\n. one of them ends up with an ugly name but yea haha doesn't matter which I guess. I wouldn't want to bake anything into component really at this point\n. rad!\n. ah yea this gets back to our semver stuff and versioned ./components/*, so it's sort of a duplicate issue\n. i've got part of it done, I'll try and finish that up this weekend\n. or as a quick hack for now we could completely remove the faux path stuff & resolution, since we don't have semver support right now anyway haha\n. it's definitely a slightly different case with client stuff since you ideally have no duplicates, but that should definitely be up to the dev to resolve, I'll start working on this alias fix and a new registry this weekend \n. yeah at that level I think semver is pretty useless but on the client we're a bit screwed if 5 libs use emitter 0.8.0 and 2 use 1.0 or something like that\n. @TooTallNate yeah I know, that's what I'm saying, because right now that won't work. @MatthewMueller agreed, im not saying we don't need it.\n.  </offtopic>\n. haha yeah that gets tricky if it's still really in flux you'd be at 55.0.0 before it's even reasonably stable. IMO it doesn't make sense to roll over patch-level on feature/bugfix mixes as well, it's not really informative to go from 1.2.3 to 1.3 with features and bug fixes, then you have to go look up a changelog\n. haha ya might be time to add #164 \n. the super agent thing might have been resolved now, I forget what the issue was, something was breaking in 0.10.x\n. +1 from me! no reason to couple the CLI and lib\n. SGTM\n. +1 for outdated / update but size isn't as necessary I think, and the test stuff while super awesome isn't well-defined enough for core IMO, we don't want to make it a giant npm monolith either, even if it lives in another repo we're committed to it\n. rad!\n. hahaha damn them\n. we could maybe work something similar into the registry. branch testing sounds like more of a dev env thing, would component link be fine?\n. i dont think forks would be too bad in a registry, only gets super messy I guess if people don't edit the description at all to mention why they forked\n. hahaha oh well we can find a way to mark them as forks and float them to the bottom, I definitely want deep github integration, and I've got a few simple ideas that should make this thing scale WAYYYYYYyyyYY better than npm, but still want most of the github stuff we have now\n. my projects must not be big enough yet, this is definitely not a concern for me, I generally hate watchers but I can see how they would be necessary for really large projects. though it's really effectively a make-like task runner, so what we maybe really need is make-style mtime checks wrapped up as a function, and watch is really just an interval on that. vs our \"dumb\" build right now that just clobbers everything, then you get smarter component builds and a watch in one\n. might complicate things too much though I'm not sure without digging around a little, might be pretty easy for us to layer that on top now that we have tree to work with, the mtime-resolver thing could just delete stuff from the tree pre-build\n. I don't type make, I always use middleware.\nthe thing is watcher libs are just that, watcher libs, when they should really be more make-like, just idempotent builds that happen to run at an interval \nI'm not against the idea, but component build etc definitely need to exist for deployments and so on, but I do think it would be more elegant if component was effectively watch -i 1s component build if watching was implemented in the make-style way\n. I never notice a build once per request, unless it's around 1s+ it never phases me really, beats having some uber complex system, and it's nice to know that the build is 100% done on that request, not that you got half a build, or you're still waiting\n. I think the ultimate but maybe needlessly complex solution would be just doing the make style builds. For example if we've already copied over 25 static assets it's definitely wasteful to do so each build haha, so we can mtime those, similar for other stuff but scripts/styles aren't even really worth it since you pretty much always adjust those each time. Building that stuff into builder would be kinda hacky too, as a layer on top would be cool. you could knock them out of the build tree to ignore them when mtime is constant\n. for copy definitely\n. sounds like a bug to me\n. hmm works for us, I was just using it yesterday\n. you can chuck them in files: []\n. hmm we normalize them in component/builder.js so they're always lowercase but the requires themselves should work as they were officially named. We could also toLowerCase() when resolving as well. IMO caps are lame but hey haha, too late to go back on that\n. can we stop bikeshedding, it's filling up my notifications. We're not changing this any time soon. if you don't like it, don't use it, and if people are bugging you to add component.json or something, tell them to fork\n. don't worry, give it a few months with web components out and they'll all disappear\n. I want to write some scripts to migrate us over eventually but no one will be using component/browserify/whatever with web components really, browsers will finally provide all this stuff, but we'll need to migrate to ES6 modules, so until then component will still be useful as an intermediate.\n. I pretty much never lint haha, IMO this more of a CI / editor feature. it could be a plugin for component but definitely not core\n. @airportyh as far as your issue goes, use the 0.10.x releases of builder\n. yup we want to upgrade eventually but we need some more breaking changes to 0.12.x\n. this is where ES6 modules will be pretty cool, with loaders we'll be able to lazy-load in development, and support bundles in production really easily, without going to something like AMD\n. weird it must have failed again, should be up now\n. last time I checked the real API only gave you weird base64 blobs that you can't stream (and base64 overhead) so that was awkward, but if there's a decent endpoint we could definitely switch. Rate-limiting is another factor since GH rapes you, I sent them a few tickets about boosting that, especially for paid users 5000 is pretty tiny\n. -1 from me, especially since browser stuff will be quite different from node in the near future, probably not worth going down the road of mixing the two, especially before we have something nice and robust for the browser\n. hmm I think standalone is more descriptive personally, for people who don't know/care about UMD\n. --amd-commonjs-whatever hahaha.. jk yayy client side\n. it's super easy to delegate compression/minification outside component, not sure if it's really worth adding a command for when you can use du -h\n. it could always be part of component-ls, but minus gzipping etc, but then again that's not useful because in reality you're going to gain a ton of from gzip\n. setting them up in the manifest might be reasonable, still very leaky compared to scripting but less leaky than via the CLI at least\n. yeah just leaky as far as logic you can apply and how and what options you pass etc. for simple cases cli/json are nice\n. I sort of agree in general that it's annoying to have component.json's in the modules, however if you don't then your app is basically just one monolithic thing with root dependencies, which is both good and bad I suppose. I guess that's where globbing really comes in at the app level if you want to do a less modular application with the deps in the root component.json only. At the public component level it's pretty rare to have a lot of files.\nThe way I see it generally is that it's akin to having many modules for your app in npm, like we have 500+ now, it's annoying but at the same time it's the \"right\" thing to do, but I totally agree it's super annoying at the prototyping stage. \nI like the idea of having the lib-ish stuff out of component/component to keep it more focused on executables. Structurally I like the functional approach, if we exported them we could unit test them pretty good, testing the whole thing end-to-end with lots of filesystem state is pretty awkward haha, I sort of gave up with that in the builder it's too weird.\nAs far as remotes go it would probably be overkill for now but if we maybe started supporting the whole { \"bitbucket.com/foo/bar\": \"1.x\" } sort of syntax similar to Go, and repo/user would just imply the github support that we already have. Not sure if that's worth tackling for now since long-term it would probably just end up being parsed from the import statements.\n. I guess the main bad thing about throwing with version conflicts is that if someone else owns the repo you might be waiting on them to make changes (though you could fork), but that could get a little weird but definitely true that css-wise you're fucked at that point anyway\n. github:foo/bar == foo/bar would probably be the nicest, no point having the whole url I guess, unless we're going to support tarballs etc those would need to be urls anyway, dunno tough call\n. the thing is if you type component open component/emitter you might as well type open http://github.com/component/emitter. With npm there's that extra indirection which definitely makes it annoying\n. if you use component-search you can cmd+click the link in the terminal to open it :D \n. hmm they should be hiding theirs in a closure\n. I wish node didn't use node_modules haha, it's super ugly, but irrelevant either way really, we can change it down the road if we need to but there's no reason to\n. their ratelimiting is pretty ridiculous, I contacted them about that a few times but seems like they're not going to change it anytime soon, even authenticated users get ratelimited pretty hard. If we did proxy like @jonathanong mentioned, something like component.io/github.com/foo/bar/ (just an example) it would make keeping things up to date a little nicer than trying to mirror them all\n. if we sent all requests through component.io we wouldn't need a publish step, no need to deal with extra accounts like npm whooppp\n. I guess GH would ratelimit us to ~5000 through component.io though, that could still be a problem, it's kinda dumb that if you pay for a large account you still get 5000/h\n. tried already, 5000 is probably fine for now though we don't even have that many components\n. I know @jonathanong wanted to proxy through component.io to normalize the end-points anyway, which sounds like a good plan to me, cache duration would definitely be an issue if we don't have a publish step, but I really dislike publish steps :( I'm sure we can find a way around it\n. we can set stuff up in our clustaAAaaa\n. I'm not sure we even need watch really, just introduces a race between viewing something and having it build, vs building on demand \n. ah yeah true that makes more sense\n. yea we should definitely retain the same output style\n. npm is generic/fragmented if that's what you want, component is/was an attempt to unify things. Over all it's just a concept, you can do whatever implementation you like, but we'd like things to work out of the box\n. but if you want just a generic tarball you could use npm, but that's where all the unwanted fragmentation steps in\n. That's what component does, define a way to unified structure client-side packages. If it were \"pure\" it would have no notion of unified contents, thus it would lead to fragmentation. Once web components are real and well supported then tarballs will be just fine, but until then that's not feasible unfortunately.\n. it is something else, right now and for the foreseeable future at least. eventually some day it'll be tarball fetcher for es6 stuff, but that'll be a while\n. sorry yea, should switch to jonathan's thing, we still need a server for the cli search but linode is crap, I haven't had time to look into it. there's going to be a new component thing soon that takes the best of browserify / component and combines them, so we'll get all this rolling again soonish I imagine. In the meantime the wiki works fine. thank god it runs on GH :D would have an npm catastrophe on my hands \n. every 15 minutes or so, something must have screwed up. good old reliable node, i'll check it out when I have some time\n. yea we're still taking the best of component for structured asset management etc, the main thing from browserify is just less boilerplate to get started without a manifest. I have some future things in mind to ditch entirely, the more I use Go the more I think manifests don't make any sense.\nThe rest of npm/browserify is mostly bad stuff, a Go approach would be much better IMO, once ES6 module loaders are in play. Browserify will eventually die out too, they all will haha, long-term none of them make sense, builds are no fun\n. we already sort of take the Go approach but ideally once ES6 modules roll around we just parse those deps out of the import statements and leave all the manifests out, making them optional. I didn't think they bugged me so much but now that I never have to write them in Go it's really really nice, and no package manager to fuss with\nfor now builds are sort of necessary which sucks but some day!\n. yea never really got around to making a real site, I have a feeling our front-end gurus at segment will want to make one for Duo, so we'll have something then, but @jonathanong is right, it was never really about any given implementation, more the packages. You could think of Duo as 2.0 (or 1.0 I guess), the packages themselves won't fragment\n. @clintwood for sure, I agree. Wish I originally had time to polish things more and get to a 1.0 at least haha, kinda feel bad but :p free is free I suppose.\n. changed my mind about using node for sites as well haha, too much boilerplate to use Koa nicely right now, maybe when everything in core/npm is promise-based it'll be fine\n. I like in-file deps too, don't need extra tooling to see what you're not using, and eliminates the need for manifests all together\n. we shouldn't have 1.x'd component it's totally not a 1.0, I'd look at Duo as being the first 1.x of a component-ish thing, it was never about a specific implementation anyway so it's awesome to see something more robust that isn't coupled to npm\n. I can only speak for myself but I think keeping it GH only is a feature haha. When I see something that isn't on GH in Go-land I just don't use it, ~95% of Go software is on GH, the odd thing is on shitty Google code or Bitbucket. Maybe it could be supported but out of the box it's almost a negative instead of a positive IMO\n. @stephenmathieson ah yeah for private stuff that's cool\n. I guess what I should have said is public components should be on GH, otherwise it's just pure rage haha\n. Oh and the cool thing is if it goes more Go-like then you can have many packages in a single repo no problem without any special exporting code. I have 33 Go packages in one repo right now for example, then if you need to break compat you just append -v2 or move it to its own repo\n. I imagine this is different for you guys as well, we should move some of this stuff to a separate npm module so it's transparent, this sort of executable stitching is pretty common\n. the reason we can't do this (at least only this), is because you could for example install say a component-server command, and component server would still work, much like extending git. We could however maybe do a quick stat() of the join, if that exists use that, otherwise PATH like before\n. nah that wouldn't change anything unless the __dirname is in your PATH\n. only tiny complaint:\njs\njs.write(umd.join('\\n'));\nshould be fine, maybe ditching the last \\n in there\n. this will throw if the file doesn't exist\n. probably safe to assume if css.length is 0 that we never had the css file at all IMO, not a huge deal if the user somehow removes all their css everywhere and it ends up being empty after that\n. not a huge fan of this personally, I think if people have ./node_modules/.bin in their PATH that's all good but then we can just leave it as-is anyway, or if someone has strong feelings towards using the localized component(1) they can just point it straight there (I always do with mocha etc)\n. we could replace both these streams with concats and simple fs.writeFile()'s, should clean things up a bit there's no reason for them to be streams really, also hasCss wont account for dependencies that have css, we have to check the Builder#build() object\n. cant remember if we use this elsewhere, might be worth moving it to ./lib\n. Ideally we handle this recursively (in component/builder.js), not just the root conf, and maybe something like <path-to-component.json> \"name\" missing\n. if ( :D haha\n. this command doesn't use ./component.json\n. I still wanted an implicit github remote regardless of defining your own (always as the last though)\n. not sure how I feel about having this, I think most people would never touch it, maybe we should just default to something sensible\n. ",
    "ForbesLindesay": "+1 I really really really need this\n. I want to make Q into a component, apart from adding component.json and making q.js the main file, it requires no modification.\n. We could just make the first script in the array main\n. It probably should be lodged as an issue with the spec rather than here, but the point is it would resolve the same use case.\n. I think it's important to do it right first time, because it's very hard to take a feature out.  I'm not sure which is the best way to go, but both options should be considered.  I would be inclined to just go for having a separate \"main\" field and add a feature into the tool to make it easy to automatically populate that field.\n. Agreed...any ideas how fast we can get this implemented?\n. :)\n. A really great feature would be if we could support accessing components from private GitHub repositories by using OAuth?  That would make having private components really simple.\n. Yeh, I wouldn't want private repositories on GitHub to be instead of multiple registry support, but it would be a great extra feature.  GitHub does support basic auth, which would be much easier than OAuth.  I hadn't realised it was an option when I suggested OAuth.\n. Interestingly the raw links on the github website include an authentication token for private repositories, so that token could be used directly.  Sadly there's no way to tell the difference between a private repository and one you just don't have access to so we'll need to have users be explicit about it so we know when to ask for username and password.  perhaps a built-in private repository that could be used in the style @juliangruber suggests.\n. Probably true\n. Yeh, falling through for multiple registry support would be great.  We still need to be explicit about private repositories though.\n. The problem is just that we need a way to distinguish private components from non-existent/miss-spelt components so we know whether to error or prompt for username and password.\n. Github returns 404 instead, in an effort to keep the existence of the repository private I assume.\n. I still think we need both.  There both absolute killer features and neither is especially difficult to implement.  I was thinking private:mycompany/dialog because then two people in my company can consume the same component and be prompted for both username and password (which would both be different for different people)\n. +1 This is especially true since we're typically going to want to give things version specifiers of * because otherwise we'll end up with multiple versions of libraries un-necessarily.\n. For npm it is a very different argument.  There is a justification for locking version numbers as each module should only use the api of another module, not expose it directly.  There is no real benefit to having unrestrictive version numbers other than faster iterations of test/dev.  This is in itself very good.  I personally use the weakest version specifiers I can get away with so as to ensure the latest versions of modules get out there and tested as quickly as possible.\nThe reason that npm is different to component is that they nest dependencies.  It would be more or less fine to have 10 or 20 separate copies of JADE at different versions in a node.js apps.  It would be a disaster to have 2 copies of jQuery on a website.  It would be pretty bad to have more than 3 or 4 copies of component/emitter even.  Keeping version specifiers as weak as possible helps to ensure that everything simply works with latest, avoiding that hell.  Personally I'd be in favour of not allowing modules to lock the version numbers at all.  Perhaps instead provide a means for the APPLICATION to request a specific version of something.  So that I could (for example) request to use an old version of jQuery if I knew that a later one broke my app.  I wouldn't then get multiple versions of jQuery, I'd force all modules in my app to use the same, old version of jQuery.\n. They do exist, but they're not popular/easy to find/easy to install.  npm's scripts tag is really really useful for windows users as it allows you not to rely on make.  I'd really like to see something similar supported by component.\n. Only applies when using the component build form, component-build gives a different error.\n. If I run component build with a couple of console.logs I get:\nCall which with the string \"component-build\" then after that call, bin is set to the string \"component-build.CMD\".  The output of that doesn't seem to be used though?\nAlso, customFds appear to be deprecated I have no idea what they do.\n. Yeh, so the FDs can probably be removed.  Not sure what's causing the problems with spawn.\n. Out of curiosity I tried spawning path.join(__dirname, cmd) instead, but it didn't really help.  I then got the error: CreateProcessW: %1 is not a valid Win32 application.\n. Great work @geekytime thanks.  Have you tried adding node to the front of the commands so that we do spawn('node ' + command) ?\nI wouldn't of thought that these process would output enough info for it to matter hugely if it's buffered, it's more that you want to be able to see the progress for long operations as it happens.  If it's needed, I'd be in favour of the messier alternative (even if it is a little ugly) it's at least not much code to switch between depending on OS.\n. Actually, looks like we could just do:\njavascript\nchild_process.exec(command, {stdio: 'inherit'}, callback)\nAnd it would solve our problem of not working on windows and do the fds thing properly.\n. We do have path, I'm really unclear as to why spawn isn't working tbh.\n. Hopefully it'll get fixed in core in a future version, but in the mean time it's really important to work around this because we need Windows support to scale in terms of numbers of users.  I'm biased in that I'd have to move to something else if you dropped Windows support, but I also think that the whole project would flounder and fail without support for windows.\n. True, Windows is fail :( I'll build a spawn npm module for us to use that abstracts away the problem (unless someone else wants to take on the task?)\n. What do you mean by which()?\n. I hadn't looked at that.  I'm not sure what it gains us though?  It would tell us whether the command existed in the path, but we could do that just by checking for the existence of the file in the appropriate location?\n. Yeh, my intention was to ensure we stuck to exactly the same API so it would be easy to swap out if node ever provided a built in way to hide the incompatibility.\n. Cool, I'll use that\n. A sample readme file:\n``` markdown\nTitle\n=====\nDescription text here\n```\nNote, no new line at start or end, title done by underlining with = and is always the same number of characters as the title.  One line between heading and description.\n. I'm pretty sure the description is always exactly one line.  Oh, and Title is the repository name (i.e. excluding the username)\n. Yeh, I'm not too fussed about it either way, but we could detect that it's already there and not over-write it?\n. I do think component-init for a potentially empty directory would be more useful, especially given the integration with github and the large number of legacy libraries that need to be adapted.\n. Or just be fully resolved?  It would be a bit weird to be able to enter ../../index.js though.  Perhaps it would make more sense to just throw a friendly exception and get the user to fix it (given all the potential issues with making many implementations of the package manager work on different OSes etc. that may be simplest.\n. Surely we want to force component.json to live at the root?  It would be really weird to let users burry it multiple levels deep.\nI think we should keep this complexity out of component and just throw a nice error for now.\n. Just for tracking, I'm running into this a fair bit when looking at the @microjs libraries, which I'm converting to component form.  A lot of them already have package.json files with the './' prefix.\n. +1 We could create issues automatically using the github api.\n. True, that would be neat.  It'd be great if we could automatically detect jshint options were present and then execute jshint on the library, but that may be overkill.\nI'd really really really love a feature that detected when global variables were being leaked and created issues for that.\n. It should have some way to disable the linting though...otherwise it would be really annoying sometimes.\nAlso this encroaches on the territory of Travis... Perhaps we should just set repositories up by default to do these things when people enable travis CI on them?\n. I mean in component-create or component-init\n. At the moment you could still stash the entire repository offline (ditto for npm which is still only about 16 - 20 GB)\n. Should be an option, could use uglifyJS\n. Doesn't look like there's anything that'll break for windows.  There is a question mark over how long we should be supporting old versions of node?  I guess one stable release behind might be sensible.  I.e. remove support for 0.6 when 0.10 comes out.\n. I'm guessing this API also needs implementing on component.jit.su if we're going to move component.jit.su to component.io?\n. :+1:\n. We could do that but it only works when you eval the code as a string so we'd have to use new Function with the source of each module as a string.\n. Also source map should support inspecting variables provided you don't minify the code anyway.\nOn the other hand //@ sourceURL is way simpler so:\nI quite like the idea of simply replacing https://github.com/component/builder.js/blob/master/lib/builder.js#L645-L647 with:\njavascript\nif (devBuild) {\n  return 'require.register(\"' + file + '\", new Function(\"module\", \"exports\", \"require\", '\n    + JSON.stringify(js + '\\n//@ sourceURL=' + file)\n    + '));';\n} else {\n  //old code...\n}\nWhich would at least show up as separate files in the scripts pane on Google Chrome.  We then just need to pass the devBuild option through from some parent location.\nI'm not too fussed about the style sheets tbh.\n. I'm pretty sure variable inspection works fine with source maps.  It just doesn't 'map' the variable names for you.  If you don't do any variable re-naming then it's not a problem.  What that means is that source-maps are fine for concatenation, fine for languages that compile to JavaScript (e.g. CoffeeScript) but not perfect for minified files.  If you're trying to use a source-map to debug a minified file you're doing something wrong anyway though.\nSourceURL is of no use with compile-to-js languages, it doesn't actually load that file, all you do is say \"this bit of code has a name\".  If you add a sourceURL to code generated by CoffeeScript, it's still going to look like JavaScript.  Adding sourceURL's to a JavaScript file directly is also no-use as it doesn't do anything.  SourceURL is intended for debugging code that's generated on the client side or loaded from somewhere other than a script tag.  i.e. code passed to eval and code passed to new Function.\nTo Summarise:\n\nSourceMap\nCompile to JS languages, file-concatenaters/module-systems and limited support for minified files\nsourceURL\nModule systems provided they 'eval' the code, dynamic script loaders that involve 'eval'ing code\n\nBoth serve very different purposes, it just happens that there's a tiny bit of overlap, which means that we could use either, although SourceMap should give us marginally better results because it would mean we wouldn't have (function (module, exports, require) {\\n and \\n//@ sourceURL=foo.js\\n}) either side of our scripts.  The down side is that it's newer and support seems to be a little bit flakier.  I still have yet to see a good demo of it that's not trying to work with minified code though, and I suspect it works a lot better when it's not with minified code.\n. CoffeeScript produces new names, but it doesn't mangle old ones, so all the old names would still be inspect-able.  What you're doing only really works because JavaScript is actually an easier language to read and understand than CoffeeScript.  With CoffeeScript I think I'm not uncommon in the fact that if I have to edit it, I edit the generated JavaScript and back-port my changes to CoffeeScript.\n. This needs to also be an Asynchronous API\n. It probably needs to be a duplicated API in the same style as node.js's fs APIs.  For most things that can be serial they'll probably be faster in serial, but that may not be acceptable in examples like the component website.\n. @jonathanong allow me to elaborate: The command line portions of this library (e.g. https://github.com/component/component/blob/master/bin/component-install) should only be concerned with passing options, getting the current working directory and writing log messages.  They should then just pass that directly to an asynchronous method that is part of a public JavaScript API.  This would make it easier to automate tasks with component.\n. The problem is that there are lots and lots of opinionated ways of consuming components and as a component author I want to support as many of these as possible.  Versioning support in component relies on tags (I assume?) so they need to be entered for component to function properly.  That's the only git things I would do.  I'd only npm publish in the event that there is a package.json file present.  We could also store information about what publishing methods are used in the component.json file.\ncomponent.json:\njavascript\n{\n  ...\n  \"publish\": {\n    \"npm\": true,\n    \"git-tag\": true,\n    \"github-downloads\": true,\n    \"jam\": true,\n    \"component-wiki\": true\n  }\n  ...\n}\n. I'd be all for steering clear of git as being too opinionated, if we hadn't already made the tool github dependant.  It's important that you don't need git to consume the components, but you already need to use git to publish components.\n. I accept what people are saying about git-extras release I wasn't aware of the command, so that reduces things a little, although all those commands can be concatenated with & anyway.\nYou're misappropriating @visionmedia's comment.  component(1) happens to have nothing to do with npm at the moment.  Component (as in the spec) MUST have nothing to do with npm or node.js because that's kind-of the whole point (once I get time I might develop a component drupal plugin or a component Visual Studio plugin).  component(1) SHOULD ultimately have a lot of knowledge of npm, jam, require.js etc. Specifically, the component build command should have lots of knowledge of these things, because part of the role of component build is to make sure that you can consume components in any module system or even without a module system.\nAs for the comment about polluting the global namespace, you totally miss the point of the entire discussion there.  This is about automating the process of publishing a component to as many people as possible.  We want all the people using JavaScript modules to look at their modules and notice that they could use our component system to consume them.\nI'm NOT a consumer of modules who's too lazy to minify the files myself.  I'm a component producer who recognises the reality that not that many people are currently using component for their live applications.  If we want this to succeed we need people to be seeing component modules everywhere.  We need all JavaScript modules to comment in their readmes that you could install them with component install module-name.  Most people who produce JavaScript modules aren't going to accept making them ONLY installable using component though, so we need to make it easy to publish in all formats while writing in one format.\nTrue, we're not as tightly coupled into github as I initially suggested, we are however making github the default, so most people will be publishing components there.  We're also talking about adding a command, it would be a command to automate publishing providing you were publishing a public component to github, if you used an alternative repository, it would be irrelevant, but not a problem.\n. If component.io is going to start listing files for download as standalone/AMD builds, that will remove a lot of the need for this.  Is the code for component.io open source?  Would be happy to start contributing to building some sort of listing page that could be generated for each component.\nI was referring to the --standalone method of component build (I never use it without standalone): I guess it's true that knowledge of npm, jam etc. is not needed, just the formats that they use (which happen to all be the same).  I think I'll still look into creating a separate component-publish module as I still want to publish to as many repositories as possible for the time being.\n. I've now written component-release which checks versions are correct in component.json and package.json (if present) and publishes to npm, git tags etc. I didn't do github uploads as component.jit.su takes care of them for me now.  It does a fair bit that git-publish doesn't and has the added benefit of being windows compatible (as it's written in node with sufficient care)\n. I'll get rid of the leading v completely.  It does only place it in the tag message anyway though, so I think it should be fine\n. I do think it would be nice to clearly mark things that have the 'big' dependencies, such as jQuery.  I don't think the size of the components is going to be a big issue any time soon, but using say jQuery or Prototype just seems to fly in the face of the whole point of component.\n. hmm, some newbies will still write components that rely on jQuery for a forEach loop or to get an element by its ID.  That's fine as long as they're clearly identifiable.\n. Hmm, true npm run-script does it somehow.  I wonder how that works...  At the moment it seems like it's tolerant of the fact that it's not an exe file or batch file, provided it's referenced as component-install but not if it's referenced with a full file path.\nOne option would be to just load them using require('./component-' + command) instead, that would be completely cross platform.\n. tbh I think it's not too big a deal if for now we make sure that all our docs take the form component-command then users will never run into it.  I agree that ideally we would like to be able to ignore these issues, but we need good uptake of the tools, which means we can't really afford to lose all potential windows users.\n. :+1:\n. @wilmoore not quite sure what that is?  It looks like it's got underscore stuff in it?  Not sure what it has to do with this.\n. Awesome work guys.  I love this idea.  I'm happy to extend the component.jit.su website to serve this image.  I'm also happy to set it up with a landing page route that redirects somewhere sensible.  I think if we're doing that it's probably time we made it the official component.io website as it's probably better than nothing.  P.S. \"component.io\" will hopefully be much more google able than \"component\"\n. Component badge is now available as a dynamic badge (updated every 15 minutes) at https://component.jit.su/component-badge.svg\n\nAt time of writing that's 348 available components, but it should update every 15 minutes.\n. The biggest thing now is to try and get #189 sorted\n. Would it not make sense to include the badge in the default readme template?  I don't think we do that yet...\nIt would need to wait for the new website as I'll want to take component.jit.su down a month or so after the real site goes live.\n. I was going to suggest filtering them and replacing with something like the word component when on component.io. We're going to be monkey punching the hell out of readmes anyway\n. I'd say make the green white (and the writing in it black) with a black border, so it looks slightly less like a build status.\n. I think at the very least the default readme should say something like \"Install with component:\" where \"component\" is a link.  Ideally it would include a logo when rendered on github which could be removed when displayed on component.io\n. sorry, didn't see that\n. Yeh, search page is pretty high on my todo list for that site (right after getting standalone builds of components)  I really like replicating readmes provided that they're at least as good as on github.  I don't like them on nom because they're easier to read on github.  Hence working to add navigation.  You'll also notice I extract trqvis-ci info and the title to display separately.  My intention is to also show installation/download instructions in the header.\nIt was heavily inspired by the less site and the vows site (I stole a lot of their css)\nI'm going to work on modularisation as well.  I envisaged that someone could pick a few more colour schemes so they repeat a little less frequently.\n. I've refactored a little to get things a bit more modular.  Forget that though, there's something way way more exciting:\nhttp://component-website.jit.su/ForbesLindesay/promises-a/download\nAll the download links work.  You can also link to http://component-website.jit.su/ForbesLindesay/promises-a/download/latest.js or http://component-website.jit.su/ForbesLindesay/promises-a/download/latest.min.js which will redirect to the numbered version if at least one tag exists, or the dev version if there are no tags.\nThere seems to be a alight but on nodejitsu with executing scripts, so I had to add timeouts and have no way of knowing when the component-install and component-build commands complete.  If we can get an api for these that'll totally solve the problem.  Anyway, if your finding it's slow to build, it's probably because there's a 5 second timeout (in total) which always gets used.\n. At the moment it doesn't work for libraries that have dependencies for some reason :(\n. Right, I ripped out all the exec stuff, so now I just download and build the components manually.  It's a lot faster now, and works for libs with dependencies.  It doesn't yet handle semver properly, I just support absolute versions and *.  This also has the advantage that I now support AMD :smile: and you can define .standalone in your component.json file to determine what property of window gets assigned (it defaults to camel casing the name).\n. OK, I'll take reading it from component.json out and just leave it as camel cased.  I've left the AMD with the original path anyway.\n. Now it has a home page http://component-website.jit.su/ which pulls the list of components from the wiki.\n. Yeh, the styling could probably do with being a bit more subtle.  I'll accept pull requests that improve things.\n. Moved the website to http://component.jit.su/\n. @devinrhode2 I'm certainly up for that, depending on when we can both be available... my typical hacking hours are 3pm - 10pm UTC\nI do plan on moving in that direction, search is next on my priority list, and immediately after is adding stats for stared/forked etc.  We can do a lot of stuff to that home page as well.  I expect to add a section at the beginning of it that does more to explain what component is, how to use it, and links to other pages (such as the FAQ and the building better components wikis).  From the point of view of displaying the repositories themselves, I parse the html page for a list of components grouped into categories, from there it's up to us how we display them.  One option would be to re-order them within the category by how many stars they have...\nThe site does already do a lot of things not supported by GitHub on its own.  Check out the dependencies section that gets automatically added to the bottom of the page here.  Or the auto-generated downloads page here\nAnother high priority is licence documents, I want to make it easier to quickly identify which repositories have which licence.\nI'm happy to see you creating lots and lots of issues at ForbesLindesay/component-website for things you don't like or think could be better.  It has a long way to go, and I really want people's input on this.\n. Has something happened on this?  Curious as to why it's been closed now.\n. Incidentally, https://jepso-ci.com can fill this role pretty nicely now.  Builds can be triggered either with a hook or by making a POST request to https://jepso-ci.com/api/hook/:user/:repo/:tag\n. Yeh, sounds good, for the time being I've moved my website to use it's own custom code for everything except the build stage (for which it directly reverences component-build).  This turns out to be way faster & more reliable than execing stuff, and I found that mostly it wasn't that complex.  The only issue is my semver handling is limited to * and absolute versions.\n. I've also come across an interesting thing when building the site's implementation - some people tag versions as 1.0.0 while others tag them as v1.0.0 which makes them difficult to pick out. At the moment there are quite a few operations on the site that involve getting all tags, and then working out which one is correct.\nMy main problem with how I've implemented it is that the first component to be downloaded gets free reign on which version each of its dependencies have, then other components get errored if they're not compatible, even if there does exit a compatible version somewhere in the middle.\n. :+1:\n. A little ugly, and they aren't going to integrate building components for you any time soon.  P.S. on this subject I'm building a mocha-ci website, see http://mocha-ci.jit.su/ForbesLindesay/mocha-ci-sample an early prototype\n. Well I have http://mocha-ci.com well under way and if @saucelabs can provide me with an account that has unlimited minutes, I'll happily run it as a product that's free for all open-source code.\n. Any chance I can also use it for the mocha-ci I've created, and plan to make support components?\n. done :smile:\n. I've submitted a pull request to update win-spawn (now win-fork) #194 which fixes this.  Note that in the mean time component-build and component-install etc. work fine as an alternative to component build and component install\n. --save-dev does in npm, would be nice from a UX point of view to match that.\n. cool, I'd personally like npm to go the same way :+1:  Could probably change the title of this to remove --save then.\n. If I can be added as a member of the component organisation I'm happy to also transfer repo ownership to component, so that it can remain the one true website, and get progressively improved.\n. Awesome, thanks.  How do you want to precede? Do you want to copy the code from ForbesLindesay/component-website as is, do you want to clone that code along with past commit history, or do you want to start from scratch (with a certain amount of copy and paste)?\nIf you want to go from scratch: I'm guessing we want an express website, do you have any preference on JADE vs. EJS etc. What else do you want to be different?\n. Cool, I look forward to seeing what you've done.\n. @eldargab What about if instead of auto-requiring all dev-scripts we had a \"devScripts\" array that got included and a \"devMain\" that got auto required if present?\n. Yes, but in any such case you can refactor to have one main:\njavascript\nexports.a = require('./main-a');\nexports.b = require('./main-b');\n. I'm fine with dropping the auto-requiring ability though, assuming that other people are in agreement that it's not wanted.\n. But then you can't use the same script in the browser and in node.js because they use different requires.  It also makes it harder to require internal parts of the component to test separately.\n. Personally I prefer the really explicit:\njavascript\n\"development\": {\n  \"something\": \"./test/whatever.js\"\n}\nYou'd need to have a lot of dependencies before that became too much redundant information.  Also it'll make building tooling much easier if we have a more explicit format.\n. Surely you'd require whatever was on the left hand side?\njavascript\n\"development\": {\n  \"something\": \"./test/whatever.js\"\n}\njavascript\nvar something = require('something');//loads the ./test/whatever.js file\n. Part of the advantage is that it can be used to define aliases\n. The problem is you need some system to specify which scripts are included for development and some of those must be scripts that aren't included when you go live because you don't want to include tests in your live system.\nBrowserify gets round this because your test scripts can just require the application.  component doesn't have that luxury, it has to be explicitly stated somewhere.\n. With npm, you can git clone then just npm install and you get all the missing development dependencies.  We have the same thing here in that you can do component install --dev and get all your development dependencies.  The problem is local scripts that are for testing only.  You need a way to build a test bundle that, when loaded in a browser, runs your unit tests.  With browserify you just do browserify test/test.js > test/build.js and you get a new file that's built and has test/test.js as it's main file instead of the normal main file.  Component currently has no way of building a bundle which has a special test module as the root file.\n. True, we could have a component build foo.js that results in foo.js being the main, and includes foo.js and any files that are included by the component.json.  That way for normal production use you'd do component build app.js and then just add that script to the page (no need to also requrie('app')).  For development use you'd just do component build test/test.js --dev and it would add test/test.js even though that wouldn't be in the component.json file.  Still makes it very difficult to write multi-file tests.\n. I was thinking more for renaming, I never deprecate a version of a module (that's implicit in the creation of the next version of that module).  I have renamed modules though, and I feel it's important to leave a helpful marker behind where the old name for the module is.\n. Needs to wait for https://github.com/component/builder.js/pull/69 but otherwise good\n. A small number of them have some sort of CI badge.  At the moment that's either jepso-ci (my creation) or testling-ci (from substack).  Soon that will include visionmedia's creation.  I'm still hopeful that since all will expose JSON APIs we should be able to display results from all 3 in a consistent fashion on http://component.io  Once they're all a little more finished I might have a go at persuading substack to do the same with browserify.org once I've finished the public API for jepso-ci.  There's no reason module system and testing continuous integration should be tightly coupled, that would be a terrible situation.\n. Yeh, my plan is to generate testling and \"visionmedia style\" badges from jepso-ci in addition to its own style so that all of them are available.\n. Might want to add 'instead of adding symlinks'\n. ",
    "jonathanong": "+1\n. thank you!\n. how can we disable URL rewriting for CSS? I prefer to handle all static assets myself since they're all going into a CDN.\n. Oh of course not. My question is just how to disable url rewriting so /images/image.png doesn't become /mycomponent/images/image.png when building. I don't see any options anywhere.\n. moving convo to: https://github.com/component/spec/pull/1\n. sure. \n. Yeah I'm going to try to do this tonight. It's been distracting me from other stuff so I kind of have to :/\n. and it would be basically a full rewrite, so it won't be pushed until a lot of tests go in\n. yeah that's why i wanted to wait for the registry. but we should support github, bitbucket, etc. anyways in case the registry fails or something. \n. it would just make things easier as the registry can handle the semver logic. not a big deal though\n. yeah i have it generally working for github now. working on the builder now\n. semver is more complicated than just using the package. i have semver going in https://github.com/component/resolver.js. you can try it with https://github.com/component/watcher.js but it's a little hacky right now\n. master w00t w00t\n. aliases are currently only built in development. the only component that doesn't get aliases is the \"main\" component\n. oh. aliases were required before 1.0.0. 1.0.0 doesn't have any aliases except during dev.\n. okay going to close this then!\n. hahahaha apparently you changed the name of the page to \"r\"\n. moving to https://github.com/component/spec/pull/4\n. this is such a vague issue. can you guys add suggestions here? https://github.com/component/spec\n. i agree, but issues should be more specific. i.e. what API do you want? what's your use-case? we also should figure out specs first before we refactor. \n. i'm going to close this unless someone has specific issues they want tested. \n. going to close this for now. logging is a whole other beast. \n. since we're going to move towards a registry, i'm going to close\n. moving conversation to: https://github.com/component/spec/pull/1\n. crap. missed this issue. we had a convo here: https://github.com/component/spec/issues/26 consensus is to basically keep things where they are. we've agreed that the ideal structure is to have a single, flat folder of components like lib/*/component.json. \nif you guys have any input, add a comment in that thread or an issue in that repo. going to close this for now.\n. Bump your ulimit\n. cool. thanks!\n. i remember asking for this when component was like 0.0.1 but now i'm against it. closing it since options = bad!\n. no longer an issue because i removed the --json option\n. closing for now\n. yeah, rather stick with debug. reopen if there are specific events you think might be important.\n. should work in master now\n. going to close this for now. logging is a whole other beast. \n. do you still want to do this?\n. going to close this for now. will probably make things more complicated\n. moving convo to https://github.com/component/spec/issues/21\n. closing this and moving discussion to https://github.com/component/builder2.js/issues/26\nif you guys know a really simple library that easily makes source maps from just concatenating stuff, let me know!\n. going to close this for now. you can reopen in https://github.com/component/remotes.js\nthe current problem is that remotes are no longer just \"configuration\", so what you would basically need is a global node module or something.\n. i agree in general, but this is still the early stage of my project and i'm building it in components from the ground up. i could also create one giant project then extract the component, but meh.\n. yep. just wondering what the current/future status of it was. thanks!\n. gah i think i'm going to go with source maps. i can't debug in safari.\n. problem isn't just syntax errors. runtime errors don't have good stack traces in safari w/ sourceURLs. not sure how much source maps would help. i plan to add syntax error checking anyways.\nor does everyone only debug on chrome o.O?\n. yeah, but when an error throws, i get \"undefined\" in my stack trace. woohoo! \n. any error during runtime\n. https://github.com/visionmedia/superagent/issues/1\ni think this is fixed\n. is there an npm module for this?\n. precompiled steps should be delegated to modules. open a new issue if anything.\n. going to close this as package is moved to a separate repo\n. merging into https://github.com/component/component/issues/346\n. i don't think semver is necessary either. i either use * or the exact tag as well.\n. @jkroso nice. first component plugin i might actually use :D\n. okay guys, v1 will only support github :(\nthe problem is that with semver resolution, we'll need an adapter for every single end point. crazy JSON configurations aren't going to cut it because we also need to handle how the response is returned as well as auth and rate limiting. this is what https://github.com/component/remotes.js aims to do, but right now it only supports github since that's what most of us use.\nplease make PRs to other endpoints!\nif you NEED custom endpoints still, just stick with 0.x for now.\n. https://github.com/component/component/commit/6e1094a764640c0a4b179cbb140ed914c80ee195\n. do you mean something like this? https://github.com/component/builder.js/pull/67\n. changed it to 1.0.0 since that's what it really is\n. https://github.com/component/component/issues/312\n. crap i made a wrong reference. we're not going to integrate with bower, though.\n. so confused\n. damn i tried component ls for the first time and its beautiful. i don't know why this issue isn't closed, though.\n. People use other package managers that use npm like browserify\n. @razic errr right. build tool. \n. okay this error is no longer relevant in master, so i'm closing.\ncan you guys open a new issue with what remotes you guys use and such? i'm only commissioned to make github work, but i still think supporting other custom remotes is important.\nlike i said in another issue, if you need custom remotes, stick to 0.x for now\n. Basically peer dependencies?\n. prefer if we keep it peerDependencies instead of creating an entirely different spec. it'll also be easier for new component users coming from npm to understand.\n. oh god i forgot they did that. i guess that point is moot then. \n. i vote to stick with npm specs and devDependencies and peerDependencies, but augment is one of my favorite words :)\n. https://github.com/component/spec/issues/11\n. moved the search logic to https://github.com/component/search.js. please feel free to update the algorithm!\n. cahnged to //# sourceURL in master\n. i don't think we should limit this issue to only html templates, but any type of \"string\" file like what component-string does, so you can use any type of template you'd like, whether it be html, jade, or ejs. so we should rename this issue to \"native template support\" or something.\ni'm okay with var html = require('./template') as an alias for var html = require('./template.html'), but it has to check .js, /index.js, and .json extensions first. i like to make components with the same file names, ex. dropdown.js, dropdown.css, and dropdown.html, so var template = require('./dropdown.html') should be specific.\n. +1 for \"templates\": [\"foo.jade\", \"bar.html\"]\n. https://github.com/component/create.js/issues/6\n. did a doc overall at https://github.com/component/guide\nhopefully https://github.com/component/guide/blob/master/component/getting-started.md and https://github.com/component/guide/blob/master/component/vs.md sheds more light on Component. feel free to make suggestions or open new PRs.\ni've added a lot of you as collaborators, so feel free to add stuff!\n. I think it's just a shortcut for fit style URLs\n. *git\nyou can just do \"name\": \"user/repo\" , not sure about \"name\": \"user/repo#tag\"\ni just prefer if everything were the same :D\n. also, just noticed this is also what bower does. if component supported this, there would be a lot less complaining by other people haha\n. oh god why wasn't this merged. i used component create for the first time the other day and was like \"WHERE ARE THE DEFAULTS, MAN!?\"\n. https://github.com/component/create.js/issues/5\n. haha. went through all my components and found out it was superagent that threw it:\n``` bash\ncomponent install visionmedia/superagent\n install : visionmedia/superagent@master\n\n_stream_readable.js:720\n    throw new Error('Cannot switch to old mode now.');\n          ^\nError: Cannot switch to old mode now.\n    at emitDataEvents (_stream_readable.js:720:11)\n    at IncomingMessage.Readable.pause (_stream_readable.js:711:3)\n    at Response.pause (/usr/local/lib/node_modules/component/node_modules/superagent/lib/node/response.js:80:12)\n    at Response.ondata (stream.js:52:16)\n    at Response.EventEmitter.emit (events.js:95:17)\n    at Stream.EventEmitter.emit (events.js:117:20)\n    at Unzip. (/usr/local/lib/node_modules/component/node_modules/superagent/lib/node/utils.js:117:30)\n    at Unzip.EventEmitter.emit (events.js:95:17)\n    at Unzip. (_stream_readable.js:736:14)\n    at Unzip.EventEmitter.emit (events.js:92:17)\n```\n. Err... To be specific, this is component 0.16.5.\n. the original issue no longer exists for me. closing. \n. @calvinmetcalf do you have an example repo where this happens? want to test some stuff out without making a  repo\n. moving convo to: https://github.com/component/spec/pull/1\nalso, i'm +1 for releases because i think it's both trivial and nice with a registry\n. +1. right now i'm using a subfolder with its own component.json and Makefile. anyone know an easier way?\n. what is this boot thing? are these just different subfolders or what?\n. this looks like just splitting one large app into subcomponents, then bundling them all together. is that correct? i'm looking to make completely separate builds but reusing some components. \n. @yields oh that's basically what i'm doing now. it redownloads all the components if i do that though, which is kind of annoying. \n. @visionmedia just removed aliases! going to close this for now. \n. https://github.com/component/create.js/issues/4\n. https://github.com/component/create.js/issues/3\n. hmmm well you don't have a component.json in your user/ directory, so you won't be able to require('user') anything anyways. node doesn't even like when people do require('module/submodule'), so i doubt component will, either.\nyou can make user/ it's own \"booted\" component, then do something like require('user').model. that's what i would do, personally. or use prefixes like require('user-model').\ni'm going to close this because it's not a typical use-case, it has a workable solution, and there are more important bugs to fix :)\n. moving convo to https://github.com/component/spec/issues/20\n. what did you need it for?\n. not 100% sure if this works for you, but you can try https://github.com/yields/component-bundle\nit's probably good to revert for now until the more important parts of component are set in stone.\n. this will just add the name to locals and the path to paths, if not already? easier just to edit the component.json directly IMO.\n. oh. i'm not going to support ../ locals. all locals should be within the app context.\ni'm going to support this later as linking, so closing this to merge with https://github.com/component/component/pull/181\nidea is to do component link ../some-component, where some-component has .version and .repository properties. then component will link it to components/<repo>/<version and treat it as a remote dependency.\n. merging with https://github.com/component/component/issues/256\n. just did a doc overall at https://github.com/component/guide.\ndon't like how the current \"getting started\" uses locals. i think this example is much easier: https://github.com/component/guide/blob/master/component/getting-started.md\nplease open issues and PRs in the guide! i'm going to cleanup this readme and point to getting started. \n. just ask more questions so we know what to add.\ncomponent is basically a stopgap for es6 modules and web components, and when they are available across most browsers, component would basically just do semver and server-side bundling as everything else would already be handled by the browser.\nwhat opinions does it enforce that you like or don't like? if you write bare components (without templating languages, future JS syntax, and CSS preprocessors), you shouldn't need custom watch/minification functions. also, components is broken into libs so hopefully customizing stuff shouldn't be too difficult.\n. > I was initially using component to build 1 big component that would house a bunch of small components, that wouldn't necessarily all have their own repo. \nhttps://github.com/component/component/issues/483\ni'm going to try to get this in component 1.1.0. it's a little more complciated, but yeah, it's very ideal for subapps and such. you would link an app to a subapp via component link, and it would take the main app's environment.\n\nAnother one that I initially wasn't a fan of is the \"all-lowercase\" approach to component names\n\nthe problem with this is that some files systems are case sensitive and others are not. easiest way to avoid this problem is to not support other cases as well. if we can figure out a way to make cased names work, i'm down!\nfor watch, we're using https://github.com/amasad/sane, which is pretty good so far. i was trying gaze before, but it was super leaky and slow and doesn't watch added files.\n. fixed apparently thanks to @airportyh \n. closing as this stuff is now in component/package.js\n. https://github.com/component/spec/issues/16\n. i'd prefer an auto-require option as well. standalone wraps everything in a closure, then i can't access require anymore, which would be important if i wanted to do separate build.\n. any specific reasons you want to use riak?\ni don't mind auto prefixing, but i don't want any options. we should just use autoprefixer's defaults which handles 99%+ of browsers.\nwhat is component publish supposed to do other than validate your package? a component doctor command like @leostera suggested makes more sense to me since in component, publishing is just pushing a tag. plus, working with npm, i would expect files to be uploaded if i did xxx publish.\n. splitting this convo to the above referenced issues\n. i would just call this global or something. i don't know what no-common means.\n. also, i'm not sure why you need --standalone when doing --global. you should be able to just do --global <name>.\n. yup, sounds better now. still don't know if they'll push this though :P\n. personally, i'd like different types of build options. i wouldn't mind maintaining them myself. the one i would particularly use is auto boot https://github.com/component/component/issues/422\n. @dncrews is this for an app or for a component?\nIMO now the only built-in options should be UMD and auto-require (default). \n. going to make it autorequire by default, then UMD as the only other option\n. we're trying to make component(1) as simple as possible. i don't think many people would use this version, especially since you might as well wrap it in a closure for some extra possible minification. autorequiring and UMD are the most common builds. plus, you only lose a few bytes with umd, so i don't think it's really worth it to add a new option.\nyou can always use the JS API though. i haven't updated master yet, but it (should be) pretty simple.\n. a component registry would even require registration. it already has all the packages in the wiki.\na cool idea would be to just have component ping the registry whenever a component is installed (or manually), then people can get analytics about their packages as well as the registry updating the info (specifically version tags and component.json metadata). \nonly reason i want a registry right now is because checking tags requires a github API request and they rate limit it, which is annoying if you have a lot of dependencies (at least for component-set).\n. https://github.com/component/spec/pull/1\n. https://github.com/component/spec/issues/10\n. i think downloads or installs would be helpful. i've had some components i no longer use with no stars/watchers that i deleted, but people complained when i deleted them - i had no idea anyone was using them.\n. https://github.com/component/spec/issues/10\n. https://github.com/component/spec/issues/9\n. @seanhess are you making public components for others to consume, or are these for yourself? if they're public components, no one's going to use them. if you're consuming it yourself, i would just save the TS files as .js and add a compilation step to my build step. i assume that would work since TS is a superset of JS. i do the same with my CSS files (reworking and auto prefixing the build files). \n. going to close this for now. there's https://github.com/edjafarov/component-typescript which hopefully works for now.\n. https://github.com/component/create.js/issues/2\n. some thoughts i had recently about component:\nit really isn't just about external components. the primary benefit (at least to me) is internal components:\n- modularize your app, each with its own dependencies\n- be able to just move a local component to an external repo, change the component from a local to a dependency, and automatically have versioned components\n- internal dependency tree of your app's components\nother obvious benefits:\n- no crazy nested folder structure\n- keep your js/css/images/fonts/etc together\n- no crazy require('../../../../../lib') calls\n- no stupid npm namespacing or downtime\n- no additional publish step\n- easy forking\n- no need for a package manager like npm or bower\n- no need for a build system like grunt, gulp, or broccoli\n- no need for a client-side loader like requirejs\n- no need for crazy long config files - component.jsons instead\n- builds faster than browserify because it doesn't parse the JS\n- no need to @import all your CSS files like all the npm-based CSS seems to be doing\n- one step away from the Web Component spec (i've been thinking how to integrate shadow templates)\na good example of how client-side assets should not be structured is ghost: https://github.com/TryGhost/Ghost/tree/master/core/client. it's so confusing. i think if we explain these benefits succinctly (i.e. a walkthrough isn't necessary, just a demonstration), more people will understand it.\nhow about for now, we create a component/wiki, component/guide, or component/docs, and i'll add you guys as team members? which name do you guys prefer?\n. hmmm i'll create component/wiki so people know they are supposed to contribute. \n. god damnit that was already taken. https://github.com/component/guide\n. i just did a doc overall at https://github.com/component/guide. please make PRs for any suggestions :)\n. @MatthewMueller you wanna rebase and merge this?\n. https://github.com/component/create.js/issues/1\n. i'm going to close this as i don't think this is even possible with github. just tried GETing it from https://raw.github.com/rogerz/d3-cloud-for-angular/d3221b5e2e0d6fe8864e0c48de14cabf5674be1e/images/20%.png\n. oh whoops was thinking 20% was a space. seems like we just need to encodeURI() when GETing stuff\n. i'm leaning towards explicitly not supporting this. is there a good reason you need symlinks in a repository meant for client-side consumption? for node modules, maybe, but i'm not sure i see the point for the browser\n. k. added a note that this isn't supported: https://github.com/component/builder2.js/commit/674662baf36fc0c186e682336608c3a35ad22c91\n. hopefully fixed by https://github.com/component/spec/pull/4\n. yeah it kind of sucks right now. some of my builds are like 50% aliases, but after gzip it's generally < 5% so i wouldn't really consider it a big deal. \nin the future, aliases will be removed: https://github.com/component/builder.js/issues/130\ngoing to close this since it's more of a builder issue. ill tag all the alias issues in that repo to make it clearer.\n. https://github.com/component/component/issues/444\n. how about --js and --css options instead? skip the whole --mode party.\n. going to go with --no-css and --no-js. what do you guys think?\n. how about component build scripts, component build styles?\n. okay cool. just agreed with @regular about the semantics. \n. landed in master\n. haha shoot, that was supposed to be squashed. hmm. you should be more interested in https://github.com/component/build.js\n. what specific issue does this solve?\n. should be fixed in master\n. hopefully a registry can resolve this issue so redirects from the client would be unnecessary\n. is this an official change or what? i can't find docs on anything raw\n. well it's a 301 redirect so i guess it's permanent... haha\n. hmmm only some repos can be accessed via the new URL, so the only real way to change this is to fix redirects =/\n. i don't get it. superagent is supposed to follow redirects 5 times, but it doesn't. is it broken? @visionmedia \n. oh LOL i got it. it's using raw HTTP. that's just ridiculous haha\n. btw this will be easy for pinned components, but it won't work when resolving semver since github's API doesn't do redirects then. will be sure to throw if that's the case.\n. closing as master supports this now. but component can't deal with semver resolution w/ redirects https://github.com/component/component/issues/497\n. style consistency is only valid within a project IMO, at least in open source. just try to respect the original author's style :). \n. i worked a little on a \"resolver\" that resolves all the locals and creates a list of component.jsons in correct order as well as resolves/consolidate dependencies based on spec changes. this would also be helpful for utilities like component-bundle and component-size since they all basically resolve everything themselves.\ngoing to wait until @visionmedia releases the registry, though. right now, dependencies are resolved recursively with a LOT of HTTP requests. IMO, the registry should resolve all dependencies in a single HTTP request. not sure what direction @visionmedia wants to go with the registry, so i'm waiting :)\n. okay so i made three repos:\n- remotes.js to normalize remotes. only supports local and github so far, but eventually it should support the registry, bitbucket, gitorious, etc. \n- resolver.js that resolves the dependency tree and also downloads components. downloads are included since most of the download logic is actually handled by remotes.js (since we'll probably download files differently from different remotes)\n- builder2.js as a new streaming builder that builds based on resolver.js's dependency tree. lots of new goodies like a much leaner require implementation and no aliases\nprobably won't be done for a while, though. \n. this is a convo between @reinpk, @visionmedia, and @ianstormtaylor . feel free to chime in.\n\nHow does the flattening step work? Curious, instead of forcing the user to flatten before passing it into the builder, why not just let the builder accept the tree, and then have it flatten it itself if that is a necessary step for building.\n\nflatten(tree) returns a list a flat list of nodes. the builder would then basically do nodes.map(plugin1).map(plugin2).join('') and return that result. \nallowing just passing the tree to the builder is a good idea as most people don't need to manipulate the tree anyways. however, if this were the only way to do it, then building and splitting different bundles is a little more complicated. plus, it's nice to have component-flatten in a separate repo.\nhttps://github.com/component/builder2.js/issues/28\n\nOne of my thoughts is that something called resolver complicates the system in general, because it seems like it takes on a lot of responsibility\n\nwell my opinion is that it \"resolves the local components and remote dependencies\", which includes installing them. installing is very easy (it's only a few more lines since most of that logic is in remotes and component-downloader) so i don't think it's overly complicated. \nhttps://github.com/component/resolver.js/blob/master/lib/dependencies.js#L92\nyou can only resolve local dependencies with dependencies: false. i'm not sure how to split up local component resolution and remote component resolution into separate repos though. most of the logic in resolver.js isn't actual logic, anyways. it's populating objects and checking states for race conditions.\n\nI like the current separation between install and build in the system. It makes it clear that for example we could just install when the server is first started, and then build on requests.\n\nmy philosophy now is that install is just the resolver. build is now just resolve + build. there's no difference between an install step's resolver and a build step's resolver. if everything is already downloaded, there's no \"installations\" happening during the resolve step (it'll only need to lookup the local remote), so it'll essentially be the same as the current build step.\nthe plus side is that if a component isn't installed when you build, it'll install it automatically. i personally like this, but it's easy to switch off. if i change a version and rebuild, the next build will work automatically.\nright now. we're actually resolving the app in two modules, once during installation and the other during building. we only need one resolver.\n. there are too many ways to write the install/build flow. one change i just thought of recently is with remotes and locals.\nCurrently, the default is remote = remotes(['local', 'github']), where local and github are included. However, this is a little confusing when you have custom remotes and sometimes you don't want to check local, i.e. when you are checking if you have the latest version.\nso i'm going to make local an option:\njs\nvar remote = remotes({\n  local: true\n}, ['github'])\nor something\n. > It feels like letting the builder doing the resolving, and letting the installer only worry about installing and downloading can reduce some of the complexity from resolver.\noh no. it won't. the installing/downloading is all done in remotes/downloader and is only a few more lines in the resolver.\nyou're still going to going to need to build a dependency tree for both the builder and the installer. making it different in the builder and the installer will make it less DRY as well as more complicated if we want to support stuff like https://github.com/component/component/issues/483\n. we could also forget about the niceties of each module and instead make a component API:\n``` js\nvar build = component\n  .remotes(['github'])\n  .set('root', process.cwd())\n  .set('development', true)\nbuild.scripts()\n  .use()\n  .write('build/build.js')\nbuild.styles()\n  .use()\n  .write('build/build.css')\n```\n. oh btw, for one-off installations, you can do:\njs\nresolve({\n  dependencies: {\n    \"component/emitter\": \"*\"\n  }\n}, { \n  install: true\n})\nkind of ugly, but it treats the first object like any other component.json. we can expose a cleaner API via component:\njs\ncomponent\n  .set('destination', 'components')\n  .install('component/emitter', '*')\n. > for flatten i think we should figure out a way to have that not be something that needs to be exposed to the user\nyeah, i made flattening optional now. the builder will automatically flatten.\n\nright now it seems to me like the resolver is trying to do too much\n\nalthough i understand that concern philosophically, i don't see a pragmatic issue or a better solution. other than a nice API, what's the issue when you can just set dependencies: false, and not have the resolver resolve any dependencies? or install: false and not have the resolver install anything? i don't see any possible edge cases. having users use 5 different modules to do a simple task is not user-friendly imo, then we end up in substack territory.\nan alternative is to have something like resolve-local-dependencies and resolve-remote-dependencies, but i tried that and it made things more complicated because you need each module to have it's own API, then glue all the APIs together. and it's harder for them to work together and be consistent.\n\ni'd rather figure out an abstraction that keeps things simpler in general, and involve less nested objects or big options objects to work with\n\ni'd rather not have abstractions in the core libs and keep the underlying code as simple as possible. we can always create a sugar API on top, which i think component should be, where we can argue about ideal API (which I agree, the current API isn't ideal). i'm just trying to get this out ASAP.\n. for remotes, the only issue is that some libraries want local as a remote, but some don't. and they can't just remotes.use(locals) because it has to be first. we could do remotes.prepend(locals) or something, but i don't really like that since libraries will basically be messing with people's remotes. \nso for now i'm thinking that people create their own remotes through a function where all settings like locals can be intercepted:\njs\nmodule.exports = function myCustomRemotes(options) {\n  var remotes = new Remotes(options);\n  remotes.use(githubenterprise({auth, pass});\n  remotes.use(github({auth, pass});\n  remotes.use(bitbucket({auth, pass});\n  return remotes;\n}\nthen for a \"outdated\" command or something, you would pass the remote in like:\njs\noutdated(myCustomRemote, function (err) {})\nwhere outdated does:\njs\nfunction outdated(Remotes, done) {\n  var remotes = Remotes({\n    local: true\n  });\n  // ...\n  var remote = remotes.resolve('comopnent/emitter');\n  var versions = yield remote.versions('component/emitter');\n  // do stuff\n}\n. closing for now. i have https://github.com/component/build.js for a nicer build api. open to more suggestions!\n. https://github.com/component/spec/issues/8\n. https://github.com/component/component/issues/450\n. added outdated and update for now: https://github.com/component/spec/commit/ea1e740908d76b89a08aae3fba25a50d6fe19301\nthinking about it more, test doesn't belong in it. i don't really care about size.\nif anyone has suggestions, open an issue\n. moving to https://github.com/component/spec/pull/3\n. i'm using it right now and it's pretty slow to compile. wouldn't mind for testing and dev, but i'm against it for releasing.\n. let's worry about the spec first :D\n. going to move all these convos to a spec repo. kind of noisy in here.\ni'm moving the convo here: https://github.com/component/spec/pull/1\n. you should move this type of discussion here: https://github.com/component/spec\ni'm currently writing a proposal for a caching server + registry, so i don't think this will be necessary if we implement that anyways.\n. yeah it's new, no worries. feel free to add comments and suggestions and open new issues!\n. We cjs guys don't know enough about this, but the umd wrapper we use is the only one I've really seen.\nDo you have a source?\n. talking about this specific issue. i'm not going to read their specs =/ doesn't quickly explain why [] is required. \n. can you make a PR here? https://github.com/umdjs/umd/blob/master/returnExports.js#L40\n. we're using their implementation. if the umd guys are okay with it, then so are we.\n. Nice! Thabks\n. hahaha\n. yeah same. haha\n. it's working again as that version of builder was reverted. reopen if it's still an issue (works for me now)\n. how are you splitting up builds?\nyou can use something like https://github.com/yields/component-bundle, though i foresee a billion different ways and edge cases with custom builds and i'm not sure how it handles those. \n. imo it sounds like the real issue is that component doesn't have a good bundling framework, not that you actually care about --out. \ni'm +1 to removing options from the CLI for simplicity. however, you should be able to specify your --out directory using the JS API as component becomes more lib-ish. component(1) should be accommodating small web components, and complicated apps should be using the JS API.\n. i'm going to put this in, but i want it to be a hidden feature. i.e. it won't display in component install -h and stuff. trying to make the help commands and simple and short as possible.\n. anyone know how to make an option in commander.js without having it print in help?\n. this is going ot be annoying because you would basically have to do --out in every CLI command. let's discuss this in https://github.com/component/component/issues/517\n. so the main concern is just backwards compatibility? for v1, we can break backwards compatibility so we will. you can always continually use an old builder/installer, but your packages won't work once deps are using semver.\nit won't eliminate those commands though. it'll just be a subcommand of the watcher, which will automatically exit.\n. yeah that's how it pretty much how it works right now but with the new builder. it's a little smarter though in that it only re-resolves with component.jsons change, only builds js when js build files change, etc.\nif you just want component install or component build, you can still do it, but they will be pretty much unnecessary. otherwise, you can component watch then install in interactive mode (or do nothing and update a file). \nthe only breaking api change i'm looking at for component(1) would be the removal of component build -u which would be for unrelated reasons. i want component itself to be component watch since right now it's component --help, which isn't really helpful.\ni'm not sure how this is a concern for production because since you should be building and minimizing before you deploy. you also don't have to use the watcher.\n. > my projects must not be big enough yet\nyour projects are bigger than mine haha. it's not just about the performance, but the performance + not having to manually type make. i find alt-tabbing between 3 things (browser, shell, editor) annoying - prefer if it were just two and have the shell log what it's doing. typing make at all is annoying, but it's especially annoying when you have to wait a second to refresh the browser.\n\nit's really effectively a make-like task runner\n\nyeah, it's a watcher + make basically\n\nso what we maybe really need is make-style mtime checks wrapped up as a function, and watch is really just an interval on that.\n\nisn't that what most watcher libs are? the bigger problem for component imo is intelligently knowing which files to watch (at least without leaking). the actual watching is easy since people have already solved this problem.\n\nGrunt tasks with plugins wrapped around component install, build, watch etc work for us.\n\nwhen building this, i'm thinking of how a screencast would look. right now, you have to use the CLI + make your own task runner, which is pretty annoying. component also doesn't do enough, which is why people like @sankargorthi need to use grunt or gulp in addition to component.\nwith this watcher, you shouldn't need any other tool like npm, bower, gulp, grunt, browserify, or requirejs. you'll just type component in the shell and never touch it again. the screencast would just be you architecting and creating your app instead of creating a makefile. The user can see the watcher resolve the build, install dependencies, and build in the background.\ni don't think anyone can really argue against that work flow since this is what most builders are trying to accomplish (albeit unsuccessfully because they focus on only a part of the workflow or try not to be opinionated).\n. > I don't type make, I always use middleware.\noh yeah i was going to make express/koa middleware next. rather than rebuilding on every request though, it would only rebuild when necessary (via the watcher) without intermediary files. not cool with adding 300ms latency to every request in dev, which is what would have to happen now.\n\nthe thing is watcher libs are just that, watcher libs, when they should really be more make-like, just idempotent builds that happen to run at an interval\n\nyeah, i consider this an \"interactive process\" rather than just a watcher. the watcher is only part of it.\n\ncomponent build etc definitely need to exist for deployments\n\nyou can still component build\n\nI do think it would be more elegant if component was effectively watch -i 1s component build if watching was implemented in the make-style way\n\nhaha this is pretty much what it is. difference is it includes component install. i also don't see the need for an interval when you're using a watcher though since it should know which files to watch and when a file is updated (i'm not waiting until the next second for a new build). otherwise, it should be called every 1s \"component install; component build;\" or something. that would actually be easy to implement. \n. yep. the idea right now is that the watcher is a separate library you can fork whereas component(1) would include a sane default. you can add your own rework plugins here: https://github.com/component/watcher.js/blob/master/lib/builders/styles.js#L14. so you'll only have this watcher vs. a whole, complex watch/install/build system.\n. > having to fork something to make my own builder \nno you can still do that just for the builders, but the point of watcher.js is the entire build/watch/middleware/update/outdated/pin/ls system, which is most of component and already mostly in separate libraries. i'm not against being able to do options (like pass a builder function instead of forking) but i foresee a lot of different possible options i don't want to deal with right now. it currently works for my app so that's it for me. i don't want it to turn into grunt.\n\ni'd much rather go with a dumb --watch flag\n\nfor now, yeah. gaze is pretty good. it's not like this stuff would be ready any time soon. now that i have my app working, i probably won't work on this stuff as much anymore anyways. \n. > it's definitely wasteful to do so each build\nyup, which is why i split the builder into three :)\n\nyou could knock them out of the build tree to ignore them when mtime is constant\n\nsounds like something you can do between the resolve and build step or as a plugin (probably better). \n. moving dev to https://github.com/jonathanong/component-process.js. will make a PR once it's ready\n. the require statements don't really work outside the build. the only real way to solve that is to either create even more aliases or have a super smart require, both of which would fatten the builds.\n. my intention is to replace everything with remotes/resolver/builder2 and maybe with bundler + watcher once it's done (which may be a while). if you guys don't want it then it's cool i can move it to a personal repo, but it's faster, more flexible, and has much fewer issues than the current builder/component(1). \ni have multiple issues with the current builder such as plugins being unnecessarily verbose, unnecessarily verbose aliases, and each plugin requiring its own concurrency control. the way it works right now would require plugins to unglob fields themselves as well, which is just annoying. \nthere are also plenty of component issues that could be immediately closed once we use my libs, and if we don't, i doubt these issues would ever be fixed. \n. yeah should've called it -dev or something. \n. closing for now. move any further comments to https://github.com/component/component/issues/448\n. if i'm reading this correctly, you create a personal access token and send that as your basic auth password, correct? shouldn't be difficult.\n. do you have a test case for this with only lowercase letters? this is just bazaar\n. going to close this for now. \n. 1. Node doesn't even completely follow the cjs spec\n2. Component (and bower) isn't just Javascript, it's also CSS, images, fonts, etc\n3. Making packages work in every package manager is not trivial. Some are completely incompatible.\nThe only other spec we're going to follow is ES modules or web components.\n. because it's ugly and inelegant. don't feel like nesting 2 objects deep to define everything. it also doesn't make sense for internal package management. \n. yup. because properties like scripts and main are in fact not the same and mean different things in different contexts. and like i said above, if we were to push everything into package.json then we would lose a lot of component's benefits and features (specifically local components) as well as making implementation harder.\n. i know this is out of component's focus, but how about including it as component bump?\n. meh. mixing different types of scripts in a component is just confusing. each component should only use one type of method. \nthinking of a type: property right now that defaults to cjs since we have to support type: 'module' for es6 modules and type: 'component' for web component eventually anyways. we can do a type: 'standalone' or something for now.\n. migrating to https://github.com/component/spec/issues/51\n. i'm not sure how to do this without actually parsing the javascript with esprima or jshint or something, which would make builds VERY SLOW.\nwould be better as a plugin for now, then we can think about adding it once it's working well\n. oh yeah. i run lint in a separate process on every build. it's super slow though - 50ms builds and 2.5s lint? which is why i don't run lint in the same process as the builder and don't really want to advocate putting it in the builder (unless someone makes it really fast with caching n stuff, though i lint my server-side js at the same time for the hell of it)\n. yeah multiple builds are the way to go.\nimo there shouldn't be any async loading. ever. just use multiple script tags. and module resolution should always occur at compile time (i.e. the builder).\n. going to see if i can use another library to replace this https://github.com/component/package.js/blob/master/index.js#L275 not sure if superagent is fixed yet\n. yeah raw is the way to go. you'll end up with different issues using that API like rate limit and 1mb size limit. we just need redirects.\nk i have https://github.com/component/component/tree/resolver going with my resolver/builder2 if you want redirects, semver, ex. i published it as component-dev if you want to try it.\nlet me see if i can fix package.js\n. k i hae https://github.com/component/package.js/tree/cogent and when i link it with component, all the tests pass. can someone confirm or okay before i push it? \nstuff like auth and netrc MAY break, mostly because i didn't test them well yet (they should still work though), but it's better than the whole thing being broken.\n. tried that. not all repos serve off the new hostname yet, so you'll still get 404s. need redirects\n. k just checked everything out, the new uRL seems to work. waiting for @ianstormtaylor or @visionmedia to push https://github.com/component/package.js/commit/8370ef1d4dee0cc9b8fdda6fd54af827f1bb15c3 or share https://github.com/jonathanong/npm-org-rights\n. k i changed the URL. lets hope it works for all the repos now\n. i want to make this default in the future. the only other transport should be UMD.\n. do you guys prefer --umd <name> or --standalone <name>? i prefer umd\n. done in master. changed to umd. \n. yeah, locals only works with \"local\" components, not remote components. i do want this though so you could split up your app into separate repos or something. it's a little more difficult to resolve though as it would require more HTTP requests (unless we download the entire repo) and we have to make sure all the locals are encapsulated.\n. yeah i don't think it would be too difficult in my resolver. probably more difficult in the current component. i'll look into it this weekend since i want it too :D\n. aside: how do you guys think we should handle IDs? \nwe can ID remote components as <user>-<repo>@<version>. the problem is that we don't want conflicts with local component names, so i was thinking path.relative(process.cwd(), <component-folder>), but then i'm not sure how to handle dependencies' locals.\nwe could also just give them all unique hashes like browserify, but then it's harder to read and debug.\n. the problem is that when we copy/symlink stuff, how do we handle paths that start with ../? imo they should be separate repos, and you should be able to symlink them as a dependency in development. so you could have model above process.cwd(), but it will be treated as /dominicbarnes/model/1.2.3/ in the build. \nstuff outside process.cwd() doesn't make sense to me, much like how stuff outside main's folder doesn't make sense to me either.\n. hmmm if we do this, the apps need a JS entry point. should we allow users to specify the main as one of the locals? or have it implied as one of the locals if there's only one defined?\n. i'm going to throw if there's more than one local. if there are no scripts, then the component will actually be the local. we can figure out the specs later\n. hmmmm i tested it locally recently and no tests fail. might just be casing, which is platform dependent.\n. k added a travis. let's see how it goes.\n. +1 just because i don't like shorthands in my .json files. but it should be strictly strings unlike npm that allows objects n stuff\nbtw there's https://github.com/component/spec for these kind of questions\n. changed in spec, and master supports it :D\n. lol so much bike shedding. what's \"ideal\" doesn't matter. ./components works and there's no compelling reason it needs to be a different folder. \n. yeah docs need to be better. hopefully that'll be fixed in the next few weeks.\nthe problem is that this discussion is neither a problem nor a solution, so it's a waste of everyone's time. you can't expect maintainers to empathize with every user's non-issues - there are better things to do. if there was a problem actually being solved or a solution you're presenting, that would be a different case. \nthere was another issue about this, but their issue is bundling. that will be solved in v1.\n. update to the latest version of that component? i think that'll work. that would update that dependency in every local component as well. to be specific, updating for me is changing the version in the component.json. to actually install it, just run component install again.\ni think reinstalling a single component might make sense, but what you're essnetially doing is rm components/some/component/v1.0.0; component install. might be better to do component remove user/repo; component install or something\n. --force removed in master. just do rm -rf components; component install; now.\nif you guys want a component remove command, let me know, but for now i'm not going to include it.\n. +1 can you open an issue in http://github.com/component/guide please?\n. component(1) stuff works with the crawler, just need to update the site now...\n. ok i'm going to assign all the component-create stuff to you. not sure what the easiest way to include an external binary with component(1). hmmm...\n. probably need tests for proxy support, but component didn't have them before so i'm not going to bother adding them now. if you use a proxy --- speak up!\n. yeah we have to try both URLs. ugh. https://github.com/component/remotes.js/issues/11\n. is this with 0.19.8 or 1.0.0-rc1?\n. merging with #503\n. hi this will be fixed soon in a coming component(1) release. reopen when it's released!\n. that's the old stuff. new stuff doesn't have the arrows.\nwe can remove the ms if you want, though i like it. \nyeah, colors are terrible. i just tried to add contrast. \n. btw if you guys want to go through the repos and add colors, please do! i started not adding any colors due to @yields' disdain with my choice of colors\n. i think you need to update your deps. you have an old version of resolver as well.\n. oh yeah, the new builder has function (module, exports) so you're using the old builder\n. Update npm too. I'm using semver v2 for deps\n. hmmm... lol. i just npm i -g component@\"1.0.0-rc1\" and it works perfectly fine for me. there could be some weird npm caching or bin stuff going on.\n. oh... you know what. mocha uses its own require()s, and the builder is rewriting them. hmmm...\n. other than that, i don't really see an issue with it.\n. hmmm i wonder why i wasn't already doing that. \n. okay it should be fixed. gotta bump component-builder. cool how you could close issues across repos now!\n. Closing because none of this shit should be necessary with es6 modules\n. can you try removing the names from all the local components? i made it so it can work from just the folder names.\ncan you send me a zip of a test case or make a PR with a test case?\n. created this https://github.com/component/builder2.js/commit/93be90a19c007a7c23854b9d12c6f6552dfc9ecb works fine. update it until it fails!\n. i'll add this to the readme :D\n. / anywhere means it's a file. what you want is just require('subcomponent-1'). the builder will then look up subcomponent-1 in all the paths you've listed.\n. errr. to be more specific. you always use the folder name. require('subcomponent-1') will look for a subcomponent-1/component.json in all the paths.\n. yup. it'll be easier to read and understand app structure that way. making component names and their containing folders different will just make it confusing.\ni'll do a MVC structure example soon. ideally, you should not require() from stuff in a \"cousin\" path (i.e. not an ancestor path of the current path). instead, you should expose each path with an index component. i.e.:\njs\nstuff/\n  - a\n  - b\nmorestuff/\n  - a\n  - b\nthen from stuff/a, you would do require('morestuff').a. require('morestuff/a') should also work, but i haven't tested that yet.\n. hmmmm i've been getting this error as well on certain scripts. just waiting usually solves it. could also be https://github.com/component/remotes.js/issues/11, but yeah, it works when i open it up in the browser...\n. that just means github isn't sending a response. i don't think the node version matters for that because that would be a pretty big compatibility change.\nis it just component/notification or is this happening with other components? going to check this in a bit.\n. yeah it's working for me. this could be a CDN thing, since you're not in california. hmmm\n. Oops I forgot a try catch. God damnit!\n. okay updated it. try again now. i seriously wonder what the deal with this is because it works on my computer as well as travis: https://travis-ci.org/component/resolver.js/jobs/22146501#L507\n. hmmm that's super weird. i test with both 0.10 and 0.11 and they both work. there could be...\n. actually, 0.11 and 0.10 are both using the regenerated code. the only difference would be the HTTP lib... the actual http.request() code is just callbacks: https://github.com/cojs/cogent/blob/master/lib/index.js#L157\n. hmmmm wonder if it's platform issues.\nyou should generally not use those shim libraries in component/ though. https://github.com/jashkenas/underscore has a component.json now. you can also take a look at https://github.com/components\n. @dominicbarnes are you still getting this?\n. can @dominicbarnes or @simonsmith setup a VM or something I can ssh into and debug? \n. yup. that's what happened to me. i have a feeling it's local-specific CDN issues since they're migrating from raw.github.com to raw.githubusercontent.com\n. going to close htis for now since @dominicbarnes test box works fine. lol\nhopefully we can figure out what's up with your work box :P\n. added a little note here: https://github.com/component/guide/commit/37812056f9db247e277f62250a2704d1c5a23098\nnot sure if it's the best place to put it\n. @simonsmith so are you saying proxies don't work? i'll be sure to add some tests\n@dominicbarnes they both use the regenerated build so i'm not sure waht the difference is =/ perhaps underlying node changes, which we can't do anything about. don't know what those differences are\n. You need to run with --harmony-generators though, Andreas flag isn't ebabled when you run the ClI commands. I would have to spawn a sub process, but I don't think it's worth the complexity.\n. haha damn. that's ridiculous! how come it works fine from the browser?\n. It changed to umd. I want to add standalone as a hidden option for backwards compatible, but not sure how to do that yet.\n. yeah i dunno. i personally want to know it's a UMD build. \"standalone\" might sound like just a global export. ideally, it would be standalone UMD build, but that's too long for an option. thus i want to support both options.\n. forget it. i'm going to add both. we can worry about making the help less verbose later\n. the problem with UMD is that it doesn't even support ES6 export yet. not even sure how to do that without raising syntax errors. woooooo\n. hmmm i don't think this is the ideal way to install it though. better to use a node version manager like nvm or n. what do you guys think?\n. only 0.10 is required through. it doesn't actually use --harmony because everythign is regenerated\n. yeah, going to just tell people to install the official version of node. \n. w00t! more docs. from the looks of it, your app doesn't have an entry point. entry points are usually either a index.js file in the main component like component-library, or a single local. however, the builder should be throwing here complaining that there isn't an entry point if you have any js.\nof course, your app could have more than one entry point, but at that point you should be using the JS API, not component(1), because you start to get into opinionated territory.\ndoes this app have js, or is it just css? a repo would help! of course, if your app doesn't have any js or css, no js or css file will be built. perhaps adding a message saying that will help.\ni actually removed the verbose options because i'm not sure what to log in verbose mode. you can DEBUG=* component build to see what's going on, but that might be too much info for you.\n. yeah, it still parses inside comments. hard to figure out if a string is within a comment block. however, it shouldn't stall the process or anything.\nit would be easier if i saw your entire repo or a runnable example. right now i'm just guessing issues.\n. yeah going ot add DEBUG docs. problem is that now that component is split into several small libs, a --verbose option means i would have to add verbose options to every single internal lib with consistent formatting. debug is easier!\n. Ohhh make sure you're using v1. 0.x uses .local, so it won't even know about the locals\n. yeah thanks. i'll be sure to add these points to the guide! great to hear the obstacles of component for new users\n. yeah, i only use 1 path. we've discussed this somewhere else, but more than one path is probably an anti-pattern, though i do see use-cases for it. \n\nlocal components which use require() to call components that are siblings of that component also need to have a \"locals\" array with those required components listed\n\nthought about adding magic for this, but the problem is CSS, not JS. component sacrifices JS ease for CSS ease.\n. Cool thabks! I'll edit it more when I get hom\n. whatever we decide, we should move it to https://github.com/component/guide. but SGTM\n. btw, v1.0.0 includes autoprefixer :) adds more benefit than cost!\ni'm going to close this. reopen as PRs in https://github.com/component/guide! i just did a doc overall, so it should be easier to contribute now.\n. are you looking for component build --standalone?\n. i changed it to umd in rc1, then added standalone back in rc2. maybe you want to update it to rc2.\nyeah i was thinking about that. a custom property called .standalone, defaulting to .name?\n. yep sure!\n. oh i don't think you need this property when building your own component. --standalone options is fine. for me, it's more for if we had a CDN or something that automated UMD builds. \n. we could also use a .rc file or something, but then we end up with more files... might be useful to specify the installation directory and stuff in the .rc file instead though. supporting --out in every command would be pretty annoying.\n. i'm going to add standalone to the docs, but only for automated standalone builds. for local builds, let's discuss this in https://github.com/component/component/issues/517\n. totally open to those. i just haven't investigated all the possible solutions yet.\n. oops\n. feel free to make a PR! milestoned for 1.1.0 just means i'm not going to work on it until after 1.0.0 is done, but i'm not against merging a PR.\n. problem is that it doesn't exist! https://raw.githubusercontent.com/es-shims/es5-shim/v2.3.0/component.json\n. you'll have to install from @master for now until they release a new version with the component.json included\n. here's the tagged v2.3.0 branch: https://github.com/es-shims/es5-shim/tree/v2.3.0\n. reopen if there's still an issue with vs though. i'm pretty sure i handle those and have tests for them.\n. unfortunately that's not possible without a lot of extra HTTP requests. what component does right now is check https://raw.githubusercontent.com/es-shims/es5-shim/v2.3.0/component.json then https://raw.githubusercontent.com/es-shims/es5-shim/2.3.0/component.json (without the v). if it's a 404, then it's a 404. we'd have to use the github API then to check.\n. yeah, you're probably using a 1.0.0 rc now. before, component just straight up used master with *. now, it actually uses versions based on git tags. it doesn't check whether the tags have valid component.jsons though. too much work. \n. isn't that what \"no remote found\" means? it sounds like you want a very specific error message for when the tag exists but the component.json does not exist in that tag. to do so would basically cost an extra github API request. not sure if it's worth it, especially once we start supporting multiple remotes.\n. https://github.com/component/spec/blob/master/component.json/specifications.md#dependencies\n. it's a little difficult to describe in verbosity because the github api is abstracted into a remote, and what the resolver does is try to find a remote+repo+version with a component.json from a list of remotes (currently just github). from the resolver's standpoint, it just couldn't resolve a remote.\nhowever, what you really want is DEBUG=remotes*. here's the output:\n\nnot perfectly described (i.e. doesn't say 404s) but shows you what it tried\n. added to troubleshooting\n. here's the code i'm talking about: https://github.com/component/resolver.js/blob/master/lib/dependencies.js#L69\n. that would be a really verbose error message =O 4 URLs were checked just with this example. debugging is the way to go IMO. maybe just adding try DEBUG=remotes* to the error message is better and improving debug statements everywhere.\n. i just think listing URLs is verbose in that it's not clearly useful to the end user. listing common causes would be better, but i generally prefer linking to an actual page that references the errors vs. printing out everything in the console. \ni think it's better to say, try DEBUG=remotes* to better understand what's going on or run \"component open troubleshooting\" for solutions to some common problems\" and have explanations and stuff about what's going on.\n. another problem is https://github.com/component/remotes.js/issues/11, which is why i don't want to list a specific error message. if we can pinpoint a cause of an error, then i'm down with a better error message, but right now there are too many ways dependencies can fail =/\n. hmmm i wonder waht's going on. can you do DEBUG=cogent when running it and print hte logs? make sure to remove your username/password\n. oooo maybe! \n. @simonsmith hmmm i think this is the same issue with https://github.com/component/component/issues/503. if i had to guess, there's some DNS issues with certain platforms w/ node. a response is never returned and i'm not sure how to go lower level than that. \ni think i had the same issue before, but only on certain components, and it eventually fixed itself.\ncan you try 0.11?\n. @cristiandouce yeah i think that's the way to go. i'll open a new issue for it\n. basically, you only shrinkwrap everything that you yourself didn't pin. there's no need to shrinkwrap dependencies you've already pinned.\ncomponent outdated doesn't handle dependencies of dependencies. i don't think it should either. the way npm outdated works right now is super annoying because i can't update most of those nested dependencies, so it's just all noise.\nwe could have component shrinkwrap install also run component install. that's not a big deal. \n. the shrinkwrap won't support multiple dependencies, but the JSON will. unless you do a nested shrinkwrap like npm, but then i'm -1.\ni see shrinkwrap as a helper for the component.jsons' dependencies. shouldn't need to replace them. what if you update a dependency but not the shrinkwrap? \nbut yeah, code first :D\n. yeah that's basically how .rc files will work if we go that route. i think a componentrc should supercede any netrc files as well.\ni'm also thinking of adding more properties like BUILD = ../path/to/my/custom/builder, etc. might be helpful instead of reimplementing all the component JS logic\n. i was thinking of a .componentenv file (or .env or whatever. not sure if there's already a standard) that look like environmental variables. then internally, we can treat all the settings as environmental variables. so instead of .env files, you can actually use environmental variables instead.\n. the idea behind .env files is that these environmental variables would only be set when you run a component command inside the project, so moving in and out of different projects wouldn't matter.\n. i updated console.js to show stacktraces for user errors. please reopen if it's still an issue\n. My only problem with closure compiler is that it's a pain in the ass to install\nI'm thinking of only showing the minimized sized of files. \n. but not on a per-component basis, both remote and local. plus, it's easy for you, but not most web developers (i didn't even know if this du -h command!). then people are going to complain about windows support, blah blah blah\n. yeah it could, but i'm thinking about how to improve its usefulness before refactoring it. \n. actually, internally, .out is where components is. .destination is build. kind of confusing ~_~ need better names\n. once you start tagging stuff it should be fine\n. @lhorie just added https://github.com/component/guide/blob/master/creating-components/publishing.md for you. let me know if you have more questions\n. actually, yeah, non master branches won't work. i'll open an issue, but i don't think we can support other default branches without 1) an additional HTTP request and 2) using a github API request\n. Component names must match the folder name\n. not sure. gotta see code\n. i'm not sure how to do this. the field each plugin acts on is important, and the way it is ordered with the default plugins matter as well.\ni think if you wanted to do this right now, you would have to re-use all the default middleware manually and specify the fields:\nbash\ncomponent build\n  --use-scripts es6modules\n  --use-scripts js\n  --use-json json\n  --use-templates templates\netc.\nplus, there are also custom options and such you would have to handle. there's just too many different dimensions, and it would end up being larger than just writing a JS file.\ni'm trying to think of a way where you can just just create a js file that looks like:\njs\nexports.scripts = function (build) {\n  build\n    .use()\n    .use()\n    .use()\n}\nwithout returning anything, and set its path as an env variable or something. \n. the use-case isn't the problem. it's actually implementing it. you're trying to map a 1-2 dimensional option space to like a 5 dimensional option space, which is pretty difficult.\n. you need require() with standalone. heh. unless there's a way to avoid that.\nunless you're implementing require() outside the closure?\n. oh the require() is required if you have more than one module in it since each module has to resolve against each other. if you have only one, then you can get rid of it. here: https://github.com/component/build.js/issues/4\n. Shoot can you give me a test case?\n. oh LOL\n. okay. i think we should add type checking to the validator. it would help when figuring stuff out vs. bower.json and package.json, etc.\n. My main issue is that it removes race condition checking, which is what most of the complexity in the resolver is. I still has some issues with it, which is why it currently only resiolves 1 semver at a time.\nUnglobbing is important for the future because listing more than a few files in a component.json is unwieldy. The builder would be much simpler without it. I also don't want plugins to have to implement control flow.\nI do want better logging and stuff though, but that's something that can be changed without breaking backwards compatibility.\n. just stuff like https://github.com/chaijs/chai/blob/master/component.json. big components are inevitable though less than ideal, but creating manifest files like that would be a pain in the ass.\ni know someone on irc complained about how manually listing all the files in every component was annoying. honestly, i think component.jsons everywhere are really annoying, but i think it's the best we can do. \n. @ianstormtaylor i don't even know how to explain it. semver deps have pinned deps who have semver deps, all of which use different semver. two different locals have the same dependency but different semver. you don't want to use an API request on every single semver. a lot of weird edge cases. the main issue is when you try to resolve them at the same time. you want to return the same resolved dependency, not multiple copies of it.\nright now, semver can handle like 3 resolutiosn concurrently, but i hit a case where it fails and i haven't yet figured out why. just put it down to 1 until i put time into checking.\n. we have to support multiple versions now because a lot of components currently pin their deps due to component@0's lack of versioning support =/\n. i thinkw e discussed this in component/spec. the consensus was to not treat CSS any differently than JS. that's why i've added the component duplicates command to help avoid this problem.\nbut i'd rather have a bad build or less-than-ideal build than no build or an incorrect build. \n. ~~the downloader already supports tarballs and zipballs. it uses them when there's more than 10 files in a component so it doesn't do 10 HTTP requests. also need it for https://github.com/component/component/issues/483. WOOO MORE COMPLEXITY!!!~~\noh nvm you mean tarballs as dependencies. i don't know why people do that.\n. yeah. when testing chaijs/chai, that shit took like 5s alone to install because of all the HTTP requests.\n. i currently install 5 components concurrently, and each installs 1 file at a time. it's just stupid concurrency stuff because i was targeting 5 global, concurrent HTTP requests at any given time (which is what will happen under the hood by default anyways because of node's stupid HTTP pooling. ).\nyou could always bump up the concurrency, but i think i need to just think of a better control flow mechanism. would cleanup a lot of code. going to open an issue for that.\n. yeah it's just a concurrency control option. i can bump it up to higher, i just don't want to deal with HTTP pooling issues, specifically when you're installing an entire app, not just a single component.\n. hopefully we can get rid of all of this stupid concurrent HTTP crap once a CDN supports SPDY or node gets their hsit together\n. yeah. there are multiple ways around it, but they all have tradeoffs. my approach is just to keep it close to 5 concurrent HTTP requests. i also don't know how proxies and such would handle it. not something i want to fiddle with since we could just wait until SPDY and ignore it.\n. we can warn on mismatches automatically. right now i tried to avoid warnings everywhere because they get really annoying and the user can't always do something about it. don't want this turning into npm. maybe warn only on semver conflicts by default.\nbut erroring out is not doable IMO since dependencies will sometimes pin their stuff and then you'd have to fork it just to even get a build, which is a pain in the ass. \n\nThere have been a lot of sweeping changes to Component for 1.0. That has had me a bit worried tbh.\n\nwhat do you mean? aside from some people not being able to hit the remotes, Component v1 is pretty set so far\n. specs moved here: https://github.com/component/spec/blob/master/component.json/specifications.md\nadded a nice big message to the wiki :)\n. this should be possible with a plugin, but it'll be a little confusing and more complex. what type of URLs are you using? images? \n. hmmm ok. for now i would just use background-image. it's kind of confusing because we would have to figure out which tags to parse, which properties to parse, change properties while preserving styles, etc. but this is inevitable when web components comes out\n. you're probably looking to do require('./template.html') instead, i.e. starting with ./ to tell require() that this file is a relative file. this issue came up before, i think we should add it to the guide.\n. if you're looking to use it outside my-component and the template is the main, just do require('my-component').\n. doing require('my-component/template.html') should work. just be sure you always add extensions when doing so\n. no. i think --verbose is pretty useless since there's not much more info you really need. only time you want more info is when somehting goes wrong, thus \"debug\" vs \"verbose\"\n. hmmm internally it doesn't matter, but i don't want to log anything during testing. \nnothing's wrong with DEBUG=, i just prefer something more user friendly for newer people\n. should open the issue here: https://github.com/component/create.js\nit just hasn't been updated yet\n. Yeah it doesn't support custom remotes right now. Need to figure it out before v1\n. It should work. Does it not?\n. oops bad link. i'll update the link\n. can you run with DEBUG=remotes and DEBUG=component*?\nquick look, your .repository field in your component.jsons should be strings, not an object\n. because there's no component.json: https://github.com/apla/node-util/tree/v0.10.3\n. actually i need to handle the bitbucket error better. \n. closing because if ixed that stupid bitbucket error https://github.com/component/remotes.js/commit/ab232b578c51750706184ac5f2f7af1f8d141d38\n. does it work if you do require('geometry/point.js')?\nit's kind of both. all the requires are explicit now, and it doesn't look up files across components. ideally, either we require extensions on all requires or support this.\n. closing and moving further discussion to https://github.com/component/builder2.js/issues/30\n. what do the errors look like? can you show some debug logs? https://github.com/component/guide/blob/master/component/troubleshooting.md\ni have an issue in the resolver where sometimes things will be out of order, but it only happens 1/100 times. not sure what's going on.\n. not sure. i didn't see anything blatantly wrong with your code. \n. confused. what's not giving you the correct information?\n. closing because yeah, component names must match the containing folder's.\nbetter error message would be nice. didn't see what message you were confused about though, so i don't know what to improve.\n. the require should also not do anything but print to the DEBUG log if it can't resolve a require() from a remote dependency's file. we ran into this with mocha as well and it's fixed now. \ncan you link me to the source code?\n. going to close until we see code =O\n. should be ignored now: https://github.com/visionmedia/node-requires/commit/82b18102de4fdb1deab990eaadbabf6d8a3af9ba\nmight need to update your deps\n. Oh you're on windows, huh?\n. Hahaha which version specifically? Someone else was using it with windows and said everything worked. Wonder what's different.\nBut yeah, we have to normalize all the paths, but now I wonder how we'd actually handle Unicode characters...\n. if we add the \"source\" i.e. github.com to each component, we could probably just store it globally somewhere instead. no more components/ folder, and installs would only happen in the background.\n. yeah just wanna do it with a .componentrc file or something. setting --out in every command would be super annoying.\n. belongs in this repo: https://github.com/component/component.io\n. yeah or pin your stuff. \nthinking of just creating a proxy to do all this stuff. this auth and remote stuff is super annoying\n. https://github.com/normalize/proxy.js\ni have the backend dependency tree thing going already, but not the server yet. \n. noooooo! no publishing step!\n. it's the same thing. https://developer.github.com/v3/auth/#via-oauth-tokens\n. yup. i'll add it to the guide.\n. it says you could leave a blank password, but i might have been too strict with that. \n. yeah. my checks are too strict because i require you to have a password. but GITHUB_PASSWORD=x-oauth-basic is fine, probably preferable since it's more specific\n. doesn't look like that https://developer.github.com/v3/auth/#via-oauth-tokens\nthough github probably just made it really flexible because why not\n. it's because that version doesn't have a component.json: https://github.com/ripplejs/ripple/tree/0.23.0\n:( needs better error message\n. yeah i was looking at that. how did it go from 8k commits to 80?\n. lol i think it's grabbing tags from here: https://github.com/ripple/rippled i wonder how that happened\n. you can't check for the content-type header because github doesn't send one. we'd have to handle every single remote separately --\n. haha i always see you commenting and being helpful in every repo on github, so why not? :D\n. yeah, i should fix that. \n. wow. one line fix. https://github.com/component/remotes.js/commit/ab232b578c51750706184ac5f2f7af1f8d141d38\n. dunno. sounds like more options ~~ \nthese option lists are getting too long.\ni'm not even a big fan of reload. makes sense for css, but sometimes reloading js just messes things up. but i think it's important for a lot of devs workflow.\n. anyone wanna try this out?\n. it's for components though. apps shouldn't be using it, but components don't have middleware to build on demand. \n. https://github.com/component/builder2.js/pull/49\n. k pushed to component-builder@1.1.3\n. Haha I was worrying about other stuff first. I'll take PRs because the whole logging system needs a do-over and I would never be happy with the result. \n. at this point, those components aren't locals but dependencies. i would just store them each in their own (private) repo and link them in development.\nlocals are for local components within the same app.\n. yeah. now that we have bitbucket support, you can store these in private bitbucket repos for free!\n. i'll add that .remotes is pretty much broken right now somewhere\n. @anthonyshort it'll be more difficult to use without aliases\n@kazupon why would you use this?\n. how do you deal with locals though since the builder rewrites them? i guess it isn't too hard to figure out since it mimics your project structure.\nhmmm... i feel like that's the wrong way to initialize an app. easier to have a config local or even a global window.config unless you're initializing boot multiple times, but then i would window.boot = boot within  the boot module itself.\ni'm primarily against adding more options because that list is too long. anyone else wanna chime in?\n. Can you elaborate?\n. If you guys really want it, go head haha\n. we ran into issues with camelcased stuff so we decided to keep them all lower case. makes stuff more platform compatible anyways if everythign is lowercased. it's just easier to implement, though i wouldn't mind adding camelcase back with a lot of tests on all platforms.\ncan you provide a test case for require('../something.js')? that stuff should work\n. oh god :( that's no bueno because that would require a LOT of API calls.\n. yeah that's why i'm working on https://github.com/normalize/package-management. at this point, you might as well just put the full URL everywhere \n. user-repo, repo, and name should all work. i just fixed a bug with just using .name though, so you'll have to update all your deps.\n. yeah. ex. visionmedia/page.js. you should be able to do require('visionmedia-page.js'), require('page.js'), or require('page') (its name according to component.json). otherwise, it's a bug.\n. it's a builder bug, so i just published it to builder. just update builder and you should be good. not pinning deps here yet.\n. naw if you want postinstall scripts use npm or something. we're trying to get away from compilation steps with component!\n. Best practice is \"don't\". Lol\n. what i would do is build them only for tags, but not for dev commits. it's a little annoying to do that though. not sure if you could use releases for this because component doesn't specifically support them.\n. it's just opinionated and everybody has a different idea about it. people wanted to work on it separately, so we moved it to a different repo.\nif people update it and it becomes good enough for core, i don't mind adding it back.\n. anyone want to actively maintain it?\n. you probably need to upgrade component\n. you know what... i think what the problem is is that 0.19.9 was release last, and latest defaults to the latest by date, not by version. ugh stupid npm\n. there's no component.json: https://github.com/techjacker/q/tree/v0.9.6\n. 0.19 simply grabbed it from master. 1 actually checks the tags. if you want master, do techjacker/q@master\n. you would have to fork it or something =/ i tend to avoid forks for this reason. imo just point to master for now\n. the first one is a bug @dominicbarnes pointed out before. i don't have the link to the issue, but the only way i know how to fix that is with more API requests.\nthe second one is just github being silly.\nnot too sure what's going with the failed semver resolution. if you can make a tiny repo that demonstrates this case that owuld be helpful.\n. imo it should be a .componentrc file or something, not options. there are already too many options everywhere, and something like increased timeout is something you want with all the commands.\n. better to fail fast vs. wait 30 seconds. if you're hitting the timeout, something is wrong, and unfortunately it's probably github and we can't do much about it. increasing the timeout is more of a \"i know something is wrong and i'll tolerate it\"\n. sure! make some PRs and ill add you guys as collabs\n. it breaks? does it give a reason? it should work since it removes any leading ./\n. this about updating the component.json file? if so, it's probably just oversight and a bug.\nit shouldn't install the development dependencies of dependencies. if so, that's a bug. i'm pretty sure i have a test for that.\n. this is a known issue with v0. it should be fixed in v1\n. for this particular case, you can just do\njs\nvar emitter = require('component-emitter')\nvar domify = require('domify')\nbut generally, you should try/catch one at a time\n. at this point, this \"component\" abstraction becomes too complex. it's really not worth the complexity. \n. nope it's both. with component you can just think of \"packages\" without the \"management\" and just build your app. \n. we can discuss this in #components. this discussion doesn't really belong here\n. yeah go ahead and do any of this logging stuff. i haven't bothered with all the logging and such\n. looks good! added to the team\n. i think so. might want to grep require('open') to be sure :P\n. it doens't check whether the repository 404d or the component.json 404d. a better error message would again require another HTTP request, which i don't think it's worth it\n. pre-mz co hackage :D\n. they are all absolute URLs so component won't touch those.\n. Summary?\n. oh sometimes i get the same. does this happen on node 0.11 or 0.10?\n. i don't really see the point since the cases where this would actually be useful is very few\n. it's also needlessly ambiguous\n. I wouldn't worry about using the components themselves. Except for the browser compatibility ones, they are here to stay.\nWhat will change is the package management, which will only become easier with es6 and spdy. What you'll basically have to do to upgrade is remove all your component.jsons\n. we don't have autocompletion =/ so we have no solution to share with you heh\n. lol why is this here? @MatthewMueller can you make the duo repos public? i don't think it'll spam your followers or anything\n. check the actual repo before you download stuff: https://github.com/component/underscore\nuse https://github.com/components/underscore instead\n. yeah normalize won't be backwards compatible. it also only supports what the browser supports, so there are no JSON files, you can't try/catch require()s, no dev dependencies, etc. \n. i don't know man, explicit dependencies are only going to make your big code base bigger :P\n. if you'd like to contribute let me know, i can add you as contributor. \n. segmentio only sponsored component for a little while. i guess you could consider duo as being sponsored by segment since @yields has been working a lot on it. \nreally, CSS should just be @imports. it doesn't have to be more complicated than that, and inlining CSS (or anything really) in JS is silly\n. the cli works is pretty well for nlz already if you want to test it. there's been some people playing with it and helping me. i'm working on the spdy push static server right now, which is where all the magic is. that might take some time to be production ready. i don't expect any of this to be \"production ready\" until es6 is finalized because shits probably going to change until then, though you could still use require()s. \ni think adding private remotes to nlz should be pretty easy, especially github-style git remotes like bitbucket. haven't tested that yet though. but github + npm already works.\nright now you have to setup your own proxy though because i haven't setup nlz.io. i'll probably do that soon so that trying nlz(1) would be a little easier.\n. i agree that dependencies should never use / because it requires knowledge of the server and environment it's running on.\n\nA component should know nothing about the external world and paths.\n\ni disagree with this, though maybe i don't understand what you mean. if you have any dependencies, that's an external world or path. having it in a manifest or inline makes no difference.\njs\nimport jquery from 'https://rawgit.com/components/jquery/2.1.1/jquery.js'\nthis will work in browsers natively, and if the package manager doesn't support it natively then it's not going to last very long.\n\nAnd this has a big side effect for the build process, especially when you're using transcompiler and use them separate from components build process. The result is that you cannot build particular components anymore, so incremental builds not working anymore, you need to build everything, the whole app. This feature is only possible with a manifest per component which contains the dependencies.\n\ni'm not sure i understand what you mean here either. seems like you've created an overly-complex build process for your app. external components shouldn't require a build process otherwise they aren't very good components. \n. does anyone using bitbucket use mercurial? i wonder if that's something package managers should ever bother supporting\n. yeah i'm asking a different question. haha. bitbucket supports both git and mercurial repositories, but i don't know if people even use mercurial. if you only support git, then you can git ls remote bitbucket like it's github, just change the hostname\n. > then if you need to break compat you just append -v2 or move it to its own repo\nlol\n. yeah, remotes before locals per bundle. \n. Order they are required. Remotes are all resolved before locals. There's a \"flatten\" function somewhere that has all the logic\n. Should be fine \n. because it sucks :) using https://github.com/polyfills/es6-module-crosspiler#type would be more robust, though i haven't updated it to the latest es6 module specs. you can also use https://github.com/webdeps/deps-parse\n. i don't remember. probably\n. i'm not sure how it works via JS API, but in the CLI it should be component-build*, etc. since i namespace a lot of things\n. ",
    "enyo": "I as well would be very happy about that enhancement. (Especially since the docs imply that it's already possible)\n. @ForbesLindesay that may be misleading or prone to error (although I'm for it) but doesn't really solve the problem of this ticket, does it?\n. Yeah.. I don't know why I wanted to split hairs there.. I just meant that the problem is obviously that not even main gets used properly. So IMO first fix main, then think about using the first scripts file as main.\n. I agree. The recommended convention is to use index.js so you should rarely have to specify a main anyway.\n. That would be awesome indeed! Although it would reduce the speed of downloading the components, especially if you use multiple registries.\n. I agree that it doesn't make sense to nest component.json which is why I suggested to just remove ./ if it occurs at the beginning since every other possibility doesn't make sense.\nI'm also in favour of reducing the possibilities one has to format their component.json. \nSo, throwing an error when a script doesn't start with ./ or ../ is probably the best idea.\n(Although most component.json files will be transferred from package.json which will lead to those errors very often)\n. @Raynos Just out of curiosity: Why do you choose npm over component?\n. One of the key advantages of component is that it removes the need of an additional repository like npm, which has two main disadvantages:\n1. The need for another account\n2. Speed (It's faster to just download the few files needed of a component)\nSo having component autopublish to npm seems like a really bad idea.\n. Oh, and I think a really important argument in favour of component is that not only nodejs developers use browser components. So using something like component increases the chance of ruby, python, javascript, and, what the heck, even php developers share the same frontend components.\n. I think that that's something really worth thinking about and could greatly increase the use of component.\n. Wouldn't it be a good idea to just use SSH authentication and specify which keys to use?\n. Aaah @kelonye ,  don't mention coffee script in the presence of TJ!!\n. ",
    "juliangruber": "accessing private github repos would be rad, but the hassle of oauth isn't worth it. we wouldn't be able to automate this, would we? with selfhosted firewall-protected registries there are no issues with authentication and you could even use github enterprise. but that still isn't a good solution in all cases. you always have to have a registry running, even when developing privately. i like the idea to support git urls like npm oder bower does.\n. what if you need 2 private registries?\nsay both registries host packages\n- dialog\n- modal\nNow you want dialog from A and modal from B. There is no way to get this work when you just have an registries array in your component.json.\nIn this case you would do sth like\njavascript\nregistries: {\n  'first': 'http://first/',\n  'second': 'http://second/'\n},\ndependencies: {\n  'first:ui/dialog': '*',\n  'second:ui/modal': '*'\n}\n. things will be much simpler with basic auth, you would just to type passwords on component install\n. I guess that auth token is regenerated periodically or on demand so we can't rely on that.\n. github should return propper response codes, 403 or 404, so that's no problem...if we want private repo support.\n. @tj of course, you would seldomly overwrite exact repositories so your proposal works perfectly\n@forbes so sth like forbes@mycompany/dialog would be necessary. i'm tending more and more towards private registries over private repositories. the syntax is better and it's easier as soon as you have your registry set up. supporting both isn't so cool...\n. I like the syntax as it encourages the \"*\" version.\n@shtylman reinstall your deps from time to time or run an integration server.\n. why not check in components/ and node_modules/ to your scm?\n. you use them for installing and updating. and in component's case also for bundling and all that stuff. look at the npmjs website, its dependencies are also checked in.\nthink about all the packages you use from npm, you can't force a version number on their dependencies. And I absolutely don't want to have to find out a package's latest version during development. Deps should be in the component.json from the beginning.\n. +1\n. in component.json:\njson\n{\n  \"path\" : [\"lib\"]\n}\nthis could be called path, private, bundle, internal...\n. You should build without the --dev option then. See https://github.com/component/builder.js/blob/master/lib/plugins/commonjs.js#L65-L70\n. staying library-agnostic would be great. we atm use gettext for easy collaboration with translation bureaus and sticking to an approved standard. \nwhat i do now:\n- leave strings out of the template\n- pass a translation fn to the component\n- fill in text through dom traversal and calls to that fn\nthis works with gettext and t. you alao get the benefit of having all translations take place in one code block.\nis dom traversal the preferred way of doing this anyway, or will sth like mustache be integrated?\n. ``` javascript\nvar $ = require('jquery');\nvar clazz = require('clazz');\nvar ee = require('events').EventEmitter;\nvar bind = require('bind');\nfunction Card(pattern, t) {\n  clazz.base(this);\n  if (!t) t = function(s) { return s; };\nvar dom = this.dom = $(require('./template'));\ndom.find('a').click(function(e) { e.preventDefault(); });\ndom.find('.patternchart') .click(bind(this, this.emit, 'open', pattern));\n  dom.find('.watch')        .click(bind(this, this.emit, 'watch', pattern));\n  dom.find('.products')     .click(bind(this, this.emit, 'products', pattern));\n  dom.find('.details')      .click(bind(this, this.emit, 'open', pattern));\ndom.find('.category')     .text( pattern.breakout? t('Ausgeborchen') : t('Ausgebildet') );\n  dom.find('.type')         .text( t(pattern.type)       );\n  dom.find('.headline part').text( t('auf')              );\n  dom.find('.instrument')   .text( t(pattern.instrument) );\n  dom.find('.watch')        .text( t('Beobachten')       );\n  dom.find('.products')     .text( t('Produkte')         );\n  dom.find('.details')      .text( t('Details')          );\n};\nclazz.inherit(Card, ee);\nCard.prototype.render = function() {\n  return this.dom;\n}\nmodule.exports = Card;\n``\n. ok, that looks good too.\n.exports.stringswon't work when there is data from an API that is to be translated. If a component e.g. should print a color's name, likeYour chosen background color is black` it needs to translate that on the fly.\n3 possibilities:\n- assign the whole translation object to exports.strings: comp.strings = translations['en'] || clone(translations['en'])\n- translate strings in the api response: res.color = t(res.color)\n- let your api do the translation\nWith the passed t-function that is already covered.\n. What about performance? and precedence?\n. wiki, list sounds like ls\n. which would also augment .gitignore\n. yeah that looks like the best solution. read package.json, repl for component.json is cool.\nThe convention for existing files could be that if a file is already present then print out what component would create and let the dev merge that in. \n. component/jquery is a fork of jquery/jquery and has to be kept up to date by a maintainer.\n. he should fork it to his account and use that until the pull request he posts gets merged in. There's no other way.\n. repices won't work because libs like jquery need modification. jquery doesn't export itself, it's only in the global namespace\n. comma separated lists should be valid also! js: index.js, lib/foo.js\n. deep namespaces cause cancer\n. this was already fixed but not yet released. this issue relates to component/require btw\n. leaving out deps like jquery in that build would be great. Something like --wout component/jquery,component/emitter. then those would be picked from the globals and made requirable. in e.g. jquery's component.json that would be global: 'jQuery' which says both the export name for standalone builds and the import name for partial ones.\n. or leave out --wout, just put build.js first. The global field would still be necessary.\n. yeah that will be rad. still, under which name will a component be exported? if it's called event-emitter then would it be camelCased?\n. k nice\n. do we need auth for private registries or can we just asume that they are behind firewalls?\n. ?? what if multiple registries require multiple authentifications?\n. we don't do git clones, just plain http, so ssh is not an option\n. how can you specify for certain files that they are only included in dev builds? i thought this only works for which extra dependency should be included\n. I see...it shouldn't cascade as you don't need to work on a dependency. Work should always happen on the top level.\n. the consumer also has to write window['foo-bar'] which is lame, we should auto camelCase this\n. yeah but if you're gonna call your module jsonLogger in JS, the convention is to call it json-logger in the package manager. We should support that. On another thought...just use a correct name as argument to --standalone and if you screw up that's your fault. Noone should have to do window['foo-bar']\n. component should warn about that, however\n. as those files are all compiled to js and css before publishing you can just cover that in your makefile\n. One will eventually have to \"win\"...and both are using component.json so they're directly conflicting with each other. idk\n. or\njs\nvar zepto = require('zepto')\nvar $ = require('traversty')({ engine : zepto })\nor something. Just state that people need to install selector engines themselves\n. nice!\n. works for me, but I also recently had npm issues with dependencies not being installed for modules...\n. Private github repos are handled via\njs\n{\n  \"remotes\" : [\n    \"https://user:pass@raw.github.com/\"\n  ]\n}\nfor Github supports basic auth.\nIf you want them completely inside your infrastructure check https://npmjs.org/package/contre\nYou would add this as a 2nd remote on your component repos and push to it when you release a component. Then you only need a static file server (like connect with the static middleware) that serves the public folder. The url of this public file server again goes into the remotes path of your component.json. \n. As a new point at the bottom of the faq page in the wiki?\n. Have you tried whether that already works?\n. Ah of course.\nAnd putting multiple projects in the same repo is not that good idea anyway. Maybe GitHub is not your right choice then.\nI don't yet see a possible workaround.\n. @visionmedia ?\n. +1 atm I'm way too lazy to include minified and ulgified versions that work without require in the releases\n. Do you mean removing from the component.json or from fs? If the latter, that's not necessary\n. What exactly do you propose?\n. We def. need something like this! That's the reason why for some projects I still export a global.\n. wtf is this sorcery! if it works for travis it will work for component and having the cound even days behind should never be a problem\n. I don't see a problem except for batch\n. try https://github.com/visionmedia/watch\nthen use a makefile and\nbash\nwatch make\n. Or maybe use graceful-fs\n. The reason this works with npm is that when you have a script that says coffee my.coffee you can have coffeescript as a devDependency. So all it takes is npm install and everything works, there's no need for any tool except npm to be already installed.\nWhen we introduce this for component, there would need to be a way for component(1) to install coffeescript, otherwise you would expect binaries on a developer's machine that might not exist.\n. would also not work with npm shrinkwrap and probably other features, so it could be weird\n. ",
    "matthewmueller": "Ah, that's super awkward though. \"component/inherit\" is like the best of the possible names. \nvar Backbone = require('matthewmueller/backbone')\nThat's super ugly, because username has nothing to do with the project. \nSent from my iPhone\nOn Aug 13, 2012, at 9:20 AM, TJ Holowaychuk notifications@github.com wrote:\n\notherwise we'll run into collisions.. right now it's up to whatever you put as \"name\", but if two deps have \"foo/inherit\" and \"component/inherit\" with different APIs then we'll have issues. This means you'll need to do var inherit = require('component/inherit'), kinda sucks but it's not the end of the world\n\u0081\\\nReply to this email directly or view it on GitHub.\n. Yah... I definitely see this being a huge issue. I was porting some components last night and having a different name and package directory definitely feels inconsistent and strange.  But I just can't imagine referring to package names by username.\n\nUpdate: Haha, you also end up with:\nvar backstack = require('pwalczyszyn/backstack')\nvar html5clear = require('yyx990803/HTML5-Clear')\n... I don't know. It's not the end of the world.\n. Yah, I like that a lot. I think you could still have a dependency collision if you had:\ncomponents/\n  component/tip\n  bootstrap/tip\n... but it's much less likely than the current implementation. I could see a long dependency chain that could require two different forks with the same name though. Perhaps if you fork and make a bug fix to the main project. Not sure how often that would occur though..\n. cool! so just to make sure I understand this, the file structure would look like this?\n./components\n  ./component-tip\n    ./deps\n      ./component-emitter\n      ./component-jquery\nWhy'd you decide to go with ./deps instead of an inner ./components, like how npm does it?\n. Ah, okay that makes sense. sounds good.\nOn Aug 14, 2012, at 9:07 AM, TJ Holowaychuk wrote:\n\nthe user wont see that anyway, it could be ./components or whatever we want, even something ugly like deps would separate better for debugging haha\n\u2014\nReply to this email directly or view it on GitHub.\n. What about public and local? I tend to find npm link useful to fix bugs as they come up in public modules while building out some app.\n. Hmm.. this has come to bite me again. Trying to have a homepage and login page with a shared components.json / components/ dir.\n\nThere's no concept of two main's. Not that there should be, but to pull off multiple pages, everything has to be referenced by it's full package name (ex: component-jquery)\nNow that the project has matured a bit, I wonder if the dependency resolution (ie. component/emitter, visionmedia/emitter) has actually been an issue. \nI think it would be significantly easier to consume packages if we just went with require.register('jquery', function() { ... }), no more crazy aliasing, and builder could just throw if it ran into conflicts.\n. blah, it's not a big of a deal going with: require(\"component-jquery\") at the top of the file once. I think I got used to the look of it now, haha.\nI still run into the Error: trying to require(...) from root more times than I like.\n. It's not necessarily two separate builds, it's two separate pages that want to use the same components. Components are catered to building single-page web apps right now - that's a good thing. \nThe problem is once you try to tack on another page, it becomes messy. I could be missing something, but how would you \"boot\" from homepage and then \"boot\" from your main app?\nAlso, I actually think two or more builds could be necessary. Do you want your homepage loading all the JS from your js-heavy main app? That would be slow for first-time visitors.\n. mmm okay, but I don't think it's possible to have N \"boot\" components right now.\n. Yah, that's a good point. So with these \"boot\" components, are you even using stylus / jade / etc?\n. Sorry to keep \"opening\" this up, but the JS turns out to be pretty easy to manage with a single build.js. The \"leaking\" CSS in the single build.css from components required on other pages is problematic (eg. .menu coming from component/menu that's required on another page)\nAny ideas on how to manage this?\n. +1 this is also a big one for me\n. thank you thank you! I like local.\n. ahh shit, trying to update and accidentally deleted my last post... :-x\nanyway, updated:\ndirectory:\n/app\n  /components\n  /ui (private components)\n    /inbox\n    /group-list\n  component.json\ncomponent.json\njson\n{\n  \"name\" : \"app\",\n  \"dependencies\" : {\n    \"matthewmueller/backbone\" : \"*\"\n  },\n  \"bundled\" : [ \"inbox\", \"group-list\" ]\n}\nterminal:\n$ app : echo $COMPONENT_PATH\nui\n$ app : DEBUG=* component build\ndebug info:\ncomponent:builder lookup check $PROJECT/app/components/inbox +0ms\ncomponent:builder lookup group-list +0ms\ncomponent:builder lookup check $PROJECT/app/components/group-list\n...\ncomponent:builder ignore \"inbox\" styles +0ms\ncomponent:builder ignore \"group-list\" styles +0ms\n. oh one thing about these \"ui\" components is that they don't follow the naming convention username/repo, just inbox and group-list. Not sure if that would matter here..\n. okay no problem, thanks man.\n. +1 I'd also love to see some examples of application-specific components (signup, app views, etc.) to get a better idea of how to glue everything together.\n. Ooo what a great way to practice spanish :-D\n. Okay cool, just noticed this is a repeat of #119, closing this.\n. Yah, separating the template compiling from the builder makes sense - just means you can't have the template and javascript have the same name.\nChanging the main file requires way too many steps right now (update component.json, update makefile, change filenames). I always forget something. \nAnd editor thing isn't a big deal. Just for sublime/textmate the \"jump to file\" (\u2318+T) search on \"index.js\" returns like 20 results that all do different things. I guess it comes down to index.js just not being very descriptive.\nIn the end... a bunch of minor inconveniences, haha.\n. haha yah that's fair. \n. Ah yah, that makes sense.. just putting the private components onto a private remote if it ever gets to that point. \nNot really sure the distinction is too strong between private and locals though because \"local\" components are also \"private\" and \"private\" components could be \"local\", haha.. maybe I don't see your point.\n. I could be missing a use case, but it seems possible to distinguish between *, semver, and everything else, unless v1.0.0 is also supported. What about keeping a paths key and going with:\njson\n\"dependencies\": {\n    \"some/foo\": \"*\",\n    \"some/bar\": \"1.0.0\",\n    \"user\": \"user\",\n    \"admin\": \"admin\",\n    \"login\": \"login\",\n    \"signup\": \"signup\"\n}\nalthough it does look a bit redundant after looking at it for a bit.\n. yah, true. I guess it feels a bit fragile to me right now. It took only a minute to figure out, but it's also like a one-line fix. \nAlso, wouldn't the github url disambiguate - vs _?\n. hahaha yah. alright no biggie\n. oh you know what it is... I think component-search is \"lowercasing\" everything. \nThe component is correctly cased on the wiki and at https://github.com/yields/isArray\n. haha, okay no I think it's fine:\nyields/isarray\n  url: https://github.com/yields/isArray\n  desc: es5 isArray\n  \u2605 0\nIt's just confusing cause you can grab yields/isarray and dump it in as a dependency, and everything works... until it doesn't haha.\n. yah, dunno. not a big deal while developing, but trying to finish up a project sans jquery. oops, i meant npm ls btw, think you got that.\n. ahh that's great - thanks! haha, I guess I introduced jquery through an event lib I did a while back :-[\n. Yah, that's what I was kind of thinking but wasn't sure that was going to work. Instead of publishing each-component, publish as component-each.\n. Oh cool, I'll take a look at the repo key. \nYah, lots of components are browser only.. but there's also a bunch of js components that are generic enough to work on both sides. A consistent API without writing two different modules is a huge win.\n. interesting, yah i'll take a look at it now\n. sweeeet. ok yah, by specifying deps like that you can completely bypass npm publishing. \nOpened two issues on NPM to try and get some things resolved: https://github.com/isaacs/npm/issues/3013 and https://github.com/isaacs/npm/issues/3014.\n. TL;DR: package.json and component.json should have the same name.\nOkay so I think we should be encouraging people to not publish components to NPM, unless they can get the exact name as the component's name. Here's why:\njson\n\"dependencies\": {\n  \"set\": \"component/set\"\n}\nwill create node_modules/set-component because the name in package.json is set-component. This becomes incompatible with other js components that would like to consume set both client-side and server-side. \nE.g. - node.js's require will be require('set-component'), while component's require will be require('set')\nI think this tradeoff is fine. The only thing you currently lose is the ability to specify specific versions when you want to use components in node.js.\n. mmm yah that's true too.\n. anyone else still stuck? fwiw, I'm still running into this again and again.\nI think the appropriate solution would be for NPM to allow require('emitter'), where the package.json is:\njson\n\"dependencies\" : {\n  \"emitter\" : \"component/emitter\"\n}\nThis would be regardless of the emitter's package.json, which might look like this:\njson\n{\n  \"name : \"emitter-component\"\n}\nThis allows you to consume node modules in two different ways:\nnpm central-registry style:\njson\n\"dependencies\" :  {\n  \"emitter-component\" : \"*\"\n}\njs\nvar emitter = require('emitter-component');\ngithub style:\njson\n\"dependencies\" :  {\n  \"emitter\" : \"component/emitter\"\n}\njs\nvar emitter = require('emitter');\nya dig? here's the corresponding issue in npm: https://github.com/isaacs/npm/issues/3144.\n. @visionmedia yah, it works for emitter because emitter doesn't have any dependencies. it becomes a bigger mess  when there are dependencies.\nPersonally, I really think this should be solved with npm. I haven't exhausted all the use cases, but it seems to me that all that's required is when you see:\njson\n{\n  \"dependencies\" : {\n     \"some-name\" : \"component/emitter\"\n  } \n}\nyou should create the dir some-name in node_modules, not whatever is the name field is in emitter's package.json. This is a useful feature regardless if you use component or not. One way to solve this right now is a post-install script, but that's so ugly.\n. Well I think this is a big shame. It's all javascript. Perhaps right now it's an odd utility or two, but by making this easy and encouraging common libs, we open the doors to a bunch of new possibilities. For example, component/s3 and learnboost/knox could pretty easily be merged into a lib that works on both sides. From there you get a single repo for developers to come to, report bugs, create pull requests. Right now try-catch is fine for a single utility, but when you need a bunch of utilities across a bunch of files, it gets messy quickly.\nI do think the component's \"de-centralized approach\" is a more scalable approach, that's why I was hoping to get support from npm, even though npm is older, more established, and working fine. Perhaps, we were hyperbolizing that it's hard to find names in NPM. Yes, you can find new names for things. But as TJ said, it's the utilities that get annoying. The problem is that the utilities are exactly what you want working on both sides.\n. all i mean is namespacing (component's raynos/graphics, visionmedia/graphics vs. npm's graphics)\n. @dominictarr so the programs we would write would take advantage of the similarities, just abstract out the differences and provide a common api. \nor are you saying there's no need for a package manager on the client side?\n. @Raynos I was taking a look at some of your repos. Are you even publishing to npm or just doing:\njson\n\"dependencies\" : {\n  \"graphics\" : \"Raynos/graphics\"\n}\nor are you saying I should just call my modules:\njson\n\"name\" : \"matthewmueller-graphics\"\n\nThis whole issue has gotten lengthy (perhaps spammy for some), but the approach we could advocate for in component is to not even publish to npm, just have in the docs:\nFor npm: \nnpm install raynos/graphics\nFor component:\ncomponent install raynos/graphics\nDownsides mentioned earlier: discoverability\nI'm not sure how many people run npm search graphics and just install it right away without going to the github page anyway. I think most discoverability comes through stars and visibility of repo on github. Could be wrong though. I guess repos wouldn't even show up if you did npm search graphics, might be a problem.\n. Any update on this? Maybe just me, but I used to check this thing like everyday and always remembered to publish to component wiki because I wanted it to show up so others could see it.\n. hmm, this still seems to be an issue. do we know what needs to be done to properly address this?\n. @visionmedia the error is inconsistent, but this is what i'm getting:\nevents.js:80\n        throw er; // Unhandled 'error' event\n              ^\nSyntaxError: Unexpected end of input\n    at Object.parse (native)\n    at /usr/local/lib/node_modules/component/lib/Package.js:167:19\n    at fs.js:253:14\n    at Object.oncomplete (fs.js:96:15)\np.s. - we're migrating our deps over to component (finally!) \n. @dominicbarnes yep! that could definitely be it. so maybe it's related to multiple in-flight requests from the remotes?\n. oh yah, okay. I guess you can have a component.json with only dependencies. ie,\ncomponent.json\njson\n{\n   \"name\" : \"test\",\n   \"dependencies\" : {\n      \"learnboost/engine.io-client\" : \"*\",\n      \"component/url\" : \"*\"\n   }\n}\ntest.html\nhtml\n<script src=\"/build/build.js\"></script>\n<script>\n   var io = require('LearnBoost-engine.io-client'),\n       url = require('component-url');\n</script>\nIt's definitely a bit finicky, but probably fine for now.\n. doesn't seem to be working now, component search css should return a few results aha\n. also, displaying the version number would be hawt\n. anyone still running into this? I'm on 0.11.7 with component@0.18.0. @TooTallNate wasn't able to reproduce.\n. Fixed in 0.11.8.\n. My vote is using github's search to discover components, e.g. https://github.com/search?q=path%3A%2Fcomponent.json+dom\n. +1 for readme search. there's plenty of times i remember some random phrase from the Readme or description but have no idea what the name of the project is or how to search for it.\n. +1, I would also be down to help. Two other features that would be great to support:\n- Private registry support from the start. npm install component-registry should be everything you need to get started.\n- Support for lazy-loading modules from the registry, which is especially useful for mobile and tablet apps. Something like this:\n``` js\n// synchronous\nrequire('login')\n// asynchronous\nrequire.xhr = '/load';\nrequire('settings', 'faq', function(settings, faq) {\n  // issues a request to something like: /load/?modules=settings,faq\n});\n. yah, i was thinking about it a bit more last night. The ability to request a single component from the registry without getting all the `require(...)` stuff would be all that's necessary.\n.\nfailed to fetch https://MatthewMueller:somepass@raw.github.com/learnboost/private-repo/master/js.js, got 404 \"Not Found\"\n``\n. ahh silly mistake. thanks for help.\n. We ran into problems with scaling component too :-(... personally I think getting the dependencies right is more important than duplicates. We could use warnings (Warning you are requiring: emitter@0.8.0, emitter@1.0.0) or likecomponent doctorto allow for build optimizations.\n. latest component 0.19.9 fixes the redirect errors from raw.github.com\n. +1, i'm not a fan of multiple builders, especially when the \"2\" doesn't carry any meaning that would differentiate the two.\n. if you generate a token from here: https://github.com/settings/tokens/new, you should be able to access the API with basic auth.\n. I can confirm adding a token to the.netrc` now works:\nmachine raw.github.com\n  login MatthewMueller\n  password $PERSONAL_TOKEN\n. @visionmedia what do you mean? i'm not super familiar with the web components spec..\n. yah, i tend to agree with @jonathanong. component.json's in all the local directories of an app is a lot of extra labor for quite little gain.\nif you want to open source the local component, it's really simple to add a quick component.json and release.\n. i think multiple versions is definitely a good idea during prototyping. correctness is more important than bundle size in the beginning. then you can use tools / fork repos to optimize your dependency graph later.\n. yah, but throwing won't get your app off the ground in the initial stages. you'll end up forking everything. i actually don't really understand how component is working well for people right now, it simply picks whatever dependency version comes first in the install process. at cloudup we did have this sort of strict versioning in place, but i think mandating it from the beginning is the wrong call.\n. yah, multiple versions of css is definitely tricky though. i think in that case you would have to fork the repo if you didn't own it.\n. oh interesting, so you're already downloading the full tarball in some cases?\n. Great list. I was thinking about this a bit last night too and i think the CSS issue just has to be handled differently. It's seems to me that:\nJavascript is more likely to work when you have proper versioning, but CSS is less likely to work.\nI like @anthonyshort's suggestion about having a warning (or even error out) when there is a CSS version mismatch.\n. oh actually, my bad, i still had my old components\n. haha no idea why this is here, but @KenanY is right. I was publishing using 0.11.x. The latest duo was published using node 0.10.x so it should install. \n@samuelreh thanks for playing around with an early version of duo! duo will be open sourced very soon, but until then please find me on #duo.js or shoot me an email (address in my profile). this is not the right place for these kinds of issues.\n. So a few things:\n- Duo is about 95% ready to ship. I plan to open source it in about a weeks time. Basically I want to fix up some stdio issues, add a few more tests, and bring in the watch command. \n- It's private right now, but all duo related things will live at: http://github.com/duojs\n- @timaschew there's a few additional differences. I've added the latest documentation to a gist: https://gist.github.com/MatthewMueller/42fa88095b80155a1934. I'd encourage anyone who's interested in Duo to take a look at it.\n- @visionmedia you should give Duo a spin once we release, I think you'll reconsider ;-)\n. > if you use explicit dependencies you have more control. for instance if you want to switch a component or a version, you need only to change it in your component.json instead of replacing every file which using this dependency.\n@timaschew the manifest is optional. When I'm building a big web app, I'll probably use explicit dependencies as well for the reasons you mentioned.\n\nhow can I get more info on Duo so that I can evaluate it as soon as possible?\n\nI'd just start playing with it :-P. The examples should get you started and I'd read the readme one more time. As with anything there's a learning curve, but for component users it should be pretty minimal.\n. @darsain\n\nCan you try/catch require calls? finally? please??\n\nDuo ignores dependencies it cannot find. So it supports try-catch deps, but so did component with:\njs\ntry { \n  var tip = require('tip');\n} catch(e) {\n  var tip = require('tip-component');\n}\n\nIf you can't try/catch, how do you consume development dependencies?\n\nThis needs to be better documented, but you build a development bundle to test from. @yields has done a lot of work to make this easier with duo-test, which is an improvement over component-test.\n. > Also a feature I always wanted in component: I'd love build to somehow set environment flags & properties so I can check for env.development environment, or set stuff like env.apiurl\nYou could make a plugin, or if gulp has one, we'll support all gulp plugins by release :-)\n. Overall, Duo is not a huge departure from component 1.x. In fact it supports 99% of existing components. The only components that would need to be updated are CSS components that have CSS dependencies. The only components I found that do this are logo components.\nDuo reduces boilerplate, so it will make component development easier, not harder.\nNonetheless, it's going to take a bit of effort on your end to try it out and give it a shot. If you're not ready to do that or you don't have the time right now, then I would keep using component 1.x. Just be aware that most of us have moved on to using Duo or Browserify or Normalize and so Component updates will be infrequent.\nDuo is the most like Component of the 3 options, so if you enjoy using Component, I would give it a shot.\n. @fairwinds: \n\nCan you explain the scenario for CSS components with CSS dependents. This may not be common in public components but more apt to crop up in modular CSS Components that are private.\n\nSure, for example, https://github.com/logo/apple has the dependency https://github.com/logo/logo in the manifest here: https://github.com/logo/apple/blob/master/component.json#L17.\nIn Component, CSS files are included from the manifest. In Duo they're loaded in the code. This gives CSS an actual load order and only includes the CSS you actually use. \nTo retrofit https://github.com/logo/logo to use Duo, you'd simply include @import \"logo/logo\"; at the top:\n``` css\n@import \"logo/logo\";\n/*\n * Apple logo.\n /\n.logo[data-logo=\"Apple\"] {\n  width: 0.8113207547169812em;\n}\n// ...\n```\n\nWhen you say that most of us are onto something else, are you suggesting component needs a new maintainer? Can someone be clear about the segment.io sponsorship for the project and where this stands.\n\nHonestly not sure who the main contributors of Component are right now. What I do know is TJ is in Goland, Cloudup team @ Automattic is using Browserify, Segment is using Component 0.x & Duo, and Jonathan is using Normalize. That pretty much covers the core contributors that I know of anyway.\n. this week :-)\n. @timaschew \n\nwith duo components are not self-contained anymore, because when you write require('/lib/foo') or require('../foo) you are reference to a scope out of your component. A component should know nothing about the external world and paths.\n\nThis is not quite true. All remote components have the root set to their contained directory. So if you ran require('/lib/foo) on components/component-emitter@master/, you'd resolve to components/component-emitter@master/lib/foo. \nAs far as breaking out locally, it's all about application design. You can shoot yourself in the foot with both package managers. The only difference between component's local components and duo's local components is require('local-component') => require('../local-component') or require('/lib/local-component'). In both cases you're breaking out of the component.\nIn Duo we opted for less magic in the resolving process. The upside is you have a better idea of where your assets are, especially when there's new eyeballs looking at the code. The downside is it does take maybe 3 extra minutes to prepare a local component for open souce if/when you want to push it up to github.\n@fairwinds \n\nIt seems duo uses a duo.json that breaks with the existing component spec\n\nDuo is pretty much entirely compatible with existing Components. Certain CSS assets, that I discussed earlier are not compatible. Also assets that get linked in the manifest, but are not referenced in the code will not get picked up. I've searched through most the public repos with a component.json and there are very few cases where the component itself would need to be updated.\nWe haven't been basing our decisions on the existing Component spec as we don't think Component is sufficient. The \"spec\" of Duo is taking the good parts of Browserify & Component, with inspiration coming from Go.\n\nLooking forward, developers are also doing a number of things today that are not going to mean much with the future for JavaScript. npm and manifests fit into this category. Transformation or transpilation processes can be handled differently. That said, we are in this transition and tools that facilitate the newer workflows that allow developers to evolve is going to be helpful.\n\nCompletely agree, however I do think the work we're doing here will be better than anything the browser comes up with. At least for a while. Duo is just another evolution in the workflow.\n\nFWIW, I'm not pushing anyone to start using Duo. I've been using component for the last 2 years and it changed my perspective on front-end development. I have immense respect for the project and if it's working for you, then you should keep using it. \n. > I do wonder a bit about stylesheets now, though. You can't (unless I'm missing something) import the same stylesheet into multiple modules without significant code duplication. That is, if I want to have a module for my stylesheet variables which multiple components import, then my variables are contained within my code for every import. @MatthewMueller is this how it works?\nThis was fixed by @lancejpollard :-). It should be in the latest Duo release: https://github.com/component/duo-pack/commit/560b859acb3597c3bb592d3b07b06359f79890f2\n. haha, fixed.\n. ",
    "ovaillancourt": "+1 on that last solution\n. Yeah, and if it does happen, you can always have the require system throw an \"ambiguous component name\" error or something that forces you to fully qualify the name, no shortcut.\n. ",
    "colinf": "It's a tough call. Extending the use of package.json seems the most comfortable as it means just 1 package descriptor instead of 2 with some consequent overlap/duplication. However, in the limited work I have done to date I have found some conflict in dependencies when using a single package.json file. e.g. when I have jade in dependencies because I am using it server-side it is getting built into my components.js file as well even though I'm not using it client-side.\nMaybe package.json but with no overlapping usage. So I mean there would have to a componentDependencies entry as distinct from existing npm dependencies.\n. Yes I agree - if separate component.json then it should ideally not repeat anything from package.json\n. Hi Julian. I mean the dependencies specified in the \"development\": section of the component.json file. These are only included in the build targets if you run component build --dev. What I seem to be finding is that for all of the components specified in the \"dependencies\" section the --dev option is cascaded to them so all of their \"development\": components are also included in the build targets.\nOr I could just be going mad again!\n. Great - thanks\n. ",
    "eldargab": "Yeh, there will be many components making sense for both client and backend + there are dev time dependencies like mocha. The majority of components will have package.json anyway... But I like the idea of separate component.json. The best  thing to me is to just merge things from both of them.\npackage.json\njson\n{\n  \"author\": \"Guy\",\n  \"name\": \"foo\",\n  \"description\": \"Something awesome\",\n  \"keywords\": [\"foo\", \"client\"],\n  \"version\": \"0.2.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/component/foo\"\n  },\n  \"main\": \"./lib/foo\",\n  \"devDependencies\": {\n    \"mocha\": \"*\",\n    \"should\": \"*\"\n  }\n}\ncomponent.json\njson\n{\n  \"name\": \"component/foo\", // there is no need for this field since it can be inferred from the repo \n  \"scripts\": [\"index.js\"],\n  \"styles\": [\"style.css\"]\n}\nThe rule should be \"no component.json - no component\" but there should be ability to grab missing fields like description, author, repo, etc from package.json\n. > We likely wont even need the version field, keywords + description would be nice for search, name we'll need because for example visionmedia/page.js might want the name \"page\", or \"foo/popover-component\" may want \"popover\". repository prop is no good for us here either\nI mean that inspecting of package.json is nice to have feature it's not a requirement. The same is true about component name. Don't mean there is no need for it at all, but if there is a repo in package.json and no component name I'd like it to be inferred. That's just a personal preferences. I like a little magic like this.\nIf deciding on completely separate package.json vs component.json then\n+1 for component.json\n\nWe likely wont even need the version field\n\nO no! Please keep it!\n. > Maintaining a \"version\" in each is really the only annoyance, and that's pretty minor\nIt's just stupid to maintain \"version\"  for no reason. One nested async call introduced to fix this is not a \"complexity\". Really why not just merge?\n. > one async call what?.. \nThere is .getJson() method in https://github.com/component/component/blob/master/lib/Package.js#L120\nMerging means that it should be refactored to something like this\n``` javascript\nPackage.prototype.getJSON = function(fn){\n  var self = this\n  this.getRemoteJson('component.json', function (err, cmp) {\n    if (err) return fn(err)\n    self.getRemoteJson('package.json', function (err, p) {\n      p ? fn(null, self.mergeJson(cmp, p)) : fn(null, cmp)\n    })\n  })\n};\nPackage.prototype.getRemoteJson = function (file, cb) {\n  var url = this.url(file)\n  debug('fetching %s', url);\n  request.get(url, function (res) {\n    if (res.ok) {\n      debug('got %s', url);\n      try {\n        var json = JSON.parse(res.text);\n      } catch (err) {\n        return fn(err);\n      }\n      fn(null, json);\n    } else {\n      fn(new Error('failed to fetch ' + url));\n  })\n}\nPackage.prototype.mergeJson = function (cmp, p) {\n  cmp.version = cmp.version || p.version\n  cmp.desc = cmp.desc || p.description\n  cmp.keys = cmp.keys || p.keys\n}\n```\nIs it hard?\n. With this feature my typical component.json whould be\njson\n{\n  \"scripts\": [\"foo\"],\n  \"css\": [\"be\"]\n}\nDon't want to use scripts for coping fields. \n. I created a module which allows to require components from node programs as well as to easily share them with npm users. \nhttps://github.com/eldargab/component-as-module\n. The majority of components  will be private and app level and reside in the lib dir or so. There is even no need to maintain component.json for them. Just concat and you are done. component.json for such use case is a kind of pain. Yes, public ones are often required, but people are already doing using com.company.foo.bar in .NET, java. No one complains. \n. I would like to vote for the following:\n1) Deprecate .paths\n2) Deprecate .local\n3) Specify local dependencies as\njson\n{\n  \"dependencies\": {\n    \"foo\": \"*\",\n    \"component/event\": \"*\"\n  }\n}\n4) add --path option to component-build(1)\n5) Support nesting via components/ convention (like node with node_modules)\n6) No relative paths!\n. > it would be more convenient and easier to implement if node used a project-level dir with - \nHa, that's why I am trying to get components work on server as well :)\nWhat about .paths vs components/ I just feel they add additional bit of complexity. For example someone can specify \"paths\": [\"../foo\"] then everyone else should be aware about that if he wants to move things around. \nBut, fortunately all that \"local-paths-components\" stuff is private and therefore not important. \n. Hm, personally I wanted to try nested components some day because it's not always convenient to see lots of foo-* in a root dir. But for that case it's much better to have\n- lib/\n  - core/\n    - a\n    - b-c\n  - foo/\n    - foo-bar/\n    - foo-baz/\n  - mm/\n    - mm-a/\n    - mm-b/\nand add to paths all lib/*\nInteresting will that solve a problem for others?\n. I do this. The fact that regular css is a valid stylus makes it very easy to mix css and stylus components in one app. You can specify stylus files as styles in a component.json\njson\n{\n  \"styles\": [\"mixins.styl\", \"reset.css\", \"app.styl\"]\n}\nthen use component(l) to bundle all this mess and then just filter result through stylus compiler. Pretty handy.\n. +1\nWe should probably vote in npm issue as well.\n. May be just not to put things to npm? Or if you want to make your module easier to discover just publish a dummy version:\njson\n{\n  \"name\": \"username-foo\",\n  \"dependencies\": {\n    \"foo\": \"username/foo\"\n  }\n}\njavascript\nmodule.exports = require('foo')\nThat's for names which are essentially taken. There are few such. They all belong to very simple elementary tasks. For example UI elements - tip, dropdown, menu, etc. Each app, developer or organization might have it's own idea about what such names should mean exactly. Saying \"be creative and pick another\" just doesn't make sense. Prefixing with username-? Not too bad actually, but in the component word the choice is already made and it makes sense.  \nOn other hand there are tasks for which there is no one precise word describing what it does or tasks for which we really want only one canonical solution. For such case I agree with isaacs  - \"go and be creative\".\n. I created a module which allows to require components from node programs as well as to easily share them with npm users. \nhttps://github.com/eldargab/component-as-module\n. +1 for devScripts. Just because global script can't facilitate require('name') convention (at least seemingly) and in any case looks foreing\n-1 for auto requiring\n. Don't think it is necessary. It's better to have one obvious location for main and it's a script tag on page. If you have in mind particular use case e.g. testing then why not to go with convention such as devMain is always test and craft  executable for common boilerplate?\n. Also there are cases when there is more than one main. I have such :)\n. I like an idea of local dev component with relative path.  One thing I am curious about is why introduction of relative paths should mean deprecation of lookup paths for local components and why we should have separate local property? Absence of / could imply local component and after all the fact that some component is local is not so important to emphasize it with separate property. That idea were mentioned in #152 but got neither rejection nor approval. \n. Or \"user\": \"/\". Hmm, still odd but provides better visual contrast. Although logic should rely on absence of / in component name.\n. I changed my mind on this. It seems to be better to require dev stuff by convention, like node does. Some tooling could be used issuing sync xhrs or including sync scripts.\nSo now I am voting :-1: for relative paths and dev scripts)\n. > The problem is you need some system to specify which scripts are included for development.\nThat's what I am arguing with. component.json could include only assets needed for production. For development you can do git clone and then install missing external deps with component. Exactly what we have with npm.\nRelative paths with lookups together is a complexity. And I am definitely for lookup paths.\n. Yes it doesn't. But it doesn't mean that package format should be changed. That's just an adhoc way to add such support.\n. ### Styles\nThough I use Stylus it seems it should work for Sass too.\n1) Specify your Sass files as normal styles\njson\n{\n  \"styles\": [\"foo.sass\", \"bar.css\"]\n}\n2) In before styles hook replace content of all files with @import \"/full/path/to/file.sass\".\njavascript\nbuilder.hook('before styles', function (pkg) {\n  var styles = pkg.conf.styles\n  styles && styles.slice().forEach(function (file) {\n    pkg.removeFile('styles', file)\n    pkg.addFile('styles', file, '@import \"' + pkg.path(file) + '\";')\n  })\n})\nSo as result of build you have a \"css bundle\" like\ncss\n@import \"/full/path/to/foo.sass\"\n@import \"/full/path/to/bar.css\"\nwith everything in a right order. Pass it to Sass compiler and you done.\n. One downside of having separate properties for none-standard assets is that you wouldn't be able to fetch them with component-install(1) in case you decided to publish it somewhere, e.g. for internal reuse.\n. +1 for making support of unofficial file types easy with lib-ish version of component-install(1) once it become available.\n. Please, no.\n. For apps I put /components/ under version control and there is no root /component.json here. Also my personal workflow wouldn't benefit from that in any case. Also that may be kinda unexpected.\n. I didn't know that component-install(1) resolves locals as well, otherwise I wouldn't comment.\nBut if answering:\n\nI dont get why your app would have a ./components dir but no component.json\n\nWhy not? The app structure is\n- components\n- lib\n  - every\n  - thing\n  - is-here\n  - including\n  - boot\nThe build step is build lib/boot were build(1) is a custom builder. There is just no need for root component.json.\n\nIMO what we have now is unexpected\n\nI would expect from component-install(1) that it just puts stuff. I used to call it from app dir and it always created for me component.json. That was annoying. \nBut yeah, that's all personal, I am not arguing.\n. It's something like this https://github.com/eldargab/frp. There is component.json it just not where components installed.\nWhy not to put boot component stuff right into the root dir? \nThat will pollute root dir IMHO. Also for this concrete case there is no such thing as a boot component.\nWhy there is bin/cbuild that almost just a copy-paste from component-build(1)?\nIt was written for our app when there were no --use option and builder plugin API were not released. Here all what it does is that it allows to include lookup paths not via .paths option.\n. The best thing is site:component.io get me something cool :D, but also not working right now :(\n. I meant just google search :-)\n. +1 except I don't think that index.html.js is a good idea. For example if you want to go with the same rule for e.g. .jade you end up with require('item.jade'), require('view.jade') which is ugly because today it is jade, tomorrow html and so on. Anyway \njavascript\nvar html = require('./template')\nlooks better for me. What about file clobbering or template type ambiguity I haven't found that to be an issue. \n. though -1\nWith introduction of multiline strings this stuff will become almost useless. For now, if you have an app you need a custom builder anyway, and for public components compile step is not an issue.\n. All those ad-hoc searchers by keyword (npm, github, ...) suck. What works best is google if READMEs are properly indexed. E.g. https://www.google.ru/#newwindow=1&q=site:npmjs.org+open+xml\n. > there's plenty of times i remember some random phrase from the Readme or description but have no idea what the name of the project is or how to search for it.\nYeah, that's often the case for me too.\nActually the only thing I would like to have is just Readmes exposed in a search bot friendly manner.\n. ",
    "NuckChorris": "I agree with a separate component.json because it avoids polluting package.json with client-side stuff.  Libs which work on both client and server can use a package.json and a component.json, it's just one more (tiny) file.  Additionally, component.json would be easier to expand in future (no need to discuss additions with the server-side people), and would prevent publishing a client-side library to NPM (which, although possible, is a terrible practice that muddies everything).\nAll three pros of the package.json option can be defeated in some way.  The first one (adoption) is not really better on package.json \u2014\u00a0adding a file versus adding fields, there's unlikely to be a substantial difference.  Plus, if we copy isaac's thing and just start throwing component.json files at open-source projects, eventually it'll stick.\nThe second one, duplication, I can see being a problem, but it will only affect cross-side modules, which should be fewer than single-side ones.\nAs for dev dependencies, how about \"server-side modules\" which could allow for things like socket.io, where you need a client and a server to both be aware of the protocol?\n. I think a fallback adds complexity to the system, creates two places to check to see if it's a component, and overall is a bad idea. The only reason I'd do that fallback is for backwards-compatibility, which is not a concern at this time.\nPutting a component object in package.json would simply crowd an already fairly crowded file. Perhaps in cli tools for generating component.json, make it read from package.json (if it exists) to provide defaults?\n. ",
    "MandarinConLaBarba": "This may be outside the scope of this thread, but if there's going to be a separate module definition file (component.json), and its main purpose (most of the time) is to convey information for client-side implementations, why not name it something a little more meaningful/specific...something like 'clientPackage.json'? Naming it 'component.json' just seems like you're starting over, and since 'package.json' is already taken, the next best thing is..'component.json'. \n. ",
    "stagas": "How about both? The builder can check for component.json and fallback to package.json's component field. This way one package can be component only, or if it has node counterparts or is a generic one the author may choose to have the field in package.json instead since it's there already. I agree it should inherit certain properties but only when you use the field inside package.json. Also gives meaning to the option. Put all in one if you're doing both, if they're different separate them.\n. Not read both. Fallback. I think it's saner. You create a package.json, authors, keywords, repos and stuff, and you want to describe its component part. Just put the field right there. For generic modules this would be just a: \"component\": { scripts: [ \"index.js\" ] }.\nYou'll make a component.json when something is component only and you don't want to make a package.json or publish to npm. This way we're not forcing yet another thing, just gently telling them \"I'll look for components here and there, whichever is convenient to you\".\n. @Raynos I needed the to use modules from everywhere as well, so I built this. It works for components, npm and browserify modules. Maybe it sucks, I don't know. I like it so far.\n. For what it's worth, at first I was opposed to the idea of component being something else and the whole repo story. I really don't know what's best, time will tell. But after actually using it for some time now, I must say I kinda dig it. Let me throw some bullets to tell you what I like:\n- downloads are super fast, I mean, really.\n- it downloads only the things that are actually used, not the whole repo/package, which means you need to explicitly declare every useful file (leaves little to wondering), bundling is also cheaper\n- dep name is determined by the .json and not anything else. So I can fork component/foo, do something weird with it, change the dep to my username and it's still require('foo') to anything, so code doesn't need to be updated, (provided I kept the previous api).\nIf I were to publish to npm, I had to change all requires to 'foo-with-my-feature' which is an extra annoying step and it's ugly. Recently npm allows you to point to a git url, but mainly I like the fact that github is the default and everything is there.\nIt mainly boils down to, it's using github which is really good, and it's the only choice, so if you want your shit in there, you need to put them in github. I don't want to seek in the entire internet to see a source code, fork something or submit an issue. This is a really good feature.\nAnd of course, components are awesome! Use them now! Look at so many goodies you can component-install!\n. +1 one I see is the remotes resolving should be delegated to Package.js (currently in component-install)\n. This is the main reason I want implicit remotes, it saves all this trouble, just fire up the server and everything loads from your dev environment, no need to link/unlink or edit anything.\n. Currently, you can run a local server like this and put a \"remotes\": [\"http://localhost:8080/\"] in the component.json of the repo you want to try that remote first. What I wish for, is declaring the remote server on an env var or similar, so whenever I have the local server/registry running then all the components should attempt to fetch from my local repos first but without having to be explicit in every component.json and have all that clutter. If I understand correctly, this is the behavior you are looking for.\n. @clintwood for the multiple locations, I think it can be solved by modifying the registry server to run express.static for multiple paths, for the selective part I believe linking is the easiest way though install will try to use github by default if the remote isn't found so you could start/stop the server, effectively switching between origin and local. I guess there's no silver bullet here. Maybe @visionmedia has some suggestions on how to setup our dev environment properly.\n. I'm using it for dev only but the project itself doesn't need it, it is supposed to use github. I feel it's just easier for development to set your remotes and run a server and have everything try that first implicitly.\n. ",
    "balupton": "For what it's worth, I've started work on a project here https://github.com/bevry/projectz that auto-generates the different package files, as well as update your readme files from a single configuration file\n. ",
    "sebs": "```\nyori:backbone sebastian$ git push \nCounting objects: 8, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (6/6), done.\nWriting objects: 100% (6/6), 602 bytes, done.\nTotal 6 (delta 4), reused 0 (delta 0)\nTo git@github.com:solutionio/backbone.git\n   34b0511..e514ad4  master -> master\nyori:backbone sebastian$ component register solutionio/backbone\nevents.js:66\nyori:backbone sebastian$ \n.\nyori:tester sebastian$ component install solutionio/backbone\n install : solutionio/backbone@master\n     dep : component/underscore@master\n install : component/underscore@master\n   fetch : solutionio/backbone:backbone.js\n   fetch : component/underscore:index.js\ncomplete : component/underscore\ncomplete : solutionio/backbone\n\n```\nSeems to work fine ;) Just a little more messages I would need. \n. Hmm, I did not succeed in my own first component. Have a look here. \nMaybe I am missing the point. \nhttps://github.com/solutionio/countdown\nI still need one extra ../ although you dont seem to need it in yours ;) \n. Yeah, I got that, but in my countdown component neither the short one is working nor the version without ../ prefix. Sorry to bother you. \nChecked the install .. component is version 0.0.1, node is 0.8.6 \n. https://gist.github.com/3503541\nHere you go. \n. https://github.com/sebs/pomodorotimer/\nThis is where I build the application .. \n. I pushed a fix. \nhttps://github.com/sebs/pomodorotimer/commit/09e73b8327ceaae3163035c8ab30717ce069c3ae The main app stiull needs component- prefixes but not the ../ anymore \n. The prefix came with the name attribute in component.json of the application\n. ty, i guess i was jumping on to early. Will watch the second part again tomorrow. ;) \nSorry for the hassle\n. ",
    "buschtoens": "+1\nBTW, do we already have or do we need softDependencies?\n. A dep that is not neccessary but can extend the function of the component.\n. True words.\nBut btt I really like the array syntax, object literals don't make sense, since we don't have any data to assign to a dep, because components should be atomic and only requiring single files of the component is impractical.\n. +1\n. Automatically fully resolving on build makes sense to me.\n. You're right. There seems to be no reason for placing component.json outside or nested deeper in the root and ./ could just throw, so adding it to the spec would be unnecessary.\n. +1\nPlease contrast components and packages, too.\n. +1 for that issue magic.\n. +1\nThere should be a limit. Imagine 40 tabs opened at once.\n. I'd highly recommend rewriting your stuff. As you said yourself you're locked in a npm and browserify specific enviroment. This is an issue component tries to solve.\nAnd updating - let's say - 15 modules to the new component spec is a work of rarely 20 minutes.\nWhen you plan to dual publish our work you have to rewrite that too, so I don't understand why you won't tweak your models a bit.\n. It would be very sad, if somebody converts the components to npm.\n. @enyo Probably because npm existed before component.\n. That absolutely must go into the screencast in #37. Haha.\n. First of all using two different packages that do the same doesn't seem smart to me.\nAnyways you can require(\"visionmedia/markdown\") as well. No name-collisions here.\n. #6 Every kind of registry is supported. Even private ones.\nI bet you're referring to that npm discussion, but regarding registry lockins, we're way more independent. :D\n. +1 for wiki.\nMaybe registry?\n. May I help you? Or just trolling?\n. npm is npm and component is component. Crossing over would force\ncomponent to implement parts of npm's nature, which is contradicting\ncomponent's principle.\nForking would be the easiest and safest way.\n. Why not return str == 'y' || str == 'yes';?\nIt's a clean one liner without the ugly switch-case syntax. ;)\n. Dynamic images won't work on GitHub, since they cache all images.\nBut the core idea is very right.\n+1\n. Yup, that guy is a real lamo.\nBut wait... I noticed something odd.\n\nRight click on that image and check the source.\nTravis' images aren't cached... but components logo is. Could it be that, GitHub only caches non-https images, so that we users don't get that pesky warning? I think so, because Travis' build status is delivered via https, whereas the component logo was originally delivered via http.\nTest: an image delivered via https. Image url should be: https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRsG464cF1uZXfhJ4w38Zr28u1pNbWeJ1lsoROw2yQRAkPr0tBO8Q\n\n. Yup. works! We can use the dynamic images if they are delivered via https.\n. \nWhen this dot becomes green anytime soon they recache. I changed the original resource to a green dot.\nDo they recache on edits?\n. Yup, I edited the post to test. Seems like they recache on edits.\n. \nI won't edit this post. Let's see, if it becomes green.\n. Awesome. So that means, we don't have to purchase a SSL certificate. Haha. :)\n. Oh great, @guille already owns component.io. :D\n. Delete your browser cache. (Ctrl + F5)\n. That's really weird, because me it's green for me. Hm, GitHub works in mysterious (but pretty awesome) ways.\nI'll do a quick README.md test...\n. Let's see how it performs in README.md.\nhttps://github.com/silvinci/readme-test\nI'll change the image in about 5 minutes, without pushing to the master.\nHaha, you got me with the uncertainty principle. :D\n. I changed the image resource and it's still red. Deleting the cache doesn't work either (my iPhone shows red too). Guess, we'll have to wait and see when (and if) camo recaches.\n. Schr\u00f6dinger's cache! HAHA, I'm choking on my coke. :laughing:\n. I correct, we may have or may not have liftoff.\nFor me it's still red. But It's plain to see, that GitHub recaches, so green lights for dynamic images. :smile: \n. 2012: an internet odyssey.\nOkay, btt. I would prefer this:\nmarkdown\n[![This is a component](http://www.component.io/refer/:user/:repo.png)](http://www.component.io/components/:user/:repo)\nWe could also add some GET parameters so the image is somewhat configurable.\n. Green for me too now. We don't have to worry about GitHub's/Akamai's caching methods anymore. Although it would be pretty cool, if GitHub is respecting Cache-Control: private.\nSo what about the proposed format? Should plain text be added? Should additional text be added in the image?\nI kinda like @timoxley's image. But others may prefer bigger, more descriptive images. These could include text about components or the component itself. Could be configured with /:repo.png?description&someMoreStuff&andThatTooPlease.\n@pyrotechnick Ah, let's build it and name it PHP (lol).\nThe only problem is that not all requests are forwarded to component.io. But it would still be interesting and we could nag authors, who don't have implemented the image yet.\nAutomated PRs? :heart: \n. 10 hours passed an we've gone from 348 to 350. What a satisfying feeling. :+1: \n. We have a custom parser. Probably something's going wrong there. I'll\nimplement yours in about 8 hours (school).\nDo you got news on GitHub's improved searching API?\n. Did a quick <li> count on the wiki. We have 350 components indeed.\nDo you already have a graph on components growth? ForbesLindesay/component-website#14\n. Something like that? Haha.\n\nI know it looks rather shitty, I've spent like 5 seconds on that.\nDo you want the actual logo with that C-circle-thingy in there?\n. We will probably end up with inconsistent readmes anyway, since so many components have been released without such a notice.\nSending automated PRs or automatically creating issues, when we have a website would be a solution.\nI don't really like this either but the thought that so many people stumble upon all the sweet components and are just like dafuq? really nags me.\nI'd prefer setting up a quick simple server on component.io which temporarily servers the same image for all components, until we have a real website. As seen in the issue #144, GitHub would recache the image, when we're up an running.\nThe only things left to do now are agreeing on a format (/reference/:user/:repo.png) and setting up the catch-all server.\n. Well, all PRs are reviewed by humans before they are merged or discarded. We're not risking destroying something.\nI would parse the readme and then iterate over all links. Is there a link pointing at github.com/copmponent[/optional...] or component.io?\nYes: check if it is already in the correct format, if not replace it and PR.\nNo: insert a link at the top (?) and PR\nWhen in doubt (multiple links pointing to github.com/component) just open an issue with example code, etc.\nThe PR and issue should of course contain a detailed description, why this is happening and that this was automated.\n. #146, my friend. :D\n. +1\n. Are you talking about the readme.md? If so: #144, #156, #158\n. Ah, now I get what you mean. Until component.io is up that makes perfect sense.\n. Yeah, but what's the matter with adding https://github.com/component/component as a temporary website for the organisation profile at github.com/component? It won't hurt anybody and finding the main repo will be simpler, during this term.\n. Looks nice! :)\nAdd a start page and this will totally fulfill our needs until we have a public repo on which everybody can improve the \"official\" component.io website. :)\n@visionmedia will you route component.io to @ForbesLindesay's website or copy his app?\nP.S.: Hold PageDown on here for ultimate seizure.\n. Looking at your code, I think it's quite ironic that you built a everything-in-one-file website for a modular system. :D\n. It was worth it checking my mails at 2:50 am. This is awesome!\n. Haha. :D\nI recommend using a freehoster.\n. I see a potential problem with PHP's max_execution_time.\n. Same stuff, the drupal plugin would do and component already does: require()ing UI/client-side components.\n. @Nami-Doc Well, what else would you wanna do? We can't offer a cli on WordPress and Drupal.\nMaybe component.io should have some buttons \"Install on WordPress\", \"Install on Drupal\", \"Install on Node.js\", which then would show a short customized tutorial and/or do it automatically, just like the Faceook Like button.\n. Can't wait to see it and how you're going to use the self-containing express sub-apps as components.\n. Great, thanks. :)\n. Oh, like that.\n. AFAIK LearnBoost uses components.\n. component/component.io#16\n. Haha, WTFPL.\n. So, to get this to an end: @djanowski where's the difference between MIT and Unlicense?\n. @visionmedia Why do we specifically need to query the GitHub API to fully support semver? I am quite happy with just using plain old tags. AFAIK that's what they were made for.\n. So we can finally close #261 too :D\n. \nThe search API is down.\n. Ran into this problem with my own software. Either we have to limit the number of concurrent fs operations or have to increase the limit of the fs module (I can recall that this is sonehow possible). But I'd recommend manually limiting ourselves.\nOn Mon, Mar 25, 2013 at 3:55 AM, Erik Sundahl notifications@github.com\nwrote:\n\nGetting an error when adding too many dependencies. the dependencies work fine on their own but when i add a 9th dependency it gets the error below\n\"dependencies\": {\n    \"esundahl/attention-seekers\": \"*\",\n    \"esundahl/bouncing-entrances\": \"*\",\n    \"esundahl/bouncing-exits\": \"*\",\n    \"esundahl/fading-entrances\": \"*\",\n    \"esundahl/fading-exits\": \"*\",\n    \"esundahl/rotating-entrances\": \"*\",\n    \"esundahl/rotating-exits\": \"*\",\n    \"esundahl/flippers\": \"*\",\n    \"esundahl/light-speed\": \"*\"\n  }\nerror\n(libuv) Failed to create kqueue (24)\n(libuv) Failed to create kqueue (24)\nevents.js:72\n        throw er; // Unhandled 'error' event\n              ^\nError: write EBADF\n    at errnoException (net.js:878:11)\n    at WriteStream.Socket._write (net.js:626:26)\n    at doWrite (_stream_writable.js:211:10)\n    at writeOrBuffer (_stream_writable.js:201:5)\n    at WriteStream.Writable.write (_stream_writable.js:172:11)\n    at WriteStream.Socket.write (net.js:596:40)\n    at Console.warn (console.js:61:16)\n    at Object.exports.fatal (/usr/local/share/npm/lib/node_modules/component/lib/utils.js:10:11)\n    at /usr/local/share/npm/lib/node_modules/component/bin/component-build:110:18\n    at /usr/local/share/npm/lib/node_modules/component/node_modules/component-builder/lib/builder.js:411:21\nWhen I build with the --verbose flag\nerror : EMFILE, too many open files\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/issues/296\n. Oh, am this really is an issue we should resolve, as it's likely to happen again. Catching that error with a link to this issue would suit out needs if we can't really fix it now.\n\nSo please reopen this. :)\n. Maybe it should be the other way around. The plugins' package.json contains something like \"extends\": {\"ianstormtaylor/model\": \"~1.0\"}.\n\u200bThis way the main package doesn't need a push for each and every new plugin.\nOn Tue, Jun 4, 2013 at 5:32 AM, Ian Storm Taylor notifications@github.com\nwrote:\n\nsorry, to be more clear, plugins are things you extend the functionality of a component with, usually with a use method, like builder:\njs\nvar Builder = require('builder')\n  , jade = require('component-jade'); // plugin\nvar builder = new Builder(__dirname);\nbuilder.use(jade);\nor model:\njs\nvar model = require('model')\n  , defaults = require('model-defaults'); // plugin\nvar Person = model('person')\n  .use(defaults)\n  .attr('age', { default: 0 });\nthe reason for wanting it in component.json is so they can be displayed along with the main component in directories, otherwise they are hard to find. and it also increases the value of the main component by a lot if its got an ecosystem of plugins.\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/issues/346#issuecomment-18887296\n. Great, now we only need to find a suitable name for this property and @visionmedia's okay.\n\nIs there a better word than \"extends\"? It too much reminds me of subclassing and prototypal inheritance (which is also an interesting idea for compinents btw).\nOn Tue, Jun 4, 2013 at 5:57 AM, Ian Storm Taylor notifications@github.com\nwrote:\n\nyeah that's definitely much better if they're all crawled into one dataset, which i guess isn't too much to expect. and definitely gets over the annoyance problem of maintaining one to many plugins\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/issues/346#issuecomment-18887878\n. Well, now that you say it. Yes. :D\n\nOn Tue, Jun 4, 2013 at 6:17 AM, Jonathan Ong notifications@github.com\nwrote:\n\nBasically peer dependencies?\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/issues/346#issuecomment-18888356\n. So, I take it. The idea in general is accepted. However a good name has to be found. peerDependencies sucks; shortening it to peers is better. However peers doesn't really fit. The components listed under peers aren't peers to the plugin. They are more of a host (still this doesn't fit quite right).\nI kinda like extends as the plugins really extend their hosts. Yet extends is commonly used for inhertiance. So we can't really stick to that either.\n\nAs soon as we have a name we can start implementing in the spec, component-info and component.io.\nAny good ideas? Maybe @visionmedia can tweet something about it; he has a decent amount of followers.\n. +1 for augments.\n. extends and --extensions for plugins/peers.\ninherits and --children for prototypal inheritance stuff.\n. If they list them as their dependencies - of course.\n2013/6/9 whirlibulf notifications@github.com\n\nWill packages be able to require code from peer dependencies?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/346#issuecomment-19167306\n.\n. Maybe an extra db of aliases would do the trick?\n\n2013/6/6 Cheng Lou notifications@github.com\n\nThis might be too much of a demand, but I think in the long term it'll\nprove to be immensely beneficial.\nSearching components for \"page\" and \"pages\" should return the same\nresults. Same for \"query\" and \"queries\", and to a certain extent,\n\"validate\" and \"validations\".\nAs for the implementation details, I think the component contributors are\nmore qualified than me at handling this. But basically we could save the\nkeyword stems when a new component is submitted, then search those, rather\nthan the exact keywords.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/347\n.\n. An automatic mirror of the wiki would be quite interesting.\n\n\u2014\nSent from Mailbox for iPhone\nOn Tue, Sep 10, 2013 at 11:38 PM, TJ Holowaychuk notifications@github.com\nwrote:\n\ntotally, we need to add some real content to the site\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/issues/398#issuecomment-24196763\n. I'd really wanna read a blog post on Cloudup. For me, Cloudup's the best implementation of components so far.\n\n\u2014\nSent from Mailbox for iPhone\nOn Sat, Sep 7, 2013 at 9:04 PM, Anthony Short notifications@github.com\nwrote:\n\nI'm keen to help out on this.\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/issues/404#issuecomment-24007580\n. +1 highly anticipating this! Also wanting to help out on this. :)\n\n@nomilous not everyone uses twitter though.\nSent from an iPhone, so please excuse shitty spelling.\nOn Sat, Nov 30, 2013 at 10:29 AM, nomilous notifications@github.com\nwrote:\n\nperhaps a specially tagged tweet can activate the publish / versioning updater on the backend / backends\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/issues/429#issuecomment-29549000\n. @nomilous Haha :D\n\nSent from an iPhone, so please excuse shitty spelling.\nOn Sat, Nov 30, 2013 at 10:40 AM, nomilous notifications@github.com\nwrote:\n\nok, facebook then... :----)\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/issues/429#issuecomment-29549170\n. +1\n\n\u2014\nSent from Mailbox for iPhone\nOn Mon, Nov 18, 2013 at 1:29 AM, Matthew Mueller notifications@github.com\nwrote:\n\nThis PR does 2 things:\n- uses the new templates key for html, jade, etc. templates\n- allows you to give custom names for example\ndoes this component have html? yes // okay create name template.html\ndoes this component have html? no // do not create anything\ndoes this component have html? template.jade // create template.jade\nThis PR also sets a precedent that we should be requiring templates using:\njs\n// good\nvar template = require(&#39;./template.html&#39;);\n// bad\nvar template = require(&#39;./template&#39;);\nPersonally, I think this is must more understandable and allows templates and scripts to share the same name. I think with the introduction of the templates key, this is a good change.\nYou can merge this Pull Request by running:\n  git pull https://github.com/component/component update/component-create\nOr you can view, comment on it, or merge it online at:\n  https://github.com/component/component/pull/437\n-- Commit Summary --\n- use templates now for html, allow custom names\n  -- File Changes --\n  M bin/component-create (47)\n  -- Patch Links --\n  https://github.com/component/component/pull/437.patch\n  https://github.com/component/component/pull/437.diff\n. I guess checking mtime would do the trick.\n\n+1\nSent from an iPhone, so please excuse shitty spelling.\nOn Thu, Nov 28, 2013 at 5:31 PM, Dominic Barnes notifications@github.com\nwrote:\n\n+1\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/pull/445#issuecomment-29474212\n. Don't wanna be a downer here, but my impression was that component is kinda dead and duo is the new kid on the block.\n\nBut please correct me if I'm wrong.\n. Wow, thanks for taking time to write this elaborate answer. :)\nAnd thanks for keeping component on life support, I guess. :D\n. ",
    "defunctzombie": "I think it is very important that versions are required and must be pinned. If you don't pin versions you may run into the issue of deploying code which is different than what you tested with. It was a mistake for npm to allow * or > or ~ in the first place. During development you can install whatever you want freely but you should never publish components or modules which have flexible dependencies. You will run into problems.\nNot sure how to deal with resolving versions to prevent code duplication (possibly warn the user this is happening) but it is safer to duplicate code than to deploy something which will be broken and untested.\n. Was the problem description not clear? If you deploy something and it has deps with * you will be deploying a different version than what you are testing with. No integration server is going to stop that if the deps change between your deployment to integration and production.\nUsing * is just terrible, period. If you want to use it in your app, fine you can get burned by it. But don't put it in modules (npm or otherwise) and have it destroy other people's deployments just because you are too lazy to update your dependencies.\n. Because that pollutes your source tree. What is the point of using package managers and installers if you are just gonna put it into your scm? Now we are back to just having everyone copy the files into their repo and fixing them there instead of sharing the fixes back upstream.\nI find that by encouraging installation from package managers you also encourage contribution of fixes to upstream projects. Components are no different; people want to install something and have it work.\n. I am not saying I have an answer to the code duplication or how you should do things. But I do want to make known the dangers of not pinning your versions. This has gotten both myself and other users in the past. It doesn't matter if you are a believer in semver or whatnot. Any change to a package is a potentially breaking change to behavior and as such should not be pushed out without realizing that such changes have been made. Think about the failure scenarios and not just success :)\n. I think people tend to favor * when they have control of all the packages and versions they are using. As soon as you start to rely on others the process can break down.\nI agree that duplication is bad, but a broken release is worse than some duplication. One aspect I have yet to see done here is the idea of external modules/deps. Sure my component may use jquery I certainly don't want that packaged with the rest of it. That throws away all the goodness of CDNs and browser caching. Many apps are built in layers with some things changing more often than others. Finding a way to incorporate that aspect is pretty important to building out \"components\" But I digress :)\n. ",
    "athibaud": "this is one of the reasons we can't really use component for out app right now, do you think this could be implemented soon?\n. merveilleux ! merci !\nlocal does sound better than bundled...\nprivate?\n. ",
    "nickjackson": "+1\n. Or perhaps rather than using something like lookups, just shift the working directory to a specified directory and build everything from there?\n. haha. I know, I contributed to the lookups/paths stuff. I will try and explain a little better what I mean...\n. So if I was to have a node application, with a structure something like this quick example. I have all the community components in ./components and all my custom components in ./lib\n\nMy question relates to an individual component where I have server portions and client code. It can get a bit confusing with all that javascript. I am currently putting all component code inside login/client which is fine with only a couple of scripts.\nI was wondering if something LIKE this would be possible? Where a subdirectory is specified, and the styles/scripts are looked up in that location. Admittedly, \"localLookups\" is crap but its just an example.\n\n. cooool! Sorry about the typo!\n. ",
    "tomerdmnt": "Right now the Package module in component is depending on superagent, which means it is tied up with HTTP, maybe it can be abstracted away, making Package protocol agnostic, and this feature pretty easy to implement in many ways?\n. I fixed the small problems. \nI addressed the reporter, it now issues a warning and doesn't exit if it can't find a package in the private registry, I added a level paramer for the report function, not sure this is the best way.\n. I guess with this implementation it will use the same auth for all listed registries, which doesn't make a lot of sense, but it's a start.\nConfiguring different auth for every registry will not be too difficull, but it would complicate the component.js, don't you think?\n. OK, I added support for different auth for every registry. it supports both the verbose JSON object and the minimal URL with @.\nThe global auth (the one not assigned to any registry) is still used for the github URLs.\nI still need to write tests for auth use cases in general, I'll probably do it tomorrow.\n. I added the followin tests:\n- install private component\n- fallback to github\n- verbose json notation to authentication for each registry\n- minimal url notation for authentication for each registry\n- failure on bad credentials\n- global auth in component.json is not used in the private registries\nI also noticed while testing that require() caches the json files between tests. So this may produce some false positives with the existing tests as well. I added an afterEach for the registries tests which invalidates require's cache.\n. ",
    "geekytime": "It looks like you can't call cmd or batch files from spawn because they're not directly executable.  I've run into similar problems with build scripts in the past.\nAnyway, Grunt uses CLI, which uses exec() instead of span(), so I replaced the spawn() call with an exec() call (in place in my bin folder), and that seems to work.\nNot sure if there was a reason for using spawn over exec. Presumably the buffer length of the output could be a problem?\nA slightly messier alternative would be to build an alternative command for spawn() that invokes the windows cmd executable.  You'd have to extract it out into Windows and non-windows versions of the spawn process, of course, but in windows it works like:\nvar bin = \"cmd\";\nvar cmdName = 'component-' + cmd;\n//New args will go to cmd.exe, then we append the args passed in to the list\nnewArgs = [\"/c\", cmdName].concat(args);  //  the /c part tells it to run the command.  Thanks, Windows...\nvar proc = spawn(bin, newArgs);\nI don't have a non-Windows vm stood up to test, right now, but either of those will probably work okay.  Let me know if a pull request would help, but I wasn't comfortable choosing between those solutions without a bit more backstory...\n. I ended up using a Windows-specific spawn function.\nI couldn't get child_process.exec() to work properly for commands like create, which expect user input.\n. The problem is that when you spawn a process in Windows, the file that you give as the executable must be an executable.  '.cmd' and '.bat' files in Windows are not directly executable.  They're scripts that must be run within the context of an executable shell, such as \"cmd.exe\".\nIf you look at the code for child_process, Node is actually invoking 'cmd' in exec() (see line 471), but attempting to spawn the process directly if you use spawn() (see line 618). This spawn() call fails in windows because the cmd files we're trying to execute aren't directly executable.\nI'm not an expert in child-processes, but I'm guessing the exec() wasn't working for me because it's designed to return the results of the whole execution, and isn't set up to wait for user input.\nThat's why I thought our best option is probably to do like they do in child_process.exec(), and invoke cmd.exe on Windows machines.  The only question I had was whether to use process.platform, os.platform() or os.type() for the OS check.  The docs for that module aren't great, but from a few discussions I found it looked like os.type() might be a slightly more consistent check across versions of OSes, so I used that one.\n. (I started that last post before I saw @visionmedia's post.)\nOf course, another option would be to push this down a level, and extend child_process to support a combination of spawn() and exec().  Perhaps an option for spawn() that can force it to launch the process in the native shell?\nThe design of differentiating between spawning a process and executing a command is probably okay, but I agree that they way it's written now it  forces anyone who wants things to work cross-platform to jump through this particular hoop when they want to spawn() an interactive process.\n. It turns out there's already a discussion about this: Node #2318.\nThere's a subtle difference between child processes that are pure executables and child processes that are really shell commands, and the cross-platform issues exacerbate it.\nSomething like libuv should probably be able to handle both in a much more elegant way. We shouldn't need a third-party library to run shell commands.\n. Works for me. Thanks for at least trying to keep Component fully working on Windows.\nAlso: nice solution with the function swap. I spent way too much time working in Java... :P\n. which() looks like it only manages path and file extension issues.  It doesn't look like it will force the launch of the cmd.exe shell. I tried all kinds of hard-coded paths in there to make sure it wasn't a path issue when I was testing, so I don't believe that'll do the trick.\nFor what it's worth, over in the Node discussions, it looks like @isaacs seems to be in favor of a spawnShell() function on child_process, mainly because it would make it easier to spawn shell commands in both Unix and Windows. \nI might take a cut at that spawnShell() method tonight or tomorrow night and see if he'll accept it. If we can get something like that in child_process, we can simply just replace @ForbesLindeasy's fix with the built-in node function.\n. Heh.  Just push it up a level, huh?  Works for me.  At least the code we get to look at isn't cluttered. :)\n. ",
    "Raynos": "@visionmedia customFds is replaced by the stdio option\n. @silvinci I'm not \"locked in\". I choose to use npm as my module management system.\nWhen I say dual publish I mean I'll write a script to auto generate a package.json from a component.json then iterate over everything in component search and publish them all.\n. Maybe I should just ignore components and rewrite anything vaguely useful.\n. not dual publishing leads to duplication of effort in the component repo and npm repo. which is a waste of effort / shame.\nI'd personally use classes, event and matches selector if they were on npm.\nheck I might rewrite classlist myself tonight and publish it to npm.\n. Oh classes is. There were a bunch of other useful ones which are not in npm.\nSeriously though. You write awesome code. I want to use it. It sucks I can't because of package manager differences.\n. @visionmedia you have to name it something unique. But you never have to use it by that name. You can use the gh namespace.\nAnd the only reason the gh namespace works is that every module is prefixed by the author's name by default.\nHeck it doesn't solve the namespace issue at all. You are still forced to choose a unique name. Even worse you have no option to change your unique name. your stuck with visionmedia.\nNamespacing is a problem, it is a pain, you've just moved it somewhere else.\n. > still require them as you would with npm\nHow does component handle loading visionmedia/markdown and isaacs/markdown. What does require(\"markdown\") do.\n. @stagas +1 if that's a solid solution then awesome.\n. @guybrush has a point.\nThere's no reason why component can't be a command line tool that uses npm as the repository instead of github.\nJust have it auto publish component-visionmedia-classes or whatever have the the component tool abstract away the prefixes for you.\n. > I think browserify is definitely a cool and interesting approach - but it is a bit too heavy handed for me. For instance, packaging Resourceful using browserify results in like 150K of JS. No thanks.\nOnly 10k of that is browserify the other 140k is just about how bloated resourceful is.\n\nI view the browser and node as two different execution environments.\n\nThey are the same, they just have different host environments. Just like IE8 and chrome have different host environments. Simply write host environment agnostic code and your set.\n. @visionmedia have you considered just solving the namespace problem?\nI.e. \n```\nrequire = require(\"require-no-namespace\")\nvar Emitter = require('emitter')\n    , querystring = require('query-string')\n```\n. @visionmedia so I'm on the same page other then the namespace what other problems are there with npm?\n. @visionmedia that means you cool with loading mocha through component in the browser and through npm in node?\nI guess the \"npm is a bad browser tool\" is a bigger problem then \"I'm using two tools for javascript stuff\"\n. Then it's solving a different problem, makes sense.\n. This is actually a pain point for me with npm.\nI'm starting to do some significant amount of travel development without wifi and the only way to do it is with npm link.\nSo this is a good feature for any package manager!\n. @isaacs actually naming things is super hard.\nNot just npm modules. Functions and variables too. I waste like 50% of my time figuring out what to name the damn things.\nActually having a proper namespace in npm is god send. It's something enforcing uniqueness and consistency. Do you appreciate how awesome it is to have require(\"foo\") and npm docs foo mean the same thing everywhere.\n. as TJ says. If you treat node and frontend as two disjoint special childs then use npm for node and use component for frontend. For frontend stuff component is nicer. \nIf your into isomorphic code and want to treat node & frontend as the same JS with minor host environment differences then suck it up, use npm and browserify, if they suck then improve or fork them. \nOr if your really crazy you can hack in a npm-component interop thing. Like using a fork of the npm client locally, that could work. Good luck with that!\n. how is github any more \"de-centralized\" then npm. npm can hook into any registry you want, it's just a couch client.\n. @MatthewMueller prefix your modules with your name. easy enough. I don't have this naming problem. I authored 206 modules.\ndominictarr means the differences in host environments between frontend and backend are trivial. Write isomorphic code.\n. @MatthewMueller graphics is an experiment. It's not ready for npm yet. When it's ready I will publish it to npm under the name graphics.\nI refuse to use git for downloading and installing dependencies. It's a nightmare because you can't do npm i graphics@0.4.x\n@MatthewMueller discoverability is a seperate and difficult problem. npm is for VERSION MANAGEMENT.\n. Aw man. That's a great idea. Use component on the server side!\n. ",
    "impronunciable": "@MatthewMueller I'm using components for a personal project and also used in http://nicar.herokuapp.com/ that's a whois domain demo for a Express + Components talk I made at node.js Argentina meetup: http://zajdband.com.ar/express-nodejs-ar-meetup/\nI can build a couple more of examples and create a repo for those if it helps...\n. Just tried to add the option usign UglifyJS. It's super easy but I'm agree is more for deployment than dev.\nI'll close the ticket. If anyone wants to minify the build.js can just $ component build && uglifyjs -o build/build.js (if you build into the default path) \n. I'll try to deploy to heroku tonight.\n. Tonight = Argentina night\nhttp://www.timeanddate.com/worldclock/city.html?n=51\n. Just deployed to heroku. I'm going on vacations (without my laptop) so it will be cool to add some of you to the app.\n. ",
    "yields": "@danzajdband I think an example repo will be awesome, plus everyone can contribute to it, so patterns will emerge from there.. :)\n. @silvinci thanks, changed it :)\n. i think this should be opened ? it's not implemented\n//cc @jonathanong \n. http://browsershots.org/ there are too much browsers out there lol.\naren't all components suppose to support all mainstream browsers ?\nif they don't and we need dialog to support ie8 we can fork and pr it.\n. I basically do git release with git-extras add the component to the wiki, \nand i'm done.\nI don't think that component(1) should do any git or npm stuff, it's too opinionated.\n. @avetisk That i can agree haha :)\n. > has 100 dependencies\nSometimes it won't be accurate i agree, but it's still nice to know how big a component is\nbefore you use it.\n\nget the most points\n\nI don't think devs will do that, because it has nothing to do with how you write\nyour code, we simply minify gzip and check to see how large the component is.\n. Yeah the idea isn't perfect.\n\ndemoscene style\n\nI have never seen that before haha..\nThere is a lot of unreadable code on github that's for sure,\ndevs who write unreadable code will keep writing that way, regardless of what we are doing...\n\nuse dependencies\n\nI agree, but not adding the size of the whole component with it's dependencies will\nbe kinda useless because it's not real.\nI think we can solve this with adding standalone size which includes dependencies and size which\nis the code.\nI don't know haha, let's wait to hear some more ideas on what is the best way to go...\n. > If only we had a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications, using an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.\nThat would be awesome :)\n. @visionmedia \n@gjohnson\nTJ's screencast shows how to build modular web application with express, it's not MVC, it's modular. \nnot sure if TJ actually does this, but in my case each \"module\" has it's own component.\ncurrently with some hacks i can build my app successfully, but it's not pretty.\n. don't you guys have to add multiple .paths for that ?\njson\n\"paths\": [\n  \"modules/something/components\",\n  \"modules/login/components\",\n  \"modules/signup/components\"\n  ....\n]\nor maybe i'm doing something wrong here.. ?\n. json\n...\n\"paths\": [\"lib\"]\n\"local\": [\n    \"models/user\"\n    \"pages/user\"\n  ]\n@rschmukler Is this the root component.json ?\n. maybe you can do that with builder, i'm not sure though (didn't play with it yet)\naddLookup\n. I do agree with @silvinci i think we should put something until component.io is ready.\n. @jsalonen I think you meant component create test instead of npm component create test, give it a try.\n. @timoxley I haven't used json in a component yet but i think you could just do module.exports = require('./somejson');, not sure about other types though...\ncomponent/require#L65\n. @visionmedia @timoxley  i think that glob shouldn't be allowed, for example i wanted this feature before, but i don't want it anymore because now i \"get it\".\nmaybe we should add more examples of building apps using component, for example the \"todo\" app helped me a lot when i just got started with component(1).\n. It's hard to know what exactly the builder is attempting to do, did you try $ component build -v ?\n. Awesome! command + f to find categories in the component wiki is a little bit annoying.\nmaybe component add.\n. component register sounds even better :)\n. should i just change it to is-array ?\n. +1\ni think we can solve that easily:\ntake uid as an example, you can require it client side with MatthewMueller-uid (i think ?)\nso publishing it to npm with the name MatthewMueller-uid should work?\nanyway it's an issue, doing the try catch thing is PITA.\n. @MatthewMueller +1 !\n. I think what @Nami-Doc meant to say was \"finding descriptive names is almost impossible..\",\ni don't think someone could argue with that.\n. >  Are you saying that not even ONE of these is \"descriptive\"\nNever said that, i said almost impossible, so the question should be:\nAre you saying that most of these are descriptive ? surely the question cannot be yes... \njson\n{\"key\":[\"created\",2013,3,1,\"xcas\"],\"value\":1},\n{\"key\":[\"created\",2013,3,1,\"y\"],\"value\":1},\n{\"key\":[\"created\",2013,3,1,\"ctx\"],\"value\":1}\nbtw i'm happy with npm as it is, but it would be great if you think about this feature, if you decide to have it (or a portion of it), I will be happy to give back to npm and actually implement it... :)\n. Looking at \"requirements\", it seems that this feature isn't going to be implemented, ever.\n\nAt this point, we may decide that this feature is, in fact, too horrible to even consider, and it will die a bitter and tragic death, once and for all\n\nWe should look into other solutions.\n. component/todo has an mvc structure of some sorts, with a view and a model.\n. sorry this is a builder issue.\n. basically convenience and security :)\n. ! lightweight.\nTwitter is behind it so it will succeed.\n. :clap: @danzajdband \n. @TomasKuba \nwhy not use a makefile?\n``` Makefile\nstyl= $(wildcard lib//.styl)\ncss= $(styl:.styl=.css)\n%.css: %.styl\n    @rework-convert < $< > $@\n```\ni never used stylus but i'm sure you could just compile to css with a makefile.\n. i just usually do\nhtml\n<script src='build.js'></script>\n<script>require('boot')</script>\nboot is just initialization, you can always put require('boot') in a function that will be called .onload,\nor you can just put the scripts at the bottom of the page. \n. +1 awesome idea IMHO\n. +1\n. I use --out from time to time, plus like @dominicbarnes said, people might need this if they work with a framework that isn't as flexible as Express.\n. nope, this is what i mean.\n. yeah, lazy loading will be hard to implement but lazy evaluation could work, \nfor example we can require onclick.\n. @iyedb \ncomponent ls will only work on a directory which has component.json file in it.\ngetting started\n. this might irritate ppl.\n. Yeah I wanted to make it a full url but I saw that the .repo is appended to github.com.\nyou can still set a full URL and it will work fine :)\n. Gonna change this to full URL when I get home.\n. @visionmedia \ni'm all for integrating / embedding / mounting the app in component.io.\nhttps://github.com/component/component.io/issues/65\n. wonder what happens if you have a root component.json that lists both lib and views in .paths[].\n. i agree with @ianstormtaylor, my app uses 50+ components it's quite complex, graphs, keyboard and touch.\nonce i need something i prefer to build it from scratch using components, it's smaller,  readable  and most importantly it uses components.\n. you should put \"local\" dependencies in .local: []\n. > A quick search in the NPM registry will show that people are publishing their components to NPM\ni don't publish to npm :P. \n\nif I follow the convention that everyone is doing right now\n\nthere's no convention.\n\nAm I missing something\n\nPeople who want to use components with node or browserify will publish to npm, you don't have to publish to npm, there's no \"component naming convention\" you can name it with Math.random().toString(16).\n. works for me as expected, how does it get \"screwed up\"?\n. +1 for augments.\n. @ianstormtaylor thinking about this idea some more i think putting extends: is a bit risky, what if people start doing old style slideshow's with extends: [\"dom\"], looks a bit like jquery to me.\nmaybe something like Google Go interfaces could fit instead of extensions\n. +1 for this, i recently discovered this great plugin for rework, if we implement --extensions i think we can discover stuff more easily.\n. +1 @matthiasg just a string, shouldn't be a dom element imho.\n. maybe i want to manipulate it as a string, maybe i want to use jquery and not component/domify.\nmaybe i will add placeholders like :athing: and replace them with .replace().\nmaybe i want to require() it but not use it unless something happens, since no processing will happen when i require it, i can require it in the top of the file. instead of if (something) foo = domify(require('foo')).\n. i don't think you understood, it says that you should be doing this at build time, not component.\nif component was doing this, i will not be using it.\ni personally use the awesome rework by far my favorite.\n. component won't do that for you, you will have to use a tool.\n. i think going with different build will be better that way the signup page, won't load the whole ~200k.\nmaybe i build the signup and the landing page as different app and mount them :)\nthanks.\n. @ianstormtaylor yup express is awesome  :) each part of my app is mounted, the \"root\" app just connects everything together learned this from http://vimeo.com/56166857\n. btw, if anyone is stuck with a framework that isn't express what i would do is this:\n/\nhtml\n<script src='/build.js'></script>\n<script>require('boot-home')</script>\n/signup\nhtml\n<script src='/build.js'></script>\n<script>require('boot-signup')</script>\n. what command did you invoke, i'm on node 0.10.10 and component 0.16.4\n. you can have boot-signup, boot-login, boot-whatever, this is the simplest way.\nif you have a lot of pages this can become a PITA, but i have 3 pages and a single page app.\ni did this for the login page, for the signup and landing pages i created a separate app, and mounted it. (express)\n. https://github.com/component/todo/blob/master/index.html#L20\n. @jonathanong you can just do component build in a boot-signup and you will get a separate build, it's as simple as that.\n. imho, it's supposed to download them if they are in .dependencies: {} and it's a separate build.\n. i'm using node 0.10.12, component 0.16.7 and it happened to me only once. i don't remember what i did, probably make clean build.\n. @viatropos what versions of node, component are you using.\ni'm trying to get this to happen to me again so i can see what's going on.\n. this is intentional. that way people can add their own commands. \n. #124 \n. did you try updating to the latest version ?\n. > i think there was talk of standardizing a demo field in component.json as a link to where the demo lives?\nyep!\n``` text\n  \u03bb ~  cs -v cornelius\nrestorando/cornelius\n  url: https://github.com/restorando/cornelius\n  desc: Cohort Visualization component\n  demo: http://restorando.github.io/cornelius\n  version: 0.1.0\n  license: MIT\n  \u2605 0\n``\n. yeah .demo is supported since [0.16.0`](https://github.com/component/component/blob/master/History.md#0160--2013-05-13-).\n\nI guess the only issue with this feature is not many people know the URL of their component demo before they create it. \n\nyou don't have to know the url before you create it, you can add .demo anytime you want, and it will be updated in the search, remember the search get's updated every ~5m\n\nWould it be best that the standard Readme that is created simply contains a demo section to be filled out\n\nmost component shouldn't have a demo, we shouldn't force people to remember to remove a section from the readme.\n\nI guess the goal of this is just to make sure people supply some form of demo if they want their component to be used by others.\n\nit's recommended to add a demo.\n. yeah\n. @MatthewMueller \nlazy loading would be awesome, does it have to be in core though ?\nalso i noticed it would be really easy to do lazy-evaluation with component :D\n. @seanhess maybe files: prop is what you want.\n. yeah builder.js makes this easy.\n. yea though you need to wrap the global require, to support both component and node.\nit's ugly but it works.\nalso TJ might have a nicer way.\n. +1 for function(){}\n. damn i think i'm loosing...\n. assert doesn't change to component-assert in the built file ?\n. looks like it's a builder.js issue ?\nhttps://github.com/component/builder.js/blob/master/lib/builder.js#L839\nmaybe requires should be replaced only when not in --dev...\n. -1 make / middleware works for me.\n. you can do require.register('my-component', function(){}), but multiple builds are def nicer.\n. @matchdav i should've said this earlier, but totally forgot require.register() is not public api i just used it once to test something.\nso if you use it, and we decide to remove it your app will break.\n. agree with @ianstormtaylor @anthonyshort and basically most component users on this, you can use Makefile or component-bundle.\nrequire.register() is just too nasty :P\n. ``` bash\n\nc -V\n1.0.0-rc1\n```\n\ni'll try and npm cache clean.\n. k after cleanup here are the versions (still seeing require(\"undefined\")).\n``` bash\n\nnpm -v\n1.4.6\nc -V\n1.0.0-rc1\n\ncd into global component\n\ncat */package.json | awk '/\"name\"/||/\"version\"/{ print $0; }'\n  \"name\": \"commander\",\n  \"version\": \"2.2.0\",\n  \"name\": \"component-build\",\n  \"version\": \"1.0.0\",\n  \"name\": \"component-consoler\",\n  \"version\": \"1.0.1\",\n  \"name\": \"component-ls\",\n  \"version\": \"2.0.0\",\n  \"name\": \"component-resolver\",\n  \"version\": \"1.0.0\",\n  \"name\": \"debug\",\n  \"version\": \"0.8.0\",\n  \"name\": \"mkdirp\",\n  \"version\": \"0.3.5\",\n  \"name\": \"open\",\n  \"version\": \"0.0.4\",\n  \"name\": \"semver\",\n  \"version\": \"2.2.1\",\n  \"name\": \"superagent\",\n  \"version\": \"0.17.0\",\n  \"name\": \"win-fork\",\n  \"version\": \"1.1.1\",\n\ncd into component-build/node_modules\n\ncat component-builder/package.json | grep '\"version\"'\n  \"version\": \"1.0.1\",\n```\n\nno idea what's going on :/\n. weird, are you trying this on yields/k with --dev ? here is the complete build.\n. yeah, that's the only issue.\nmaybe return the string if a component is not found ?\n. Haha sweet, thanks!\n. > we want to build single components during development (only the files we've changed) and not the all 80 components.\nduo uses Stat.mtime to only parse / build / fetch stuff that are not installed / built already, if that's what you meant ?\n. gotta agree with @stephenmathieson here, i can't understand how manifests tie in with Makefiles or why would auto generating makefiles is better / easier than just using duo.\n. > , is there a way to add additional GH-like resolvers to Duo? I see duo-package uses gh-resolve and that looks pretty baked in... if that's that case would this be where it could be extended to use additional resolvers?\ni think we agreed on something like duo.provider(regexp, obj), obj has #auth, #resolve and #tarball, so should be pretty easy to add a provider i think.\n. ",
    "adamsanderson": "@visionmedia  and @ForbesLindesay:  Is anyone working on this?  If not I have a script that ,while not terribly pretty, is more or less working.\ncomponent-lint \n        lint : /Users/adam/Projects/trigger-event/component.json\n          ok : name\n          ok : repo\n          ok : main\n          ok : description\n        warn : keywords \u2013 are suggested\nIf you're interested I can work through the remainder of the spec and we should have something reasonable.\n. @visionmedia ok, I'll clean it up and load in the rest of the spec.\nI figure some other script could drive the command-line tool if someone wanted a github nagging bot.  Are the end points for http://component.io documented anywhere?\nBonus: while writing this, I realized I never added any keywords to my component.\n. @visionmedia for what it's worth I put together component-lint. \nEventually, I would like it to suggest fixes for easy things (missing name, description, license, etc.), and also do some checks against the files, like warning if people are using prefixed css.\nI think component-bot could even use it to open issues ;)\n. If you have any suggestions, let me know.  I haven't done much with node outside of little personal projects.\n. ",
    "guybrush": "I don't see why component solves the namespace-conflict-problem or why npm is a \"lockin\" into an evironment and component isnt.\nYou guys know, with npm you can do the following?\n{ \"name\" : \"foo\"\n, \"version\" : \"0.0.0\"\n, \"dependencies\" : { \"bla\" : \"https://github.com/userX/bla/tarball/v0.0.0\" }\n}\nnpm is all but a lockin! its a package-manager for packages we all agree to define in a specific way (node_modules -folder + package.json -file).\nSo for now at least, for me component is just noise :/ I really would like to see: what exactly are the benefits?\nPlease dont understand me wrong, I am a @visionmedia fanboy! But i dont see the real advantage of components over npm-packages. Why dont we just extend the package.json with {component:{files:[],styles:[]}} and write a fileserver which just mounts assets out of the node_modules -folder?\nI heard that @isaacs said that he doesnt care about what exactly is in npm, so assets-only packages would be fine? As long as one does not care about naming-conventions (i.e. node_modules -folder + package.json -file).\nRegarding the namespace-conflict, we dont have to use the registry as mentioned above. Component could be just a tool which greps a list of tarball-urls. But the important thing is, to make them a npm-package with a package.json file which will end in a node_module -folder after installation.\nMaybe i am all wrong and dont get it at all, though i wanted to tell you guys my thoughts.\nps: in some way, component is to npm like coffeescript to javascript :p\n. @enyo sorry my english isnt good, but i think you didnt get the point i wanted to make.\nnpm isnt only about the npm-registry, you can define your dependencies with tarball-urls (also git-urls are possible besides using your own registry or multiple registries). so you dont have to rely on any registry what so ever. the important thing is how you define your packages.\nthat said, after looking into some components i noticed they are all built in that way (?):\ncomponent.json:\n{ \"name\" : \"foo\"\n, \"version\" : \"0.0.0\"\n, \"dependencies\" : { \"userX/bla\" : \"*\" }\n}\nand an optional(?) package.json:\n{ \"name\" : \"foo-component\" \n, \"version\" : \"0.0.0\"\n, \"dependencies\" : { \"bla-component\" : \"*\" }\n}\nthe problems i see with this:\n- the package.json becomes an \"odd\" thing, instead of being an integral part and the most important thing regarding package-definition\n- now i have to maintain 2 definitions for 2 ecosystems - which now introduces a real naming-problem, since i have 2 names for the same thing\nhow i think the whole problem would be solved \"better\":\n- if you are not ok with the fact, that there can only be one module with a certain name in one registry, just dont put it into the npm-registry. host it anywhere and lets put a list online somewhere with tarball/git-urls\n- send a PR to npm, which implements dependency-urls to packages where every file is served separate\nso again, maybe i just dont get it - but imho components as of now do not only split the community but they create a seperate ecosystem instead of making the existing one better. i get it that clientside-modules/packages are not only about scripts but also include assets (sometimes even only assets). but i really would like to use them by installing them with npm!\nalso I think right now is a very important point in time, where we all decide how to do things in the future. and @visionmedia plays an important role in that decision since he is kind of an opinion-leader and actually implements his ideas instead of only talking about it. so for me.. if everyone sticks with the component-approach, i will have to also go this way :p\n. Thanks for explaining your thoughts in depth (again).\n. ",
    "medikoo": "@guybrush +100, very well put. I don't get that as well, totally happy with npm.\n. @visionmedia you repeat that all over, without any constructive explanation, it's hard to treat you seriously.\nI don't see any advantage for using components system, to me it's no value added just noise @guybrush explained the concerns very well\n. > Component(1) is faster\nNPM was never slow to me, so I don't see a problem you are trying to solve.\n\nhas search that works\n\nNPM can be searched well and fast from various sources, its native search if it has problems, surely will have it solved\n\nrequires no secondary credentials like npm does to manage\n\nThe way NPM does is totally fine for me, why is that an issue for you?\n\nsolves the namespacing problem elegantly\n\nNamespaces if needed can also be accomplished with npm, and technically if you want, you may just prefix any package you publish with any chosen string you want (some developers do that). Still public system shouldn't depend too much on namespaces, it makes it not clear. I don't favor namespacing on that public level.\n\nWhat does npm get you? nothing\n\nHow constructive is that?\nIn my opinion it doesn't take much to turn npm into a decent package management also for client-side, it has great design and has already proved to work great for server-side. Creating other not compliant package systems introduces a mess, and moves us away from idea of one system that we can use across environments\n. It's always though to come up with good original name for your utility, and it's not 5000 names taken that makes that difficult. I have about 20 packages published and about 10 I plan publish soon, and names was never a blocking issue for me (even though few times, name I wanted was already taken).\nI also don't see a solution in naming your utils as my-nick/util, it doesn't bring nice recognizable names but instead brings no name feeling. It might be ok if you do stuff for yourself, but if you also care for outer adoption it probably won't help.\nI'd say: if your after generic cross-environment packages just use NPM, if you're ok just with browser world, you might be fine with Components. I'm personally totally happy with NPM although 70% of my work is dedicated for client-side.\n. @visionmedia the only \"advantage\" you have is that you can import namespace/whatever with require('whatever'), that's all. I don't see any big opportunity in that.\nExternally your package remains namespace/whatever, from that perspective there's no single advantage over NPM. Some NPM users used namespace based naming method (\"namespace-whatever\") even before Component existed.\n. ",
    "isaacs": "For what it's worth, I disagree with some of @visionmedia's arguments here, but not all of them.\nThe search capabilities in npm leave a lot to be desired, it's true.  But it's also searching a much larger corpus of data, and is a much more challenging problem than what component has right now.  That's not to say that I'm happy with npm having a shitty search experience, obviously; I'm not happy with it.  In the meantime, if using some other system provides you with a better experience, then that's easily a short-term win.  I'm skeptical that component will be able to avoid the same problems at the same scale that npm is today.\nWe've talked about namespaces, and that is a settled issue.  I think that component will run into the problems that I've seen in other namespaced package lists.  Maybe I'm wrong.  Only experience will show us.  I'm didn't judge that experiment to be worth the risk of the costs it would introduce; @visionmedia does.  I'm grateful for that, and eager to see how it works out.\nI don't think that picking a username and password is a big deal.  Some kind of oauth to github would be nice, but it's also a non-trivial thing to implement, and it's not very high priority.  Also, it would wed us to github in a way that would be very difficult to change in the future.  You could argue that we're already wedded to github today, and that's a fair claim, but it wouldn't be hard to change when something better comes along.  If we use github as the registry, or as a core part of the infrastructure, then we can't change that nearly as easily.\nAs I've said repeatedly in the past, I am perfectly happy with people using npm for non-node code.  That's fine.  I don't even think that the ambiguity is really as bad as you might expect, since it is all JavaScript, and a surprising amount of stuff is reusable (as browserify users have found).  But I'm not willing to add features, complexity, or requirements for things that are not of benefit to the node user experience, because that is what I care about, and that is the core purpose of npm.  If for whatever reason that means that npm is not a good fit for some use case, then using something other than npm is probably a very good choice.  I think that comparing it to using gem is a bit weird, because it's a different language entirely.  But I guess you could argue that css and html aren't javascript, so... I don't know.\nLastly, none of this is permanent.  If @visionmedia wants to use github as the component registry, more power to him.  If he gets to 10k packages and search starts falling over, and by that time, npm has fewer of the problems that he's unhappy with, then we can re-evaluate it.  It's software.  It's just costs and benefits.  Component is a cool program, and it's great to see someone actually building something rather than just whine about stuff.  That's why I have so much respect for @visionmedia, and take his criticisms seriously, even when I disagree with him.  Let's see how this goes, and solve the problems that we encounter along the way :)\n. > this argument is not going anywhere, I'm not going to use npm sorry it makes no sense to me\nIn case it wasn't clear, +1 to closing this thread.  Better to be decisive than hesitant and democratic, especially with a thing that's as new as this.\n. > for now I'm just building what I personally want in a dev environment, it wont be for everyone\nThat's pretty much the ideal approach, in my opinion.  Don't waste time on imaginary users you don't have, when you are a real user today with a real need.\n. So, maybe this is a silly question, but why does component require you to have a different name in package.json than what is passed to require()?\nIt is prohibitively complicated to make npm support this.  There is a sprawling network of tools and services already built on the assumption that the name in package.json is the actual name of the thing.  Handling the fallout from unraveling that assumption would be insane.\nIs there any way to make component not do this?  It seems pretty surprising and weird.\nJust FYI, the medium-term plan for npm is that \"dependencies\": { \"blerg\": \"component/emitter\"} to actually raise an error and fail the install because the name doesn't match what it expected.  I'd've done it already by now, but it's hard, and node 0.10 has to go out.\n. Really?  ALL names are literally taken?  I think that's pretty obviously not true.\n. Well, actually, that's exactly what I'm arguing with.  So far 4766 brand new packages have been created with unique names, just this year.  742 of those were in the last week.  Almost 100 of them JUST TODAY.  Are you saying that not even ONE of these is \"descriptive\"?\nhttps://isaacs.iriscouch.com/registry/_design/app/_view/analytics?group_level=1&startkey=[%22created%22,2013,3]&endkey=[%22created%22,2013,3,{}]&group=true\nFrankly, if you're having trouble coming up with a reasonable name for the thing you're building, you're probably building the wrong thing.  I've written almost 150 modules published to npm, and a bunch that haven't been published.  Finding an un-taken name is not a real problem, and when the best name is taken, even better!  You've found someone else solving the same problem as you, so you should work with them.\n. > Never said that, i said almost impossible, so the question should be:\nSo, if you're going to split hairs, then there's no such thing as \"almost impossible\" because that would mean it's \"possible\", and thus, not impossible.\nMy point is that, if you're having a hard time picking a name, and that's really your biggest problem, you're probably solving the wrong problems, or engaging in NIH.\nMy complaint about your criticism is that it's hyperbole.  I have no problems finding new names.  Neither does @substack, or @Raynos, or @dominictarr, or many other prolific node module authors.  Are you saying that \"emitter\" is a more descriptive name than \"component-emitter\" for the emitter module that is component-specific?\nThe fact is that @visionmedia has made design choices in component that make it less compatible with npm.  That's fine.  But that's no reason to rewrite npm so that you can call things different names.  Tell TJ to rewrite component so that it uses the name from package.json, if it really bugs you so much.\n\nit would be great if you think about this feature, if you decide to have it (or a portion of it), I will be happy to give back to npm and actually implement it... :)\n\nI explained the requirements over at https://github.com/isaacs/npm/pull/3205#issuecomment-14654258\n. ",
    "stereosteve": "Guess I'm kinda late to this party (just found component a few days ago), but this is an interesting thread to read.\nI encountered this when starting to write a component that could be used both in node and the browser.\nHere is a gist with the way I solved this problem.  Perhaps there is a better way to do this, but to me it seems like a very minor inconvenience for now.\nI agree with @visionmedia and really like the approach that Component is taking.  The only benefit I see to using NPM is for the small subset of component packages that are designed to work in Node as well.  And in this case, it saves the author from having to dual publish.  But this is a very minor inconvenience, and who doesn't push code to github before publishing to npm?\nBut sharing code between the node and the browser is an interesting topic.\nI think browserify is definitely a cool and interesting approach - but it is a bit too heavy handed for me.  For instance, packaging Resourceful using browserify results in like 150K of JS.  No thanks.\nI view the browser and node as two different execution environments.\nInstead I much prefer the approach of things like superagent which provide a nice API and sane implementations for the specific environments.  This is a package carefully designed to work in two places, so it makes sense that it is published to both registries.\nLong story short - npm packages work in node, component packages work in the browser, makes sense to me.\n. One idea that would not require a change to NPM would be to adopt the github naming convention when publishing components to NPM, and adding support for github naming convention in component (using aliases).\nFor instance, when publishing emitter to NPM:\njson\n{\n  \"name : \"component-emitter\"\n}\nThen add extra aliases to component so that you can require things by their component name or full github name.  For instance, make it so that both of these would work in component land:\njs\nvar emitter = require('emitter');\n// or\nvar emitter = require('component-emitter');\nBy using the later you would have code that would work in both node and the browser without env checks.\nOf course, this sucks in the long run, like if you want to use a different fork\n. @visionmedia I get 503 errors at least a few times a week.\n. ",
    "reinpk": "this is still a pretty big pain for me. our current workaround is to change the standard build from this:\n@component build --dev\nto use the standalone flag:\n@component build --standalone build --out ./build --name build\nand then require build.js as  so that i can do mocha testing in the terminal. but this breaks down when you want to include one of your dependency components (or any other component) for use in your testing suite.\nhow can we unbreak require-ing components in our testing suites? two ideas so far:\n- map components/ to node_modules/ somehow so that require() works\n- component build your mocha test so that require() works\nam i missing something obvious or is this a big problem for testing with component (when your component isn't a tiny piece of code, but has dependencies).\n. yeah, it looks like testing in the browser w/mocha is the way to go. if your tests fail at least chrome dev tools can help you debug.... would be nice to have testing in the terminal though. thanks!\n. ",
    "jhnns": "I'm currently using webpack to cope with different module styles like CommonJS and AMD. In combination with webpack-dev-server and the mocha-loader of webpack it's pretty easy to write JavaScript modules and get instantly feedback from the browser. You can check these tests for a live example.\nUnfortunately webpack doesn't support components yet, but maybe in the next few weeks.\n. Now he has written a plugin for components ^^.\nSorry, I just realized that it doesn't really answer your question. But it makes testing in the browser almost like testing in the terminal.\n. Why does requiring dependencies work differently than in node?\nIf dependencies would be installed like\ncomponents/\n     userA/\n          moduleA\n     userB/\n          moduleA\nand always required with require(\"userA/moduleA\") it would be easier to achieve a common codebase. Than all I would have to do is to add the components-folder to NODE_PATH (or am I getting it wrong?).\nI really like your idea of components and I understand your decision, to make components independent from npm. But I don't understand why this have to be different than in node. It just adds another fragmentation imho. \n. I totally agree. That's what I like about component. This also makes it easy to publish certain parts of your application open source without exposing app-specific stuff - because you write a modular app from the start. \nIt's also a good idea to decouple component from node in order to open it to other communities. But decoupling shouldn't mean separation. One great advantage of node is that it uses the same language as browsers. And I want to re-use certain components in both environments.\nWhether component will be the place for browser-only or common JavaScript modules - I think it's a good idea to adopt some conventions from the node community in order to improve interoperability.\nHowever, I do like the <user> / <project> convention :smiley_cat: \n. Nice license, exactly my style :grinning:\n. Things that can be used in both environments should be published to both package managers :smile: (like qs for instance).\n. In the end it's just convenience. If I'm running a node-only project and I want to use one specific module I'm glad I don't have to use two package managers.\n. Yep :+1: \n. component search model --extensions sounds nice.\nThe problem is: I will always search for plugins or extensions of a host module (thus using a noun). But the dependency should be kept in the plugin's component.json (thus using a verb). However, I think extensions and extends do fit well together. :+1: \n. > Alternative idea, they could go into the scripts section and we just parse anything that isn't a js file into a string.\nI like this one because it's simple but yet powerful.\n. \"Quick Start Make a Blog in 5 minutes with component\" - nice! WHERE is this tutorial??? :wink: \n. ",
    "bmcmahen": "I have a workflow that lets me run tests in phantomjs via grunt. I use grunt to watch my index.js and build it automatically. I then use mocha in browser-mode, including the build.js file, and exposing the component via the require('name/repo). I can then run my tests via grunt mocha. It works quite well. You can see it w/ a (more extensive) component I've been working on recently: https://github.com/bmcmahen/cast\n. i just ran into this issue too. Updating my npm seemed to fix it.\n. I'm definitely a bit confused by this as well. I'm often using something like component/swipe which has a dependency on an older version of component/emitter... and I tend to need the newest version of component/emitter elsewhere in my project. I specify the version, but it often seems to revert to installing the older version. \n. @visionmedia I hardly noticed it too, until recently when I was relying specifically on features of component/emitter-1.1.0. As more people start pegging properly (as opposed to the * that I usually use), I suspect this will become more of a problem. \n. agreed. i've had a number of enquiries about how to use my components (and thus, how to use component more generally), and it's a bit difficult to explain how to get started. having a really good introductory tutorial in the readme would be best, imo. \n. I wrote a rough first-draft on the Getting Started Wiki to help people understand how you would build your entire client-side app using Component. I see this as being complimentary to a more basic 'How to write a Component' tutorial that (as far as I know) needs to be written. Some feedback would be useful from those that know more than me ... i.e., @ianstormtaylor @visionmedia @anthonyshort @MatthewMueller \n. We should also have some basic guides to implementing build-on-change, rework, etc., into the building process. I imagine that we all do these things in our apps, but knowing how isn't exactly easy for a beginner.\n. I've definitely had some problems with this too -- and again, related to multiple versions of component/emitter. My only solution seems to be deleting the component in question, and then installing the specific version that I want. \n. +1 Saves from having to manually delete components/ upon failed install.\n. I like the idea -- I basically have my own watch/build system using rework and a few other plugins. But having component install in response to component.json changes would be pretty sweet. Even if not part of core, this would definitely be something I'd use... analogous to component test, etc... and I suspect it would make component much easier to use for beginners.\n. +1 these can be pretty difficult to debug.\n. Having used Duo a bit, it seems mostly backwards compatible... and it also seems much easier to use. Specifically, there is way less boilerplate, which is a big + for me. Definitely seems to combine the benefits of component with those of browserify. Still a few bugs with it right now, but that's understandable since it hasn't really been released yet :)\n. @stephenmathieson haha, yeah. just curious, that's all. ... and sick of writing component.json files everywhere.\n. I don't see duo as necessitating or encouraging less modular design by taking away 'locals'. In effect, it's simply taking the reference path -- the knowledge of the rest of your app -- from the component.json and putting it into your javascript require statements themselves. This has the benefit of increased explicitness... i.e., you are in fact using a local component, and not something from github.. and increased flexibility. It's a lot easier to organize your app in different ways now, with a lot less effort. \nI do wonder a bit about stylesheets now, though. You can't (unless I'm missing something) import the same stylesheet into multiple modules without significant code duplication. That is, if I want to have a module for my stylesheet variables which multiple components import, then my variables are contained within my code for every import. @MatthewMueller is this how it works? \n. @MatthewMueller ahah! Excellent. \n. ",
    "sindresorhus": "then why request it. keep out stuff that isn't needed. this for sure isn't.\n. There is a problem with Solarized and the color \"bright black\", which is made almost invisible. Just not use that color and you should be ok.\nhttps://github.com/altercation/solarized/issues/220\n. :+1: The npm link command is very useful. Having it in component will be too.\n. specify a version\n. --no-deps?\n. ",
    "edmellum": "Wasn't there an issue with some specific color themes making output unreadable? Another solution would be to just have a --no-color options and have people use grep to tweak the colors.\n. Wouldn't it be easier to use Testling CI? You can run it without Browserify with plain script tags. The only requirement is that the tests output TAP to console.log.\n. This could be fixed by using sourcemap instead of SourceURL since sourcemap doesn't require an eval. However sourcemaps aren't really supported that well in current debug tools so variables aren't mapped back properly.\n. Having source URLs behind a flag is nice for IE debugging too. Or maybe someone should make a builder that spits out <script> tags or something.\n. I've been thinking of looking at it. Should be real easy to do. Another solution would be to get an editor extension that checks for parser errors.\n. What are the pros of this compared to MIT? Don't see the point of churn if there's no benefit.\n. Take a look at component/calendar. It is one component with JS and structural styling. Then if you want a theme there is a separate component with the theme styling.\nMake theme components for every component and make some for things like typography and the like. Now you can mix and match different parts from different themes! You'll also only use whatever CSS you really need.\n. --out for both install and build is actually quite useful for writing integrations into existing apps and frameworks. However changing it so --out points to a directory that will then get a ./components directory is a change that wouldn't hurt the integration aspect and keeps the convention.\nI'd actually like to see a --in option too which would solve a bunch of headaches that comes with writing flexible integrations.\n. Show will that solve it? The issue here is installing after pegging to newer version than is already installed.\n. @visionmedia this really needs to get merged. Github is throwing all sorts of weird errors during install now.\n. I actually don't like this. CSS is different as it has to be, it's not supposed to be required. HTML templates are supposed to be required into JS which changes everything, compiling them down to JS is simple to understand and is universal to HTML, Handlebars, Markdown, etc. Having an html field is just more to understand.\n. Going for 10 to begin with and seeing if that fixes all the install issues for everyone seems like a good solution to me.\n. ",
    "matthiasg": "not sure i get this ... when i use uglify on a build.js i only minify the outer loader script of component.io, i.e. the require functionality. uglify does not minify the scripts inside of the require statements since they are just strings from the perspective of uglify... but minimizing has to run during the gathering phase of the component.io builder .. \nthats where https://github.com/Wizcorp/component-uglifyjs and other build step components come in .. just thought i should mention it here, in case others find this issue and think just passing the build.js in would be enough\n. Awesome .. It didn't know it did that .. I had thought dev would only add the source file names irrespective of the content...\nDoing it as part of the pipeline though might have the advantage of still knowing where a potential error originated from .\n but that's not really a good reason ... And it might not work anyway..\n-----Original Message-----\nFrom: \"Julian Gruber\" notifications@github.com\nSent: \u200e30.\u200e01.\u200e2014 09:38\nTo: \"component/component\" component@noreply.github.com\nCc: \"matthiasg\" mgt576@gmail.com\nSubject: Re: [component] Minify option on build (#50)\nYou should build without the --dev option then. See https://github.com/component/builder.js/blob/master/lib/plugins/commonjs.js#L65-L70\n\u2014\nReply to this email directly or view it on GitHub.\n. requiring an html as in require('./template.html') or require('./snippet.html') should just return a string in my opinion this is the easiest and most straightforward use-case. requiring a js would return an exports as is its now .. requiring an html would return a string (thats what it is at first) , requiring a .json could return a js object. \nand html templates could be listed in template: []\nif you want to have require a template return a function then precompile it during build into a js file, because thats what it is.  whether pre-compilation does get added in the builder later is beside the point here since neither html nor json etc would require it.\n. @visionmedia btw nothing happens auto-magically when requiring html, it just returns the file content as a string.  an added advantage is that the 'template/html' could theoretically also be put into the main build output and loaded dynamically if one wanted to.\n... auto-magically compiling templates, that sounds a lot like .coffee auto-compile in node (i like it, mostly, but its explicity added during startup of the program and not a feature of require per se and on the client side it would not make much sense due to cost involved). \nif someone wants to load handlebar and compile into a function, that is extremely easy (maybe it already exists), just make a handlebar component which uses require internally, then require the handlebar component and call something like handlebar('template.html') which uses require internally to first load it then compile it or return from cache.\nlimiting require to just js files and forcing html to go through an export function seems a lot more weird to me, and  i would assume also to normal web devs that are not quite so much into the node / require way of doing thing.\nif the word 'require' is an issue, then using a different word such as 'import' or 'load' etc for strings might make sense.\nenough said, shoot me out of the sky, am i off-base here ?\n. Great.. Btw i always thought that using require on a Js file that contains a\nhtml string is more of a special case treatment of html... And CSS is also\n'special cased' :)\n. Getting a dom instead of a string is the same as getting a function for a\ntemplate.. Its additional processing and should not be a native part ...imho\nIt can easily be wrapped as soon as component natively supports reading\ntext.\nSpeaking of which the function reading in the file does not necessarily\nneed to be called \"require\"...\nMy two cents\n. @yields  exactly ... require should import the referenced file. normally it returns a string. the only two native processing use cases i see are js and possibly json (since they are so closely related).... \nnormally i would expect the \"require\" a string to be the lowest level function which would always return a string and the \"require\" as we understand it from node.js would then parse this based on its extension into a js file according to module.exports logic. so require('test.js') would internally use e.g. load('test.js')\nthats why i had initially proposed to use another function name... but i dont really care one way or another.\nbut dom or template mechanisms should definitely not be part of it, domify could be any number of parsers or modules, same with templates based on extension, any number of parsers are e.g. mustache compliant... \nall those things can easily be wrapped as @yields showed. but none of them work if component does not have a simple way to require files as strings ;) its really a lowest common denominator and in-line with remove everything not necessary. \njust to emphasize my point. require() already uses that functionality internally. its about exposing that.\nplugins are not a solution i think, since we dont really need any plugins like that, not for processing templates or anything. it would just be code. just like npm does not have plugins for loading yaml files differently.  developers just wrap the call to fs.readFile ... but in component.js we dont have an equivalent for that. thats why we need it :)\n. ",
    "timoxley": "Can either of you give any guidance on a decent way to handle this? I'm doing stupid stuff like this in my makefile:\n``` make\nrelease: replace\n    @component build\nreplace:\n  @cat ./css/font-awesome.css | sed -e 's/..\\/font\\//..\\/components\\/timoxley-font-awesome\\/font\\//g' > ./release/font-awesome.css\n```\nThis, seems wrong.\nRelated tickets: #28, #11\n. @visionmedia I'll have a look into rework. If you couldn't tell, the use case here is an icon-font component. I was thinking about perhaps having the component inject the css into the dom so it could manipulate the paths dynamically\u2026 but then you lose cachability. Perhaps something along those lines might work.\n. :+1: :+1: \n. \u2026 and perhaps prompt for override?\n. Interesting, I'm on OSX as well and didn't experience this, so perhaps that narrows it to your editor as the source.\n. Awesome, did you figure out your issue?\n. :+1: \n. One thing that might be useful is having a single place for 'known' popular stuff like jquery/underscore/zepto/backbone, etc. If people are looking for those things, there's a good chance already know what they do thus don't need to be categorized to the same level of detail. My understanding is that we're trying to provide a viable alternative to such frameworks, so they  mostly exist for backwards compatibility reasons and should be isolated and shunned.\n. Yep cool, by 'a place' I did mean 'a category on the wiki'.\n. I've seen people struggle with this a few times\u2026 mainly because it diverges from npm's behaviour. \nPerhaps a user-friendly way to go would be to not punish the user for assuming npm's behaviour by having component install [names ...] do a component-create . if component.json doesn't exist.  And, rather than removing component install [names...], have it simply add dependencies to the component.json by default.\n. > I though it's cool to use the latest source without being afraid of breaking an app.\nGood in theory but doesn't work so well in practice. According to http://semver.org/:\n\nMajor version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable. \n\nNotice most (almost all?) components are in 0.y.x state, therefore semver is of little value for consumers of these apis.\n. hahahaha\n. haha nice work @avetisk, I believe the font is Arial.\n. also https://github.com/solutionio/async\n. Components already supports CoffeeScript. Just put\ncoffee -c index.js index.coffee \nin your Makefile.\n. Wow, I disagree with everything :D \n\ngit commit -a -m \"Release v1.0.0\"\n git tag -a -m \"v1.0.0\"\n git push\n git push --tags\n\nThis is basically git-extras release, use git-extras and never git push --tags again.\n\nuglify build/build.js > build/moduleName-v1.0.0.min.js\n minify build/build.css > build/moduleName-v1.0.0.min.css\n\nWhy not leave this step up to the component consumer? It's easy enough for developers to minify files themselves, should they wish to do so, and I'd typically do that in my deploy/build step anyway. Having unminified files is good during development.\n\nManually upload both files to github in the downloads section\n\nAgreed, this is a pain and if there's not already tool to do that from the command line, you should build one\u2026 (perhaps add it to https://github.com/defunkt/hub) but I don't see what this has to do with components at all.\n\nIt should then look for component.json and package.json and do all the magic as needed.\n\ncomponent(1) should know nothing about node, or npm\u2026 unnecessary coupling to the node ecosystem.\n\nIt should not use builder on the file unless -s is specified so that you can instead use\u2026  window.moduleName = moduleName;\n\nWhoa\u2026 IMO messing with the global namespace by shoving everything into window is part of the reason we're in this mess to begin with.  commonJS-style require is particularly clean, and I think if consumers need it in another format, they can component build -require-js-version themselves.\n\nI'd be all for steering clear of git as being too opinionated, if we hadn't already made the tool github dependant.\n\ncomponent(1) is only coupled to git+github insomuch as it's the default remote repository. component(1) uses http to download required files, not git, so you are free to define your own remotes which aren't github-based, so long as they follow the same url convention e.g. user/project/master/*. You could easily build your own CVS-backed server on top of PHP just so long as component files are served against that same url structure.\n. Bah. Your aversion to this probably means your workflow must be different but I really feel local development should supported 'out of the box' by just putting files in a particular folder and listing them in .local, without having to mess around with build scripts or shell environments.\nI guess I don't see what the downside is against selecting a decent default here, other than potentially having naming collisions\u2026 which is why I think something 'namespaced' like components.local might work good.\nNo default local dir means:\n- Modifying every build script to include the var prefix before each build command.\n- Inability to use component(1) directly on the commandline anymore without arduously typing out the prefix\n- Teaching every \"why aren't we using jquery\" developer on my team about this caveat, and either force them to add environment variables to their shell config (seems unnecessarily invasive), and ensure they know to always add the prefix every component(1) call\u2026\nAnother solution might be to specify the local dir in component.json OR an easily sharable ~/.components config, where you could also specify things like your github username (sets default username in component-create). \nAnyway, please reconsider. \n. Hm, time to what level of granularity? Days? Hours? Would you want to extract existing info up to this point, or just from now onward?\n. Interesting idea, though how would this take into account size and overlap of the dependencies? If your component is only 200 bytes of code but has 100 dependencies, that could mean many hundreds of kilobytes of additional code\u2026 but this wouldn't mean any additional code for dependencies if I'm already using those 100 deps in my codebase.\nAlso note as soon as you display any metric, people naturally feel it's important to 'get the most points' and turn it into a game. This could lead developers to writing more obfuscated code than they normally would in an effort to have the best compressing components (how valuable is that?), at the cost of readability/maintainability. A metric for useful, simple and maintainable is far more valable. Conveniently, the number of github stars for a project is a reasonable approximation of this metric, and is already visible.\n. > because it has nothing to do with how you write your code\nI was imagining people going demoscene style, where they write code optimised for the compression algorithm, but perhaps that's far-fetched\u2026\nHm, if the size of dependencies isn't counted, it could actually encourage people to seek out and use dependencies rather than fattening their codebases with duplicated functionality, which is a positive\u2026 more code reuse and more separation of concerns.\n. Good point. Something similar to the component.io idea can be found over at http://microjs.com/\nThey list the watchers (stars?) forks, sizes in kb, and tweets(!). Looking at that, I agree, the size definitely influences how complex a lib appears to be.\n. Locals won't ever need versioning because component doesn't need to resolve anything\u2026 it can safely use whatever component you've placed in the local_component_path/reponame folder. If your use case does require versioning, then it probably makes more sense to set up a local component server and use .remotes.\n. Also, locals != private components\u2026 just local components. It may make sense to even check them into the parent component repo. Again, .remotes is more suited for 'private' components.\n. Ahhh, that's possible. I d assumed dynamic would be cool due to the way Travis CI badges work, perhaps Travis works because caches are flushed on push (I guess?). In that case you could change it to \"230+ available\" so the number would at least be right at push time, but then having each component reporting different numbers would look more like the value was just random...\nWay to be a wet blanket by bringing reality into the discussion... I hate that guy :D\n. Good detective work. I had a brief look for some documentation on this feature but came up dry. \n. Whoo. Nice one guys.\n. > 162 including ones like \"jade\" \nThere's 53 (54 minus first line)\njs\n$ npm ls | wc -l\n      54\nWhat your seeing is npm's logging of requests it's sending and the http response codes it gets back, e.g.\nnpm http GET https://registry.npmjs.org/commander/0.6.1\nnpm http GET https://registry.npmjs.org/growl\n...\nnpm http 304 https://registry.npmjs.org/commander/0.6.1\nnpm http 200 https://registry.npmjs.org/growl\nStill, jade does seem out of place\u2026 npm ls will explain why:\n$ npm ls\n/Users/timoxley/Projects/testing/component\n\u2514\u2500\u252c component@0.9.0\n  \u251c\u2500\u252c batch@0.2.0\n  \u2502 \u251c\u2500\u252c mocha@1.7.0\n  \u2502 \u2502 \u251c\u2500\u2500 commander@0.6.1\n  \u2502 \u2502 \u251c\u2500\u2500 diff@1.0.2\n  \u2502 \u2502 \u251c\u2500\u2500 growl@1.6.1\n  \u2502 \u2502 \u251c\u2500\u252c jade@0.26.3\n  \u2502 \u2502 \u2502 \u2514\u2500\u2500 mkdirp@0.3.0\n  \u2502 \u2502 \u251c\u2500\u2500 mkdirp@0.3.3\n  \u2502 \u2502 \u2514\u2500\u2500 ms@0.3.0\n  \u2502 \u2514\u2500\u2500 should@1.2.1\n  \u251c\u2500\u252c commander@1.0.5\n  \u2502 \u2514\u2500\u2500 keypress@0.1.0\n  \u251c\u2500\u252c component-builder@0.4.2\n  \u2502 \u251c\u2500\u252c batch@0.1.1\n  \u2502 \u2502 \u251c\u2500\u252c mocha@1.7.0\n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 commander@0.6.1\n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 diff@1.0.2\n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 growl@1.6.1\n  \u2502 \u2502 \u2502 \u251c\u2500\u252c jade@0.26.3\n  \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 mkdirp@0.3.0\n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 mkdirp@0.3.3\n  \u2502 \u2502 \u2502 \u2514\u2500\u2500 ms@0.3.0\n  \u2502 \u2502 \u2514\u2500\u2500 should@1.2.1\n  \u2502 \u251c\u2500\u252c better-assert@0.1.0\n  \u2502 \u2502 \u2514\u2500\u2500 callsite@0.0.2\n  \u2502 \u251c\u2500\u2500 component-require@0.1.0\n  \u2502 \u2514\u2500\u252c rework@0.7.0\n  \u2502   \u251c\u2500\u252c commander@1.0.4\n  \u2502   \u2502 \u2514\u2500\u2500 keypress@0.1.0\n  \u2502   \u2514\u2500\u252c css@1.0.5\n  \u2502     \u251c\u2500\u2500 css-parse@1.0.4\n  \u2502     \u2514\u2500\u2500 css-stringify@1.0.3\n  \u251c\u2500\u2500 debug@0.7.0\n  \u251c\u2500\u252c jog@0.4.0\n  \u2502 \u251c\u2500\u2500 commander@0.5.2\n  \u2502 \u251c\u2500\u2500 ms@0.1.0\n  \u2502 \u2514\u2500\u2500 redis@0.7.1\n  \u251c\u2500\u2500 mkdirp@0.3.4\n  \u251c\u2500\u2500 string-to-js@0.0.1\n  \u251c\u2500\u252c superagent@0.9.3\n  \u2502 \u251c\u2500\u2500 cookiejar@1.3.0\n  \u2502 \u251c\u2500\u2500 emitter-component@0.0.5\n  \u2502 \u251c\u2500\u2500 formidable@1.0.9\n  \u2502 \u251c\u2500\u2500 methods@0.0.1\n  \u2502 \u251c\u2500\u2500 mime@1.2.5\n  \u2502 \u2514\u2500\u2500 qs@0.4.2\n  \u251c\u2500\u252c term-css@1.0.0\n  \u2502 \u2514\u2500\u252c css@1.0.1\n  \u2502   \u251c\u2500\u2500 css-parse@1.0.1\n  \u2502   \u2514\u2500\u2500 css-stringify@1.0.1\n  \u2514\u2500\u2500 win-spawn@0.0.0\njade comes in because mocha is a dependency of batch\u2026 which is probably a mistake since mocha is a testing tool\u2026 and it looks worse since batch is depended on twice.\n. Only other small nitpick is if some of the packages used the same versions you could get more 304 cache hits e.g. \n\u2502   \u2514\u2500\u252c css@1.0.5\n  \u2502     \u251c\u2500\u2500 css-parse@1.0.4\n  \u2502     \u2514\u2500\u2500 css-stringify@1.0.3\nV.S.\n  \u2502 \u2514\u2500\u252c css@1.0.1\n  \u2502   \u251c\u2500\u2500 css-parse@1.0.1\n  \u2502   \u2514\u2500\u2500 css-stringify@1.0.1\nBut thankfully using node means this kind of stuff doesn't really matter at all\u2026 except when waiting for a bunch of crap to install.\n. I don't think it's a good idea to do this as a temporary thing, since then you will end up with inconsistent readmes.\n. > so many people stumble upon all the sweet components and are just like dafuq? really nags me.\nExactly.\nI too was thinking automated PR, my hesitation about this PR is that an automated 'add logo/link to readme' bot might be trickier to do safely if it needs to first delete the existing link (generated in this PR, that people may have modified for whatever reason) and then add a new one. Maybe not though.\n. I'd also consider removing the \"github as a registry section\", and replacing it with a \"Publishing a Component\" section after \"Creating a Component\", but I'll leave the wording of that up to you.\n. Also possible it'd be better to just do this kind of thing in a Makefile\n. Use Case:\nRequire the package's component.json to extract the version key. How would you do this otherwise?\n. I was using the version number for cache busting some dynamically loaded component assets, though there might be a better way to do that, perhaps during the build step\n. Looks like they're shutting down, so likely it won't matter:\n\nAlert: We hope you've enjoyed sharing your stories via real-time video. Regretfully, the app will no longer be available after 12/31/2012. \n\nhttp://www.geekosystem.com/color-shuts-down/ lol @ $41 million.\n. Perhaps in dev mode you should be able to require any script in any folder, but if you want to make your component consumable by other components, you've got to list the files out. This allows people to build their monoliths but discourages them from sharing them. Though this limitation may not be obvious and people might end up listing broken modules on the wiki. Dunno, but it is a pain to constantly update the component.json when you are just experimenting, don't know exactly what you're building and how exactly you're going to go about modularizing it just yet.\n. +1 more examples. Would be good to see examples from people other than tj\u2026 hint hint\n. +1\n. Yeah didn't help very much :( Also ran it in debug mode with no further insight. \n. Actually, i've been messing with symlinks\u2026 possible I've got a stray one around somewhere that's confusing the builder\n. --verbose could simply turn on the env var DEBUG=component*?\n. Why not just issue a PR?\n. Whoo\n. you probably just want to do something like call b.init() after requiring it on each page. Remember, component isn't really a script loader.\n. Alternatively you could have a core set of functionality and simply load additional components on the pages they're required via <script> tags, though you'll need the init() call in this case anyway. At this point, I believe component is forsaking \"memory efficiency\", for simplicity, since in most (all?) cases memory consumption will never be an issue (how big are your components?!). Perhaps later it will do dynamically loaded components, but that's not a driving factor in its design AFAIK.\n. Yeah that's probably the best solution if you're going to insist on using component in that manner.\nrequiring a module, generally, shouldn't have side effects other than returning you an object (or function) for the caller to invoke, otherwise you end up having to do hacky stuff like this.\ne.g.\njs\n// do-stuff.js module\nmodule.exports = function() {\n   // init do-stuff.js\n}\nthen\nhtml\n  <script src=\"../build/build.js\"></script>\n  <script>\n    var doStuff = require(\"do-stuff\")\n    doStuff();\n  </script>\n</body>\nThis gives you absolute control over when doStuff() is called, rather than relying on the require call to initialise things.\nI probably wouldn't include any <script> tags in the content you're returning with ajax\u2026 keep your html and your JS separate. Cache the page content somewhere. If you already have the page\u2026 then grab it from the cache and run the init() call, otherwise, load it via ajax, and then run the init() call. All your page JS should already be loaded. Keep things simple man, make it work optimise (much) later.\n. Check the FAQ\n. Have you seen https://github.com/component/todo?\n. I wonder if it's an option to just parse the AST and reassign globals to module.exports during the build process\n. yep, it does, but doesn't seem to work if there's a syntax error.\n. browserify seems to parse your code before it will successfully build it, I wonder if component could/should do something similar\n. @visionmedia can you just put up an auto-generated gh-pages branch? It's got to be better than a 502.\nedit: this is what defaults look like: http://timoxley.github.com/component/ definitely better than 502.\n. @visionmedia Hm. I was doing something like this in my app's Makefile, for each local component:\nmake\nlocal/stuff:\n  $(MAKE) -C local/stuff\nmainly so the local component is in a position it can be easily abstracted out and I don't need to have instructions on how to build each local component in the main Makefile. So how do you guys handle this?\n. works in iterm2.\n. I'm interested in what @visionmedia thinks of this\n. perhaps this is ok because it doesn't break anything now, and go deal with that versioning crap when we get to it\n. temporary solution is to bump up your ulimit\n. @leostera component create?\n. @webpro I'm interested in what you're doing instead of using built-in require\n. -1 article behind registration wall: \"THIS IS A PREVIEW. DOWNLOAD APRIL 2013'S ISSUE TO READ THE FULL ARTICLE.\"\n. -1 registration broken: \"Unable to send e-mail. Contact the site administrator if the problem persists.\"\n. Though probably good practice to link to these things when they pop up, since they'll be hard to track down later due to googlability of \"component\". Perhaps should start a wiki or add them to Building-better-components\n. url makes more sense. or even a script. In some cases you may not have the bother to set up/host a demo online, but a demo could be easily buildable.  default script could perhaps do something like, build, boot a http server then open browser to localhost/myexample, or if you have it hosted then simply open http://github.io/.../demo.\n-1 for gh-pages/branch magic though, sorry @yields \n. but what are \"plugins\"? how do they differ from \"components\" i.e. \"dependencies\"\n. -1 augments. peer is fine. parent, host etc is fine.\n\"dependencies\" is a noun. \"description\" is a noun. Every other key is a noun. +1 nouns.\n. +1 strings for flexibility. Parsing to DOM immediately is making far too many assumptions about how I work.\n. Rationale is described in detail here: http://tjholowaychuk.com/post/27984551477/components\n\nwhat the advantages of this framework are compared to say Ruby on Rails or just writing plain HTML, CSS and JS\n\nthis really isn't anything to do with Rails, it's specifically for packaging/distributing front-end code.\nThe problem with vanilla HTML/CSS/JS is that they don't compose on their own, thus we typically write spaghetti or  have to lean on frameworks like backbone/ember/angular. \nThe problem with these frameworks is they:\n- Create technology silos and duplicated effort by being generally incompatible. Frameworks serve no-one but themselves.\n- Stifle innovation by tightly coupling components across too many concerns. It's often hard to swap pieces out or use pieces in isolation.\n- Add complexity and an unnecessary _re_learning curve through deep abstractions. KISS\n- Require a heavy investment that is hard to undo. Changing framework usually equates a rewrite.\n- Don't offer much long term value. When a framework dies, so does its ecosystem. \n- Frameworks are going in and out of fashion more and more frequently. 6 months from now there'll be a whole new framework landscape. Are you going to rewrite your app?\nComponents is an effort to solve all of the above problems by providing a way to easily create and consume many small, loosely coupled, reusable components. It's not perfect yet, there's a long way to go but its head is in the right place.\nI envisage future frameworks becoming \"distributions\" of components. Thus, if a framework improves a common component, all frameworks benefit, even though their approach may be radically different. With frameworks, only the framework clique wins. With components everyone wins.\nYMMV.\n. @thirdreplicator the point is to just add the minimum necessary overhead to make html/css/js composable. If you can think of a way to get around using require and a build tool while keeping the modules clean and isolated, those ideas would be interesting. Until there's something better, it seems a pretty safe choice to closely emulate the mechanism that powers node/npm, which has a particularly successful modular ecosystem.\n. @ericgj planning in open source projects doesn't generally work\u2026 the only way is to JFDI\n. Component's format is far more succinct, how about rather than requiring everyone to agree, we just write wrappers to convert one to the other? e.g. browserify  -> component but the other way around\n. I wonder if defaults functionality could be added directly to commander.js.\n. Also, no tests because there were no tests for component-create. you know, broken windows and all that. I could knock some up I guess.\n. bump\n. ahh you could tap into the github config inheritance thing using git config github.user, but would require an async call to child_process.exec, which makes the code more ugly as everything else in here is sync\u2026\n. so it turns out new streams were rolled out in node 0.9.4, I believe it's another compatibility problem with streams/superagent similar to #364 \n. Ok, so it's a streams issue and it's something to do with the way the superagent requests are being piped in Package.js.\nSpecifically, if I change this code from \njs\nreq.end(function(res){\n  if (res.error) return done(error(res, url));\n  res.pipe(fs.createWriteStream(dst));\n  res.on('error', done);\n  res.on('end', done);\n});\nto\njs\nreq.pipe(fs.createWriteStream(dst));\nreq.on('end', done)\nreq.on('error', done)\nit appears to work on both node 0.10.5 and node 0.8.25.\nNot sure if I'm dropping some error handling there though, should probably check for errors on the fs.createWriteStream\n. lol @ component only being able to install this between node 0.9.4 and 0.9.10, any higher I get the \"cannot switch to old mode\" ala #364, any lower it doesn't install all the data hahah \n. more info: so, while the change I describe above installs all the fonts correctly, it also breaks the tests\u2026 \"complete\" is never printed, which means the package's \"end\" event is never called\u2026 turns out the batch around the installation never actually ends\u2026 it's like it's silently dying somehow or perhaps somehow running to completion. Ugh.\n. Here's a failing test I've adapted from the existing install tests:\njs\n    it('should install dependencies.', function(done){\n      exec('bin/component install --verbose timoxley/font-awesome@3.2.1', function(err, stdout, stderr){\n        if (err) return done(err);\n        var stats = fs.statSync(path.resolve('components/timoxley-font-awesome/font/fontawesome-webfont.woff'))\n        stats.size.should.equal(43572)\n        stdout.should.include('install');\n        stdout.should.include('complete');\n        done();\n      })\n    })\n. @visionmedia this should work (at least the tests pass) so long as you merge/release https://github.com/visionmedia/superagent/pull/239\nand bump the superagent version in component/component.\nTested on node:\n- 0.8.22\n- 0.8.25\n- 0.10.5\n- 0.10.12\n. I just tried this on OSX, node 0.10.2, component 0.16.6:\n```\nmkdir test-install && cd test-install\ncomponent create --local .\ncomponent install component/format-parser\ncomponent build\ncat build/build.js\ncomponent build --dev\ncat build/build.js\n```\nAnd the output looks totally fine. Looks like an issue with these tools running on window 7.\n. my bad, component@latest isn't 0.16.6 yet, reproduced. Looks like files aren't being unzipped, I think I know where the problem is. \n. > if reduction is pass, should be no decompression.\nsorry, can you rephrase?\nThe bug seems to be that superagent doesn't unzip when using pipe\n. Here's a test case: \njs\n    it('should unzip files', function(done){\n      exec('bin/component install component/format-parser@0.0.2', function(err, stdout, stderr){\n        if (err) return done(err);\n        var content = fs.readFileSync(path.resolve('components/component-format-parser/index.js'), 'utf8')\n        content.should.include('function') // make sure it unzipped\n        stdout.should.include('install');\n        stdout.should.include('complete');\n        done();\n      })\n    })\n. @chemzqm @domachine try 0.16.5\n. I'd +1 an alias from component init to component create, and a better error message.\n. I don't believe the categories are \"locked\" or even thought out very much\u2026 if you see something that could be categorized better, just go ahead and move it, it's a wiki. If you want more categories, create them. Add more keywords to repos if you find stuff that needs more keywords. It's all open so just go for it?\n. duplicate of #226\nSolution: just turn off --dev.\n. Would be good if this was written by/for someone with little node experience.\n. auto-require is bleh. how about \"entry\" or \"start\", i.e. describe what its purpose/responsibility is, not the mechanism\n. /me welcomes everyone to the new bikeshed\n. if this is a good idea, ideally it'd be implemented as just a case-insensitive regex for /^readme/ over all files in the dir.\n. readdirSync doesn't take a callback :)\n. @anthonyshort you won't notice semver when it's working.\nYou also won't notice semver when components are small enough that the interface will rarely need to change. But imagine if express didn't use semver and tried to do something drastic like swap the order of arguments to res.send.  many gifs would be posted.\n. @TooTallNate also note according to semver:\n\nMajor version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable.\n. Perhaps just rename the components folder at the end of your build?\n. > This wiki is deprecated. Please make PRs to http://github.com/component/guide instead!\n\nWow, I did not see that.\n. Added a big \"deprecated\" to main wiki page.\nhttps://github.com/component/component/wiki\n. @darsain just fyi you can get these in browserify with: https://github.com/hughsk/envify and https://github.com/hughsk/remove-catch-require/https://github.com/hughsk/remove-try-require\n. i.e. the makefile is just a scaffold. TJ, perhaps the ability to define your own scaffolds would solve these types of issues.\n. ",
    "shaw-bluezinc": "@timoxley @visionmedia \nFinding that building a component referencing FontAwesome on windows is causing a problem which I think relates to this.\nThe result is:\n@font-face {\n   font-family: \"FontAwesome\";\n   src: url(\"\\timoxley-font-awesome\\font\\fontawesome-webfont.eot\");\n   src: url(\"\\timoxley-font-awesome\\font\\fontawesome-webfont.eot?#iefix\") format('eot'), url(\"\\timoxley-font-awesome\\font\\fontawesome-webfont.woff\") format('woff'), url(\"\\timoxley-font-awesome\\font\\fontawesome-webfont.ttf\") format('truetype'), url(\"\\timoxley-font-awesome\\font\\fontawesome-webfont.svg#FontAwesome\") format('svg');\n   font-weight: normal;\n   font-style: normal;\n }\nNote that \\t is a tab character so the escaping isn't working right, however, even so, I'm not convinced a backslash for a css url is ever appropriate - even on windows?\nThanks\n. ",
    "godfryd": "Well, I just read the component spec. It is GitHub centric. So it sounds like other repositories/registries are not considered or even excluded from the component idea.\n. ",
    "gjohnson": "Cool... Yeah, the child_process stuff changed so much from 0.6 to 0.8... it's annoying. LOTS of people still using 0.6.x though. We could drop the hackity hack and use pipe() again or something... It is pretty ghetto lol.\n. @juliangruber it is lame indeed, however it is a valid package name and it's not forced or anything. If someone wants a lame standalone name, then the burden is on them. I think the consistency between require('...') and window['...'] is more important.\n. Opps haha, I didn't even realize --standalone took an optional name. I will leave the PR open so we can resolve something to not generate errors for dummies like me. :-)\n. Awesome!\n. +1 to having the path within the local value. dependencies, remote, etc. are self contained, so seems like it would fit in nicely for it to behave that way too and just toss out the paths confusion.\n. Hmmm dig it... Though I think you mistakenly left off username/project, what if that played a role too? Meaning the lack of a username implied the component should be resolved locally. Meh?\n. This way, if I want to use component create for local components, I wouldn't HAVE to put in a username for something that it didn't really need it.\n. Since the ambiguity is around the key, why not make all the rules around it. IMO, the following rule(s) seem sane and like @karlbohlmark said, its very clear by the value where the component is coming from:\n- if key contains \"/\"?\n  - download from default remote of github.\n- else\n  - if value is remote? (matches git, http, whatever remote transports we support)\n    - download using matched transport.\n  - if value is local path?\n    - if value is within parent directory\n      - leave alone.\n    - if value is outside parent directory\n      - copy over.\njs\n{\n  dependencies: {\n    \"redventures/pixel\": \"0.0.1\"\n    \"pixel\": \"git@github.com:redventures/pixel#0.0.1\",\n    \"pixel\": \"./lib/path/to/pixel\",\n    \"pixel\": \"/some/random-ass/directory/not-sure-why-anyone-might-do-this/but-maybe\"\n  }\n}\n. @visionmedia is there actually a use case for needing just a nested component? In your example, I can't see why one would require user/view instead of user. I think the rule of thumb should be if you find yourself saying \"nested\" in front of your component... it should probably be its own component, especially if you need to require it outside the parent context.\n. Just hurt here. :-)\n. Related: http://developer.chrome.com/extensions/sandboxingEval.html\n. There is a google group, if you want to go ahead and copy the question over there, I (and others) can help you out.\nhttps://groups.google.com/group/componentjs\n. http://nodejsreactions.tumblr.com/post/51550909419/waiting-for-tj-to-deal-with-a-pull-request\n. Maybe just write an extension to automate it a bit? Something like:\nsh\n$ component wrap --name html5shiv --script https://raw2.github.com/aFarkas/html5shiv/master/dist/html5shiv.js\n. ",
    "donpark": "I understand that. What I am really asking is whether there is a mechanism that covers what I consider a very common situation which is a component user wanting to install the latest stable release installed without a) waiting for component maintainer to update, or b) create another component/fork.\n. Oh well. Thx for the answer, Julian.\n. @visionmedia TJ, your optimism is impressive but seems to me this is just swapping one set of chores for another.\nIn most situations, I think a component definition only needs to be a recipe describing where and how to get the parts making up a component, meaning it doesn't need to fork the source nor require it to be a git repo.\n. \n. Bigger problem is component user is dead in the water until Github fixes the problem. What's the Plan B? :-)\n. Yes. Component is too good to be lamed by Github.\nLooks like engine.io-client repo is back up and so is my build. Excellent.\n. ",
    "kelonye": "Hmm, want to integrate this with https://github.com/livingsocial/rake-pipeline\n. You mean remove it from builds? Just remove it from dependencies prop.\n. - coffeescript support\n. @enyo :smiley: , hoping he'll give in to the pressure.\n. also, directory file discovery e.g. \"scripts\": [\"/directory/**\"], e.g. when building an ember/backbone app, do I have to list all 20+ scripts?\n. @visionmedia, great :thumbsup: \n. still waiting on the app, :smile: \n. \"paths\": [\"client\"] :)\n. +100 :cry:\n. i too have to resolve the symlinks manually before deploying in production\n. Hm,\nproduction: build\n    for sym in $(shell find $< -lname \"*\"); do\\\n        orig=`readlink $$sym`;\\\n        rm $$sym;\\\n        cp $$orig $$sym;\\\n    done\n. same here\n. yeah, i also downgraded to 0.16.4\n. All components\n. Great, hope @visionmedia refines this.\n. ",
    "clintwood": "@visionmedia, for pull request #181 (component-link(1), component-unlink(1)) I copied functions report(1) and install(1) from component-install(1).  In there is a note to you for a possible refactoring of these functions to a js file in lib to prevent dup code...\nNow's your chance! :o)\nBTW, I've use this link (symlink) functionality extensively in my workflow... it allows me to work on several components simultaneously without having to do multiple tiny pushes for tweaks on dependent components.  When I'm happy with the changes across several components I push them all to our internal git server and unlink them...\n. For my workflow the attraction of a symlink is that it helps reduce the number of pushes to git.  We are working on a large project with many components in the boiling pot and pushing every little change on each dependent component to a local or remote repo would clutter the repos unnecessarily...\nAlso the symlink mechanism allows me to go to the directory of /components/ and directly tweak the dependent component.  Then retest by rerunning mocha tests (which rebuilds etc.)...\nAgreed, running component-unlink(1) may be a pain but on my windows platform I just delete the components directory (or a specific components/component_to_unlink folder) and it reverts to the repo based component scheme on next test/build...\nWould implicit remotes behave the same, i.e. reduce the noise in repos, etc.? \n. @stagas, your solution looks like it is quite similar in end result. One thing with link/unlink is that you have complete control on which components are linked and which are from the origin repo. You don't have to tweak remotes in the component.json in both solutions which I think is cool. The only thing is an env var seems like it would be an all or nothing switch between origin repo or local source. Can this be made selective? Last thing, I have components in different locations on local disk so I like to be able to link in a component from wherever without being forced into some rigid source location...\n. This would be nice... How would you foresee disambiguating the require('comp_name') for dup components?\n. Ok, that helps me big time... thanks\n. This is becoming a problem for me... unless I'm not understanding something.\nI have two components that depend on different versions of the same component say component/tip. \ne.g. componentA depends on component-tip (0.0.2) and componentB that depends on component-tip (0.0.4).\nI get an undefined behaviour as to which component gets installed to the components/... directory.\nThis breaks either componentA or componentB...\n@visionmedia, what is your thinking on a solution for this and what is required to fix this... perhaps:\n\\components\n  \\component-tip        <-- implies master or latest\n  \\component-tip-0.0.2  <-- version 0.0.2\n  \\component-tip-0.0.4  <-- version 0.0.4\nThat's one issue.\nFrom your comments above will the aliases deal with the ambiguity on a per component basis?  It looks like the aliases may need a version number too!? \n. I'll see if I can take a look at this...\n. +1, Our co would like to wholeheartedly adopt TJ's awesome component mechanism and for that we need some of our components in a private repository.\n. Umm... no... will try and post back!\n. Nope!  Firstly I just tried on a public Github account to eliminate auth for now...\n...with component-create I entered  myrepo/ctest/models as the repo and it built a component.json with \n \"repo\": \"myrepo/ctest/models\",\nthen it failed like so: \nC:\\Users\\DevUser\\AppData\\Roaming\\npm\\node_modules\\component\\bin\\component-create:65\n  if (2 != repo.length) throw new Error('repo must be <username>/<project>');\nI manually pushed a folder called 'modles' to github  so the repo was something like \nhttps://github.com/myrepo/ctest/master/models when in the models folder and \n...with \"myrepo/ctest/models\" : \"*\" in the dependencies of another component.json the \n'component-install' says: \n       error : failed to fetch https://raw.github.com/myrepo/ctest/models/master/component.json, got 404 \"Not Found\"\nwhat github expects if I go there and click raw is:\nhttps://raw.github.com/myrepo/ctest/master/models/component.json \n'master is in a different place in the url generated by component-install.\nPerhaps the pattern for dependencies should be:\njavascript\n\"dependencies\": {\n    \"component/emitter\": \"*\",\n    \"component/jquery\": \"*\",\n    \"myrepo/ctest:models\": \"*\"\n  }\nwhere a ':' denotes the start of a path into the 'myrepo/ctest' repository...\nthen this would build a url replacing ':' with '/master/' (or some other branch name).\nJust a thought! \n(I may fork and try make it work... if I get time!)\n. True multiple projects in the same repo is not what this component manager is trying to encourage... and that is agreed... but it may make sense to have logical groupings of components. So what I am proposing is an optional way to provide a logical grouping of components within a component repository.\nThis has a number of benefits, \n- provides a way to minimise the number of repositories when using private repositories,\n- allows component contributors to logically group components with similar functionality,\n- helps consolidate documentation for components suites, etc. \ne.g.:\njavascript\n\"dependencies\": {\n    \"component/data-modeling:path-to-regexp\": *,\n    \"component/data-modeling:model\": *,\n    \"component/data-modeling:davis.js\": *,\n    \"jquery/core\": \"*\",\n    \"jquery/css:<css related components>\": \"*\",\n    \"jquery/data:<data related components>\": \"*\",\n    ...\n  },\nSo I'm new to the component manager and I'm not sure what impact this idea will have and I see the danger of grouping may be an anti-pattern for this effort, however, it would solve the repository proliferation problem (for my project anyway).\n. Aha, local will work for me... that keeps things simple and clean I guess, thanks!\n. Take a look at this pull request, works 100% for me and also see the added component link and component unlink commands, they are extremely useful IMHO!\n. This doesn't really fix the problem or difference between Windows and Linuxy platforms...\nOn windows you have to add the dash between component and its sub-command:\ne.g. on Windows component-build instead of component build on Linuxy platform.\nThis is not a solution since most if not all makefiles use the latter, Linuxy, form (without the dash/hyphen). This is fixed in this pull request though...\n@visionmedia I should have kept the two pull request separate but through sheer noobness on the git front I somehow merged the two together...\n. It does indeed!  Awesome!\nIt looks like the only package.json \"bin\": {...} entry that is required is \"component\": \"bin/component\" unless I've misunderstood why the other entries are there.\nI havre reverted the specific changes in my pull request in lieu of the changes in win-spawn to win-fork (which is a better place for the fix anyways).\n. Been a long day... the mouse has got a life of it's own...\n. With my noobness for Linux, I think I've go this to work on that platform...\n. Great!  There is some copy and paste with respect to 'report' and 'install' functions (see line 144 of bin/component-link) borrowed from bin/component-install which could/should be shared (as an external js file) between the two.  Not sure what you want to do here (or what your general policy on this is).\n. On Windows, we've had a problem with relative symlinks due to a bug in fs.js (see joyent/node#3879) with versions of node earlier than v0.8.7.  This caused component-link(1) to fail with 'EINVAL symlink'.\nTo fix: Either update node to a release > v0.8.7 or use an absolute target path.\nEnjoy!\n. I'll be updating this shortly... thanks for the interest!\n. Hey, TJ, how would you propose this functionality gets integrated with component in a way that does not add to it's core (since you feel it is too much for core)...\nAs I've mentioned before we use component not only in the UI context but also at the systems level where we build functional components with their own dependency hierarchies.  Yes, we use the linking 'feature' mainly in the dev cycle and that is probably where it should live... Could this be integrated as a dev only feature perhaps so as not to pollute the core, if so how???\n. @anthonyshort, it is very useful indeed!\nOh crap... I pushed some changes for the link / unlink pull request and it closed the pull request.\nI deleted the 'link' branch having merged it into master...\nThe good news is that link / unlink is in master which is on pull request: Solution for Issue #138 (Issue with Windows)\nUpdating pull request title!\n. +1 and how would you disambiguate the require(...) of this specific 'branch' or version if you also had the master branch used in the same project.  Like in npm a project can have two modules that use different versions/branches of the same module.  Is this even supported in component?\n. @MatthewMueller +1 here too... this is killing me!  I'm wrapping to sync the names and that is not cool!\n. @jonathanong, agreed that pushing every little change during early dev cycle is lame esp. when cross-component integration is being tested.  Take a look at #181, this will solve your problem asap.\nAlso, I've recently added (see #181) a --targets [file] option which allows you to specify a text file of local component targets that you want to symlink (the default being a file called .symlinks in your component folder). This avoids changing the makefile for changes to what you symlink.\nI'm considering modifying the component makefile to include targets for link and unlink... they will be ignored if a .symlinks file is not present...\n. Agreed, I think both solutions are hacky... I guess the limitation of both hacks is that local var's to Package.js introduces concerns for using Package(...) beyond a short process lifetime.\nI also observed good performance gains... would be good to have a better fix down the line but I think the inflight responsibility needs to live outside of Package.js.  Maybe an inflight callback that can be passed into Package(...) and that will be called to test if the package should be installed or not...\n. @jonathanong, I'm wondering if this is not because of this issue component/builder2.js#29. I know the issue was raised for CSS but the root cause is possibly generator related?\n@simonsmith, I'm wondering if the command line version on your platform eliminates using generators (node --harmony-generators) and therefore uses the non-generator code path... whereas your API version maybe uses a generator based code path? If so it make the above issue more likely the cause...\n. +1 for making this optional... on the fence about what the default should be - perhaps make the default the current behavior to avoid confusion.\n@jonathanong, ok so it's another option, is that really an issue?\n. --no-auto is not the most elegant but it does default component build's behavior as it currently is.\nSo for those of us whinging for this option LGTM!\n. @andreasgrimm, I think this is the same issue (component/resolver.js#17) I had and which led back to component/resolver.js.  It's been fixed in version 1.1.4 but it's not yet sync'd with npmjs registry...\nCould you try referencing 1.1.4 directly in your package.json (for now) to confirm that it fixes your issue? e.g.: dependencies: {\"component-resolver\": \"component/resolver.js#1.1.4\"}\nI'm not sure about my permissions for publishing to npmjs.org, @dominicbarnes, @jonathanong? ...\n. component/resolver.js#17 was the root cause in my case... personally I like to require local components like so require('./path/to/component')... It would be great if node.js only used the / separator and did the translation under the covers... but meh!\n. @andreasgrimm, No you not doing anything wrong and yes in the component/component/package.json, but the problem is that component-resolver on npmjs.org is also published with a build folder with output from regenerator. This is what is causing your error in your custom install.\n~~As a hacky workaround to get you going (on Windows)  until component/resolver.js gets republished (see above) you can use \"component-resolver\": \"clintwood/resolver.js#hack\" in component/component/package.json in your cloned component/component repo as before the do npm install -g . from the cloned repo.~~\n. This should be resolved now, see component/resolver.js#20.\n. @visionmedia, @jonathanong,  A road-map of sorts would be great... the die-off/fragmentation of component is becoming obvious and a concern for myself and others I would assume...  The fact that component.io site (apart from being up and down) doesn't really 'sell' the concept of component to one, I believe, makes the would be component user move on to something else leaving to die quietly.  The core concept of moving away from monolithic libs like jQuery is what brought me to component but I have found it hard work to select components and perhaps this is due to the lack of an informative repository...\n. Right now what component gives me is require(...) with all it's boilerplate namespacing and component identity (user/component#ver) what could/would be great is a well orchestrated repository/package manager that really sells the concept... So for Duo I'd suggest that the presentation and marketing needs to be a very high priority so that it gets good traction... With good traction comes better community support and energy in general... BTW (@visionmedia, @jonathanong and component friends), your efforts are really appreciated :) thanks...\n. Woha... @visionmedia... with all your contributions... you should never ever feel bad... Anyhow, for Duo, if it becomes a thing, we need marketing angle that makes it stick!\n. @timaschew, I share your concerns and for me these concerns are growing...\n@MatthewMueller, our company has made a strategic choice to depend heavily on component... we are in early development of 3 systems that form the core of our business strategy and will serve a large user base in the public and private sector.  I've read the readme you pointed to above and am very interested in giving Duo a go (with a lower case G @visionmedia)!\nWe are at a point where we could switch to something like Duo and TBH the component boilerplate is something that has cost us in terms of time especially during this period of switching to 1.x.\n@MatthewMueller, how can I get more info on Duo so that I can evaluate it as soon as possible?\n. @jonathanong, @MatthewMueller, can we get an indication on how close/far either of these solutions are for community use/contribution/adoption. @fairwinds, agreed on npm, also need to go beyond GitHub for locked down in-house/intranet dev/solutions but that looks covered by both nlz and Duo...\n. @jonathanong, thanks, will have to put some time aside to take a look at both nlz and duo...\n. @visionmedia, @MatthewMueller, looking forward to it... Duo eta to open source?\n. Awesome...\n. @visionmedia, we run our own GH-like component server in-house for business logic (private) components (of which there are many) which we can't push to GH, so being limited to only GH is a non-starter for us.\n@MatthewMueller, @yields, is there a way to add additional GH-like resolvers to Duo?  I see duo-package uses gh-resolve and that looks pretty baked in... if that's that case would this be where it could be extended to use additional resolvers?\n. @yields, that would be great.  I don't see it there now... :) so will hack away until it's OS...\n. > ..., otherwise it's just pure rage haha\nhahaha, lovely...\n. Thanks @timaschew, will take a look...\n. @jonathanong, figured that thanks, but are remotes ordered in the order they are required or on whichever downloads first?\n. @jonathanong, thanks for your time...\n. hahaha, @timaschew,  yup, its definitely this: https://github.com/component/builder2.js/issues/29... a day later with randomly breaking CSS...\n. @timaschew, looks good to me... (and BTW great effort thanks...)\nOn 0.19, I think people should migrate to 1.0.0 as soon as possible. :)\nOn Duo, I agree with you @timaschew, @netpoetica and other comments I have seen in other threads, to me it has some nice clean ideas but is too shiny for production at this point.  To be fair I haven't had the time to see how 'feature complete' it is, esp. with respect to APIs for resolvers, builders, bundlers, etc. (which I use heavily).\nA fundamental issue which should be resolved since I believe it is at the root of quite a few other issues is componentjs/builder2.js#29 (@jonathanong needs your input).  But that's no reason to not go 1.0.0!\n. @timaschew, first off thank you for all your amazing work on componentjs!\nIn the early days component was amazing but for myself the writing on the wall with respect to it's future was when key people began talk of webcomponents and es6 modules.  To that end I have looked to other 'component' packaging, bundling and development mechanisms including jspm, webpack, Polymer as well as switched to es6 for iojs/node side stuff using babel, esperanto and rollup.  To be honest it's been a time consuming switch but necessary to stay in the game!  Thanks!\n. Ok will do...\n. Better too! Will update...\n. ",
    "bitmage": "This is very unfortunate.  I'd like to use Flight, but yeah, not a big fan of bower.  I'm with you guys, I don't know why twitter is using the name component.json.  Maybe we can get them to change it to bower.json or even components.json.\nIs there any possibility of defining pragma or something that would make a file compatible with both systems?  Could you recognize the bower format, go and query their registry to find github links, and continue processing as normal?\n. How does component handle other libraries that just define themselves as globals?  Is there any legacy/backwards compatibility support?  I know require.js has some tools for wrapping legacy libs:\nhttp://requirejs.org/docs/api.html#config-shim\n. Cool.  I'll just manage deps like that manually then.\nFYI, looks like Twitter is changing to use bower.json as the standard, so that may put the OP's issue to rest.\nhttps://github.com/twitter/bower/issues/37#issuecomment-15485488\n. I was thinking about a possible solution to this.  I'm not sure how hooks or custom build steps work though.  Would it be possible to define a custom entry in the component.json:\nraw: ['dist/alias.js']\nWhich would put the contents of any 'raw' files in with the final build?  Essentially they just need to not be wrapped in the commonjs require.define, which would differ execution of the aliases.\n. Wow.\n. This sort of reasoning seems fundamentally broken to me.  I've outlined a strategy for interacting and collaborating with the larger community, and your response is \"We'll just rewrite everything?\"\nQuestion for you guys.  On average, is the strategy of fork-and-pull-request resulting in re-merging of these changes, or are these forks becoming permanent artifacts?  I don't think that forked versions of projects in order to support different package managers is a sustainable path.  These forked versions will quickly fall out of date (I've already experienced this with lodash).  And as we've seen with AMD, RequireJS, and other dependency systems, the trend is for people to NOT adopt a single solution.  What makes you think this situation is different?\n. Yeah, I guess I see the usefulness of this sort of thing more at the application level than at the library level.  I understand you don't want to pollute the ecosystem with libraries of mixed dependencies.  On a given application though, it would be very nice to manage dependencies through a cohesive system such as Component rather than by a collection of build scripts (often haphazard and error prone).  Without shims, Component will only ever be able to manage a subset of the dependencies I require.\n. ",
    "rvagg": "Got any thoughts on this for Traversty? It needs a selector engine but is capable of handling a bunch of different ones via feature-detection so it would be less than ideal to add in a specific selector engine as a dependency. I tried an approach similar to the one you've exampled above, which obviously didn't work!\nTraversty is mainly targeting Ender builds where we can guarantee that the core ender object has at least some basic selector engine functionality even if it doesn't have a selector engine plugged in.\n. OK, so will this make sense in my README for component users?\nComponent integration\nYou can also install Traversty as a component:\n$ component install rvagg/traversty\nWiring up a selector engine is let to you in your component build. You'll need to make one-off call to setSelectorEngine() once you have a selector engine to inject, otherwise Traversty will simply use native querySelectorAll() and matchesSelector() if available. See the setSelectorEngine() for more details on how this works.\njs\nvar zest = require('zest')\n  , $ = require('traversty').setSelectorEngine(zest)\n. ",
    "beaubrewer": "Getting the same error when trying to build\ndesktop$ component build\nmodule.js:340\n    throw err;\n          ^\nError: Cannot find module '/Users/beau/component.json'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:362:17)\n    at require (module.js:378:17)\n    at Object. (/usr/local/lib/node_modules/component/bin/component-build:51:12)\n    at Module._compile (module.js:449:26)\n    at Object.Module._extensions..js (module.js:467:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Module.runMain (module.js:492:10)\n. I don't. I have the 'components' folder that was created when I installed the bus component and the sub-folders both contain a component.json file. I hope I'm not just doing something wrong.\nI assumed that after installing any number of components... that component build would create my build file(s) that include the components in the list. I can build any single component in the components folder however. I just tried it out. That leads me to believe I'm a crack head and totally wrong in my assumptions.\n. ",
    "bestander": "+1 for that\n. This link/unlink functionality is really awesome, hope to see it soon in release\n. +1 for debugging in production, especially with all the line numbers preserved it helps to send bug reports for 3rd party components\n. ",
    "karlbohlmark": "It would even be good enough to just have a --debug build that would output the css as one css file with a list of imports and add sourceURL mappings for the javascript.\nActually, isn't //@ sourceURL even better than source maps, since it preserves the inspectability of variables?\n. Yeah, that's all I need with regards to the javascript. Actually I don't get why they didn't include variable inspection in the source maps spec; it makes it pretty much useless when you have //@ sourceURL as a much simpler alternative.\n. Yes, thanks for the clarification.\nI use sourceURL for my compiled and combined coffeescript to split it back up into files i dev tools. While you are probably correct that variable inspection will work for build processes not involving any obfuscating of names, the coffeescript compiler actually does introduce quite a few new names that would not be inspectable in current source maps implementations.\nFor this reason, I much prefer debugging the compiled javascript with sourceURL annotations to using source maps, since I find debugging without inspection mostly pointless.\n. I vote for keeping the local components separate from the remote dependencies, as I think this is more intuitive.\nI don't think that\njson\n\"dependencies\": {\n    \"some/foo\": \"*\",\n    \"user\": \"user\"\n}\ncommunicates clearly where the two dependencies can be found.\n- I am ok with requiring relative paths in local. (slightly verbose and ugly)\n- I think I am also ok with keeping paths and defining and implementing the behavior for nested components. (slightly complex)\nIt would be very nice to reach some kind of stability in the basic component json format.\n. @Nami-Doc yes, I understand. Well, for me, the most important thing is that we reach an agreement about the format. I'm fine with listing them together with remote dependencies also, even though I think it's a bit redundant to have \n\"user\": \"user\",\n\"login\": \"login\",\n\"yada1\": \"yada1\"\netc\n. While where discussing the json format, I have another case to handle, I think it's pretty self explanatory, tell me if it's not:\njson\n        \"some-dude/some-lib\": {\n            \"version\": \"*\",\n            \"redirect\": {\n                \"some-dude/jquery\": \"component/jquery\"\n            }\n        }\nI.e. How do you adhere to the \"dependency inversion principle\"? How do you switch in another implementation of that interface?\n. This looks to me like a node core bug. I just reported it:\nhttps://github.com/joyent/node/issues/6197\n. Yup, I just lost half an hour because of a missing parenthesis. Anybody knows where to add the error handling for this?\n. If you end up here, you might want to change https://github.com/component/console.js/blob/master/index.js#L29\nto err = err.stack || err; and your life will be a whole lot better.\n. ",
    "plievone": "Good to hear. Looking forward to see your approach. Nested components are also an interesting problem. Both Rdio and Soundcloud define sub-components in templates (Justin's talk and for example \"Views as components\" in http://backstage.soundcloud.com/2012/06/building-the-next-soundcloud/). And then there's also Facebook's Bigpipe-like streaming pagelets which are related to component approach.\n. Yes I agree. Looking forward to see how you approach composition, even though it is not in component as such.\n. ",
    "jeromegn": "Would love to hear about this too. I want to use components, but everything is rendered server-side in our app (using PJAX in the client).\n. ",
    "netpoetica": "Does this Todo example help at all in making sense of how to boot your client side code from dynamically generated sever-side code?\n. +1 on this, I have done some builds where aliases happen, and some where they don't, and I can't make any sense as to when an alias is or isn't generated\n. I haven't intentionally used the --dev option since beginning to generate builds, but I was getting quite a few alias per required local component at one point. My recent builds using 1.0.0rc-1 seem to have no aliases whatsoever, but previous builds were creating all sorts of aliases - for example, \"component-a\" would have an alias for \"component-a/index.js\" and whatnot\n. LoL I think I just picked a bad time to come on board :) if I had started using it at 1.0.0 I probably wouldn't have most of my issues :p anyhow yes my confusion about aliases seems to be pretty much taken care of in 1.0.0 versus the ~0.19 I had gotten from npm just a week ago\n. @yorkie Are you using Github username & password or an access token?\n. I think also it's time to stop relying on TJ's blog post to describe the thinking behind component as well - definitely should be kept around as a historical document, but component has grown quite a bit since that concept began.\nFor me, getting started, it was much less about the tooling and much more about the philosophy. I was under the impression initially that component was simply a competitor to bower, and yes, for a consumer of individual components it does feel like that - however, as a component author/builder, understanding locals, remotes, dev (which I still don't get), directory structure, rules and best practices are really where documentation currently falls short. I'm fairly confident that component is very well liked by people who are just running\ncomponent install component/jquery\nbut if you're looking to build an MVC app, or to create an entire project that has many dependencies, or if you would like to use it in conjunction with build tools and scripts - that's where you start to get to some confusion.\nJust my two cents as a recent user. I hope component doesn't get too involved in watch/minification and other make/grunt level tasks - I think once you get into that you're going to lose some focus and start enforcing too many opinions\n. One of the opinions that I struggled with initially is the idea that a \"component\" should be a small module in it's own repo. I was initially using component to build 1 big component that would house a bunch of small components, that wouldn't necessarily all have their own repo. In this situation, I would need some sort of recursive build, and I would initially be able to create configurable global builds of the container component as various distributions representing a variety of client's needs (aka, use this module but not that module in build X, use this module at version 0.1.0 in build Z).\nAnother one that I initially wasn't a fan of is the \"all-lowercase\" approach to component names, because I usually use the approach where my class is Capitalized and my instance is camelCased. Ultimately, this is inconsequential because when you build standalone, you can just tell it what name to use for the module.\nIn terms of watch/minification, I have had various experiences with different forms of watch where some would fail intermittently when watching too many files, where others would be just fine. The ability to plug and play these modules is very useful to me. The same is true with CSS minification - google's Closure Compiler and more recent versions of grunt-cssmin are the only CSS minifiers I haven't run into trouble with regarding - particularly - old IE8- CSS I had to write. RECESS, for example, gave a lot of IE grief. For me it's very important that when I hit those kinds of snags, I can just quickly get a minifier that does work and use that instead. I would hate to see bugs popping up in component's issues because the chosen minifier still hasn't fleshed out all of their own issues\n. I think having an rc file which allows you to configure what \"component build\" actually does will help with watch, as right now I think it would only be useful for a fraction of the component authors who are getting by with simple default builds. Unless watch is tied directly to make, and we standardize on people having to use Makefile tasks with specific known names to construct builds, having watch always call \"make build\".\nGrunt uses gaze, which has seemed to improved over time, but I did get the \"too many files\" error a couple of times where it didn't seem realistic. With sane, I would also consider whether that module author is going to be ready for the influx of usage as soon as all the current component users start reporting bugs :-)\n. @TheHydroImpulse I don't disagree with you about the minification of the final output, that definitely makes enough sense. However, I cannot understand how the components do not belong in a source/ directory below root, where root may be used to provide functional utilities (thinking bash scripts, deploy scripts, resource management, etc). The idea of having my front-end components living at root, with my build/ folder and core utilities just doesn't quite sit well with me. I think it may just be a philosophy problem, though, much less than an issue. I would still love to hear some justification for this if any is available though\n. Picture something like this:\nmy-app/\n  .gitignore\n  .git/\n  component.json # tells component my install dir === source/components/\n  service.sh # utility script for syncing remote resources, to keep them out of a Git repo\n  Gruntfile.js # because my build is special and requires more special attention than simply concat\n  node_modules/\n  build/ # this folder is usually for the generated build, which will become a \"release\", maybe a .zip\n  test/\n    index.html\n    js/\n      lib/\n        qunit.js\n      my-app.test.js\n    css/\n      qunit.css\n  source/\n    index.html\n    partials/\n    styles/\n    js/\n    components/ # in my ideal world\nNote: obviously this code is not using Express, and the backend code does not live in the same repo. Generally, grunt is using a connect server to run local tests and for local dev, and then the codebase is later to deployed to an environment with supported backend.\n. Thanks folks, I think I have a better grasp on this now. I was thinking of this relative to existing client-side package mgmt tools I've used rather than giving it blank canvas treatment.\n@jonathanong I do agree that it \"works\", but you are asking users to adopt a philosophy and structure here - maybe users will (as many obviously have), maybe they won't, but if you don't care enough to explain your philosophy, then why should users of this tool expect you will care enough to properly address future issues? If I'm going to agree to let tool authors define my directory structure by making a commitment to their tools, then I need to know the tool authors are willing to make a commitment to their users. Your snootiness and attitude are certainly not indicative of that commitment.\nAdditionally, you may want to consider updating the documentation in the locations I specified that imply ./components is a default to a configurable property. \nClosing this as to prevent additional opportunities for derping\n. I don't think there is currently a way to do this, but maybe with https://github.com/component/builder2.js you would be able to make a custom build. I couldn't tell exactly by reading the docs but the README seems to imply you could programmatically pass your component.json file as a JS object (aka you could have 2 component.json living at root and generate a build for each). Additionally, this bundler module seems like it allows you to specify more entry points, which is more along the lines of what it seems you need\n. Sounds like the kind of thing that should be set in a global component config :) the idea of coding in color support and having naked B&W theme is cool, but then open up theming to individuals, add a section in the README with links to peoples ~/.componentrc or ~/.componentconfig files as \"themes\" and keep focus on larger issues\n. Which redirects to here: https://github.com/component/require2\nMy issues are more likely with builder2 based on the very simple source here - thanks\n. @jonathanong It looks like the folder name was exactly the problem - just renamed it to the same name as components, and it works fine. I had a component called \"google-analytics\" in a folder called \"GoogleAnalytics/\" - this worked like a charm. I've been through the documentation pretty thoroughly, but I didn't see anything about folder names having any impact - just noting for any future documentation updates. Also, just as an FYI, it seems to work just fine with keeping the \"name\" field in the component's component.json file - it was just a matter of changing the folder name\nThanks again\n. @jonathanong  Thanks! Just out of curiosity, is there is any way I could use the folder name when requiring an item? For example, I want to call\nrequire('subcomponents/subcomponent-1')\nTo give it a sensible namepsace, even though it's local. I'm not certain how I can tell component that I want the slash there, but I don't want it to be a Github user/repo combo\n. Yup, I definitely get that, I guess if you want to namespace it, you would just use a dash like you guys do for components. \"component-require\", \"component-builder\", etc. I'm trying to achieve the effect of grouping alike components into a namespace for readability, so something like \"subcomponents-subcomponent-1\", imagining that the name was more creative, like \"service-google-analytics\"\n. This app has only js - all of the components have index.js files as their \"script\", but there isn't an index.js file in the folder that contains all my components (aka \"core\" does not have an index.js).\nNot sure why I would need an index.js for the folder that contains my components? After adding the \"scripts\" array back to all my subcomponents, I now receive an error which implies what you just said:\n```\n/Users/krosenberg/.nvm/v0.10.21/lib/node_modules/component/node_modules/component-build/lib/scripts.js:50\n    throw new Error('failed to resolve the entry point of component \"' + tree.\n          ^\nError: failed to resolve the entry point of component \"m3-component-libary\". please either have .scripts or a single .locals in your main component.\n```\n. Debug mode is very interesting :) I have a require('async') line commented out with a TODO note, but it looks like component-builder is parsing the file for require calls and still trying to resolve the dependency even though it is unused:\n// TODO: utilize async.js for more advanced AJAX functionality.\n    // async = require('async'),\ndebug output\ncomponent-builder:scripts could not resolve \"async\" from \"./core/custom-ajax\" +0ms\n. Also, as for what --verbose should do, I would expect it to do what DEBUG=* does - I'd also highly recommend putting a note about the DEBUG=* thing in the\ncomponent --help\nlisting, at least until this lib is more stable/predictable\n. That logic about DEBUG definitely makes sense.\nUnfortunately the repo I'm working in is for work, and I couldn't share it without permission. I certainly wish I would have toyed with this library on a personal project before choosing it for this :) if I have to, I will try to make a new copy-cat repo and attempt to strip out company related stuff.\nI would be curious though if you have any sort of troubleshooting guide or maybe could spell out some of the steps you might take to diagnose the issue if you did have the repo?\nAdditionally, I'm curious about the \"JS API\" - not seeing any such thing in docs? This maybe?\n. Also, FYI, I think this error shows up in 0.19.8 but not in 1.0.0-rc1 (I'm switching node versions so I can test two diff versions of component)\n/Users/krosenberg/.nvm/v0.10.21/lib/node_modules/component/node_modules/component-build/lib/scripts.js:50\n    throw new Error('failed to resolve the entry point of component \"' + tree.\n          ^\nError: failed to resolve the entry point of component \"component-libary\". please either have .scripts or a single .locals in your main component.\n    at canonical (/Users/krosenberg/.nvm/v0.10.21/lib/node_modules/component/node_modules/component-build/lib/scripts.js:50:11)\n    at /Users/krosenberg/.nvm/v0.10.21/lib/node_modules/component/node_modules/component-build/lib/scripts.js:25:16\n    at /Users/krosenberg/.nvm/v0.10.21/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/build/builders/builder.js:573:9\n    at next (/Users/krosenberg/.nvm/v0.10.21/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/node_modules/chanel/lib/proto.js:246:5)\n    at Channel.onevent (/Users/krosenberg/.nvm/v0.10.21/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/node_modules/chanel/lib/proto.js:182:9)\n    at Channel.g (events.js:175:14)\n    at Channel.EventEmitter.emit (events.js:92:17)\n    at /Users/krosenberg/.nvm/v0.10.21/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/node_modules/chanel/lib/proto.js:130:10\n    at processImmediate [as _immediateCallback] (timers.js:330:15)\n. It's strange, I think based on the todo exampe, and one of the comments you left about main point of entry, that what you're saying is that I should have a \"main\" component (like \"boot\") which I tell my component.json (root level) about, which then goes and requires all it's siblings? Is that correct?\nI can see why this would be useful in at least helping to determine dependency load order, but it is quite strange that I haven't had any trouble with this before now, all of a sudden. I have been working with this for days without having any issue about not having a main point of entry, but I think it's been blind luck - I don't think I have been using it as intended\n. This was the result of a variety of issues, the primary one being my own misunderstanding of component. There is are big differences between 1) how I assumed component should work and 2) how I interpreted how component works via documentation and 3) how component actually works. I am not sure I have a full grasp yet on how component actually works, but I do think it is becoming more clear.\nAnyhow, things to note:\n- v1.0.x uses \"locals\" instead of \"local\" (contrary to comment above)\n- v1.0.x has significantly more useful error reporting and feedback\n- as far as I can tell, ALL component.json files, from root, to subfolders, should have a \"scripts\" array with the name of required scripts.\n- run build with DEBUG=* component build to see where lookups are failing (this is usually the cause of empty builds)\n- having more than 1 path in your paths array seems to break things or be generally useless, more clarity about how and why one would have multiple paths is necessary\n- local components which use require() to call components that are siblings of that component also need to have a \"locals\" array with those required components listed\n. Looking for my component to be an instantiable object for use in another JS file somewhere, there is no known option currently for --standalone \nerror: unknown option `--standalone'\nIt may be the -s/--umd option though that I am looking for\n. Yes, -s is what I was looking for, however, do you think the name of the exported module should be definable in component.json?\n. Defaulting to name is a very good idea, that is exactly what I had though it would do when I passed it the -s flag. I think \"standalone\" is a more approachable option name than \"umd\" so good call on bringing it back in rc2. @jonathanong Want me to open a separate issue so you can flag as a feature/proposal?\n. I get the idea that the component.json file, as it is related to the component and not the build process, probably shouldn't have config info for the component-builder, but I think the need for a that type of config exists and should be considered. I imagine that the absence of this configuration is the reason why we see people putting Makefiles in their repos a lot. I think there should be a more convenient way to manage building considering the frequency with which it is done during development.\nAdditionally, I think it's a steep enough learning curve to get on board with the philosophy of component let alone ask devs to use Make - I think 1 out of 4 or 5 front-end devs (maybe grim outlook) actually know/understand/have seen Makfiles, it will probably intimidate some\n. I'm not positive that environmental variables would be the best way of handling this because of the usecase where someone who is technically working on 1 large component that contains a couple of smaller components. Due to the current philosophy behind component, it makes sense to separate these components into separate \"projects\" (aka folders with a root level component.json),so you find yourself going in and out of each component folder to run \"component build\" in order to ultimately generate a couple of components for consumption within one over-arching project. I'm already picturing that during fast-pace development people forget to change env vars and end up with the wrong settings generating the wrong builds, with errors resulting in more Github issues\n. Ah , gotcha. I thought you meant manually settings environment variables via shell\n. @marcelklehr can you post your component.json and your directory structure of your project?\n. It seems silly no? I mean it's a trim enough instance of require that I can't complain too much, it's very concise and thorough. But if it's being assigned to global window['name'] anyway why not just bypass require altogether?\n. It appears this was the result of having another local component listing the same dependency as the global component.\ncomponent.json\ncore/\n  boot-component/\n     component.json\nBoth component.json files had the same repo in the dependencies array.\n. Here we go: https://github.com/netpoetica/component-locals-and-remotes\n. Scratch this... this was me trying to use an array instead of an object for Dependencies, so no version was specified.\nhttps://github.com/netpoetica/component-locals-and-remotes/commit/d369a453b5ca734037bf0f1edad07976cb1ddaba\nIt is strange that it tried to append the 0 to the GET string though, maybe there is a better way to handle that? Check instanceof Array to check and see if anyone else derped up, or just fail if it's not a key/value pair\n. > I think we're trying to make too many changes at once here. It's going to be unmanageable and unreleasable. We should pull back and make smaller, incremental changes.\nI think reducing core is a noble goal but maybe there could be a promotion strategy, where, as things becomes demonstrably stable, they can be merged into component/component (in support of making smaller incremental changes)\n\nAs far as remotes go it would probably be overkill for now but if we maybe started supporting the whole { \"bitbucket.com/foo/bar\": \"1.x\" } sort of syntax similar to Go, and repo/user would just imply the github support that we already have. Not sure if that's worth tackling for now since long-term it would probably just end up being parsed from the import statements.\n\nI think this would be a good idea at least for reducing requests made, decreasing install time. I cringe a little bit though because I remember Go package management being a nightmare early on to the point where the Google group about golang pm felt a bit like an emotional more than technical support group\n. Think it's a good idea, I actually only found this the other day and remember thinking it was cute. It was like an easter egg\n. Can you post your component.json file here or link to repo?\n. You'll definitely want to take a look at https://github.com/component/guide\nParticulary, looking at entry points and standalone builds based on what I'm seeing you're trying to do (could use more details though).\nYou may also find the spec very helpful - try to make sure that you're setting all required fields and that you are using the correct things for dependencies. For example, \"dependencies\" implies you are trying to look up a remote, and it is an object (JSON) whereas \"locals\" property implies you have components on your local machine and should be an array.\nAdditionally, try running your command with debug:\nDEBUG=* component build\nEDIT: I was linking to the wrong repo (scripts), I meant to send you to this one: https://github.com/component/todo\nI also found this repo very informative in helping to explain the philosophy of component, and local components in general. Note: that repo is based on a little bit older version of component from a few weeks ago, but the ideas are there. Particularly, using a \"boot\" component to load all your other local components into one build.\n. You should definitely open an issue on that authors repo because that code hasn't been updated in a year - it's very possible his code may be out of date with the current component codebase.\nFor example, \"local\" has been deprecated and \"locals\" is now used, and is an array\n. This one is pretty strange - since that Git repo exists, it should never even get to look on Bitbucket. The error message is correct though because when it tries to get JSON from that URL it's actually getting HTML, as if you did \"curl https://api.bitbucket.org/1.0/repositories/apla/node-util/raw/v0.10.3/component.json\", so it is malformed JSON.\nThe component.json in your fork of node-util looks like it has a bunch of additional properties that are not in the component spec - what's probably happening is that your component.json is not passing validation so remotes.js is looking to Bitbucket next\n. Highly recommend giving this a shot: try to make your component.json for node-utils look like the spec - I think that component.json is intended for use with a different package manager or something.\n@jonathanong Here's the output if it helps any but I'm fairly certain it's just the component.json from Github being invalid. Maybe there is a better message to use when hitting this error?\n\u279c  test  DEBUG=component* component install\n  component-resolver remote not set - defaulting to remotes's defaults +0ms\n  component-resolver:locals resolving local at \"/Users/krosenberg/Desktop/temp/test\" +0ms\n  component-resolver resolving \"test\" +10ms\n  component-resolver remaining dependencies: 7 +7ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver finished resolving locals +0ms\n  component-resolver finished resolving dependencies (1) +1ms\n  component-resolver:semver resolving semver apla/dataflo.ws@* +0ms\n  component-resolver:dependencies resolving dependency apla/dataflo.ws@master +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for apla/dataflo.ws@master +0ms\n  component-resolver:dependencies found apla/dataflo.ws@master from remote \"local\" +2ms\n  component-resolver resolving \"apla/dataflo.ws\" +6ms\n  component-resolver:semver resolving semver apla/node-util@* +5ms\n  component-resolver remaining dependencies: 1 +1ms\n  component-resolver remaining semver: 7 +0ms\n  component-resolver:semver resolved semver apla/dataflo.ws@* -> apla/dataflo.ws@master +2ms\n  component-resolver:semver resolving semver ftlabs/fastclick@* +0ms\n  component-downloader \"/Users/krosenberg/Desktop/temp/test/components/apla/dataflo.ws/master\" exists, skipping downloading. +0ms\n  component-resolver:dependencies resolving dependency ftlabs/fastclick@v1.0.1 +39ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for ftlabs/fastclick@v1.0.1 +0ms\n  component-resolver:dependencies found ftlabs/fastclick@v1.0.1 from remote \"local\" +1ms\n  component-resolver resolving \"ftlabs/fastclick\" +39ms\n  component-resolver remaining dependencies: 1 +0ms\n  component-resolver remaining semver: 6 +1ms\n  component-resolver:semver resolved semver ftlabs/fastclick@* -> ftlabs/fastclick@v1.0.1 +39ms\n  component-resolver:semver resolving semver apla/eventemitter@* +0ms\n  component-downloader \"/Users/krosenberg/Desktop/temp/test/components/ftlabs/fastclick/v1.0.1\" exists, skipping downloading. +14ms\n  component-resolver:dependencies resolving dependency apla/eventemitter@v4.2.7 +2ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for apla/eventemitter@v4.2.7 +0ms\n  component-resolver:dependencies found apla/eventemitter@v4.2.7 from remote \"local\" +1ms\n  component-resolver resolving \"apla/eventemitter\" +2ms\n  component-resolver remaining dependencies: 1 +0ms\n  component-resolver remaining semver: 5 +0ms\n  component-resolver:semver resolved semver apla/eventemitter@* -> apla/eventemitter@v4.2.7 +2ms\n  component-resolver:semver resolving semver apla/node-util@* +0ms\n  component-downloader \"/Users/krosenberg/Desktop/temp/test/components/apla/eventemitter/v4.2.7\" exists, skipping downloading. +3ms\n  component-resolver:dependencies resolving dependency apla/node-util@v0.10.3 +551ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for apla/node-util@v0.10.3 +0ms\n\u279c  test  ls\ncomponent.json components     test.js\n\u279c  test  ls components \napla   ftlabs\n\u279c  test  ls components/ftlabs \nfastclick\n\u279c  test  ls components/apla \ndataflo.ws   eventemitter\n\u279c  test  DEBUG=remotes* component install\n  remotes:local checking local components at /Users/krosenberg/Desktop/temp/test/components +0ms\n  remotes:local resolving local remote +17ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/apla/dataflo.ws +1ms\n  remotes:local got folders: master +0ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/apla/dataflo.ws +1ms\n  remotes:local got folders: master +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/apla/dataflo.ws +0ms\n  remotes:local got folders: master +0ms\n  remotes:local resolving local remote +2ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/apla/node-util +0ms\n  remotes:local resolving local remote +2ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/ftlabs/fastclick +1ms\n  remotes:github GET \"https://raw.githubusercontent.com/apla/node-util/master/component.json\" +0ms\n  remotes:local got folders: v1.0.1 +27ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/ftlabs/fastclick +1ms\n  remotes:local got folders: v1.0.1 +0ms\n  remotes:local resolving local remote +12ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/ftlabs/fastclick +0ms\n  remotes:local got folders: v1.0.1 +1ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/apla/eventemitter +0ms\n  remotes:local got folders: v4.2.7 +0ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/apla/eventemitter +0ms\n  remotes:local got folders: v4.2.7 +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/apla/eventemitter +0ms\n  remotes:local got folders: v4.2.7 +0ms\n  remotes:github GET \"https://api.github.com/repos/apla/node-util/tags\" +272ms\ngithub remote: only 50 requests remaining.\ngithub remote: see https://github.com/component/remotes.js/blob/master/docs/github.md for more information.\n  remotes:local resolving local remote +384ms\n  remotes:local checking folder: /Users/krosenberg/Desktop/temp/test/components/apla/node-util +0ms\n  remotes:github GET \"https://raw.githubusercontent.com/apla/node-util/v0.10.3/component.json\" +153ms\n  remotes:github GET \"https://raw.github.com/apla/node-util/v0.10.3/component.json\" +224ms\n  remotes:github GET \"https://raw.githubusercontent.com/apla/node-util/v0.10.3/component.json\" +123ms\n  remotes:github GET \"https://raw.github.com/apla/node-util/v0.10.3/component.json\" +211ms\n  remotes:bitbucket GET \"https://api.bitbucket.org/1.0/repositories/apla/node-util/raw/v0.10.3/component.json\" +0ms\n  remotes:bitbucket GET \"https://bitbucket.org/api/1.0/repositories/apla/node-util/raw/v0.10.3/component.json\" +180ms\n  remotes:bitbucket GET \"https://bitbucket.org/apla/node-util/raw/v0.10.3/component.json\" +183ms\n  remotes:bitbucket GET \"https://api.bitbucket.org/1.0/repositories/apla/node-util/raw/v0.10.3/component.json\" +193ms\n  remotes:bitbucket GET \"https://bitbucket.org/api/1.0/repositories/apla/node-util/raw/v0.10.3/component.json\" +174ms\n  remotes:bitbucket GET \"https://bitbucket.org/apla/node-util/raw/v0.10.3/component.json\" +168ms\n. @ryanchamp-ICE The local component name should be the same as the folder name containing it. Is this helpful?\n. Is this linked to parsing text in a file for \"require\" and then looking up dependencies?\n. Ah, I didn't see this. I had tried this about a week ago so this wouldn't have been fixed at the time\n. Can you post a link to your components repo or the project code, or your component.json in a gist?\n. Would you mind also posting your directory structure?\n. One last thing --- can you post your build.js file? I'm curious if I can use vim to detect the malformed unicode characters in there\n. Ah, i see you're using component in a way I don't have much experience with, like the Todo app here, it has a similar directory structure and composition to what you're doing.\nIt looks like your root level component.json is configured correctly with locals/paths. I would be curious if maybe your folder names are not matching with local components names in the \"locals\" array in your Gist. aka capitalized vs non-capitlized (none should be capitalized per Component convention).\nOtherwise, I would try to see if you can run your individual components in your browser directly, because it sounds like it's a file-level error that component-build isn't catching that then cannot be run in your browser\n. What command did you run to get this error? \"component install\"? If you can post your component.json that might help as well\n. Ah, I see, also worth noting is that http://component.io/learnboost/jsonp shows \"undefined\" - how did you get to that link anyway?\n. @jonathanong Maybe there is a way to see if the return header is json or not before checking for malformed JSON? Or just do a check for 404s? This is the second one of these in the last few days :-) BitBucket really shouldn't be returning their 404 page on an API call though, kind of silly on atlassian - should be a JSON response like \"resource unavailable\" or something\n. Oi. Major oi. @jonathanong every couple of days I think to myself, maybe the deps array should literally require the end user to put instead of a version number for release, the actual URL of the release :0)\n. @timaschew I think release of 1.0 will close this issue no?\n. Just confirmed this as well, looks good\n. Another example\nmkdir my-cool-app\ncd my-cool-app\ncomponent install someones-component\ncomponent build --standalone someones-component\nFails to generate a component (\"no point of entry\"). In this case, I do not want my overall project to be a component (no component.json, no use of require), I just want to generate a standalone component which can be used in my next JS file.\nNot sure if I am explaining this well - does this make sense to anyone else?\n. @jasonkuhrt in your original post, you show reactjs/reactjs and reactjs/reactjs-min - I'm probably missing something, but are you implying that component authors should be maintaining releases for minified and non-minified versions of their components?\nI definitely have encountered this type of use case before. Generally I find myself using component to generate standalone components which I then manage via Grunt builds, where I can actually automate tasks based on environment. AKA I rarely ever have projects that contain a component.json themselves, unless they are small modules shared across multiple projects, which I usually just build as standalone items.\nI am not sure that the solution of creating builds per environment really covers the full breadth and depth of problems opened up by some of the various use cases I have encountered so far, have to put some more though in to that\n. @stephenmathieson is this a private component? If so, have you configured your globals?\nCan you run with DEBUG=* and provide the output? Leaving a note for myself to verify that this isn't a problem with BitBucket's lack of support for Git trees, could be related to https://github.com/component/remotes.js/pull/14#discussion-diff-11324698R110\n. @stephenmathieson yeah, it's pretty difficult for me to tell if this has anything to do with the bitbucket remote. It's worth noting that if the BitBucket repo you are trying to use doesn't conform to semver and use release tags, it's possible this could be causing the issue. It is very strange that the error message from debug != the error message from your original post, I'm not too sure what's going on with that.\nOut of curiousity, can you confirm that the BitBucket repo (private) you are looking for is not being treated as local in your Gist? i.e. \"some-bitbucket-user/some-bitbucket-component\" whatever that was, is it in the Gist at all?\nAdditionally, try navigating to this URL directly and seeing if you get any JSON (in browser, logged in as a user who has access to that repo):\nhttps://api.bitbucket.org/1.0/repositories/some-bitbucket-user/some-bitbucket-component/tags\n// replace some-bitbucket-user/some-bitbucket-component with details\nAs an example, this is what it should look like in a public repo\nhttps://api.bitbucket.org/1.0/repositories/fenics-project/instant/tags\nThe error that you are getting in your original post is only possible if you get a 404 from https://api.bitbucket.org/1.0/repositories/some-bitbucket-user/some-bitbucket-component/tags\nRelevant code here for reference: https://github.com/component/remotes.js/blob/master/lib/remotes/bitbucket.js#L46\n. So that line 471 should be using bitbucket but instead it's using Github?\n. Interesting. The way it works right now is that it is cascading, that is, component checks locally first, then reaches out to github, and if it doesn't find it, it should then go to the next remote (only BitBucket). This is because we cannot explicitly tell component which repo belongs to which remote via component.json (the spec doesn't support this but it has been discussed, I can't find the thread though). See: https://github.com/component/remotes.js/blob/master/lib/remotes.js#L98\nIt looks like for some reason, in this case, it's throwing an err for Github and then never trying for BitBucket. I will definitely spend some more time with this and see what's up\n. At some point ong and I discussed having the user specify remotes in their dependencies. It could also be a list of remotes in the component.json, or something similar.\n\"dependencies\": {\n  \"bitbucket:netpoetica/my-component\": \"~1.2\"\n}\nI like your previous example where remote order is specified via component.json though, that's a good idea. I would ideally combine the two ideas, so that people can still prefix their deps to optimize speed  and accuracy of downloads, and avoid issues of failed lookups.\nBecause of how component/remotes.js is constructed, it's fairly simple to add any remote that has a decent API. I was working on CodePlex for a while but their API is godawful. Post 1.0 I would like to try to add all known remotes :-) that would keep Component relevant as well, \"the package manager that works across all Git hosting platforms\", etc\n. @tetsuo How do you see an update changing the component.json file? I might be missing something on that one\nAn error in this situation is expected behavior - if no component.json is found, component should not attempt to treat the repo like a valid remote. I agree with Ong that adding an extra HTTP request is overkill, just to provide a more accurate error message.\nWhat about changing the message of all 404 errors (whether remote or component.json is not found) to just say\nerror : no valid remote found for dependency  ... ...\n. Hey @bigmeech it may be a good idea not to use component for something that is time sensitive right now, but definitely think about starting out/learning with a personal project or something that you can take your time on. There is a bit of a learning curve at first as component can be a bit opinionated, but once you're more comfortable with it, it's awesome.\nFirst thing though for starters, it looks like you've got stuff that belongs in your component.json file inside of your package.json file. What does your actual component.json file look like? I think the package.json file probably shouldn't have most of those properties in it\n. You can connect to it via http://component.github.io/component.io/ if need be.\nI linked this issue over to component.io issues here https://github.com/component/component.io/issues/80\n. > does anyone using bitbucket use mercurial? i wonder if that's something package managers should ever bother supporting\nI have seen Mercurial used by software devs much more than web devs, but Git is slowly taking over there as well. Only one web app company I worked for used Mercurial, but the lead dev who chose is was a C++ guy who did svn -> mercurial path. I imagine by now they have moved to git just for pure convenience of all web packages being on Github\n. This is kind of a cool concept, but personally I think the best way to handle this is to fork the repo and create a modified codebase with the CSS you want, and then just include that in your dependencies (ismay/h5bp)\nI think that having a list of overrides in the component.json is not necessarily a \"package description\" anymore - it's actually got a builder-level knowledge to it.\n. A second option would also be to have an intermediate build step, i.e. some build script takes the source/ directory and distributes it to two separate components, which can then be built independently:\n```\nsource/\n-- index.html\n-- theme1.css\n-- theme2.css\n-- index.js\n-- component.json (points to \"index.css\")\n// run build script\ndist/\n-- component-a/\n-- -- index.css <- theme1.css\n-- -- component.json\n-- component-b/\n-- -- index.css <- theme2.css\n-- -- component.json\n```\n. @timaschew I think we should merge this one in before a 1.0 release. This is just a good idea in general. I checked through the rest of the codebase and didn't find any other occurrences of splitting on \":\" so this should solve the problem global.\nThanks for this pull request! Nice catch!\n. I think now is as good a time as any :-) I think I have to update the changelog where we talk about custom remotes, since we also support BitBucket now, unless there is an intention to not allow Bitbucket in 1.0?\nAlso I would like to merge this last pull request in, as it's pretty minimally invasive and will solve a problem that we definitely don't want to hear about in the future :)\n. Oh one thing though - I definitely think we should wait until component.io actually works, having to tell people \"1.0 is released! Get it at http://www.somethingreallylong.com/somethingelsereallylong.com/\" is going to look botched ;) \n. Merged in doc updates for custom remotes: https://github.com/componentjs/guide/pull/25\nThere is a pull request here that resolves components below root, but I would like one of you guys to review and merge it to make sure it's a good idea & that it shouldn't affect anything elsewhere - I added a test for it as well. Additionally, I added a warning in there that symlinking might be a better option in some situations as per conversation.\n. Is this the only open issue in .19 atm? https://github.com/componentjs/component/issues/569\nI'm going by label, not sure if maybe there is another known way of tracking issues in .19\n. @phvcky Duo is the new kid on the block, but\n1. More people/teams are using component than Duo in their projects simply due to how long it's been around, and it's important to continue to support them.\n2. Component still achives up to 3 times as many downloads per day from npm (note: this is probably due to it's use in a variety of deployment structures)\n3. Duo currently only supports Github as a remote whereas component supports Bitbucket as well\n4. Duo currently has > 3 times as many open issues as it's still very young\nI'm looking forward to seeing Duo do great things, but, right now it's still in early growth stages, its the new kid on the block :) \n. I agree that that line should be removed - when it is feature complete, we can reconsider, but I don't think it's worth compromising people's faith in this project by turning them to Duo right now. The development repo is awesome, nice work on that!\nI think \"show how to use the github token, instead of username and password\" has already been fixed by showing people how to use netrc? In the docs here we point folks to the Github page which explains creating a token\n. @timaschew I can def. do the extra.md, no prob! I'm having trouble locating that callout that \"newcomers have switched to Duo\" - did you already remove it? I can also fill in this bit if you want: https://github.com/componentjs/component/tree/master#team\nAnd then Extras.md would be in the main component repo here?\n. Awesome :-) let me know if there's anything I can do to help!\n. Working on it - got a lot of little typo/spelling/grammar fixes I will be pushing up shortly. Done: https://github.com/componentjs/guide/commit/97efd0a1c8292a90bc679fafdb76e3ad4056ae5e\n. I figured it should just be left in \"Extras.md\" standalone, and curious parties would navigate to it there. You think it should be called out specifically and linked to from the Readme? I could do that\n. Do you have a repo for this that I could check out?\n. When you install with -g you must be an admin/have admin privileges, on windows I believe. Are you able to install any other packages with -g (grunt-cli for example)?\n. Glad you found a solution, thank you for sharing!\n. Do you mean that if there is no component.json in master, we should checkout and look through all branches until we find the first branch that has one, and then use that component.json and install from master?\n. I agree with this, but I think we might want to consider this as part of a more major log output overhaul, because I've seen a lot of logs like this.\n. @timaschew I think for me it's some of the sentence particles using arbitrary punctuation, in combination with all-lowercase words. I don't think the logs are awful, they're just not super-polished.\nFor example, outdated name of a dependency : please update: is just strange use of the colon twice.\nA clear structure like\nLOG_LEVEL + TITLE + \":\" + MESSAGE\n```\nWarning - Outdated Dependencies: Please update \"component/search.js\" to \"componentjs/search.js\"\n// or\nWarning: Outdated Dependencies\nPlease update \"component/search.js\" to \"componentjs/search.js\"\n// or\nWarning -> Outdated Dependencies: Please update \"component/search.js\" to \"componentjs/search.js\"\n```\nWould be good to hear from @stephenmathieson for detail about possible improvements.\n. Is mca \"mac\"? Just for clarity :) otherwise I will be googling what an mca is for a little while ;)\n. You think this is possibly permissions changing when travis clones the repo, maybe component.json not getting write permission? Is it possible to SSH in and check this?\nTried opening permissions all the way up just to see, doesn't fix the problem actually seems to make things worse: https://travis-ci.org/componentjs/component/jobs/43424742\nTests pass on my mac but all sorts of strange errors in that build\n. @sankargorthi I have intentions to make Gitlab a possibility for component, but unfortunately I am not super-familiar with Gitlab.\nYou may want to look at component remotes and see what I did to make BitBucket a possibility. It shouldn't be much more work than what was done for BitBucket to be able to make Gitlab a reality for component@1.\nI would definitely be willing to work with you to bring this to component if you're interested\n. @timaschew are we still fixing bugs in lower versions of component at this point? Aside from the idea of adding the remote which is awesome, this is still a strange bug. I would like to keep away from < 0, what do you think?\n. This is pretty strange - I am curious if you would have the same error with a different version of lodash? The URL for that component.json is dead, so it's \"not valid JSON\" because the response is text:\nNot Found\nCan you run again with DEBUG=* in front and give that output? I'm curious about the \"<-- wrong version\" in there, it doesn't look familiar\n. One last thing - what does your component.json look like? I think it's very strange that with ~2.4.1 specified we're seeing this 3.0.0-npm-packages in the slug where it's looking for the component.json\n. It looks like it will install without trouble if you don't have a ~ tilde in front of the package, if you need a fast solution (I noticed you said it is breaking your builds). i.e. you can run component install lodash/lodash@2.4.1 without trouble\nEven though ~2.4.1 is specified, it's resolving to use that tag 3.0.0-npm-packages which does not have a component.json. The same error comes from DEBUG=* component install lodash/lodash.\n. @timaschew Do you think it's a bug, or maybe I am missing something, that \n{\n  'lodash/lodash': '~2.4.1'\n}\nShould attempt to resolve from these tags to \"3.0.0-npm-packages\" when there is clearly a 2.4.1 tag on that list?\n. @timaschew I was testing this a little yesterday with components/jquery and tried things like:\nDEBUG=* component install components/jquery@~1.7\nWhere it would resolve that 1.7.2 was the right tag to use, but then give an error:\nfatal : no remote found for dependency \"components/jquery@1.7.2\". Visit http://component.github.io/troubleshooting for help.\nEdit: removed invalid comment and test case :)\nSharing because I think these might be useful test cases and had started some bit of adding tests for these and looking through the resolver code, but haven't quite found yet where we are looking at available tags and determining which one is appropriate\n. Can confirm I was able to install both ways with 1.0.2 on Mac OSX - I also ran npm install -g component@1.0.1 (the version you guys would have been having trouble with) and was not able to replicate. Wonder if npm might have been having trouble for a min (or hour or two)?\n. @timaschew Thanks for all your hard work on component amigo. I agree with you that it is the right time for this announcement. I have not had my hands in every nearly as many modules of componentjs as you have and I certainly don't think I would be capable of maintaining this project - especially to the quality it has been maintained by you - without you.\nI am still open to being pinged for Bitbucket remote-related issues if they are business-/originzation-crucial, but I do not think this portion of component has been heavily utilized.\nLet me know if there is anything you need from me. It's been fun working on the small slices of component that I've had a chance to be involved in - hopefully one day we'll run into each other at a conference!\nCheers,\nKeith\n. ",
    "cbou": "But download from the internet is the most common way to install components. Actually I think it should be the only way to install component.\n. ",
    "andrewrk": "I would encourage sticking to npm's philosophy of duplicating dependencies if the versions don't match. I would argue that correctness is more valuable than smallness.\nWe don't have to give up smallness, however. We could try to use the same versions when the version locking allows and output warnings when duplicates must be used.\n. Yeah I think that's reasonable. But there's a deeper underlying issue, which is, what do we do about projects where the maintainers are laggy and we want component versions of their software?\n. @visionmedia I like that philosophy.\nRelated: https://github.com/caolan/async/pull/193\n. Oh wow, that was really dumb of me. I totally forgot to mess with module.exports which means that the whole idea of using it as a submodule is moot. Sorry.\n. 0.6.4\n$ find components/superjoe30-async/\ncomponents/superjoe30-async/\ncomponents/superjoe30-async/component.json\ncomponents/superjoe30-async/lib\ncomponents/superjoe30-async/lib/async.js\nwhat else can I show you?\n. Oh, it's a reverse alias. I see.\n. Sorry. Should have tested by testing rather than inspection.\n. equivalent of npm remove --save some-library\n. Option 1. You could optionally supply an object instead of a string to a dependency:\njs\n{\n  \"dependencies\": {\n    \"juliangruber/events\": {version: \"*\", alias: \"foo-events\"}\n    \"component/inherit\": \"*\"\n  }\n}\nIn this example, require('events') would not work, but require('foo-events') would work.\nOption 2. Explicitly list aliases.\njs\n{\n  \"dependencies\": {\n    \"juliangruber/events\": {version: \"*\", alias: \"foo-events\"}\n    \"component/inherit\": \"*\"\n  },\n  \"dependencyAliases\": {\n    \"foo-events\": \"juliangruber/events\"\n  }\n}\nIn this example, require('events') and require('foo-events') would both work.\n. Oops. Edited.\n. component already solves 95% of the problem of creating components that work both in node.js and component. Can't we gently push it the rest of the way?\n. @timoxley Fun idea, but flawed, as arbitrary values can be assigned to the global object at runtime.\n. sure but if you think in terms of total maintenance required, it makes sense for everyone to depend on the same fork.\n. maybe using this? https://github.com/isaacs/node-which\n. ",
    "matthewp": "As an alternative to semver it would be nice to include a specific commit hash in your dependencies. This should work right now (haven't actually tried it), but I'd like to see it be officially supported.\njson\n\"dependencies\": {\n  \"component/emitter\": \"3d5b12b113ca67a8c23d94aca74d18e9b70a72b7\"\n}\n. Closing due to the issue being closed.\n. ",
    "anthonyshort": "Surprised more people haven't been pushing for this. We're currently running ~50 components across multiple corporate sites and semver resolution would lower the amount of manual work we have to do with versions. I even tried to use bower for dependencies and component to build :cry:\nIs there anything I can do to help get this started? I'm happy to start working on some code for this if you've got an idea of how you'd like it to work.\n. I have a fork that installs and builds with multiple versions, but it doesn't use semver yet, so every version is added to the build. This means there are never any conflicts with the versions, but it could theoretically get quite large. \nPersonally, I don't really care that every version is added to the build if it means component stays simple. A few extra KB to keep life simple with plain versioning.\nMost people won't like this though. But it won't really work until we get semver which we can't get until we have a registry (mostly).\n. I could be missing something, but it seems for people who don't want to make everything a component but still want access to the Component require and aliases there really isn't any option. I've even tried exporting the component require to the window so I have access to it as 'component'. \nI ended up making a grunt plugin for building components that will accept a glob in the scripts and expand it out to a list of files before building. This way I can use Component to compile simple CJS apps.\n. I opened the issue and I actually agree now that globbing shouldn't be a feature. I don't think I've actually needed it since I've starting building out a large site using Component... Once you've seen how little components are so much more digestible it really isn't a problem.\n. +1337\nCould really use this right now :dancer: \n. Nice. This would be incredibly useful.\n. That's how I wrote my calendar https://github.com/anthonyshort/calendar-skeleton component. So this how you see things going? It's a pretty solid solution. We'll end up having components for JS and components for HTML/CSS.\n. The problem with the basic CSS that is included is that it could still not fit in with the current styles of the site the component is being used in. There's a chance that the CSS from the component could affect things they're not supposed to.\nCSS really isn't ready for components. We need the all:default property to get some support. That would be a start.\n. It would be nice if a user could change the 'base' class used by the component. eg, from #dialog to .ui-dialog or whatever. Or if components provided Sass mixins or placeholder selectors instead. Again, author issue.\nCould it still be beneficial to have local components overriding? Maybe... I might fork it and try it out. If it seems to work I'll create a new issue.\n. I use a grunt task to run my custom builder.js implementation. https://github.com/anthonyshort/grunt-component-build \n. You can use component as a library by exporting the require function and making a standalone component. Make your main file this:\nindex.js:\njs\nmodule.exports = require;\nBuild the component as standalone:\ncomponent build --standalone component -n component\nAdd the script to your page and you'll have a global called component. Now you can do:\nvar dialog = component('dialog');\nUsing a single global to access your components. This is useful if you don't want to go full Component :)\n. I've been thinking about the exact same problem. Regarding Sass, I'm thinking it could be best to just combine all of the sass files together into a component.sass and then import that in your normal styles.\nsass\n@import '../components/build/component'\nOr something like that. So you're using Component to combine all of the Sass rather than compile it. This would mean you would use something like a sass section in your component.json.\nBut then how about using Component as a package manager for Sass components? You want each component to be able to depend on and require other components. Still, I suppose it could just have them as dependencies but not actually @import them. Then we could just combine everything still. \nI'm toying with a few ideas at the moment and trying to get a Sass workflow figured out.\n. It's really hard with regards to Sass because they don't have modules like we do with CommonJS. Importing things multiple times across various components could end up in bloat or broken code, I haven't figured that out yet. \n. Closing this as I've opened a PR for it #287\n. I've been using it today to setup an internal registry using Gitorious. Everything seems to work pretty well. Plus it doesn't break existing functionality.\n. /ping @visionmedia \n. This could be a case where using Bower to handle pulling down dependencies could be easier than Component. They might have a lot of garbage in the registry but they do have that part working quite well. No harm in that I suppose. \n. I don't normally use these sites either, but I'm stuck with it at work and I'm determined to get Component working -_-\n. For anyone in a similar situation, another solution for this is to create a little routing server that sits in between that redirects from Github-style URLs to the Gitorious-style URLs. Being able to just use the one tool would be great though.\neg. https://github.com/anthonyshort/gitorious-component-server\n. Not really sure how important semver really is. People end up shrinkwrapping things anyway to lock down dependencies. I mean it's slightly annoying having to manually update lots of things, but it feels safer too. Maybe Component could just stick to plain ol' tags\n. I've just stopped putting the version in the json :) it's easy to forget to update which makes it unreliable anyway. Component install could get the latest, set the tag in the dependency and set the version in the downloaded component.json\n. Consistency and predictability would be winning reasons.\n. Making a custom builder is a bit much for something this simple. I wrote one for grunt-component-build and a Sass compiler.\nFor now, it would be useful for working with projects that aren't typical. The coffee was just an example. It could mean that you might not need to pre-compile things like templates before you push them up, or you could avoid requiring a builder plugin for your component.\nFor me, I'm trying to use it share templates across multiple backend applications. I need to create some symlinks from the components to the correct directories in the app. I use npm's scripts to run grunt or component after an install during a build process.\n. You could possibly use this to create 'bundles' like browserify that require modules in other bundles. Maybe.\n. I'm for the option of having all of the files in templates require-able as strings. This lets people put whatever template they want in there and they get access to it. Handlebars templates could go in there and be compiled in the JS if that's what you want to do. \nIf you needed to do some processing of another type of file, even CSS, you could put it in templates, require it, process it and then inject it into the page. It's just another sort of template.\nIf people want to pre-compile templates just use a plugin that updates the templates section from blah.jade to blah.html. If not, just require('blah.jade') and do your thing.\n. Yeah, that's what I meant. In the component plugins we're already looking for files with certain types and updating the scripts and templates section in the builder anyway. If we just make all templates available as strings then we don't really care what people want to do with it.\nI can't think of any good reason other than someone not wanting to use a component plugin as part of their build step. Not requiring the use of plugins could just make things easier for some people.\n. It might be worth adding in a hook for post-processing templates just to make the plugins easier to write as well.\njs\nbuilder.on('before templates', function(){\n   builder.addTemplateType('hbs', Handlebars.compile);\n});\nOr just use a process template event or whatever\n. @ericgj I think you can. You'll see foo.jade in templates, and you'll be requiring require('foo.jade'), I really doubt there would be much to debug there. The plugins already rewrite the builder fields and it works fine. \nAnd if it's from within your application it's not too much to expect to run the build with a plugin. You would be using some other build step to compile the jade templates anyway, this is even easier than that.\nThe idea of having everything in templates converted to strings is to make it template-agnostic. Whether or not plugins decide to use their own section is a whole other issue.\n. That seems like another problem altogether. Very rarely do I find I run component build directly instead of using it through grunt or make. You'd still be teaching this new person how to compile templates anyway.\nYou'll always pre-compile templates for production, but that isn't the only thing you could use the templates section for. I use plain HTML and you could put CSS in there to inject into the page. Also, for smaller applications pre-compiling isn't an issue and you can just compile templates on-the-fly. This approach would be flexible, it's simple, and it solves most use-cases.\n. Any opinion on this @visionmedia?\n. Could be worth trying out as a build option and see how it goes. If it seems to be a bit intrusive it could be removed. Although, doing this with a plugin is stupidly easy. It just could be nice knowing we'd be able to share components with plain HTML not require a build or a plugin. \n. You could require an .xml by putting it into the templates section. This could arguably be using it for the wrong purpose and maybe a more generic data or strings section could be better. It's really just semantics\u2026 \nI might take a look at this tonight.\n. Alternative idea, they could go into the scripts section and we just parse anything that isn't a js file into a string.\nI still prefer the templates idea though. Plugins can easily process templates and pull them out before we create strings from them, meaning it will still work with plugins. If you really don't want to use templates this way in your component, you could just put them into the files section or ignore templates.\n. Using strings is the least opinionated option and this isn't just for HTML \n. If you really need on-the-fly loading, you can use RequireJS to just load CommonJS modules or a built component. You don't need to use the AMD syntax for that. \n. I had to do something similar. I needed separate builds of a complex page for A/B testing. In a single project now I have \"bundles\", basically components that are build as separate files for use on the site, as well as a shared local components folder.\nIt looks like this:\n/scripts\n   /shared\n   /bundles\n      /quote\n         /build\n         /components\n         index.js\n         component.json\n      /quote-alt\n         /build\n         /components\n         index.js\n         component.json\n      /base\n         /build\n         /components\n         index.js\n         component.json\nI use grunt along with grunt-component-build to run the custom component build on each folder in bundles. This means that each bundle is completely isolated with it's own components folder but they all use local components in shared. There is no component.json at the root.\nThe grunt build runs component install on each folder using grunt-component-install, then runs the build, runs tests, uglifies etc. \nThis way is much more independent than having a single manifest file. You could do this with a makefile pretty easily as well, but I'm using grunt to do a bunch of other things too. The grunt plugins work dynamically, so I can add new \"bundle\" and they'll get automatically built, minified, linted etc.\n. @tomaskuba That's by design. That's how Component works, it needs to know the paths of all files for when it pulls the component down from Github. You can use the component-assets tool to help speed this up if there are lots of images. \nnpm install -g component-assets\n. Don't think the proxy support entirely works yet because we're not using superagent to pull down files at the moment :P\n. Component doesn't support proxies just yet. There's a pull request open for it.\n. Yeah avoid using sudo, it places them in a different place.\n. It could perhaps be the new version of netrc introduced in 0.17.1. Maybe try using 0.17.0 and see if it fixes the problem.\n. I'm keen to help out on this.\n. Kind of related: I started building a registry that would work like the wiki. Running 'component publish user/project' would just look at the project in github and just add a row with a name, description and some keywords. It could handle looking up tags, possibly the semver logic etc.\nPlus it wouldn't need auth since it just looks at GitHub instead of uploading anything. Updating a package is just running publish again. Seems simple enough to work and feels Component-y :)\n. Also, it wouldn't be required to use Component, it's just a separate tool to make life easier. \n. This will mean we can finish proxy support too\n. You can already do that.\n\"dependencies\": {\n   \"component/model\": \"develop\"\n}\n. You shouldn't need to worry about dependency order with a module system. If you're using libraries that provide and rely on globals though, it's probably not a good idea. \n\nOn 1 Oct 2013, at 8:26 am, Dqubes notifications@github.com wrote:\nIs there a way to define a dependency-order without actually depending on other component?\nFor instance, the angularjs component should not necessarily depend on jQuery, but if it is included, it should be included before angularjs (optional depenancy).\n\u0081\\\nReply to this email directly or view it on GitHub.\n. This we mean we need to force people to put the version in the component.json. I'm always lazy and leave it out :p but if it's used, it would be worth it. \nOn 3 Oct 2013, at 6:17 am, Ian Storm Taylor notifications@github.com wrote:\nthis is slightly related to #104. the problem is that if i have a simple Makefile of:\ncomponents: component.json\n  @component install --dev\neven if i upgrade the version of a dep in component.json, the install will just see that the dep's folder exists (even if it's an older version) and not upgrade it.\nnpm handles this nicely so that it will always upgrade if you've changed the version you rely on in package.json so a similar make node_modules command will always keep you update to date as expected\n\u0081\\\nReply to this email directly or view it on GitHub.\n. Check out Yo and the generators. It's another quick alternative to component-create. I made one for work so people didn't need to think about where things even needed to live in the project. \nOn 9 Oct 2013, at 3:57 am, Ian Storm Taylor notifications@github.com wrote:\ni wouldn't use it just because i rarely know all the methods to start with when i open a file, and just by writing either the logic itself, or the docblock comments, i figure out what should happen. that, and apart from our private views, our files aren't all that similar.\nprefer writing the stuff out because either:\nyou'll quickly realize through lots of writing which pieces should be modularized\nyou'll realize through lots of writing that you're making things more complicated than you should be :)\nno harm if you dig it though.\nwhat i'd really like to see is a way to make component-create pluggable (since i have my own preferences for projects) or at least more fully fleshed out.\n\u0081\\\nReply to this email directly or view it on GitHub.\n. I would be up for this. Putting it in scripts could be weird but it could\njust be more pragmatic\n\nOn Thu, Oct 17, 2013 at 2:19 PM, Qiming zhao notifications@github.comwrote:\n\n[image: :+1:] I can forget to use -u component-json which not always\nresolved correctly.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/421#issuecomment-26476694\n.\n. There's a previous issue talking about this. I think the vote was to not add support as it adds unnecessary complexity as nearly all Component packages don't use the v prefix. I'm sure you could sway @visionmedia with a pull request though.\n. This is another case where having a 'registry' type thing that knows about all packages could be handy as it could do the resolution for us, and could allow for semver. But I do like not having to worry about a registry though...\n. This sounds amazing. I\u2019m keen to help out with this wherever I can.\n. Plugins would be nicer if they were just installed globally once, they would use their own field, and then component build transparently apply all plugins it can find. Then to use a component that needs a plugin you just need to make sure it has been installed once, then blamo.\n\nNo idea how that would work though.\n. Yeah we really need to add some better documentation. Probably redo component.io too. All the people who use component heavily have probably just figured it out by reading the code. Component is so much better than other solutions out there and we really need more people writing about it.\nThe annoying bit is getting a site designed so we have a place to put the docs. I don't really have the time at the moment to design anything but I'll happily write some articles or review other peoples.\n. That's a really good place to start. We can just add folders with markdown files of docs explaining things. When we get something solid together we can put a site together.\nHere are a bunch of docs I put together for my last company https://github.com/nib-components/fed-docs/tree/master/Component I'm sure @chrisbuttery won't mind if we move them into the guides.\n. Semver. Meh. Don't think I've needed the entire past year. It's a little overrated.\n. @timoxley True, but if your app is working and you've got fixed versions everywhere, then your app won't ever break. With the fuzzy semver version you could break your app if the author is a jerk about their versioning.\n. That would be super handy. Half of my time debugging is doing this haha\n. I usually just dump those things on the page as their own script tags. Shims are just expected environment variables, I think, since they're usually manipulating the globals anyway.\n. A browser feature list could be interesting. Then Component can check the environment to make sure those things are there. A little out-of-scope probably.\njs\n\"env\": [\n   \"classList\",\n   \"addEventListener\"\n]\n. https://polyfill.io \nJob done.\n. Adding a linter builder plugin could make the most sense for this I think. That way it could just pick up a bunch of different things including syntax errors.\n. component build --use lint\nor something.\n. Why not just have two bundles? A common one and another one? Or just the one build and then require things in the next script?\nhtml\n<script src=\"build/build.js\"></script>\n<script>\n   var Emitter = require('emitter');\n   // rabbit jazz here\n</script>\nor \nhtml\n<script src=\"bundles/common/build/build.js\"></script>\n<script src=\"bundles/rabbits/build/build.js\"></script>\nThen just have multiple component builds.\nThe second build can leave out the require definition if you want, but I find that gets to complicated and you're better off leaving everything standalone and suck up that extra 2kb of overlap. \n. Not if you have separate components\nbundles/\n   common/\n      component.json\n      build\n   rabbits/\n      component.json\n      build\nWriting a makefile that builds all components in that folder is easy too.\n. ^ what that guy said\n. Woah, I totally forgot about component-bundle. Nice.\n. Nifty trick that could be useful for you is exporting the require function from your common build and making it standalone\nmodule.exports = require;\nThen, lets say you build it like component build --standalone common, you could do\nvar Emitter = common('emitter');\nFor situations like this everyone is going to approach it differently. Hopefully one of these solutions works out for you. Whatever floats your boat.\n. This has come up a few times in the past and I think the idea has been turned down. The reason being that the builder shouldn't store build options within the manifest because it isn't relevant information about the package. It could create weird cases when building with packages that have dependencies with options like these.\n. I'd be open to trying it out. But I still think it messes with concerns a bit too much. It could be nice for \"boot\" components. Maybe open a pull request instead. \n@visionmedia and @ianstormtaylor are going to hate this though :)\njson\n{\n   \"builder\": {\n      \"standalone\": \"myapp\"\n      ...\n   }\n}\n. @Paulmicha We're currently using Component for all of our CSS, and have been for a while, with a Makefile to run Myth over the built file and using Suit for some utils. Works a treat and highly recommended. Just use a makefile and everything is nice and simple.\n. Well I mean you'll probably have some sort of build tool, and in that you'll probably be running a minifier over it, so just run Myth/Rework over it too :) \n. Couple of thoughts after reading all of this:\n- The idea of throwing at mismatch is the safest option I think, but this could be run with a build/install flag instead. I'd rather make sure I have a build that is guaranteed to work. Having CSS just override each other silently just isn't a viable option. Maybe we could add a bit of complexity and only throw an error if there is a mismatch in a component with CSS.\n- Splitting everything in a ton of different repos can seem nice, but we don't want to go overboard with it. Keeping things together is sometimes cleaner than the maintenance overhead. There's no reason the CLI tool and component.js can't be together, right? \n- I personally don't think there should be a strong focus on install speed. Slow builds suck, but mysteriously broken builds and lack of semver suck more. Sure, you save a few seconds, but we still don't have semver, so lets just get something working and improve from there.\n- In the wild CSS conflicts don't happen that often. I can't remember the last time I'd had an issue with it even though each new version just blasts the previous one. There are only a few cases where you'll be using someone else's CSS since it is something that is really unique to your own app. There are utility libraries like suitcss but even they won't change that often and can be pegged as root dependencies. There are things like structural styles in UI components that could break, but even they don't actually change that much across versions.\n- Globbing just isn't needed most of the time. If someone is building a big app it will be internal and they can just use something like component-assets to fill out the manifest. You could even add that to your Makefile before build and you'd never have to worry about it.\nWhat's the goal with this branch? Semver? Or just code quality/organization? There have been a lot of sweeping changes to Component for 1.0. That has had me a bit worried tbh.\nI think we're trying to make too many changes at once here. It's going to be unmanageable and unreleasable. We should pull back and make smaller, incremental changes.\nMaybe there is some other way we could handle CSS that we haven't thought of yet as well. I think we're screwed until we get real web components. Hell, just drop support for CSS in remote components and it wouldn't be a problem ;)\n. I really don't know why we just don't store all the package names/locations/tags on a server somewhere and just call that instead. Hell, the clients could just download and update that locally and all the resolution would be done locally, then just fetch the files from github old-school. When you run crawl it could just post the updates to that server.\nI could even try and build it today.\nUsing the API to get tags and files is going to cause lots of issues like this unless Github removes the rate limiting.\n. We'd need to have some sort of publish step with that wouldn't we? I don't really mind having to do that, it's better than other options :P\n. @jonathanong have you started on this? I could take a look at it\n. Yeah that's why I thought you'd need the \"publish\" step to tell it about the tags so it doesn't need to do any fetching.\n. just looked at the way bower does it, it calls git ls-remote --tags git@github.com:ripplejs/ripple.git to get the tags. It's slow, but you'd cache them. Remote adapters would create the git url.\nJust another option.\n. Woah, looks like the project has somehow fetched tags from another project.\n. No idea. But a little worrying. Deleted all those and it's fine now.\n. It would be nicer if this was the other way around. At least it would stay consistent with pre 1.0\n. Yeah good point\u2014\nSent from Mailbox for iPhone\nOn Sat, Apr 19, 2014 at 11:53 AM, Jonathan Ong notifications@github.com\nwrote:\n\n@anthonyshort it'll be more difficult to use without aliases\n@kazupon why would you use this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/pull/554#issuecomment-40877571\n. Too many options is usually just a sign that a tool is doing too much and needs to be split, or isn't opinionated enough so it's not as useful. That's generally why component has it's CLI kept small, and plugins can extend it. \n. I agree though, --no-auto is useful :p\n. \n",
    "smagch": "Really? Only 1.x syntax? No >, >=, <, <=, ~ syntax? How can I specify a version when I want a module greater than 1.3 and less than 2.0? Requiring 1.3.x will be likely to produce duplication because other module would require 1.2.x at the same time. Optimistic dependencies declaration is what semantic versioning is good at.\n. > a little duplication until resolved is better than a lot of broken apps\nFair enough. I haven't had a serious issue that minor/patch upgrade of modules break my app. When I first used npm and saw semantic versioning spec, I though it's really cool. I though it's cool to use the latest source without being afraid of breaking an app.\nAs long as I use only public API method of a module, it won't break my app with minor/patch upgrade theoretically unless the module author break semantic versioning convention. I know it isn't actually; I'm always locking uglifyjs's version in order to make sure minification succeed.\nAnyway, I'm glad to hear that ~ syntax is to be supported.\n. composer uses \"dev-{branchname}\" syntax for specifying a branch. So \"dev-master\" fetches from master branch. http://getcomposer.org/doc/02-libraries.md#branches\nI found no spec for this kind of stuff on component wiki.\n. Right. I think \"dev-{branchname}\" is ugly feature to be avoided.\n. npm and component is quite different thing. I think no package/dependency manager is discouraging people from using other package managers. It seems there are lots of stuff to be discussed. It might be good to move on to Google Group for further discussion.\n. As I see Issue #148, * is going to reference the latest tag. So component-add command doesn't really make sense. Once semver matching would be implemented, I think tilde ~ syntax is going to be the default one as npm does.\n. Ah, component-add is supposed to just add the latest tag without installing. Why not compoent-info and write by hand?\nI don't think adding a specific version of dependency is good idea because it'll be likely to cause duplication when other module require the same module of other specific version.\n. #150 \n. I've just wrongly submitted comment. I personally prefer component-update to tiny utility command like this.\n. If I'm not misunderstanding component-add feature, it should be used like following.\nshell\n$ component add component/each\n$ component add component/tip\n$ component install\nWhat if I forgot doing component install after component-add? And then I wrongly git-commit the change of component.json? It's scarcely at this point. I would suggest component-outdated might be useful. I don't really use npm outdated though :p \n. I use npm home command quite often. I end up with googling when a module I search doesn't have .repository field.\n. It's handy. But it might bring complex specification in the future. Because someone would say that .xml or .txt should be required as well. At this point, I think it's better to keep doing component-convert rather than simplifying development process.\n. Ah, I didn't look into discussion details. I missed the whole point. I'm +1 for native string require. But I'm -1 for .templates field name. Let's use .files. Oh, .files is already on the spec. I would suggest .readable is the way to go.\njson\n{\n  \"readable\": [\"foo.html\", \"bar.html\"]\n}\n. It might be a good idea to contribute a component standalone app boilerplate to H5BP. \n. ",
    "wyuenho": "\nno matter how much you try and follow semver there's always things you'll get wrong, regressions happen, even if your release promises a bugfix it may introduce other bugs :D\n\nThat pretty much sums up supporting semver probably should be done anyway. You can't prevent other people from breaking things and not supporting it just confuses people because that breaks the convention. It took me a while to figure this out as it is not mentioned in the docs.\n. Any progress on this front BTW? \n. If you could break this out into a list of smaller tasks then new people will probably have an easier time to help out if they want to. This issue is pretty critical I think.\n. What is this registry you speak of and why do you need one?\n. Doesn't say why tho. I don't see a functional dependency between a registry and semver support.\n. Why would you move this computation to the server? Traversing a dep graph is potentially expensive, and also for redundancy's sake, in case the registry goes down, you'll still need to be able to fetch from github/bitbucket etc, like how component already does anyway. A registry is good for searching but that's pretty much it.\n. :+1: \n. semver resolution on the server would make writing clients easy, but that shouldn't be the first thing to worry about unless the registry and related work can be done quickly?\n. My point is, for robustness, semver resolution will have to be done on both sides anyway...\n. ",
    "Swatinem": ":+1: for ~ x.y.z versioning\n. Well I\u2019ve tried the sourceurl option (which is now the default with --dev) and with Firebug, I have per source file a giant string with \\n embedded instead of split across multiple lines. And I can\u2019t set breakpoints and whatnot.\nSo from a development point of view, this is even worse since I either have to console.log() everything or expose closure vars to the global scope in order to inspect them at runtime.\nSo while sourceurl may give you better stacks in case have an uncaught exception (which ideally should not happen) it actually makes things worse for the case where you are developing the software.\n. Thanks for the pointer. I will try that when I have some time.\nI guess whats missing is good tooling support. When I tried sourceurl last time, firebug didn\u2019t seem to have the ability to display these virtual files the same way it displays real files. Maybe Chromes Dev Tools can do that properly?\nI really have to try this for myself before I continue the discussion :-D\n. Yep. Chromium does transparently support sourceurl functions as if they\nwere files. Neither firebug nor the new dev tools in firefox do. :-(\nHipster devs, Y U NO LIKE firefox? :-D\nAm 18.12.2012 18:36 schrieb \"TJ Holowaychuk\" notifications@github.com:\n\nthe JSON.stringify isn't necessary, we could just escape the quotes,\nactually we'll have to escape the quotes because old browsers obviously\ndont have JSON haha\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/pull/175#issuecomment-11496827.\n. yup.\n. As far as I understand, you have to define the default middleware manually as well in a build script, right? Thats one of the reason why it is so highly redundant and copy-pasty.\n\nIts also that I might want to have two different builds, one with component-jade, one with component-jade + component-istanbul.\nThen I would either have to do separate build files, or one which has option parsing (might be as simple as one argv) logic.\nI just think make/shell is more convenient.\n. ",
    "jasonkuhrt": "Based on my limited experience the use-cases I've hit the most are:\n- Using semvar to spec an exact version 1.2.3\n- Using semvar to bind on the latest patch 1.2.x (despite caveats noted in this thread)\n- Using a git tag (if people are semvar tagging then it ends up being equatable to using semvar, just less direct)\n- Using a git commit id\n- Using a git branch name (implicitly meaning the HEAD of that branch)\n- Using '*' to imply a git master branch HEAD seems fair\nnpm offers a boat-load of options I've never memorized or used.\n. Not to rule out all of @Nami-Doc's use cases but I generally agree with @visionmedia about not replacing make et al. That said, maybe there's another valid reason.\n. The global require can be solved by using angularjs inside brunch.\n@visionmedia But how does the component build process elegantly work within brunch? Brunch can concatenate all my files in the app etc. I don't really need/want components build step?\n. @visionmedia I'm aware of it but the Readme leaves me somewhat confused of its full power. I will just give it a go in brunch and see if I can create a coherent seed repo. I will report back into this issue (even if it just became closed =)) with problems I encounter\n. @visionmedia Brunch is an application assembler like the new yeoman project. It creates a platform for common app build patterns (i.e. brunch can transpile languages, minify, lint, wrap all files in commonjs, etc.)\n. @visionmedia I guess you feel that instead of using an application assembler you could just roll your own build process via make? That's fair enough too, but in practice I've wasted time trying to manage transpiling each language in an app (typically LiveScript, Jade, Stylus), and creating a pleasant build step. Maybe some people like grunt, not me.\n. Interesting.... so eventually component-builder is going to become an application assembler, or not at all? I.e. in the compile step can arbitrary things be done, appropriate for building an application? Will generators be supported? etc.\n. @visionmedia thanks for explaining a little. \nWhat's your take on angularjs (directives especially) and meteorjs? The angjs guys and metjs guys have said they are talking to one another to make their projects play excellent together. I love the commonjs and focused nature of components, I love the database concept and deployment story of meteor, and I love directives. Kind of sucks that none of the 3 play well together =\\\nI guess that's the whole concept of component: start making stuff play well together!!!\n. @visionmedia another question: is components the right avenue for sharing stylus modules? ...\n. @visionmedia It would be best if you spend a half-hour learning about directives yourself (better than me trying to half-ass explain it). Start here? http://angularjs.org/ (see last example).\nBut basically directives allow users to extend html to create new tags or attributes, and have them do anything, and have multiple new tags and/or attributes interact with one another in anyway. You create DSLs for your app, and you make creating apps a declarative process? etc...\nIf you google it there's lots and lots out there. I think you'll not-like it, but it would be useful for you to learn about I think... (project ideas, technical ideas, etc.)\nIn general angularjs basically puts a compiler in the client.\n. @visionmedia I think I know what the problem is, sec...\n. @visionmedia the problem was that I didn't have a completed component.json.\nNext problem is that now I am getting Error: failed to require \"components\" from \"root\" (in browser) where my component.json looks like:\n```\n{\n  \"name\": \"components\",\n  \"dependencies\": {\n    \"component/emitter\": \"\",\n    \"component/enumerable\": \"\"\n  }\n}\n```\nAnd my standalone code section looks like:\n```\nrequire.alias(\"component-emitter/index.js\", \"components/deps/emitter/index.js\");\nrequire.alias(\"component-enumerable/index.js\", \"components/deps/enumerable/index.js\");\nrequire.alias(\"component-to-function/index.js\", \"component-enumerable/deps/to-function/index.js\");\n  if (\"undefined\" == typeof module) {\n    window.components = require(\"components\");\n  } else {\n    module.exports = require(\"components\");\n  }\n``\n. @visionmedia Pardon, I misunderstood--standalone. It exposes your component but not your component's dependencies.\n. @visionmedia sure, I see that, but if I want each dep to be shoved ontowindow(don't ask...)? I understand now that is not at all what-sis about.-sis just for shoving _your_ component ontowindow.\n. @visionmedia Ah, thanks\n. @visionmedia err, wait, what does that \"look\" like? I don't see anything documented here: https://github.com/component/component/wiki/Spec\n. @visionmedia Ya I saw it just before you commented again. You had good 'ol minimal docs! =) My bad man. I thought that you''re top-levelpackage.json` example was demonstrating every possible field...\n. The example or the rationale?\nCurrently the above example would do this:\n```\n\ncomponent build -s components/.component-init.js\n\n...\nwindow.components/.component-init.js = require('components/.component-init.js')'\n^ ERROR!\n```\nSo what this issue is about, is, being able to decouple the window name from the required name. Make sense?\n. @visionmedia yup. But then what you're saying is component doesn't support [1] non-valid-identifier names like foo-bar for component names? Since as you see in the above example that would break, again:\n```\n\ncomponent build -s foo-bar\n\n...\nwindow.foo-bar = require('foo-bar')'\n^ ERROR!\n```\n1 Edit: Doesn't support them IF you have to make your component --standalone.\n. @visionmedia ... Ah. : )\n. @visionmedia Maybe component build ... --no-symlinks could suffice. Do you think symbolic links will break things often? If so reverse the option so that symlinks are opt-in: component build --use-symlinks Given such a CLI flag it then could be used intelligently for builds: keep things fast in dev and only hit slow builds once for prod.\nSymbolic links feel elegant and light, it's a nice thing... but seriously I'm beginning to be a huge advocate for KISS. The simplest thing is no-config and if you think that checking mtimes will abate bad performance than man, just go that route : )\n. @visionmedia yup, avoid extra docs. Relying on --dev could be a nice and overhead-less compromise. +1\n. I'm confused about what the proposed workflow would be versus what it is now.\n. That's great. I will try to submit a pull-request for better documentation then.\n. I basically agree that --use is a legitimate feature. I-think-but-cannot-proove that a non-trivial quantity of use-cases benefit from it. It just makes intuitive sense, but I agree with everyone that good interface behaviour here is complicated (harder than complex). I don't think the current programatic .use(...) is even right yet so that precludes any serious discussion of --use for me.\n@visionmedia As far as the passing of options goes that does not seem like that hard of a problem to solve. Either improve the CLI parser with --use foobar 'key=value, key=value or we create a way for field names in component.json that match the plugin to be applied to said plugin at --use time. In fact both might be worth supporting. Lots of ways to make this work and work well.\n. @jonathanhefner generally I like, seems quite usable, and multiple bundles fall out of this super simply, no? I assume that all plugins would first check node_modules/.bin/* and then only if not found there look up the bin path.\n. @stephenmathieson Hm not against the idea at all but another file to specify a few fields is not great for the end user. Too much modularity for the end goal in a lot of use cases I would imagine. \n. This has nothing to do with @ai's autoprefixer.\nThe issue is css-url-rewriter (https://github.com/callumlocke/css-url-rewriter/blob/master/lib/css-url-rewriter.js) has regexp that reads url(...) (http://refiddle.com/refiddles/match-multiple-urls-within-a-css-property-value) which component/builder2.js (https://github.com/component/builder2.js/blob/master/lib/plugins/url-rewriter.js#L27-L39) treats AS IF IT WERE just the ... part (from above), see:\n[...]\n      file.string = rewriteCSSURLs(string, function (uri) {\n        var orig = 'url(' + uri + ')';   // <<<<<<< ERROR url(url(...))\n[...]\nSo the bug is in component/builder2.js\n. @jonathanong @callumlocke Hey guys at this time, a fix is required in one of or both:\n- https://github.com/callumlocke/css-url-rewriter/blob/master/lib/css-url-rewriter.js#L50-L52\n- https://github.com/component/builder2.js/blob/master/lib/plugins/url-rewriter.js#L27-L39\nBefore diving into a pull-request I would like to vet the direction to take and if you want to fix yourselves.\nA fix in component/builder2.js might look like:\n``` js\n      file.string = rewriteCSSURLs(string, function (justURL) {\n        if (isData(justURL)) return justURL;\n        if (isAbsolute(justURL)) return justURL;\n    // IS THERE A BUG HERE TOO?\n    justURL = resolve(file.path, justURL);\n    justURL = resolve(prefix + utils.rewriteUrl(branch) + '/', justURL);\n    return justURL;\n  });\n\n``\n. I think this is a useful feature. For example, if you want to ship react components but also have a local \"solo\" development environment then off--no-auto` is useful because ultimately you're going to bootstrap the solo component like this:\nrequire('foo-component)({ ... })\n. I also don't understand the argument of being against many options in its own right. Many command line tools have many options, sub-commands and sub-command options that turn out to have a well defined interface and purpose. \"Too many options\" is not a constructive criticism.\n. @anthonyshort Agreed but I don't think that goes deep enough to be genuinely useful.\nClarification e.g.: component open isn't worth it, component build --no-auto is. I am stating the obvious, sorry, but the decision for these has nothing to do with counting the options list up to a subjective number. The aws(1) is complex, probably much more than is(1), but still  simple, maybe simpler. That's because of properly applied design patterns. too many options in its own right isn't worth its weight as a design critique, that's all.\n. I see that component-downloader goes from here\nhttps://github.com/component/downloader.js/blob/master/lib/fields.js#L56-L67\nfunction* download(path) {\n    var url = encodeURI(remote.file(repo, ref, path)[0]);\n    var destination = join(folder, path);\n    debug('downloading \"%s\" to \"%s\"', url, destination);\n    var res = yield* remote.request(url);\n    if (res.statusCode !== 200) {\n      res.destroy();\n      throw new Error('Error downloading \"' + remote.name + '//' + repo + '@' + ref + '\". Got status code \"' + res.statusCode + '\"');\n    }\n    yield write(res, destination);\n  }\n}\nthrough to here ?\nhttps://github.com/component/remotes.js/blob/master/lib/remotes/github.js#L153-L160\nGitHub.prototype.file = function (repo, ref, path) {\n  if (typeof path === 'object') path = path.path;\n  var tail = repo + '/' + ref + '/' + path;\n  return [\n    'https://raw.githubusercontent.com/' + tail,\n    'https://raw.github.com/' + tail,\n  ]\n}\nClearly there is nothing here for authentication. I've tried putting in my .netrc file:\nmachine raw.githubusercontent.com\nlogin ***\npassword ***\nWhich has no affect seemingly.\n. It seems that github will only facilitate downloading of private files via api.github.com. http://stackoverflow.com/questions/18126559/how-can-i-download-a-single-raw-file-from-a-private-github-repo-using-the-comman\n. This seems to be working now, I don't know why.\n. @jonathanong a bug that has yet to be rolled into component/component?\nAre you saying that if a component.json has .name of \"foobar\" that downstream should be able to just require('foobar')?\n. @jonathanong Ok sweet seems to be working now!\n. Generally what I am getting at is there is a surprising and subtle (aka terrible) interplay between ./components and component.json that influences how component(1) behaves. I believe the current behaviour to be bad, but worse still is there are no warnings or explanations of what's going on even if current behaviour is exactly as desired implementation-wise.\nNot ragging, lets just make it better.\n. @dominicbarnes 1.0.0-rc5.\n. @dominicbarnes Here is a debug flow. This is yet another issue not listed above.\n~/projects/cloud-client-api-http\n\u29d1 cat component.json                                                                                                                                                    \n{\n  \"name\": \"littlebits-cloud-http\",\n  \"version\": \"0.0.3\",\n  \"description\": \"Lightweight wrapper for littleBits Cloud HTTP API\",\n  \"main\": \"index.js\",\n  \"scripts\": [\n    \"index.js\",\n    \"lib/customizations.js\",\n    \"lib/make-method.js\",\n    \"lib/method-process-signature.js\",\n    \"lib/route-utils.js\",\n    \"assets/routes.js\"\n  ],\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"lodash/lodash\": \"^2.4.1\",\n    \"visionmedia/superagent\": \"~0.18.0\"\n  }\n}\nI change my ./component.json via superagent ~0.18.0 to ~0.17.0\nFail:\n```\n~/projects/cloud-client-api-http\n\u29d1 DEBUG=* c install                                                                                                                                                 \n  remotes:local checking local components at /Users/jasonkuhrt/projects/cloud-client-api-http/components +0ms\n  component-resolver remote not set - defaulting to remotes's defaults +0ms\n  component-resolver:locals resolving local at \"/Users/jasonkuhrt/projects/cloud-client-api-http\" +0ms\n  component-resolver resolving \"littlebits-cloud-http\" +6ms\n  component-resolver remaining dependencies: 2 +4ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver finished resolving locals +0ms\n  component-resolver finished resolving dependencies (1) +0ms\n  component-resolver:semver resolving semver lodash/lodash@^2.4.1 +0ms\n  remotes:local resolving local remote +14ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +1ms\n  remotes:local got folders: 2.4.1 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +0ms\n  remotes:local got folders: 2.4.1 +1ms\n  component-resolver:dependencies resolving dependency lodash/lodash@2.4.1 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for lodash/lodash@2.4.1 +1ms\n  remotes:local resolving local remote +2ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +0ms\n  remotes:local got folders: 2.4.1 +0ms\n  component-resolver:dependencies found lodash/lodash@2.4.1 from remote \"local\" +2ms\n  component-resolver resolving \"lodash/lodash\" +7ms\n  component-resolver remaining dependencies: 0 +0ms\n  component-resolver remaining semver: 2 +0ms\n  component-resolver:semver resolved semver lodash/lodash@^2.4.1 -> lodash/lodash@2.4.1 +7ms\n  component-resolver:semver resolving semver visionmedia/superagent@~0.17.0 +0ms\n  remotes:local resolving local remote +3ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash/2.4.1\" exists, skipping downloading. +0ms\n  remotes:local got folders: 0.18.0 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent +0ms\n  remotes:local got folders: 0.18.0 +0ms\n  component-consoler Error: invalid semver range \"~0.17.0\" for \"visionmedia/superagent\"\n    at Resolver. (/usr/local/share/npm/lib/node_modules/component/node_modules/component-resolver/build/semver.js:624:13)\n    at Generator.invoke (/usr/local/share/npm/lib/node_modules/component/node_modules/component-resolver/build/index.js:141:31)\n    at Generator.invoke (/usr/local/share/npm/lib/node_modules/component/node_modules/component-resolver/build/index.js:79:50)\n    at next (/usr/local/share/npm/lib/node_modules/component/node_modules/co/index.js:77:21)\n    at /usr/local/share/npm/lib/node_modules/component/node_modules/co/index.js:96:18\n    at ReaddirReq.Req.done (/usr/local/share/npm/lib/node_modules/component/node_modules/component-resolver/node_modules/graceful-fs/graceful-fs.js:143:5)\n    at ReaddirReq.done (/usr/local/share/npm/lib/node_modules/component/node_modules/component-resolver/node_modules/graceful-fs/graceful-fs.js:90:22)\n    at ReaddirReq.Req.done (/usr/local/share/npm/lib/node_modules/component/node_modules/remotes/node_modules/graceful-fs/graceful-fs.js:143:5)\n    at ReaddirReq.done (/usr/local/share/npm/lib/node_modules/component/node_modules/remotes/node_modules/graceful-fs/graceful-fs.js:90:22)\n    at Object.oncomplete (fs.js:107:15) +0ms\n   error : invalid semver range \"~0.17.0\" for \"visionmedia/superagent\"\n\n```\nWhat?\nOh:\n~/projects/cloud-client-api-http\n\u29d1 rm -rf components/visionmedia/superagent\nOk lets try again...\n```\n~/projects/cloud-client-api-http\n\u29d1 DEBUG= c install                                                                                                                                                 \n  remotes:local checking local components at /Users/jasonkuhrt/projects/cloud-client-api-http/components +0ms\n  component-resolver remote not set - defaulting to remotes's defaults +0ms\n  component-resolver:locals resolving local at \"/Users/jasonkuhrt/projects/cloud-client-api-http\" +0ms\n  component-resolver resolving \"littlebits-cloud-http\" +6ms\n  component-resolver remaining dependencies: 2 +4ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver finished resolving locals +0ms\n  component-resolver finished resolving dependencies (1) +1ms\n  component-resolver:semver resolving semver lodash/lodash@^2.4.1 +0ms\n  remotes:local resolving local remote +16ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +0ms\n  remotes:local got folders: 2.4.1 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +1ms\n  remotes:local got folders: 2.4.1 +0ms\n  component-resolver:dependencies resolving dependency lodash/lodash@2.4.1 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for lodash/lodash@2.4.1 +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +0ms\n  remotes:local got folders: 2.4.1 +1ms\n  component-resolver:dependencies found lodash/lodash@2.4.1 from remote \"local\" +2ms\n  component-resolver resolving \"lodash/lodash\" +5ms\n  component-resolver remaining dependencies: 0 +0ms\n  component-resolver remaining semver: 2 +0ms\n  component-resolver:semver resolved semver lodash/lodash@^2.4.1 -> lodash/lodash@2.4.1 +6ms\n  component-resolver:semver resolving semver visionmedia/superagent@~0.17.0 +0ms\n  remotes:local resolving local remote +2ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash/2.4.1\" exists, skipping downloading. +0ms\n  remotes:github GET \"https://raw.githubusercontent.com/visionmedia/superagent/master/component.json\" +0ms\n  cogent options: { protocol: 'https:',\n  slashes: true,\n  auth: 'jasonkuhrt:314314Dd',\n  host: 'raw.githubusercontent.com',\n  port: null,\n  hostname: 'raw.githubusercontent.com',\n  hash: null,\n  search: null,\n  query: null,\n  pathname: '/visionmedia/superagent/master/component.json',\n  path: '/visionmedia/superagent/master/component.json',\n  href: 'https://raw.githubusercontent.com/visionmedia/superagent/master/component.json',\n  headers:\n   { 'accept-encoding': 'gzip',\n     'user-agent': 'https://github.com/cojs/cogent',\n     accept: 'application/json' },\n  method: 'GET' } +0ms\n  remotes:github GET \"https://api.github.com/repos/visionmedia/superagent/tags\" +366ms\n  cogent options: { protocol: 'https:',\n  slashes: true,\n  auth: 'jasonkuhrt:314314Dd',\n  host: 'api.github.com',\n  port: null,\n  hostname: 'api.github.com',\n  hash: null,\n  search: null,\n  query: null,\n  pathname: '/repos/visionmedia/superagent/tags',\n  path: '/repos/visionmedia/superagent/tags',\n  href: 'https://api.github.com/repos/visionmedia/superagent/tags',\n  headers:\n   { 'accept-encoding': 'gzip',\n     'user-agent': 'https://github.com/cojs/cogent',\n     accept: 'application/json' },\n  method: 'GET' } +363ms\n  component-resolver:dependencies resolving dependency visionmedia/superagent@0.17.0 +1s\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for visionmedia/superagent@0.17.0 +0ms\n  remotes:local resolving local remote +1s\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent +0ms\n  remotes:github GET \"https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/component.json\" +714ms\n  cogent options: { protocol: 'https:',\n  slashes: true,\n  auth: 'jasonkuhrt:314314Dd',\n  host: 'raw.githubusercontent.com',\n  port: null,\n  hostname: 'raw.githubusercontent.com',\n  hash: null,\n  search: null,\n  query: null,\n  pathname: '/visionmedia/superagent/0.17.0/component.json',\n  path: '/visionmedia/superagent/0.17.0/component.json',\n  href: 'https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/component.json',\n  headers:\n   { 'accept-encoding': 'gzip',\n     'user-agent': 'https://github.com/cojs/cogent',\n     accept: 'application/json' },\n  method: 'GET' } +715ms\n  component-resolver:dependencies found visionmedia/superagent@0.17.0 from remote \"github\" +1s\n  component-resolver resolving \"visionmedia/superagent\" +2s\n  component-resolver:semver resolving semver component/emitter@ +2s\n  remotes:local resolving local remote +1s\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/emitter +0ms\n  component-resolver:semver resolving semver component/reduce@ +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/reduce +0ms\n  component-resolver remaining dependencies: 2 +1ms\n  component-resolver remaining semver: 1 +0ms\n  component-resolver:semver resolved semver visionmedia/superagent@~0.17.0 -> visionmedia/superagent@0.17.0 +1ms\n  component-resolver finished resolving semver +0ms\n  remotes:local got folders: 1.1.2 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/emitter +0ms\n  remotes:local got folders: 1.0.1 +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/reduce +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent +0ms\n  remotes:local got folders: 1.1.2 +0ms\n  component-resolver:dependencies resolving dependency component/emitter@1.1.2 +2ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/emitter@1.1.2 +1ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/emitter +0ms\n  remotes:local got folders: 1.0.1 +0ms\n  component-resolver:dependencies resolving dependency component/reduce@1.0.1 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/reduce@1.0.1 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/reduce +0ms\n  component-downloader resolved visionmedia/superagent@0.17.0 to github +2s\n  remotes:local got folders: 1.1.2 +2ms\n  remotes:local got folders: 1.0.1 +0ms\n  component-downloader downloading \"https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js\" to \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent/0.17.0/lib/client.js\" +2ms\n  cogent options: { protocol: 'https:',\n  slashes: true,\n  auth: 'jasonkuhrt:314314Dd',\n  host: 'raw.githubusercontent.com',\n  port: null,\n  hostname: 'raw.githubusercontent.com',\n  hash: null,\n  search: null,\n  query: null,\n  pathname: '/visionmedia/superagent/0.17.0/lib/client.js',\n  path: '/visionmedia/superagent/0.17.0/lib/client.js',\n  href: 'https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js',\n  headers:\n   { 'accept-encoding': 'gzip',\n     'user-agent': 'https://github.com/cojs/cogent' },\n  method: 'GET' } +1s\n  component-resolver:dependencies found component/reduce@1.0.1 from remote \"local\" +5ms\n  component-resolver resolving \"component/reduce\" +7ms\n  component-resolver remaining dependencies: 2 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver component/reduce@ -> component/reduce@1.0.1 +7ms\n  component-resolver:dependencies found component/emitter@1.1.2 from remote \"local\" +0ms\n  component-resolver resolving \"component/emitter\" +0ms\n  component-resolver remaining dependencies: 2 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver component/emitter@* -> component/emitter@1.1.2 +1ms\n  component-downloader \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/component/reduce/1.0.1\" exists, skipping downloading. +3ms\n  component-downloader \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/component/emitter/1.1.2\" exists, skipping downloading. +0ms\n  component-resolver finished resolving dependencies(2) +1ms\n  cogent timeout exceeded for GET https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js +5s\n  cogent received error \"timeout of 5000ms exceeded for \"https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js\"\" with \"https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js\" +1ms\n  component-consoler Error: timeout of 5000ms exceeded for \"https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js\"\n    at null. (/usr/local/share/npm/lib/node_modules/component/node_modules/cogent/build/index.js:435:23)\n    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15) +0ms\n   error : timeout of 5000ms exceeded for \"https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js\"\n\n```\nHuh?\nTry again?\n~/projects/cloud-client-api-http\n\u29d1 DEBUG=* c install                                                                                                                                                   \n  remotes:local checking local components at /Users/jasonkuhrt/projects/cloud-client-api-http/components +0ms\n  component-resolver remote not set - defaulting to remotes's defaults +0ms\n  component-resolver:locals resolving local at \"/Users/jasonkuhrt/projects/cloud-client-api-http\" +0ms\n  component-resolver resolving \"littlebits-cloud-http\" +5ms\n  component-resolver remaining dependencies: 2 +5ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver finished resolving locals +0ms\n  component-resolver finished resolving dependencies (1) +0ms\n  component-resolver:semver resolving semver lodash/lodash@^2.4.1 +0ms\n  remotes:local resolving local remote +14ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +1ms\n  remotes:local got folders: 2.4.1 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +0ms\n  remotes:local got folders: 2.4.1 +1ms\n  component-resolver:dependencies resolving dependency lodash/lodash@2.4.1 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for lodash/lodash@2.4.1 +0ms\n  remotes:local resolving local remote +2ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash +0ms\n  remotes:local got folders: 2.4.1 +0ms\n  component-resolver:dependencies found lodash/lodash@2.4.1 from remote \"local\" +2ms\n  component-resolver resolving \"lodash/lodash\" +6ms\n  component-resolver remaining dependencies: 0 +0ms\n  component-resolver remaining semver: 2 +0ms\n  component-resolver:semver resolved semver lodash/lodash@^2.4.1 -> lodash/lodash@2.4.1 +6ms\n  component-resolver:semver resolving semver visionmedia/superagent@~0.17.0 +0ms\n  remotes:local resolving local remote +2ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/lodash/lodash/2.4.1\" exists, skipping downloading. +0ms\n  remotes:local got folders:  +0ms\n  remotes:github GET \"https://raw.githubusercontent.com/visionmedia/superagent/master/component.json\" +0ms\n  cogent options: { protocol: 'https:',\n  slashes: true,\n  auth: 'jasonkuhrt:314314Dd',\n  host: 'raw.githubusercontent.com',\n  port: null,\n  hostname: 'raw.githubusercontent.com',\n  hash: null,\n  search: null,\n  query: null,\n  pathname: '/visionmedia/superagent/master/component.json',\n  path: '/visionmedia/superagent/master/component.json',\n  href: 'https://raw.githubusercontent.com/visionmedia/superagent/master/component.json',\n  headers:\n   { 'accept-encoding': 'gzip',\n     'user-agent': 'https://github.com/cojs/cogent',\n     accept: 'application/json' },\n  method: 'GET' } +0ms\n  remotes:github GET \"https://api.github.com/repos/visionmedia/superagent/tags\" +605ms\n  cogent options: { protocol: 'https:',\n  slashes: true,\n  auth: 'jasonkuhrt:314314Dd',\n  host: 'api.github.com',\n  port: null,\n  hostname: 'api.github.com',\n  hash: null,\n  search: null,\n  query: null,\n  pathname: '/repos/visionmedia/superagent/tags',\n  path: '/repos/visionmedia/superagent/tags',\n  href: 'https://api.github.com/repos/visionmedia/superagent/tags',\n  headers:\n   { 'accept-encoding': 'gzip',\n     'user-agent': 'https://github.com/cojs/cogent',\n     accept: 'application/json' },\n  method: 'GET' } +603ms\n  component-resolver:dependencies resolving dependency visionmedia/superagent@0.17.0 +721ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for visionmedia/superagent@0.17.0 +1ms\n  remotes:local resolving local remote +721ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent +0ms\n  remotes:local got folders:  +0ms\n  remotes:github GET \"https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/component.json\" +115ms\n  cogent options: { protocol: 'https:',\n  slashes: true,\n  auth: 'jasonkuhrt:314314Dd',\n  host: 'raw.githubusercontent.com',\n  port: null,\n  hostname: 'raw.githubusercontent.com',\n  hash: null,\n  search: null,\n  query: null,\n  pathname: '/visionmedia/superagent/0.17.0/component.json',\n  path: '/visionmedia/superagent/0.17.0/component.json',\n  href: 'https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/component.json',\n  headers:\n   { 'accept-encoding': 'gzip',\n     'user-agent': 'https://github.com/cojs/cogent',\n     accept: 'application/json' },\n  method: 'GET' } +114ms\n  component-resolver:dependencies found visionmedia/superagent@0.17.0 from remote \"github\" +58ms\n  component-resolver resolving \"visionmedia/superagent\" +780ms\n  component-resolver:semver resolving semver component/emitter@* +779ms\n  remotes:local resolving local remote +59ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/emitter +0ms\n  component-resolver:semver resolving semver component/reduce@* +1ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/reduce +0ms\n  component-resolver remaining dependencies: 2 +1ms\n  component-resolver remaining semver: 1 +0ms\n  component-resolver:semver resolved semver visionmedia/superagent@~0.17.0 -> visionmedia/superagent@0.17.0 +1ms\n  component-resolver finished resolving semver +1ms\n  remotes:local got folders: 1.1.2 +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/emitter +1ms\n  remotes:local got folders: 1.0.1 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/reduce +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent +0ms\n  remotes:local got folders: 1.1.2 +0ms\n  component-resolver:dependencies resolving dependency component/emitter@1.1.2 +4ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/emitter@1.1.2 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/emitter +0ms\n  remotes:local got folders: 1.0.1 +0ms\n  component-resolver:dependencies resolving dependency component/reduce@1.0.1 +1ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/reduce@1.0.1 +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/cloud-client-api-http/components/component/reduce +0ms\n  remotes:local got folders:  +0ms\n  component-downloader resolved visionmedia/superagent@0.17.0 to github +784ms\n  remotes:local got folders: 1.1.2 +2ms\n  remotes:local got folders: 1.0.1 +0ms\n  component-downloader downloading \"https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js\" to \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/visionmedia/superagent/0.17.0/lib/client.js\" +3ms\n  cogent options: { protocol: 'https:',\n  slashes: true,\n  auth: 'jasonkuhrt:314314Dd',\n  host: 'raw.githubusercontent.com',\n  port: null,\n  hostname: 'raw.githubusercontent.com',\n  hash: null,\n  search: null,\n  query: null,\n  pathname: '/visionmedia/superagent/0.17.0/lib/client.js',\n  path: '/visionmedia/superagent/0.17.0/lib/client.js',\n  href: 'https://raw.githubusercontent.com/visionmedia/superagent/0.17.0/lib/client.js',\n  headers:\n   { 'accept-encoding': 'gzip',\n     'user-agent': 'https://github.com/cojs/cogent' },\n  method: 'GET' } +66ms\n  component-resolver:dependencies found component/emitter@1.1.2 from remote \"local\" +5ms\n  component-resolver resolving \"component/emitter\" +8ms\n  component-resolver remaining dependencies: 2 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver component/emitter@* -> component/emitter@1.1.2 +9ms\n  component-resolver:dependencies found component/reduce@1.0.1 from remote \"local\" +1ms\n  component-resolver resolving \"component/reduce\" +1ms\n  component-resolver remaining dependencies: 1 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver component/reduce@* -> component/reduce@1.0.1 +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/component/emitter/1.1.2\" exists, skipping downloading. +3ms\n  component-resolver finished resolving dependencies(2) +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/cloud-client-api-http/components/component/reduce/1.0.1\" exists, skipping downloading. +0ms\n  component-downloader installed visionmedia/superagent@0.17.0 in 76ms +68ms\n   installed : visionmedia/superagent@0.17.0 in 76ms\n  component-resolver finished installing dependencies +70ms\n     install : complete\nIt worked? Oh.\nSo two other issues above there:\n1. A timeout\n2. Having another version of superagent in ./components breaks component install\n. And:\n~/projects/cloud-client-api-http\n\u29d1 c --version                                                                                                                                                         \n1.0.0-rc5\n. I hit this timeout routinely, why was 5000 deemed sufficient?\nSent from my iPhone\n\nOn May 15, 2014, at 17:03, Jonathan Ong notifications@github.com wrote:\nimo it should be a .componentrc file or something, not options. there are already too many options everywhere\n\u2014\nReply to this email directly or view it on GitHub.\n. @lancejpollard not sure but I would be more than happy to contribute tests for the numerous broken flows I've found. Time is always an issue though so if the maintainers @jonathanong et al can whip up a point-form contributing.md template that outlines how to get tests added quickly that would be awesome.\n. Here it is failing:\n\n```\nDEBUG= component build                                                                                                                 \n  remotes:local checking local components at /Users/jasonkuhrt/projects/oauth2-implicit/components +0ms\n  component-resolver remote not set - defaulting to remotes's defaults +0ms\n  component-resolver:locals resolving local at \"/Users/jasonkuhrt/projects/oauth2-implicit\" +0ms\n  component-resolver resolving \"oauth2-implicit\" +10ms\n  component-resolver remaining dependencies: 1 +3ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver finished resolving locals +1ms\n  component-resolver finished resolving dependencies (1) +0ms\n  component-resolver:semver resolving semver yields/store@~0.2.0 +0ms\n  remotes:local resolving local remote +18ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/store +1ms\n  remotes:local got folders: 0.2.0 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/store +0ms\n  remotes:local got folders: 0.2.0 +1ms\n  component-resolver:dependencies resolving dependency yields/store@0.2.0 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for yields/store@0.2.0 +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/store +0ms\n  remotes:local got folders: 0.2.0 +0ms\n  component-resolver:dependencies found yields/store@0.2.0 from remote \"local\" +1ms\n  component-resolver resolving \"yields/store\" +6ms\n  component-resolver:semver resolving semver component/each@ +5ms\n  remotes:local resolving local remote +2ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/each +0ms\n  component-resolver:semver resolving semver component/type@ +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/type +0ms\n  component-resolver:semver resolving semver yields/unserialize@ +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/unserialize +0ms\n  component-resolver remaining dependencies: 3 +1ms\n  component-resolver remaining semver: 1 +0ms\n  component-resolver:semver resolved semver yields/store@~0.2.0 -> yields/store@0.2.0 +1ms\n  component-resolver finished resolving semver +0ms\n  remotes:local got folders: 0.2.3 +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/each +1ms\n  remotes:local got folders: 1.0.0 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/type +0ms\n  remotes:local got folders: 0.0.1 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/unserialize +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/yields/store/0.2.0\" exists, skipping downloading. +0ms\n  remotes:local got folders: 0.2.3 +0ms\n  component-resolver:dependencies resolving dependency component/each@0.2.3 +3ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/each@0.2.3 +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/each +0ms\n  remotes:local got folders: 1.0.0 +0ms\n  component-resolver:dependencies resolving dependency component/type@1.0.0 +1ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/type@1.0.0 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/type +0ms\n  remotes:local got folders: 0.0.1 +0ms\n  component-resolver:dependencies resolving dependency yields/unserialize@0.0.1 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for yields/unserialize@0.0.1 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/unserialize +0ms\n  remotes:local got folders: 0.2.3 +0ms\n  remotes:local got folders: 1.0.0 +1ms\n  remotes:local got folders: 0.0.1 +0ms\n  component-resolver:dependencies found component/each@0.2.3 from remote \"local\" +1ms\n  component-resolver resolving \"component/each\" +3ms\n  component-resolver:dependencies resolving dependency component/to-function@2.0.0 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/to-function@2.0.0 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/to-function +1ms\n  component-resolver remaining dependencies: 5 +1ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver component/each@ -> component/each@0.2.3 +4ms\n  component-resolver:dependencies found component/type@1.0.0 from remote \"local\" +1ms\n  component-resolver resolving \"component/type\" +0ms\n  component-resolver remaining dependencies: 5 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:dependencies resolved dependencies of \"component/each\" +0ms\n  component-resolver:semver resolved semver component/type@ -> component/type@1.0.0 +0ms\n  component-resolver:dependencies found yields/unserialize@0.0.1 from remote \"local\" +0ms\n  component-resolver resolving \"yields/unserialize\" +1ms\n  component-resolver remaining dependencies: 5 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver yields/unserialize@ -> yields/unserialize@0.0.1 +1ms\n  remotes:local got folders: 2.0.0 +1ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/component/each/0.2.3\" exists, skipping downloading. +4ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/component/type/1.0.0\" exists, skipping downloading. +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/yields/unserialize/0.0.1\" exists, skipping downloading. +0ms\n  component-resolver:dependencies found component/to-function@2.0.0 from remote \"local\" +1ms\n  component-resolver resolving \"component/to-function\" +1ms\n  component-resolver:semver resolving semver component/props@ +1ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/props +0ms\n  component-resolver remaining dependencies: 2 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:dependencies resolved dependencies of \"component/each\" +1ms\n  remotes:local got folders: 1.1.2 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/props +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/component/to-function/2.0.0\" exists, skipping downloading. +1ms\n  remotes:local got folders: 1.1.2 +1ms\n  component-resolver:dependencies resolving dependency component/props@1.1.2 +1ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/props@1.1.2 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/props +0ms\n  remotes:local got folders: 1.1.2 +0ms\n  component-resolver:dependencies found component/props@1.1.2 from remote \"local\" +0ms\n  component-resolver resolving \"component/props\" +1ms\n  component-resolver remaining dependencies: 1 +1ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver component/props@* -> component/props@1.1.2 +2ms\n  component-resolver finished resolving dependencies(2) +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/component/props/1.1.2\" exists, skipping downloading. +2ms\n  component-resolver finished installing dependencies +0ms\n       build : resolved in 33ms\n  component-consoler Error: could not resolve \"./lib/cache\" from \"oauth2-implicit\"'s file \"./index.js\"\n    at Scripts.lookupRelative (/usr/local/share/npm/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/build/builders/scripts.js:874:43)\n    at Scripts.lookup (/usr/local/share/npm/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/build/builders/scripts.js:837:12)\n    at /usr/local/share/npm/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/build/builders/scripts.js:665:14\n    at /usr/local/share/npm/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/node_modules/requires/index.js:41:33\n    at Array.forEach (native)\n    at map (/usr/local/share/npm/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/node_modules/requires/index.js:40:17)\n    at requires (/usr/local/share/npm/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/node_modules/requires/index.js:18:18)\n    at Scripts.register (/usr/local/share/npm/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/build/builders/scripts.js:663:8)\n    at Scripts. (/usr/local/share/npm/lib/node_modules/component/node_modules/component-build/node_modules/component-builder/build/builders/scripts.js:622:78)\n    at Generator.invoke (/usr/local/share/npm/lib/node_modules/component/node_modules/component-resolver/build/index.js:141:31) +0ms\n   error : could not resolve \"./lib/cache\" from \"oauth2-implicit\"'s file \"./index.js\"\n\n```\nAnd then working after removing ./:\n\u29d1 DEBUG=* component build                                                                                                                 \n  remotes:local checking local components at /Users/jasonkuhrt/projects/oauth2-implicit/components +0ms\n  component-resolver remote not set - defaulting to remotes's defaults +0ms\n  component-resolver:locals resolving local at \"/Users/jasonkuhrt/projects/oauth2-implicit\" +0ms\n  component-resolver resolving \"oauth2-implicit\" +9ms\n  component-resolver remaining dependencies: 1 +4ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver finished resolving locals +0ms\n  component-resolver finished resolving dependencies (1) +0ms\n  component-resolver:semver resolving semver yields/store@~0.2.0 +0ms\n  remotes:local resolving local remote +17ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/store +0ms\n  remotes:local got folders: 0.2.0 +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/store +0ms\n  remotes:local got folders: 0.2.0 +1ms\n  component-resolver:dependencies resolving dependency yields/store@0.2.0 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for yields/store@0.2.0 +0ms\n  remotes:local resolving local remote +2ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/store +0ms\n  remotes:local got folders: 0.2.0 +0ms\n  component-resolver:dependencies found yields/store@0.2.0 from remote \"local\" +2ms\n  component-resolver resolving \"yields/store\" +6ms\n  component-resolver:semver resolving semver component/each@* +5ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/each +1ms\n  component-resolver:semver resolving semver component/type@* +1ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/type +0ms\n  component-resolver:semver resolving semver yields/unserialize@* +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/unserialize +0ms\n  component-resolver remaining dependencies: 3 +1ms\n  component-resolver remaining semver: 1 +0ms\n  component-resolver:semver resolved semver yields/store@~0.2.0 -> yields/store@0.2.0 +1ms\n  component-resolver finished resolving semver +1ms\n  remotes:local got folders: 0.2.3 +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/each +0ms\n  remotes:local got folders: 1.0.0 +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/type +0ms\n  remotes:local got folders: 0.0.1 +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/unserialize +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/yields/store/0.2.0\" exists, skipping downloading. +0ms\n  remotes:local got folders: 0.2.3 +0ms\n  component-resolver:dependencies resolving dependency component/each@0.2.3 +3ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/each@0.2.3 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/each +0ms\n  remotes:local got folders: 1.0.0 +0ms\n  component-resolver:dependencies resolving dependency component/type@1.0.0 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/type@1.0.0 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/type +1ms\n  remotes:local got folders: 0.0.1 +0ms\n  component-resolver:dependencies resolving dependency yields/unserialize@0.0.1 +1ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for yields/unserialize@0.0.1 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/yields/unserialize +0ms\n  remotes:local got folders: 0.2.3 +0ms\n  remotes:local got folders: 1.0.0 +0ms\n  remotes:local got folders: 0.0.1 +0ms\n  component-resolver:dependencies found component/each@0.2.3 from remote \"local\" +1ms\n  component-resolver resolving \"component/each\" +3ms\n  component-resolver:dependencies resolving dependency component/to-function@2.0.0 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/to-function@2.0.0 +0ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/to-function +0ms\n  component-resolver remaining dependencies: 5 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver component/each@* -> component/each@0.2.3 +3ms\n  component-resolver:dependencies found component/type@1.0.0 from remote \"local\" +1ms\n  component-resolver resolving \"component/type\" +1ms\n  component-resolver remaining dependencies: 5 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:dependencies resolved dependencies of \"component/each\" +0ms\n  component-resolver:semver resolved semver component/type@* -> component/type@1.0.0 +1ms\n  component-resolver:dependencies found yields/unserialize@0.0.1 from remote \"local\" +0ms\n  component-resolver resolving \"yields/unserialize\" +0ms\n  component-resolver remaining dependencies: 5 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver yields/unserialize@* -> yields/unserialize@0.0.1 +0ms\n  remotes:local got folders: 2.0.0 +1ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/component/each/0.2.3\" exists, skipping downloading. +4ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/component/type/1.0.0\" exists, skipping downloading. +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/yields/unserialize/0.0.1\" exists, skipping downloading. +0ms\n  component-resolver:dependencies found component/to-function@2.0.0 from remote \"local\" +1ms\n  component-resolver resolving \"component/to-function\" +1ms\n  component-resolver:semver resolving semver component/props@* +1ms\n  remotes:local resolving local remote +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/props +0ms\n  component-resolver remaining dependencies: 2 +0ms\n  component-resolver remaining semver: 0 +1ms\n  component-resolver:dependencies resolved dependencies of \"component/each\" +1ms\n  remotes:local got folders: 1.1.2 +1ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/props +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/component/to-function/2.0.0\" exists, skipping downloading. +1ms\n  remotes:local got folders: 1.1.2 +0ms\n  component-resolver:dependencies resolving dependency component/props@1.1.2 +0ms\n  component-resolver:dependencies searching [\"local\",\"github\",\"bitbucket\"] for component/props@1.1.2 +0ms\n  remotes:local resolving local remote +0ms\n  remotes:local checking folder: /Users/jasonkuhrt/projects/oauth2-implicit/components/component/props +0ms\n  remotes:local got folders: 1.1.2 +1ms\n  component-resolver:dependencies found component/props@1.1.2 from remote \"local\" +1ms\n  component-resolver resolving \"component/props\" +1ms\n  component-resolver remaining dependencies: 1 +0ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver:semver resolved semver component/props@* -> component/props@1.1.2 +2ms\n  component-resolver finished resolving dependencies(2) +0ms\n  component-downloader \"/Users/jasonkuhrt/projects/oauth2-implicit/components/component/props/1.1.2\" exists, skipping downloading. +1ms\n  component-resolver finished installing dependencies +0ms\n       build : resolved in 33ms\n       build : build/build.js in 23ms - 12kb\n       build : files in 21ms\n. @jonathanong @visionmedia I'm digging in to fix this as my first pr but first must clarify the following.\nIt appears that --dev is passed through to resolve() via options which in turn installs the development: ... components-of-sub-components. Test coverage seems to confirm this.\nGiven the above, I need to clarify if this is bug or bad design or good design (if so how so?).\nBefore \"fixing\" I want to understand the background problem space in case there is something I am neglecting, I am currently thinking of --dev like npm's --save-dev.\n. > this about updating the component.json file? if so, it's probably just oversight and a bug.\nYes. Ok thanks for confirming.\n\nit shouldn't install the development dependencies of dependencies. if so, that's a bug. i'm pretty sure i have a test for that.\n\nI am / we are confused, this test code:\nhttps://github.com/component/component/blob/master/test/install.js#L128-L140\njs\n  it('should install dev deps when --dev is used', function(done){\n    exec('bin/component install -d', function(err, stdout){\n      if (err) return done(err);\n      stdout.should.include('install');\n      stdout.should.include('complete');\n      var json = require(path.resolve('components/component/tip/1.0.0/component.json'));\n      json.name.should.equal('tip');\n      var json = require(path.resolve('components/component/popover/1.1.0/component.json'));\n      json.name.should.equal('popover');\n      assert(exists('components/component/assert/0.3.0'), 'dev deps should be installed');\n      done();\n    })\n  })\nIs ensuring that assert is installed due to dependencies depending on assert in their development field. Clear? I couldn't decide if this is odd or not yet, first I am working on the issue that --dev installs to your dependencies field instead of development.\n. FYI some of this seems related to https://github.com/facebook/react/issues/1635 wherein each react add-on would have to be its own repo etc.\n. A build error would be helpful but only given these conditions:\n- actually useful error message, with source code dump around offending code\n- doesn't interrupt --watch. Think how node-dev works.\nNeither of the above is currently true.\n. @kevva @jonathanong cool guys, thanks\n. Other use-cases:\n- we don't need to special-case development anymore, it would just fall out from this feature simply, e.g.: component install mocha --env development\n- becomes easier to support stuff like #512, #517 wherein the build is shaped by the env\n. @micky2be \n\nI personally don't like to have 2 different behaviours between prod and dev.\n\nI don't really understand this statement, sorry. Can you elucidate?\n\nWhy would you need different version of the same dependency?\nI also usually minify the build for production release. So having the dependency already minified doesn't provide any help. \n\nI agree in principal but its not that simple.  Please refer to https://github.com/reactjs/react-bower/issues/1 and https://github.com/facebook/react/issues/1635.\n. @micky2be Yup. But until component provides support for multi-dist components (if ever, is philosophically opposed currently) this feature would provide a low-labour work around. Also, this isn't the only use-case.\nFor COMPONENT_ENV I rely on it for making sure I load the correct config branches for my application. It turns out my client projects often rely on lots of different cloud services so being able to require('env') makes it trivial to get the right URIs for those respective to the env in use.\n. FWIW, were the following true, would make me very happy to not have this:\n1. projects better-expose their build tools in a cli so that we're not stuck requiring multi-dist components https://github.com/reactjs/react-bower/issues/1#issuecomment-46578277\n2. a robust .use() system that makes it easy to inject synthetic files etc.\n3. --use support https://github.com/component/component/issues/524\nBut since: \n1. is not realistic\n2. is not happening any time soon\n3. depends on 2 plus additional discussion\nI don't see a way forward other than some simple interface tweaks to compoent.\n. @netpoetica Hey\n\nbut are you implying that component authors should be maintaining releases for minified and non-minified versions of their components?\n\nIdeally no, but certain circumstances point in that direction. I've given up thinking about this problem space for now, too complicated for me right now. There's a cascade-like series of problems that need addressing, starting with how difficult component plugins are to employ. I don't feeling like bitching though because I would rather just help, but that's near impossible for me until later this year.\n. All too nutty, never going to happen.\n. @Antaranian Expanding lodash to lodash/lodash etc. is not a bad idea. Thanks for suggesting it.\nNote however that your motivation is based on some false assumptions I think. You do not need to do this: \nrequire('name-repo')\ncomponent knows how to resolve just this:\nrequire('repo')\nThe only time you would need require('name-repo') is if you have installed two dependencies with the same name. : )\n. If @jonathanong is cool with it @Antaranian feel free to submit a pull-request. You basically just need a small pure function.\nAlso while we're on this topic here are other wacky possibilities:\ncomponent install component/emitter, tip, foobar lodash mnmly/sldr ios7-switch\nPersonally I don't need this stuff, just sharing.\n. @stephenmathieson Yup! :+1: \n. @visionmedia Can you summarize Go re build/package management as you see it in relation to future ideas for component, duo, etc.? You're ~~name~~ tech dropping pretty hard here, I am genuinely curious what the material substance is.\n. @visionmedia Cool thanks for clarifying\n. What @clintwood said. Thanks @visionmedia . \nWould be nice if duo leveraged @joliss's broccoli build tool which seems well designed and aims to be better than gulp which duo is based on.\n. @netpoetica Thanks. To be totally honest at littleBits we're mostly looking toward Duo.js right now. I am all for making component work better but its just not a priority for my time right now. I barely have time to even code front-end any more these days so meta projects like this are even tougher to get time spent on. I'm not opposed to being listed but it may be more helpful to only list the most active maintainers for now? Cheers.\n. ",
    "ianstormtaylor": "@anthonyshort has been doing something?\n. Been using the flat approach for the past month+ after seeing TJ recommend it everywhere and it's actually been really nice. Our setup is something like @rschmukler's:\nsite/\n  components/\n    component-tip/\n    component-each/\n    ...\n  lib/\n    user-model/\n    integration-model/\n    integration-sheet/\n    integration-metadata/\n    page-header/\n    ...    \n  pages/\n    signup/\n    login/\n    ...\n  theme/\n    theme-button/\n    theme-tooltip/\n    theme-page-header/\n    ...\n- components is you know what.\n- lib are most of our private components\n- pages are the pages inside our app, that can eventually be bundled into single builds (haven't gotten around to this yet, @rschmukler would love to read a blog post about how you guys are doing it btw).\n- theme is all of the theme files for public components like component/tip, as well as for our private components like page-header. I'm still not exactly sure if I'm sold on keeping the private components' themes in here since it's so easy to forget and get the non-base styles mixed up (already happens).\n. @rschmukler ah sorry looks like I misunderstood you. I meant that page components would get built separately, so that login builds into login-build.js instead of packaging the entire app into one huge build.\nSharing stuff server/client also sounds like something I'd read though :p\n. +1 on sticking with it and forcing people to get it. If it doesn't work still, you could decide to change it later, once there's less excuse for people not getting in (examples, docs, etc).\n. what would the plugin be doing?\n. +1 for finding a way to make it commonjs-like cuz i find that having global testing utils instead of tracking down the require paths makes things way harder to reason about over time\n. -1 for magic, cuz then everything depends on that global setting without explicitly showing that it does. same reason that paths is much better than NODE_PATH in my opinion\n. Yeah I definitely prefer using the scripts and styles arrays and just filtering for .sass. I've already solved the actual building of Sass files (and the import paths, especially with a smarter builder) seems like it would completely solve it.\nI'm more interested about the Jade complications.\nTJ do you share you server-side views and the .js for that page in the same folder? This seems like it would be a nice way to do it to me so that everything I need for login is in that one spot. (Even thought about having the backend controllers join that folder too..) Do you just have extends that reach out like extends ../page/template, I was hoping to remove that.\nOr more generally, how do you structure the server-side part of your component-ized projects?\n. Ah gotcha. We have to have some of ours be rendered server-side for SEO until that stops being a problem. Will be curious to see how other people deal with server-side views then.\nI feel like server-side views are currently jankily put together. Either lots of includeing little pieces, but still repeating boilerplate, or lots of reaching up all the time for extending. And they're often nowhere near the stylesheets/scripts that they are tightly coupled to (or even the controllers for that matter). But maybe I'm just looking in the wrong places :$\n. yup have been doing that for now and it works nicely\n. by the sloppy syntax do you guys mean things like ~1.0.0? or 1.0.0 in general? (sorry, confused) oh i think i see, you only need the full list if you're trying to get automatic latests, otherwise just go straight to the right tags endpoint yeah? from my current experience, i either use * or completely specify 0.1.2\n. ah yeah i forgot that * has the same problems. i'd say that * is extremely useful though. at least all of my development dependencies are always starred since i don't feel like having to manage them all separately \u2014 i could be convinced to stop using it if install automatically grabbed the latest for me.\none problem i run into is that the version property isn't directly tied to tags, so people can increment version without tagging and then youre screwed since there's no tag to find. but that could be an unrelated problem if we want.\n. +1\n. havent seen this in a very long time.. gna close but feel free to reopen\n. would be better named hooks i think, instead of commands. could be something that gets added, but to keep things simple for now you might just want to make a custom builder instead. for reference:\ncomponent/builder\nsegmentio/logo\n. maybe google needs to get smarter\n. personally i prefer Node.js to nodejs, but anywaayyyss\n. i don't think an exact copy of npm is what we want. because that would guarantee that all the size benefits of sharing components for the browser are erased. but i think logging a warning, and installing duplicates of the ones that conflict would be best.\ni feel like we'd definitely want to have 0.0.x support at that point since if people are pegging properly things are going to get out of hand pretty quickly\ni think the log but still install two copies is the best since it lets you do whatever you want in the case where you don't care, but if you do care it logs so you can do something about it. better than the \"complain and fail\" approach\n. the versions in the tree or the version on master?\n. better yet, both and a separate color to mark out of date ones :)\n. wrote up a thing for it since i wanted outdated too: https://github.com/ianstormtaylor/component-outdated\nupdate is next, and then ill really have solved all my version problems haha\n. oh nice thanks :)\njust added another: https://github.com/ianstormtaylor/component-update - to make re-pinning deps less tedious. could be cleaned up and put in core later probably\n. wow ls is sick\n. This seems like a really big increase in scope in my opinion, that doesn't get you that much (except a more complicated API). I'd rather just have one person fork and make a component-compliant repository once than have everyone have to shim existing repositories.\nFrom what I've found, while using component it's actually somewhat rare that I need another repository to be shimmed. Usually I'm pretty content either using the existing components or quickly whipping up a small one of my own.\n. hacked it up for fun: https://github.com/ianstormtaylor/component-size\nsome jank stuff in there. would probably be nice to have a common traverse-components for making command plugin building real easy\n. +1 on the auto-converting for a simpler api\n. haha yeah i was gonna say an argument against it is that it's old-world thinking. but at the same time, i feel like certain strict APIs like model and builder.js will always have components instead of just any old plug and play thing.\nunless you're literally taking about the outcome, in which case it doesn't do anything in the build process. its just metadata to link semantically to repos that are plugins of the current one (like keywords, author, etc). they dont get built in or anything, which would make huge files if you used dependencies for this case\n. sorry, to be more clear, plugins are things you extend the functionality of a component with, usually with a use method, like builder:\n``` js\nvar Builder = require('builder')\n  , jade = require('component-jade'); // plugin\nvar builder = new Builder(__dirname);\nbuilder.use(jade);\n```\nor model:\n``` js\nvar model = require('model')\n  , defaults = require('model-defaults'); // plugin\nvar Person = model('person')\n  .use(defaults)\n  .attr('age', { default: 0 });\n```\nthe reason for wanting it in component.json is so they can be displayed along with the main component in directories, otherwise they are hard to find. and it also increases the value of the main component by a lot if its got an ecosystem of plugins.\n. yeah that's definitely much better if they're all crawled into one dataset, which i guess isn't too much to expect. gets over the annoyance problem of maintaining one to many plugins\n. haha yup, peer dependencies is exactly what i was trying to say. although hopefully we can shorten it to peers, or extends or something else without camel case\n. peerDependencies -> peers would be pretty equivalent to devDependencies -> development imo\n. some other names: augments, supplements, enhances, modifies\n. really? i actually like augments\n. mm good point about nouns, ill try to think of some more noun options\n. +1 to --extensions and extends: fitting nicely together\n. hmm yeah i guess it's just a trade-off. if e think model or reactive or whatever extensions are valid, then it could be potentially very useful. i feel like education is what's needed there, since obviously a slideshow is a bad dom extension, but there could be legitimate dom extensions too\nbut i'd tend towards thinking that metadata does more good for us than harm. i think jquery plugins only came to be since there wasn't an easy way to require('dom') like we have now. i'd actually assume that extends would be more of a power-user feature than just plain old requiring.\nactually, i'd be more worried about people providing a plugin to model by doing hackish things with require('model') instead of exporting a plugin for .use(), know what i mean?\n. -1 to strings since it's just vague. I like that we have the trifecta: scripts, styles and templates.\nAlso yeah, even with multiline strings I'm going to want to have my HTML templates in .html files instead of inline in Javascript.\nI don't think we should handle .jade or .ejs or any other files like that other than .html. The other ones should all be handled by plugins since they aren't native to the web and we don't want to get into the business of the builder supporting everything. \nI'm not sure the component-jade example is a problem. I wouldn't ever want jade templates as strings, always as functions, but I also don't think I'd get confused by that. I'd get even less confused if it was still require('./template.jade'), and I still like not having to worry about clobbering. I also don't mind them being intermingled the way .sass and .css files are in styles. But I could be convinced here.\nAs far as limiting the issue, I think the implementation should be limited to .html natively, but we should definitely discuss how the other templating languages would work alongside while figuring out the spec.\n. @edmellum No one suggested an html field, unless you mean templates? The field name was chosen so that it was universal.\n. @anthonyshort do you have any thoughts on the use case where you want .jade files to be made available as pre-compiled functions so that you don't have to do the expensive compile step at runtime?\nI think your suggestion is interesting, and could make it pretty straightforward (and maybe this is what you meant already). templates would be made available as strings by default. But then a component-jade plugin's transform step would be to read the templates file, and then remove it from templates, adding the function exported version to scripts.\n. -1 for readable or strings or data or files or scripts since they all seem hacky since they aren't really semantic at all. i guess strings kind of is, but it's coupled too tightly to the output we want instead of the type of file it is. and files should stay generic for all the other things people might want to use in their builds. scripts seems like too much magic, especially since they aren't scripts at all.\n+1 to @anthonyshort: still prefer templates and if you want to opt out (like with any other special-cased keyword) just put them in files.\n. Agree with @ericgj, and ideally that updated copy with go on http://component.io when there's time to add to it. We definitely need to get a better introduction for newcomers setup since there is a lot to digest all at once.\nThe idea of a blog in 5 minutes is a bit of a stretch, but the idea isn't completely off. I could totally see a much simpler kind of tutorial that involves composing a few components in a useful way. For example, imagine a page with just a <textarea>. And then using a few components you'd build up some pretty complex functionality very quickly. Adding matthewmueller/grow to get the <textarea> growing as more text is written. Using yields/store to save the result of the <textarea> to Local Storage and retrieve is on refresh. Maybe adding in component/reactive to get a Twitter-like \"characters remaining\" counter. You could actually build a small twitter-style feed like that very quickly and show how lots of component can work together. Throw in component/collection and component/relative-date. You get the idea...\n. One thing I think can be good in similar situations is that you might consider unbundling the builds. So you'd actually move to multiple builds instead of one monolithic one. It gets a little excessive (and potentially unperformant) if you do builds for each individual page. But I've been thinking about having builds for different parts of our app, for example:\n- Registration: figure chances are likely that if they hit /signup they'll also hit /confirm or whatever else your registration steps are.\n- App: bad name, but the real internal part of your app would be another build since they're likely to use all the pages of it at once.\n- Each landing page: here's where it might actually be better to split builds into single pages, since they aren't likely to hit two of your different landing pages, and you'd want to maximize page load time on these?\nAnyone else do something like this yet? or see any huge holes in it?\n. That's exactly what our plans are too :) got pretty excited the other day when @calvinfo showed me mounting\n. I think the standard so far has been to put the LESS files inside the styles array with a .less extension. So the LESS builder plugin then looks in styles for any files that end in .less and converts them. I tend to like that solution more because it uses the extensions that are already there, so there's no extra config to write.\n. As far as public components go, the consensus is that they shouldn't be built with necessary transform steps at all, to make them as interoperable as possible.\n. this happened to me yesterday as well for about an hour, not sure what i did either, but it disappeared again.\n. nvm, it's pretty regular now. happens a lot to me with component/event and component/classes, although that could easily just be in my case, downloading ~40 components into /components\ncomponent 0.16.7\nnode 0.8.8\n. check out issue https://github.com/component/component/issues/374\n. sounds cool, would it be better as component-installer and new Installer?\n. haha, was just showing it to a friend and he got real confused by the current readme ;)\n. @visionmedia what are your thoughts on throwing errors for component.json that don't comply with the spec like this? for example v3.4.5 throws an error. the reason i'm asking is because i think npm also forces package names to be all lowercase, where component doesn't so some people make uppercase packages which is another annoyance to remember\nalso ran into the v0.0.0 issue the other day, and this might be a place where stronger validation is worth it to keep the annoying edge case behavior from diluting the community?\n. ah yeah that's a good point. i am more and more in favor of the registry as time goes on haha (although that makes sense).\ni had been thinking that component build or whatever would error out (assuming they would never get it working that way in dev, so they'd change it) - but totally understand that that is hackish\n. was thinking the same thing. i actually always use it, but even forget to update it which is even worse. i was thinking that this is one of the big benefits of npm, that it forces you to version things properly, so that everywhere else in the system you can rely on versioning existing.\ni'm getting more and more convinced that having a smarter registry has lots of positives\n. i think there was talk of standardizing a demo field in component.json as a link to where the demo lives?\n. i wouldn't use it just because i rarely know all the methods to start with when i open a file, and just by writing either the logic itself, or the docblock comments, i figure out what should happen. that, and apart from our private views, our files aren't all that similar.\nprefer writing the stuff out because either:\n- you'll quickly realize through lots of writing which pieces should be modularized\n- you'll realize through lots of writing that you're making things more complicated than you should be :)\nno harm if you dig it though.\nwhat i'd really like to see is a way to make component-create pluggable (since i have my own preferences for projects) or at least more fully fleshed out.\n. i forgot to mention, another option could be to put it in a new section, like json or something.. can't think of a good name though. config, data, .....\n. json makes sense, ill update the pr with that. i like that .sass etc. go under the key that they compile down to, altho yeah also dont really care about em haha since i dont use em anymore\n. ah yeah, i use boot in our stuff too haha for the same reason, but trying to move away from it when @ivolo gave me shit for being unintelligible :p\nauto-require feels like the best option to me\n. hahaha yeah you're right, auto-require is pretty horrible. i actually take back my negative feelings about boot. but i like the idea of describing the purpose\n. ah true it doesn't work for a sub-component boot file. in my case tho it does work since im just using an index.js as boot, in which case i'm a moron :)\n. yup very true. honestly i think standalone can solve the need. makes sense to me anyways that the boot would be the index.js itself instead of a nested component\n. truth, either way, solved! :p\n. One thing I was thinking about is that the CSS prefixing is only useful if the prefixes are chops able by the user not the maintainer. Otherwise for old support you'd still need rework\nIf it was on build maybe you could choose a level back to support. But that gets real magicy and js isn't shimmed (although it could be who knows)\nBut yeah needs to be a user decision\n. i feel like those little things keep coming up haha, like validating the repo field, or even defaulting license to MIT or whatever :)\n. Also you can just add your own fields if you want and write a plugin that checks them\nWouldn't recommend it generally though because no one is going to want to have to use the plugin to use your components\n\nOn Nov 9, 2013, at 9:02 AM, amir abu shareb notifications@github.com wrote:\nyeah builder.js makes this easy.\n\u2014\nReply to this email directly or view it on GitHub.\n. +1 to following and then showing a warning\n. k so i added two repos: installer.js and package.js. i'm no longer sold that package should be its own repo actually, maybe it should just be exposed from this one instead. happy to make that change if we decide that\n\n@dominicbarnes or if anyone else wants to help, both of those could use lots more testing. and i probably made some dumb mistakes somewhere. among other things. now that installer is pulled out, i'd like to get it properly handling versions too and complaining when dupes with diff versions are installed\n@visionmedia let me know what you think about all this. happy to keep working, or change what im doing if its all fucked up haha ;)\n. +1 for function () {} hahahaha :)\ni think i've come to the conclusion, after much OCD sadness, that that type of spacing is unfixable. there isn't enough of a default in either direction in the community, and differnt autocomplete tools do different things. it's not like if () vs if() which is much more slanted in one direction\n(yes i think about this way too much)\n. How does the flattening step work? Curious, instead of forcing the user to flatten before passing it into the builder, why not just let the builder accept the tree, and then have it flatten it itself if that is a necessary step for building.\nOne of my thoughts is that something called resolver complicates the system in general, because it seems like it takes on a lot of responsibility (hence why it doesn\u2019t have a simple name to describe what it does) which seems like we could improve that somehow.\nI like the current separation between install and build in the system. It makes it clear that for example we could just install when the server is first started, and then build on requests.\nI might be thinking about this incorrectly though. What do you all think?\nRandom sketch of a way I think about it:\njs\nnew Installer(__dirname)\n  .remotes([local, github])\n  .destination('components')\n  .install(function(err){});\nThose two remotes would be included by default (and would be their repository inside the component org so people can use them as well), but that\u2019s the idea for how it can be extended. They would have a define API similar to how remotes does it. It could have useful statics for one-off installations:\n``` js\nInstaller.install('path/to/dest', 'component/emitter', function(err){\n});\n```\nWhich is a \u201crun-once\u201d operation. And then the builder:\njs\nnew Builder(__dirname)\n  .scripts()\n  .build(function(err, res){\n    write('build.js', res.require + res.scripts);\n  });\nThat is for just installing scripts. But if you don\u2019t specify anything it will build with the entire spec:\njs\nnew Builder(__dirname)\n  .build(function(err, res){\n    write('build.js', res.require + res.scripts);\n  });\nSeems like this is similar in a lot of ways to what you\u2019ve built Jon, so just trying to figure out the differences and arrive at the best API for this stuff.\nIt feels like letting the builder doing the resolving, and letting the installer only worry about installing and downloading can reduce some of the complexity from resolver.\nLet me know what you guys think.\n. for flatten i think we should figure out a way to have that not be something that needs to be exposed to the user, since that seems like an implementation detail to me. i'd prefer to remove the \"bundling\" use case from the initial builder implementation in terms of design. aka dont want the builder to have a weirder api if thats required just to support bundling, but i feel like it should be possible with small pieces to be able to easily support bundling without the api changing. as long as inputs and outputs are exposed everywhere it would just be piping basically\n\nwell my opinion is that it \"resolves the local components and remote dependencies\", which includes installing them. installing is very easy (it's only a few more lines since most of that logic is in remotes and component-downloader) so i don't think it's overly complicated.\nthe installing/downloading is all done in remotes/downloader and is only a few more lines in the resolver.\n\n\"resolves\" doesn't actually mean anything in this context though, since it also means \"downloads\" and \"semvers\" and a bunch of other stuff. just because the logic is in another repo doesn't mean that it isn't being performed by the resolver. right now it seems to me like the resolver is trying to do too much, and having a build step that \"might\" install dependencies and might not ends up in the core api having weird side effects in different use cases\nfor remotes it seems like local wouldn't need to be an \"option\" if the installer just had a way to define remotes, and then throw the defaults in separate libs that are required in by the installer:\n``` js\nvar local = require('component-local-remote');\nvar github = require('component-github-remote');\nvar Installer = require('component-installer');\nvar installer = new Installer(__dirname);\n// the default\ninstaller.remotes([local, github]);\n// something custom\ninstaller.remotes([myCustomRemote, github]);\n```\ninstead of getting fancy with options:\njs\nvar remote = remotes({\n  local: true\n}, ['github'])\n\noh btw, for one-off installations, you can do:\n\nwhat about setting a directory for the destination to install? the problem i see with that syntax is that it's really verbose, i'd rather figure out an abstraction that keeps things simpler in general, and involve less nested objects or big options objects to work with\n. one thing is would the remote situation default to the registry, but still fall back to github? if so all the branch/commit logic could still stay with github and the registry could just handle tags.\ni can see why branch/commit is hard to manage registry side, and abstraction wise. branches are still super useful sometimes when you want to just swap to your fix quickly, which is my only hesitation if we ditch them\n. haven't used link enough before to know tbh. i know that we've been using branches in prod even tho just when we can't wait for things to be merged into the original. its definitely solved by just tagging our own branch normally, but then publishing our own fork seems like an anti-pattern from a registry cleanliness thing. (unless it recognized forks differently somehow)\nits one of those things where it can be done in other ways, but so far the sexiness of just fork, edit, one line change to component.json has been a cool thing i've gotten spoiled on, which i think would also blow other people's minds haha\n. you can guarantee i never do that :) hahahah\n. thats the kinda shit i love to hear :)\n. i know we had to add our own wrapper for analytics.js to not break require.js implementations. @calvinfo was the one who figured out what in gods name was going on in AMD land\n. You're all welcome :pp\n. damn, sick photography tj\n. would sooner think this would be implemented as a watch command like the others said. and then instead of replacing the current builder.js, it could be smart and allow it to be passed a pre-resolved resolver.js if that is the problem we're trying to solve. then the watch command can keep be in charge of the resolver, and build can still function as normal.\ni see this as a dev-only problem, and purely to solve performance of builds. which is a good problem to solve, but shouldn't involve completely changing the API IMO\nin production i don't really want to have to mess with a watcher, i just want to build it once and then be done with it, and making the api harder for those cases sounds not as great.\ndisclaimer: i might not be understanding how it works\n. having to fork something to make my own builder sounds less appealing that using an existing JS API to make my own build rules, am i missing something there?\nagree with tj that the peace of mind of knowing that you didn't refresh mid-build is a positive to factor in\nmore generally, unless i start to understand what the positives are, i'd much rather go with a dumb --watch flag or something to start and see where people's real issues are. i haven't really had trouble with build being too slow either, and we're working on decently sized apps. only time it was a problem was back when we were using Sass\n. yeah the current builder's copy plugin could just be augmented to add mtime checking if we wanted? (more reason to have it in a separate repo, just required in)\n. i'd implement it as a separate plugin for now and then we can see if everyone thinks its super useful enough to be added to core\n. http://www.youtube.com/watch?v=gm2xdqEjBlI\n. in the meantime: https://github.com/ianstormtaylor/set-version\n. just added major minor patch shortcuts and changed the name to bump at @anthonyshort's suggestion. so now its a pretty nice overall solution:\n```\n$ bump minor\nVersion bumped to 0.5.0 in package.json and component.json.\n\n```\n. he's not saying it will be removed, but it's not public so it can be removed (or the API changed) at any time. \ni don't understand the require.register use case. it sounds like you're tightly coupling any component you register that way to the entire build as a dep since it's not longer defining its own dependencies... the line \"assuming component/emitter was in my global build\" is the giveaway that it's a bad idea to begin with IMO\n. if you write the stupid Makefiles nicely from the start though the whole thing should be handled with a single make build from the top layer tho :p and it would even use mtime to not update unnecessarily\n. but totally agree that Grunt is never a good thing haha\n. added\n. umd sounds better to me i think\n. Amir I and will have a solution for this soon I think. Just gotta open source it :) but totally agree about removing from core \n. sounds good. i wouldn't include it by default, just point people to it if anything\n. +1 would rather not have them have to be managed in core too i think\n. @jonathanong totally agree about logging. can you elaborate on the race conditions in semver? didn't realize i was missing something there, let me know and i can think about how to handle that as well\ni'm not yet sold on the globbing because from everything i've worked on that's just never been a problem, as components tend to be very small in scope thanks to how easy the ecosystem is. would be keen to hear others's thoughts on that. i've been -1 on globbing for a while for that reason, since it adds complexity\n. i agree with @jb55 on this. it's all about just automating the initial creation (and i dont even do that yet) but then the upkeep on existing components is practically null if they are self-contained from the start\nthat being said, i think globbing could (?) be added back in here unless im missing something core to the way it works, so i'd rather leave that for a \"next\" part of the discussion and instead discuss the core way this idea is laid out differently\n@jonathanong i think (?) that may be solved in this installer already. i chose to fail out when it first finds a semver mismatch, and it just recurses through the tree, but only ever do a single level at once. there's a non-low chance i might be missing something obvious though :)\n. not that many pin their deps though. most of mine i left unpinned (and all of ours internalled are unpinned) since keeping up with the version changes wasn't worth it. going through the component org while testing i had to work to actually find conflicts that would let be easily test logger.fatal haha\n@MatthewMueller @jonathanong for multiple versions how were you thinking CSS would be handled? i can't find a good solution for it, so i think multiple versions is out unforunately. otherwise we're going to end up with tons of dev time spent not realizing why CSS is messed up. i think it's much clearer to the user whats going on if we just throw like most package managers do\n. @visionmedia i dig that Go approach, whether we do it or not haha. you prefer the github.com approach to github://? i dont have an opinion there. i'll update the remote.name to be github.com in that case\nas for lib-ish stuff, we could make two repos component and component.js if we want to solve that part. that way we end up with a small number of repos to wrap people's head around, but we can still get the separation for the CLI niceness? i don't have a strong opinion on whether the lib should be in the same repo as the cli or not. for things like metalsmith its nice.. thats my only thought\n. i'm not convinced the strict versioning will occur in the wild that much. if you think about it, right now we have no ability to apply semver ranges and the conflicts do happen, but they are rare. when you're prototyping couldn't you just use * to make your life easier in that respect? \nwith everything pegged to ~ or ^ by default the conflicts will be still be rare i think, and in that case they would be completely merited because CSS is never going to work across breaking major changes anyways, so the developer is going to get screwed with debugging the problem\n. @MatthewMueller that's why i'm thinking we should rather go with a solution that works the same in all cases, since it will make the mental model a lot easier for the user. instead of cases where only sometimes conflicts will result in potentially really hard to track down CSS bugs\nnot sure which side of the ease spectrum web components would fall into\n. @visionmedia haha luckily its a call for future us\n. wouldnt it take just as long as it did in component@0.x since its just raw.github access? or was there a change that makes it takes much longer?\n. just checked on this branch, downloading all of the files for chaijs/chai is like 1 second\n. +1 to disliking node_modules\ni think just letting people supply a components dir would be fine (and easy) later on\n. it should be first in the the JS api, then in --out then in .componentrc. but i dont think any build-level settings should ever be settable only in .componentrc (only user level settings)\n. ",
    "KenanY": "@wyuenho #429\n. isaacs/npm#563\n\nIf it's just a string, then convert it to {\"type\":\"git\",\"url\":<string>}\n\nDepends how verbose you want to be, I guess. Some of your projects like express and jade don't specify the type, but mocha does, so I just made the arbitrary decision of not including the type. If you'd like it, you can close this PR and add it yourself I guess, lol.\n. component/require\n. So I can't consume components that don't use n.n.n?\n. :+1:\nI was looking for this a while ago. I wanted to require() a JSON file in one of my components but I was bummed out to discover that I would be forcing users to install component-json (which uses files so maybe that's better for legacy stuff?). Ended up putting the JSON in a JavaScript file and module.exporting it but I've been having nightmares ever since.\n. Yeah I ran into this as well (#406).\n. #405\n. I believe #485 fixed this.\n. @cristiandouce \nbash\n$ npm repo component\n? https://www.npmjs.org/doc/cli/npm-repo.html\n. Woah that was weird. Getting a 404 now though, haha.\n. It is unless they do\nbash\n$ npm install -g component@1.0.0-rc5\n. @samuelreh Node.js 0.11.x has a bug in its shasum implementation (joyent/node#7365). Maybe that's why you're getting a different shasum than expected?\n. component/component.io#80, #587\n. @sankargorthi organization name changed on GitHub. It's http://componentjs.github.io/component.io/ now (\"componentjs\" vs. \"component\")\n. ",
    "marcelklehr": "Isaacs has published a nice package for dealing with semver madness: https://npmjs.org/package/semver\n. I'm still getting error : component at \"xxx\"'s name does not match the component's when running component build -c with component@1.0.0.-rc5\n. Why?\n. Just tried changing component.json:name to match the directory name and I still get the error. What am I missing?\n. I'm not working on it right now, and it's probably an error on my end migrating from the old component to the new version. I'll get back to you when I know more\n. ok, so renaming my local components fixed this, but still I think it's a bug that it doesn't tell me the correct location\n. (component@1.0.0-rc5)\n. Yes, all folder names have to match the name of the component they\ncontain. I gave up on 1.0.0 for now and switched back to 0.9 again.\nStill, I think the new version is really exciting. Keep up the good work\nand thank you!\n. Sorry. This is what backbone-orm prepends to the build: https://github.com/kmalakoff/gulp-module-system/blob/master/module_systems/local-shim.coffee\n. ",
    "jiyinyiyong": "I want component remove too. But if that's not a good practice, how can I remove a package from my projects?\n. Step 1, subl -a component.json, remove package\nStep 2, rm -rf components/ + package name\nlol ...Why is that... isn't it a package manager, I have to manage packages by hand.\n. I've been watching Component Project since it came out, but still I can't run component by reading this guide or TJ's screencasts. It made me quite depressed. I have worked as a front-end developer for less a year..\nSo I vote for adding better docs.\n. And Bower use the word \"Components\" too, https://github.com/components\nEven in using component in my command ilne, we need some more key strokes:\n\u27a4\u27a4 com\ncomm               complete           component-convert  component-install  composite\ncommand            component          component-create   component-ls       compress\ncompare            component-build    component-help     component-search\ncompgen            component-changes  component-info     component-wiki\n. ",
    "kewah": "@jiyinyiyong If you are interested, I published a command to uninstall dependencies https://github.com/kewah/component-uninstall\n. I wrote an article earlier this week to help people to get started with Component http://blog.kewah.com/2014/build-a-web-app-with-component/\nI think it's also important to talk about the workflow and tools (component sub commands). People seem to be afraid of having to deal with multiple component.json files.\nWe should definitely have a website where we can easily find tutorials. It is hard to find good resources on Google because of the generic name \"component\".\n. component/create.js doesn't work currently though. See https://github.com/component/create.js/pull/8\n. @dominicbarnes @bigmeech few months ago I started to work on a small generator for component (https://github.com/kewah/component-generate). If you are interested we can improve it and add new features :)\n. @karlbohlmark you should make a PR\n. ",
    "heavyk": "I can't find a way to undo the changes! I really don't know what happened!! since component-search updates from this, I'm kinda worried... help!!!\n. ",
    "timeturner": "It would be beneficial to have component install --remove for deps that are no longer in in ./component.json but in ./components. Kind of keeps ./component.json and ./components in sync.\n. ",
    "avetisk": "@ronquil What about component autoremove \u00e0 la apt-get?\n@visionmedia It would be nice to have a creation wizard like:\nWhat's your GitHub username? component\nWhat's your project name? emitter\n...\nSave these information to component.json? [Y/n]\n. Installation yes.\nIt's not adding much, but it's always nice to have some kind of wizard which can prevent, for example, some useless duplication, etc.\n. The best I could do (used Adelle Sans font, but it's a guess):\n\n. Sometimes I'm really overlooking things...\nHere's the Arial version:\n\n. @yields I agree, but it should at least provide a nice and easy way to release new components.\nThat would help growing faster and better.\n. \u00ab without having to mess around with build scripts or shell environments.\u00a0\u00bb (@timoxley)\n+1\nBut having more and more configuration files can't be a good idea.\n. @visionmedia What about conflicts?\nCOMPONENT is quite common word in development and there might be some other projects which are using or would like to use COMPONENT_PATH.\n. Let's say someone is using some custom shell which has components and it allows the user to give a custom path to these components via COMPONENT_PATH; there would be a conflict between your project and the shell project.\nPersonally, I don't like when there's no kind of namespacing in globals.\nUsing shell vars without namespaces is like using globals in a browser. You can compare COMPONENT_PATH to window.component. \nDepending on the developer approach, some will try to have no globals, some won't be bothered.\nLibraries such as Backbone, jQuery, etc. have a the commonjs noConflict() in the browser env., so may be we could have an equivalent for the shell?\n. > In this example, require('events') would not work, but require('events') would work.\nSomething's wrong here.\n. Will there ever be any other kind of lookup except for paths?\nIf not, then I guess lookup is just fine.\n. So...many...colors...\nAnyway, well done!\n. ",
    "brighthas": "\\components\n   \\component-tip@0.0.2\n   \\component-tip@0.0.4\n. but windows ,  process.env.HOME  is undefined.\nif (process.platform == 'win32') {\n    process.env.HOME = process.env.HOMEPATH;\n}\n. thanks :100: \n. +1\n. thanks\n. TJ please pull  :p\n. superagent's  bug\n. fixed superagent  old code\njavascript\nResponse.prototype.pause = function(){\n     // empty code , then component v0.16.5  run ok!\n};\n. yes, gzip  req result  no unzip . \nthe code have bug if reduction is pass, should be no decompression.\n. very good :+1: \n. thanks :+1: \n. making progress?\n. component install componennt/event \nthis ok\ncomponent install component/event\n. such api reasonable? rely on require.resolve \nhttps://github.com/brighthas/resource\n. ```\nd:\\project>component -V\n0.16.8\nd:\\project\\toolbar>make clean\nrm -fr build components template.js\nd:\\project\\toolbar>make\n install : uico/uico@master\n install : brighthas/bootstrap@master\n install : component/domify@master\n install : component/reactive@master\n install : visionmedia/mocha@master\n install : component/assert@master\n install : adamsanderson/trigger-event@master\ncomplete : visionmedia/mocha\ncomplete : component/domify\ncomplete : adamsanderson/trigger-event\ncomplete : component/reactive\ncomplete : component/assert\ncomplete : uico/uico\ncomplete : brighthas/bootstrap\n\n\n   error : failed to lookup \"toolbar\"'s dependency \"uico-uico\"\n\n```\nif 0.16.7 is pass, but 0.16.8 is fail.\n. ",
    "bengarnett": "Thanks, I appreciate it. I should have clarified. I meant the components.json file of the component spec. So component creators will be more likely to include a license.\n. i agree, i did a component-search for all components with --json and not one had a license\n. Thanks, this will save me from visiting each github page to confirm licenses.\n. ",
    "niftylettuce": "yea 0.6.x wasn't working afaik\n. ",
    "weepy": "fork && pull request ?\n. only other thing to point out. I mostly dont care about size of\ndependencies wrt download speed etc. BUT I do find it very useful for a\nquick heuristic about how complex a project is. I avoid larger project not\nbecause I worry about my users having to wait 10ms longer in their first\nrequest, but more because BIG ~= BLOATED\nOn Tue, Nov 6, 2012 at 10:36 AM, Amir Abu Shareb\nnotifications@github.comwrote:\n\nYeah the idea isn't perfect.\ndemoscene style\nI have never seen that before haha..\nThere is a lot of unreadable code on github that's for sure,\ndevs who write unreadable code will keep writing that way, regardless of\nwhat we are doing...\nuse dependencies\nI agree, but not adding the size of the whole component with it's\ndependencies will\nbe kinda useless because it's not real.\nI think we can solve this with adding standalone size which includes\ndependencies and size which\nis the code.\nI don't know haha, let's wait to hear some more ideas on what is the best\nway to go...\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/135#issuecomment-10105860.\n. it's because if they link to a http image from a page that's https ---- it\nwill break the security of the page.\n\nOn Thu, Nov 8, 2012 at 4:18 PM, Nicholas Kinsey notifications@github.comwrote:\n\nI just had a rather thorough look through markuphttps://github.com/github/markup,\nredcarpet https://github.com/vmg/redcarpet, sundownhttps://github.com/vmg/sundownand could not find a single reference to caching.\nThere are, however, references in publications by Akamaihttp://www.akamai.com/dl/feature_sheets/fs_edgesuite_securecontentdelivery.pdf\n.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/144#issuecomment-10193880.\n. @weepyfail\n. would it be possible to just be able to make require so that any extension that's not js or json or blank (and hence js) is just returned as text. It would simplify the whole process. \n. i suppose i meant I wanted to the builder to do something dependenat on the extension : \n\nrequire.register('template.html', function( ... ) {  \n   return \"<body> </body>\"\n})\n...\nhtml = require('template.html')\nso we can just rely on the extension rather than having a load of extra template.js and convert commands,\n. +1\n. when u say the \"source url stuff\" - do you mean the eval thing ?\n. just been trying out 'evalling' the source. Seems to be a major PITA to prepare the text  so it can be included in another script.\n. just tried - works nicely for me. JSON.stringify is a great way to encode\nthe\n. I did this just using uglify in similar build system\nparser = require(\"uglify-js\");\ntry {\n  parser.parse( js )\n} \ncatch(e) {\n  var err = 'Syntax error in: ' + file + ' at line ' + e.line +':' +e.col +'\\n  ' //+ \n  console.log(err)\n}\n. I have found it very useful ...... \n. can't you use sourceURL's to get separate files in safari ?\nOn Sat, Mar 29, 2014 at 1:03 AM, Jonathan Ong notifications@github.comwrote:\n\nproblem isn't just syntax errors. runtime errors don't have good stack\ntraces in safari w/ sourceURLs. not sure how much source maps would help. i\nplan to add syntax error checking anyways.\nor does everyone only debug on chrome o.O?\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/247#issuecomment-38982149\n.\n. a syntax error or any error ?\n\nOn Sat, Mar 29, 2014 at 7:24 AM, Jonathan Ong notifications@github.comwrote:\n\nyeah, but when an error throws, i get \"undefined\" in my stack trace.\nwoohoo!\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/247#issuecomment-38989011\n.\n. dang. maybe use chrome ;-)\n\nOn Sat, Mar 29, 2014 at 7:29 AM, Jonathan Ong notifications@github.comwrote:\n\nany error during runtime\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/247#issuecomment-38989085\n.\n. The nice thing about using the DOM is that you don't need to explicitly bind components to each other.\n. \n",
    "jacquestardie": "Thanks. New to this. I'm skipping through the components looking for an example. You aware of any that support building jade or stylus?\n. Alright, thanks. Think the approach is brilliant btw.\n. ",
    "esundahl": "It still doesn't install the required dependencies in lib/foo and lib/bar. Do I just need to go into each of my those dependencies and 'bundle install' them separately then?\n. Works great. Thanks!\n. Thanks.\n. ",
    "pyrotechnick": "Here be dragons.\nI fear this would fail harder than it has in npm...\n\n\ndependents\npackage\nengines\n\n\n1603\nunderscore\n\n\n\n972\nrequest\n'node >= 0.3.6'\n\n\n952\nasync\n{node: '*'}\n\n\n907\ncoffee-script\n{node: '>=0.4.0'}\n\n\n794\nexpress\n{node: '*'}\n\n\n...\n...\n...\n\n\nInterestingly, these packages (or at least parts of them) have all been utilised in both node and the vast majority of browsers to various degrees. And yet there's evidently very little incentive to populate the engines field of the package.\nI'm guessing this is primarily due to a lack of formalisation.\nIs it > IE7 or >= internet-explorer-v8 or IE8+ or microsoft-ie-8 or ms-i-e-8 or etc. ?\nWhat about the specifics like combinations of platform/browser/codec/plugin/extension/flags/preferences?\nWhat actually constitutes a browser? Is it the engine like trident / webkit / spidermonkey? Or is the vendor like Microsoft or Google Et. Al. or Mozilla? Or is the product like Internet Explorer or Chrome or Chromium or Firefox? Or is it a combination of all these?\nSeems a bit like opening Pandara's box.\nSomehow I think you'd have more success with a full-text search over names, keywords and descriptions.\nNevertheless, I'm interested in your proposal :)\n. +1\n. I just had a rather thorough look through markup, redcarpet, sundown and could not find a single reference to caching, or any real difference in http/https for that matter.\nThere are, however, references to this behaviour in publications by Akamai; the CDN fronting GitHub.\n. > @weepy \n\nit's because if they link to a http image from a page that's https ---- it\nwill break the security of the page.\n\nIndeed, as @silvinci mentioned in his comment:\n\nTravis' images aren't cached... but components logo is. Could it be that, GitHub only caches non-https images, so that we users don't get that pesky warning? I think so, because Travis' build status is delivered via https, whereas the component logo was originally delivered via http.\n\nThe question remains: does it simply proxy the asset to avoid mixing protocols or, more complexly, does it also cache them during this process for some substantial amount of time too?\nIf not, awesome. Let it proxy.\nIf so, for how long? Can it be bypassed or limited?\n. Green from here in both the email notification and from the site too :)\n. Looks like camo is the proxy. Yet that's still all behind akamai.\nLayers. Onions have layers.\n. Thank you for your Sherlock Holmes-calibre investigative insights @silvinci\nI've wanted to probe deeper into this kind of thing in the pursuit of the elusive, dynamic README.\nThe latest test is still red for me; I suspect it will remain that way until an edit but I'll keep watch.\n. Still red. I'm hopeful for some kind of polling sorcery.\nNevertheless, having to bump the README isn't the end of the world.\nConsider it an incentive to keep it maintained.\n. It's definitely still red from here (iiNet, Australia).\nAs I understand, Akamai practises all manner of witchcraft against space-time.\nNothing is immune to the uncertainty principle ^w^\n. ### Schr\u00f6dinger's Cache\n\n. We have liftoff.\nI repeat; we have liftoff.\n\n. Caching! Caching, Jan, you boy. Drained dry. I'm so sorry. Here, if you have an image, and I have an image, and I have a CDN. There it is, that's a CDN, you see? You watching?. And my CDN, reaches, acroooooooss the internet, and starts to cache your image... I... cache... your... image!\nI CACHE IT UP!\n. > if it works for travis it will work for component\nThis presumes\n- GitHub isn't making an exception for Travis\n- We don't want to make the effort to keep the counters as fresh as possible\n- We don't want some other, perhaps even more dynamic, information in the badges\n. > @visionmedia\n\nmaybe github is respecting:\n\nCache-Control: private\nContent-Disposition: inline; filename=\"passing.png\"\n\n\nGood call. Naturally, Akamai seems vastly configurable WRT all of this.\n@silvinci Perhaps more insightful than using gh-pages would be something we can get at the logs of.\nIf only we had a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications, using an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.\n. FYI this was fixed in 77d8a3b573f93b9b5894363a9768a59b07809d32\n. FYI this was fixed in 77d8a3b573f93b9b5894363a9768a59b07809d32\n. ",
    "slaskis": "Maybe it's enough to simply add a check for res.ok here?\n. ",
    "camwest": "Where do you think the best place to add this to the FAQ is?\nCameron Westland\nVice-President, Products\n647.887.8644\ncameron@bigbangtechnology.com\nOn Sun, Nov 4, 2012 at 3:11 AM, Julian Gruber notifications@github.comwrote:\n\nPrivate github repos are handled via\n{\n  \"remotes\" : [\n    \"https://user:pass@raw.github.com/\"\n  ]}\nfor Github supports basic auth.\nIf you want them completely inside your infrastructure check\nhttps://npmjs.org/package/contre\nYou would add this as a 2nd remote on your component repos and push to it\nwhen you release a component. Then you only need a static file server (like\nconnect with the static middleware) that serves the public folder. The\nurl of this public file server again goes into the remotes path of your\ncomponent.json.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/123#issuecomment-10048325.\n. \n",
    "wilmoore": ":+1: \n. Are you thinking, add a secondary option like --module-amd or simply have --standalone build a UMD-like wrapper?\n. I've been spiking on this trying to make it more concise: https://gist.github.com/3880415\nI'm sure it can be improved upon greatly.\n. It's just an example of how one would do imports, exports, and module definition across AMD, NodeJS, and Browser Globals. The underscore import is just a contrived example. Some modules won't have any dependencies, some will have more than one.\nI am currently using this in a project where I can't convince the rest of the team to adopt \"component\" (we will be using RequireJS), but we have a ton of code as globals so we need to incrementally move to modules but browser globals shouldn't break just yet.\n. The one in Mocha seems to work quite well.\n. If such a feature is to be supported, it would be much more useful to allow output groups. For example, you may want to output two built files. One for application stuff and another for 3rd party/vendor stuff. This is just one configuration scenario, but other scenarios should be supported via configuration.\nObviously a single output file should continue to be the default as not all apps will have this requirement.\n. I agree with the - convention; however, that being said, I'd still love to see the lower-casing (case insensitivity). That whole, it just works feel will really help with that first impression which sadly, is what it comes down to sometimes.\n. The original for context:\n```\nbuild: components index.js\n    @component build --dev\ncomponents: component.json\n    @component install --dev\nclean:\n    rm -fr build components template.js\n.PHONY: clean\n``\n. @timoxley easier to bat the mockup around in an issue in case it isn't desirable as-is :)\n. That being said, #214 has been created.\n. We should close this also :)\n. If this PR doesn't fit with the design goals, we probably want to close this.\n. Added a commit which _should_ be safer: https://github.com/component/component/pull/215/files#L0R49\n. I had a feeling this would be the sentiment. I can't say I disagree.\n. Probably should get this article posted somewhere without a registration wall. Let's table this until then.\n. :+1: \n. +1strings`\nIt's not perfect, but it's semantically better than the alternatives and cuts through all of the bikeshedding\u200e. That being said, if someone implements this via templates, I don't expect many feelings to be hurt.\n. @timoxley \nProbably something you'd want to do in a custom command (not via core). Assuming this PR isn't accepted, I will just continue to use a custom Makefile each time I create a new component (i.e. I generally don't do npm install -g ...).\n. Unfortunately, this line always creates the file (even if empty). We probably want to put a guard around that.\n. Perhaps the safe and simple condition is:\n!conf.styles || !conf.styles.length\n. Um...yeah, I have no idea what I was thinking when I wrote that :)\n. ",
    "Pickachu": ":+1: for Asynchronous API\n. The problem was an outdated version of nodejs.\nUpdated node to v0.10.26, and now everything works.\n. ",
    "ronkorving": ":+1: would really love to see a component-install API.\n. :+1: \n. You just killed my use case. I guess I'm gonna have to come up with a new workflow.\n. I can do without, but it makes sense for me to have it central. The flow of my builds is as follows.\nI serve a one page app, but the app is still fragmented into multiple builds. Those builds are individually injected into the one page app around first use. Their order is fixed. To make those builds, and not repeat dependencies needlessly, I let each build fill the ignore list of the next one. To install dependencies, I run a component install pass on all folders that represent such a build. Since many dependencies overlap, I use a common components folder for all my dependencies.\nI'm not saying there is no better workflow, there may well be. It may be better to simply install everything for each build folder, even though I will not end up using those downloaded components. But for now, this is how I've been doing things.\nSo can I live with this change? I can probably deal with it. The fact that all components end up scattered throughout my repository does have an effect on how I make clean my project. I like having all 3rd party dependencies in one place, distinctly separate from my local components.\nAnyway, these are my 2 cents. I will leave it to @visionmedia to revert, or not. I won't argue. I'll just... cry a little inside ;)\n. Looks like that could work. I'll definitely try it out, thanks for the tip!\n. They share the same source, but as it is right now, --force is simply broken. It's only usable for people who are lucky enough not to be hurt by it. It really boils down to luck, so if you ask me, it should be fixed (independent from semver, as I imagine that's gonna take a while) or --force should be removed.\n. The redirect mechanism exists for a reason. Does your browser, on redirect, tell you \"You should've typed a better URL, too bad. Try again.\"? No, it follows the redirect.\nA warning would be appropriate. Eg: \"This project has been renamed, you should probably update your dependencies because the name you are currently using may no longer exist in the future.\"\n. Right now, I add everything that got built in page 1 to the ignorelist of page 2, etc. The order in which I load pages is deterministic, so that works really well for me.\n. @stephenmathieson Of course hacks are possible. But this used to work, and it wasn't hacky, was it?\n. Until the new version of component and component builder are out and useable (to me, nothing using generators is usable until Node 0.12 is out and ideally has the generators harmony flag on by default), reintroducing --out will do the trick for me. I would love to use an API instead if I could.\nPlease keep in mind that solutions for tomorrow are great discussion material, but many of us need solutions yesterday.\n. It's probably me, but why does this say https?\n. ",
    "micky2be": ":+1: for an API\n. I also use nested components, it makes a lot of sense for my app structure.\nI have something like that\n- generic-components/\n  - core/\n  - a\n  - b\n- app/\n   - app-components/\n     - c\n     - d\n  - pages/\n    - main/\n      - e/\n      - f/\n    - other/\n      - g/\n. Yeah, it seems very difficult to work with local dependencies. \nMy local dependency has an other local dependency, looks like the builder can't find this grandchild dependency.\n. Seems that, when using component install we need to put the path of the grandchild dependency in the current component.\n. :-1: Even if it looks usefull, I don't like magic\n. Trowing a stone in the void here but does anybody has a fix?\n. :+1: \n. +1 for using local\n. It's a big issue for me as well\n. If you put all path needed in the root component.json it's working perfectly.\nBut it's not scalable for big project. It will require you to know all the dependencies of dependencies....\n. Exactly. This is a major issue that will need to be fix. \nI'll see what I can do on my side and provide a fix if I can find something. \n. See #337 for a fix\n. Kinda need a fix asap on this.\nSo, any feedback would be appreciated.\n. Include fix from #336\n. @visionmedia > Let me know if you wanna me to do any change on this\n. Will make a test then.\nBut if you look at #324, you will see I'm not the only one having the problem\n. @visionmedia Added a test to replicate our problem\n. @dominicbarnes I'm glad it fixed your problem\n. Weird, I may have messed up during a merge or something.\nI pushed a fix anyways\n. It's not like I wanna to pression on @visionmedia but this is getting old. \n. Oh! The file was ignored by git. Pushing now\n. Git didn't see those even with the .gitignore update.\nGonna force them\nOn Jun 19, 2013, at 9:04, TJ Holowaychuk notifications@github.com wrote:\ndamn, still missing the other ones, master has\n!test/fixtures/**/component.json in the .gitignore now so it should be less\nannoying that way, but \"direct\" and the other two are missing for me as well\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/component/component/pull/337#issuecomment-19651762\n.\n. Sorry for the delay, I had to do it from my phone\n. It's in since v0.16.4\n. Not having any problems on my side. You sure all your paths are correct?\nIf you really have a problem you should definitely open an issue.\nDon 't forget to mention versions (component, node), and describe your use case.\n. It's something we should keep in mind for sure.\n//# sourceURL has already been implemented in Google Canary :wink: \n. Since it's more a builder problem I opened an issue in there\nhttps://github.com/component/builder.js/issues/105\n. Coming a bit late on this topic but, the best way for me to require an html file would be to get a dom element, a documentFragment I should say.\n. So what do you do with your string then except appending ot to your main html?\nWith a dom you could at least work with it before. \n. Well I thought we were talking anout requiring a native html file, not a template file. \nI'm sorry but for me if you require html you should get a dom. \nPlugins or parsers should be use for templates not for pure html. \nJQuery shouldn't have any problem with getting a dom element. \nInstead of doing a search on ':athing:' use data attribute. \nI don't really get the idea of the string. With json, you don't want the string, you want an object, right?\n. It should be optional anyways. I mostly create local components, why should I enter a repo?\n. @ericgj My bad, I didn't know that. Very useful information.\nI always create the files manually anyways, I'm using a different style guide.\n. +1\n. :+1: \n. +1 for this fix\n. Well npm is more like\njson\n{\n  \"name\": \"version\",\n  \"name\": \"git@github.com:user/repo.git#tag\"\n}\nSo component does already almost the same by doing\njson\n{\n  \"user/repo\": \"version\"\n}\n. Look at #360 if this is your problem\n. :+1: \n. Personally I wouldn't put any entry on component install. npm install doesn't.\nA component add would make more sense or an component install --add.\nI don't use the same code style than what Component create for my json files in my projects, so it's kinda frustrating to have those lines added with a different style.\n. You have a good point that I forgot here, the entry in component.json is mandatory to make it work.\n. Might be annoying but the good news is that it shouldn't break. Basically /./ is the same as /.\nThe browser will consider \"build/mycomponent/./images/icons.png\" same as \"build/mycomponent/images/icons.png\"\n. I had to rollback to v0.16.7 to have it works\n. Not sure it's netrc issue.\nBut I will investigate today to pin point the problem.\n. What about putting netrc back like the TODOs mention?\nhttps://github.com/component/component/blob/master/lib/Package.js#L256-L271\n. @visionmedia If I put back netrc in there it works again, but what about the issue #374?\n. @visionmedia On another topic, what do think about authentication through prompt or ssh key?\n. Anything I can help on superagent? I kinda need netrc to work urgently\n. Not sure I can really test properly since I never run into the problems mention in #374 \nWell, I'm still using node 0.8.x, so it's probably something that appears with node 0.10.x\nGonna start with that.\n. @visionmedia Did you experienced the problem yourself? And is there an easy way to reproduce it?\n. +1\nWould help me to get my team up to speed\n. That's good to know\n. That sounds totally awesome\n. I would love to see documentation\nWe use it very heavily here but it's hard to get new people up to speed.\nI'll try to help as much as I can but sadly I'm not really good at writing documentation myself..\n. :+1: \n. There is already an issue open on builder.js\nYou are welcome to complain there :wink: \nhttps://github.com/component/builder.js/issues/117\n. I'd like to get camelCase back in.\nI stuck with Component v0.18.0 on my projects just because of that\n. Using Master is usually a bad idea I will suggest to fix q instead and to have your dependency pointing to that new version\n. I personally don't like to have 2 different behaviours between prod and dev.\nWhy would you need different version of the same dependency?\nI also usually minify the build for production release. So having the dependency already minified doesn't provide any help.\n. > I don't really understand this statement, sorry. Can you elucidate?\nYou'll have to setup 2 different dependencies based on your environment.\nNothing guaranty that user/repo-min act the same as user/repo. And it's becoming difficult to manage.\nBut that's just my opinion and how I manage my projects.\n. Yes yes yes yes\n. -1\nSeems normal to me. If there is no release/tag available why should it take master?\n* should mean the last release available, and not master. \n. For our projects, that are still using Component, we are not writing component.json files anymore.\nWe generate them. \nPlease take a look at https://github.com/Wizcorp/component-extractor\n(PS: not tested with Component v1)\n. ",
    "TooTallNate": "The problem is that component-command is really component-commant.bat on Windows, which is not directly executable, but instead must be executed as the argument to cmd.exe. The upstream tracking issue is joyent/node#2318.\n. Update to node v0.8 or newer please.\n. Ya just use the .pkg installer. It's the simplest.\nSide note: to use n, you would do:\nbash\nsudo npm install -g n\nsudo n 0.8.16\n. It is indeed already fixed on master branch, but apparently v0.11.7 has been out for a while, and there hasn't been a v0.11.x release with the fix yet: https://github.com/joyent/node/commit/f31037ddfefdc8fab94980cd16a525827ba19abf.\n. I don't think we need this anymore as of cfcd0c8f8403d22b8f39f7a7373f5ee29b61da80. Please open a new pull request for any additional fixes. Thanks!\n. /cc @guille @coreh \n. /cc @MatthewMueller \n. > we're a bit screwed if 5 libs use emitter 0.8.0 and 2 use 1.0 or something like that\nAccording to semver, those 2 versions should be API compatible, and thus only one copy of v0.8.0 should be included in the build.\n. > Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable.\nOh gawd, I hate that they added that line... It makes no sense and ruins the programmability of semver... If you break the damn API, bump it to v1. It's not a big deal. v1.0.0 isn't sacred.\n. +1\n. You could just use gnode's programmatic API as well\nOn Sunday, December 15, 2013, Jonathan Ong wrote:\n\ncomponent/builder.js#133https://github.com/component/builder.js/issues/133\ni was checking out @ianstormtaylor https://github.com/ianstormtaylor 's\npackage.js and installer.js source code, and i realized that improving it\nwill be a pain in the ass due to all the callbacks. so of course, i\nthought, \"generators?\"\nwe closed that issue in builder.js because we didn't like the node\nrestriction. we won't be able to use generators without\n--harmony-generators until both node 0.14/0.1 and es6 is finalized. how\nabout we write it so that it'll work now and later?\ni'm thinking we write it in generators, but compile it using regeneratorhttps://github.com/facebook/regeneratorlike it's coffee script. so the file structure will look something like\nthis:\nlib/\n  installer.js # source\nbuild/\n  installer.js # regenerated\nindex.js # delegate\n@visionmedia https://github.com/visionmedia maybe you want to call it\nsomething else than /build/. index.js will look like:\ntry {\n  module.exports = require('./lib/installer.js')} catch (err) {\n  module.exports = require('./build/installer.js')}\nwe won't ever have to change anything, and it should support 0.8-0.10.\nwhat you guys think?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/454\n.\n. The filename needs to be .netrc, not _netrc\n. There's a X-GitHub-OTP header we can send as well, if we wanted to implement like a --2fa=123456 flag or something like that: http://developer.github.com/v3/auth/#working-with-two-factor-authentication\n. Could use something like: https://github.com/rvagg/ghauth (note the built-in OTP support).\n. @MatthewMueller Sure, but that's \"token\" support, not 2fa support. I'm thinking they're slightly different, but I guess this works for now.\n. @visionmedia There's an Unsubscribe button FYI, though I think ignoring the requests of your users is a pretty lame way to go about this.\n\nThere seems to be some demand for package.json's \"overlay\" field to be supported. What's the issue with that for people who want to use it? component.json could still be the preferred file name, however I'm in the same boat as thinking it's a PITA to update the version in 2 different config files.\n. I hate to be the pessimist here, but that's what happens when we don't use the publicly documented API :\\\n. > so you could split up your app into separate repos or something\nExactly :) Is a quick fix possible or is it a good amount of code?\n. ",
    "retrofox": "@weepy \ncomponent docs component/model\n. wow, haha. it's true.\n. oh man, I'll move the app to another server.\n. https://github.com/retrofox/component.js\n. thxs @danzajdband\n. mmm, I have to re start up. I'll do it soon.\n. ",
    "nick-thompson": "Were you thinking an additional bin/ file for this? Or a direct alias? I was thinking you could solve this pretty easily the same way you alias add to install:\nhttps://github.com/component/component/blob/master/bin/component#L52\njavascript\nif ('update' == cmd) {\n  if (!~args.indexOf('-f') && !~args.indexOf('--force')) \n    args.push('-f');\n  cmd = 'install';\n}\nThe downside to the above would be that the help documentation (-h, --help) wouldn't necessarily make sense. That's the only reason I can figure adding an additional bin/ file would be worthwhile.\nIf you're interested in that code snippet, I'd be happy to plug it in, write up a test, and send a pull request.\n. ",
    "jkroso": "would be useful to have it install the absolute latest tag of each dependency regardless of what version is specified in the json. Then you could run the test suite and use $ component update --save to update to 'component.json' file once everything is green.\n. Is that since you can't have multiple instances of a CSS component?\n. I don't think CSS will ever be any good for applications, its really badly thought out. I had an idea for a JavaScript library the other week that could take CSS style code and apply it directly to the style property of nodes. That way you avoid having everything global and the composability issues that go along with it. I haven't found time to start implementing anything yet though. \nAnyway though I think every problem you could think of with CSS components or CSS component plugins is there already and always will be with any CSS. I don't see how they are specific to plugin based components or the automatic \"plugging in\" that I suggested. \n. +1 for no sloppy semver syntax. I think there has to be a better way to auto update deps than that.\n. I mean anything that isn't explicit, so 1.0.0 is good but * is bad. Anytime you do that your effectively deploying untested code because 2 weeks from now deps will have been updated and any fresh installs are going to get the new deps. Automatic updating is good but not without at least running the test suite first and creating a fresh release.\n. yea actually do we have to put versions in the json at all? Im kinda sick of doing that :). component-set makes updating deps easier btw.\n. @smagch in a lot of cases \"component.json\" is out of date and doing this by hand sucks anyway\n@smagch its a judgment call you need to make on a case by case basis. I think we could use a version selector in the command which lets you choose roughly what gets added. e.g. something like $ component add jkroso/graph \\~0.1 might add \"jkroso/graph\": \"~0.1.9\" to the json. The default should always be to pin though and thats all I want for now.\n@visionmedia would you take a PR?\n. @smagch the alias thing?\n. probably a bad choice of words on my part. this is my Makefile atm\n``` makefile\nbuild: components index.js\n    @component build --dev\ncomponents: component.json\n    @touch components\n    @component install --dev\n```\nso the above works fine but if I take out the touch and run $ touch component.json it'll always run the install thinking \"component.json\" is newer than \"components\"\n. thanks\n. @thirdreplicator not really components can and are consumed by other packaging tools just as easily as component itself consumes them. if component is a framework its a pretty good one.\n. nope its correct. they ended up in the same repo because they share most of their code. I'll update my readme so its clear\n. I think an approach similar to https://github.com/TradeMe/bootup.js could work well. Basically that means constructing builds on the client rather than the server. It'd benefit single page apps too because a small change in one module wouldn't result in the entire build being invalidated.\n. > adding specific support for them in JSON I think that's too leaky personally, hard to express the same options you can with regular js closures that just take arguments\none way to deal with that might be to allow referencing local files from the JSON. So in the example above you might write:\n{\n  \"transform\": {\n    \"*.js\": [\"./custom-deamdify.js\"],\n    \"*.less\": [\"less\"]\n  }\n}\nThe local file would then have all the options hard coded so it can just process the matching files. Note the glob selectors as keys, they are just a lil more flexible.\nThere is still the problem of installing build dependencies like \"less\" but perhaps they could just listed in the \"development\" dict and installed with component-install. Anyway I like the idea and I think its probably do-able in a water-tight way.\n. you can raise the rate limit to 5000/hr by providing your login details, which should be plenty I guess. component-set supports it too so I'll mention it there. I'd still be stoked to have a registry available though.\n. @sankargorthi kinda. I think remotes are assumed to have similar semantics to Github which would make things messy if any registry wants to do things differently.\n. A CLI could easily give you back whatever you like about the current format, apart from not needing a CLI obviously.  You could support both formats happily at the same time too so no need to break anything. Whatever though I'm not super fussed right now.\n. ",
    "vendethiel": "\"some/foo\": \"*\",\nThey're not versioned. I'd vote for \"useName\": \"/path/to/component/\",\n. Please, for windows users. (even if it still work as separate command)\n. Also, asset pipelines can allow to have multiple file requirements for easier dev debugging, while still using a monolithic file\n. > may re-open this if people keep wanting to build monolithic apps instead of modular ones, seems like a lot people are kinda confused by the idea\nI think component should keep the philosophy. People like me, yields or everybody else just got to \"get it\" ;).\n. seems more user-friendly than dev-friendly, isn't it ?\n. My use case is that I've already got too much 3rd-party folders around. One for composer, one for component, one for other vendors ... That's too much, I'd like to namespace them under vendor/\n. True about building, but my point was rather about installing (even if you don't install that often).\nAlso, about building, @component build --out vendor/component will fail to find the component.json file, thus won't work\n. Then I need to copy first the .json file, but for some reason it fails with the message \"unable to find package component/...\" Like I'm not in the dir\n. I'd be ok with the Makefile solution it it was working\n. @jhnns everything is first-class with component, which doesn't work well with non-flat directories. I agree I'd like to be able to use require('./templates/item') from user/views/item-view\n. no I agree that your features things should be in components however in my app I have a module register()ed for each controller/action, how am I to structure that ?\n. well for example I have to create a form validator for registration, I'll have a module for form validations, required by my module controllers/Account/create, itself required in require('MyApp');\n. I currently have http://i.imgur.com/vBJuQot.png\nso yeah the controllers/Account/create will require controllers/Account/validator etc\nit's autorequired from the php action I don't want to mess things\n. @isaacs component relies on component.json's name. npm has far too many entries and all names are literally taken, which is why component uses the username/repo github-like naming style .\n. This is also an option, but that means keeping modules for every page I load. Doesn't seem very memory-efficient\n. Another point is that it requires me to add another indentation level. I'd like to avoid adding more and more scripts tag - this is passing through a kind of \"asset pipeline\". (I'm currently unsetting require.modules[name] before the ajax call start atm)\n. Yeah, I'm currently returning a function, I was talking about the {init: } - adding one more depth. Thanks anyway\n. I had a solution when I came up with issue at first : \n\nI'm currently unsetting require.modules[name]\n\nBut that's not a clean solution.\nIf you think that's not a valid suggestion/feature request then feel free to close :).\n. How much does it hurt ?\n. You have to list the scripts so I guess yes ? (could default to index.js ?)\n. It should have sourceURL so that chrome etc can read from it.\n. That's a pretty deep abyss...\n. component.io says : \n\nN.B. This website has not yet been deployed. In the mean time you can check out component.jit.su (the outgoing website)\n. I havn't tried it yet, but seeing how they're doing it (no handle+full events), it seems like one nice debug hell. Here goes another thing that will use component(s) all over the place so that it creates more confusion :p.\n\nEDIT : I can't get their example app to display an email, btw.\n. #248 \n. Close maybe ?\n. > I think we have this same thing discussed somewhere else, maybe component.io\ndo you mean the thing with iframes etc?\n. Probably because this gives \"enough\" freedom and is gpl-compatible, probably\n. To start with, what prevents you from being polite ? Do we not deserve it ? Do the others repos you've issued are not deserving it either?\nThis asides, you have to npm install it (and in case you don't know what npm is is ... \"Damn Google It\" ;)?).\nThe $ is just the base terminal line. If the command you have to type is $ component install abc/foo, you'll have to type component install abc/foo.\n. Can you type in npm -v, just to see?\nIt looks like node didn't overwrite the old executable when you compiled it yourself.\nCan't help you much more than this sadly, never had a mac.\n. > @ckizer - for mac it's best to install node/npm using the installer found here http://nodejs.org\nHe apparently had a problem with that\n. here, probably.\n. no updates on IRC either I believe it's broken and tj probably didn't look at it for now\n. yeah I saw that's why I closed\n. https://github.com/btknorr/bootstrap\n. ah, right, like you did with your uikit\n. Interested in #269 ?\n. I think @forbeslindesay made @jepso-ci for that\n. should've been fixed in #280\n. :(\n. Well, it's always interesting to see other people write articles, to see it quoted on websites etc.\n. I'm talking about things gravitating around. I'd love to be able to search for it, ie if somebody wrote an article on it (even if I'm probably see it if you tweet it)\n. Agreed with that\n. close then :D \n+1 for the wishlist\n. > i think \"process.env.HOME\" is \"process.env.HOMEPATH\"\nIt's HOMEPATH for windows only\n. > As I see Issue #148, * is going to reference the latest tag.\nyes, but dynamically. This issue is about using component-add(1) command to fetch the latest tag and save in the .json as \"name\": \"fetchedtag\"\n. interesting idea\n. I don't think these are good names\n. this was changed for compat with oldIE (currently you have to use /* //@ sourceURL) but I'm not sure we should change it before it lands as a release (for both firefox and chrome)\n. +1 for op and the one before me\n. agreed, this bites me some times\n. \"for non-local components\"?\n. \"with this simple tip, learn how to shave 100ms off your component-build task in only 2 weeks\"\n. >  (which won't work on some older browsers)\nonly very old spidermonkey, no ?\n. releases are tied to tags anyway.\n. :cake:\n. 404 elegance not found ;) ?\n. Your ide/text editor should help you\n. :heart_eyes_cat: \n. I like how composer does it. You register once on the website (the default repo is packagist), and every 5 to 15 it queries the repos to check if a new git tag is present (you also have a button to refresh your package).\n. 5 to 15 minutes*.\n. > weird people on bitbucket\nhahaha\nSounds very cool :)\n. Looks neat -- Interesting !\n. I'm using windows with component, but that's 0.19 for now so maybe it got broken\n. Just tested with component 1-rc5 and yep, same. \\u\n. can't you message them if you have a paid acc ? Seems like they could allow a bit more\n. shouldn't it imply --watch ?\n. Either require it or make it implicit, imho.\n. Haha oh wow thanks @jonathanong :)\n. Travis failure looks like a transient failure ? Seems like it's #548\n. I wonder thogh, should this really be in the core ? Do we consider it's a common enough case ?\nI see how --watch is useful for nearly every component but I'm not that sure for --reload\n(I'm actually wondering if people later will come and ask for another option to change port and stuff haha)\n. The list keeps getting bigger :(\n. not really\n. not sure if npm should install RCs though :/ maybe when they're major, hard to tell\n. > @visionmedia left node.js land\nI think he said he'd continue to use nodejs for websites, though ;).\nDuo takes a much more declarative approach than nlz, which pretty much \"guesses\".\n. Yeah, they're for different things alright (and i'm not going on the go boat but anyone is free to!)\n. :+1: \n. well, the individual components should still work fine, so long they have a bower.json / package.json / something else to be used\n. I think it's possible with a builder option, no? I don't think it's part of the .componentrc file, though.\n. -r ?\n. typo \"compnoent\"\n. ",
    "rschmukler": "Personally I am looking to do something like TJs screencast, but with a little bit deeper level of organization. My directory structure looks something like:\nlib/\n    models/\n    pages/\n...\nThe problem then comes for adding paths, I would really like to just add lib and then set local to something like this:\ncomponent.json\n...\n\"paths\": [\"lib\"]\n\"local\": [\n    \"models/user\"\n    \"pages/user\"\n  ]\nDoes anyone have suggestions how I can make my folder structure work with components as it exists today?\nIdea being that I can use component to require a client-version of the user model, and even use it to render pages client-side or server side with (mostly) the same code...\n. @yields Correct and then lib/models/user would have it's own component.json etc...\n. @yields That's what I am doing right now, but it doesn't solve the namespace collision that I'll run into. I end up having to do addLookup('lib/models').\n@visionmedia I like gjohnson's solution, personally. But at this point, any solution would be fine. Is there something you're waiting for to make the decision beyond certainty?\n. No rush, you do amazing things. Just was wondering if there were questions left to be asked or whether it was a \"matter of time\" thing\n. @visionmedia What were you thinking for the spec on this? I don't know if I'll have time/be able to figure it out, but if you post what you're thinking I can at least take a look.\n. I'm also with @visionmedia on not resolving the local ./components -- in my opinion it can make the application quite  messy and doesn't lend itself to using the same sub-components in different larger components very well.\n. @visionmedia in that way would you also allow something like paths: [ '../some-other-component']?\nMy dir structure looks something like this:\n- lib/\n    - components/\n         - some-component-a/\n         - some-component-b/\n    - pages/\n         - some-page-a/\n         - some-page-b/\nWhere some-page-a and some-page-b both might use components from the components/ directory. Pages then basically map out to express routes w/ views that can be rendered either client or server side (and as such package themselves up in some-page-a/component.json such that an application router such as pages.js can render them client side too.\n. @eldargab I absolutely agree that nested components should be possible, but it shouldn't be dependent -- since the whole point of using components is reusable and modular code.\n. @visionmedia Yeah, I definitely have run into the unique name issue. As such folders in lib/models are usually named like user-model etc. This solves the naming collision and helps me keep it a bit more organized.\n@ianstormtaylor what do you mean by single builds? I am planning on releasing a blog post/screencast shortly showcasing how I am using component and a few other libraries I wrote to do shared views/models/routes client and server side. It's got me really excited and definitely wouldn't be possible without @visionmedia and his awesome work on component.\n. @ianstormtaylor Ah yeah, nah nothing like that yet. Interesting idea though.\n. @visionmedia Could you share some insights about how you guys go about re-using model logic in various components under that structure?\nAlso, initially the unique names constraint felt taxing, but now that I've actually gotten some depth in my project I actually feel it's better regardless of whether it's required or not.\nGranted require('models/user') would also work fine, but require('user-model') is still good I find.\n. Absolutely agree on the mess of ./views, ./models, ./styles, ./assets. Within our components everything is nice and flat, it's just a question of where the components go. I use a dir-tree from time to time in my editor and I think that may be the distinguishing difference. I think that if I didn't, it'd be irrelevant since Cmd+T/Ctrl+P just takes care of it for you; but having a massive list of components in the dir-tree can be a bit claustrophobic.\n. ",
    "razic": "Anyone come to any solutions to this?\n. :thumbsup: \n. @jhnns To my understanding, component(1) is not just for client side components, as @visionmedia points out in the Wiki and his blog post.\n. @jhnns I understand that. In fact, one of my projects for work isn't using components but we wanted the drop component. I didn't know at the time it came in the form of a node module, so I used component build --standalone to put it into my application.\nMy point is that I feel like publishing to NPM kind of defeats the purpose of one of the things component aims to solve; the namespace issue.\nAlso, nobody wants inconsistant names. If I am going to dual publish to NPM like everyone else, then I don't want to have to name it tappy on NPM and tap on component.io.\nI'd like to hear @visionmedia's thoughts about the subject, since he seems to be publishing the majority of components to NPM.\n. Not sure what you're saying here. Browserify isn't a package manager. \nOn May 18, 2013, at 23:21, Jonathan Ong notifications@github.com wrote:\n\nPeople use other package managers that use npm like browserify\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks guys :+1:\n\n@visionmedia Sorry to kind of use Issues as a sort of question board, however I do have a few more questions I'd like to be clear on. These questions may help other people who are wondering the same thing too.\n- My understanding is that you want to migrate your main application to using component but does that mean you will stop publishing to npm?\n- I know you said you recommend against publishing components that are in languages like Ruby and Python because they're harder to share amongst the community. Could you elaborate on that? What about it makes it harder to share? I think it would be cool to use one package manager for many languages. I see several benefits.\n- Last question and I really appreciate your time, but I'm coming from the world of Ruby where we have both a package manager gem and a gem dependency manager bundler. People never really use gem-install alone because they have a Gemfile that defines the dependencies and you just run bundle to sync those dependencies to that project. My question is, is component both a dependency manager and a package manager?\n. :+1: This would be a good idea. Putting * for dependencies is most certainly not a good idea.\n. if you're cool with that, i wouldn't mind sending a pull request\n. :+1: Thanks :smile: \n. ",
    "ghost": "no, just the github page itself https://github.com/component\n. still valid for current corrupted build of topcoat/topcoat, try it out.\n. Code was merged about 16 days back but unfortunately did not fix the issue. The issue exists in the master and 0.13.1 release.\n. remotes are working fine :)\n. I think one approach might be a warning not an error. A warning could be emitted if looked up on a remote and not found but there would only be an error on fatal after all the remotes have been tried.  Part of the issue perhaps also is verbosity for the install. Some folks don't necessarily need to be exposed to the verbose messages and only need  to see that their component got installed.\n. @yeilds The rationale for this option is to ensure components may be shared between builds. There is nothing that anyone from executing multiple builds within a project. Only that it is messy. If there are already components downloaded that are in common with another build, it is not particularly smart to have them downloaded again within the project. The option helps maintain a clean project structure so that downloaded components may be consolidated in single folder (with one or more manifests available in your project root). At the project root you are able to name your manifest anything you want. ie app.json\n. @anthonyshort your solution is similar to what I am doing now. The issue is multiple component folders for the downloaded results. From your example, this is my take on something less verbose and is not fetching many of the same components unnecessarily.\n\u251c\u2500\u2500 project\n \u00a0\u00a0 \u251c\u2500\u2500 base.json\n \u00a0\u00a0 \u251c\u2500\u2500 quote-alt.json\n \u00a0\u00a0 \u2514\u2500\u2500 quote.json\n \u00a0\u00a0 \u251c\u2500\u2500 components\nOf course this can be handled in your makefile or grunt regardless. Btw, what is you opinion on this. Since dependencies are spelled in json, I tend not to be concerned what is in components unless something goes wrong. More concerned that my code simply has the dependencies it needs. Ultimately you determine where you want the build to be for each so there is an accountability there to review from the build.\n. Am closing this issue. In the end the more I think on it, the duplication for separate builds is acceptable in a structure that makes it clear the dependencies for each build and maintains consistency the manifest name. I appreciate the comments.\n. I am a bit behind on 0.17 but have been using -o to direct build output to specific assets folders. Can this please be reverted.\n. I am using images within components. There is no issue with the current code. I use the copy option. More often than not, you consume images within the components in your CSS. This is just a relative path within the CSS you for your component. ie background: url(\"../img/checkmark.png\") no-repeat top left; An appropriate url is generated for the path in the resulting css for the build.\nIf you need to link to an image, for templates or HTML is just as easy. Add the copy option and the images will be copied to the a folder for the component. ie mickey2be/amazing-widget/img/iphone.png will be copied to micke2b3-amazing-widget/img/iphone.png. Use that path in your HTML or templates. I generally build a public assets folder that will be exposed by the server.\nThe only issue I have had has been with ulimit on osx where the image copying can die with the default value of 256. Increasing ulimit to 1000 takes care of this.\n. Please put it back, thanks. This is the second thread on this topic with out reverting. Would appreciate some solid rationale for leaving it out or put it back so folks using it can use it without hacks, forks, or other work around.\n. There is interest in having this option back. A collection of comments and two issues on this demonstrates interest and concern that does not seem to be heard. There is legitimate use case for building and locating the assets without additional software. Please take the feedback as constructive and revert this.\n. @visionmedia The browserify / component combination sounds interesting. As is stands I like the flat structure of dependencies and using git repos so will see where this goes. Browserify does not have a decent way of managing images and other files and somehow cannot bring myself to include these in a node_module.\nComponent has been from the start a simple and elegant way of managing dependencies without a mess of nested dependencies. That said, its difficult for folks to rationalize multiple manifests.\nWas disappointed recently by a move by socket.io-client maintainers to recently exclude component citing the die back of component.js as the reason for removing support for it  https://github.com/Automattic/socket.io-client/issues/729. Seems by number of stars on this repo that it continues to attract developers but perhaps this is a sign that a resolution is necessary. \n. @MatthewMueller Browserify is weak on CSS and assets where Component excels for modularization. I assume images, fonts, files etc are handled in same way as Component without the additional manifest boilerplate.\nCan you explain the scenario for CSS components with CSS dependents. This may not be common in public components but more apt to crop up in modular CSS Components that are private.\nWhen you say that most of us are onto something else, are you suggesting component needs a new maintainer? Can someone be clear about the segment.io sponsorship for the project and where this stands.\nIt would be good to understand the circumstances for those with a vested interest in continuing with Component. There are valid concerns if development has stalled.\n. @MatthewMueller This looks good. If we are looking at a flat dependency structure and \nES6 transpilation, CSS preprocessing through transforms, this could be pretty nice. Honestly, NPM has to go away in favour of consistent module management for client and server. Life will not be rainbows and unicorns until it is gone.\n. @MatthewMueller Can you advise on the bitbucket support. Thanks.\n. @stephanmthieson Great, let me know if you need help.\n. A bit of perspective. Components was about a components and the spec at the outset, not the package manager that works with them as much. It seems duo uses a duo.json that breaks with the existing component spec @MatthewMueller can you clarify.\nI also understand the concern about a manifest. Component/Component(1) is currently being used for more than front end work as a general tool \u2013 even by folks outside of the node community. It is part of many build workflows and one that doesn't particularly care about whether it is specifically used as front end javascript package and build tool. \nLooking forward, developers are also doing a number of things today that are not going to mean much with the future for JavaScript. npm and manifests fit into this category. Transformation or transpilation processes can be handled differently. That said, we are in this transition and tools that facilitate the newer workflows that allow developers to evolve is going to be helpful.\nThe problem we have with Component/Component(1) project atm is practical and we want an end to the limbo it is in. This was the reason for the thread. The fact the site is down and development stalled at an rc5 is hurting components in general and the adoption of an asset workflow that is better \u2013 regardless of what software is used to manage it.\nJonathan suggested splitting the Component/Component(1) code into its own github org account so it could continue to evolve. Duojs living in another org and the component org remaining as it is with the all the general component code and maintainers live here. Component and Duo are both tools that manage components.\nWe've offered to sponsor the component.io site and the continued work on Component(1). We'll support the newer workflows as they evolve regardless.  Component plays a role for us which is why we'd do this. If Duo is the next Component 1.0.0 living here we are fine with that also. One way or another, we want this resolved and the site back up for anyone to have confidence in components of any kind.\n. @MatthewMueller The efforts behind Duo look solid but am not sure I agree with the insufficiency of the component spec, only that its scope was different.\nFrom what I have seen, Duo is more purpose built with an alternative resolver that takes a lesson from browserify. It steps back to a builder with sensible plugins. These are both good things but may have been accomplished by offering resolver options in Component and reverting the direction that the builder took with the RC candidates (to arrive at a final with interesting character). \nI see this as both good and bad. If there is a stigma attached to Component as being onerous for its manifests, Duo might be a fresh start without the burden of its legacy. That said, evolving Component may have demonstrated that the mind share behind Component was able to resolve its warts and reward its community with a release. Perhaps this is what @visionmedia was getting at, hard to say. if Component's effect was to evolve alternatives that is also a good thing and expect Duo to be quite shiny. Its all good.\n. @stephenmathieson Hey, have you got your bitbucket code started or visible anywhere.  I'll likely be taking some time to start something if not. I've had a read through the code to review the gh support at this point but ready to dig into this.\n. @stephenmathieson Sadly, I am not able to access the duo-package repo just yet. Just don't want to repeat work someone may have already done. Agree with @stephenmathieson. Bitbucket may be behind on some capabilities but good value for private repos.\n. ",
    "devinrhode2": "We need a full site for component for searching. Cloning the wiki here serves nothing except a cleaner url, and prettier site.   Ideally this can/should eclipse any work on plugins.jquery.com What we want to do is fork toolbox.no.de\nI'm a fan of mutual hack sessions on G+ hangouts and/or skype\n. ",
    "necolas": "\nThe one in Mocha seems to work quite well.\n\nYeah, love that feature for small projects. Is the argument against adding --watch still true today? Thanks\n. Yeah, Apple have acquired the company or something. I don't know what the potential, related legal issues are\u2026just a heads up.\n. My bad. I see I should have been running make build.\n. That sounds familiar; not much of an issue then. Going forward I'll drop v to improve compatibility. Thanks\n. Doesn't https://raw.github.com need to be updated in that package?\n. ",
    "wprater": "getting the dreaded file limit issue on OS X when running component from /usr/local/lib\nError: watch EMFILE\n. ",
    "antoinerousseau": "http://superuser.com/a/306555\n. ",
    "jsalonen": "npm was a typo (edited original issue). component create test doesn't work either.\n. ",
    "andzdroid": "Can we get an update on this?\n. ",
    "Jody-Geers": "+1 for dev on multiple components collectively in an application environment. \n- just dont forget recursive repo commits :P\n. ",
    "rogeriopvl": "You got point there. I just managed to mess around with the contrast settings of iterm2, and it got a little better:\n\nSo it's solved. Thanks!\n. ",
    "egeste": "I would if I could. Issues are disabled for that repo\n. ",
    "btknorr": "I am having the same issue deploying to AppFog.  Any idea on when 'component build' will copy the assets instead of symlinking them?\n. Sorry for not being very clear on our issue...it's a little different, but can be solved by copying assets instead of symlinking.  When we check our code into git, it checks in the symlinks, not the real files.  When another developer pulls the changes, they get invalid symlinks.  Also if we deploy to a PaaS directly from git, the app will fail because of the invalid symlinks.\n. @ckizer  -  for mac it's best to install node/npm using the installer found here http://nodejs.org\n. +1 \nWe use --out for building components in the Titanium/Alloy mobile framework as a plugin.  We can do it a different way, but would rather keep it the way it is.\n. ",
    "robdodson": "yeah the symlink task is a little weird because it rewrites our url to /component-name/fonts/ but our test file is located in the root of the project so that would not work.\n. +1 !!!\n. ok that makes sense. so if my 3 themes were foo, bar baz:\ni would start with a vanilla button component\nthen make a button-foo component, button-bar component and button-baz component.\nthen I can make a foo component which aggregates all of my *-foo components.\nthanks!\n. Actually one more thing... how do you deal with things like color variables across the themes? I know that component discourages css preprocessors so if I have 60 *-foo components how do I make sure they all use the same red color and how do I quickly change them all without using something like SASS or LESS?\n. so we would probably have a theme variables component that each theme component requires?\n. yeah that's what I'm thinking. Do you know if anyone has done any work around turning bootstrap into a component lib?\n. yeah exactly like UIKit. We're discussing the possibility on our end..somewhat terrified by the prospect :)\nobviously it would be tricky to keep it in sync with bootstrap so that's our main hesitation.\n. ",
    "dotherightthing": "Thanks TooTallNate :)\nWhen I run sudo npm install -g n, it pulls down https://registry.npmjs.org/n/-/n-0.7.3.tgz.\nIf I try sudo npm install -g n 0.8.16 I get 0.8.16 is not in the npm registry.\nhttp://nodejs.org/ shows me a mac .pkg that I can install. Is this really the best way to keep my installation of node up to date?\n. @visionmedia Ah, sorry, am pretty new to this - misread the stackoverflow post and tried to run the commands together. :P\n. All working now thanks everyone :)\n. ",
    "pygy": "Another solution to this would be to add a component build phase to the npm install process, ie fetch all the deps with component, and build a standalone library.\nYou'd add a \"component\" dependency to package.json, and list component deps only in component.json.\nRedundancy is the norm on the server side, anyway.\n. Thanks, I just figured it out by myself, actually, after reading the source of a standalone build...\nVery, very nice :-)\n. ",
    "dominictarr": "Don't say \"naming things is hard\", that is just giving yourself an excuse to be lazy about naming things well.\nInstead, say \"naming well is a challenge\", that implies that while it's difficult, it's possible, and worthwhile.\n. A browser is not it's own thing that needs it's own package manager - it's just another VM. A VM that you don't get root access to, and has a few weird handicaps, but like VMs in a datacenter, it's just a sandbox that you can safely install arbitrary programs to over the network. Instead of writing your program to fit into the differences between the server and the client - what about designing your program to take advantage of the similarities?\nAfter all, that is one of the big wins of using js on the server and js on the client.\n. @MatthewMueller I'm saying there should just be one package manager that works for both, either use npm on the client side, or component on the server-side.\n. ",
    "dominicbarnes": "Any chance this same logic could be applied to JS? I have a component I'm building that's just an icon font (i.e. only CSS and font files) I end up with a build/build.js that only has the require code, and I can use --no-require to get an empty file altogether.\nIt's not a problem, as I can just ignore the js file, and when I build it within a larger component/project, it's not an issue at all of course. But, I just figured that for consistency and cleanliness sake we could apply the same to JS.\n. I've been seeing this in my project, are you using a custom remote, @MatthewMueller ?\nI submitted a fix a while back (#320) which actually seems to be causing a race-condition during install with multiple remotes, especially as the dependency list grows. (we have several dozen components we depend on) I've seen this error and another one in particular that I've been working out.\nI have a branch (https://github.com/treetopllc/component/compare/noblehour) I'm working on for my team, which once I verify is working as expected, I'll be contributing to component core.\n. It seems to be a race condition between the \"destroy\" method and the install of alternate remotes. Also, it seemed to come up more when the same component is depended on by multiple other components.\nIf you would like, could you try out that branch I referred to and see if it solves your troubles as well? I'd like to battle-harden this before I introduce another bug :S\n. I presume you mean getting rid of --out for both install, as well as build? Why would you want to remove this, I find it useful, especially for managing components in a larger project. (in terms of directory structure)\n. I don't have the luxury of working with shallow directory structures at work, so being able to choose my destination (ex: to put it in app/webroot/components for a cakephp project) is much preferred to sticking it in the root, where it really doesn't belong.\n. I can probably work with that, is there any chance of a less generic name than \"components\" for the default output dir? node_modules was a good choice for npm, as it seems few would have ever chosen that name first. However, I could easily see wanting to use the name components for myself. Honestly, no decent names come to mind right away, even something like .components or _components would make it clear it's \"machine-generated\".\n. Fair enough\n. All right then, I'll destroy the component.json for a package that encounters an error. I'll submit a PR for that feature hopefully very soon.\n. Sounds good to me, do you want this handled from within Package?\n. Blah, I keep running into race conditions. Batch doesn't wait for all in-flight async operations to complete before calling end, so simply destroying the dir causes the still-running file downloads to fail and kill the whole script.\nAs a temporary solution, should we simply not write the component.json file until it is determined to be a complete success?\n. Weird, I must be doing something wrong then.\n. I did notice one place where a batch method called out to fn instead of done when an error occurred. (I think breaking the usual chain)\n. One last thing, the abrupt process.exit(1); upon any \"fatal\" errors (such as not being able to locate a valid component.json) is now my main corruption source. (as it cuts off other in-process components once the process exits) I'm not sure of all the implications of that, any thoughts?\nAs far as download failures for other files go, my Package#destroy() method now works as expected. (I've used fs-extra for it's remove (rm -rf) method, unless you have another lib you'd prefer.)\n. I committed what I have with treetopllc/component@7ca70b5559b1a34662fd0dcdc7a81766403fd0c0 (the install-error-handling branch)\n. I could use rimraf instead? I only picked fs-extra since I saw you used it already in the builder.\n. This seems to have re-surfaced for me, I'm not really sure what changed to cause it though. Myself and my team have been getting 503 errors from Github pretty often, and it seems to cause component install to quit abruptly, even while other components are \"in-flight\". (causing the aforementioned \"corrupt\" state again)\n. Yeah, I could see that, warnings for all failed remotes. Then, a separate error could be emitted after those if all of them failed altogether.\n. +1\nI just ran into this problem and merging in this branch solves it for me.\n. As it stands right now, I cannot use private repos via Component. This is a blocker for me and my team, and I wish there was some sort of warning before this was changed by GitHub. :(\n. The solution, for anyone else who comes across this, is to switch to HTTP Basic Auth. (i.e. login = github username, password = github password)\n. The -c and --copy flags should perform as you are suggesting, I use that flag myself so I can verify that. If it's not working, could you have an out-of-date version of component? You may also need to remove the old build/ directory that includes the symlinks, otherwise it may not attempt to rebuild those assets.\n. I may be wrong, but I believe your only option so far is to fork the Backbone repo and modify the component.json to include jQuery as a dependency. Then, you'll need to fork all the repos of components that depend on backbone (like Marionette) to refer to your own fork of Backbone as a dependency.\nNot pretty? I know :(\n. +1\n. @jonathanong I like that idea (+1)\n. I agree as well, I really want a --js and --css option (and in the future, maybe there could also be --images, --templates, ... etc)\n. That would work for me!\n. I believe superagent can be configured to follow redirects. Unfortunately, component dropped the use of superagent in favor of the pure http module instead for the time-being. Once superagent is restored as the mechanism for handling HTTP, redirects shouldn't be a problem anymore.\n. I've been using superagent in my own branch atm (using node v0.10) and haven't had any issues. I needed to bring back superagent for my team so we could incorporate superagent-retry to address GitHub sending 503's and breaking the install. Once superagent has been brought back into the fold, I'll gladly PR my changes.\n. While I agree that a project rename should require action, I don't think we should force the install to break when a proper redirect has been given. It's how the web works, and we shouldn't shrug that off so easily.\nI think we should warn the user when a redirect has been detected, rather than failing altogether.\n. Superagent isn't being used for file downloads though, not afaik.\n. Maybe it's finally time to resolve the superagent problem once and for all.\n. +1 I've been wanting to do this for a while, but have also held back from investing time for the same reason. Is there anything I can do to help you out?\n. +1 for function () {} hehe\n. I get that it's only preference, there's not a right/wrong answer here.\nSince the rest of component seems to use function(){}, then it seems appropriate to remain consistent.\n. +1\n. -1\nI really don't want to replace the current build process. It's already pretty elegant imo, this should just be development sugar. (ie. subcommand like @jb55 has suggested)\n. Using path.relative is a great idea. One thing to consider is what if one of the configured paths happens to look outside process.cwd()? (perhaps that would be a special case?)\n. I wouldn't mind helping maintain this, and I agree it shouldn't be in core.\n. +1\n. Hmmm... I switched that URL manually to https://raw.githubusercontent.com/component/notification/master/component.json and I get the same timeout errors from cogent.\nCould something else be at work here?\n. The response event never seems to fire on the req object in my case. Just hangs around until the request is aborted by the timeout and then I get a \"socket hang up\" error.\nDoes the node version matter? (I'm on v0.10.26)\n. I'll try with another component when I am back at my desk.\n. Just tried with another component, same result. I noticed you've been making changes, so here's the latest debug output:\n``` bash\n  component-resolver:semver resolving semver component/notification@* +0ms\n  remotes:local resolving local remote +861ms\n  remotes:local checking folder: /home/vagrant/go/src/github.com/treetopllc/nobleweb/components/component/notification +2ms\n  remotes:github GET \"https://raw.githubusercontent.com/component/notification/master/component.json\" +0ms\n  cogent timeout exceeded for GET https://raw.githubusercontent.com/component/notification/master/component.json +0ms\n  cogent received error \"timeout of 5000ms exceeded.\" with \"https://raw.githubusercontent.com/component/notification/master/component.json\" +4ms\n   error : Error: timeout of 5000ms exceeded.\n\n```\nEven if I get another component to resolve first, I get the same result basically.\nIt looks like it's only trying a single location for the file, rather than trying raw.github.com next as I would have expected.\n. Ugh, still not working. I'm gonna run the unit tests for component/resolver.js and component/remotes.js to see if either of those has an obvious problem.\n. Oh wow, once I installed node v0.11, things start working much better. Could there be something going on with the code generated by regenerator?\n. Ok, I'll try from a different machine to see if I get a different result. If that doesn't help, I'll trim down the application build to see if there's a particular component causing trouble.\n. Ok, I was originally working on a Fedora 19 development box (for work) so I tried it out on my Ubuntu host machine, and it worked better. (my laptop runs Fedora 20, so I'll try that out next to see if I can narrow the problem)\nIn any case, there are still some issues with existing components, the dependency tree for my app is pretty large so I'm hitting a pretty diverse set of components and having trouble here and there. It looks like some errors are not being reported in some cases, I have to have debug enabled and even then I have to take some guesses due to all the parallelism at times.\nFor example, component/underscore did not have a component.json included with the latest tag, it was only available on master (I corrected that myself w/ a forced tag update, sorry in advance if that breaks things for anyone) I had to deduce that myself from the debug output, but it seems like that error just got swallowed up.\n. Yeah, I'm working on migrating those things now, but just wanted to allow the install/build to complete right away.\n. Regretfully, I haven't had the time to work on this over the weekend. The machine above was a box set up via vagrant, so tonight I finally got started on the process of creating a new box so I can test this stuff out again. I'll report back sometime tonight with my findings :)\n. Dang, brand new box and I still have the same problem. :(\nMaybe this is a Fedora thing, I'll try on my laptop and see if I still get this.\n. Ugh, tried this again on my laptop and I get the same result. I'm still not sure if it's a Fedora 19 issue... or a VirtualBox networking issue. I mean, the old component works just fine, it's component@^1.0.0 that is failing on me. :(\nI'm going to attempt running a live version of Fedora 19 next. Hopefully I can pin this problem down soon, I'd like to submit some sort of fix.\n. I'm still getting trouble, so I'm setting up a VM for you to test out @jonathanong \nI probably shouldn't give access to my work VM, so hopefully the problem still shows up on my custom installation.\n. If I switch to using node v0.11, (I did so via nvm) things just work. This leads me to suspect that regenerator may be doing something unusual, but it's been really difficult to debug the contents of ./build :(\n. @jonathanong I thought node v0.11 has generators? (so it would use ./lib instead of ./build)\n. I can finally put this error to rest. It turns out that NAT for my VirtualBox machine was the culprit. I kept getting the 5sec timeout because HTTP requests were taking 6-10sec to run because of slow DNS resolution (due to NAT/VirtualBox configuration)\nNow I can actually start debugging stuff related to component! YAY!\n. Well, the browser was always on my host machine. (the guest machine has no GUI) It wasn't until I tried a cURL command that I noticed it had a long delay too.\n. @rarkins is codeship.io a virtualbox machine?\n. Where I work, we use vagrant+virtualbox for development as well. Try adding this config to your Vagrantfile (it cleared this problem up completely for me)\nconfig.vm.provider \"virtualbox\" do |v|\n    v.customize [\"modifyvm\", :id, \"--natdnsproxy1\", \"on\"]\n    v.customize [\"modifyvm\", :id, \"--natdnshostresolver1\", \"on\"]\nend\nFor one reason or another, DNS resolution got really slow due to some bugs in virtualbox, hopefully this helps you out like it did for me and my coworkers.\n. Ok, yeah I've been having some transient issues with github in general over the last couple days.\nIf you use a custom builder script, you can set some configuration options to set the timeout and number of retries. (I also do that locally and it seems to help a lot) It's a little convoluted unfortunately, but it does work. If you're interested I could help you out setting it up.\n. Almost, it's a little more complicated. (but not much) Basically, you need to set up options.remote to be a custom instance of component/remotes.js (unfortunately, it doesn't currently allow changing config on the fly, so you need to use the lib directly)\nSo, first npm i --save-dev remotes, then in your builder:\n``` js\nvar remotes = require(\"remotes\");\nvar options = {\n    // ...\n    remote: remotes(remotes.defaults, {\n        out: path.join(root, \"components\"), // this line will vary for your script\n        retries: 5,\n        local: true\n    })\n};\n```\nThis is directly out of my build/builder.js, I've only changed retries, but you can also change timeout here as well. (I opted for more retries that fail quickly, seems to be the better trade-off)\n. Oh yeah... that's true. Yeah, I pass the same object to both the resolver and the builder.\n. I pass the same options object to both, (it's designed to be like that) so you should be able to do the same.\n. @timaschew It depends on how you're using VirtualBox. I've been using it via vagrant and I was able to configure it via the following in my Vagrantfile:\nruby\nconfig.vm.provider \"virtualbox\" do |v|\n    v.customize [\"modifyvm\", :id, \"--natdnsproxy1\", \"on\"]\n    v.customize [\"modifyvm\", :id, \"--natdnshostresolver1\", \"on\"]\nend\nAs far as what those specific options correspond to in the VirtualBox Settings GUI... I'm not sure. But I'm sure searching on natdnsproxy1 and natdnshostresolver1 will be a good place to start.\n. @timaschew \nLooks like the documentation shows that using the following CLI commands can accomplish the same thing: (not sure if it needs to be run just once, or on each startup)\nsh\n% VBoxManage modifyvm \"VM name\" --natdnsproxy1 on\n% VBoxManage modifyvm \"VM name\" --natdnshostresolver1 on\n. Yeah, I feel the same way since I've always wanted to use components to hold my own local components, (ones that don't belong in separate repos) but I have to come up with other weird names instead.\n. I don't think we need to change to something like that necessarilly, even just renaming to use component_dependencies or something less generic would be more than enough for me.\n. At our company, we have a shared \"machine\" github account that we use for things like CI. If you opt for doing the same thing, you can generate a token for that account and use it for your CI, as opposed to using a developers credentials.\nAs a consequence of using Github directly, instead of an external registry, there's no way around using their API for a great many features they offer. (like resolving tags/versions for a given component) As a result, each component client likely needs authentication with github to get past their rate-limiting.\n. Oic, yeah I haven't started using this for CI just yet. (still just working on converting everything)\nFwiw, you can use a token instead of username/password if you use .netrc. But yeah, the 5k limit now is standing out to me as a distinct possibility for us to hit too. :(\n. Yeah, the more I think about it a caching proxy would be a really elegant solution. (I'm sure Github and Bitbucket will appreciate it too)\nI guess the biggest problem is getting it hosted.\n. Just curious, but I thought the username/password for tokens is the reverse? For example, our netrc files look like:\nmachine api.github.com\n  login x-oauth-token\n  password {token}\n. Haha, yeah that looks to be the case. :P\n. I don't know if this would work, but if you can't do private repos maybe you could try adding a symlink within each \"app\" to your shared \"components\" dir.\n. You can use compilation steps in local components, the app I work on heavily uses LESS and Handlebars, so that's not a problem.\nHowever, anything that's meant to be consumed publicly should be only JS/CSS/HTML, which means if you're using CoffeeScript, TypeScript or whatever in your public components, you'll need to store those output JS/CSS files in your repos.\n. I wouldn't mind maintaining that, I've got some pretty cool ideas for a decent generator.\n. I've seen something like this happen when an exception is thrown in a module during it's initialization. (place a debugger at the top of your boot component to see if that is the case)\nI imagine that exceptions thrown like that should be caught, but if someone else has the same problem that I saw I would look into it a little deeper.\n. That's certainly possible, I haven't used windows in a long time, and certainly never for component dev. :S\n. Just to be clear, what version of component are you using? (component 0.19 and 1.0.0-rc5 are vastly different in how they handle versioning/installation)\n. Odd, I haven't had versioning issues w/ 1.0.0-rc5 like you are describing. Have you tried adding DEBUG=* to your component install command to see if it reveals more information?\n. If you create a custom builder instance, you can pass timeout as one of the options. (I'm working on a PR for component itself that will allow this override via the CLI)\nThere's also a retries option you can pass to help mitigate the effect those timeouts can have. (I've bumped retries up to 5 and have not even had to mess w/ timeout)\n. To be clear, the timeout is for how long it takes to get a response, not how long the entire request-response cycle takes. Taking 5+ seconds to get a response from the server is a sign you should probably bail and try again in the interest of time. That being said, I think the default retries should be boosted from just 1 to something a little more resilient (like 3 or even 5)\n. Looks like you need to install git on your windows machine. (my guess is one of those dependencies is distributing itself via github)\n. If that's the case, you probably don't have it in your $PATH. The point is npm is failing because it can't find the command.\nPerhaps this article will help.\n. What does your component.json look like? Sounds like you're missing something.\n. That's a really old post, you should reference the guide or wiki for up-to-date examples and guides.\n. -1\nI agree with @micky2be, but I would also point out that master is not always the root branch. I've encountered a handful that use something else. (gh-pages for one, as weird as that is)\nI don't want to add magic, but I also think this edge-case should be documented.\n. component@0 gets less reliable as your dependency tree grows. Since it only includes 1 folder for each dependency, when it comes to conflicting versions it will behave inconsistently. Sometimes, 1 version clearly wins, sometimes you get a corrupted file.\nThe point is, you should really consider upgrading to component@1, it fixes this particular issue and lots lots more, while retaining backwards-compatibility. (for the most part, I'm sure there will be edge-cases)\n. Oh bummer, that does complicate things. One option, albeit not a very pretty one, is to add a working components directory to your git repo, I had to resort to that when we were stuck with 0.19.x.\n. I've been using 10 with my team, which has seemed to work out nicely.\n. ",
    "paulmillr": "sure.\nI don\u2019t consider \u201ctodos\u201d as real-world web apps or even as great examples.\n. That was my first thought, then I dived into source. ~10 components including jquery etc. TJ said they develop great 300-component site.\n. ",
    "jcw": "Yes, but I'm not asking for a way to avoid the issue - more how to deal with it for user / organisation / project names which happen to already have a dash in them.\n. We worked around it by renaming the org from Nut-Bolt to nutbolt - just to stay out of trouble:\n\nIf the mountain won't come to Muhammad then Muhammad must go to the mountain.\n. \n",
    "jdalton": "@Nami-Doc Ah, yes that may be how it's resolving it as I also ship with an index.js. Thanks.\n. ",
    "ravenac95": "+1 except that I see this as being useful for defining private remotes without including any authentication to the private server in the git repo.\n. ",
    "sankargorthi": ":+1: \nwe use both a private repository and github for our components. As the location of the remote might keep changing while IT figures out where to put the repository, and if we decide to separate out development components from production components and use different IP addresses for each, a global remote config could help us eliminate having to refactor all components whenever these locations change.\n. Adding info in component-ls to show where each dependency was loaded from might provide the required data.\n. :+1: \n. To add to this, can't load component build files with sourceUrls in IE10. When IE encounters //@ sourceURL=... it throws an error: \nSCRIPT1004: Expected ';' \nbuild.js, line 1540 character 1\nThey're apparently [conditionally compiled statements](http://msdn.microsoft.com/en-us/library/ie/6s6fab9k(v=vs.94).aspx). :confused: \n. Is there a usecase for not doing this via the component.json file? Why would you not want to audit log your workflow?\n. :+1: \n. Would a judicious ordering of remotes not work for this use case? Especially if we get a global component.config as mentioned in #227 \n. > I like that you can look at component.json and know exactly where the projects came from, and where to find them on github\nIf component-ls gave us that info, would that not be sufficient?\n. :+1: Would it be simple to create a private component registry?\n. Great! This would eliminate the need for the global remote config in #227 \n. ~~Is this different from this https://github.com/component/builder.js/pull/128?~~ It looks like it is. You're fixing the component install part while the PR was for component build\n:+1: \n. As component install is a request to the component.json file hosted on the git repo (or something like that), you must be able to access the repo via git clone/push (which would mean providing your ssh keys) on that box. All team members would have to be added as members who can access your private repo.\nI think I'm right about this.\n. Grunt tasks with plugins wrapped around component install, build, watch etc work for us. If the goal is optimizing the build to not repeat unnecessary steps in a recommended manner, I'm sure it'll be an improvement.\n. Is it imperative that ~~we~~ you (@kof) maintain versions in all three (or more files)? Can't most build processes work off of the version maintained in the package.json?\n*edited to address the right person\n. :+1:\n. :+1: @anthonyshort \n. Update to component v0.19.9\n. How often does the search refresh from the wiki? Some components don't seem to be searchable (lodash for example).\n. @bmcmahen tests everything in production. :man: \n. This doesn't work anymore. fyi.\n. @KenanY thanks!\n. :+1:\n. Also, all our errors currently seem to be in our lodash/lodash: \"2.4.1\" dependency. Not sure if this is useful or relevant.\n. We're unfortunately limited to 0.19.9 as I was unable to figure out how to point component to a custom remote repo on our VPN (gitlab). Is there some documentation or examples on how to do this with component@1?\nWe're using component-bundle to drive our builds and we only do component-install once. We're manually managing our dependencies and they're all on the same version or on '*'. I'm pretty sure we don't have conflicts.\n. @netpoetica absolutely! anything to get us up to the latest version of component(1). I'll move this over to remotes then.\n. @timaschew Thanks! :trophy: \n. I ran into this too - I was running a --standalone build. Is that how you're using component too? @aprilb \nAlso, are you using a plugin for handlebars or pre-compiling them yourself?\n. @aprilb are you using a custom builder? How's the plugin parsing your templates? Also, which version of the plugin and component are you using?\n. Everything looks good to me so far. And you aren't using the standalone builder either - so no idea why your template's not loading.\n. https://code.google.com/p/chromium/issues/detail?id=451015\nRemoving new lines in the require implementation didn't seem to help either. Closing this as it's not component(1)'s problem.\n. ",
    "ajainarayanan": ":+1: Would be a better change if we want to use remotes across a number of components inside one big application.\n. ",
    "chemzqm": ":+1: our connection to github often blocked by the GFW, that would be much easier for us to migrate component to our local hosting server without having to add remotes in component.json.\n. Using uglify on every build would cost lots of time with large file, so I use https://github.com/substack/node-syntax-error to check syntax-error with only my client files in parallel when needed, code like this\n``` js\nvar program = require('commander');\nvar clc = require('cli-color');\nvar check = require('syntax-error');\nvar fs = require('fs');\nprogram\n  .version('0.0.1')\n  .parse(process.argv);\nvar files = program.args;\nfiles.forEach(function (file) {\n  fs.stat(file, function (e, stats) {\n    if (e) throw e;\n    if (!stats.isFile()) return;\n    fs.readFile(file, 'utf8', function (error ,src) {\n      if (error) throw error;\n      var err = check(src, file);\n      if (err) {\n        console.error(clc.red('ERROR DETECTED!'));\n        console.error(err);\n        console.error(Array(76).join('-'));\n      }\n    })\n  })\n})\n```\nWhen error happens, I could just run:\nsyntax-check client/**/*.js\n. component v1 support tags with v prefixes, you may need to upgrade.\n. I've got the same problem several times. I found the script fetched by component install was injected with other characters like }; during the network transfer.\nI thought it might be a network problem in China, so I backup the components folder every time before I run make clean. \n. That would make our project more reliable if we always use version control.\n. :+1: I can forget to use -u component-json which not always resolved correctly.\n. One of biggest problem for my teammates is how to make a good choice between so much components. It would be quite helpful if the registry could provide more info like depended upon downloads building state test coverage last active date demo\n. https://github.com/component/component/wiki/Plugins you can use the plugins, but plugin of typescript seems not there.\n. Just add javascript  to the scripts array as component would only grab javascript files, but users could find the source code by visit your github repository.\n. I had some misunderstanding. Currently component would not grab your typescript files, unless you do some hack yourself.\n. There is a -c, --copy   copy files instead of linking options for component build.\nI'm always using that option to prevent the symlink and I can't see any reason to use the link.\n. Everyone have the privilege of editing the component wiki page: https://github.com/component/component/wiki/Components, \nfeel free to add it.\n. Yeah\uff0cespecially when you have bad network on github.\n. I used rm components before, but I found some problem with that, the one is sometimes the network would really slow and reinstall all components would take lots of time, the other is when developing most of time I do want to update one particular component but upgrade all component might cause other problems.\nI would like to suppose command like component update user/repo to update specific component .\n. Tell the user that component 1.x is making use of --harmony flag of node and suggest the user to use n or nvm sounds better. As they can recover quickly from the fail.\n. The biggest use case of this command for me is to check how many the bytes would be bring in with one component.  Imagine one component takes of 1k of itself but brings in 5k other components,  the other one component takes of 2k of itself but no other components, then the other one looks better on the size aspect. But if the 5k taken by other components was reused by other components within the app, the first one component looks better.\nIf the component-size(or something else) command could show the total minified size of build.js file and minified js size of each component would be good enough for me.  And I prefer uglifyjs as it's probably most widely used and easy enough to use and install.\n. For the repo with many files like https://github.com/chaijs/chai, why can't they build a single file and add that file to component.json? Doesn't seems too much work, comparing the downloading process is quite terrible for so many single files, and I have no idea when the SPDY would be available for github CDN.\n. @jb55 tks for the tip.\nNever used component-open, just use Chrome seems faster for me.\n. Since github response could be broken frequently for me, I've made an API to checkout all the component stuff from github to my local machine and a local file resolver to copy the files instead of making remote call.  It only takes milliseconds to rebuild :).\nOne thing I advice is to stick to semver version as much as possible, instead of using * to indicate any version should works in the app's component.json, component pin and component update are quite useful for that, that would save us some time for some extra remote call.\n. I've added config github access section to the guide https://github.com/component/guide/blob/master/component/getting-started.md\n. How to let the users know that they should add livereload script in the html file to make livereload works?\n. Personally, I don't think auto require is a good idea.  With the build file not contains auto require, I can build test pages for each of my components with the same files, it's not possible with auto require.\n. I have a project works like a dashboard, it contains different type of charts like geomap linechart barchart datatable, they should looks concise, so I build all of them with different options on the same page to make the test easier(instead of configure them in the app, not easy as there could be some config limitation), the test page would like this:\n``` html\n  \nwidgets test\n\n\n\n\n\n\n      var geomap = require('geomap');\n      var linechart = require('linechart');\n      var barchart = require('barchart');\n      //build them all\n    \n\n```\nIf require('boot') is in build.js, I can't prevent the app from building.\nThe test pages could also make the learning of how each local component works very easy (since the API could be rapidly changing, I don't have too much comment with the API).\n. +1 I suppose when using --watch and the file have syntax error, show the error instead of break down the process.\n. @karlbohlmark works great thanks.\n. ",
    "jeremyworboys": "I just opened pull request #235 to fix this.\n. I had wanted something like this for supporting BitBucket, but went down the route of setting a simple proxy that translates the GitHub style URL to BitBucket style.\n. ",
    "vicapow": "okay. to do this I have to edit the component-builder package but I can't seem to find it on github. where can I find the repo?\n. ah! nm. here it is. https://github.com/component/builder.js\n. submitted a pull request to component/builder.js\nhttps://github.com/component/builder.js/pull/65\n. ",
    "jb55": "Thought about it and I can simply use find to track dependencies since they're the only ones pulled anyways\n. I've had --js and --css implemented on my branch for about a year now: #243. It's a bit outdated though. I would love to see this included so I wouldn't have to use mine. Really handy for build systems that don't have multiple output targets per build rule (redo, most others).\n. The point of those flags is to select a specific target to build,\n--no-{css,js} is in a negative form and only makes that process more\nconfusing.\nOn Mar 12, 2014 8:05 AM, \"Jan B\u00f6lsche\" notifications@github.com wrote:\n\nSince css and js files are generated by default, --no-css and\n--no-javascript options probably would be more intuitive.\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/pull/445#issuecomment-37418901\n.\n. In my case --no-css wouldn't be useful because the PR is about specifying which targets you want to build so that you don't have to rebuild things.\n\nfor instance, my ideal build pseudo-code:\n``` make\ntarget.js: source.coffee\n  coffee -bc $^ > $@\ncomponent.js: target.js\n  component build --js $^ > $@\ncomponent.css: target.css\n  component build --css $^ > $@\n```\nno-css doesn't guarantee that it would build just js, it's not future-proof.\n. :+1: \n. quick fix before this gets patched:\ncomponent install -r https://raw.githubusercontent.com\n. I think this would be great as a subcommand like component-watch.\nEliminating the other commands would cripple the build system I currently\nhave in place for some of our large component applications.\nIs backwards compatibility a goal for these new projects?\nOn Jan 22, 2014 2:14 AM, \"Jonathan Ong\" notifications@github.com wrote:\n\nso many of you may notice (from my spamming your github news feed) i've\nbeen working on component libs. i just got the watcherhttps://github.com/component/watcher.jsto the point i can run and watch my app in elegance.\ni wonder if you guys would be interested in making component(1) v1\ninteractive like this watcher. this would currently eliminate:\n- component install\n- component build\n- component update\n- component outdated\n- component pin/set\n- component ls - not implemented yet but shouldn't be hard considering\n  we already have the resolved dependency tree\nother commands should obviously run in a separate process like component\ntest or component search.\nthe main concern for me is speed. i wrote the resolver and builder as\nchannels/streams because i thought that was the bottleneck was (don't\nregret it though - better architecture than all those nested batch\noperations). turns out, most of the bottleneck is just starting up the\nprocess. whereas a component build operation would take ~1300ms, it would\ntake the watcher only ~50ms for scripts and ~300ms for styles (mostly\nrework/autoprefixer).\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/464\n.\n. One thing you can do in the meantime is commit your components dependencies\neach time you update,  and use git bisect or a simple diff to pin down\ncommits that cause issues.\nOn Jan 23, 2014 3:21 AM, \"Chris McVittie\" notifications@github.com wrote:\ncomponent history\nThis would return the most recent commit log of all components. Useful\nbecause I have a mysterious error in my javascript, which turned out to be\nrelated to a component update last time I had it - and having just updated\nall my components, it has re-appeared. Access to the most recently updated\ncomponents would be handy in diagnosing where to start looking.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/467\n.\n. Ahh I was running the tests on my Ubuntu machine...\nOn Mar 10, 2014 11:23 PM, \"Jonathan Ong\" notifications@github.com wrote:\nhmmmm i tested it locally recently and no tests fail. might just be\ncasing, which is platform dependent.\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/484#issuecomment-37266714\n.\n. It's useful in the sense it gives you a rough idea of relative sizes of packages that your using, if you're ocd about sizes of things. If I want to see the size of the compiled package I can just type <build/build.js gzip -c | wc -c on our dev and release builds.\n\nA shortcut for doing this would be handy, but I imagine would have to make an opinionated choice wrt. minimization. For example we use closure compiler to get much better minimization than what uglify seems to produce.\nJust some thoughts...\n. Yeah it's a pain, I made it slightly easier in the sense you can type npm install --save-dev closure-compiler-jar and it'll be in your npm bin path: https://github.com/jb55/node-closure-compiler-jar, still requires java to be installed though.\nI think the canonical uglify minifier would make sense for this command though, I would still find it useful as a rough estimate of minimized and gzipped sizes.\n. Could this not just be added as a feature to the existing component-size?\n. So yeah it could just have a summary section and then individual component breakdown\n. Not sure I understand this, it seems to add more to the core by undoing all the work @jonathanong has done by splitting everything out into separate modules.\nThe component object with events seems like a good idea though. The code looks clean though so can't complain about that. I've also not looked enough into @jonathanong's modules to judge their complexity either.\n. I agree with @ianstormtaylor about globbing, best reason to exclude globbing is to deincentivize large components. I can't say I've ever needed to glob anything, even at the app level. Considering most of the time its just easier to build apps out of local and remote components, and those usually just export one or two files.\n. @MatthewMueller not sure I agree, we used to do it that way and making everything into self contained components simplified everything: explicitly tracking component dependencies is a major one. A lot of the labor is removed once you have an automated way of creating local components.\nbut then again that's just our way of doing things, and who am I to tell everyone how to structure their project. So I have no problem conceding this point.\n. hmm is the http pool issue the same one that substack's hyperquest addresses? not sure what he's doing to get around it but might be something to look into\n. I personally never use it, this chrome omnibox shortcut works just fine:\n\n. We almost always pass data into our app constructor in all of our app components. Relying on a global variable for configuration seems pretty strange.\nOn Fri, May 30, 2014 at 6:04 AM, Stephen Mathieson\nnotifications@github.com wrote:\n\n+1 for some way of turning auto require off\nReply to this email directly or view it on GitHub:\nhttps://github.com/component/component/pull/554#issuecomment-44648013\n. \n",
    "geddski": "@timoxley that may work. \n@superjoe30 unfortunately for legacy scripts there's no getting around relying on globals. jQuery plugins rely on window.jQuery. Angular directives rely on window.angular, backbone relies on window._. Component elegantly solves this problem going forward, but we're talking about legacy scripts. Can't expect legacy compatibility to contain the new ideals.\n. @visionmedia you'd prefer that every 3rd party lib require forking for compatibility? Makes no sense.\n. @visionmedia I agree jQuery is a crutch, and I like where Component is going. But I'm talking about the common use case of a project that wants to leverage both Component and really good regular scripts like async.js. Total world domination of Component is a fine goal, but not accounting for a transitional period is a bit purist and myopic. \n. ",
    "camshaft": "I'd like to refactor this to use visionmedia/superagent#176 to make it a lot cleaner:\n``` js\n/*\n * Module dependencies\n /\nvar url = require(\"url\");\nmodule.exports = function() {\n  // load and parse netrc into machines\n  ...\n  var machines;\n  return function netrc(req, next) {\n    var machine = machines[url.parse(req.url).hostname];\n    if(machine) {\n      req.auth(machine.username, machine.password);\n    }\n    next();\n  }\n}\n```\n. From reading the source, the only way I saw to use basic auth is adding a remote with the credentials in it. IMO it's pretty ugly putting creds in a versioned file\n. Yeah I was wanting to make it an npm package, I just never got a reply if this is something people wanted. I can do that and add to the PR.\n. The reason I went with netrc is because it works with curl, ftp and git out of the box. I use https on all of my git clones which makes it nice. Since npm just uses git underneath for cloning repos that functionality was supported. I love the efficiency and speed of component though and wanted to make it as seamless as possible for others that are using the same setup. I'm open to other ideas :)\n. Perfect. Ill add those examples as well then. Thanks for the help!\n. @visionmedia I've added the examples to the readme and moved the netrc module out. How does it look now?\n. Looks good to me\n. Yeah our builds broke as well. We contacted the github support when we found out what the issue was and they said authentication (except username/password) will not be supported on raw. @visionmedia what are the chances of switching over to the content api instead of using raw? I would be willing to do a pull request; just want to make sure there is interest before doing it.\n. ",
    "jamischarles": "+1 @visionmedia Any thoughts on this? We have a component that's a private repo. I'd love to not have to maintain our own fork of component. \n. Looks good to me... TJ? @visionmedia \n. ",
    "markreg": "Any other solution come up for this problem? --dev has a major issue with this. Makes debugging virtually impossible although I really like the sourceURLs.\n. What happened to the duo github repo?\n. ",
    "adius": "Then you shouldn't post the link ;-)\n. @visionmedia Offline again! Still the same error message\u2026 Are you ever going to fix it? =D\n. ",
    "djanowski": "Sorry for the duplication, I did search for open issues :)\n. @visionmedia That's exactly my reason for going with the Unlicense/Public domain, because I don't care about all the legal stuff. Bottom line is: you refuse to claim a copyright, anyone can do whatever they want.\n. So?\n\n. > The Unlicense is a template for disclaiming copyright interest in software you've written; in other words, it is a template for dedicating your software to the public domain. It combines a copyright waiver patterned after the very  successful public domain SQLite project with the no-warranty statement from the widely-used MIT/X11 license.\nMore: http://unlicense.org\nMy rationale is: most people simply don't care (like myself), so providing a more liberal default makes sense. For those who argue that people care, then they are free to change the default.\n. @visionmedia Just to keep the discussion on this thread: you closed #290 because you say that MIT is something you heard about. So is that the only reason to include it by default in the template?\nAgain, I am no expert in licensing and I just don't care what people do with my open-sourced code. Since probably most of us in this community feel the same way, why even acknowledge copyright? Do you want to impose on users of your libraries that they read the license, and possibly try to figure out whether they should copy the copyright notice over to their application (as that's what MIT says)? Even if you argue that's not what the license says, this is all wasting energy of our lives, for those of us who simply don't care. (It's just the default, and those who do care will change it, quite possibly to a copyleft license.)\nSQLite is public domain and I've never heard of anybody not adopting it because of that. I think they set a great example. It'd be amazing if we could add this default (it's just a default) to the list of things that make Component great and magical.\n. ",
    "JoeStanton": ":+1: This is a very common scenario for us! Would be perfect if component would take notice of the http_proxy env variable which other tools such as npm adhere to. Had a look myself but looks like a fairly large change to implement HTTP proxy support within superagent.\n. ",
    "blakehaswell": ":+1: It would be awesome if this could happen.\n. ",
    "manuelstofer": "I agree. Just wanted to report, in case you still care about 0.6.\n. ",
    "artob": "While this was already resolved, I figured I'd answer the question raised here, for the benefit anyone else stumbling across this conversation in the future:\nThe essential difference between the MIT license and the Unlicense is that with the former you still claim copyright and require an attribution notice from your users, while with the latter you disclaim copyright altogether and let your users use your code with absolutely no strings attached whatsoever. See Licensed, License-Free, and Unlicensed Code.\nAlso, regarding the point about GPL compatibility, the Free Software Foundation have officially recognized the Unlicense as GPL-compatible: http://www.gnu.org/licenses/license-list.html#Unlicense\nPS. See https://github.com/unlicense/unlicense.org in case you want your public domain project added to the list at Unlicense.org.\n. ",
    "ckizer": "Extreme frustration, I've dealt with npm before, and trying to get stylus working and everyone was jerks about some basic simple questions. Everyone on these project always assume some sort of custom install or that we've always had node runing.\nThis is what happened to me so far today:\n* To install NPM on mac, get the node binary\n* Node.js binary doesn't work with OS X 10.8.3 (new mac)\n* Build from source (3 hours later)\n* Simply type npm install -g component\nWoops this error:\nserver:Documents ckizer$ npm install -g component\n/usr/lib/node_modules/npm/lib/utils/config-defs.js:5\n  , stdio = process.binding(\"stdio\")\n                    ^\nError: No such module\n    at Object. (/usr/lib/node_modules/npm/lib/utils/config-defs.js:5:21)\n    at Module._compile (module.js:449:26)\n    at Object.Module._extensions..js (module.js:467:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Module.require (module.js:362:17)\n    at require (module.js:378:17)\n    at Object. (/usr/lib/node_modules/npm/lib/utils/ini.js:43:18)\n    at Module._compile (module.js:449:26)\n    at Object.Module._extensions..js (module.js:467:10)\nserver:Documents ckizer$ \nWhy?\nI'm just trying to include a simple component that shouldn't even need to be compiled\u2026 we've now abstracted, and abstract of and abstract\u2026 you're convincing people to use this component and all over github projects are switching to it, a beta software that doesn't work on brand new computers. It really only works on people who've been using node for ages and have all the little dependencies installed.\nThe same thing happened when TJ did stylus\u2026 he made it sounds so simple but forgot to include basic instructions to get it working the same way as he had it working where import nib never worked. I challege you when building new ideas do them on a FRESH install machine and make sure that others can use them as easily as you can.\n. @visionmedia I'm not asking you to dumb it down. I'm asking you to make sure it works with a default install. Even with npm it doesn't install correctly as described. My issues relate to npm not properly clearing out some directory or  other. Your blog post (I googled) didn't clarify how to install and the packages I downloaded don't tell anyone how to install. I'd like to see something along the lines of \"This uses npm module component\" required in every package that is based off component. It was just sheer luck of google that and an hour of reading that alowed me to figure out how to install a select/drop down component packaged with \"component\"\n. ",
    "tomaskuba": "Hello, I am quite newbie to Component but I have been fighting hard with this issue. I have try to implement Stylus support to component in all suggested ways (files array, custom \"stylus\" array) while I have tried to keep HTML/JS/CSS/Assets end-points to comply with specification.\nWe are maintaining internal UI framework very similar to Foundation or Bootstrap (CSS+JS). We have already get to the point that it needs to be separated to small components and it brinks us to Component. Of course we are using CSS preprocessor (SASS in this moment, Stylus in future) because we can:\n- be DRY (functions/mixins)\n- implement inheritance (e.g. several types of navigation may have common base)\n- set common variables to all components (typography, colors, grid etc.)\n- use only necessary components (pick what you need)\nUsing compilers add \"deeper level\" to components. If HTML/JS/CSS/Assets are tip of the iceberg \u2013  Stylus, SASS, CoffeScript etc. are hidden bellow the sea level. We are all using some kind of compiler to empower our self. On the other hand I agree, that simplicity makes components far more reusable. \nI do sugest to keep HTML/JS/CSS/Assets as a standard \"view\" of components, while authors will be able to pass compiler files via dependency/package manager. \"Normal\" user will be building components as it is today and he/she will have no issues with unnecessary files (this is issue of \"files\" array implementation). Those, who would like to use power of compilers, will be able to make custom builder plugin and use deeper level of components. Even transferring of sources may be disabled by default. I have no troubles to write component install --with-sources.\nI do assume that all what we need is some kind of \"bellow the see level\" end-point for compilers in specification. Maybe \"sources\" array will be suitable for this task. I don't think that more than one array is necessary \u2013 every Component plugin I saw was filtering array of files by extension.\nSpecification about \"sources\" may be:\n.sources\nThe sources field specifies the source files used to build the component. This field is aimed to be used for compilers' files such as Stylus/SASS or CoffeeScript/LiveScript. Files in this field will be installed with components (only when component install --with-sources flag is used) and will not be processed by standard builder. Processing of sources should be done by custom builder plugin.\nPS: Sorry for such a long post and thank you for your time.\n. @yields thank for the idea \u2013 yes you can do this with Stylus but it does not allow you to share Stylus files across components. There is no end-point array where you can put .styl files and comply with specification. I can see several benefits of such \"cross source sharing\" approach as I mentioned above. \nI do assume that you have recommended me Makefile approach inside one component. I think that better way of Stylus-to-CSS compiling is though hook of plugin to Component build event: component build -u component-stylus-plugin which I am using in this moment.\n. @micky2be thanks for explaining. I do understand the point. \nPlease, is there any way how to enforce copying of images to build folder instead of creating symlinks? I thought that component build -c should be the right way but with no success (it may be that PEBKAC).\n. I have found the reason \u2013 copy flag is not working when you include images as folder:\njson\n...\n\"images\" : [\n    \"images/.\"\n],\n...\nThan you will get error : EISDIR, read\nEach file has to be named separately:\njson\n...\n\"images\" : [\n    \"images/first.jpg\",\n    \"images/second.jpg\",\n    \"images/third.jpg\"\n],\n...\nTested on Component v0.17.2 & OS X 10.8.4\n. ",
    "bergie": "https://github.com/CamShaft/component-json is also somewhat related.\n. It seems installation fails quite often with GitHub right now. I'm seeing tons of errors like:\ncomplete : component/underscore   complete : component/indexof\n complete : component/emitter\n    error : failed to fetch https://raw.github.com/bergie/noflo/master/src/components/Split.coffee, got 503 \"Service Unavailable\"\n. @visionmedia given that releases are generated from tags, isn't this the way Component already works? The main point was allowing the use of a custom downloadable when project needs one\n. ",
    "kaerus": "Simplified initialization by appending a require statement to the build. It is hooked in as a builder middleware using component build -u init. It would be nice to have it there by default though (feature request).\nIn component.json you only need to add \"init\": true which then autoloads the module.\n```\nfunction init(builder) {\n    var script;\nbuilder.hook(\"before scripts\",function(component){\n    if(component.conf.init) {\n        builder.append(\"require('\"+component.conf.name+\"');\\n\");\n    }\n});\n\n}\nmodule.exports = init;\n```\n. wrong repo in my components.json dammit :/\n. ",
    "mattcg": "Yes, the URL in the wiki is correct.\n. Excellent, thank you.\n. ",
    "donaldpipowitch": "So how would I solve my CMS scenario?\nLet us imagine WordPress-like Node CMS exist and I'm using an old version of this CMS. How could I list my plugins/components for a specific search term in my backend and filter out all components which aren't compatible to my version?\nIs this possible with components?\n(Btw, sorry for the confusion with Bower. This was a copy & paste error because I asked the same question in the Bower repo... I updated my first post.)\n. ",
    "MoOx": ":thumbsup: \n. ",
    "jofan": "I'm in the same situation and would also love to see this implemented.\nOn Mar 17, 2013, at 11:56 PM, Anthony Short notifications@github.com wrote:\n\nI don't normally use these sites either, but I'm stuck with it at work and I'm determined to get Component working -_-\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes! This is definitely my biggest pain with Component at the moment. I'm using the component-string plugin to do this but that makes it so much harder to use Component to build solutions to be adopted by 3rd-party developers.\n\nAlso, as you say, \"templates\" property make a lot of sense when you have \"scripts\" and \"styles\", and makes it feel like a complete solution for client-side components.\nSo big :+1: from me\n. Yes. For example:\n<img src=\"img/cat.jpg\"> inside my template.\n. Ok, thanks. I'll look into writing a plugin in the meantime.\n. Thank you. The last comment does work but what about when you have a JavaScript main file and want to use the template outside my-component? Is it possible to get that to work as well?\n. @remoe I understand what you are saying but in the case I'm thinking of, a client-side router that is central to the application would require the templates. These are not public components but local ones.\n@jonathanong That is what I expected but I can't get it to work, at least not with local components.\n. nlz.io sounds very promising. Big thumbs up from me. All those json and rc files are really becoming a nuisance. \n. ",
    "chrisbuttery": ":+1: \n. I could use this. :+1: \n. @anthonyshort share the wealth dude!\n. ",
    "jmhnilbog": "This would be a great addition. I'm working with an instance of GitHub Enterprise, which doesn't support a raw.github.com interface. (Raw files are only supported via http(s)://[hostname]/[username|org]/[repo-name]/raw/[branch-name|commit-id]/[filename] URLs.) \n. Actually, it looks like my problem might have a much simpler fix than the original ticket. On regular github, http(s)://[hostname]/[username|org]/[repo-name]/raw/[branch-name|commit-id]/[filename] URLs are forwarded to the equivalent raw.github.com URL automatically -- it looks like changing component-install's default behavior to use those URLs instead of raw.github.com's would make it 'just work' with github AND github enterprise.\n. ",
    "cristiandouce": ":+1:\n. I have the same issue!\n. Well, not the dependencies but at least their paths.\nWhen listing item-view dependency path ../../lib within list-views paths, the lookup works perfect.\nBut I don't believe that this list-view component should ever have to be aware of its dependency dependencies paths. With just its direct dependencies paths should be enough.\n. I took my time to install @micky2be version and tried with an example working ok!\n:+1: \n. :+1:\n. @jonathanong visionmedia/debug has a debug.enable method which allows you to set whatever you would like to see on the output.\nWouldn't it save future issues to just add a --verbose option to component(1) and do debug.enable(\"component*\") ?\nSince it could be listed at the --help list, people will just see it out of the component(1) tool and not have to check specs/troubleshooting neither any other documentation page... nor open new issues about it.\nthoughts?\n. I personally don't like the environmental variables alternative.\nAnd I don't see why I wouldn't be allowed to have a global configuration setup ~/.componentrc and a per-project one at the same level of component.json.\nAlso, along with the custom remotes, we could avoid using the .netrc for github authentication and place it all there. IMHO\n. On the other hand... I see the advantage to sometimes have the chance to override \"some\" configs via ENV vars... in PaaS like heroku for example.\nhmmm... tricky choice.\n. About the globbing. I'm not against it. I kinda feel tempted.\nBut it could be avoided by providing some sort of component-add or component-remove commands, or anything to help construct the component.json file in cases where there is an assets directory full of images and fonts and all kinds of required stuff for major apps.\nIt could make developers life easy and keep out the complexity of the component core.\nMy two cents.\n. Why not? \u00af(\u30c4)/\u00af\nAlthough... I've always questioned npm for not having such command.\nWhen I run npm show component repository the next thing I do is copy/paste in the browser...\nSo, why not have that done for me? I don't even care what the actual url of the repo is, I just want to open it in the browser to see online documentation/releases/history :dancer: \nIf there was a fancy way to display that on the term... I'd certainly opt for that. But in the meantime I think the best is to watch it on github.\n. @visionmedia Well... then I take it back! You made me feel lazy :whale: haha\nWhen I said that, I was actually thinking on the natural behaviour I usually have of component search something... component open blah/found. But yeah, I could type the whole url instead.\n@KenanY I did not know that. Thanks for making my day!\n. :rabbit: \n. With 1.0.0-rc5 shouldn't local be renamed to locals?\nhttps://github.com/component/guide/blob/master/changelogs/1.0.0.md#componentjson\n. component_components :trollface: \n. I think thats the actual output from component.io site\nhttp://component.io/learnboost/jsonp/readme\nSee the error: at Response.toError (/root/component.io/node_modules/superagent....\n. I believe for that you have this: https://github.com/component/resolver.js\nWhich is a component(1)'s core component.\n. I think it's something else\nbash\nnpm ERR! git clone git://github.com/timaschew/cogent Cloning into bare repository 'C:\\Users\\kauker\\AppData\\Roaming\\npm-cache_git-re\nmotes\\git-github-com-timaschew-cogent-5e7bf87a'...\nnpm ERR! git clone git://github.com/timaschew/cogent fatal: unable to connect to github.com:\nnotice the unable to connect to github.com message when trying to install cogent\n. I think you should check that you are actually able to clone the repository by yourself\nCan you run git clone git://github.com/timaschew/cogent and check it doesn't fail?\nIf it does, you should probably update git or your git credentials.\n. @niknah you should try this: https://github.com/componentjs/guide/blob/master/component/getting-started.md#setup-authentication\n. Just for reference and maybe as an interest implementation, I use hub fork from github:\nhttps://github.com/github/hub#git-fork\nIt might be of interest to check how they do it.\n. ",
    "tauren": ":+1: \n. It looks like Cisco Anyconnect on my Mac may be causing part of the problem.  We've seen AnyConnect cause other networking problems that are resolved when it is delete completely from the system. The same problems go away simply by disabling websecurity in AnyConnect. So I did this on my Mac:\n/opt/cisco/anyconnect/bin/acwebsecagent -disablesvc -websecurity\nNow when running within the corporate network with HTTP_PROXY set properly:\ncomponent install learnboost/jsonp\n  install : learnboost/jsonp@master\n    error : read ECONNRESET\nBefore it had a \"socket hung up\" error.\nAnd when running through my hotspot, it works properly:\ncomponent install learnboost/jsonp\n   install : learnboost/jsonp@master\n  complete : learnboost/jsonp\nBut even with the problematic AnyConnect websecurity setting turned off, component still won't install behind the proxy. Doing curl requests from the command line work properly. What does component do differently under-the-covers than a curl command?\nNote that long ago I had to add the following to my .npmrc in order to get NPM to work:\nstrict-ssl = false\nregistry = http://registry.npmjs.org/\nNote the lack of httpS (SSL) on the registry URL. Could the fact that component is accessing httpS://raw.github.com/ be the culprit?\nAgain, httpS requests work fine from curl commands. \n. Thanks! Not sure why I didn't search before posting this time... #394. So much for assuming support was already there.\n. ",
    "gunta": "+1\nThis is a must for GitHub Enterprise.\n. ",
    "hkjels": "I think what you want, is to use local.\njavascript\n\"local\": [\"lodash\"]\nAnd just make your version of lodash available in one of your components paths.\n. ",
    "iyedb": "that's fair but what about \ncomponent-ls\nerror : missing component.json\nI just installed it correctly with npm install -g component but component ls component build fail with this message\nerror : missing component.json\n. @yields thanks but not even\nseems like I have to watch that screen cast after all\n. ok thanks\n. ",
    "iaman": "component.component is clearly the way of the future\n. ",
    "ostera": "can we at least get an npm-like init? That'd be great instead of crafting a {\"dependencies\":{}} in order to start installing components and be able to build right away.\n. I meant for consuming components instead of creating one.\nOn Sep 26, 2013, at 4:10 PM, Tim Oxley notifications@github.com wrote:\n\n@leostera component create?\n\u2014\nReply to this email directly or view it on GitHub.\n. I'd say it goes with scripts as the transition would be seamless that way\n\nOtherwise, data seems too generic, that could be anything really. This\ncould be great for making translation components for example, and then\nyeah, a data section in the component.json would make sense but it could\nbe resolved as well within the scripts section. On most other cases a\nconfig.json file included with the scripts would be more than enough I\nguess.\nEither way, +1 if we resolve the naming/section thing\n. :+1: \n. I've been using alias cio='component'. On my end I have available also c, co, com and comp. As long it doesn't step over any of this I guess we should be alright.\nI like the idea around brew doctor-ish pre-publishing suggestions. \nI'm not sure about the transpilation to commonjs being prioritary right now. I think for now it's a nice have rather than a must have. When the time comes to merge in a 300+ pull requests for the current components you guys can count on me to help out there.\n. on auto-migration of all components to registry\nWhat about a GitHub app that would setup a repo for you with the hooks to update the registry? That would basically make publishing and maintaining hassle free.\n. how would it check for updates/publishes?\nautopublishing could be achieved with webhooks + checking for tags:\n- user pushes new tag-release\n- github triggers the hook\n- c8-registry gets the request\n- c8-registry checks for new tags on the repo\n- c8-registry publishes new tag if any\n- user doesn't have to manually publish anymore\nI'd take the component publish out and make autopublishes based on semver-compliant (or similar) tags to the repo...if we're going to stick with github repos then this should be valid even for private registries.\n. github login + git webhook to publish?\nsetup would be a one time thing\n. a endpoint would suffice for that matter, if you can make a tweet you can\nhit it, even with your browser\n. ",
    "alessioalex": "@visionmedia from what I see, component is installing everything in components/, so if one module has component/emitter@1.0.1 as a dependency and another one has component/emitter@2.0.x there's no way for this to work at the moment. Is this correct?\nIf so are you planning to do an NPM-like approach for the future? (every component with its own separate components folder etc)\nThanks\n. ",
    "popomore": "This milestone is 0.16.0, and 0.18.0 has been published?\n. I do a mistake.\nI don't understand why make a reference to this issue, and just make a reference to https://github.com/component/spec/issues/5\n. ",
    "webpro": "@timoxley, @anthonyshort, I'm explaining my issue/case in the issue I linked to.\n. ",
    "pirxpilot": "I think component-shrinkwrap --save  more or less does something like that for components that are installed - check out component-shrinkwrap\nBut some kind of npm outdated analogue would be nice.\n. Nice. I added it to the commands page.\n. Yup. More on this here\nThe fix in component/require/pull/28 \nI am pretty sure component is supposed to support circular reference: component/color after all is written by @visionmedia\n. Not attached to the word 'boot' here. I started using it since it was in one of @visionmedia early example (or so I vaguely remember). I think bundle is sort of taken by (component-bundle)[https://github.com/yields/component-bundle]\nI ended up writing component-autoboot since our apps almost always have:\n<script src=\"/build/build.min.js\" />\n<script>require('boot');</script>\nThe problem is not so much that you have an extra line (although why?!), but that you can't defer the script loading (well, you can try but browsers ignore 'defer' on script elements without 'src' so you end up with javascript complaining it does not know what 'require' is).\nI usually ended up fixing that in Makefiles, but I needed a build plugin when it's not an option.\nWould be nice if it was just an option for component build (just like --standalone is).\nHappy to prepare a PR if folks are OK with it.\n. @domachine  I think with --standalone your 'app' component is automatically required, which is not what you want, since it's just an empty shell.\nThen again: may be I am missing something: show me how to use --standalone to remove require('boot') from index.html in todo example\n. Not very important, but how about overloading --standalone  - when no name is passed it would just require('xyz') without exporting it in any way?\n. Looks like github started redirecting(301)  https://raw.github.com to https://raw.githubusercontent.com\nPretty hard to install anything at the moment...\n. Or add:\n\"remotes\": [\n  \"https://raw.githubusercontent.com\"\n]\nto component.json\n. The only official thing that seems related is this:\nhttp://developer.github.com/changes/2014-02-21-gist-raw-file-url-change/\n. Thanks @ianstormtaylor - I was using sed - but that looks much better.\nNow, if only we could solve 'v1.2.3' vs. '1.2.3' in tags so easily - es-shims/es5-shim#204 ;-)\n. see #422\nyou can use component-autoboot for now\n. Source is here: https://github.com/component/require\n. cool - will do\n. I am not sure why one needs component install after component shrinkwrap install. Could you explain? I would think you'd use one or the other (depending on if you want to resolve and update your deps or just restore last shrinkwrapped state).\nAlso: why a separate component shrinkwrap outdated, component outdated should do that job. \nWorth noting that shrinkwrap is for applications that use the component and not for the components. Components should always be as lax as possible with dependency declarations. Applications on the other hand need a specific subset.\nAlso one thing to clarify (I know many people get it, but I often see folks getting confused about it): Even if all components that application is using have proper semver declared dependencies there might be (and there usually is) a finite set of component versions that satisfy all dependencies. And with time that good subset changes (as new versions are released). Shrinkwrap gives you the freedom of using semver to specifying what's good enough while retaining the control on when exactly you are ready to upgrade to the next version. I would suggest using component pin very sparingly if at all. YMMV\n. OK - I get the component shrinkwrap outdated now.\nI still think things are way simpler if shrinkwrap does not make any distinctions between what's already pinned and what's not. But I might be missing something: ask again once I actually have a chance to write some code ;-)\n. yup - npm 'latest' means 'chronologically latest' - see: npm/npm#3397\nmaybe for now we should tell people to install 1.x like this:\nnpm install component@1\n. Thanks @timaschew and thanks to everyone who made component possible. Probably stating the obvious here: many components (as opposed to the component builder and tools) are probably still used in the wild. I'll keep an eye on a few I am still using. Let's wind it down gently.\n. ",
    "buritica": "Any time man! I tried looking for open issues that needed resolution but I'm not very familiar with the roadmap. So if there's some high priority stuff you got, let me know how to find it and i'll try to give you a hand with it.\n\nJuan Pablo Buritica\nt: @buritica\nOn Saturday, May 11, 2013 at 11:04 PM, TJ Holowaychuk wrote:\n\nthanks!\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/component/component/pull/323#issuecomment-17771672).\n. deal!\n\n\nJuan Pablo Buritica\nt: @buritica\nOn Saturday, May 11, 2013 at 11:15 PM, TJ Holowaychuk wrote:\n\nsounds good I'll try and tag some of them soon or add a milestone\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/component/component/pull/323#issuecomment-17771766).\n. \n",
    "ericgj": "I haven't built anything significant with component, so I probably should not comment, but wonder why you would need to design view components to depend on each other?  I don't think of them like 'partial templates', but as semi-autonomous pieces of functionality that communicate with each other in a decoupled way.  \nSo in the case of a list of items, I would start with a single component, maybe with several templates within it (one for the list and one for the item), but with all the logic for rendering them together in one component. \nWhether you even need to depend on the item (model?) library is another question, if you look at the todo app example, you see that the model instance is injected into the view component, not required as a 'factory'.  The thing is stitched together in top-level \"boot\" component rather than the views.  \nAnyway, maybe you have a different situation entirely but I found reading the todo app (and also the component.io website source) very enlightening.\n. if we go with \"templates\" that complicates how several builder plugins work, e.g. component-jade, which exposes *.jade files under \"templates\" as (pre-compiled) functions, not strings. I prefer \"strings\" or some separate key for this reason, unless you can see another way around this without getting too tricky?\n. Oh, I hadn't realized the sass preprocessor uses styles too... well in that case since there's a precedent, I agree with @ianstormtaylor 's proposal.\n. > templates would be made available as strings by default. But then a component-jade plugin's transform step would be to read the templates file, and then remove it from templates, adding the function exported version to scripts.\nYeah, but it starts to get tricky and hard to trace doesn't it? You can't just look at the component.json and figure out what's going on, you have to know upstream whether or not the builder uses a plugin or not. It just sounds like a recipe for hours of debugging to me. (Presumably not so much an issue for standalone components which would include any templates as .js, more of an issue for components within an application.) \nIf component itself is to process everything in templates, maybe plugins should each have their own section, i.e. jade, mustache, etc. ?\n. The case I'm thinking is this: someone else takes over the application, or someone new comes in. They run component build not realizing they should use a template compiler plugin. Instead of failing at the require (as it would do now), the component successfully requires it... as a string. Then they scratch their heads for how many minutes why this thing, how many layers down in the application, looks like a string and not a function. Maybe it's not a big deal in most cases, it just seems to add to the overhead you have to know.\nAlso I thought compiling templates at runtime was not the preferred way to do things, but now we are making that the easiest way to do it?\n. I'm starting to see the logic of this. Maybe it's because I'm using reactive more, and so having templates as requirable strings seems like a sensible default. Maybe plugins should follow the convention of using their own sections rather than pulling selected items out of templates, to avoid ambiguity and general hacky-ness.\n. @micky2be  component create --local doesn't ask for a repo\n. :beers: ,  @thirdreplicator  ... I agree component could use some more compelling 'copy', particularly some compelling example applications or workflows like TJ's screencast would be great.  More coverage in the Javascript blogosphere (Daily JS is where I first heard of it). Of course we're up against a growing industry of the big frameworks there.\nBut I can't see \"Quick Start Make a Blog in 5 minutes with component\" ever being written, the idea makes me kind of chuckle, that's not the problem it's designed to solve, it's not prepackaged software. Besides what @timoxley said so well about the problems with frameworks, I'd say another big appeal of component is you can read the code in an afternoon and understand the whole thing without much trouble. There's no mystery how it all fits together. Thus you are much more confident about your own code that sits on top of it.  Plus you don't have to learn yet another DSL, file format, etc. I would think that component would greatly appeal to Rails people sick of the 'asset pipeline' for instance.\n. :thumbsup:  that's a great idea.\n. I'm thinking more and more we need worked examples of apps or pieces of apps, not just as selling points but to compare notes on what kinds of decisions we're making, etc. which would also help move forward some of the discussions going on in the various repos. @ianstormtaylor 's idea is great and have a few ideas for similar kinds of tutorials/sketches myself, I wonder if we could get something like that started? Maybe a start a list on the wiki where you put down a description of a tutorial you are working on or planning to work on? \n. haha @timoxley scratch that word planning... but since JFDI didn't seem to be working spontaneously I thought it might help to keep this thread alive...\n. massive piece of work @jonathanong , fantastic!  I hope to take a look this weekend.\n. :thumbsup:, especially tutorial style docs, i.e. how do I structure/use components in a real-ish application\n. :+1:   it would be nice to use something like this as a plugin in the new builder API.\n. Great, doing some minor editing now on the https://github.com/component/guide/edit/master/component-v1.md  page, feel free to edit further or revert if not needed.\n. +1 would be glad to have a smaller core, will look at it soon\n. ",
    "ignacioola": "it was just to illustrate the problem, you can put anything you want as the name of the components\n. Sorry for the delay man. \nTried it and the problem was solved.\nThanks!\n. I had this issue with node 0.11.4 and updating to 0.11.9 fixed it.\n. ",
    "mikerudolph": "What is the status on this fix? I don't see it ever being merged?\n. I am still seeing this issue while running on latest, should I open a new issue?\n. @visionmedia whats the current status of this issue? The end issue lies in https://github.com/visionmedia/superagent correct?\n. ",
    "chenglou": "Never mind, working again.\n. I've picked up somewhere that @visionmedia already manages the db in a similar fashion.\nI think the easiest way to go about this is to store the stems only, and when the user searches, take only his keyword's stem and compare it with the db's using the same stemming algorithm. Easy and hassle-free.\n. I think we're talking about the same thing? Letting component handle the vendor prefixes and not writing them by hand.\n. ",
    "nealstewart": "There appears to still be an issue on build. I will likely be returning with another PR.\n. ",
    "luka5": "This will be solved with Issue #312 .\n. +1, even make test fails!\n. well, it doesnt even hurt it sucks, if your using a component just for styling like http://github.com/luka5/bootstrap-modal.\n. ",
    "whirlibulf": "Will packages be able to require code from peer dependencies?\n. ",
    "kokujin": "+1 to \"read HTML files from the templates folder\".\n. ",
    "thirdreplicator": "Hi Tim,\nI agree that frameworks are a bad thing and that reusable components are a good thing.  But, aren't you creating a framework to build components?  \nDavid :)\n. I think I'm starting to get the basic idea.  I think it's fantastic, and\nwhat you guys told me, plus reading the blog article, wants me to learn\nmore.\nBut getting back to this ticket/issue, your README doesn't do the idea\njustice.  You guys need to sell the idea harder.  README files should move\nyou to tears or make you want to climb a mountain.  If it doesn't, people\nwon't be willing to spend hundreds of hours learning your shstuff.  Just\nlike with any product, you need to convert people to your religion.\nFirst, you should improve the tagline.  Here is my suggestion:\nMaking apps reusable, one bite-sized chunk at a time\nSecondly, your project's name is not brandable.  You guys are using a\nreally common word.  It's like naming your company \"Company.\"  Or naming\nyour dog \"dog.\"  Maybe put an \"i\" or an \"x\" in front of it or something\nlike Apple does.\nWho is this for?\n1. Web app builders who are tired of writing the same tightly coupled\n   throw-away code over and over again.\n2. Desktop app builders who are tired of writing the same tightly coupled\n   throw-away code over and over again.\n3. JS library builders(?) who...\n4. Designers (?) who...\nWhat can I use this for?\n1. Building web apps\n2. ... (what else?)\nHuh?\nImagine a car or a house made of legos.  Now get a sledge hammer and\nbreak it down into the original lego pieces.  Match all the same pieces and\nput them in drawers, label the drawers, then put them into a searchable\ndatabase.\nComponents are not only the lego pieces, but slightly larger chunks too.\nThanks to 'require' components can be the lego pieces, the door handle, or\nthe door.  Require let's build reusable modules in larger chunks, so that\nyou're not always working at the cellular level, sometimes you're working\nat the tissue or organ level to use an analogy from biology.\nThe component project not only defines what components are but takes\nresponsibility for organizing, publishing, indexing components to make them\nsearchable, a requirements for reusability.  (If you can't find it, how can\nyou reuse it?)\nWhy?\nComponents is  just add the minimum necessary overhead to make html/css/js\ncomposable.  The only real dependencies to achieve clean and isolated\nmodules are:\n1. the massively successful Node.js require and\n2. the GNU Make tool\nIf you can think of a way make HTML and CSS modular without those two, let\nus know!  Until then read on!\nWhat drug were you smoking when you thought of this?\nDrupal has a great plugin system ....  Require automates the assembly\nA blog article that explains our motivation to create this project:\nhttp://tjholowaychuk.com/post/27984551477/components\nOk, I'm sold, now what?\nQuick Start\nMake a Blog in 5 minutes\nnpm install -g component\n....\nMake a tooltip component in 5 minutes\n....\nAnyway, it's getting late.   Hope this helps.  I'll try to learn more about\nthis project and try to help with the README if you guys want.\n. ",
    "pazguille": "Sorry! I forgot to run component install --dev\n. ",
    "jaredhanson": "I'll take a look at builder hooks when I get home\nAs for the reasons for AMD: I have some cases where async loading at runtime is beneficial. I don't want to forgo that option, so I prefer to have AMD support in the module itself.\nThat said, I really like component and browserify/npm for package management. But, I really don't want to put UMD wrappers around my code just to get CommonJS build support.\nI think it'd be great if web tooling could consume both CommonJS and AMD.\nSent from my iPhone\nOn Jun 18, 2013, at 6:42 PM, TJ Holowaychuk notifications@github.com wrote:\n\nif you're going to de-AMDify why use AMD in the first place (just curious)? but we do have build hooks in place, ATM they're more abstract than browserify's but we'll improve that api later: https://github.com/component/builder.js#builderhookname-fn\nno need for silly streaming either, i'll add a better example, the jade one is a bit of a weird case\n\u2014\nReply to this email directly or view it on GitHub.\n. Builder hooks look promising! I'll let you know if I run into any issues trying to make that solution work.\n. RequireJS will do that, but it needs a usable Function.toString() (which won't work on some older browsers) and then it then parses for require calls using regexs.  On top of that, lighter-weight AMD implementations don't support this.\n\nI consider this to be a RequireJS feature, not valid a valid AMD module, and don't use it in my code.\n. Excellent!  I took the guts of deamdify and whipped up component-amd.  With component-amd in use, you can pull AMD modules into component builds.\nTerrific work, yet again, TJ! Thanks!\n. I think most versions of Opera fall into that category, and some other obscure browsers.\nRegardless, its a hack to parse JavaScript with regexes on the client side just to load modules.  I don't do it.\n. ",
    "domachine": "+1\n. @pgherveou downgrade superagent within your component installation to 0.10.0\n. 0.16.5 has this nasty bug with superagent. see #364.\n. we tried it on 2 VMs now and it's all the same. component fetches the files: some are fine but many are corrupted and cause syntax errors in the build.js file. any ideas?\n. @ianstormtaylor the same for me. it's not really usable. i downgraded to 0.16.5 with superagent 0.10.0.\n. @brighthas ahm ... whatever ...\n@CoryG89 yeah little bit annoying. could you just attach a pull request? i think this will boost this ...\n. looks good to me\n. ahm what about building your 'boot' component as standalone (component --standalone)? using this technique it is 'automatically required'.\n. ",
    "CharlotteGore": "+1\n. ",
    "pgherveou": "same for me any workaround at the moment?\n. Same here, notice the same things with  component/event and\ncomponent/classes\nOn Mon, Jul 15, 2013 at 7:12 PM, Ian Storm Taylor\nnotifications@github.comwrote:\n\nnvm, it's pretty regular now. happens a lot to me with component/eventand\ncomponent/classes, although that could easily just be in my case,\ndownloading ~40 components into /components\ncomponent 0.16.7\nnode 0.8.8\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/374#issuecomment-21017139\n.\n\n\n\nPG\n. ",
    "Enome": "I have this for any online components that I try to install. At first I thought I was using a broken component because the download would get interrupted so I'd have a css file with the last 10% missing. Downgrading to 0.16.4 worked.\n. Sorry didn't see https://github.com/component/component/issues/364.\n. ",
    "calvinmetcalf": "Using releases (or tags) would also sidestep issues with a repo using gh-pages instead of master as it's main branch. \n. not mine, but this one has no master branch but tagged releases\n. ",
    "timaschew": "+1\n. another repo with v prefixes https://github.com/joaonuno/tree-model-js/releases\n. Oh that was another error / different behavior between 0.19 and 1.0.0:\n- you fork a repo without a component.json\n- you add component.json\nIf the repo has some tags / releases, then you cannot install from your forked repo with this dependecy: \"myfork/foobar\": \"*\", because * fetching the latest tag, not the active branch/master.\nSo don't forget to create a tag after a change.\n. both module and exports is now an object, and require is still a function\n. @jb55 agree\n. for those who wanna see the code: https://github.com/component/component/commit/7e27cac209529c4850097840e6edb784166cc589\n. :thumbsup: \n. thanks!\nfor others: see here https://github.com/component/spec/blob/master/component.json/specifications.md#development\n. @kof there is also another tool: https://github.com/jprichardson/tin\n. This has beed fixed, it works fine with 1.0.0, I think it was already fixed in rc-5\nI think @jonathanong forgot to close this issue ;)\n. kind of related: https://github.com/component/component/issues/60\n. @dominicbarnes but you need to pass the options  to the resolver, not the builder, right?\n. > I can finally put this error to rest. It turns out that NAT for my VirtualBox machine was the culprit. I kept getting the 5sec timeout because HTTP requests were taking 6-10sec to run because of slow DNS resolution (due to NAT/VirtualBox configuration)\n@dominicbarnes \nI see your post just now, I have the same problem, for me it's always 5.x seconds, using VirtualBox.\nDid you found a solution/configuration to avoid this delay?\n//EDIT\nI will try this: http://superuser.com/a/259927\n. @dominicbarnes we're using vagrant, too and it worked, thanks :)\nbtw: it enough to pass the timeout only to the resolver (unit: ms)\n. @krainboltgreene what is exactly so amazing?\nI don't think anyone will put new effort into component, see https://github.com/componentjs/component/issues/639\n. can you describe which concept is perfect and why other tools are not suitable?\nmaybe we provide these concepts in tools like webpack via plugins\n. fixed in https://github.com/componentjs/builder2.js/pull/75\n. close due to https://github.com/componentjs/builder2.js/issues/29#issuecomment-57939221\n. can't reproduce it with \nnode v0.10.31\non windows 7\nand component 1.0.0-rc5\nfor me this is working without problems build and execution in the browser: https://github.com/timaschew/component-windows\n@wryk @ivanmanetta @Nami-Doc can you try again and tell me your node version please?\nmaybe you run into this issue http://stackoverflow.com/questions/12719859/syntaxerror-unexpected-token-illegal ?\n. seems to be fixed by a transitive dependency\n. closing\ntokens are supported now, rate limit behaviour is documented and logged\neven for travis-ci you can setup a secured token as env variable. you need to configure it for each repository, this seems to be a good strategy, not just for travis.\n. Who says you could leave a blank, github? Why it's too strict?\n. there is a open PR https://github.com/componentjs/builder2.js/pull/85\nI will check it soon\n. what is best practice to provide components which are written in coffeescript or something else which needed to build before another component can use it. \nmaybe include both the source and build into the repo?\n. Haha, and the alternative?\n. Okay\nAnd can I use npm as component repo? So if I do the build via npm\nprepublish script?\n. yeah, sounds good with the tags.\nbut what's about my question with npm?\n\nAnd can I use the npm registry as a component repo? So if I do the build via npm\nprepublish script?\n\nIn other words: can I add npmjs.org as a remote?\n. closing due to inactivity\n. or to publish component 0.x with a different tag:\nnpm publish --tag=0.19 \nthis remains the latest tag, which is default and would be overwritten otherwise \n. Yes ;)\n. fixed since rc-6 release\n. they removed the component.json in the tag? or is this normal?\nI thought this worked with component 0.19, but there's the same error, but something in my (transitive) dependencies seems to be changed in the last days.\nbtw: why there is a redirect to the tag v0.9.6, why is the master branch is not used for installation if I run component-install techjacker/q\n. ahh, in 0.19 the command is component install that was my mistake ^^\nbut if q is a transitive dependency, how can I solve this problem in component(1) ?\n. okay thanks :pray: \nI will figure out the dependency which is using q without explicit master and try to send a PR with explicit master \n. but that's the problem, there is no tag/release with a component.json\nthat's really shitty:\ntechjacker/q is a outdated fork with a component.json only in the master\nmicrojs/q is a more outdated fork with the component.json only in the master\nkriskowal/q is the origin repository and they don't have inclination to maintain a component.json :scream: \ncan read it here: https://github.com/kriskowal/q/pull/162\nI think that's a reasom to move from q to petkaantonov/bluebird, even it has a better performance\n. To get back to the original issue:\nThe behaviour of component-install seems to be interpreted differently.\nBut the help output and the implementation is clear for me and just doesn't fit with your expected behaviour: https://github.com/componentjs/component/blob/master/bin/component-install#L21-L37\nSo if you provide a name (as an extra CLI argument), the component.json is not used to install the dependency. You just need to call component-install if you want to install dependencies from your component.json.\n. the reason is that the register function is written in this style:\nrequire.register(\"app/foo/./index.js\", ...\nI added a note to the component.json spec: https://github.com/componentjs/spec/blob/master/component.json/specifications.md#file-paths\n. @jasonkuhrt \n\nI am currently thinking of --dev like npm's --save-dev.\n\nI think components --dev flag is more than the opposite of npm install --production\nWith that assumption the test case (https://github.com/component/component/blob/master/test/install.js#L128-L140)  make sense.\n. for me the is-browser npm & component module is a nice solution: https://github.com/ForbesLindesay/is-browser\nHere you can find some other solutions:\nhttps://github.com/component/component/wiki/Component-and-npm\n. the full name trick only works if the module is published to the npm registry with this style <user>-<name> that's the reason why @jonathanong said:\n\nfor this particular case\n. what was your node version before?\n. you mean something like this: https://github.com/component/bundler.js ?\n. issue is fixed by using utils.error() instead of utils.fatal() and the the version of https://github.com/componentjs/console.js now checks if there is a err.stack\n\nfurthermore if an error occurs, previous generated file(s) will be deleted \n. And the guide links to the same article :D\nWe should remove all links which refers to articles / screencast that not\nworking anymore with 1.x\n. I had the same errror yesterday. It seems to happen when components try to\nbuild the css. Other files works.\n. @xiangbai try to install component again please, you have a broken version of the builder-autoprefixer\n. maybe change the order in the component.json:\n\"remotes\": [\"bitbucket\", \"github\"]\nBut I think then you can't use private gihub repos.\n. @netpoetica @tetsuo what do you think?\n. did you add these fonts, or do you get them from a third party component?\nshow your component.json file\n. How it rewrites the font URL?\nIs the CSS file you posted, the generated one? How does your raw CSS looks like? In other words: show what you expect and what the result is?\nHow does your URL looks like if you open the HTML in the broswer? //file oder http? \n. please provide more information to reproduce this issue\n. close due to no reaction\n. so since moving / renaming to componentjs the current url is: componentjs.github.io/component.io/\n@guille a whois query show me that you're the owner of the domain, not sure who else has access, but can you redirect component.io to the github page? or give me access to manage it.\n. we switched to http://component.github.io\n. The only difference between duo and component 1 is the implicit vs. explicit listing of dependencies, right?\nAll other reasons in the Readme of duo referring to component are pointed to the vesrion 0.x\nThe decision (implicit or explicit) is a matter of opinion. We decided at our company with a big code base project to use the explicit version. So browserify and duo are not compatible at this point.\nSo only component seems to be a solution.\n. @MatthewMueller thanks, sounds interesting\n@jonathanong yeah, but if your project is already big, does it really matter? :stuck_out_tongue: \nif you use explicit dependencies you have more control. for instance if you want to switch a component or a version, you need only to change it in your component.json instead of replacing every file which using this dependency.\n. I'm surprised that no one is supporting component.\nI understand that for some people explicit listing of files and refactoring in a manifest is annoying. But duo has also its drawbacks.\nOne of them breaks this philosophy: https://github.com/component/guide/blob/master/component/vs.md#when-is-component-right-for-me\n\nComponent's philosophy is the UNIX philosophy of the web\n\nwith duo components are not self-contained anymore, because when you write require('/lib/foo') or require('../foo) you are reference to a scope out of your component. A component should know nothing about the external world and paths. \nAnd this has a big side effect for the build process, especially when you're using transcompiler and use them separate from components build process. The result is that you cannot build particular components anymore, so incremental builds not working anymore, you need to build everything, the whole app. This feature is only possible with a manifest per component which contains the dependencies.\n. I mean that the manifest (component.json) should be the one and only interface to the external world. At this place you define local and remote dependencies and provide access to them via a namespace mechanism.\n\ni'm not sure i understand what you mean here either. seems like you've created an overly-complex build process for your app. external components shouldn't require a build process otherwise they aren't very good components.\n\nI mean something different:\nWe have an app and it's not a single page, we have about 80 (local) components and we use coffeescript, stylus and jade. So we need to convert these files and run component on the generated files. Since it's not a single page app, we want to build single components during development (only the files we've changed) and not the all 80 components.\nWe can achieve this incremental build by generating makefiles from all our component.json files.\n. yes :)\n. @jonathanong @yields \n\nduo uses Stat.mtime to only parse / build / fetch stuff that are not installed / built already, if that's what you meant ?\n\nYes, but how I explained, we need all manifest files to generate the make rules to build the assets (js, css), because we don't want to use component builder plugins (for coffee-script and stylus). So manifest files are mandatory for us.\nI think it depends on the architecture of your app which tool (component or duo) fits better.\nI don't want to argue against duo, I think for the most architectures you can use it and it boosts your development. That's the reason why I created a tool to convert all your local components into duo compatible require paths.\nhttps://github.com/timaschew/component2duo\nyour feedback is welcome :)\n. we don't want to use it, because we don't want to tie too much with component, maybe we wanna switch to another tool in the future which doesn't support builder plugins like component, so the switch would be easier.\n\nwhy would auto generating makefiles is better / easier than just using duo.\n\nIt's not only about easier, it's kind of architecture philosophy. With manifest files you have only one place per component with an overview of your dependencies, refactoring is done only in one file with a documented scheme. At the other site you have all your dependencies spread over your source files.\n. closing due to https://github.com/componentjs/component/issues/601#issuecomment-56864116 and https://github.com/componentjs/component/pull/604\n. related: https://github.com/componentjs/component/issues/639\n. agree with @netpoetica \nthe problem is that this kind of boilerplate templates don't fit into the concept of small independent modules. This is just hard to manage with CSS only and without using stylus, less or something like that.\nBut even if you would use stylus, for this case of using boilerplate, it's easier to adapt the code to your own purposes.\n. maybe related: https://github.com/component/builder2.js/issues/29\n. yep, sure, I've pinged @guille already in https://github.com/componentjs/component/issues/587#issuecomment-55507830\nand I added a ToDo list in my first post\n. What do you think about open issues in 0.19?\nI think we can tag them and when 1.0.0 is ready to close the issues? \nWhat do you think @ all?\n. so seems that no one want to help out with the component.io domain\nso I moved the project now to component orga back and rename it to component.github.io so that it works now with: http://component.github.io\n. @trevorgerhardt had you problems with the watcher?\n. because it doesn't work for me, but it's just my mac and maybe some wrong configuration and npm links ^^ \nbut here someone else reporting an issue: https://github.com/componentjs/component/issues/585\nyeah agree to fix https://github.com/componentjs/builder2.js/issues/29\nand maybe this here, too: https://github.com/componentjs/component/issues/573\n. so I prepared some things\n- renamed npm module remotes -> component-remotes, the same for builder-autoprefixer\n- update versions (this was actually only neccessary for major change like console.js)\n- create a master project to manage all component modules in one thing: https://github.com/componentjs/development\nmy plan is to fix the issues 29 and 573 (see previous comment) and then publish component 1.0.0-rc6\nand after a week or so to launch 1.0.0 :smile_cat: \nwe should write something about duo on an extra md file and clarify that component development will go on until duo is stable enough and stop it if it become really compatible or something like that.\nbut I think this note we should change:\n\nNewcomers should use Duo instead of this implementation. Duo is more feature-complete and adds additional goodies while still supporting component.json, so check it out!\n. Sounds good, you're a english speaker, right? maybe you can replace or setup it in an extra file. This could be helpful: http://www.jongleberry.com/the-future-of-component.html\nI think \"show how to use the github token, instead of username and password\" has already been fixed\n\nYes, that's right, I meant the remote.js repo and changelog: https://github.com/componentjs/guide/blob/master/changelogs/1.0.0.md\nI fixed it at these parts as well.\n. @netpoetica yes, I removed it already, sorry, I forgot to notify you\n\nAnd then Extras.md would be in the main component repo here?\n\nI think we should make a note, that component repo has only documentation for 0.19.\nAnd everything related to 1.0.0 will be handled in the guide repo.\n\nI can also fill in this bit if you want: https://github.com/componentjs/component/tree/master#team\n\nWould be nice!\n\n@trevorgerhardt \nI would like to fix 3 issues before we pushing rc6, with https://github.com/componentjs/builder2.js/issues/82 is almost done\nI updated the other two tasks in the first post\n\nAre those last two items in docs required for a release?\n\nLike I said, if we seperate between 0.19 and 1.0 docs by using the guide repo for 1.0.0 it's almost done.\nThere are some articles and examples linked, which might not work with 1.0.0\nThese should either moved to componentjs/component wiki (which has a deprecated note) or to make the note for each article\n. just published 1.0.0-rc6 :)\n. So, I would like to update some docs in the guide, then IMO we can release 1.0.0 :smile_cat: \n. yeah would be nice if you could review these changes: \ne5e50\n66f97\n. great thanks :) will publish 1.0.0 now :smile: \n. to use * is usually a bad idea, unless you're using something like a npm shrinkwrap file, because you can't ensure to get things reproducible.\nso if this breaks for some components, it's a signal to pin the * dependencies. you shouldn't fork the repos, just make a PR and if they won't merge it, then you should maybe use another component.\n\nthe downside is that there are a LOT of these being called under official component repos\n\nwe will fix that (add tags) for all our components within the component orga.\n. > but it's ubiquitous\nThat is not a reason to support these bad things ^^\n\nUsing master by default if no tags are present creates less work and isn't an unexpected result.\n\nin which context? you mean when upgrading component from 0.19 to 1.0?\nBut that I think it's not really expectably when you are on the master using * and then someone push a commit which breaks your app. Any branch, if master or something else, representing your current working draft which is not guaranteed to work.\n\nIsn't forcing tags equivalent to forcing a \"publish\" step like npm?\n\nYes, it is :)\n. > That would happen as well if someone publishes a new version without thorough testing. It's not a matter of tag/no tags, it's a matter of being mindful about what code is pushed/tagged. \nThe frequency matters, in a active project you commit and push more often than release a new tag.\nokay so let's do the fallback and make a console.warning  with a  deprecated note. and tell the people to pin it or change it to master. the fallback will be removed in component 1.1.0\n. yep :) I found and changed it already, need to do some test, then I'll push it\nshould be this function: https://github.com/componentjs/resolver.js/blob/master/lib/dependencies.js#L126-L150\n. hmm I can't reproduce this, that's strange because I run into this issue as well some month ago\n. @gvilarino master is used as fallback, here is the line: https://github.com/componentjs/resolver.js/blob/3b4a7a04663e7b99d4a5ec99a414fec6b04a0384/lib/semver.js#L141\nSo I close this issue unless you give me a script to reproduce the behaviour you described.\n. isn't it just component install component/aurora?\nThis works for me, that's the reason why I'm asking to close, because the issues seems to be gone?\nMaybe github now returns not an empty array for tags anymore, because I don't see that the implementation of component has changed in the meanwhile.\nSo the issue should be open if we can reproduce what you have reported in your first post.\n. :+1: \nThanks :)\nSo where we should link the extra.md About Duo.js?\n. Yeah, that makes sense :)\n. @netpoetica let's merge it :)\n. okay thanks for the info\n. Oh thanks, component open was removed, see here https://github.com/componentjs/component/pull/578\nI'll update the message and link to http://component.github.io/troubleshooting\nBTW: I can install the dependency without any problems if I run:\n component install swatinem/scrollbars@0.0.1  even component install swatinem/scrollbars works fine.\nDid you installed component properly? Try this component --version If it's correct, please show your component.json file(s)\n. fixed in https://github.com/componentjs/resolver.js/commit/0ce1775cd84bd37b23938ba751d8116695dc23ac\njust reinstall component via npm\n. I don't get \n\nI think is possible import all dependencies one by one, but there is other way to do that?\n\nand is this a problem for you:?\n\nInside of menuTest.js I import index.js but, index.js require other local components.\n\nDid you checked out my c8-experiments repo? Here is a commit, where I test a local component: https://github.com/timaschew/c8-experiments/commit/4266bd7c43ed3bcb800f61ef24a9d6b01e9dae22\nI have this structure\n\u2514\u2500 lib\n    \u251c\u2500 dev-local\n    \u251c\u2500 foobar\n    \u2514\u2500 my-component\nmy-component has a local dependency to foobar and in dev environment it also has dev-local as a dependency\n. So @vmariano did you solve it or you need some help?\n. what is your npm version?\nand can you try this one\n- create empty directory and then add this file package.json:\njson\n{\n  \"name\": \"component-test\",\n  \"version\": \"0.0.1\",\n  \"dependencies\": {\n    \"cogent\": \"git+https://github.com/timaschew/cogent#fix-redirects\",\n  }\n}\n- and then just a npm install\nDoes this work for you?\n. It's the wrong order, see DEBUG:\nremotes:github GET \"https://raw.githubusercontent.com/component/emitter/master/component.json\"\nremotes:github GET \"https://api.github.com/repos/component/emitter/tags\"\n. I mean we can fetch all tags for a repo (one request), then sort them and use the latest tag to check if there is a component json. If the latest tag doesn't contain a component.json then we don't check all other tags, instead we check the master branch (second request in this worst case).\n. have you some other examples?\nwhat exactly is ugly? that there is a missing warning prefix? or the wording?\n. damn, the tests passed, but not in the parent project which are not executed automatically :scream_cat: \nI close this one in favor of https://github.com/componentjs/remotes.js/issues/22\n. > Is mca \"mac\"?\nOps, yes - I meant mac\nI think the problem is because the repo has no github auth token\n. Yep, I think supporting < 0 isn't worth it.\n. I think it's a dup: https://github.com/componentjs/builder-es6-module-to-cjs/issues/1\n. Looks like a bug, hmm, I'll test it for another remote\n. thanks, found the error, it was a side effect of some change in the last resolver by me.\nIt become a problem here: https://github.com/componentjs/resolver.js/commit/2dceb3bf5713b39c2f5813032635dc934e2832ff#commitcomment-9372384\nI already fixed it, need to clean up and commit&push it.\nBTW: components/jquery@~1.7 is another issue, version 1.7.2 has no comonent.json: https://github.com/components/jquery/tree/2c28f73cb57535e37283b7f27fa1e06307bd09af\n. can reproduce the same , but just with this error:\nRefusing to install component as a dependency of itself\nstrange, I just fixed the repo and republished, now it works again: https://github.com/componentjs/component/commit/1faa7767ae9fd1247e25193639aa682511683ca8\n. there is no real component registry, all the components are just on github.\nthe important thing is that the repository needs to include a component.json file.\nIf your project you're looking for has no component.json you can fork it and add the file (and send a pull request)\n. You can test it just by run\ncomponent install shobhitg/dc.js\n Am 14.02.2015 01:05 schrieb \"Shobhit Gupta\" notifications@github.com:\n\nThanks a lot for explaining.\nI forked and added component.json file.\nCan you please glance and see if it looks right before I make a pull\nrequest: https://github.com/shobhitg/dc.js/blob/develop/component.json\nAlso I have a question, is there a way I can tell component to use \"dc.js\"\nfor development mode and \"dc.min.js\" for production mode?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/componentjs/component/issues/624#issuecomment-74349168\n.\n. > Also I have a question, is there a way I can tell component to use \"dc.js\" for development mode and \"dc.min.js\" for production mode?\n\ncomponent have two main features:\n- package manager (component-install) \n- build tool (component-build)\nIf you define dependencies via the copmonent.json you using it as a package manager. In this scope you should never provide minified files.\nTo distinguish between your enviroments: dev and prod you can use component as a build tool. In you process flow this step is after the part of managing the dependencies.\nComponent has no built-in minify features if you using it via the CLI (,yet)\nIf you're using component via the API resolver and build(er) you can use this one for instance: https://github.com/ianstormtaylor/minify\n. yes, it's really a pain, but I don't think it belongs to component.\nIt could be a feature of https://github.com/tj/git-extras\n. It looks like it solves the same problems.\nSome differences which I see at a first glance:\n- component use commonJS, you can wrap the build output with a UMD\n- component has support for github and bitbucket endpoints, npm is not supported yet (#613)\n. > I guess this is concatenated by Component from the FastClick lib itself.\nNo FastClick, provides this to support several module loaders, so this part has nothing to do with component.\nYou can see here the raw script (not build by component or somehting else): https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js#L829-L840\n\nWhen Switchery needs FastClick and executed require('fastclick'), Component's require function will return an empty Object since there is no module.exports for that at all. That of course breaks Switchery.\n\nno this is wrong, component is throwing an error if a module could not be loaded.\nIt looks like someone is using something wrong, but I'm not sure yet.\n. I think this is a switchery/fastclick issue?\nsee https://github.com/abpetkov/switchery/issues/22#issuecomment-34957892\n. okay whatever the comment did said: https://github.com/abpetkov/switchery/issues/22#issuecomment-34957892\nit seems to be fixed.\n\nI tried out to install switchery via component install abpetkov/switchery\nthis works fine, here is the output:\ninstalled : abpetkov/switchery@0.8.0 in 1708ms\n   installed : abpetkov/transitionize@0.0.3 in 1183ms\n   installed : ftlabs/fastclick@v0.6.11 in 1218ms\n   installed : component/events@1.0.9 in 1248ms\n     install : complete\nThen I run component build --dev and this worked as well.\nI embed the generated js file into my html file and open it in the browser.\nThen I added a breakpoint into the switchery file. Then I run this command in the webdev toolbar\nrequire.latest(\"abpetkov~switchery\") and verified that switchery was required successfully.\n. I think that's a feature, it's by design that you cannot require something from a standalone output, that's why it's called standalone\n. there is, if you don't use --standalone, instead wrap it into a UMD\n. > there is, if you don't use --standalone, instead wrap it into a UMD\nsorry, that was wrong\nSo, if you would use component to build something on top of Switchery, the you should avoid --standalone\nBut when you using another module system like requireJS, then you're right.\nSo I executed the UMD build of Switchery (dist/switchery.js), it works fine, it requires Switchery and fastclick without any problems.\nSo if you have still a problem provide a script or a repository, how I can reproduce your problem.\n. is it on github or bitbucket?\nhow your component.json looks like?\n. need more information: \n- content of your component.json\n- which auth mechanism are you using?\n- which version of component?\n. I add add you to my private test reop, it works fine for me with component 1.0.2\n```\n$ component install timaschew/TodoFPM-test-private\ninstalled : timaschew/todofpm-test-private@master in 783ms\n     install : complete \n```\nis it working for you?\n. can you show me the content of your netrc (without the password/token)\n. your netrc is wrong, you need to change the first host entry, instead of github.com you need raw.githubusercontent.com\nThere was an error in the guide, it was fixed some weeks ago: https://github.com/componentjs/guide/blob/master/component/getting-started.md#configuring-github-access \n. What's the error if you omit the github.com host? Because there should be no request for this host.\nIf there is an error DEBUG=* component install user/repo should show where the error comes from\n. no, drop github.com not api.github.com\n\ninstead of github.com you need raw.githubusercontent.com\n. - what is the error?\n- how your build output looks?\n- how you build your app?\n- do you use the hbs plugin and if yes, how?\n. why you use also the string plugin? \nhttps://gist.github.com/aprilb/aedad66feec4236f1982#file-gistfile1-txt-L58\n\nthe readme of the handlebars plugin don't mention the string plugin, so it looks like you using it wrong.\n. If you want help, please provide a repository where I can reproduce the problem.\n. to less information: no install log, no build output file via gist for intance\n. I'm not sure what your issue is ;)\n. can you explain why you deleted the description and closed the issue?\n. duplicate https://github.com/componentjs/crawler.js/issues/7\n. DEBUG=* can help to find where the error comes from, see https://github.com/componentjs/guide/blob/master/component/troubleshooting.md\ncomponent uses cogent for http requests, there is a deafult timeout of 5 seconds, but you change the timeout: https://github.com/componentjs/component/blob/1faa7767ae9fd1247e25193639aa682511683ca8/bin/component-install#L13\nso we can close this issue?\n. > It looks like the '--timeout' flag does not work on all operations within 'component'.\nYep, I think this is the problem, here is the code:\nhttps://github.com/componentjs/remotes.js/blob/0c32e97cc07dd2bbb7076fdf52102e514d4b7431/lib/remotes/github.js#L43\nThe options are not passed at this place.\nGood catch, thanks!\n. I was wrong, it's not the problem, I add a console.log into every request and the timeout option works fine:\n```\nawilhelm@antonsmac:~/dev/c8-experiments$ rm -rf components/tj && component-install tj/debug\ntimeout:  5000\ntimeout:  5000\n  outdated name of a dependency : please update: \"tj/debug\" -> \"visionmedia/debug\"\ntimeout:  5000\ntimeout:  5000\ntimeout:  5000\ntimeout:  5000\ntimeout:  5000\n   installed : tj/debug@2.1.3 in 2186ms\n     install : complete\nawilhelm@antonsmac:~/dev/c8-experiments$ rm -rf components/tj && component-install --timeout 20000 tj/debug\ntimeout:  20000\ntimeout:  20000\n  outdated name of a dependency : please update: \"tj/debug\" -> \"visionmedia/debug\"\ntimeout:  20000\ntimeout:  20000\ntimeout:  20000\ntimeout:  20000\ntimeout:  20000\n   installed : tj/debug@2.1.3 in 1347ms\n     install : complete\n```\n. Cannot go further without any debug lines\n. > DEBUG=* can help to find where the error comes from, see https://github.com/componentjs/guide/blob/master/component/troubleshooting.md\nI just added a console.log after this line with the \u00b4timeout` value: https://github.com/timaschew/cogent/blob/patch-1/lib/index.js#L39\nSo search for this file within your node_modules. Be careful, if you using node without generators you need to use the index file in the build directory instead of in the lib.\n. line 565 form in build comes from line 130 in the source: https://github.com/componentjs/resolver.js/blob/master/lib/semver.js#L130\n\nI find this code very hard to follow !\n\nyou should not read the build, it's a generated code, switch to node 0.12 with --harmony or just use iojs, then you can read and execute the raw code (in the lib directory) \n. inherit@0.0.3 works fine for me\n```\n$ component install component/inherit@0.0.3\ninstalled : component/inherit@0.0.3 in 1428ms\ninstall : complete\n```\nhow can I reproduce your issue?\n. It's quite more easier to run it with iojs, because you don't need any flags for it.\nIf you really want to stick to node, here is a note how to run component with harmony flag for 0.11 and 0.12\nhttps://github.com/componentjs/development#running-component\n. works fine with component 1.1.0\n```\n$ component install lodash/lodash\ninstalled : lodash/lodash@3.8.0 in 1771ms\n     install : complete\nvagrant@devbox:~$ component --version\n1.1.0\n```\n. we're generating them as well, but we still have our Manifest files for each local.\nwe want to drop component now in our company, we have to many issues.\nwe're switching to webpack now, see https://github.com/componentjs/component/issues/639\n. Of course component and its modules (component-builder, component-resolver, component-remotes ,..)  - actually everything in the componentjs organisation - will still available on npm and on GitHub, but the development will stop for new features and bugfixes.\nAnd of course all the components like commponent-dom and domify, everything in the component organisation will still work, as long the modules have a component.json file. They even work for other tools like browserify, webpack and jspm if they provide a package.json \n. > When I run component build, the css file gets put into components/necholas/normalize.css/3.0.3/normalize.css\nThat's not completely true. I think you misunderstood the usage of component build and component install.  component build call internally component install if it does not find the dependencies in the components directory.\ncomponent install does install all your dependencies into the components directory, it's like npm and node_modules and you should not use these files directly!\nWith component build you can bundle the files (to use them in the browser), if you're using the CLI you can specify the name and directory of the js and css file, you can run component build --help to find out which options are provided.\nBut in your case you don't want to put the js and css files together into one directory, so then you need to use the builder API\nBUT you should consider to use another tool, because component is deprecated already.\n. You can't use component when your dependencies don't provide a  component.json file in the root directory.\nHere is the spec: https://github.com/componentjs/spec/blob/master/component.json/specifications.md\nBUT component is not maintained anymore, you should consider to switch to another tool, there are lots of good tools, which don't rely on a custom configuration like component.json, they all (expect bower) use package.json standard:\n- webpack\n- jspm\n- browserify\n- bower but this tool doesn't support package.json and is only installing the dependencies, it neither build or bundle them nor it provides a module system\n. Sounds good, thank you. I removed most of the people, 7 have access now.\nDid the people get any notification that their credentials were leaked?\nJust want to be sure it wasn't me...\n. > I am working on a project which is using componentjs\nBe aware, componentjs is deprecated since 2015\n\nWhen trying to require a module in the node_modules folder such as require(\"nodemailer\"); It cannot find it\n\nnodemailer is not a compatible with component\n\nThere are no component dependencies which allow for mail.\n\ncomponentjs is a build tool for frontend modules. Mail related modules require a server.\n\nHow do you require a node_module without having to create a component out of it? any ideas?\n\nNot at all, if you're using componentjs. Just use Node.js. > The problem is the structure of component is it doesn't allow you to require node_modules from the server as it is trying to look for a component.\nOf course, as I said, component is a package manager and build to tool (bundler) for the frontend. You won't be able to require a module which doesn't have nor a component.json or some special properties in the package.json and that is by design!\n\nI know nodemailer would not work with component but it seems to override the require command completely which is how you require server-side node_modules. \n\nNot exactly, it just provides an implementation of require, because browsers don't have requireimplemented.\n\nHow do you require non-components using node.js and use them on the front-end when component is present in the project?\n\n\nNot using component, switch to webpack. This is the de facto standard frontend bundler.\nAdd a component.json or these properties to the module.\nIf you don't have control of the module, wrap it.\nTry out https://github.com/eldargab/component-as-module\n\n\nHow would i require nodemailer using the \"require\" command when it tries to look for a component?\n\nAh, I think I got it. So you have already component in usage. But i still don't understand how you want to use nodemailer in the browser, this doesn't make sense and is just impossible, see https://stackoverflow.com/questions/37630543/can-i-use-nodemailer-in-browser\nAnyway if you want to load a module which is not compatible with component you basically need  another bundler. Some bundler polluting the global scope with require so you need to take care that they are bundling their modules isolated, for component see https://github.com/componentjs/guide/blob/master/creating-components/standalone-umd-builds.md\nBut this sounds like a really ugly hack. I recommend you to switch from component to webpack or some other maintained  bundler.. thanks :)\n. ",
    "stephenmathieson": "@timaschew when were developing and pushing changes quickly, we just use \"foo/bar\": \"master\" rather than *\n. closing (dupe of #124), though there doesn't seem to have been any progress or discussion in months...\n. awesome!!\n. thanks man that was bothering me\n. @yields nope, as the tests aren't built.  your tests for k are experiencing the same thing.\n. i'm not sure if it's builder.js or component itself.  i haven't dug too far yet.\n. Can you do something like this (like @timoxley suggested)?\n``` Makefile\nbuild: my-custom-out-dir index.js\n    @component build --dev\nmy-custom-out-dir: component.json\n    @component install --dev\n    mv components my-custom-out-dir\n```\n. > Component names must match the folder name\nas @marcelklehr asked, i'm curious too... so: why?\n. rather than adding a bunch of weird stuff to component.json, what about builder.json?  we could possibly make component-build(1) respect it..\n. what's wrong with $ DEBUG=component:* component build, etc?\n. +1 for some way of turning auto require off\n. imo, too many options is a ridiculous problem.  check the man page for ls(1) :p\n. > npm ERR! not found: git\n\nnpm ERR!\nnpm ERR! Failed using git.\nnpm ERR! This is most likely not a problem with npm itself.\nnpm ERR! Please check if you have git installed and in your PATH.\n\nLooks like you need to install git. \n. @dominicbarnes Haha beat me to it!\n. yup it's private. I've got my credentials setup, but still seeing this. I'll look more in depth in a bit\n\nOn Jul 3, 2014, at 2:26 PM, Keith Rosenberg notifications@github.com wrote:\n@stephenmathieson is this a private component? If so, have you configured your globals?\nCan you run with DEBUG=* and provide the output?\n\u2014\nReply to this email directly or view it on GitHub.\n. here's output with all of the debug stuff: https://gist.github.com/stephenmathieson/b4c065fb3e32fe491f2d.  no mention of bitbucket at all :/\n. haha, yeah, some-bitbucket-user isn't the actual username :p \n\nthe actual error is displayed on lines 724-736\nthe API will 403 without credentials:\n$ curl -v https://api.bitbucket.org/1.0/repositories/dmusser/project-x-highlighter/tags\n[ . . . ]\nHTTP/1.1 403 FORBIDDEN\n[ . . . ]\nbut with credentials, we'll get back:\n```\nHTTP/1.1 200 OK\nContent-Language:en\nETag:\"a6bb68d2f5e363089010c410d9b9551e\"\nX-Render-Time:0.471938848495\nContent-Length:1039\nX-Served-By:app22\nX-Version:69e6e47e5db0\nX-Request-Count:284\nServer:nginx/1.5.10\nX-Content-Type-Options:nosniff\nX-Frame-Options:SAMEORIGIN\nStrict-Transport-Security:max-age=31536000\nDate:Mon, 14 Jul 2014 17:52:41 GMT\nVary:Authorization, Accept-Language, Cookie\nX-Static-Version:2de54e0b41c0\nContent-Type:application/json; charset=utf-8\n{\n  \"0.1.0\": {\n    \"node\": \"9fbb859b6821\",\n    \"files\": [\n      {\n        \"type\": \"modified\",\n        \"file\": \"History.md\"\n      },\n      {\n        \"type\": \"modified\",\n        \"file\": \"component.json\"\n      },\n      {\n        \"type\": \"modified\",\n        \"file\": \"package.json\"\n      }\n    ],\n    \"raw_author\": \"Stephen Mathieson smath23@gmail.com\",\n    \"utctimestamp\": \"2014-06-02 14:01:32+00:00\",\n    \"author\": \"stephenmathieson\",\n    \"timestamp\": \"2014-06-02 16:01:32\",\n    \"raw_node\": \"9fbb859b68217620b93c194021291595c134d49e\",\n    \"parents\": [\n      \"c80e7a26b472\"\n    ],\n    \"branch\": \"master\",\n    \"message\": \"Release 0.1.0\\n\",\n    \"revision\": null,\n    \"size\": -1\n  },\n  \"0.0.1\": {\n    \"node\": \"bcb0050fc43b\",\n    \"files\": [\n      {\n        \"type\": \"added\",\n        \"file\": \"History.md\"\n      },\n      {\n        \"type\": \"modified\",\n        \"file\": \"component.json\"\n      },\n      {\n        \"type\": \"modified\",\n        \"file\": \"package.json\"\n      }\n    ],\n    \"branches\": [],\n    \"raw_author\": \"Stephen Mathieson smath23@gmail.com\",\n    \"utctimestamp\": \"2014-05-29 14:21:09+00:00\",\n    \"author\": \"stephenmathieson\",\n    \"timestamp\": \"2014-05-29 16:21:09\",\n    \"raw_node\": \"bcb0050fc43b4a9a395585c44465f1cc4a4acee5\",\n    \"parents\": [\n      \"c2bdd4597059\"\n    ],\n    \"branch\": null,\n    \"message\": \"Release 0.0.1\\n\",\n    \"revision\": null,\n    \"size\": -1\n  }\n}\n```\nEDIT: typo\n. btw, it looks like we're never hitting the API at all: https://gist.github.com/stephenmathieson/b4c065fb3e32fe491f2d#file-gistfile1-txt-L471\n. yup\n. @jasonkuhrt the comma thing seems silly, as brace expansion already works ;)\n```\n$ component install component/{emitter,tip}\n install : component/emitter@master\n install : component/tip@master\ncomplete : component/emitter\ncomplete : component/tip\n\n```\n. Duo (component+browserify) will have the same flat dependent structure you're used to, and should be mostly backwards compatible with component ;)\n. duo isn't quite ready yet, so you probably shouldn't be installing it yet :p\nfor what it's worth, i can install it fine:\nsh\n$ npm --version\n1.4.14\nstephenmathieson at MBP in ~/repos/tmp/foo\n$ npm install duo\nnpm WARN package.json better-assert@1.0.0 No repository field.\nnpm WARN package.json component-builder@0.6.5 No repository field.\nnpm WARN package.json express@0.14.0 No repository field.\nnpm WARN package.json stdin@0.0.1 No repository field.\nnpm WARN engine koa@0.8.2: wanted: {\"node\":\">= 0.11.9\"} (current: {\"node\":\"v0.10.29\",\"npm\":\"1.4.14\"})\nnpm WARN engine koa-ratelimit@1.0.3: wanted: {\"node\":\"> 0.11.4\"} (current: {\"node\":\"v0.10.29\",\"npm\":\"1.4.14\"})\nduo@0.5.4 ../../../node_modules/duo\n\u251c\u2500\u2500 co@3.1.0\n\u251c\u2500\u2500 unyield@0.0.1\n\u251c\u2500\u2500 co-exists@0.0.1\n\u251c\u2500\u2500 debug@0.8.1\n\u251c\u2500\u2500 stream-log@0.1.0\n\u251c\u2500\u2500 bytes@1.0.0\n\u251c\u2500\u2500 thunkify@2.1.2\n\u251c\u2500\u2500 delegates@0.0.3\n\u251c\u2500\u2500 win-fork@1.1.1\n\u251c\u2500\u2500 batch@0.5.1\n\u251c\u2500\u2500 extend.js@0.0.1\n\u251c\u2500\u2500 step.js@2.0.1\n\u251c\u2500\u2500 commander@2.3.0\n\u251c\u2500\u2500 archy@0.0.2\n\u251c\u2500\u2500 json-mask@0.3.1\n\u251c\u2500\u2500 atomic-json@0.0.3 (enqueue@0.0.3)\n\u251c\u2500\u2500 co-parallel@1.0.0 (co-thread@0.0.1)\n\u251c\u2500\u2500 duo-string-to-js@0.0.4 (string-to-js@0.0.1)\n\u251c\u2500\u2500 file-deps@0.0.5 (mini-tokenizer@0.1.2)\n\u251c\u2500\u2500 mkdirp@0.5.0 (minimist@0.0.8)\n\u251c\u2500\u2500 co-fs@1.2.0 (thunkify@0.0.1, co-from-stream@0.0.0)\n\u251c\u2500\u2500 component-clone@0.2.2 (component-type@1.0.0)\n\u251c\u2500\u2500 duo-pack@1.0.2 (combine-source-map@0.3.0)\n\u251c\u2500\u2500 duo-package@0.4.2 (thunkify@0.0.1, enstore@0.0.2, node-netrc@0.0.1, semver@2.3.2, gh-resolve@3.0.1, request@2.39.0, tar-fs@0.4.1)\n\u251c\u2500\u2500 duo-main@0.0.3 (component-type@1.0.0, mocha@1.21.3)\n\u251c\u2500\u2500 duo-test@0.2.4 (co-exec@1.1.0, buffer-events@0.0.2, wd-browser@0.1.1, open@0.0.5, queue-component@1.0.6, koa-route@1.1.4, debug@1.0.4, koa-common@1.2.0, koa-static@1.4.6, koa@0.8.2, to-pascal-case@0.0.2, localtunnel@1.3.0, mocha@1.21.3, wd@0.3.4)\n\u251c\u2500\u2500 max-component@1.0.0 (to-function@2.0.5)\n\u2514\u2500\u2500 gnode@0.0.8 (regenerator@0.4.12)\n. @bmcmahen yeah, you probably shouldn't be using it yet haha\n. yeah thats fair. there are still major decisions being made atm, so i wouldn't get too used to it yet\n. @fairwinds i've been working to get BitBucket support built-in.  I don't think it'll land before the initial release, but it is in the works!\n. @timaschew sounds like your build process is overly complex.  why don't you want to use plugins?\ncoffee support could be as simple as:\n``` js\nvar coffee = require('coffee-script')\nmodule.exports = function (opts) {\n  opts = opts || {};\nreturn function coffeePlugin(file, duo) {\n    if ('coffee' != file.type) return;\n    file.type = 'js';\n    file.src = coffee.compile(file.src, opts);\n  };\n};\n``\n. @fairwinds nope, not yet. There's basic custom provider support in./duo/lib/parse.js`, but that's all I've been able to convince @MatthewMueller to merge thus far :p\nI think the eventual BB support will be something like:\njs\nvar module = require('bitbucket.org/somebody/module@x.y.z:index.js')\n// ... etc\nI've got basic semver support with bb-resolve, but it needs a bit of work still.\nI think the plan is to get Duo as stable as possible, then add features like BitBucket, etc. \nedit: there's a PR for duo-package which adds support. I think it's conflicted at this point tho :/\n. @visionmedia i can only speak for myself too, but i use BB for business logic and GH for everything else.   BitBucket offers free private repos, so it's hard to justify paying to host ~50 SLOC javascript components on GitHub.\n. @jonathanong I used hg on a project years ago just to test it out. never again though haha\n. > I guess what I should have said is public components should be on GH, otherwise it's just pure rage haha\nagreed ;)\n. What?\n. Ahh okay. We don't support that.\nWhat's the use case? Why not just use your editor?\n. keep the left side of the : short and simple.  for example: warning : ... (as suggested in the OP).\n. ",
    "lancejpollard": "Getting this too, it seems pretty random. Sometimes it injects extra characters in one place, sometimes in another place, sometimes not. It seems to happen at roughly the same few points in the code though.\nAny updates?\n. @yields component v0.16.7, node v0.10.4\n. Haven't had much time to dig in, but seems like it's probably happening because of the this.piped in superagent:\nhttps://github.com/visionmedia/superagent/blob/f25d32432cf04d992f65e82187ab002d65444c5f/lib/node/index.js#L691-L696\njs\n    if (self.piped) {\n      res.on('end', function(){\n        self.emit('end');\n      });\n      return;\n    }\nhttps://github.com/visionmedia/superagent/blob/f25d32432cf04d992f65e82187ab002d65444c5f/lib/node/index.js#L399-L410\njs\nRequest.prototype.pipe = function(stream, options){\n  this.piped = true; // HACK...\n  this.buffer(false);\n  this.end().req.on('response', function(res){\n    if (/^(deflate|gzip)$/.test(res.headers['content-encoding'])) {\n      res.pipe(zlib.createUnzip()).pipe(stream, options);\n    } else {\n      res.pipe(stream, options);\n    }\n  });\n  return stream;\n};\nconsole.logging some when the streams each close shows that the first block of code executes before the gzip stream is finished. It seems that the end shouldn't be called until the gzip finishes. This could explain why only part of the file is written (seemingly random, but most of the time at the same position in the file). Haven't used the latest streams much yet tho, so might be missing something.\nSeems like maybe it needs to be using the close event instead of end? Or is there a bigger problem with node.js streams in general?\n. following @domachine's suggestion solved the problem, good temporary workaround:\nbash\n$ npm uninstall component -g\n$ npm install component@0.16.5 -g\n$ cd /usr/local/share/npm/lib/node_modules/component\n$ npm install superagent@0.10.0 -S\n. Agreed, component is so much better than anything out there, it feels like a waste to write code any other way.\n@anthonyshort i'd be glad to help writing with articles here and there too, let me know if you start on something. btw i'm pretty excited about ripplejs, nice work man.\nIn terms of docs, there's like three groups of people:\n1. the vast majority of coders who just use tools to get their work done and don't really ever dig into open source projects or write their own things\n2. people who are actively learning how to code and dig in and make their own stuff, who participate in open source, but use docs and tutorials to get started\n3. people who just read the code and tests and whatnot to figure it out\nThe biggest impact component is making is that it's standardizing the way code is written, so it's shareable, and eventually becomes maximally optimized and simple. This is huge for companies. Most companies using JavaScript haven't even heard of component that I've talked to, and most are still using large frameworks (or hiring people to help refactor their huge code bases which is a waste if it's still done with large frameworks). Imo if they started using it they would move way faster and put themselves in a much better position. Components pretty quickly get refined and \"completed\" with tests and all that, and they're optimized and clean and easy to dig into.\nSo in terms of docs for the first group of people, imo it should be simple and basic, just how to install it so they can continue building their web app in a better/faster way. They don't need anything about how to create their own component or whatever, just a page that if one of us pointed them to it, they would be like \"oh yeah that makes sense, let me start installing some of these components so I can finish this work thing\". Like twitter bootstrap in a way. This group of people probably won't create components or dig into the wiki or readme or anything, but they are the large part of developers at companies and if they started using component they would be more effective and would provide more short and long term value for the company.\nFor the second group of people, not sure about the best way of writing tutorials and screencasts (but trek did some great tutorials for Ember a while ago, so they may be helpful to checkout, i think this is it. Ember's guides are also pretty straightforward). However, having a clean page with a few clean and simple components' source on the left with a visual or something on the right (like twitter bootstrap, or the ionic ios framework) might be helpful. Something where you could see examples of well built components, outlining how the readme and source code comments are all structured and all that... that would be exciting and helpful I bet.\nAfter learning just the bare bones (which is really all there is), you'll be able to create components and contribute to existing ones and all that. The more detailed stuff like creating your own build process and such seems like it'd be fine just in the wiki.\nThoughts?\n. One of the things that's really great about component that just became clear to me is that you can include arbitrary strings in them, which you can require like anything else. All you do is specify them in the templates field.\nSo I'm taking a little time off to learn some new stuff and I got excited about the idea of being able to draw diagrams, really simple diagrams. Basically you just need a graphics library, and there are lots of them. There's one like flash (Easel.js), there's Paper.js, Two.js, Fabric.js, and Raphael.js. And a new one, Pixi.js, just came out with 2d WebGL support.\nBut it's like, I don't want to deal with all of that.. I don't know anything about blend modes or bezier curves, and just want to start with the basics and piece together what I need. So that's where component comes in, just start building really simple stuff and compose it into more complex stuff.\nIf you look at any of these libraries, they are like 80-90% the same, with at least 50% of the code the same boilerplate as every other large library. The thing that got me really excited was seeing how Pixi.js and Three.js are basically hardcoding tons and tons of WebGL shaders as strings deep within their code bases. That is a total waste, and something that's well suited for componentizing.\nCheck it out, here's one of many files from Three.js with the WebGL shaders:\n\nPixi.js has the same thing. There's probably a hundred or more in Three.js, and that stuff is complicated. Not to mention it's hard to read in those strings like that.\nInstead of keeping all that as part of a huge repo, imagine if there were just a huge collection of shader components, just the straight .glsl files for WebGL vertex-shaders and fragment-shaders. For things like 2d and 3d lighting, textures, water, particles, etc. Or for simple things like circles and squares for simple diagrams.\nThis is what that Three.js stuff would look like as simple components:\n\nThis kind of stuff is happening in all sorts of areas, and it's all making life so much simpler. And it shows that even pretty complicated projects like Three.js and D3.js are really at least 50% boilerplate, and the rest could be pretty quickly redone as smaller, faster components.\n. @jonathanong sounds good :)\n. The components folder is also just like the node_modules folder. It just stores your remote dependencies (though you could put your local dependencies in there). The reasoning is (I imagine) because you don't need to worry about that folder. If you want to put your local components in their own folder, you can do that just like you're describing, and then either write a custom build script, or possibly point to your source/components/x using the \"local\" and related properties in your root component.json.\n. It probably also has to do with coming to it from a server-side perspective somewhat. You could have your client-side stuff and your root component.json inside of a sub folder like source/components and source/component.json, and just add a task at the root to build it and move it to where you want.\nAs a side note, there's a couple branches here showing some different folder structures for simple apps:\nhttps://github.com/component/todo\nAlso, when you are building standalone components, you want the component.json to be at the root, because all you have in the repo is just an index.js and perhaps some css and html. So that's why it's not customizable.\n. Not only that but if there is an error there's extra whitespace :/\n```\n$ component build\n       build : resolved in 10ms\n       build : files in 6ms\n   error : failed to read \"project-page\"'s file \"template.js\"\n\n$\n```\nBasically this gives the feeling of a lack of care for quality in the component ecosystem, one of the main things that originally made it so attractive.\n. That makes sense, because functionally who cares. But design and clean-ness are also just as important.\nWhat will inevitably happen is if these loose ends aren't taken care of from the start, they will build up and build up and never be gotten around to. The more and more these collect, the more it feels like a giant mess.\nI appreciate all the effort you are putting into this tho, for sure. I just got super upset seeing this, it was a big slap to the face lol.\n. Haven't figured out the error logging one yet.\n. Have any tests been being written lately? It seems that the large number of problems with component lately is because there are basically no tests being written. We should be definitely write tests for each of the cases that breaks, so it stops happening over and over again.\nFrom what it looks like, all of the code for builder.js/component/installer.js hasn't had any tests written for months, and there's only a handful anyways.\n. @jonathanong i think @stephenmathieson ways saying he uses bitbucket so he can have lots of free private repos. makes sense, especially if you want to follow component's super-modular conventions but don't have a few hundred dollars a month to spend on github\n. oh haha, sorry yeah i see now\n. ",
    "anttikissa": "I was just about to fix the same thing when I saw the pull request. I'd be happy to see this merged in the interest of newbie-friendliness.\n. ",
    "CoryG89": "That's the simplest change that made it work right for me.\n. No problem. After looking at it this morning though.. as far as I can tell it is now causing the default GitHub remote to be added to component.json; causing duplicates with multiple calls to component install. This is because before my pull request saveConfig was called before the default remote as was added. Also as far as I can tell, since we're using end event for each package to write the file, the forEach loop is unneeded now. pkg.version gets set to master so there is check performed to change it to * I added commits to fix both of these problems and I read the file over to make sure it wasn't breaking anything else. As far as I can tell everything is right now.\n. ",
    "urban": "My application had a sub-project that was a browser bookmarklet. At the time I wanted to utilize the same components directory for both because they shared the same 3rd party dependencies. Since then, I've changed my  file structure, build process and my opinion on this feature. I think a simple CLI is better so I'm going to delete my +1 comment above.\n. ",
    "daslicht": "Found a solution here : https://github.com/isaacs/npm/issues/3433\n. ",
    "v13inc": "I wasn't able to track down exactly what was causing this issue, unfortunately (I think it might be superagent or component passing an invalid default port to the Node HTTP libs).\nFortunately, adding \"https://raw.github.com:443\" to my remotes in component.json seemed to fix the issue for me.\n. ",
    "shallker-wang": "thanks. Now I should move all my dev tools from \"development\" to \"dependencies\", when I want to build a production then reverse them back to \"development\" and build. Guess this is the workflow in current version of component.\n. ",
    "MAK-Jr": "Okay, add /usr/local/share/npm/bin to PATH solve it.\n. ",
    "yorkie": "it still seems to be not working until now, curl for my github returns the correct component.json, but component install returns 404 responses for dependencies.\n```\n$ component --version\n\n0.19.9\n``\n. Yeah, i use netrc,curl` works well with netrc.\n. \n",
    "milaniliev": "I love writing docs, and am having a little trouble getting started myself.\nI opened a separate issue (https://github.com/component/component/issues/435) before seeing this one, but basically I would love to write up a better documentation flow if @visionmedia & co. are up for it.\n. +1 for out-of-the-box private repos. I'm onboard to help, too.\n. ",
    "gnimmelf": "Would be nice to see an example of a more complex private component with server-side stuff. Would it be wise to make a mountable component (express.use), like a signup component? Atm, it looks wise to me to do this to be able to bundle server-side JSON models and validations? Examples, examples =)\n. Bump. npm update component gave 0.19.9 and nothing gets buildt.\n. ",
    "airportyh": "https://github.com/component/component/pull/466 fixes this, please review.\n. Closing as dup of #405.\n. Syntax error checking can actually be done fast w/o using Esprima - by executing the script and then checking if a syntax error was thrown, see syntax-error. This is what's being done in browserify, and is indeed fast (I've some experience doing perf tuning in browserify recently). I can put in some benchmarks to prove it if needed. I think this is a nice improvement in UX w/o performance penalty.\n@visionmedia so new development should be done on 0.10.x branch? are there plans to upgrade component to the latest of builder?\n. I just check in all my dependencies, which gets around this issue.\n. ",
    "mikach": "See pull #410 \n. ",
    "kaheglar": "Sure thing.\n. ",
    "DomiR": "Thanks, i misunderstood the building process... it's actually concatenating the whole scripts... \n. ",
    "Eirik81": "This is not working for me. I'm using the latest component version (0.19.5). I have tested using several components and it never works. For instance using the lodash/lodash component:\nFirst I installed lodash 2.3.0 by specifying \"lodash/lodash\": \"2.3.0\" as a dependency in my component.json file.\nNext I tried to install a newer version by changing the dependeny to \"lodash/lodash\": \"2.4.1\"\nRunning component install -v gave this result:\ninstall : lodash/lodash@2.4.1\nexists : lodash/lodash@2.4.1\nBut the lodash version that is installed is still 2.3.0.\n. ",
    "jh3y": "Was this added then? or does it need to be added? \nI guess the only issue with this feature is not many people know the URL of their component demo before they create it. Would it be best that the standard Readme that is created simply contains a demo section to be filled out?\nI guess the goal of this is just to make sure people supply some form of demo if they want their component to be used by others.\n@jheytompkins\n. So just to clarify then. If I add demo field to component.json. This will get added in to the search results?\n. Cool thanks.\nWould just be nice to ensure people remember to have a demo available for their UI element components.\nI'll close this up. Thanks again.\n@jheytompkins\n. That is a fair point and you are certainly right that it's not hard to simply use an editor to get up and running. But a little script can save you from typing anything and I guess it gives almost like a boilerplate to people who haven't written components before and may be deterred and resort to popular frameworks such as jQuery.\n. Thanks for the response :)\n@jheytompkins\n. ",
    "alekseykulikov": "I have some ideas which can be interesting for this topic.\nC8 https://github.com/gingkoapp/c8 is an experimental component build server. It allows you to publish and then get builded version back with simple urls (see examples).\nMy favourite feature, and the reason why I created it is concatenation. It allows you to get concatenated & minified version of components group with one request. For example we want to get specific build of amazing UI components by @yields:\n- js files: https://c8.gingkoapp.com/concat.js?repos=yields/select,yields/sortable,yields/editable,yields/select-reflect\n- css files: https://c8.gingkoapp.com/concat.css?repos=yields/select,yields/sortable,yields/editable,yields/select-reflect\nIt's similar with idea of http 2.0, when you do a lot of request and get only one response. In current state of http we only can emulate this behaviour. concat basically makes a composable stream for a group of files.\nNice feature of future component's require(in future es6 modules?), could be detecting modules, making request to c8 server, and loading what app requires. So you can start prototype your app immediately and load only necessary components (not one giant js/css file) on demand. It will especially useful for SPA.\nI know, that component does not have plans to have registry ;)\nThat's my idea. Thoughts?\n. Hi @visionmedia, yeah, I really like to use github in this way. Let me share another one idea: web-hooh + travis-ci like interface.\nImprove component.io with ability to authenticate through Github. On site, you see all your repos and just check components (same logic as travis-ci). It adds web-hook to your repo, and on every push it does something. It will help us avoid of using wiki (annoying process, and I bet we miss a lot of cool components), because component.json already has name/repo/description/keywords. And simplify \u201ccomponent publish\u201d to one click, which you do only once.  \nAlso, we can use this server for anonymous stat on install, see ratings, second registry(github first), show outdated components, search, visualise dependencies graph, and etc. And it can be good \"teach component(1)\" open-source example and great move for community.\n. wow, a lot of big cool things coming! I have some ideas, and considerations.\nes6 modules\n@visionmedia could you share your idea related with ES6 modules? Will it transpile to commonjs? Will this syntax analysis affect too amazing build performance which I so appreciate?\nrebrand, c8\nLocally I use alias c8=\u2018component\u2019, maybe component is a good name, but it's too long for terminal. If eventually you will like this name, I'm ready to free https://npmjs.org/package/c8. \npublish magic.\nPersonally I don't like magic. Maybe:\n- component publish do some analysis similar to brew doctor and give improvement suggestions?\n- instead of auto-prefixing on publish, maybe we can smoothly integrate with rework. And have var, auto-prefixes and another cool css stuffs.\n. That will amazing!\n. I'm ready to help too!\nAgreed, registry-side transformations requires more considerations. I posted some ideas at #423\n. I can confirm that user:pass works.\n\"remotes\": [\n    \"https://user:pass@raw.github.com\"\n]\nMake sure that this user has access to selected repo.\n. ",
    "dncrews": "Thanks @jonathanong. Renamed.\n. @jonathanong, it's no longer necessary, but won't break if they use both.\n. @visionmedia, I agree that it could be considered edge-casey, but I've come across it enough times to submit a PR for it.\nI could write a script for it, but it feels really kludgy to have to wrap it in a closure just to inject a non-object exports and a non-function define. I'd rather not have to build the file standalone and then modify it to make the script ACTUALLY stand-alone.\n. This is for my components, for use in different apps (those that have an export / define). I ended up writing an alternate builder, but it's non-ideal.\n. And will there be any way to opt out of it?\n. (what this PR was for)\n. I understand. I just needed to be able to opt out of require. I ended up writing something else to do it, so I didn't have to do it manually. It's non-ideal, but if the library can't do it, I have to.\n. ",
    "nomilous": "perhaps a specially tagged tweet can activate the publish / versioning updater on the backend / backends\n. ok, facebook then... :----)\n. ",
    "darsain": "How about a travis-ci style administration?\nYou log in with github. In your profile you'll get a list of repos you have commit rights for. Each repo will have buttons next to it:\n- Publish - publish repo as a component (morphs to Unpublish)\n- Attach hooks - attaches service hooks (morphs to Detach hooks)\nAlso how to handle repository name / github username changes? This and Unpublish button need attention too. Lets not risk silly things like Bower's issue 120 :)\n. I'm working on an app that has a lot of proprietary stuff scattered into libs. I'm currently maintaining a component.json:scripts array around 20 items big - adding/removing files as I work on it.\nNeedles to say, this process is extremely annoying. @jonathanong gave me hope on irc when he showed me the new globs he was working on, and I almost fainted by thinking that the whole array could be replaced by a single lib/*.js glob. I beg you on my knees, don't take it away :'(\n. @MatthewMueller the readme looks nice! A few questions :)\n1. Can you try/catch require calls? finally? please??\n2. If you can't try/catch, how do you consume development dependencies?\nAlso a feature I always wanted in component: I'd love build to somehow set environment flags & properties so I can check for env.development environment, or set stuff like env.apiurl ...\nI also don't mind listening to reasons why I'm retarded and how to do things in a better way :)\n. Seeing as component is being deprecated, but component spec is still used by duo, webpack, and maybe others, wouldn't it be a good idea to use component.io for description of a spec (similar to json.org), along with component discovery? That way other tools like the ones mentioned would be able to just point to this to specify how to create & find components.\nAnd component discovery could use some upgrade. Instead of relying on one huge wiki page that none really edits, search and list all github repos with component.json in the root. Is this doable?\n. ",
    "seanhess": "So the correct way to do this would be to add both the javascript and typescript files to the scripts array, then users can use a plugin if they want to read them, or they can ignore them?\nThose plugins seem to conflict with the spec on the wiki. \n. I'm sorry, but I'm still a little confused. Let's say I have two Typescript\nmodules: one.ts and two.ts. You're saying I should do this right?\n\"scripts\": [\"one.js\", \"two.js\"]\nThat doesn't solve my problem, because from my application I need to be\nable to include the typescript files, but I have no idea of knowing where\nthey are.\nOn Sat, Nov 9, 2013 at 9:34 AM, Qiming zhao notifications@github.comwrote:\n\nJust add javascript to the scripts array as component would only grab\njavascript files, but users could find the source code by visit your github\nrepository.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/432#issuecomment-28130878\n.\n. Right, I would like to discuss some way to change the component spec such that it would be possible to grab the typescript files. I'm happy to write some code to do it, but I want to hammer out the spec in a way that the creators agree with and that doesn't conflict with component's design goals. \n\nWhat if we make it possible to add compiler-specific fields to the spec? This way I could write a plugin that reads it when someone has a typescript project, but component would ignore it by default, and regular javascript users would still get the compiled code?\n\"typescript\":[\"one.ts\", \"two.ts\"],\n\"scripts\":[\"one.js\", \"two.js\"],\nOr what do you recommend?\n. @yields That could work. It is possible today to write a plugin that scans the files array for .ts files and puts them somewhere useful, correct?\n. Both. I would like to add the compiled js files so anyone can use them. But\nanyone who uses a typescript project could take advantage of the types too.\nSo I would like to do what you say: include the compiled JavaScript files\nso it can be used by anyone, but additionally specify the typescript files\nfor TS users.\nOn Thursday, November 14, 2013, Jonathan Ong wrote:\n\n@seanhess https://github.com/seanhess are you making public components\nfor others to consume, or are these for yourself? if they're public\ncomponents, no one's going to use them. if you're consuming it yourself, i\nwould just save the TS files as .js and add a compilation step to my\nbuild step. i assume that would work since TS is a superset of JS. i do the\nsame with my CSS files (reworking and auto prefixing the build files).\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/432#issuecomment-28465735\n.\n. \n",
    "BardurArantsson": "For this, the \"--declarations\" option to the TypeScript compiler should probably be used, ISTM that this is exactly what it's meant for. (Though I have no idea how well that would actually work in practice given the module situation in TypeScript.)\nThen you would include the compiled js (for non-TS users) and the .d.ts file (for TS users) separately.\n. ",
    "jmarca": "Well, the problem is that write uses exists = fs.existsSync; so it is a little hard to pass a regex to that I think.\nI'd keep it in write() though, so that any new file gets checked \nsomething like \nvar p = require('path')\nfunction write(path,str){\n  var basename = p.basename(path,path.extname(path))\n  var dirname = p.dirname(path)\n  fs.readdirSync(dirname,function(err,files){\n     // some clever check.  my brain dead take:\n     var regex = new RegExp(basename,'i')\n     var haveone = files.some(function(f){\n         return regex.test(f)\n     })\n     if(!haveone){\n         //write away\n     }\n  })\n}\n. On Wed, Nov 13, 2013 at 10:54:03PM -0800, Tim Oxley wrote:\n\nreaddirSync doesn't take a callback :)\n\noh, oops.  I told you I was going fast and was brain-dead at that time\nof night!  \n\nThis message has been scanned for viruses and\ndangerous content by MailScanner, and is\nbelieved to be clean.\n. ",
    "rogerz": "The file was named 20%.png. % should be escaped as %25\nYou can get the image from Github with escaped url: https://raw.github.com/rogerz/d3-cloud-for-angular/d3221b5e2e0d6fe8864e0c48de14cabf5674be1e/images/20%25.png\n. BTW: the directory browse page in Github escape the file name correctly. See\n\n. Since there is an easy work around for this, I think we can close the issue now.\n. ",
    "regular": "once the two build steps are separated with the command line option, you could use make to do the mtime-dependent build for you.\nso: +1 \n. Since css and js files are generated by default, --no-css and --no-javascript options probably would be more intuitive.\n. My point is compatibility to the current semantics: if you do not specify any flag, both, JS and CSS are being generated. So the semantics of the --css flag for example would actually be: do not generate the JS. Thus imo, it may be less confusing if we explicitly say in the flag\u2019s name what it is doing: suppressing output. \nOn 12 Mar 2014, at 16:50, William Casarin notifications@github.com wrote:\n\nThe point of those flags is to select a specific target to build, \n--no-{css,js} is in a negative form and only makes that process more \nconfusing. \nOn Mar 12, 2014 8:05 AM, \"Jan B\u00f6lsche\" notifications@github.com wrote: \n\nSince css and js files are generated by default, --no-css and \n--no-javascript options probably would be more intuitive. \n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/pull/445#issuecomment-37418901 \n. \n\u2014\nReply to this email directly or view it on GitHub.\n. How about using git fetch to update the proxy's cache and then libgit2 bindings to find out about tags etc.? I had an email conversation six month ago about frequent problems with raw.github.com and their reply basically was: please don't use it, use git clone instead, we have much more server capacity to support the git clone use case. So I would guess there is no rate limit at all on git fetch.\n. \n\n",
    "mnichols": "Installs deps from development config.\nOn Dec 29, 2013 5:30 PM, \"Jonathan Ong\" notifications@github.com wrote:\n\nwhat specific issue does this solve?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/component/component/pull/446#issuecomment-31329375\n.\n. \n",
    "lepture": "@visionmedia @ronkorving I don't think it is a good idea to follow the redirects in this case. As you can see, the project name is changed, and in this case, we should break the installation, and show a message of rename proposal.\n. This is a little off topic, but builder.js and installer.js have different code styles.\nIn builder.js:\nfunction(){\n}\nbut in installer.js\nfunction () {\n}\n. @yields My fault! I shouldn't bring this up.\nActually, I prefer\nfunction() {}\nNo white space after function, but white space before {.\nBut, my point here is that, since all other component projects use function(){}, I think installer.js should be the same.\n. Also, COMPONENT_PATH can be used by component-link.\n$ component link lepture/caret\nThis command will create a symbol link from $COMPONENT_PATH/lepture/care to components/lepture-caret.\n. @jonathanong sorry, didn't notice that spec is a standalone repo now.\n. ",
    "lvivier": "@MatthewMueller :beers: thanks for the 0.19 support!\n. ",
    "csnover": "The description on this PR is not really clear.\nThe AMD specification states the following:\n\nIf the dependencies argument is omitted, the module loader MAY choose to scan the factory function for dependencies in the form of require statements (literally in the form of require(\"module-id\")).\n\nBecause component currently excludes the dependencies argument in its call to AMD define, and because component uses the identifier \"require\" for the factory, AMD loaders implementing CommonJS wrapping will attempt to attempt to fetch whatever is defined as conf.name as an AMD dependency. This will either cause a load failure (if the module has been renamed) or it will cause a circular dependency (since the loader will see the module as depending upon itself).\nAMD loaders that do not implement CommonJS wrapping will simply fail outright since the call signature that component is currently using is the CJS wrapper signature.\nIn all cases, the current code is not correct and only \u201chappens\u201d to work, some of the time, only ever for modules that assign properties to the precreated exports object. This pull request adds an empty set of dependencies so that the AMD loader never tries to scan the factory, and so loaders that do not implement the optional CJS wrapper will work.\n. It\u2019d be swell if this one-line fix could be landed. If there is something more you need, please let me know.\n. @jonathanong I linked to the AMD specification above. Is there something more specific you are looking for that I can provide for you?\n. The dependencies argument is required because without it the factory is scanned for dependencies literally in the form of require(\"module-id\") and then the AMD loader tries to load the dependency \"module-id\" before executing the factory. You use the identifier require inside factory functions created by component, therefore the AMD loader tries to load dependencies that aren\u2019t actually AMD dependencies but are, in fact, you making internal calls to your own special require function. If you add the dependencies argument, as per the part of the spec I quoted, it will no longer scan the factory and things work correctly.\n. @jonathanong OK, I did it at https://github.com/umdjs/umd/pull/34 but I am not clear how doing that has relevance to this PR?\n. @jonathanong Hoop jumping achievement completed. Could you please land this now? Thank you.\n. ",
    "jason0x43": "chaijs/chai#225 (linking)\n. ",
    "blossk": "2014/1/9 Qiming zhao notifications@github.com\n\nhttp://tjholowaychuk.com no longer hold the articles\nYou can merge this Pull Request by running\ngit pull https://github.com/chemzqm/component patch-1\nOr view, comment on, or merge it at:\nhttps://github.com/component/component/pull/463\nCommit Summary\n- update articles link\nFile Changes\n- M Readme.mdhttps://github.com/component/component/pull/463/files#diff-0(4)\nPatch Links:\n- https://github.com/component/component/pull/463.patch\n- https://github.com/component/component/pull/463.diff\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/pull/463\n.\n\n\nDiligence Express\n\u00f3 \u00d5\u00d7\u00c1\u00d6\u00c5\u00ce\u00c9\u00c5\u00cd, \u00e1\u00cc\u00c9\u00c8\u00c1\u00ce\u00cf\u00d7 \u00e6\u00c9\u00cc\u00c9\u00d0\u00d0\n\u00d4\u00c5\u00cc.:(812)4016740 \u00c4\u00cf\u00c2. 104\n\u00cd\u00cf\u00c2.:8911-158-6883\n\u00c6\u00c1\u00cb\u00d3: (812)4959036\n\u00e2\u00d9\u00d3\u00d4\u00d2\u00c5\u00c5 \u00d0\u00cf\u00de\u00d4\u00cf\u00d7\u00d9\u00c8 \u00c7\u00cf\u00cc\u00d5\u00c2\u00c5\u00ca!\n. I just bring you back your items\n\u00de\u00c5\u00d4\u00d7\u00c5\u00d2\u00c7, 9 \u00d1\u00ce\u00d7\u00c1\u00d2\u00d1 2014 \u00c7. \u00d0\u00cf\u00cc\u00d8\u00da\u00cf\u00d7\u00c1\u00d4\u00c5\u00cc\u00d8 Qiming zhao \u00d0\u00c9\u00d3\u00c1\u00cc:\n\nhttp://tjholowaychuk.com no longer hold the articles\nYou can merge this Pull Request by running\ngit pull https://github.com/chemzqm/component patch-1\nOr view, comment on, or merge it at:\nhttps://github.com/component/component/pull/463\nCommit Summary\n- update articles link\nFile Changes\n- M Readme.mdhttps://github.com/component/component/pull/463/files#diff-0(4)\nPatch Links:\n- https://github.com/component/component/pull/463.patch\n- https://github.com/component/component/pull/463.diff\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/pull/463\n.\n\n\nDiligence Express\n\u00f3 \u00d5\u00d7\u00c1\u00d6\u00c5\u00ce\u00c9\u00c5\u00cd, \u00e1\u00cc\u00c9\u00c8\u00c1\u00ce\u00cf\u00d7 \u00e6\u00c9\u00cc\u00c9\u00d0\u00d0\n\u00d4\u00c5\u00cc.:(812)4016740 \u00c4\u00cf\u00c2. 104\n\u00cd\u00cf\u00c2.:8911-158-6883\n\u00c6\u00c1\u00cb\u00d3: (812)4959036\n\u00e2\u00d9\u00d3\u00d4\u00d2\u00c5\u00c5 \u00d0\u00cf\u00de\u00d4\u00cf\u00d7\u00d9\u00c8 \u00c7\u00cf\u00cc\u00d5\u00c2\u00c5\u00ca!\n. Is he ok?\n\u00de\u00c5\u00d4\u00d7\u00c5\u00d2\u00c7, 9 \u00d1\u00ce\u00d7\u00c1\u00d2\u00d1 2014 \u00c7. \u00d0\u00cf\u00cc\u00d8\u00da\u00cf\u00d7\u00c1\u00d4\u00c5\u00cc\u00d8 Ian Storm Taylor \u00d0\u00c9\u00d3\u00c1\u00cc:\n\ndamn, sick photograph tj\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/pull/463#issuecomment-31959072\n.\n\n\nDiligence Express\n\u00f3 \u00d5\u00d7\u00c1\u00d6\u00c5\u00ce\u00c9\u00c5\u00cd, \u00e1\u00cc\u00c9\u00c8\u00c1\u00ce\u00cf\u00d7 \u00e6\u00c9\u00cc\u00c9\u00d0\u00d0\n\u00d4\u00c5\u00cc.:(812)4016740 \u00c4\u00cf\u00c2. 104\n\u00cd\u00cf\u00c2.:8911-158-6883\n\u00c6\u00c1\u00cb\u00d3: (812)4959036\n\u00e2\u00d9\u00d3\u00d4\u00d2\u00c5\u00c5 \u00d0\u00cf\u00de\u00d4\u00cf\u00d7\u00d9\u00c8 \u00c7\u00cf\u00cc\u00d5\u00c2\u00c5\u00ca!\n. ",
    "azhang": "Thanks a lot for the quick response!\n. ",
    "kof": "I have created this and now I realize its actually wrong place to fix it https://github.com/kof/node-xpkg\n. there are a number of properties which are component specific and can be placed in overlay namespace. Name, version, description etc ist mostly the same, but even if not - override it in overlay specific definition. \nWhats the problem?\n. Inelegant? So having package.json, bower.json, component.json and bla.jquery.json is better?\nEvery time you need to update version in all of them.\nMost properties are the same. Name, version, autor, description, keywords, license, scripts, main, repository ... \n. Yes, another way could be to read such stuff like version, author, description, keywords, license, repository from the package.json if its not defined in component.json!\n. I would not bug you if it were 2 ... but its currently 4 ... and every next one will go the same way like you ...\n. Small unimportant trivial thing, but its irritating ... :)\n. ",
    "dshimkoski": "@gjohnson You look familiar. Don't I know you from somewhere? Nyuk nyuk nyuk!\nI've written a build system on top of component-builder that includes this, so it's not really a matter of support for me. I was just wondering if it should be in the spec in some form or fashion.\nI like the idea of having a type field. Feels much cleaner. I'd prefer type: 'global' over type: 'standalone' though, since it says something about the scope and format of the code.\n. ",
    "matchdav": "The problem with multiple builds is that the last build clobbers the other builds.  yields' answer makes the most sense, I'll test that.\n. Why would I do multiple builds repackaging everything all over again, if I can just define a new module below the global build that knows about all the common dependencies?\n. javascript\nrequire.register('rabbit',function(exports){\n    exports.name = \"roger\";\n});\nrequire.register('ferret',function(exports){\n    exports.name = \"tobi\";\n});\nWorks great.  Thanks.\n. Hmm, why would you do that?   It's a really useful capability to have.\n. Yeah it's not so much about being tied to a particular singleton module like \"app\" or \"site\".  It's more that I want a library loader and a set of common modules to carry across all pages (say in my layout.jade file)\nAnd then, let's say on some other page I have a really rich GUI, and I want the benefits of using require, but don't want to have to write a bundler that does a bunch of bookkeeping if I want to add a new feature to this page but not another page.  Especially if I do have to used the accursed mothership jQuery or Backbone, do I really want to have to rebundle and rebundle and rebuild and rebuild multiple instances on different pages, not so much.  I want to write apps not stupid Gruntfiles.\n. ",
    "lydell": "Ah, thanks, didn\u2019t know about that. Now that I do, I found a related issue: component/spec#42\n. ",
    "thehydroimpulse": "@netpoetica You shouldn't have to touch the components directory at all. When you build a component (with dependencies), those dependencies will be packaged up into a single build.js file, which you can then run minifications on that single file. \nI typically have a gulp/make task to take the build.js,build.css files and minify them as needed. The components and build directives untouched all the way.\nAlso, I should point out that it's probably best to minify at the highest-level. For example, you shouldn't minify components that are dependencies of other components. You should minify the highest-level of components.\nHope that helps.\n. @netpoetica So you have something like this?\nsrc # Front-end stuff here\ncomponent.json\ncomponents/ # You hate this being here?\nbuild/\n* # Other stuff not related to front-end here\n. @netpoetica \nI'm also assuming you're ignoring both the build (component's build dir) and components from git? I also personally hide them from within my text editor.\nI'm personally one to love having a super clean directory structure. Components is truly best when using them as first-class resources. Typically, in something like rails or other frameworks, the client-side JavaScript get hidden within a slew of directories app/assets/javascripts/src/. Which I think is awful.\nI personally really love this style:\nclient/\n  component.json\n  index.js\n  users # Example local component\n  task # Another local component\n  - components/ # Hidden\n  - build/ # Hidden. This is the highest-level build\nserver/ # If you have server components.\ngulpfile.js # Handles building and watching components as they change. Also has tasks to minify them.\nBecause the components/ folder is completely hidden, it doesn't really matter where it's at. It only matters to the component builder. Each local component (if building them separately/in isolation) could have it's own build/ and components/ directories, which are also hidden.\nLike Lance said, it's pretty much the same as Node's node_modules folder, which should be used as a throwaway folder (i.e., at anytime, you can delete it and rebuild it's contents.)\n. ",
    "u9520107": "regarding bundling... is there a way for 2 separate builds to share the same components directory?\nsay i have \nlib/\n    module1/\n        component.json\n    module2/\n        component.json\nAnd they share some remote dependencies. It seems like a good idea to be able to specify a shared installed folder for them instead of having 2 separate copies of the dependencies.\n. ",
    "bjornstar": "force is horribly broken and exceptionally dangerous to use. It will install multiple versions of the same component into the same folder simultaneously. I am definitely in favor of removing it.\n. ",
    "mciparelli": "I think this kind of practices would be rather cool to have them in a Wiki.\nSay:\nTo remove a component just do rm -rf component/{component-name}\nand the same for every of these features that have been removed so everyone who was using those can understand how to achieve the same with one or two simple command line commands.\n. done!\nOn Tue, Apr 1, 2014 at 10:15 PM, Jonathan Ong notifications@github.comwrote:\n\n+1 can you open an issue in http://github.com/component/guidehttps://github.com/component/guideplease?\n\nReply to this email directly or view it on GitHubhttps://github.com/component/component/issues/490#issuecomment-39279659\n.\n. \n",
    "bredele": "thanks @jonathanong.\n. ",
    "codeactual": "I'd really appreciate this enhancement. Please let me know if I can help test.\nRe: link and shrinkwrap, I'd personally be okay with those caveats. \n. ",
    "simonsmith": "Some oddness. I'm back at home now and it's working. The problems earlier were at work. However the first time I tried it at home today it failed like before, then the second time and all subsequent times it has been working fine.\nI will try again when I'm at my other machine tomorrow, and will also try an older version as requested\n. Hmm, still seeing this issue at work. Even with node 0.11.\nCould a proxy interfere with this? I am behind one here but I can access the URLs in my browser just fine. \nTrying install -p throws:\nerror : \"www-cache.myworkdomain.co.uk\" is not a valid dependency\nEdit - So it does seem proxy related here. Apologies if I've raised false positives. Strange that I can't get the -p flag to work though\n. @jonathanong I get the feeling that the proxy is being treated as a dependency somehow. Example:\n```\nsimonsmith@Simons-MacBook-Pro:~/Sites/component-test $ component install -p http://webproxy.net\n   error : \"http://webproxy.net\" is in invalid dependency name. Please check \"/Users/simonsmith/Sites/component-test/component.json\".\n\n```\nUnless I'm using that wrong?\n. I'm also getting this error when trying to follow the simple example on the Getting Started page:\nsmiths100@mc-s710119:~/Desktop/component $ DEBUG=remotes* component build\n  remotes:local checking local components at /Users/smiths100/Desktop/component/components +0ms\n  remotes:local resolving local remote +16ms\n  remotes:local checking folder: /Users/smiths100/Desktop/component/components/necolas/normalize.css +0ms\n  remotes:github GET \"https://raw.githubusercontent.com/necolas/normalize.css/master/component.json\" +0ms\n  remotes:github error when GETing \"https://raw.githubusercontent.com/necolas/normalize.css/master/component.json\": \"timeout of 5000ms exceeded for \"https://raw.githubusercontent.com/necolas/normalize.css/master/component.json\" +5s\n  remotes:github GET \"https://raw.github.com/necolas/normalize.css/master/component.json\" +0ms\n  remotes:github error when GETing \"https://raw.github.com/necolas/normalize.css/master/component.json\": \"timeout of 5000ms exceeded for \"https://raw.github.com/necolas/normalize.css/master/component.json\" +5s\n  remotes:github GET \"https://raw.githubusercontent.com/necolas/normalize.css/master/component.json\" +0ms\n  remotes:github error when GETing \"https://raw.githubusercontent.com/necolas/normalize.css/master/component.json\": \"timeout of 5000ms exceeded for \"https://raw.githubusercontent.com/necolas/normalize.css/master/component.json\" +5s\n  remotes:github GET \"https://raw.github.com/necolas/normalize.css/master/component.json\" +0ms\n  remotes:github error when GETing \"https://raw.github.com/necolas/normalize.css/master/component.json\": \"timeout of 5000ms exceeded for \"https://raw.github.com/necolas/normalize.css/master/component.json\" +5s\nUsing the following component.json\n{\n  \"name\": \"getting-started-with-component\",\n  \"dependencies\": {\n    \"necolas/normalize.css\": \"^3.0.0\"\n  },\n  \"scripts\": [\"index.js\"],\n  \"styles\": [\"index.css\"]\n}\nI am able to access https://raw.githubusercontent.com/necolas/normalize.css/master/component.json just fine in my browser\nHave also tried master instead of ^3.0.0 but no joy\n. Here it is: http://pastebin.com/YGqgyb8C\nI didn't see any credentials in there?\n. Logs here - https://gist.github.com/simonsmith/10501679 Showing the difference when I have no components installed vs when they are already installed.\nI don't get an error as such just that sometimes the file is built out of order and my unit tests fail. So far it happens every time when the components have to be installed. After they have been installed the tests pass 90% of the time. \nEdit: I should probably do a similar test with the component CLI, just to clarify if it's my code.\n. @jonathanong I set up a similar test but instead used the component CLI. Running this command passed the test every time regardless of installing components or them being there already.\nCould I be using the libraries incorrectly? I've tried to follow the docs as closely as possible.\n. Hmm okay. I'll go back to stepping through the code and see if I can spot anything obvious. Thanks for casting your eyes over it :)\n. ",
    "rarkins": "FYI I get this same error when testing on codeship.io\n. @dominicbarnes yes it's a continuous integration provider using AWS infrastructure. We use vagrant/VirtualBox in development and never had a problem though \n. We don't see the problem in deV actually - only in the hosted test env and it takes a few retries to pass. Hopefully it's transient but we need a way to increase resilience. \n. @dominicbarnes we're using your component-builder, example like below (heavily abbreviated):\nvar build = require('component-builder');\n...\nbuild.scripts(self.tree,options)\n      .use('scripts', build.plugins.js())\n      .use('json', build.plugins.string())\n      .use('jade', jade({string:true}))\n      .end(function(err,js){\n        js=build.scripts.umd(self.tree.name,self.tree.name,js)\n        js=minify.js(js);\n    }\nIs it just a matter of adding to that existing options?\n. So should I pass the retries parameter to only resolver, or both resolver and builder?\n. Repeated 5000ms timeouts from githubusercontent.com when using codeship.io have brought our workflow to an almost halt. Does GitHub \"punish\" hosts with rate limiting for making too many requests?\n. ",
    "vmariano": "Hi. I had the similar issues (timeout), when the internet has micro cuts/ high ping, or simply works slow.(my 3 world connection sucks).\nI think the main problem, is on to the github api with slow connections, because I have  reject commits and fails in to synchronization.\n. No for the moment, but I will create some one.\n. Thx @timaschew  I will take a look.\n. Sorry for the delay, I was working in other issues with more close deadlines. I think I can can close and if i had other issue will be back.\nThanks a lot guys.\n. ",
    "intoxicated": "Or maybe someone needs to up date README. I think there's also incorrect installation for OS X.\n. Actually the way I installed was following: install node js from pkg (latest), and then do npm install -g component. Apparently  installing component with 0.8.x node js didn't work \n. ",
    "wryk": "i actually use component serve with a livereload plugin on my code editor\nwhy not just run a livereload server (https://github.com/mklabs/tiny-lr ?) under a flag on component build ?\na livereload browser plugin is a common tool for a front developer\n. a dateline is scheduled for 1.1.0 ? \nI want to take care of this feature :\u00b0\n. -r, --reload as flag ? ($ component build --watch --reload)\n. #406, v-prefixed tag hell ? :)\n. I'm using win7 with component 1-rc5, i got the same error when a local component name (directory name) starts with 'u'. Awkward unicode prefix uh uh :3\n. actually, I can't reproduce this issue :<\n- windows 8\n- node 0.11.13\n- component 1.0.0-rc5\n``` javascript\n// now\nrequire.register(\"./local-components/util\", [...]) // fine\n// before (tested on april)\nrequire.register(\"./local-components\\util\", [...]) // unicode error\n```\n. actually --reload need an explicit --watch, should i make an implicit --watch on --reload ?\n. wow, @Nami-Doc in component organization, nice :3\nfirst travis failure is my fault, but now it's just a malformed json from bitbucket on component install\n. i forget that pull request i rebuild and now travis pass, others things to add ?\n. I'll add a note in component/guide api.md file tonight\n. > tonigth\nah ah ah ah :<\ncomponent/guide@c55b9a4\n. File names should be lower-cased, and hyphenated when multiple words are used. (cf. wiki: old / new)\nAnd I guess you should not require a file below your root component folder, like paths for locals.\nIt's weird IMHO.\n. take a look at https://github.com/component/create.js\n. You should use 1.x for semver support\n. +1 for doesn't interrupt --watch, it's pretty annoying\n. Without that command, open dependency is no longer needed, right ?\n. wow, 12k ms, it's weird :O\n. component/guide@31c3d77\n. Duo install works fine for me with npm@1.4.9 and duo@0.5.4\n. @MatthewMueller @yields \nMe too, I really love component and I wonder a lot about his future\nDuo looks like a next version for component (mix from component@0.9 and browserify ?).\nThankfully, it seems backwards compatible  (I hope so much)\n. yay, component going forward ! motivation growing\n. wonderful ! :+1: \n. ",
    "andyburke": "I've tried this in my component.json:\n\"es-shims/es5-shim\": \"v2.3.0\",\nI still get:\nerror : Error: no remote found for dependency \"es-shims/es5-shim@v2.3.0\".\n. Ok, so now I set it to master in my component.json, but the solution to this was not at all obvious. I don't think this issue should be closed yet.\nI had originally had the version set to \"*\" and was seeing this error. There was no information in the error to give me a hint about what to do or why this was happening.\nIt would have been helpful if the error said something about the component.json not existing at the specified URL (and print the URL), that would have given me a much better chance to understand what was going on.\nFor example, this would have been a much more helpful error message:\n```\nerror : Error: no remote found for dependency \"es-shims/es5-shim@v2.3.0\": https://raw.githubusercontent.com/es-shims/es5-shim/v2.3.0/component.json does not exist.\nThis can happen if a repository is improperly tagged or currently broken. You may want to specify a known-good version in your component.json.\n```\n. I've made it further, but I've hit another one of these. Did something change internally to component that's causing this to just start happening? I updated component today. I've never encountered this before...\n. Wait, what's not possible?\nI'm asking for an improved error message. By the point you emit that error, you should know that neither https://raw.githubusercontent.com/es-shims/es5-shim/v2.3.0/component.json or https://raw.githubusercontent.com/es-shims/es5-shim/2.3.0/component.json exist.\nLetting the user know that would be a hint at why things aren't working.\n. Also, this change to component seems to make the \"*\" specification undesirable.\nPeople should just use \"master\", right? That's definitely more explicit and I'm fine with that, but maybe component should issue a warning about the \"*\" specification and how it can cause issues.\n. (I want to take a moment and just make sure the tone of these comments isn't being distorted by the internet: I'm trying to offer constructive feedback on how I think component could be improved based on an experience I had with it. These comments are meant to be taken in the friendliest terms. I'm just trying to share a much less experienced user's viewpoint. As one of the developers, you have a much better understanding of how the systems work and what may seem obvious to you is not at all obvious to me.)\nI did not understand what 'no remote found' means. I'm still not very clear on what it means. Now I'm guessing it means something like 'in the list of remotes [ 'local', 'github' ] we could not locate a component.json'.\nBut even that isn't really helpful enough for someone like me. I had no idea what URLs it might have been checking for that.\nEven doing DEBUG=component* component install ended up giving me lots of output that didn't show me any 404s that I could see.\nI think it would be great, but I realize this may not be trivial, to keep track of the locations that have been checked for a component.json, then to display them in the error. I don't think that would take any additional HTTP requests, would it? It's entirely possible I still don't understand what's happening and that it would.\nI still think the error message could be improved to offer me (an inexperienced user) more of a breadcrumb trail to start to figure out what's happening, for example, something like:\n```\nerror : Error: no component.json could be found for dependency \"es-shims/es5-shim@v2.3.0\".\nChecked:\n local ( /home/foo/thingy/components/es-shims/es5-shim@2.3.0/component.json )\n local ( /home/foo/thingy/components/es-shims/es5-shim@v2.3.0/component.json )\n github ( https://raw.githubusercontent.com/es-shims/es5-shim/2.3.0/component.json )\n github ( https://raw.githubusercontent.com/es-shims/es5-shim/v2.3.0/component.json )\nCommon causes for this include:\n  - A mistyped version spec (double-check your component.json)\n  - An improperly tagged/versioned github repository\n  ...\n```\nAn error message like this is a bit more verbose and gives me some direction on what might be happening under the hood and how I might begin to solve it, empowering me as a user.\n. That's definitely better, but I had no idea I could do that with DEBUG.\nI still believe an effort to improve the error would go a long way. Having to dig into the documentation to locate a relatively obscure DEBUG command to even start to solve the problem is pretty rough on someone who doesn't understand the guts of the system.\n. I'd be tempted to make a change to remotes.js to keep track of the checked URIs since the last resolve() call.\nThen maybe you'd be able to do something like:\nif (!remote) throw new Error('no remote found for dependency \"' + name + '@' + ref + '\".' + \"\\n\\nChecked:\\n\\n\" + this.remote.resolve_attempts.join( \"\\n\" ) );\nWould a direction like that make sense?\nIf so, I can try to find some time next week to fork and play around with this to see if I could help improve this error message.\n. Adding that would be a step in the right direction.\nWhat's undesirable about a verbose error message? Isn't it best to provide as much relevant info as possible to help someone solve the problem?\n. I agree with adding the text you're talking about.\nBut I'll also point out that the moment you commented on this issue with the URL, I was able to understand what was happening.\n. ",
    "ljharb": "for those watching, es5-shim v3.0.0 has been released - sorry for the delay :-)\n. ",
    "krainboltgreene": "Can I do anything to resolve this? Because componentjs is amazing to me and I want this to be a part of it.\n. It's exactly what I want and perfect for web components. I'm annoyed that it's not moving forward.\n. ",
    "kazupon": "You're right. :-)\n. @jonathanong \nbecase, there are cases of require manually.\nfor example, application recieve data from server-side, when page is rendering.\njs\nrequire('boot')({ foo: 'bar'});\n. ",
    "queckezz": "By default component install installs the master branch and since you don't have one it fails. This should work:\nbash\ncomponent install lhorie/mithril@gh-pages\nor in your component.json:\njson\n{\n  \"name\": \"app\",\n  \"dependencies\": {\n    \"lhorie/mithril\": \"gh-pages\"\n  }\n}\nBut I wonder why you need to distribute a github page anyway.\n. ",
    "casio": "+1 for bringing CLI plugins back\nThe way browserify was able to achieve this is really super convenient. \nAlso I think not having this option might hinder adoption quite heavily.\nDoes it make sense to just have specified --use-X middleware applied after the default stuff?\nThat should go a long way for lots of usecases. \nWhere it doesnt, people can still use the API in their own scripts, then.\n. ",
    "jonathanhefner": "I also thought the CLI option was convenient.  But I was thinking, wouldn't it be more convenient to list the build plugins in component.json?  That way you wouldn't have to bother with a shell script (or type them out each time), and they could even be downloaded / resolved the way dependencies are.\nAs for ordering and configuration options, what about the following:\n- Plugins specify a file name regex for which files / extensions they apply to.  (This could be an exported function instead of a regex if more sophisticated logic is needed.)\n- Plugins transform file names / extensions in memory in addition to file contents\n- Plugins also specify if they're a post-processor or a pre-processor, i.e. whether they require valid canonical JS/CSS/etc\n- Post-processors are applied after the default plugins, in any order(?)\n- Pre-processors are applied in any order based on the current in-memory file name, but only once per file\n- If these basic ordering constraints are insufficient (e.g. there are multiple ES6 plugins that operate on *.js but need to be applied in a specific order), a \"meta\" plugin can be created which is just a normal plugin component that delegates to other plugins in a specific order.  It could look like the simplified build script that @jonathanong mentions above.\n- If any extra configuration options are necessary, they can be specified in a hash alongside the plugin version number in the consumer project's component.json\n. Leaky as in leaky abstraction?  I suppose the non-deterministic ordering makes it that way.  But having plugins be components which can, themselves, depend on / delegate to other plugin components provides a DRY way of composing deterministic builder pipelines.  Then, being able to specify at least a root plugin (pipeline) in the manifest could give people the brevity they want.  (Said root plugin could be remote or local, allowing people to reuse existing published pipelines, or switch to customized local ones with zero friction.)\nHaving a single combined pipeline (selected over by regex), instead of separate pipelines for each asset type, also simplifies things, IMHO.\n. I've been giving some thought to how make this feature less magical / easier to reason about.  What about something like this inside component.json:\njson\n{\n  \"build\": {\n    \"myFile1.js\": [\"plugin1\", \"plugin2\", \"plugin3\"],\n    \"myFile2.js\": [\"plugin2\"],\n    \"myFile3.css\": [\"plugin7\", \"plugin8\"],\n    // etc\n  },\n  \"plugins\": {\n    \"plugin2\": { /* configuration */ },\n    \"plugin7\": { /* configuration */ }\n    // etc\n  }\n}\nThe downside of this is that, with less magic, it's duplicating build script functionality.  The upside is that it's friendlier / easier for common cases.\n. ",
    "Paulmicha": "I'm currently assessing the feasability of using Component (for me and my team) as the ONLY tool for structuring, reusing and compiling CSS across different projects (using SuitCSS, at least with Rework & minification)\nUse case : Build SuitCSS Components & custom ones with Rework + minification\nCaveat : having to use an additional custom build script every time is a potential deal breaker\nHaving no scripting for simple cases is less error-prone, less time-consuming - and of course, lowering the perceived difficulty of this tool is a critical factor of its immediate adoption.\n\"list the build plugins in component.json\"\n-> Sounds better than the now mandatory additional custom build script, +1\n. \"with a Makefile to run Myth\" -> this is an extra tool, and the people I will try to convince will probably just hear \"it works if you also use this like this and...\" and then give up.\n. \"you'll probably have some sort of build tool\" -> No : that's the whole point, I think.\nBesides, that's out of the scope of this issue - \"bringing back CLI build plugins\" (and/or \"list the build plugins in component.json\") : the simplistic use case I added to this discussion (build CSS-only components like SuitCSS with Rework & minification) is quite different than building an entire app (http://blog.kewah.com/2014/build-a-web-app-with-component/).\nI know that this perspective is perhaps a little edge-case, but I believe there is value in making possible this minimalistic use of Component, where it does this only one thing really well - so it could be used on any kind of projects.\n. ",
    "remoe": ":+1: \n. @jofan, what do you mean? You can simple import it from a different module. But this is not the way you should go :)\n. ",
    "trevorgerhardt": "Would using --debug be the same as using --verbose?\n. Along with this should we remove the rest of the --verbose flags and where verbose: true is being passed in each options object?\n. Proxy support is definitely useful. Let's punt to 1.1 for now. \n. Looks good to me\n. Auto-require is nice but I agree that it should be off by default. --auto-require seems more appropriate than --no-auto.\n. Thanks!\n. That's fine with me. Let's switch references from component.io to the gh-page and check that box off.\n. @timaschew no problems that I've ever seen, something in particular?\n. https://github.com/componentjs/guide/blob/master/component/getting-started.md shows how to use a Github token instead of username/password\n. Are those last two items in docs required for a release?\n. The build passed after I published the latest resolver.js. Time to tag rc6?\n. woohoo!\n. :+1: \n. This is an example of a smart default, I'm all for this.\n. @timaschew, I agree using * is generally bad idea, but it's ubiquitous. Using master by default if no tags are present creates less work and isn't an unexpected result. Isn't forcing tags equivalent to forcing a \"publish\" step like npm?\n. > This is all meant to improve adoption of component 1. The more rocks on the road someone meets when migrating is one more reason to drop component.\nAt this point, this is enough of a reason for me to disregard any downside of supporting a * to master fallback.\n. So implementation for this would be in resolver.js correct? Any volunteers?\n. :+1: \n. To simplify, should it just be component-* for everything?\n. ",
    "138over": "I'm using  https://github.com/timoxley/component-server \nand located in  https://github.com/timoxley/component-server directory\n{\n  \"name\": \"example\",\n  \"repo\": \"timoxley/404\",\n  \"description\": \"Example of serving local component\",\n  \"version\": \"0.0.1\",\n  \"remotes\": [\"http://localhost:3939\"],\n  \"dependencies\": {\n    \"local/object\": \"*\"\n  },\n  \"development\": {}\n}\nerror : no remote found for dependency \"local/object\".\nIf I go to my component \n{\n  \"name\": \"git-reflog-layout\",\n  \"version\": \"0.0.1\",\n  \"license\": \"MIT\",\n  \"description\": \"git reflog HTML Layout\",\n  \"dependencies\": {\n    \"component/dom\": \"*\"\n  },\n  \"development\": {},\n  \"main\": \"index.js\",\n  \"scripts\": [\n    \"index.js\"\n  ],\n  \"templates\": [\n    \"template.html\"\n  ]\n}\nI can download the dependency ok.\nIf I add an any remote... I was expecting it would default to github\n{\n  \"name\": \"git-reflog-layout\",\n  \"version\": \"0.0.1\",\n  \"license\": \"MIT\",\n  \"description\": \"git reflog HTML Layout\",\n  \"remotes\": [\"http://localhost:3939\"],\n  \"dependencies\": {\n    \"component/dom\": \"*\"\n  },\n  \"development\": {},\n  \"main\": \"index.js\",\n  \"scripts\": [\n    \"index.js\"\n  ],\n  \"templates\": [\n    \"template.html\"\n  ]\n}\nerror : no remote found for dependency \"component/dom\".\n. using this as a reference https://github.com/component/component/tree/master/test/fixtures/local \nI'm unable to get https://github.com/component/component/tree/master/test/fixtures/local/direct \nrelative paths working for dependencies \n{\n  \"name\": \"direct\",\n  \"description\": \"Local component dependency for main application\",\n  \"version\": \"0.0.1\",\n  \"dependencies\": {},\n  \"local\": [\n    \"first\",\n    \"second\"\n  ],\n  \"paths\": [\n    \"../others\"\n  ],\n  \"main\": \"index.js\",\n  \"scripts\": [\n    \"index.js\"\n  ]\n}\nWhen I try to add a dependency to git-reflog-layout like that, I get\n       error : can not require components below the root\n. Ok. that last example is in the component tree. The first example is in Tim's tree. Thanks!\n. Thanks Jonathan! What about  relative paths to component dependencies?  https://github.com/component/component/tree/master/test/fixtures/local/direct\n. Yeah -- the test are passing. I'm able to run the test ok \nit('should install dependencies through chain of local dependencies', function(done){\n  exec('cd test/fixtures/local && ../../../bin/component install', function(err, stdout){\n    if (err) return done(err);\n    done();\n  })\n})\nI must be doing something incorrect in my component. Let me poke around some more, and I'll report back on what my mistake is and it might help someone else down the road\n. dump question of  the day... what is this:\ngithub remote: only 14 requests remaining.\ngithub remote: see https://github.com/component/remotes.js/blob/master/docs/github.md for more information.\n. ok. I found out my misunderstanding when using paths and local with my git-reflog components... and misread component documentation.\nhttps://github.com/component/component/tree/master/test/fixtures/local/\nIf I run component install from ./local -- everything works as expected, all components are found and resolved. But when traversing into the ./local/direct directory and running component install... I get\nerror : can not require components below the root\nWhen I was at ./local -- everything is resolved from that directory (root - directory from where I issued component command) and thats why direct can reference ../other (./local/other)\nAnd when I change directory to ./local/direct (root) and run component install -- so it cannot reference ../other/first (./local/other/first) as it is not a subdirectory to ./local/direct, and hence the error : can not require components below the root\n. Keith, thanks for the pointers!\n. i'm learning about a number of technologies, including component.io -- and structured like this as a temp hack until i figure out what I'm going to do with local components. my local components are under ./qbal\nproject-root/...\n./index.js\n./components.json\n./components/qbal => ../qbal\n./qbal/git-reflog-widget/0.0.1/component.json\n./qbal/git-reflog-widget/0.0.1/index.js\n./qbal/git-reflog-widget/0.0.1/template.html\ncomponent.json\n{\n  \"name\": \"sde-toolkit\",\n  \"description\": \"QBAL Software Delivery Engine Toolkit\",\n  \"version\": \"0.0.1\",\n  \"dependencies\": {\n    \"component/dom\": \"*\",\n    \"qbal/git-reflog-widget\": \"0.0.1\"\n  },\n  \"main\": \"index.js\",\n  \"scripts\": [\"index.js\"]\n}\nOn Apr 28, 2014, at 11:23 AM, tjb1982 notifications@github.com wrote:\n\nSo what is the best way to require local components in a project then?\nFor example, at work I have a django project whose directory structure looks like this:\nour_project/\n    apps/\n        some_app/\n            static/\n                some_app/\n                    css/\n                    component.json\n                    index.js\n            models.py\n            views.py\n    static/\n    locals/\n        project_level_component/\n            component.json\n            index.js\nI want to keep all of my project-level locals behind my app-level components and use them with the \"locals\" property of the app-level component.json. This configuration worked prior to upgrading to v1.x by having \"../../../../static/local\" in the \"paths\" property and \"project_level_component\" in the \"locals\" property.\n\u2014\nReply to this email directly or view it on GitHub.\n. just did a quick read of package-management. nice work.\n. \n",
    "tjb1982": "So what is the best way to require local components in a project then?\nFor example, at work I have a django project whose directory structure looks like this:\nour_project/\n    apps/\n        some_app/\n            static/\n                some_app/\n                    css/\n                    component.json\n                    index.js\n            models.py\n            views.py\n    static/\n        locals/\n            project_level_component/\n                component.json\n                index.js\nI want to keep all of my project-level locals behind my app-level components and use them with the \"locals\" property of the app-level component.json. This configuration worked prior to upgrading to v1.x by having \"../../../../static/local\" in the \"paths\" property and \"project_level_component\" in the \"locals\" property. \n. Thanks! I did this in my Makefile:\nCOMPONENTS = $(shell find . -type f -name 'component.json' |sed 's/component.json//' )\n    PROJECT_DIR = $(shell pwd)\n``` bash\nCOMPONENTS = $(shell find . -type f -name 'component.json' |sed 's/component.json//' )\nPROJECT_DIR = $(shell pwd)\ninstall: sass\n    @for DIR in $(COMPONENTS) ; do \\\n      if [[ $$DIR != components && $$DIR != ./STATIC/* ]] ; then \\\n        echo \"Building component at $$DIR\" ; \\\n        cd $$DIR ;  \\\n        rm ./global ; \\\n        ln -s $(PROJECT_DIR)/lm_portal/static/local/ global ; \\\n        echo $(PROJECT_DIR) ; \\\n        component install && component build ; \\\n        rm ./global ; \\\n        cd - ; \\\n      fi ; \\\n    done ;\nclean:\n    @for DIR in $(COMPONENTS) ; do \\\n      if [[ $$DIR != components ]] ; then \\\n        cd $$DIR ; \\\n        rm -rf ./components ; \\\n        rm -f ./build/build.css ./build/build.js ; \\\n        cd - ; \\\n      fi ; \\\n    done ;\nsass:\n    @echo \"updating sass stylesheets\"; \\\n    sass --update .\nall: clean install\n.PHONY: all clean install sass\n```\n. ",
    "apla": "@netpoetica, i know, my component.json is slightly different from spec, but error is irrelevant. something must be added to the validation, because component validate gives me nothing:\nDEBUG=component* component validate\n  component-resolver remote not set - defaulting to remotes's defaults +0ms\n  component-resolver:locals resolving local at \"/Users/apla/tmp/comp-v1.0.0\" +0ms\n  component-resolver resolving \"test\" +9ms\n  component-resolver remaining dependencies: 0 +1ms\n  component-resolver remaining semver: 0 +0ms\n  component-resolver finished resolving locals +0ms\n  component-resolver finished resolving dependencies (1) +0ms\n  component-resolver finished installing dependencies +0ms\n. ",
    "graouts": "Yeah, adding the .js extension fixes the issue. My personal preference would be to not require the file extension.\n. ",
    "ryanchamp-ICE": "What did you rename your local components to? I am having the same issue... The confusing part is... what should i name my root component for this to work? In the error message, it would be nice to know what name it was expecting\n. Ok cool that's fine... I'm working with an old project that had components built with a previous version of component, and I want to add a new one (I am new to component to I just downloaded 1.0.0)... I was hoping there was a way to incorporate this new component with out updating the names of every single legacy component (since a lot of them don't match the folder name) but I guess there isn't.\nLet me see if I'm understanding this right:\nSo, for example, if I have a root folder named public with a component.json file in it, and that folder contains a bunch of other folders with for different components in it (few of which actually match the name of its folder) the error I'm getting is that the top level folder (public) doesn't match the name of it's component, when in fact there are lots of other sub-components that don't match the name it's expecting either... however the error I get is mis-leading in the fact that a) it makes it only seem like 1 component's name is not matching and b) it doesn't really communicate which one is failing if there are several...\nAlso, if the names are required to be the same as the folder, is there a way I can make it just assume that the name of the component is the name of the folder I place it in?\nI'm sorry for all the questions I'm a n00b in every sense.\n. ",
    "ivanmanetta": "https://gist.github.com/ivanmanetta/10606888\n. sure\nroot\n- client\n  - utils\n  - other components..\n- server\n. I don't have a build.js file, I have in root folder a component.json file like this:\n{\n  \"name\": \"something\",\n  \"private\": true,\n  \"paths\": [\"client\"],\n  \"locals\": [\"boot\"]\n}\nand run component build -w\n. check this please https://gist.github.com/ivanmanetta/10608572\n. yes :/\n. Windows 7 exactly, but time to linux vm, haha thanks!\n. ",
    "ukd1": "@dominicbarnes yeah we've just set that up and insta hit it again trying to build everything, it's only a 5k limit. I think we'll have to have a separate account per project which seems like a non-ideal solution.\nIt also seems a poor choice that this is not a token, but username + password.\n. These all feel like worse solutions than before 1.0.0. It just worked then, this is a step back. It's complex, insecure and breaks if you use it a lot.\nTokens (#547) would be nice.\n. That or ask @github for an exception, somehow?\n. @jonathanong the docs don't say that, also tokens don't require the username as well. Could you update the docs?\nIs it something like:\nbash\nGITHUB_USERNAME=<token>\nGITHUB_PASSWORD=x-oauth-basic\n. ",
    "bodokaiser": "just as a help for people who get 404/\"dependency could not be resolved\" errors when using authentication: you must use an api token as password!\n. Both solutions worked out. Thank you!\nWhat is the actual reason why it is not possible to use one try/catch for everything?\nAlso why do you suggest  to use try/catch over using <usernam>-<package> all the time?\n. Ah okay. So I will use the full names and when not possible the 'module.component' test.\n\nAm 21.05.2014 um 10:35 schrieb Anton Wilhelm notifications@github.com:\nfor me the is-browser npm & component module is a nice solution: https://github.com/ForbesLindesay/is-browser\nHere you can find some other solutions:\nhttps://github.com/component/component/wiki/Component-and-npm\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah but it will work also when the package has the same name like as the component (the case with superagent).\nAm 21.05.2014 um 11:03 schrieb Anton Wilhelm notifications@github.com:\nthe full name trick only works if the module is pushed to the npm registry with this style -\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "andreasgrimm": "(maybe slightly OT) currently I'm hitting the github api limit.\non my local developer machine when I use the cli component-build command and don't have remote dependencies installed yet, then the first time it downloads them from github into 'components' folder. all subsequent calls don't hit github's api anymore it seems.\nDue to gulp-component npm module not working for me (outputs nothing at all), in a gulp task I implemented the example shown here: https://github.com/component/builder2.js with the effect that apperantly each build hits githubs api.\nCan you tell me how I'd achieve the same behaviour of the cli component-build when incorporating the resolver manually?\n[edit] Is it the resolver's local option I have to set to true ?\n. I debbuged boot/index.js and the regarding modules (e.g. base-page) are already undefined at this stage.\nI should mention that I'm currently running the build on a windows machine. maybe paths get messed up in this case (due to back-slashes insted of forward-slashes)?\n(edit) in a few hours I'm back on a Mac and can check if it's still a problem there.\n. In the resulting build.js it's the line\nrequire.register(\"./app\\lib\\base-page\",\nthat messes up the module name.\nand the line\nrequire.modules[\"base-page\"] = require.modules[\"./app\\\\lib\\\\base-page\"];\nthat leads to the undefined state.\nI wonder why in the register part the back-slashes won't get escaped opposed to the assignment statement where it seems correct .. but still is mixing up forward and backslashes\nWould you say that's an issue belonging to the component/builder.js issues?\n. fyi: On a Mac it works.\nThere the two lines are consistent and look  like they should:\nrequire.register(\"./app/lib/base-page\",\nand\nrequire.modules[\"base-page\"] = require.modules[\"./app/lib/base-page\"];\nAs a result the objets' names in the require.modules array are correct, too.\nNow do you think I should open an issue over at component/builder.js ? Is Windows OS officially supported in the first place?\nIf not, on windows I could work around this error with a vagrant box. But it seems like much additional work for bootstraping ones component dev environment initially. At least if you wouldn't have virtual box / vagrant installed anyway.\n(edit) oops, I think I was wrong and bundler.js would actually be the wrong place\n. my current workaround: in component.json set paths to \".\" and place all local component's folders in the root folder.\n. I fixed potential(?) bugs in component/builder2.js and component/build.js\nnow it works just fine on windows machines .. although the resulting canonical names are not consistent compared to building it on a non-windows machine (because of the backslashes instead of the forwardslashes for paths)\nShould I make Pull Requests and you want to take a look at it that way? .. or should we first discuss it here?\n. @clintwood I didn't stumble upon your fix in resolver.js at the time I did a search regarding this error. but that fix is actually more accurate, as it also addresses the inconsistency between windows and other systems I described and that'd be still existing with my fix. your fix seems to address the root of the problem. I don't see why your fix wouldn't work on my side. I can tell for sure in an hour or so whem I'm back at a windows machine.\n. on the other hand .. as the JSON.stringify is used inconsistently (which led to being a serious bug in the first place), maybe applying my fix would make it more consistent? ... or removing the other usages of it, if it isn't necessary\n. @clintwood In what package.json files do I have to change the dependencies? I cloned component/component, changed it in it's package.json and installed the local module with -g. but that breaks it when calling component build , resulting in Error: Cannot find module './build'\nmaybe I'm doing something wrong. though several component dependendies on the other hand, in their package.json depend on component-resolver as well, specifying a version different to 1.1.4\nAny hint on addressing this circumstance?\n. it is solved for me. thank you.\n. ",
    "sachalifs": "machine api.github.com\n    GITHUB_USERNAME=<token>\n    GITHUB_PASSWORD=x-oauth-basic\nthis should totally be on the guide :+1: \n. :+1: \n. ",
    "hallas": "having played around with a few webkit apps I really love watch, and for dev flow, I guess live reload is a neat feature\n. ",
    "prewk": "@jonathanong Okay thanks, I was hoping I could keep it simpler. Keeping all local components in separate repos instead is a hard idea to sell to my dev team but I understand it's sort of a core concept.\nCould you elaborate some on what locals actually are considered to be, and where they may apply? I couldn't find a whole lot in the guides about this.\n@dominicbarnes Interesting idea! Adds a bit of complexity to the dev directories I'd rather not have (symlinks in git etc) but it might be doable.\n. Never mind, I think I found the info I needed.\nI'll have to consider to host the components in a private repo instead, it seems to be the cleanest solution and it does have a lot of benefits.\n. @jonathanong Yeah, but now I can't seem to get the private hosting to work at all!\nI have a public repo at lumikenterprises/color-picker (just some test component to get things going).\nCreating a component.json:\n{\n    \"dependencies\": {\n        \"lumikenterprises/color-picker\": \"0.0.2\"\n    }\n}\ncomponent install installs the component, no problems.\nI can access https://raw.github.com/lumikenterprises/color-picker/0.0.2/component.json in the browser.\nNow, I make the repo private (and wait for a while, GitHub needs a minute or two it seems).\nI add the remotes to  component.json:\n{\n    \"dependencies\": {\n        \"lumikenterprises/color-picker\": \"0.0.2\"\n    },\n    \"remotes\": [\n        \"https://MYUSERNAME:PASSWORD@raw.github.com\"\n    ]\n}\nDEBUG=component* component install\n``\ncomponent-resolver remote not set - defaulting to remotes's defaults +0ms\ncomponent-resolver:locals resolving local at \"/Users/oskar/lumikenterprises/app\" +0ms\ncomponent-resolver resolving \"app\" +8ms\ncomponent-resolver:dependencies resolving dependency lumikenterprises/color-picker@0.0.2 +0ms\ncomponent-resolver:dependencies searching [\"https://MYREDACTEDUSERNAME:MYREDACTEDPASSWORD@raw.github.com\"] for lumikenterprises/color-picker@0.0.2 +0ms\ncomponent-resolver remaining dependencies: 1 +4ms\ncomponent-resolver remaining semver: 0 +0ms\ncomponent-resolver finished resolving locals +0ms\ncomponent-consoler Error: no remote found for dependency \"lumikenterprises/color-picker@0.0.2\". runcomponent open troubleshooting` for help.\n    at Resolver. (/usr/local/lib/node_modules/component/node_modules/component-resolver/build/dependencies.js:504:13)\n    at Generator.invoke (/usr/local/lib/node_modules/component/node_modules/component-resolver/build/index.js:141:31)\n    at Generator.invoke (/usr/local/lib/node_modules/component/node_modules/component-resolver/build/index.js:79:50)\n    at next (/usr/local/lib/node_modules/component/node_modules/co/index.js:77:21)\n    at /usr/local/lib/node_modules/component/node_modules/co/index.js:50:5\n    at Channel._call (/usr/local/lib/node_modules/component/node_modules/component-resolver/node_modules/chanel/lib/proto.js:114:3)\n    at Channel.push (/usr/local/lib/node_modules/component/node_modules/component-resolver/node_modules/chanel/lib/proto.js:100:8)\n    at Resolver. (/usr/local/lib/node_modules/component/node_modules/component-resolver/build/dependencies.js:574:8)\n    at Array.forEach (native)\n    at Resolver.resolveDependencies (/usr/local/lib/node_modules/component/node_modules/component-resolver/build/dependencies.js:573:21) +0ms\n   error : no remote found for dependency \"lumikenterprises/color-picker@0.0.2\". run `component open troubleshooting` for help.\n\n```\nI might be misunderstanding how raw.github.com works but I note that https://MYUSERNAME:MYPASSWORD@raw.github.com/lumikenterprises/color-picker/0.0.2/component.json doesn't work (404).\nI've also tried adding credentials to ~/.netrc and the environment variables to cover all bases.\nAny ideas on how I should proceed with the troubleshooting?\n(I made the repo public again for the sake of debugging)\nedit:\nSame problem with bitbucket for me.\nPublic works fine, but if I make my repo private and add:\n\"remotes\": [\n    \"https://prewk:MYPASSWORD@api.bitbucket.org\"\n]\nor\n\"remotes\": [\n    \"https://prewk:MYPASSWORD@bitbucket.org\"\n]\nThe same error occurs.\nIt should be noted that https://api.bitbucket.org/1.0/repositories/prewk/color-picker/raw/0.0.1/component.json is accessible with normal HTTP authentication in the browser.\nI'll reopen this so it won't get buried, hopefully the answer might help someone else.\n. Continuing my crazy-person monologue:\nI finally got Bitbucket private repos to work using the env variables found here and removing .remotes from the JSON completely:\nhttps://github.com/component/guide/blob/master/changelogs/1.0.0.md\nThank you and good bye! :)\n. I'll answer my question myself: Yes it is, the error message doesn't accurately describe the file name required.\nI re-arranged all the relative requires to a js file higher up in the file hierarchy and my problem was solved.\nIt's pretty easy to run into weird problems with require paths etc, but since I can't present at better test case I'll just leave it.\nI'm still wondering about require('../something.js), though. Is it supposed to work?\n. @wryk Yeah I'd like to respect this but it becomes ridiculous in a large project, which utilizes multiple small components but in itself is a large component never meant for publishing.\nIsn't it fairly common to use filenames matching \"class names\", even in JS?\nBut I'm sure there's lots of arguments back and forth about this I'm not aware of. I just hope I won't get forced to use spinal-case everywhere in the future.\nrequire('../something.js) wasn't mean above the root folder, it's for something like this:\napp.js\nsome-module/controllers/\nsome-module/controllers/SomeController.js\nsome-module/module.js\nTo be able to use SomeController.js I need to require module.js in it, and that's where ../module.js came from.\nIt's not above the root folder, but maybe it's not a very clever way to work with anyway.\nI moved all the requires to the app.js in the above example instead to solve my problems. Not very elegant but it works.\n. I see, thanks!\nYeah, I should be able to isolate and reproduce it. I've been fighting a couple of days with weird behaviors in component build vs using the example code for component-builder2 (which I had to change a lot due to a non-existing end method and when I finally got it to build, it complained about using require('./foo/bar/MyController.js');, which built fine with component build.. but that's for another test case and/or repo :grinning:)\nI'll drop a test case here ASAP.\n. Alright, the problem seems to happen if I'm requiring a path including a camelCased directory. If that's normal then I guess that's my issue.\nThis seems to work:\n\"src/spinal-case/module.js\",\n\"src/spinal-case/controllers/AlsoCamelCaseController.js\",\nWhile this doesn't:\n\"src/camelCase/module.js\",\n\"src/camelCase/controllers/CamelCaseController.js\",\n(Both controllers use require('../module.js');)\nIf you want to reproduce the error, clone https://github.com/prewk/component-problem.git and try out component build in it:\n```\nbuild : resolved in 9ms\nbuild : files in 9ms\nerror : could not resolve \"../module.js\" from \"component-problem\"'s file \"src/camelCase/controllers/CamelCaseController.js\"\n```\n. Since camelCasing clouds the error-report, I'll close this.\n. ",
    "bigmeech": "I wonder why this decision. We all love the create command, why you lot gotta be like this? Please give us back our create command. We beg of you!!!\n. Okay! Seems no one cares about this i'd like to maintain it. @dominicbarnes what idea do you have. Can we work on this together?\n. here is my package.json file\njavascript\n{\n  \"name\": \"widgetui\",\n  \"repo\": \"NPWeatherWidget/widgetui\",\n  \"description\": \"Widget UI directive\",\n  \"version\": \"0.0.1\",\n  \"keywords\": [],\n  \"dependencies\": {},\n  \"development\": {},\n  \"license\": \"MIT\",\n  \"main\": \"index.js\",\n  \"files\":[\n      \"views\",\n      \"assets\"\n  ],\n  \"scripts\": [\n    \"index.js\",\n    \"WidgetDirective.js\"\n  ],\n  \"styles\": [\n    \"widgetui.css\",\n    \"style.css\"\n  ]\n}\nIn the assets folder i have fonts and img directory, after the build out a get a package structure such as this \njavascript\nbuild\n  -widgetui             \n     -assets          //symlink\n         -fonts        //symlink\n         -img          //symlink\n     -views           //symlink\nYou would think the build.css references the fonts properly but it seems to rewrite the urls. i ended up having to use a cdn link to get those glyphs in.\n. @timaschew unfortunately i have taken component out of the project just for simplicity sake as not only was it complicating my css assets urls but also my angularjs test with karma so i cant exactly remember how it rewrote my links but it did. Maybe there are things i dont understand yet but i'll keep on doing my research and possibly find a good material on this and hopefully use component without issues in the near future.. Thanks guys!\n. Oh Might God @netpoetica I just realised what i wrote when i posted that comment. It was meant to be component.json file not package.json file. Thanks Anyways..I'm still using component in my personal project so i'm still learning a lot about it. I absolutely love component especially with angularjs development and how it forces you to think about your modules as separate self-contained testable features without worrying too much about application structure  and what generators to use so yes i am still using it.\nMy biggest issue was figuring out how to test these each component with karma the CommonJS way. \n. Thanks Jonathan. All good now.\n. ",
    "dandv": "If I replace \"necolas/normalize.css\": \"^3.0.0\" with \"necolas/normalize.css\": \"*\", component build still fails, unless it's run after component install.\nI'm going through the Get Started in the shoes of a Component n00b, so things should run right out of the box.\n. I had just installed 0.19.9 fresh.\n. sudo npm installl -g component brings 0.19.9. That's what new users will run, right?\n. Same issue reported by another user at https://github.com/component/guide/issues/16\n. ",
    "DrDub": "Hi, I'm experiencing this timeout issue with 1.0.0-rc5.\nAny way to increase that 5000ms timeout?\nTIA.\n. Thanks! \nJust modifying the default under $HOME/.nvm/v0.11.12/lib/node_modules/component/node_modules/cogent/lib/index.js did the trick for the time being.\nLook forward for any PR that improves the situation.\n. Or that you're far from github. Not everybody lives in CA ;-)\n. ",
    "wasinger": "Oh, I forgot: using version 1.0.0-rc5\n. ",
    "gvilarino": "I work with @slifszyc and about this, we've already moved to v1 so I guess it can be closed.\n. I work with @slifszyc and about #569, we've already moved to v1 so I guess you can close that one.\n. @micky2be @dominicbarnes I'm saying this because it's how 0.19.* used to work, and not supporting it breaks compatibility with components that haven't been updated since v1 is out. Even those under component github organisation.\nMy suggestion would be for * version number to work just as it is now, with the sole exception of fetching master when there are no tags at all in the repo. In a repo with no tags, master is the latest release available.\nFor instace, the repo I mentioned component/aurora is used by some other component in my dependency hierarchy. The only way I can think of to keep these working when migrating to v1 is to support * as fetch master when no tag is available. Builder could maybe issue a warning and tell you to be careful, but that shouldn't be a build-breaking issue.\n. @timaschew I agree with spirit behind the more restrictive approach to the use of *. I just believe it's not completely acceptable that 1.0.0 ships as is while official /component repos fail to build because no one tagged them.\n\nBut that I think it's not really expectably when you are on the master using * and then someone push a commit which breaks your app.\n\nThat would happen as well if someone publishes a new version without thorough testing. It's not a matter of tag/no tags, it's a matter of being mindful about what code is pushed/tagged. And let's keep in mind that what I suggest is only for those repos with the very rare -though real- case of not having public tags.\n\nAny branch, if master or something else, representing your current working draft which is not guaranteed to work.\n\nI believe nothing is actually guaranteed to work on the open source community. All softare is provided 'AS IS', as can be read in every other license.\nWrapping it up:\n1. In the ideal world * should fail when no tags are present.\n2. There are official /component repos that work, with no tags.\nThat being said, maybe supporting the very specific case of master when no tags are present is something that would make stuff work without the need of forking 6-7 repos in the hierarchy just to work around a tag that someone forgot to create, especially under /component.\nThis is all meant to improve adoption of component 1. The more rocks on the road someone meets when migrating is one more reason to drop component.\n. That sounds awesome!\nThanks for the support :+1: \n. Hey thanks @timaschew ! Close away if you will; I'll try to provide a script that repros on rc5\n. I understand and that makes a lot of sense. I'll try to make a repro situation later today and share it here\n. Well, that's pretty weird. It should fail as it did before, with a simple empty project and the following in their component.json\njson\n{\n  \"name\": \"foo\",\n  \"version\": \"0.0.1\",\n  \"description\": \"foo\",\n  \"dependencies\": {\n    \"component/aurora\": \"*\"\n  }\n}\nBut it doesn't. Maybe the github API is actually working differently. I say just close it.\n. ",
    "evs-chris": "Unless I'm missing something (entirely possible), that seems to be more geared toward packaging an app into components for internal (local) consumption, rather than packaging a component for publishing for general consumption. In the cases I've run across, I have an existing project with multiple outputs that can each be considered a component, but there is no way to easily package each in an individual component since they all derive from the same code base in the same repo.\nAnother solution would be to allow a sub-directory of a repo to house individual components i.e. yui/pure is the aggregated component and yui/pure/grids is its own component directory that references the grids.css output from the build directory in yui/pure. I have no idea if this is already possible in some way, but it doesn't appear to be.\nBut, again, I'm not sure that this sort of support isn't contrary to the goals of this project. My question primarily revolves around getting component support in existing projects that are already committed to bower and/or browserify. If they can add component support without having to completely rearrange their code-base, they would be much more likely to accept a pull request to do so; thus removing the need for component-ized forks that are subject to bit rot.\n. That's fair.\nI have one last (slightly rephrased from above) query as I close this issue: is there any chance that any sort of sub-component reference would be simple enough? For instance what if a component named 'yui/pure#grids' could behave exactly as 'yui/pure' in all other ways except pull the component.json from http://raw.github.com/yui/pure/whatever-tag-uri-parts/grids/component.json instead of http://raw.github.com/yui/whatever-tag-uri-parts/component.json? The paths in the json would still be relative to the repo root, but there would be the potential to reference aggregate projects without multiple forks.\n. ",
    "em": "That's really disappointing. I don't think anyone wants that. I think everyone just wants a package manager for the web that has a consistent API (unlike bower) and uses synchronous node-style modules. Really all I ever wanted was npm but with the expectation that the modules don't require('fs').\nEverything else that is a part of the component stack can be built on top of the basic standard offering of a standard component.json spec, and component(1). Why make the core component project do so much other stuff? It's like npm implementing require().\nThe reason I'm asking is because of this project I am working on: https://github.com/em/elem\nI have the unique ability in this context, to implement my own require() and parse component.json myself. There is no need to use a component-builder in this circumstance, it's something you can get for free. But I keep asking myself, is this something that even bodes with the component philosophy? Is this a project that doesn't want alternate consumption of components? I really wish it did, because it opens up the doors for component to be less of another web framework, and move closer to being the standard for distributing browser libraries.\n. My project is extremely different. But I'm not trying to show you my project. I'm trying to urge you to brand component as a package manager, and reference things like builder and resolver as component consumers, so that other people like myself can consume components independently in a sanctioned way, and try to further the proliferation of components as a whole.\nPeople understand that the web needs a package manager, and that bower is far too agnostic to be a real solution. We need a package manager first, and then we can have those other things. I think component trying to be so many other things is preventing it from being adopted.\n. Part of that is including things that people expect like component update in component(1). And promoting certain libraries to first-name basis, so I can just do component install page rather than component install visionmedia/page.js\n. Bower and component both competing to be the package manager for the web, yet neither of them actually being a complete package manager that can version and manage agnostic packages w/ a common interface, really really bums me out. Just saying.\n. The problem with npm for the browser has never been anything more than the fact that you need to know ahead of time if what you're installing is going to at some point try and require a core node module it doesn't really need and blow up. The solution for that is just to have a place to put modules that are supposed to be run in the browser. You could even implement some core modules like 'path', they'd just need to be dependencies in the browser because bytes cost something in that environment.\n. The way I see it, a package manager has a unique and noble role, unlike other projects. It has to be somewhat unopinionated like bower, but it also has to provide a common interface unlike bower. Module authors need a definitive way to expose their API, and consumers need a definitive way to use it. Neither component or bower are providing that. The end result is the community is split even further.\nWhat I'm suggesting - is just that you consider branding component as a pure package manager and focus on that aspect of it. Get the web frameworks out there on board with consuming components as opposed to making their own package managers. If they are using component, then it feeds back in to the component community, and people can finally author libraries that can be used in many places with semantic versioning, search, update, all the stuff you want from a package manager.\nRight now we have tons of popular web frameworks. But they only last a few months before something better comes along. If component takes this direction, then the next generation of web frameworks can share components at their core. I want to see component be a commodity of other frameworks, not a framework itself.\n. I don't think we disagree.. I simply think the current readme does not reflect the ultimate goal of component to be reduced to a package manager for es6 web components. Most people I know think component is something else. Just trying to give you an outsider's perspective.\n. Oh ok. Sorry.\n. ",
    "kevva": "@jasonkuhrt, https://github.com/component/remotes.js/blob/master/lib/remotes/github.js#L46-L59 in case you want to submit a PR.\n. @fairwinds, you can download it from npm.\n. ",
    "sankaran85": "Im blocked ... Some help !!!!\n. i have git in my machine ....\n. Cool that's rite  ... it worked thanks all !!!!!\n. ",
    "xiangbai": "@dominicbarnes\nhttp://flippinawesome.org/2014/02/17/introduction-to-the-component-javascript-package-manager/\nin the part Create a Project\n{\n  \"name\": \"hello_commponent\",\n  \"dependencies\": {\n    \"component/dialog\": \"*\"\n  }\n}\n. Thank you very much\nI use the up-to-date examples,when I run the command of component build,\nthe error is :error : Cannot call method 'process' of undefined\nlike this:\ninstalled : necolas/normalize.css@3.0.1 in 1805ms\n       build : resolved in 13486ms\n       build : build/build.js in 32ms - 1kb\n       build : files in 28ms\nerror : Cannot call method 'process' of undefined\nthe index.html can be able to run normally\n. @timaschew thank you very much, I will try to install component again.\n. @timaschew  It's ok!\nThank you \n. ",
    "tetsuo": "update changes component.json file even if the latest version is not component-compatible. that's a bug indeed.\nkeeping component.json as it is and showing an error message will work out as expected\n. @netpoetica  here https://github.com/componentjs/update.js/blob/master/lib/index.js#L38 there is some weirdness going over there :) enigma of @jonathanong \n. ",
    "poying": "component build -w sometimes not work and there is no error message.\nBut after I add console.log('some text') into node_modules/bin/component-build, it works again.\n. node 0.11\n. ",
    "Antaranian": "Wandering if it's more Spec's related and depends on decision guys will make on component/spec#52, as this change may or may not involve changes to dependencies section in manifest file?\n. ",
    "xmojmr": "1 Original site founder (@visionmedia) is not going to look after the site anymore, at least this article seems to say that - https://medium.com/code-adventures/4ba9e7f3e52b\n2 The domain was registered (WHOIS record) by @guille \n3 If you just want to find something you can use http://component.xmojmr.cz\n. >  @clintwood: :+1: ..I have found it hard work to select components and perhaps this is due to the lack of an informative repository...\nThat is why I resorted to building and running the component search tool as an temporary answer to https://github.com/component/component.io/issues/78 (BTW yes it was my homework playground to learn things and it was fun)\nBut the someone somewhere someday will do something approach resulting in tool with bad support makes me to consider\n\n@clintwood: :+1: ..would be component user move on to something else leaving to die quietly..\n. \n",
    "augbog": "For the time being, can the Github repo description change the link from component.io to http://component.github.io/component.io/ at least until this issue is resolved?\nIt's confusing users.\n. ",
    "ustccjw": "npm update to lastest & random => this is windows\n. ",
    "ismay": "\nMe too, I really love component and I wonder a lot about his future\n\nMe too. I hope that duo will be backwards compatible with component, or that someone'll take over component.\n. I agree, I'll close this then. Thanks for the feedback!\n. > the problem is that this kind of boilerplate templates don't fit into the concept of small independent modules.\nI agree, I think I ran into this issue because I misunderstood the proper use of component and its more modular approach to writing css.\n. ",
    "watilde": "Sorry for duplicate.\nI can see for now at http://component.github.io/component.io/\nThanks!\n. ",
    "285858315": "Npm is \"npm remove name\",component how to do?\n. OK,I see..\n. ",
    "sk7": "ah perfect, thanks! component is installed fine, but component validate already shows some issues with my component.json, so i'll try to fix them\n. ",
    "travelbasys": "Solution found!\n@netpoetica: Yes, I did have admin privilege. But I could not install -g grunt-cli. Same error messages.\n@cristiandouce: Yes, the problem is with the \"git:\" url.\n        git clone git://github.com/timaschew/cogent    fails but\n        git clone https://github.com/timaschew/cogent    is ok.\nI always use https: when cloning from github.\nI am sitting behind a firewall.\n@timaschew: I tried your example, but it failed, too.\nA solution is given on this page:\nhttps://coderwall.com/p/sitezg/force-git-to-clone-with-https-instead-of-git-urls\ngit config --global url.\"https://github.com\".insteadOf git://github.com\nreplaces the git: protocol by https: on github.com.\nAfter that, npm install -g component worked fine.\nThank you to all contributors.\n. ",
    "mteichtahl": "Antonio\nI had a quick look. Very possibly a duplicate but I can't confirm that at the moment. \nIf related to the transpiler we would need to ensure broad support for ES6 operators. \nIt would be great if a contributor could validate of this is a dup or not. I'm happy to share my repo of needed for testing. \nSent from my iPhone\n\nOn 30 Dec 2014, at 21:09, Anton Wilhelm notifications@github.com wrote:\nI think it's a dup: componentjs/builder-es6-module-to-cjs#1\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks all\n\nThis was resolved by enabling harmony. Closing this issue\n. ",
    "KenanSulayman": "If you provide a PR I'll happily merge it.\n. That's a Chrome bug. We ran into it as soon as Canary became Stable. I am confident that the comments used for annotations are causing this bug in Chrome and it wasn't properly unit tested. (regression, that is)\n. +1 for changing. Even if it was an artifact of design, the behavior fired back pretty hard.\n. ",
    "gamtiq": "Unfortunately I don't know the correct link.\n. ",
    "aprilb": "@netpoetica here is the entire log using mf DEBUG=*\nLodash stuff starts at line:\nhttps://gist.github.com/aprilb/cfd63f68467f07dad968#file-gistfile1-txt-L3677\n. I started another thread earlier:\nhttps://github.com/lodash/lodash/issues/861\nwhich resulted in this change:\nhttps://github.com/ifandelse/machina.js/blob/master/component.json#L9\nI believe this is the source, but the change should have remedied it.\n. Also, that is a remote dependency.\n. @timaschew thanks for looking into it.\n. github\n. {\n  \"name\": \"shared-scripts\",\n  \"repository\": \"treetopllc/shared-scripts\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"description\": \"Treetop Commons shared Javascript files\",\n  \"main\": \"index.js\",\n  \"scripts\": [\n    \"index.js\"\n  ]\n}\n. netrc which is valid. component version 1.0.0\n. machine github.com\n  login xxxxxx\n  password x-oauth-basic\nmachine api.github.com\n  login xxxxxx\n  password x-oauth-basic\n. actually i am using component 1.0.2\n. did you say you added me to timaschew/TodoFPM-test-private?\n```\n$ component install timaschew/TodoFPM-test-private\nfatal : no remote found for dependency \"timaschew/todofpm-test-private@master\". Visit http://component.github.io/troubleshooting for help.\n```\n. ok, great. yeah, that did it.  thanks for looking into it.\n. actually, looks like I needed all three:\n$ cat $HOME/.netrc\nmachine github.com\n  login xxxxxxxxx\n  password x-oauth-basic\nmachine raw.githubusercontent.com\n  login xxxxxxxxx\n  password x-oauth-basic\nmachine api.github.com\n  login xxxxxxxxx\n  password x-oauth-basic\n. Here is the error if i leave out api.github.com:\nError: no remote found for dependency \"mochajs/mocha\".\n    at Resolver. (/home/nobleweb/go/src/github.com/treetopllc/nobleweb/node_modules/component-resolver/build/semver.js:565:13)\n    at Generator.invoke (/home/nobleweb/go/src/github.com/treetopllc/nobleweb/node_modules/component-resolver/build/index.js:141:31)\n    at Generator.invoke (/home/nobleweb/go/src/github.com/treetopllc/nobleweb/node_modules/component-resolver/build/index.js:79:50)\n    at next (/home/nobleweb/go/src/github.com/treetopllc/nobleweb/node_modules/component-resolver/node_modules/co/index.js:74:21)\n    at /home/nobleweb/go/src/github.com/treetopllc/nobleweb/node_modules/component-resolver/node_modules/co/index.js:93:18\n    at Gunzip.onEnd (/home/nobleweb/go/src/github.com/treetopllc/nobleweb/node_modules/component-remotes/node_modules/cogent/node_modules/raw-body/index.js:136:7)\n    at Gunzip.g (events.js:180:16)\n    at Gunzip.emit (events.js:117:20)\n    at _stream_readable.js:943:16\n    at process._tickCallback (node.js:419:13)\n. kk.  Will do.\n. Error:\nUncaught Error: failed to require \"./template.hbs\"\n. @sankargorthi using component-build-handlebars plugin\n. Here is the build file:\nhttps://gist.github.com/aprilb/aedad66feec4236f1982\nVersions:\n\"component\": \"~1.0.0\",\n\"component-build-handlebars\": \"0.0.1\",\n. @sankargorthi here is the builder:\nhttps://github.com/dominicbarnes/component-build-handlebars\n. Removing the string plugin doesn't seem to have an affect  --still getting the same error.  But the person who wrote the handlebars plugin I mentioned --also wrote this part of the script.  It doesn't fail if these scripts are local --they are only failing now that they are being required as a remote dependency.\n. ",
    "shinux": "I still don't know what happened, just let it rotate, and finally it installed successfully......maybe after u fixed it up.\nBut whatever, thanks for your reply.  I was really screwed up with this.\n. At that time, I also installed stylus and uglify-js without a hitch. That's why I had the doubt about component and npm or something mixin.\n. ",
    "niknah": "I had this problem too.  On projects with lots of components on github you'll eventually get this error...\n{\n  \"message\": \"API rate limit exceeded for _________. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)\",\n  \"documentation_url\": \"https://developer.github.com/v3/#rate-limiting\"\n}\n. ",
    "shobhitg": "Thanks a lot for explaining.\nI forked and added component.json file.\nCan you please glance and see if it looks right before I make a pull request: https://github.com/shobhitg/dc.js/blob/develop/component.json\nAlso I have a question, is there a way I can tell component to use \"dc.js\" for development mode and \"dc.min.js\" for production mode?\n. ",
    "bartzy": "OK, sorry for throwing you in the wrong direction then.\nSee this issue: https://github.com/abpetkov/switchery/issues/22 , if it helps at all...\nThanks!\n. @timaschew Any news on this issue?\nThanks!\n. I don't think so - Switchery uses Component as its build/dependency system. It depends on FastClick.\nThen Component just concatenates Fastclick into the switchery dist file, and that breaks RequireJS (since you can't just concatenate a requireJS module (fastclick) inside another file (switchery dist file)...\n. Did you try to build a standalone version of switchery (through component, it has a Makefile and can be built with make standalone), and then require it with RequireJS? It doesn't work.\nThe problem is not with FastClick, It happened to me when I added Hammer.js to Switchery as well (I forked it). The problem is with the fact that Component concatenates all the dependencies when building a standalone file, and then RequireJS breaks when you try to load require Switchery  with it.\nThanks for the help!\n. So there's no way to use RequireJS to load code that uses Component as a build/dependency system (like Switchery)?\n. Thanks.\nHow can I do that?\nI'm using Bower to pull Switchery as a dependency.\n. ",
    "AaronNGray": "On Windows the files are the same except the visionmedia/debug dependency is obviously missing in the lib/debug\napp\\lib\\debug> component install visionmedia/debug\nis giving :-\nfatal : no remote found for dependency \"mediavision/debug\".\n. I am getting the same error message on doing a 'make' on Linux :-\nfatal : no remote found for dependency \"visionmedia/debug\".\nI don't know if I am missing doing something with componentjs at this stage ?\n. Okay its just being non determinate. GitHub was being DDoS'ed apparently and I think its possibly to do with this maybe as some things are now working that were not working before but for no reason. And it seems only to be with new repos, not existing ones.\nI think the componentjs component architecture does not do enough retries or wait long enough at times in places like when resolving dependencies.\n. Thanks !\n. I am still having problems with 'component install' particularly redirects like tj/debug -> visionmedia/debug are still not getting resolved when the internet is busy even with a --timeout 480000\nI seemed to have clear periods of working behaviour when the internet is quiet in the early hours in the UK, i.e. 6:00AM GMT.\nIt seems to be redirects that are hit worst, then newer created repositories, then when it very busy other modules at random. It looks like the '--timeout' flag does not work on all operations within 'component'.\nI am in the UK so probably have longer latencies that the US.\nI think its the component-resolve module is where the problem is occurring.\n. Is it possible to solve this ?\nI don't have good enough knowledge of the component codebase.\nAaron\nOn 8 April 2015 at 11:00, Anton Wilhelm notifications@github.com wrote:\n\nIt looks like the '--timeout' flag does not work on all operations within\n'component'.\nYep, I think this is the problem, here is the code:\nhttps://github.com/componentjs/remotes.js/blob/0c32e97cc07dd2bbb7076fdf52102e514d4b7431/lib/remotes/github.js#L43\nThe options are not passed at this place.\nGood catch, thanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/componentjs/component/issues/634#issuecomment-90867926\n.\n. Anton,\n\nAs I am experiencing the problem at this end I suppose I need to do the\ndebugging here.\nIs it possible you can push what you have done onto a github repo or branch\nand give me instructions on how to set it up for debugging ?\nOn 8 April 2015 at 17:58, Anton Wilhelm notifications@github.com wrote:\n\nCannot go further without any debug lines\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/componentjs/component/issues/634#issuecomment-90974808\n.\n. Yeah I have tried DEBUG=* but there seem to be no debug lines at the\nrelevant points so I suppose I need to further instrument the code.\n\nI have found the line that throws up the actual fatal throw line :-\nnode_modules/component/node_modules/component-resolver/build/semver.js:565\nNot sure how the build directory gets there from looking at componentjs/resolver.js\nI find this code very hard to follow !\n. Okay I have Node 0.12\nWill try with --harmony\n. Okay seemed to have fixed it by using long timeouts of 240000ms I will close this issue as soon as the it has been tested at peak US and UK internet access time, later today.\n. Ah its still not working on a Windows VMWare with Fedora installed, even with a timeout of 480000 !\nSo there is some form of timing latency or retry problem, probably not enough reties at some points in the code.\nSee issue https://github.com/UKDemocracyOS/app/issues/1\n. Okay its not working on deployment on my Fedora F20 i686 HP DL140 G3 Dual Core Servers\nI think either there is a race condition in the code or there are no retries or not enough retries.\n. I use CMD on Windows. But was getting the problem there at times of high\nlevel internet usage, when UK and US were quiet the problemS ceased.\nIt still looks like a timing and retry issue to me. As it also happens on\nLinux VM's under VMWare on Windows. And on my Fedora 21 Linux machine too.\nIts intermittent basically.\nOn 26 April 2015 at 07:10, rickdog notifications@github.com wrote:\n\nwin64 with npm v2.1.18\nnpm install component fails for certain shells: msys32 msys64, cygwin64\nbash - POSIX filenaming incompatibiliity.\nuse regular cmd or git bash\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/componentjs/component/issues/634#issuecomment-96327534\n.\n. I am getting all sorts of random errors, depending on time of day, --timeout value, and internet busyness, Windows or Linux, and when I try to debug I get different results yet again. There has to be timing issues such  as lack of retries. It looks like either a latency problem or a race condition.\n. Things seem to be working now both on Windows as well as Linux ! You seem to have made a new master on cogent. I will test again at peak internet activity. \n. Lots of working installs on both platforms, just had one :-\n\nfatal: connect ETIMEOUT\n. Not fixed I must have had very good internet another tester is getting :-\nno remote found for dependency \"democracyos/timeago@master\".\n. Heres the generated code in 'node_modules.bin\\component-install.cmd' \n@IF EXIST \"%~dp0\\node.exe\" (\n  \"%~dp0\\node.exe\"  \"%~dp0\\..\\component\\bin\\component-install\" %*\n) ELSE (\n  @SETLOCAL\n  @SET PATHEXT=%PATHEXT:;.JS;=;%\n  node  \"%~dp0\\..\\component\\bin\\component-install\" %*\n)\nor 'node_modules.bin\\component-install'\n```\n!/bin/sh\nbasedir=dirname \"$0\"\ncase uname in\n    CYGWIN) basedir=cygpath -w \"$basedir\";;\nesac\nif [ -x \"$basedir/node\" ]; then\n  \"$basedir/node\"  \"$basedir/../component/bin/component-install\" \"$@\"\n  ret=$?\nelse \n  node  \"$basedir/../component/bin/component-install\" \"$@\"\n  ret=$?\nfi\nexit $ret\n```\n. Its more complicated in the app as component is loaded as a node module !\n. Tim,\nThings seem to be working now both on Windows as well as Linux ! You seem to have made a new master on cogent. I will test again at peak internet activity. \n. I am getting the same issue with both VM's and Linux during times of high internet usage, seems to work fine on Windows though. I did an issue for it here https://github.com/componentjs/component/issues/634\n. Is this just component or the whole of componentjs ?\nOn 22 June 2015 at 01:48, Damian Krzeminski notifications@github.com\nwrote:\n\nThanks @timaschew https://github.com/timaschew and thanks to everyone\nwho made component possible. Probably stating the obvious here: many\ncomponents (as opposed to the component builder and tools) are probably\nstill used in the wild. I'll keep an eye on a few I am still using. Let's\nwind it down gently.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/componentjs/component/issues/639#issuecomment-113974402\n.\n. So ComponentJS itself is being scrapped ?\n\nOn 22 June 2015 at 21:05, ven notifications@github.com wrote:\n\nwell, the individual components should still work fine, so long they have\na bower.json / package.json / something else to be used\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/componentjs/component/issues/639#issuecomment-114242032\n.\n. \n",
    "rickdog": "win64 with npm v2.1.18\nnpm install component fails for certain shells: msys32 msys64, cygwin64 bash - POSIX filenaming incompatibiliity.\nuse regular cmd or git bash\n. ",
    "g105b": "Oh no, I was just getting to know component... shame it isn't being maintained.\nThanks.\n. ",
    "ChALkeR": "@timaschew Yes, they did, and it wasn't you.\nThanks, looks better now!\n. ",
    "bijanmmarkes": "The problem is the structure of component is it doesn't allow you to require node_modules from the server as it is trying to look for a component. I know nodemailer would not work with component but it seems to override the require command completely which is how you require server-side node_modules. How do you require non-components using node.js and use them on the front-end when component is present in the project? How would i require nodemailer using the \"require\" command when it tries to look for a component?. ",
    "bpierre": "Oops f02cfe9\n. "
}