{
    "PaulLeCam": "Thanks, I didn't notice the renaming wasn't properly committed, should be fixed now!\n. It's not stable so I wouldn't use it in an important project.\nSo far I focused on rendering static maps, so the library only acts as a wrapper for Leaflet, creating an instance and adding elements according to the component hierarchy, but it won't update them (unless you completely re-render the map, which is unlikely to be an option).\nFor this behavior, the components should be working, but the library is still lacking tests so there may be typos or other small bugs like this.\n. Yes, I'm adapting it to React 0.12 using JSX and ES6 instead of CoffeeScript.\n. Hi,\nYou can pass any option used by Leaflet as property of the component, ex: <Marker icon={myIcon} />.\nAlternatively you can always use the Leaflet library to add other elements to the map. It may not be easy at the moment but I'm working on making these elements easily accessible by components.\n. Leaflet will insert its own HTML, so for elements with HTML properties, it should be set as such, either using React.renderToStaticMarkup() on React components or HTML.\n. Indeed, sorry I left it out, it's fixed now.\n. Do you have an example code not working with server-side rendering please?\nThe Map component initializes its Leaflet instance in its componentDidMount callback, and it's only after this instance is created that its children are rendered.\nI just added a test to check this behavior, it works as expected: https://github.com/PaulLeCam/react-leaflet/blob/master/src/tests/Map.js#L68\n. I see. Considering it's Leaflet's behavior, I think it's really an application concern, not a library one.\n. Thanks!\n. Cool, thanks!\n. Hey, does it really need to remove and re-create the layer?\nWhy not calling the element methods instead to handle the changes?\n. Hey, I updated the ImageOverlay component to make the url and opacity properties dynamic, can you please check with v0.3 if that solves your problem?\n. I'm closing it now due to inactivity, but please feel free to reopen if you need.\n. I see, it seems it can't be handled directly by a Leaflet method on ImageOverlay according to the documentation, but I'll check.\nJust out of curiosity, if you set a different key prop on the <ImageOverlay /> component, does it work as expected?\n. I'm glad it works, that way React properly treats it as a new image rather than the same, so it gets properly attached.\n. Thanks!\n. Hi,\nI use React.renderToStaticMarkup() because Leaflet sets the content of the Popup by manipulating the DOM itself (https://github.com/Leaflet/Leaflet/blob/master/src/layer/Popup.js#L172), so at this point it is not possible to use React elements.\nInstead of having to patch react-leaflet, I think another way you could do it is to instantiate a Leaflet Popup and attach it to the Marker in your application instead of using the <Popup> element, this way you would have full control over it.\nThe best solution may be to render an empty element with a specific ID as the content of the Popup so that Leaflet inserts it in the DOM, and then call React.render() on this element, but I've never tried this so I have no idea how it would behave. I'll try this when I can find some time.\n. Hi,\nGreat if that works for you.\nI think this kind of code should be in the application, not the library as it introduces specific handlers, that goes against the purpose of this library to simply wrap Leaflet in React components.\n. Hi,\nLeaflet event handlers can be attached to the Map using the onLeaflet prefix (https://github.com/PaulLeCam/react-leaflet#events), but not the DOM ones.\nIs there any use case it would be an absolute necessity to bind DOM events?\n. Hi Andy,\nThanks for the context.\nAt the moment I'm still unsure whether DOM events should be supported or only Leaflet ones.\nThe Leaflet ones are prefixed with onLeaflet so they wouldn't clash with DOM ones in the props, but at the same time my concern is that attaching both DOM and Leaflet events could lead to confusing behaviors.\nThe only case I've had where DOM events would be useful is on the Map, as in your case, and what I did was simply to wrap the Map in another component to handle these events, do you think this would work for you?\nAt some point I'd like to simply set the Leaflet events as on... rather than  onLeaflet..., any suggestion?\n. Hi,\nI think this kind of code should go in the application, not the library.\nAt this point I don't want to add specific handlers like createPopup() to be able to create a Popup, in my opinion it goes against the point of using React and simply having to include a component to render it.\nI'll try to find a solution to render React components in Popups that doesn't involve new APIs.\n. Hi,\nI have never used FeatureGroup, I just added it as an interface to http://leafletjs.com/reference.html#featuregroup so that you can pass it a layer array, that would be Leaflet elements.\nIt would really make sense to be able to have React-Leaflet elements as children, but I don't know how it would behave with Leaflet, so for now it's not supported.\n. Hi,\nSure it can be an issue with the library, but hard to tell without a code example.\nAre you setting a unique key property on each Marker?\n. It's used by React to keep track of components identity, see: https://facebook.github.io/react/docs/multiple-components#dynamic-children\n. Hi!\nReally depends on your use case, but if you are using Flux, your components should simply render the state of the app, not hold it.\nThere is no major difference using React-Leaflet or components manipulating the DOM, all you need to do is listen to events, dispatch actions, handle your state in the stores and render your components based on their state.\nYou can have a look at the \"events\" example that listens to an event on the map to update its own state. Using Flux, it would dispatch an action instead of setting its state directly, and get its state from the related store.\n. Hi,\nThere is no subdomains setter in Leaflet TileLayers so it can't be made dynamic here, see http://leafletjs.com/reference.html#tilelayer\nI suppose a solution is to set the key property on each TileLayer component so that React would add/remove them accordingly.\n. Hi,\nYes it's possible to use it with React.createClass(), as long as it's using React 0.13+ the components definitions will be handled by React.\nLooking at your code, how does it behave when you remove these lines?\njs\nconst flux = this.getFlux();\nflux.actions.drafts.reloadAsync();\n. Hi @Otann, any news on this?\n. Hi,\nHard to tell what the problem is without seeing more code, but could you please try without flummox and other components?\nIt's possible they try to update the component before it's actually mounted, and that would likely result in the error thrown by React.\n. Hi,\nI've been investigating a bit on this and I think the issue is that you are updating the Popup, which is simply not supported.\nOne thing to understand with this lib is that the DOM is manipulated by Leaflet, not React, so there is no use of virtual DOM, the components are just an abstraction on top of Leaflet.\nThe components render a <noscript> element because React's render() needs to return an element, but ideally they wouldn't render anything, so using a <div> may be a simple workaround, but not a proper solution.\nIf you want to update components on the map, some of them can be updated directly by their props, if there are equivalent Leaflet setters, but otherwise the best solution is to remove the existing layer and add a new one.\nIn your case, I think you're trying to dynamically update the children of an element implementing PopupContainer, but this is not possible. To achieve this behavior, you need to remove the existing layer and add a new one, by setting a different ref property on the layer component.\n. So you've found a workaround for this with your code?\nI'll update the documentation to make this more explicit.\n. OK perfect!\n. Hi,\n<FeatureGroup> only passes its layers property to Leaflet.featureGroup(), the only child that can be set is a <Popup>.\n. Hi,\nThis lib doesn't use window or other DOM APIs directly, but Leaflet, which is a dependency, does.\n. Hi,\nYou can use the getLeafletElement() function on the Map component to get the created Leaflet instance after the component is mounted.\nEx:\n``` js\ncomponentDidMount() {\n  this.element = this.refs.map.getLeafletElement();\n}\nrender() {\n  return ;\n}\n``\n. I have never tried to use theload` event, it should be implemented as all Leaflet events are simply passed to the Leaflet instance, but it's possible this event is fired just before the event handlers are actually attached.\nI assume any logic you would put in a load handler could be set in the componentDidMount of the containing component, but it really depends on your use case.\n. Hi,\nCould you please give more details about how this change affects the library please?\nI have never tried leaflet-headless, but from my understanding it renders a static map to an image, which is not the purpose of this library.\n. As much as I'd like to support server-side rendering, I don't think it's the way forward. leaflet-headless has too constraining dependencies to be a simple drop-in replacement.\nFor now, this library is only focused on proxying to Leaflet, not offer additional features that are not supported by Leaflet.\n. Hi,\nJest does not support node v0.12, see: https://github.com/facebook/jest/issues/243\n. Thanks!\nI'll implement the other setters as well and publish a new version.\n. Published in v0.5.0.\n. Hi, thanks for the fix but it would be hiding the problem rather than solving it, see https://github.com/PaulLeCam/react-leaflet/issues/18#issuecomment-99013617 for a more detailed explanation.\n. Thanks!\nNo it doesn't support react-native.\nLeaflet needs to access the DOM so I assume the only way to use it is in a WebView.\n. Well it's the purpose of react-native to render native components, not a DOM :)\n. Hi,\nRemoving a Popup is not supported, you need to update the entire layer, see https://github.com/PaulLeCam/react-leaflet/issues/18#issuecomment-99013617\n. Sorry I misread about the Popup deletion.\nI'm not so up for using a <div> as a workaround because the rendering is made by Leaflet, not React, so the null/<noscript> rendered by the components are only there because React needs to render something.\nMy main concern is that rendering <div>s could affect the expected layout, but display: none should avoid that issue, I'll try that!\n. The style would only apply to the PopupContainer component, that should be invisible anyways, not the Popup that would be rendered by Leaflet.\n. It should work properly now in v0.6 using a div with display: none, I didn't find any issue using it.\nPlease reopen if the bug appears again after updating.\n. Good idea, thanks!\n. Hi,\nYou could use Browserify or Webpack to build the library the way you want, I may provide a standalone build at some point but that would likely be part of a larger refactoring.\n. Hi,\nSorry for the delay, UMD builds are now available in https://github.com/PaulLeCam/react-leaflet/tree/master/dist\nThis makes them also available on npmcdn: https://npmcdn.com/react-leaflet/dist/react-leaflet.js and https://npmcdn.com/react-leaflet/dist/react-leaflet.min.js\nI'll update the documentation with these links.\n. Hi, are you including the dependencies before loading react-leaflet? It requires React, ReactDOM and L (Leaflet) to be defined on window.\n. Added to the Readme.\n. Hi,\nThe default path is set in the main file: https://github.com/PaulLeCam/react-leaflet/blob/master/src/index.js#L30 so maybe you tried to load a component directly instead of using the entry file?\n. It's an issue with Leaflet I had originally developing this lib, that's why it's set by default in the entry file.\nI just compiled the lib again without any problem, how are your trying to compile it?\n. Hi,\nI could never reproduce the error compiling the lib, and Travis doesn't complain when running the tests, so it really seems like a runtime issue.\nCould you please post a running example of the failing code in a jsbin or something like this?\n. Hi,\nYou can't allow all props to be passed the Map because the events are handled by Leaflet, not React. I'll make a new release with the added style prop on Map in the next few days.\n. Updated in v0.6.\n. Hi,\nAt this point I don't want to support individual styling attributes on the elements that do not have specific Leaflet setters for them, this kind of logic should be part of your application code rather than the lib.\n. I never tried this, but you should be able to pass the onEachFeature handler as a <GeoJson> property.\n. I suppose you could have the react-leaflet Popup rendered elsewhere and pass its instance to the layer.bindPopup(), but it is unnecessary complex, I would rather simply let the layer.bindPopup() create the Popup itself.\n. It really depends on your use case, if you're using Flux you would likely have the properties of your circle set in a store, so it would make sense to update the map based on these values as well.\nIf your map layers are your sources of truth, your solution seems good.\n. Thanks!\n. Hi,\nFor plugins that provide additional layers, integration should be pretty easy by extending one of the base components provided and implementing the relevant lifecycle handlers (most likely componentWillMount and componentDidUpdate) as it is done in the lib, ex with then Rectangle component.\n. I think in your case the best solution is to implement a custom GeoJson component pretty much the same way as it is done in https://github.com/PaulLeCam/react-leaflet/blob/master/src/GeoJson.js\nAll you need is to add the onEachFeature handler to the props variable in componentWillMount, it would have access to the map directly.\n. It's not supported by the library, you can simply force the component recycling by changing is key property, but you should implement your own solution to efficiently diff the GeoJSON data.\n. Hi, thanks!\nI have never had this use case so I don't know what can be the exact origin, can you setup a jsbin or something showing the issue please?\n. Hi,\nIt seems to be a known issue with Leaflet, if its container size is changed or if it's not visible when the map is created. Calling map.invalidateSize() resets the map display.\nHere is an example to make it work with react-bootstrap:\n``` js\nclass MapTabs extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      key: 1\n    };\n  }\nonSelect(key) {\n    this.setState({key});\n    setTimeout(() => {\n      this.refs['map' + key].getLeafletElement().invalidateSize(false);\n    }, 300); // Adjust timeout to tab transition\n  }\nrender() {\n    return (\n      \n\n\n\n\nA pretty CSS3 popup.Easily customizable.\n\n\n\n\n\n\n\n\nA pretty CSS3 popup.Easily customizable.\n\n\n\n\n\n    );\n  }\n}\n```\nThe trick is to control the tabs from a parent component, this way you can access the relevant <Map> via its ref, and call invalidateSize() after the tab is fully displayed. That's why there is a 300ms timeout before calling the function.\nIf the tabs transition has a different timing, you should adjust this timeout, making sure it's always superior or equal to the transition time, otherwise the map rendering would not be done properly.\n. Thanks!\n. @troutowicz's example is a good one, you can also have a look at this discussion: https://github.com/PaulLeCam/react-leaflet/issues/37 for more information\n. The issue with making it an explicit prop is that React would always warn it's missing, because it checks the propTypes when creating the components tree, not when rendering it.\nBecause the Map component needs to render the <div> containing the map first, and then render its children, the validation happens before this map prop is created.\nI added a note on creating custom components to the Readme, hope it helps.\n. What version of node are you using? Jest is only compatible with v0.10.\nThere is no eslint in package.json but it's a good idea, I would add it eventually.\nRegarding your error when using npm link, I suppose it's an issue with you configuration, seems to be an error with webpack loader and this library is not using webpack.\n. Closing due to lack of response, feel free to reopen if you need.\n. The issue is with Leaflet itself, as it doesn't check if the DOM is available when it's loaded, not directly this library.\nI do not plan to support server-side rendering in this lib until it is supported by Leaflet itself, unless it's a trivial implementation with no side-effect.\nThe solution you presented may work for you, but it's completely dependant on your environment and your build, it would probably not work in other cases.\n. @iam4x Feel free to implement any workaround in your app... As I previously explained, this issue is not caused by this lib.\n. Out of curiosity, why do you want to call invalidateSize() once the map is loaded? As far as I know, Leaflet sets its size when it's loaded anyways.\n. OK so in your case I think it's a much better solution to load your styles before, just like Leaflet styles should be loaded before creating any map anyways.\n. Closing for now as it doesn't seem to be an immediate issue.\n. The onLoad handler is not called because it is fired by Leaflet before the events are attached, but you can use the componentDidMount in your container component to achieve the same purpose.\n. These interaction options are passed from the props when creating a Map, ex <Map dragging={false}>.\nThe purpose of this lib is not to add functionalities that are not supported by Leaflet, just provide an abstraction for it, so if you need this kind of features, the best option if to extend one of the components depending on your needs.\n. Hi,\nThere is no divIcon option in the Marker constructor, only icon (see the documentation), it's up to you to instantiate and pass it a divIcon if you want.\n. Hi,\nIf you want to use a divIcon, you just need to pass its instance to the <Marker>, ex:\n``` js\nimport { divIcon } from 'leaflet';\nimport { Marker } from 'react-leaflet';\nconst icon = divIcon({className: 'my-div-icon'});\nconst marker = ;\n...\n```\nThere is nothing specific in this lib regarding divIcons, the properties you set in the <Marker> component are simply passed as options to Leaflet's marker() constructor.\n. I haven't used divIcons much so I don't know about their expected behavior, all I can tell is that this library does not have any behavior related to divIcons in particular, so you should refer to Leaflet's documentation.\n. Hi,\nA Circle can't contain a Marker, it can only contain a Popup.\nDepending on what you're trying to achieve, these components should be siblings or you should use a CircleMarker.\n. For this kind of case, I usually do something like this, I find it more readable:\n``` js\nrender() {\n  let circle = null;\n  let marker = null;\nif (this.props.uiState.hasUserPosition) {\n    circle = ;\n    marker = ;\n  }\nreturn (\n    \n      ...\n      {circle}\n      {marker}\n    \n  );\n}\n``\n. Thanks!\n. What are quadkeys?\nThecomponent passes its props as options to the Leaflet constructor, so any option supported by Leaflet should work the same way.\n. If this is default Leaflet behavior, it's Leaflet's documentation you should refer to.\n. You only need to add arefto thecomponent to access it from its parent, as you would for any other React component.\nYou can check [this example](https://github.com/PaulLeCam/react-leaflet/blob/master/example/events.js) that accesses the Map'sleafletElement`.\n. Have you tried mapbox-gl-leaflet?\n. I don't think you would get any performance benefit using this lib rather than Leaflet directly, it only uses React as an abstraction over Leaflet.\nIt works well with static maps, in my opinion the biggest advantage is that you don't have to switch between Leaflet objects and React components, as this lib does it for you.\nFor dynamic maps, especially if they refresh often, you'll probably want more imperative control so interact directly with Leaflet objects.\nHope this helps, don't hesitate if you have any other question! \n. Thanks but I plan to move over to Webpack for the build, I'll make it export to UMD.\n. Fixed in v0.7.\n. I think this kind of optimisation should be part of the application, not the base components like this.\n. Hi,\nThanks for the PR, could you please add tests to check the behavior when (un)mounting a LayerGroup on a Map and other layers on a LayerGroup?\n. Added in v0.8.0-rc.3, thanks!\n. Hi, thanks for the PR, I changed a few things but added this logic in v0.8.\n. Thanks!\n. Do you get any warning when using a divIcon?\nIf so, could you please provide a reproducible example?\n. You seem to be loading Leaflet with a script loader, while it should already be installed as a peer dependency of react-leaflet, so I assume your error comes from having two versions of Leaflet.\nI tested it again an I get no warning when creating divIcons using the Leaflet package.\n. Hi,\nThe layers value is simply passed to the L.featureGroup function, so it's expecting Leaflet classes, not React components.\nThe API you're suggesting for it would be much better indeed, but I don't have time to implement it with all the use/test cases, if you feel like it you're more than welcome to send a PR :+1: \n. Hello,\nNo it's not at all made compatible with Leaflet 1.0 beta, and it will probably not be until Leaflet 1.0 is released as stable.\nBeing in beta means the API can still change and I don't have time to track all the changes upstream to update this lib, I'll probably adapt it once Leaflet 1.0 hits a RC but not before.\nGood idea for the new branch, here it is in case you or anybody else has the chance to start adapting it: https://github.com/PaulLeCam/react-leaflet/tree/leaflet-1.0\n. \"+1\" noise is completely useless, but pull requests are welcome!\n. First beta released, you can install it from npm using npm install react-leaflet@next.\n. No timeline for a stable release, please use the RCs in the meantime if you need Leaflet v1 support.\n. Now released\n. Hi, it's now supported in v0.7, for Polyline and other vector layers extending the added Path class.\n. Hi,\nPlease refer to https://github.com/PaulLeCam/react-leaflet/issues/45 for more information.\n. Hi, thanks for reporting this.\nI pushed a change in RC2 that should address this issue, could you try with it?\nIf the problem persists, could you please add an example code to reproduce the issue? Thanks.\n. This is an issue with your compilation process, not this lib.\nSee the babel-loader usage documentation for example if you are using Webpack, it explicitly excludes node_modules.\n. This is not a problem, it is intended.\nThe modules made to be consumed are in lib and are exposed by the public API.\n. No, to be clear, there is nothing preventing you from extending the components as they are already exposed. It's just JavaScript.\n. Hey, no problem.\nSure, I'll publish the src folder as well in future npm releases.\n. Added in RC3 :)\n. Hi, thanks for the PR.\nIs there any particular reason for doing it as a separate component rather than adding this behavior to Map?\nI suppose the fitBounds() call could be made after the center and zoom are set, would that suit your use case?\n. I think it makes sense to have the Map component handle dynamic bounds and maxBounds props, it could then be used either using bounds or the center/zoom combination.\nI'm against adding any specific logic in the components regarding specific use cases as in my option the components provided in this lib should always be \"dumb\" ones, the \"smart\" ones being in the app.\nRegarding the case of setting bounds, center and zoom, I think the Map component would just apply all of them, it's up to the developer to use the APIs they need.\nIf you're up for it, would you mind updating your PR to add this to Map? Otherwise I'll try to experiment around it when I have some time.\n. Good idea, I added it to the readme.\n. It's a dependency of Leaflet, which is a dependency of React-Leaflet. It's up to your build process to handle these kind of requirements, not this library.\n. Hi, can you please provide a more detailed description of your issue and the associated code to reproduce it?\n. Hi,\nI fixed the lint errors, thanks for reporting.\nRegarding adding this kind of features, I don't want to add it to the \"core\" library as it would add dependencies that would not necessarily be needed.\nThe way I see it, there are 3 major options:\n1. Adding these features to the lib, not exposed in the API (importing react-leaflet module), but rather having to import from another directory (ex importing react-leaflet/plugins/CartoDBTileLayer).\n   - Advantages are that plugins would be updated with the lib, so it's easier for consumers to update. It's also easy to keep track of the plugins and to add new ones.\n   - Disadvantages are that it would require more work to maintain this lib, especially to update it with newer versions of React and Leaflet, as the plugins dependencies would also need to support these new versions.\n2. Creating a separate repository for plugins, ex react-leaflet-plugins having react-leaflet as a dependency, and same as previous option, each module would have to be loaded individually so that only the dependencies for this module would be required.\n   - Advantages is that it keeps this lib only dependant on React and Leaflet, so easier to update, while having most of the advantages of including the plugins with the lib.\n   - Same disadvantages as integrating with the lib, one plugin dependency could hold back updating others.\n3. All plugins should be separate projects.\n   - Advantages are that this lib and the plugins are loosely coupled, they can be updated completely independently. It also leaves full control with plugins authors rather than having to PR this lib.\n   - Disadvantages I can think of would be plugins discovery, but it's not a major issue thanks to npm search, and the documentation in this lib could always link to the plugins.\nMy preference really goes for the third option, the disadvantages of the other two are much bigger than the advantages in my option.\nAny thought?\n. Great, thanks!\n. Hi,\nIf you want to add multiple markers, you can simply add as many <Marker> children to the <Map> as you need, ex:\n`` js\nrender() {\n  const markers = [\n    [51.505, -0.09],\n    [51.605, -0.09],\n    [51.705, -0.09],\n    [51.805, -0.09],\n  ].map((position, i) => (\n    <Marker key={marker${ i }`} position={position}>\n      \nA pretty CSS3 popup.  Easily customizable.\n\n\n  ));\nreturn (\n    \n\n  );\n}\n```\n. What version of React and the lib are you using?\nHow can this issue be reproduced?\n. v0.7 does not support dynamic rendering of Popups, it's been added to v0.8.\n. Hi,\nThis is purely Leaflet behavior, as per their documentation, it is possible to hide it but not set its position directly in the map properties.\nI think you best option is to hide it from the map, <Map zoomControl={false} ...> should work but please let me know if it doesn't, and add the zoom control to the map yourself, as this library does not provide components for controls.\n. As I wrote in my previous message, it's possible to set this in the control options, not the map ones.\n. Hi,\nThe ZoomControl as been added to v0.9.\n. Hi,\nThanks for reporting this, I pushed v0.8.1 that fixes this.\n. Hi, this should be fixed now.\n. Hi,\nNo, this is not supported yet, probably in a future release.\n. Hi,\nI created a new branch to have the FeatureGroup work like LayerGroup: https://github.com/PaulLeCam/react-leaflet/tree/feature-group\nThe main differences from LayerGroup is that it needs to pass the popupContainer prop to its children, so that the Popups can bind to it, and support the style props, as they can be applied to its children using setStyle\nIt seems to work for a very simple use case (https://github.com/PaulLeCam/react-leaflet/blob/feature-group/example/other-layers.js#L34) but it needs lots of tests for different cases, on the top of my head:\n- What happens when you nest FeatureGroups? FeatureGroup in LayerGroup? LayerGroup in FeatureGroup?\n- Should the FeatureGroup styles override its children? If so, every time? Only if changed dynamically?\n- What happens when a child components contain a Popup?\nPlease let me know if you're playing around with this branch and have any issue and answers to these questions!\n. Hi,\nI added it to v0.9, please let me know if you have any issue with it!\n. Hi @jonboiser, thanks for asking!\nI think adding the attribution, layers and scale controls is the next priority. It shouldn't be a lot of work, just make sure they behave as expected.\nLeaflet v1 support is tricky because I want to have it as soon as it's stable, but the current betas seem to change the APIs so I'm not sure it's worth investing time on it.\n. Mostly waiting on a RC of Leaflet v1 to start adapting what needs to be, and the final v1 release to effectively version this lib as v1 as well.\n. Closing this issue, please go to the v1 release plan for more information about this future release.\n. Good idea, thanks!\n. I don't think this can work, Leaflet maintains its own state for the popup and as far as I can tell there is no way to prevent it from opening/closing a popup from the events, so the value of the prop would not match the actual popup state.\n. Hi,\nLeaflet v1 is not supported by this lib.\nIts API is not stable yet and there are still features of v0.7 that are not implemented in this lib, so this is my main focus until Leaflet v1 is stable.\n. Hi,\nIt looks like you are not including Leaflet's CSS, see the \"Preparing your page\" section in Leaflet's quick start guide.\n. Hi,\nPlease refer to the documentation for creating custom components.\nI don't know leaflet-routing-machine but it seems you're on the right path: you basically need to instantiate the Leaflet element and attach it to the provided map property. Depending on your needs, you might want to handle specific properties in your component.\nRegarding the center and zoom properties, they are not required as they do not prevent the creation of the map. This lib simply provides bindings to Leaflet, it is not meant to change its behavior.\n. Please refer to Leaflet's documentation, the center and zoom are not required to instantiate the map, though obviously they are to render anything.\nAgain, his library is a simple wrapper for Leaflet. If you have issues with plugins that work with Leaflet but not with this lib, please post them here, but in this case your issue seems to be with leaflet-routing-machine.\n. Hi,\nAs answered by @gryzzly, you can access the leafletElement property or any created element after it is mounted.\nIn your case though, I think you could simply pass add these properties when creating the map, as they are passed to the Leaflet.map() factory. See Leaflet's documentation for the available options.\nEx in your case:\njs\n<Map ... scrollWheelZoom={false} boxZoom={false} keyboard={false}>...\n. Hi,\nI'm not sure I understand the problem here, is it with React's diffing or applying the properties?\nThe dummy <div>s are simply used as containers for children elements, but they are not actually displayed so they shouldn't be used for styling.\nAll the rendering is handled by Leaflet but the diffing in the tree is made by React, so the best way to force the update of a layer is to change its key property, so that React simply replaces it.\n. The GeoJson data prop is not dynamic, so if it changes you should change the key as well to make sure it's properly updated.\nThe path options should be updated though, here is the logic handling this: https://github.com/PaulLeCam/react-leaflet/blob/master/src/Path.js#L32 \nIf it doesn't update when one of the Path options prop is changed clearly it's a bug, I'll have a look at it but I don't have so much time at the moment so could take a few days. In the meantime if you can provide a working repro it would certainly help :+1: \n. @luqmaan I wonder what is the advantage of this solution rather than changing the key prop?\nI haven't done any test, I just assumed having React remove the node and Leaflet create a new one would be less expensive than having Leaflet remove its layers, add new ones, and apply the styles, but maybe I'm wrong.\n. @ericsoco Thanks for the link, I'll add this to the next release to handle dynamic changes of the data without needing to change the key.\nI haven't had time to investigate your issue yet, but I set a JSFiddle up, if you could please use it to try to reproduce the issue when you have some time that would help!\n. Thanks for this link.\nClearly if Leaflet doesn't support setting className it won't be supported in this lib either.\n. Hi,\nWould you have a code example to reproduce the issue please?\nAlso, have you checked the behavior using Leaflet only (not this lib), as it may be the default Leaflet behavior and not something due to this lib?\n. No problem, I hope you sorted it out.\n. Hi,\nThanks for your PR but I don't want to use undocumented React APIs that could be removed at any time without warning.\nI hope this function would be added to the official API in a next release!\n. Hi,\nYou can use Leaflet's getCenter() to get the LatLng of the center of the map, accessing its instance on the Map component using its getLeafletElement() method.\n. I use master as the main development branch so it matches more the next release than the current one, but I understand it might be confusing so I'll keep it matching the latest release instead.\n. Hi,\nzIndex is not a Path option handled by Leaflet: http://leafletjs.com/reference.html#path-options\nRegarding your issue, you should check with Leaflet's documentation / tutorials, this lib does not do anything related to rendering, it just passes the properties to Leaflet.\n. Hey, thanks for the PR!\nI'll try to have a look at Leaflet's doc this week for these controls, see if there any specific cases to consider.\nOther than that I think it will mostly be about handling dynamic properties and adding some doc, but your current code looks good.\n. Thanks!\n. What do you mean by default? The default options are Leaflet's ones, this library simply passes the props to the relevant Leaflet constructor.\n. You can use the getLeafletElement() on any component to the Lealfet instance created for this component.\n. https://github.com/PaulLeCam/react-leaflet#components\n. No you can't set nested options like this in the properties, but as stated in the documentation, you can access Leaflet's map instance using getLeafletElement() on the Map component.\n. As written in the documentation, you need to pass the map property injected by the <Map> component to children components.\nEx:\n``` js\nconst MyMarker = ({ map, position }) => (\n  \n\nA pretty CSS3 popup.Easily customizable.\n\n\n);\n...\n\n\n\n```\n. What do you mean by variable and set of markers?\nAt this point it is just React, so you can apply usual patterns that work with it.\nEx:\n``` js\nconst MyPopupMarker = ({ map, position, children }) => (\n  \n\n{children}\n\n\n);\nconst MyMarkersList = ({ map, markers }) => {\n  const items = markers.map(({ key, ...props }) => (\n      \n  ));\n  return {items};\n};\n...\nclass MyMap extends Component {\n  ...\n  render() {\n    // Probably generated dynamically, but the logic is the same                          \n    const markers = [\n      {key: 'marker1', position: [51.5, -0.1], children: 'My first popup'},\n      {key: 'marker2', position: [51.51, -0.1], children: 'My second popup'},                \n    ];\nreturn (\n  <Map ...>\n    <TileLayer .../>\n    <MyMarkersList markers={markers} />\n  </Map>\n);\n\n}\n}\n```\nThe only constraint if you want to render a list in a component is to wrap it in a container, this is purely a React constraint.\nIn our case having Leaflet actually render the layers, a possible solution is to wrap them in a div with display: none.\n. Glad it helps!\nThanks for your PR, I'll merge it.\n. Hi,\nSorry for the late reply.\nIt's likely the \"load\" event is not fired because the map is already loaded when the listener is added, but as you've done in your solution, you can access the leafletElement created for the <Map> in its children, because the children are only rendered after the instance is created.\n. ref is supported as it is default React's behavior, nothing specific to it.\nAs written in the documentation you can already access the created instance for the Leaflet element.\nRegarding animations, I think the best option is to refer to Leaflet's documentation as the DOM manipulations are handled by Leaflet, not React.\n. The rendering happens in different steps:\n1. The <Map> component renders an empty <div> that will contain the map. At this point the children are completely ignored (so it's expected no ref would be bound).\n2. The Map componentDidMount() handler creates the Leaflet map instance.\n3. The Map renders its children, injecting the map instance as their map property.\n4. Children components instantiate their Leaflet instance using the provided map, that usually renders them (this is purely Leaflet rendering, React only provides the abstraction).\nSo if you are trying to access a ref of a layer in the componentDidMount() handler of a component rendering the Map, it would be undefined as only the empty <div> would be rendered at the time componentDidMount() is called.\nA very ugly workaround would be to use a setTimeout() in componentDidMount() to defer the access to the ref, but a better solution is to create a custom component to handle the specific logic you want around this component, ex:\n``` js\nclass MyCustomFeature extends React.Component {\n  componentDidMount() {\n    const el = this.refs.feature.getLeafletElement();\n    // Your custom logic interacting with Leaflet\n  }\nrender() {\n    return ;\n  }\n}\n```\n. Glad it helps!\nI haven't tried anything related to animations, but I think the best options is to use Leaflet APIs directly as they are the ones interacting with the DOM. Using a custom component would give you the most flexibility.\n. Icon and DivIcon are types, not layers, they would not provide any value as components, only overhead.\n. Hi,\nThis is out of the scope of this library, as it only provides React bindings to Leaflet, not additional features.\nI hope you'll have more luck with Leaflet documentation / plugins.\n. Hi,\nThanks for your PR but this project intends to be a simple interface for Leaflet, not implement its plugins, please read this comment for a more detailed explanation.\nAs stated in this previous comment, if you want to add this plugin as a separate project, I'd be glad to reference to it from the documentation here.\n. Hi,\nThanks for the fix, it will go in the next release.\n. Hi,\nThanks for the fix, I added it to master, it will go in the next release.\n. Published v0.10.1.\n. No feedback... I'm closing it but feel free to comment / reopen if relevant.\n. Hi,\nAs stated in the documentation, one way to achieve this is to extend the relevant components to add the handlers you need.\nI haven't used Leaflet.label or tested the code below so it may not work, but it should give you the general idea.\nFor example let's take the Polygon source, as you can see the Leaflet.polygon instance is created in componentWillMount(), using the provided props.\nIt seems with Leaflet.label you need to call the bindLabel() function on this instance:\n``` js\n// Use the same code as Polygon, just customise componentWillMount()\nclass PolygonWithLabel extends Path {\n   // Add the relevant prop types for Leaflet.label\n   static propTypes = {\n    label: PropTypes.string.isRequired,\n    labelOptions: PropTypes.object,\n    positions: PropTypes.oneOfType([\n      latlngListType,\n      PropTypes.arrayOf(latlngListType),\n    ]).isRequired,\n  };\ncomponentWillMount() {\n    super.componentWillMount();\n    // Extract label and labelOptions from props\n    const { label, labelOptions, map, positions, ...props } = this.props;\n    // Call bindLabel() as documented in Leaflet.label\n    this.leafletElement = polygon(positions, props).bindLabel(label, labelOptions);\n  }\ncomponentDidUpdate(prevProps) {\n    if (this.props.positions !== prevProps.positions) {\n      this.leafletElement.setLatLngs(this.props.positions);\n    }\n    this.setStyleIfChanged(prevProps, this.props);\n    // Eventually handle specific logic if props change\n  }\n}\n```\nDepending on your usage, you may also want to customise the componentDidUpdate() handler to update the label accordingly when the props change.\n. Hi,\nThanks for your PR. I haven't looked more at the changes in Leaflet v1 as it's still not out of beta, but it seems your PR breaks the tests, would you mind having a look at it?\n. I see, it's a tricky issue.\nI don't think replacing jsdom is really an option considering it's part of Jest, but maybe by mocking the relevant getter in Leaflet to return an acceptable value?\n. No, Leaflet is not mocked, so I think only mocking the failing method as you suggest is the best option given the constraints. Would you mind updating your PR with this change please?\n. Great, thanks!\n. Hi,\nIf you are referring to the Path options? They should be supported on all vector layers, please let me know if this is not the case.\n. Hi,\nIt's probably an issue with your Webpack configuration, make sure babel loader ignores the files in node_modules. Ex: https://github.com/PaulLeCam/react-leaflet/blob/master/example/webpack.config.js#L14\n. Hi,\nSeems your issue is with MarkerCluster, how is it related to this lib?\n. Hi,\nThanks for the PR!\nI realised the documentation may not be explicit enough about properties like this that are simply passed to Leaflet, I added links to the relevant Leaflet documentation sections.\n. This example assumes you are familiar with React and Leaflet, if not you should read their \"getting started\" guides first to make sure your environment is properly set.\n. Getting started section of the doc:\n\nIf you are not familiar with Leaflet, make sure you read its quick start guide first. You will need to add its CSS to your page to render the components properly.\n\nIt's written black on white you should setup Leaflet following their documentation, if you choose to skip this step it is not an issue with this lib.\n. Again, this library provides bindings to Leaflet, it is not a replacement for it. This documentation is not intended to replace Leaflet's one, it is meant to describe how to use this library after you have setup Leaflet (and React, and Babel, and an HTML page for that matter).\n. Here is a working jsfiddle using the UMD build, you may have better luck starting from there to adapt your code: http://jsfiddle.net/paul_lecam/q2v7t59h/\n. I can't reproduce your issue, this example using style rather than setting CSS properties is working as expected: http://jsfiddle.net/paul_lecam/w04wrb4g/\n. Thanks but this is part of Leaflet documentation, it's out of the scope of this lib.\n. Leaflet is a peer dependency set to ^0.7.0, so matching all 0.7.x releases.\n. npm install leaflet?\n. I just installed it with the following results:\n```\n\nnpm -v\n2.14.20\nnpm install react-leaflet\nreact-dom@0.14.7 node_modules/react-dom\n\nleaflet@0.7.7 node_modules/leaflet\nreact@0.14.7 node_modules/react\n\u251c\u2500\u2500 envify@3.4.0 (through@2.3.8, jstransform@10.1.0)\n\u2514\u2500\u2500 fbjs@0.6.1 (whatwg-fetch@0.9.0, ua-parser-js@0.7.10, loose-envify@1.1.0, promise@7.1.1, core-js@1.2.6)\nreact-leaflet@0.10.1 node_modules/react-leaflet\n\u2514\u2500\u2500 lodash@4.6.1\n```\nWhatever your issue is, it's most likely your environment, not this lib.\n. Thanks!\n. Yes I'll publish a new version this week-end.\n. @mariusandra I just published v0.10.2 containing you commit, thanks!\n. From the Map documentation:\n\nRefer to Leaflet documentation for more information about the properties.\n. Good idea, thanks!\n. Hi, thanks for this PR!\n\nI like the \"layer container\" approach, would you mind adding this change only as a separate PR that could be merged before this one?\nRegarding the layers control, I agree it would be nice to handle it directly as components, but I'm not sure the ControlledLayer HOC is the best way to go, as from my understanding of your code it would shadow the title and type props that could be used by the wrapped component.\nI'll experiment a bit around this to try to come up with possible alternatives that could match both React and Leaflet APIs.\n. Thanks!\n. Hi,\nI'm not familiar with rails so I don't know how it processes JS assets, but this lib is available in different formats:\n- CommonJS (the default exposed by package.json) in /lib\n- ES2015 modules in /src\n- UMD in /dist, exposing the library as window.ReactLeaflet\nDepending on your environment you should choose the most appropriate one.\n. @awe2m2n2s You can see the version of the lib in package.json and in the releases page, and using npmcdn you can specify the version you need, ex: https://npmcdn.com/react-leaflet@0.10.0/dist/react-leaflet.min.js, depending on your needs it may be more convenient than embedding the file in your project.\n. It's up to you to add the this.leafletElement, the base classes contain utilities and lifecycle handlers, but the point of extending them is to provide the relevant element.\nFor example as you can see in the ZoomControl component, the this.leafletElement is set in the componentWillMount() lifecycle handler, and then used by the componentDidMount() handler of MapControl to add it the map, making the actual ZoomControl code dead simple.\n. Yes, basically the components provided by this library are bindings to Leaflet elements, all the rendering is performed by Leaflet so if you want to render DOM elements as you would otherwise do with React, you need to do it explicitly and provide the resulting HTML to your Leaflet component.\nThe Popup component should be a good start as it's implementing this logic to render the popup contents.\n. Thanks for the feedback.\nRegarding the use of refs rather than layerContainer, it is needed because the ControlledLayer subclasses are not layers themselves, they are just container components used for lifecycle, so the contained layers need to be attached to layers created higher in the component hierarchy.\nAbout the \"default added\" prop I don't think it's possible with the current Leaflet API, the methods to add layers only support the layer and its name as arguments.\n. Thanks!\nI made a few changes in my branch, mostly around making the checked property (defaultAdded in your PR) dynamic, now released in v0.11.\n. Hi,\nI just released a new version (0.11) that makes the LayersControl API more \"React-friendly\", you can check the new documentation and a more advanced example of this new behavior that should make it much easier to manipulate LayersControl.\n. Hi,\nCan you provide a jsfiddle or similar to reproduce the issue please?\nYou can find a simple one here: https://jsfiddle.net/paul_lecam/q2v7t59h/\n. Looks like your event listener is not properly bound to the instance:\n<Map ...\n    ref=\"map\"\n    onResize={this.invalidateMap()}>\n    <TileLayer ... />\n</Map>\nis calling this.invalidateMap() on every render, not when the event is triggered, it should probably be:\n<Map ...\n    ref=\"map\"\n    onResize={this.invalidateMap.bind(this)}>\n    <TileLayer ... />\n</Map>\n. Thanks for using it, glad it's intuitive to use!\nCreating custom components implementing plugins is usually pretty easy, just a matter of interacting with the plugin in React lifecycle methods.\nYou can have a look at the documentation and possibly this similar issue for more information.\n. Hi,\nYou are probably missing dependencies (React as it looks like), make sure to load React, ReactDOM and Leaflet before this library.\nYou can have a look at the External Resources section in the sidebar of this example jsfiddle to see the dependencies included.\n. Thanks!\nI just published it as v0.11.1.\n. Hi, please refer to the creating custom components section of the documentation.\n. Hi, please refer to the creating custom components section of the documentation.\n. Hi,\nIt should be fixed in v0.11.2, please let me know if you have any problem using this new release.\n. Hi,\nI have never used this lib, or Leaflet, with so many layers so I don't know the performance implications.\nIf you can provide the simplest example possible of performance degradation between using this lib and Leaflet only, it would be helpful to try to find when the issue might be.\n. Closing this issue, please refer to #150 to track performance improvements.\n. Hi,\nThanks for your PR!\nI think this behavior is out of the scope of this lib because in your case, your application sets the height and width styles dynamically, but other style properties could affect, as well as the classes, so effectively completely implementing such a behavior would mean constantly keeping track of the container dimensions.\nConsidering it is not what Leaflet does itself, instead letting the application call invalidateSize() as needed, I think it's better leaving this behavior as part of application logic rather than implementing it in this lib.\n. The Leaflet element created by each component is accessible using the getLeafletElement() method, so you should be able to wrap your <Map> with a ref property in a parent component handling this logic.\nNote that because React renders the div containing the map before creating the leaflet element, it will only be accessible after the componentDidMount lifecycle handler.\n. Good idea, thanks!\n. Published in v0.11.3.\n. Please provide steps to reproduce / example code.\n. Hard to say what could be the issue looking at your code, but here is a working example of dynamic polylines and color: http://jsfiddle.net/mf9z320t/\nUnless there is a very particular edge case, I expect the issue is likely with your application not injecting the needed data to the components.\n. Yes, it's probably a good idea!\nFrom my understanding the context API is pretty stable for a basic use case, the issue is more about overriding keys in children.\nA possible way to abstract it in this lib would be to create getters like getMap(), getLayerContainer() etc. that could either get the value from the context (new behavior) or the props (legacy behavior), so the transition could be smoother.\nEventually if the context API is no longer relevant, the internals of the lib could also change as long as the getters are consistent.\n. Now implemented in v0.12.\n. Thanks for reporting this issue, it's been fixed in v0.11.4.\n. Thanks!\n. Thanks!\n. Hi,\nThis code is only an example, it is not meant to replace the getting started section of the documentation.\n. > If you are not familiar with Leaflet, make sure you read its quick start guide first. You will need to add its CSS to your page to render the components properly.\nThis is literally the first line of the getting started section of the documentation, before the code sample that is simply an adaptation of Leaflet's one. I'm all for making the documentation better, but I can't help if people choose not to read it.\n. Hi,\nPlease follow the issue template to report issues.\n. Closing as it seems due to bad configuration/environment setup, not an actual bug in the lib.\nPlease make sure you go through all the steps of Leaflet's getting started guide if you encounter this kind of problem.\n. Hi,\nThanks for reporting this, it should be fixed in v0.11.5.\n. Hi,\nSorry but it's not something I'm going to investigate this, as needing 10k markers to be visible is likely to be a very rare edge case.\nFuture changes notably by using context instead of props as suggested in this issue would likely improve the performance of this lib, but no matter what it is an abstraction on top of Leaflet and therefore comes as a certain cost.\nRegarding your use case, do you absolutely need to have all these markers visible rather than reducing them to the visible bounds?\n. Hi,\nThanks for your PR, indeed the initial check for opacity and zIndex would make it fail for 0. I removed this check in v0.11.5 so it should work as expected now.\n. Hi,\nThe CanvasTileLayer simply passes its props to Leaflet tileLayer.canvas() function, please refer to its documentation from Leaflet.\n. Hi,\nThe Lodash dependency matches the latest v4 release, if you have an older version installed you should always be able to update it via npm.\n. Hi,\nThis is a pretty self-explanatory error from React: one of the components you are trying to use is not valid, please make sure you are correctly importing the components you are trying to use.\n. Hard to say just from the imports, I suppose if you console.log() each component you would find one is undefined.\n. Hi,\nIndeed, the style prop should be updated as expected if it is a function, that should be fixed in v0.11.6.\n. Hi,\nLeaflet maintains its own state of the map, and this lib simply uses components and props as an abstraction on top of Leaflet, so it's up to your application to work around Leaflet's model.\n. Hi,\nCould you please provide a jsfiddle to reproduce the problem?\nThanks.\n. OK if I understand the problem correctly I think the issue is that you are trying to control the opening state of the popup in your component while also letting Leaflet control it itself, it can't work as you expect.\nEither you can let Leaflet handle this opening state by itself, and use its events to reflect this state in your app, or you need to prevent Leaflet from handling this state itself, and drive it in your component.\n. @jgimbel I haven't use these so I don't know how Leaflet handles them, but Popup has the closeButton and closeOnClick options that seem to have the wanted behavior.\n@benzen yes it's quite tricky sometimes to make sure the state of the app is consistent having Leaflet maintain its own, but I find it easier to always consider it as the source of truth regarding the actual display of the map.\n. Yes these are warnings from UglifyJS optimisations, is there a problem with it?\n. Updated in v0.12, the warnings are now hidden.\n. Hi,\nI'm closing this issue as it's not directly related to this lib but a broader question about asynchronous data management and rendering with React. There are different resources on this subject but it mostly depends on your application needs and the stack you are using.\n. Hi,\nYou probably want to use React's lifecycle methods to update the Leaflet element when the props change, this is pretty much how this entire lib works.\nThe MapControl component should be a good example to reproduce or directly extend depending on your needs.\n. Hi,\nIndeed it's a bug, thanks for the detailed issue, it helped a lot!\nI just published v0.11.7 that should solve the issue, if you can give it a try?\n. It seems to be an issue in Leaflet itself and not caused by this library, so you'll have to wait for a fix upstream or implement a workaround yourself.\n. peerDependencies does not constraint you in any way using npm 3, if you want to use another version you can set it in your own package.json, but this library is not made to be compatible with Leaflet v1 yet, so it won't be supported until then.\nSo you can either implement a fix in your application code or wait for a release compatible with Leaflet v1, but I don't plan on implementing a fix in this lib itself as it's an issue from Leaflet.\n. Hi, please refer to the creating custom components section of the documentation.\n. It really depends on your needs and the plugin you want to implement, but it's usually about implementing React's lifecycle handlers. You can have a look at the Rectangle component for a very simple example.\n. Thanks!\n. Not an issue, I just forgot to update Leaflet's CSS path to v1 in the examples I ran.\n. Hi,\nThis library only provides bindings between React and Leaflet, no specific behavior.\nPlease refer to Leaflet documentation or file an issue following the template if there is something missing in this lib.\n. Hi, \nPlease follow the issue template to report an issue, preferably with an example jsfiddle or similar.\n. Leaflet maintains its own state independently of React's one, so you need to keep track of it using the relevant events if you want your component's state to be current with the map's one.\nIn your case, the center prop that you set twice is the same as far as React is concerned, so it does not call the Leaflet setter, this is the expected behavior. You can always access the created Leaflet.Map instance using this.leafletElement in the Map component instance, and use it's API as you need.\n. Hi,\nI want to keep this project as a simple interface for Leaflet and not its entire ecosystem, so I find having plugins as other npm modules a good solution.\nI added a plugins section to the documentation, please feel free to send PRs to update this list!\n. Hi,\nThanks for reporting this, indeed it seems L.Control.Layers tries to add layers to the map when it gets updated after being removed, but the map itself is removed as well so it breaks.\nI pushed a fix in v0.12.1 that should address the issue, please let me know if it works in your case.\n. Sure, good idea!\nI'm not very familiar with stack overflow, any idea of the process to have a tag added to it please?\n. Great, thanks @bigsassy!\n. Yes I added it.\n. Hi,\nThe map's center is applied as expected, there is no \"automatic\" center, it's up to your application to set it.\nYou probably want to use something like Leaflet's latLngBounds() to create the bounds to inject to the map.\n. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.\n. Thanks!\nCould you please remove the code related to generating an id for the map? It should not be needed anymore as the L.map() factory accepts a DOMElement in Leaflet v1.\n. Oh yes sorry I forgot to push an update to the test, should be OK now.\n. Thanks!\n. Hi, you can already use DivIcons, you simply need to generate them from Leaflet, ex:\n``` js\nimport { divIcon } from 'leaflet'\nimport { Marker } from 'react-leaflet'\nconst icon = divIcon({className: 'my-div-icon'})\nconst marker = \n```\n. Thanks!\n. Added in beta 2.\n. v1.0.0 RC 1 released, still under the \"next\" tag.\n. v1.0.0 RC 2 released, please try it out!\n. Preferably as new issues please, make sure to indicate the versions of the libraries you are using, thanks!\n. v1 is here! https://github.com/PaulLeCam/react-leaflet/releases/tag/v1.0.0\n. Hi,\nThanks for the detailed explanation.\nI think the issue comes from the fact you are calling bringToBack() in the ref handler of Polyline instead of the componentDidMount() handler of your containing component, so the Map is not initialised yet, see https://jsfiddle.net/m5gatktz/4/\n. This is working exactly as expected, you are setting the zoom property in your render() method so it's up to you to handle zoom changes events if you want to keep its value updated.\n. Hi,\nSorry I don't use Mocha so I don't know about its setup, if it's indeed an issue with the library please provide a jsfiddle or similar with a running example, not a specific environment like Mocha.\n. This is a client-side library so yes, sorry but I will not investigate issues specific to Node and jsdom.\nIf you can find a solution to your issue I would gladly review a PR but unless it is something that can be reproduced in a client-side environment, I won't focus on it myself.\n. Hi,\nThere is no specific logic in this library regarding the ordering of layers so please refer to Leaflet documentation to check its behaviour. If the behaviour in this lib is indeed no matching Leaflet's one please provide a jsfiddle or similar.\nRegarding className changes, it should be supported so again, please provide an example to reproduce the issue.\n. Indeed this library is a wrapper, and React does not do the rendering, it's just an abstraction over Leaflet.\nIf you want to add specific behaviour, you can always create custom components to implement specific logic but they would need to do so calling Leaflet APIs anyways.\nIn your case, you can probably also recreate the entire <LayerGroup /> when its contents change by changing its key, I suppose that would ensure on Leaflet's side the contained layers are in order.\n. All these limitations are described in the documentation, and this library's purpose is only to provide an abstraction on top of Leaflet using Leaflet APIs, not to change them in whatever way people think is best.\nIf the components provided don't support your needs, you can always create custom ones and call Leaflet's APIs as needed.\n. I can't reproduce this issue in the repo's examples and this jsfiddle so it's probably an issue with your environment, please make sure you haven't skipped any step of the getting started guide.\n. Hi,\nPlease make sure to read the documentation, especially the how it works section that seem relevant to your issue.\n. Sorry if it's not explicit enough in the docs but this part about the lifecycle means that when your component's componentDidMount() handler gets called, only the containing <div> for the map is rendered and the Leaflet map is just being created.\n\n\nThe top-level Map renders an empty <div> to contain the map.\nThe Map's componentDidMount() handler instantiates a Leaflet.Map() for the created <div> with the component properties and sets this instance in state. This instance is made available in the context.\nThe Map's render() handler is executed again, this time rendering its children components.\n. Thanks for reporting this, should be fixed in beta 3.\n. Hi,\nYou can access the instance of the created Leaflet element for any component after it is mounted using the component's leafletElement property.\n. Sorry I don't get your issue, the behavior you expect is not the one of this library and it's not supposed to be.\nIf you want to implement additional logic for rendering popup contents, you should create a custom component.\n. As long as the DOM container is the same, ReactDOM.render() handles the diffing and unmounts any previously rendered component so if you get any memory leak, I'd assume it's more likely coming from you app. This library only calls ReactDOM.render() for the contents of the Popup, there is no extra logic around it.\n. The DOM rendering is performed by Leaflet, not React, so it's necessary to call the relevant Leaflet setters when the props change.\nThis library does not make assumptions or rendering optimizations itself, it only acts as an interface for Leaflet.\n. Apparently IE <= 10 does not support proto so IE <= 10 isn't be supported by React-Leaflet from v0.12\n. If it works with babel-polyfill, why don't you add it to your app?\n. Fixed in latest commit, thanks for reporting.\n. Hi,\nThanks for this PR, do you have a reference of this support by Leaflet please?\n. Thanks!\n. Released in v0.12.2\n. Hi,\nSeems like a good idea, I won't have time to work on this for the next few weeks and I don't think it needs to be released in v1.0 but seems like a good addition to a minor release.\n\n\nA few things I can think of:\n- This new Pane component should only support the className, name and style props, no event handling or other hacks people could try to use it for, it would become very hard to maintain an expected behavior.\n- The name prop should be optional in React-Leaflet and can be auto-generated, ex using uniqueId() from Lodash as it's done in the Map component.\n- Does Leaflet allow to override its existing panes?\n  - If so, we could have ex <Pane name='overlayPane' style={{zIndex: 620}} /> effectively changing the z-index of all overlays dynamically, assuming Leaflet applies the updates.\n  - One thing to be very careful with is about removing such a Pane, would Leaflet reset its own?\n  - If not supported or no way to properly remove the Pane, the existing Leaflet names should be blacklisted (= the component has no effect and displays a warning).\n- Regarding the implementation, it's likely very similar to the Map component:\n  - The Pane goes through a first render where it needs to render the <div> with a reference and prevent the children from rendering (as the pane wouldn't be set in context yet), as done in the Map component.\n  - In its componentDidMount() handler, the Pane needs to call map.createPane() and set the created pane in its state, to trigger a re-render. Again, same logic as the Map component.\n  - Subsequent renders should display the children components, now having access to the pane in context exposed by the Pane. \n. Closing as now in PR https://github.com/PaulLeCam/react-leaflet/pull/227\n. Hi,\nAs your jsfiddle is working it's most likely an issue with your environment, make sure you've followed all the installation steps.\n. Thanks!\n. Hi,\nThanks for reporting this issue and the code samples, it should be fixed in v0.12.3.\n. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.\n. Thanks for this PR!\nI'll review it in more details later, but a few things already:\n- Please don't add the transpiled files, it makes the changes more noisy to review.\n- Please make sure ESLint checks pass (see Travis failure).\n- Could be done in a separate PR, but could you please also add docs + at least one example usage?\nThanks!\n. @rjdestigter thanks for the changes and explanations.\nMy only major concern remaining is with allowing to override an existing pane, whether it's a default Leaflet one or another one already created, but I'm happy to merge this PR as-is and work on it myself if you prefer?\n. Thanks for this PR!\nI'll need to play a bit with it to make sure I catch possible edge cases before releasing, but hopefully it should make it to the next RC.\n. Hi,\nThanks for this PR but it should no longer be necessary to set the default icon path with Leaflet v1.0.0.\n. Good idea, thanks!\n. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.\n. Thanks!\n. Please follow the issue template and make sure all the boxes are checked before posting an issue.\n. Thanks!\n. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.\n. Good idea, added to v1.0.0-rc.2.\n. v0.12.x of React-Leaflet only supports Leaflet v0.7.x, please use the v1 RC if you want support for Leaflet v1.\n. This is documented in the components section\n. Hi, please refer to the creating custom components section of the documentation.\n. v0.12.x of React-Leaflet only supports Leaflet v0.7.x, please use the v1 RC if you want support for Leaflet v1.\n. The path works fine with Leaflet v0.7.x, please check you're using compatible versions of Leaflet and React-Leaflet.\nIf the issue persist please provide an example using jsfiddle or similar.\n. What version of the library are you using please?\nDynamic props for WMSTileLayer are only supported in v1.0.0-rc.2.\n. This seem to be an issue with mocha/enzyme, same as in https://github.com/PaulLeCam/react-leaflet/issues/204, as it works as expected in browsers.\nIf you have a fix for it please open a PR but I won't spend time on this myself.\n. Yes, good idea. I added support for dynamic url prop in v1.0.0-rc.3.\nRegarding the issue with unsetting other parameters, I think that should be handled by Leaflet directly so I'd rather not implement custom logic here. If you need to clear the layer you can always give it a different key.\n. There is nothing preventing you from using whatever icon you want.\n. <Marker icon={<MyCustomIcon />}> ... </Marker> can't work as <MyCustomIcon /> would return a React Element, not a Leaflet Icon class, so please use the alternative that suits you the most.\n. Hi,\nThanks for this PR, looks great!\nA few things:\n- Could you please change the base branch to next? It's the branch I'm currently using for v1 RCs so it is more up-to-date than master. If it's too much trouble no worries I can merge to master first.\n- Could you not add the compiled files, just the source ones are fine.\n- Not sure this rule is properly unforced by ESLint but could you please remove semicolons where not necessary?\nThanks!\n. Great, thanks!\n. These are not dynamic props, it's expected they don't get updated.\n. It is documented here: https://github.com/PaulLeCam/react-leaflet/blob/master/docs/How%20it%20works.md#component-properties\n. Hi!\nIt is used to handle nesting of layers, as the components created do not alter the DOM themselves (they pass props to Leaflet, that handles the DOM manipulations). You can see it used in this component, extended by most others.\nI don't know about the performance cost of these empty divs, but if you have any idea/data I'm interested. One simple solution to reduce the number of divs would be to check if the children of a component are in an Array or not, and only wrap in a div in that case, but that means extra work in render() for things that are not displayed anyways so I don't know what is best.\n. Yes that's what I was thinking, I'll update this for the next release if I don't find any edge case.\n. Yes, GeoJson becomes GeoJSON in v1 to mirror Leaflet's change, this is indicated in the release notes: https://github.com/PaulLeCam/react-leaflet/releases/tag/v1.0.0-beta.1\nRegarding onEachFeature, please post a new issue following the template and provide an example jsfiddle or similar. \n. Leaflet changed the way it loads image assets based on the CSS URL, please refer to their documentation as there is no specific logic regarding the CSS and assets in this lib.\n. Closing as it's not an issue that can be fixed in this lib. Hi,\nIf you want to access the Map instance created by Leaflet, you can do it using the leafletElement of the Map component after the componentDidMount() handled is triggered, ex:\n``` js\nclass MyMap extends Component {\n  componentDidMount () {\n    const map = this.refs.map.leafletElement\n    map.panTo(...)\n  }\nrender () {\n    return ...\n  }\n}\n. Thanks!. Thanks!. Thanks!. Hi,\nThe `center` prop should not be a `Leaflet.LatLng` but a plain array of object, as defined in the [PropTypes documentation](https://github.com/PaulLeCam/react-leaflet/blob/master/docs/API.md#proptypes), please check if the problem persists when using one of these formats.. Please follow the issue template.. Thanks for reporting this, should be fixed in v1.0.2. Not preserving the context is the behavior of `ReactDOM.render()`, so this is expected behavior.\n`unstable_renderSubtreeIntoContainer()` is very explicitly labelled as \"unstable\" so I don't think it should be used in this library.. Please refer to the documentation about [creating custom components](https://github.com/PaulLeCam/react-leaflet/blob/master/docs/Extending.md#creating-custom-components).. As written in [the documentation](https://github.com/PaulLeCam/react-leaflet/blob/master/docs/Components.md#tooltip), the `<Tooltip>` contents are rendered using `ReactDOM.render()`, which does not propagate the context from its container.. It's not supported out of the box, but you could investigate Leaflet plugins.. I think the main problem is that creating and updating the Leaflet element is done directly in the React lifecycle handlers, while it should be abstracted from it.\nI started to refactor the library in [the split-logic branch](https://github.com/PaulLeCam/react-leaflet/tree/split-logic) to extract the element creation as `this.leafletElement = createLeafletElement(props)` and update as `updateLeafletElement(fromProps, toProps)`, I still need to run more tests around it but if you want to try out this branch, it should be stable enough.\n. I just published the changes from this branch in v1.1.0. Yes it's an issue that it's not working like this already, thanks for reporting it.\nI just published v1.0.3 that should address the problem, please try it out and let me know if it works as expected in your case.. Thanks!. This is the expected behavior, as the rendering is done by Leaflet, not React. It's up to the applications to implement the logic they need on top of it.. The components tree changes are handled by React and the rendering (and therefore ordering) of layers is done by Leaflet, so if some layers change while others don't, React will only add and remove the relevant ones.\nIf your app needs a specific ordering, then using the `key` props can be an option to enforce components being added or removed even when their other props don't change, but if it's just a display concern, a better solution is likely to render the layers using a different z-index as necessary.. Yes looks like a good solution.. Hi,\nThanks for your PR but this is out of the scope of this library, this kind of feature should be added to apps or as an external plugin as it's not a core Leaflet feature.. I wonder what is your use case for multiple children in `Marker`?\nIt's not directly supported by this lib as `Marker` can only optionally have single `Popup` child.. Well seems to me the actual problem has nothing to do with this lib, it doesn't seem like the right place to fix it.. `<Marker>` is a React element, not an HTML one. The expected behavior is that it can optionally contain a single `<Popup>` element, if you're application is not respecting this behavior, it would not work as expected.. Again, `children` has nothing to do with HTML, I think you're confusing concepts here. The `childrenType` is a generic PropType for components that may handle children nodes, it's not a representation of what children are supported and how.\nIf anything, this seems like a documentation issue to indicate what children are supported, so in the meantime please refer to Leaflet documentation about the relevant elements, as this library aims to provide the same support for children layers and controls.. If you are referring to something like the `<Provider>` component in react-redux, no it doesn't.. I am not the author of react-leaflet-heatmap-layer, so this is something you should report in the relevant bug tracker, not here.\nThe added `createLeafletElement()` does not break any public API, but requires changes if you are using internal ones, as documented in the [upgrade guide](https://github.com/PaulLeCam/react-leaflet/blob/master/UPGRADING.md#v11).. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use [the `react-leaflet` tag in StackOverflow](https://stackoverflow.com/questions/tagged/react-leaflet) for general questions about it.. They are, [these components are extracted from `LayersControl`](https://github.com/PaulLeCam/react-leaflet/blob/master/example/components/layers-control.js#L13).. Thanks!. Please follow the issue template and make sure all the boxes are checked before posting an issue.. Thanks!. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use [the `react-leaflet` tag in StackOverflow](https://stackoverflow.com/questions/tagged/react-leaflet) for general questions about it.. I'd suggest looking for existing [npm packages](https://www.npmjs.com/search?q=react-leaflet) or [creating it yourself](https://github.com/PaulLeCam/react-leaflet/blob/master/docs/Extending.md#extending) if you do not find an existing plugin.. As [documented by Leaflet](http://leafletjs.com/reference-1.0.0.html#layer-popupopen), these events are exposed by the layers containing popups, not the popups themselves. This also [matches the implementation](https://github.com/Leaflet/Leaflet/blob/master/src/layer/Popup.js#L114) so I wonder what is the purpose of your PR because it seems to me it would trigger these callbacks when any popup gets opened or closed, which would defeat the purpose of adding them on a single popup in the first place.. Hi, please refer to the [relevant section of the documentation](https://github.com/PaulLeCam/react-leaflet/blob/master/docs/API.md#events).. Hi!\nThanks for reporting this, should be fixed in latest commit, using `L.Evented`.. `L.Mixin` is not used anymore in this library, please check the behavior without any Leaflet plugin.. Leaflet.Label is deprecated since Leaflet v1 includes it in the core as Leaflet.Tooltip, which is supported in this lib with the `<Tooltip />` component.\nYou can see it used in [this example](https://github.com/PaulLeCam/react-leaflet/blob/master/example/components/tooltip.js), I don't think you need a custom component for this use case.. There was a bug preventing `Marker` from having multiple children, that should be fixed in v1.1.1 so your codejs\n\n\n{item.name}\n\n\n{item.name}\n\n\n``\nshould work as expected after you upgrade to the latest version.. Please open a PR to add it.. You can refer to the [documentation regarding creating custom components](https://github.com/PaulLeCam/react-leaflet/blob/master/docs/Extending.md#creating-custom-components), it should work as documented.\nAssuming you've added theL.control.watermarkpresented in Leaflet's documentation, porting it to this lib would work the same way as other controls implementations, such as the [ZoomControl`](https://github.com/PaulLeCam/react-leaflet/blob/master/src/ZoomControl.js), ex:\n```js\nimport L from 'leaflet'\nimport { MapControl, PropTypes as LeafletPropTypes } from 'react-leaflet'\nexport default class WatermarkControl extends MapControl {\n  static propTypes = {\n    position:  LeafletPropTypes.controlPosition,\n  }\ncreateLeafletElement (props: Object): Object {\n    return L.control.watermark(props)\n  }\n}\n```. > @PaulLeCam thanks a lot for your reply! I tried what you suggested and it worked like a charm. Also I just wanted to mention that you did an outstanding job porting LeafLet to React. Your component works so smooth.\nThanks!\n\nI have few other questions about the example. I assume that I would need to extend L for any new custom control I want to create (e.g. L.control.myOtherGreatControl). Or I can put all this logic into createLeafletElement() ?\n\nYou can have the logic you want in createLeafletElement(), as long as it returns a Leaflet instance having the expected APIs for the element type (ex don't use a layer as a control).\n\nAlso noticed that code <WatermarkControl position=\"bottomleft\" /> would work. But then controlPosition would not (according to https://github.com/PaulLeCam/react-leaflet/blob/master/docs/API.md#proptypes)\n\nWhat do you mean by controlPosition not working?\n\nDo I need to extend componentUnmount() for every component or react-leaflet will take care of that? (once again reading doc here https://github.com/PaulLeCam/react-leaflet/blob/master/docs/How%20it%20works.md#lifecycle-process but not sure if map removes layer for custom components)\n\nYou only need to extend it if you have additional logic, for example if you added custom event listeners that need to be removed.\n\nTo be honest I find documentation very dry and cryptic. I re-read it multiple times and tried few different things until wrote a message here. Maybe it is just me, but a separate page even with this example, possibly another very simple example of some custom control counter (or other dynamic changing property on a map) could be so beneficial for anyone who wants to use react-leaflet.\n\nPlease don't hesitate to send PRs for anything you feel could be improved!. Please don't hesitate to send a PR for any change you feel would make it more explicit.\nAlso, please note this documentation assumes the reader is already familiar with React and Leaflet, both libraries have relatively large APIs and different concepts that are specific to them, not React-Leaflet.. Hi,\nCould you provide the similar demo with Leaflet only please to compare the behavior?. Hi, thanks for all the details, it helped a lot!\nI don't know what's the exact cause of the issue, as there is no logic trying to alter Leaflet's one, but I pushed a workaround to master that makes all tile layers inherit the maxZoom and minZoom properties from the map.\nCould you please try the code from the latest master and check if it solves your issue?. Now published in v1.1.2.. Hi, please refer to the creating custom components section of the documentation.. Please try upgrading to v1.1.3 to see if it fixes the issue.. Yes good catch, I updated the config in v1.1.3 so it should be back to smaller imports.. Please try upgrading to v1.1.3, it should fix the issue.. Thanks for reporting this, should be fixed now in the jsfiddle.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.. Thanks for reporting this, should be fixed in v1.1.4.. These values are provided by the context, not the props, see this section of the documentation. Please provide steps to reproduce, with a jsfiddle or similar (you can use this one to get started), not a complete project.. Thanks for your PR but this is not a typo, geoJson has been replaced by geoJSON in Leaflet v1 (though the geoJson still works as an alias to geoJSON).. Yes, please make sure you are using Leaflet v1+, react-leaflet v1 is not compatible with previous versions.. Good idea, thanks!. Yes, it's always a nice feature to have!\nIt's now published in v1.1.5.. Hi,\nThe leafletElement is already defined in the Marker instance (cf the MapLayer implementation), so you can access it using the ref like any other element, ex:\n```js\nclass MyComponent extends React.Component {\n  bindMarker = (ref) => {\n    if (ref) {\n      console.log('marker element', ref.leafletElement)\n    }\n  }\nrender () {\n    return \n  }\n}\n```. Sorry I don't get what you mean by \"Marker will have leafletElement from start\"? The Leaflet element is created by the Marker component itself when it's about to mount, that how everything else works in this library.\nIf your problem is getting multiple markers, no need to clone the element, you can simply adapt the bindMarker() handler, ex:\n```js\nclass MyComponent extends React.Component {\n  markers = []\nbindMarker = (ref) => {\n    if (ref) {\n      this.markers.push(ref.leafletElement)\n    }\n  }\ncomponentDidMount () {\n    console.log('markers', this.markers)\n  }\nrender () {\n    return (\n      \n\n\n\n    )\n  }\n}\n```\nIf you need to access the markers before componentDidMount(), I don't think this will be possible directly, in that case you should create a custom component using Leaflet directly to implement the logic you want.. Yes that's the way React works, as far as I know. Seems to me the problem you're having is about accessing React instances, not the actual Leaflet element.. Hi,\nI don't think it is possible to do what you want, there seem to be some confusion between the React elements and instances, because when you iterate over this.props.children from your containing component instance, you're iterating over the React elements, not the created instances. That's what refs are for, they allow to get access to the instance.\nI don't know of another way than cloning the elements before rendering to dynamically inject extra props, that's the way it's done in the LayersControl component for example, as long as you want to use the provided Marker.\nAn alternative could be to create a custom Marker component that would use a context function injected by the MarkerCluster to notify it when it gets (un)mounted, this way it wouldn't need to clone the children.\nSorry if it's not the answer you expect, I understand the problem as I've been through it notably to implement the LayersControl so if there is a better way to do this I'd like to know, but it's the only one I found.. The Popup contents are rendered using ReactDOM.render(), which does not preserve the context from parent components. It's simply React's behavior so it's up to your application to inject this context if needed.. Sorry I don't get what is your issue?\nIf it is having to import Leaflet, it is the expected behavior, this library is a wrapper around Leaflet, not a replacement for it.. These are the props handled by React-Leaflet itself, as there can be additional logic related to them, but any other prop is passed to the Leaflet.map() factory, as you can see here.. I don't know what doc you're referring to, because CircleMarker is documented as such: https://github.com/PaulLeCam/react-leaflet/blob/master/docs/Components.md#circlemarker. Hi,\nIf it's not supported by Leaflet directly, it won't be by this library either, but you can easily create custom components to extend it, as it is notably done by plugins.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.. If it's not supported by Leaflet I don't plan on supporting it in this library either. You can always wrap the <Map> in a containing <div> is you need extra CSS rules.. Please refer to Leaflet's documentation, there is the isOpen() method that seem to provide what you need.. As far as I know It's not something supported by Leaflet itself so it won't be implemented in this library either, but you can always create a custom component to implement the logic you need.. I understand what you're asking but this is out of the scope of this library.\nOne important thing to consider is that Leaflet maintains its own state and handles the interactions with the DOM, React only provides the component abstraction, see the \"how it works\" section of the documentation for more information.. Thanks!. Please provide an example using a jsfiddle or similar, I think the issue you're having is that you're mutating the positions array rather than providing a different one.. That's my previous comment: you're mutating the array rather than cloning it, so this is the expected behavior.. Thanks!. Please follow the issue template.. The behavior you're having is the expected one, see http://leafletjs.com/reference-1.0.3.html#map-closepopuponclick. Good idea, thanks!. Should be fixed in v1.1.7 thanks to your PR.. Good catch, thanks!. You need to add these dependencies to your package.json, cf https://github.com/PaulLeCam/react-leaflet/blob/master/docs/Getting%20started.md#using-npm-or-yarn. Thanks!. Now published in v1.2.0. I don't think there should be special cases, it leads to misleading implementations, but I added whenReady in v1.2.0.. Thanks but this is already indicated above on the same page, I can't help it if people decide not to read it.. Thanks for your PR but I don't like the idea of changing the expected behavior of Leaflet handlers. Instead, I added a whenReady prop to Map in v1.2.0 to hopefully cover the use case.. This is the expected behavior, as documented.. You can set an unique key on the <GeoJSON> element every time you want it to be changed. In practice this will cause the existing layer to be removed from Leaflet and a new GeoJSON layer to be created with the provided data.. There is nothing specific about it, it's just React behavior.\nPut a different key on an element and it will be updated, in this case <GeoJSON key=\"whatever\" data={geojson} /> for example.. I don't do support by Twitter, please use StackOverflow if you have questions regarding using the library.. I don't think there is anything specific in this library that would cause this behavior, as your described it's likely related to the issue you referenced to in Leaflet itself.. Your jsfiddle is using an outdated version of the library, please open another ticket respecting the issue template if the problem exists in the latest version.. Fixed in v1.2.1, thanks for reporting this. Sorry I'm not sure I understand what you're asking.\nThis library doesn't \"force\" or basically \"do\" anything, it simply abstracts Leaflet APIs. If you want to use options provided by Leaflet, you can likely do so by providing the relevant props, otherwise it's logic you'll have to implement in your app.. Please check the viewport and onViewportChanged properties added in v1.3.0 as they can provide a simplified way to handle this. viewport changes are compared by reference so it can be an easy way to reset the map's position.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.. Sorry but I have no way to reproduce this so please open a PR with a fix if you have one.. Your jsfiddle is using an outdated version of the library.. I don't mind reopening it but I have no way to reproduce it, so please open a PR if you have a fix.. You seem to be using an old jsfiddle as reference with outdated dependencies, the code from your gist works as expected in webpackbin: https://www.webpackbin.com/bins/-KmT3ODX5UKFZuZ6ehVt. Please open a PR with a fix if you have one but I can't reproduce the issue.. I didn't notice at first but your jsfiddle is using an outdated version of this library, please make sure you respect the issue template instructions rather than blindly checking the boxes. . There is additional logic to onViewportChange(d) so that it doesn't get fired when the map is being updated. If you don't have similar logic in your app debouncing onMoveEnd in some way, or at least checking if the values changed, it's likely you get in an infinite feedback loop of having onMoveEnd triggered as a result of setting the position.. This is out of the scope of this library, it's up to your application to handle this.. ref works as expected, whatever issue you're having is most likely coming from your code, please provide an example using webpackbin or similar if it's not.. Thanks for the detailed report, should be fixed in v1.3.1.. Thanks!. Only the required Lodash functions as loaded, as you can see in the generated files.. Please follow the issue template and make sure all the boxes are checked before posting an issue.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.. Please follow the issue template and make sure all the boxes are checked before posting an issue.. This is the expected behavior, please refer to Leaflet's documentation. Please follow the issue template, that includes reading the documentation.. Please only check the boxes if you have actually done what they say... this is the expected behavior, as documented.. Yes, it's not supported as a \"dynamic property\" as documented in the link above, so there is no logic to update the value from the Map's props to the Leaflet element. . Build systems are out of the scope of this library, it's more likely an issue with your configuration than anything to do with this library.. Yes good catch, thanks for reporting this!\nIt should be fixed in v1.4.1, please give it a try.. There is nothing magic about it, the props are simply passed as options to the relevant Leaflet factory, ex https://github.com/PaulLeCam/react-leaflet/blob/master/src/Map.js#L98\nmaxBoundsViscosity works as expected, whatever issue you're having is likely from your end, please make sure you have actually followed the steps of the issue template before checking the boxes, or at least use WebpackBin to provide an example.. Please refer to Leaflet's doc, Marker expects a Leaflet.Icon to be provided as icon, not a string.. As I wrote in my previous comment, you need to use Leaflet.icon, please refer to the docs.. There is no Map rendered in your example, please use the reference WebpackBin to reproduce your issue.. You example is still breaking, whatever problem you're having doesn't seem related to this lib. . I don't know why you're expecting this behavior, as far as I know it's not documented anywhere.. As indicated part of the issue template checklist, make sure to read the technical considerations.. Thanks for taking this on, looks great!\nI'll try it out this week if I find some time, at worst this week-end.\nRegarding lib being in the repository, it's only for convenience of being able to pull specific branches from GitHub and consume them directly, I agree it's not needed so much and it doesn't seem to be common practice so I don't mind getting rid of it.\nIs there any reason for not including the babel-runtime plugin in the es build? Is it because it is assumed it will be processed by the app's build system anyways?\nAlso, at the moment the src folder is exported to npm so that the source can be consumed directly, would it still be useful or does the es export completely cover this possible use case?\nThanks!. Whao that's great, thanks!\nI originally added babel-runtime to avoid the repeated helpers definition in all the modules, but if in the end the added runtime size is larger better no have it indeed!\nRegarding the folders let's add dist and lib to the .gitignore and src to the .npmignore assuming the added es folder covers the use case, it should make things cleaner.\nWith the changes to the .babelrc file, do the webpack.config.babel.js in the examples folder still work or should it be changed to CommonJS as well please?\nGreat job on improving the UMD builds as well! Do you think using Rollup instead of Webpack would make sense as well, or provide more benefits?\nWebpack could still be used to run the examples and have Rollup for the UMD builds if that makes sense?. One other thing I'm thinking could be good to improve tree shaking would be to use lodash-es instead of lodash, possibly using a plugin to replace the imports automatically as react-redux is doing?. It looks great!\nI'll try it out a bit this week-end before merging to master but I can't see of any issue with the changes, thanks for this PR!. Thanks for your PR, it's great changes!\nI'll probably make a new release in the next few days, I'm working on updating the types to match the changes in Flow 0.53 so when it's done it should be good to go.. Thanks!\nYes I haven't changed this setup since I added it, great to have it fixed!\nCould you update your PR to resolve the conflicts with master please?. Thanks!. I removed setting the maxZoom and minZoom from map in GridLayer in v1.6.1, could you please check if it solves your problem?. Thanks for reporting this, should be fixed in v1.6.1. I think the solution might be to do\njs\nimport { GeoJSON as LeafletGeoJSON } from 'leaflet'\nimport type { LatLng, Layer } from 'leaflet'\nto work around the problem, I'll check it when I have some time later today and try to push a fix.. Thanks for investigating this and sorry for the trouble, it should be fixed now in v1.6.3.. I don't know how Flow handles lints in libraries like this, but it doesn't return any error with the config used in this repo, so you'll probably need to update your own config.. This is the expected behavior for this library, the same way the React elements get rendered when the popup opens, they get unmounted when the popup closes. This is simply a trade-off of supporting React elements as popup contents.\nIf you want to avoid this behavior, you can create a custom component implementing the logic you need.. Sorry I don't get what you're trying to do... The latlngList is already an arrayOf(latng), see https://github.com/PaulLeCam/react-leaflet/blob/master/src/propTypes/latlngList.js#L7 so I don't see in what way your PR is changing anything.. Ah yes good catch!\nYes if you can please update your PR to fix the import should be good to go.. Should be fixed in v1.6.4. Thanks!. Thanks for reporting this, should be fixed in v1.6.5.. I'd rather not export it as-is considering it's simply declared as Object | Array<any>, but I'd gladly merge a PR to improve this type and export it.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for general questions about it.. Should be fixed in v1.6.6, please try it out.. Should be fixed in v1.6.6, please try it out.. Could be your version of node, please use node 8. Thanks!. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Yes it will be supported once React v16 is released.. Sorry but this is out of the scope of this library, you should implement the solution in your app.. Please refer to Leaflet's docs, style should be a function, not an object.. You're likely using a version of Flow older than the one supported (0.54).. See https://github.com/PaulLeCam/react-leaflet/issues/364. Hi!\nSounds great!\nSorry I don't get what you mean by v8? The latest version is 1.6.6, are you referring to something else?\nThe files produced in example/build are only meant to be used locally, they shouldn't be distributed. The UMD build is generated in the dist folder as part of the build (cf https://github.com/PaulLeCam/react-leaflet/blob/master/rollup.config.js#L14-L15), it is present in the npm package when published but not committed using git, though I can change this if it helps?. I don't remember exactly at what version the UMD build was introduced, but is there any particular reason to include older versions? Why not start with the current 1.6.x and add new releases?. OK I see, I think the first version that had the UMD build was v0.8.1. Until v1.6.0 the dist folder was checked out in git so the files should be available in GitHub, but since v1.6.0 the dist folder is only published in the npm package.\nWhat is the process for CDNJS to get these builds and provide the new ones when available please? Is there an automatic process to do it?. No worries, thanks for taking care of this!\nIf I understand the docs correctly, I think it should be configured to get the dist/react-leaflet.js and dist/react-leaflet.min.js files from the npm packages, and yes only since version 0.8.0 of the library as previous versions didn't have an UMD build.. Thank you!. Thanks!. I updated the docs, the zoom prop is \"optional\" as the zoom can be provided in viewport, but it has to be provided somehow.. The expected behavior you describe is not the expected behavior for this library, you should provide the same object if you don't want to trigger a re-render.. Thanks for the detailed explanation, I agree I think it makes sense to be more explicit about how the props changes are compared, I updated the docs in the latest commit.. Hi,\nThanks for your PR but this comparison is done by reference, it's up to your application to provide the same icon or a different one.. Please provide a WebpackBin or similar example.. I think the issue in your example is your MyLayer component render method returning null. This is not supported, all layer controls must contain a layer to render.. Thanks!. Hi,\nI thought about that but the problem is that getting the bounds involves computations from Leaflet, so I don't think it's a good idea to do it when triggering this event.\nCalling getBounds() on the map instance only when your app needs it is likely the best option.. Use the code from https://www.webpackbin.com/bins/-Kl_ZeUx4I05ETYoT26O\nWhatever issue you're having comes from your config, not this lib.. Should be fixed in v1.7.1 thanks to your PR, please try it out.. Thanks!. Only browsers are supported, if the DOM is not fully implemented by the environment you want you should open an issue in the relevant project.. Your example provides these values as strings where they should be numbers.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Then please fill the issue template with a WebpackBin or similar showing the problem.. Please check the behavior using Leaflet directly to make sure it's an issue caused by this lib and not upstream.. Leaflet's docs are misleading, these events listeners shouldn't be attached to the Popup layer itself, you can check Leaflet's code for the actual implementation.. This is up to Leaflet defaults and your webpack config, not this lib.. Great idea, thanks!. Should be fixed in v1.7.2 now thanks to your PR, please try it out.. Thanks!. Thanks!. Sorry but this has nothing to do with this library, a JSX tree is no a string, you need to convert it anyways.. Thanks for reporting this, it should be fixed in v1.7.3.. Thanks, should be fixed in latest commit.. You are not required to extend one of the base classes, it can be a simple React component, but the base classes provide some common logic that are usually required to support Leaflet elements.\nIf the Leaflet plugin you want to use does not render or provide anything to its children, it's unlikely it makes sense as a component, you're probably better using it directly.. Yes you can extend Map or anything else you want.. class MyMap extends Map {... and implement the lifecycle handlers you need, check the code and documentation.. I don't know, it's up to whatever you want to implement.. Support for plugins is out of the scope of this library but you can refer to the documentation on implementing custom components.. Thanks!. Yes it's done now in v1.7.4.. Please provide a WebpackBin or similar to reproduce the issue and make sure it comes from this library and not your code.. Closing for lack of activity, please feel free to reopen if you can provide a way to reproduce.. Thanks for the details, it should be fixed in v1.7.5, please try it out!. Please open a separate issue with a minimum way to reproduce in WebpackBin or similar if it is breaking anything but I don't think this warning is any issue, it's likely just a side-effect of the way it's implemented.. You'll probably need to make some changes to your MarkerCluster component to handle this logic there.\nI don't know how leaflet.markercluster handles it but as it's a plugin and only displaying a warning, I'm not going to dig into this, sorry.\nPlease feel free to open a PR if you find a solution that can be implemented without hacks or side-effects.. Thanks for reporting this, as you suggested I made the change to split the className and call addClass/removeClass on each class.\nIt's pushed in v1.7.6, please try it out!\nThanks for the P.S., great to know this library is useful!. I updated it in v1.7.7, it should be more permissive for this kind of case now.. You're welcome!. Thanks for reporting this, it should be fixed in v1.7.6, please try it out.. You can check this example that works as expected. If it doesn't for you it's most likely an issue with your environment.. Sorry but this is not helpful, please provide a WebpackBin or similar.. I don't know why your example doesn't work but this one does so I suggest you start from there to see what fails with your setup.. You can extend the Popup component to implement this behavior, but it won't be provided by this library itself.. Good catch, thanks!. Thanks! It's now pushed in v1.7.8.. Thanks!. Please follow the issue template and check Leaflet's default behavior.. Thanks but this code is meant for demo purposes only, it's not intended to be used as-is.. If you want to compile this library you'll need to install the dependencies, but you're likely better off using the compiled files unless you have a specific need to use the sources.. It's likely caused by the fact you recreate the customIcon all the time in render(), so the icon effectively changes and likely the event handlers on the marker get replaced.. Thanks!. It's unrelated to this library, as stated in the docs it uses Leaflet, it's not a replacement for it.. Please refer to the documentation, anything I would explain here is already documented.. I just pushed v1.8.0 that changes the peer dependency. Apart from the added support for an image element in ImageOverlay I haven't spotted any required change in this library so hopefully everything should work as expected, but please open specific issues you may find.. Please follow the issue template, posting issues like this is not giving any meaningful information on what could be the cause of your problem.. Yes, once Docusaurus supports client-side components (https://github.com/facebook/Docusaurus/issues/292) that would be a good thing to add.. Hey, thanks for your comment and your offer to help!\nI've never used CodeSandbox so I don't know if it's the best solution, but please don't hesitate to try it out! Maybe it can be used at least as a temporary thing, if it integrates well with Docusaurus.\nIdeally the examples could be updated when building the website, using the latest version of the library rather than using the published files from a CDN, but I don't know if it is possible with a third-party solution like CodeSandbox, that's why I was more thinking about using a tool like component-playground or similar once it's possible do provide client-side components with Docusaurus.. I agree Storybook is great for component demos, the issue is more how to integrate it with Docusaurus?\nAt the moment the publication process with Docusaurus is very simple and I'd rather keep it that way rather than rolling a custom setup adding maintainance.\nMaterial UI is a good example as well, that's what I had in mind originally, but until Docusaurus supports hydrating components client-side, this kind of solution is not possible.. As written in the documentation, all props are injected as options in the element constructor, so it works in a similar way.. You need to import it from Leaflet. This library uses Leaflet, it's not a replacement for it.. I can't reproduce the issue, the value is true by default anyways, so there is likely something else happening in your code, please provide a running example.. Please follow the issue template.. Thanks, it's fixed now.. Please follow the issue template and make sure all the boxes are checked before posting an issue.. Thanks!. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Please follow the issue template and make sure all the boxes are checked before posting an issue.. Hi, the original issue was https://github.com/PaulLeCam/react-leaflet/issues/415\nI think it's related to the way components get unmounted, in your case the tooltip is removed but not its container so it doesn't get properly removed, but in the previous issue the container gets removed as well and therefore the unbinding fails to reference it.\nIt's possible the implementation may have changed in Leaflet 1.3 and fixes the original issue, but that need to be checked before reverting this change.. @jonathanchrisp could you check if v1.8.1 fixes your issue please? I changed the unmounting check, hopefully it covers both cases now.. Hi, thanks for your PR but why are you trying to merge in the v2 branch? Please open a PR against master, not another branch.. No problem, thanks for your contribution!. No, it's not meant to be compatible with anything but the supported versions of React.. Thanks!. Thanks!. I've gone through the rabbit hole on this one and it seems to be caused by the fact the Map component somehow shadows the browser's Map when using destructuring with the UMD build, though I couldn't figure out how it happens.\nIn your Codepen, if you replace the first line by const { Map: LeafletMap, TileLayer, Marker, Popup } = ReactLeaflet and consequently Map by LeafletMap, it works as expected.. I think the issue comes from Leaflet's canvas renderer usage of requestAnimationFrame to defer the call to update the canvas' context, that happens at a time React has already removed the canvas from the DOM so the reference is lost.\nI changed the unmounting behavior for the Map component in v1.8.2 so it should avoid triggering this error but that may have other unwanted side-effects, please let me know if you have any related issue.. Thanks! Yes should be released soon.. Thanks, should be fixed now.. Please follow the issue template and make sure all the boxes are checked before posting an issue.. Thanks!\nI think it might needs additional logic in the scrollWheelZoom and touchZoom, the behavior when setting the value to center would enable the handler, but as if the value provided was true rather than the expected center behavior, unless I'm missing something?\nOne way to achieve this could be to update the map.options Object in the Leaflet element to reflect the change, I don't think it needs to check for the center value specifically, checking for the string type is likely a better way to make sure the behavior will also work for other values that could be added by Leaflet later.. Thanks for the changes!\nRegarding enabling the handler when setting the value to center for scrollWheelZoom and touchZoom, I'm not sure it's enough to enter this condition for example. If I understand it correctly, if the map is created with scrollWheelZoom={false} and then updated to scrollWheelZoom=\"center\", the handler would be enabled but not behaving as expected because map.options.scrollWheelZoom would still have the value false, so I think before enabling the handler, this.leafletElement.options.scrollWheelZoom should be set to the scrollWheelZoom value in updateLeafletElement(), does it make sense?. Looks great, thanks!\nSorry I don't have much time to play with the branch at the moment but I'll try to get to it in the coming days.. Yes you need to properly setup Leaflet in order to make this library work.. Thanks for your PR but as commented above, https://github.com/PaulLeCam/react-leaflet/pull/452 already includes this change among others so better follow-up in this PR.. You can inject any option supported by a Leaflet layer in the corresponding component, so the example from\njs\nvar map = L.map('map', {\n    crs: L.CRS.Simple\n});\nroughly translates to\njs\n<Map crs={L.CRS.Simple} ...>...</Map>. Hi, this library only aims to implement core Leaflet features, for plugins support you should check out the plugins page of the documentation or how to implement your own.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. This functionality should now be supported with v1.9, please reopen this issue if it's not working after updating.. Thanks!. Thanks for your PR but this should be in a separate project, this library only implements core Leaflet functionalities.. Thanks!. Thanks!. Thanks for your PR but the master branch should be compatible with previous versions of React, could you please change the target branch to v2?. Thanks!. Hi, please refer to the creating custom components section of the documentation.. No, you probably need a plugin for this.. Array.isArray() is not a good check, children could be other types of iterables.\nThis logic should be in your component, you shouldn't render an empty LayerGroup, could be as simple as markers.length > 0 ? <LayerGroup>{markers}</LayerGroup> : null.. No idea sorry, I think it's more a question for the Flow project itself.. Please follow the issue template and make sure all the boxes are checked before posting an issue.. This is Leaflet's expected behavior, not an issue with this library.. Great idea, thanks!. Please refer to Leaflet's documentation.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Thanks!. From your description it seems you're confusing the usage of React's createRef() and callback ref, please refer to React's docs, it's not an issue with this lib.. Hi, thanks!\nWhat version of the library are you using please? v1 won't support React's strict mode but v2 should already be compatible, please provide more details if it's not.. Yes v2 is in beta but unless you are using third-party plugins that haven't been updated to it, you should be able to upgrade from v1 without having to make any change.. Added in v2.. Thanks. The Overlay holds the name, it's Leaflet's behavior for these layers. Not sure what you're expecting but you should refer to Leaflet's docs.. Thanks but v1 should only get new releases for bug fixes, please use v2 if you want to take advantage of the most recent changes.. What is the issue?. Could you open another issue with a CodePen or other running example exposing the problem please?. The issue might be caused by something else in your code then, please provide a way to reproduce if you want to get a PR merged.. Closing due to lack of feedback, please reopen if you want to update the changes.. From your description this is an issue with your setup, not this library.. What class are you trying to extend? When creation custom components, you should extend one of the base classes, not one that is meant to be consumed directly.\nFor example let's say you want to implement a Square component that would actually render a leaflet rectangle, you should not extend from the Rectangle component in this library (meant to be used direclty) but the Path one, containing the shared logic for all vector layers, or even one of its parent classes if you don't need the additional logic provided by Path.. They are both made for react-leaflet v1, not v2. This is a major version because it introduces possible breaking changes.. I don't think it's a good idea to have two GeoJSON exports, it's more confusing than anything.\nIf you want to implement your custom GeoJSON, you can start by copying over the current implementation and change what you need.\nThe primary use for this library is to consume the components directly, not extending them and expecting things will work out of the box. The \"abstract\" component classes can be extended but the public components should be used as-is.. @sanfilippopablo sorry for the late reply, I updated the docs but yes please open a PR if you think things can be better explained.. Hi, please refer to the creating custom components section of the documentation.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Hi, please refer to the creating custom components section of the documentation.. You can use the collapsed property of the LayersControl component in v2.. SSR is not supported by Leaflet.. Hi,\nIf I understand your request correctly this is already covered by the events support, you can read about it in the documentation: https://react-leaflet.js.org/docs/en/events.html. According to your example this is not an issue with this lib but rather the expected behavior considering you're using the same ref for all markers, it only gets applied to the last one in the loop.. Yes this notice is about WMSTileLayer, not the other raster layers. Only the properties documented as dynamic are expected to get updated.\nIn your case you'll probably want to change the element's key in order to re-render it as needed.. Hi, thanks for your PR!\nCould you please fix the CI issue and provide a link to the Leaflet documentation or code for this setTitle() method?. Thanks!. This is something you should investigate with Leaflet and its plugins as it's out of the scope of this library.. The Pane component will provide the pane option to its children components, but it is the expected behavior that it is not affecting Leaflet itself in any way.\nAs you presented in your code, providing the pane option to Leaflet factories is the way to go.. This is the expected behavior as the changes to the positions prop are compared by reference, not by value, so you need to provide a different array of positions rather than mutating the existing one.. Thanks for reporting the issue, please try using v2.0.1 that should fix the problem.. v2 exposes 2 types of components: the \"public API\" ones that are meant to be consumed directly, and \"abstract\" ones that contain shared logic by the components extending them.\nIt works differently from v1 because of the context architecture changes introduced in React v16.3. If you know of a better way to handle this, please open a PR, but I don't like the option to export both \"extendable\" and \"directly usable\" version of a component, it's only going to make things more confusing.\nv2 is a major version due to breaking changes and this is the main one, please don't expect things to work like v1.. Thanks!. Thanks!. Thanks!. Hi,\nThanks for your PR but I don't think this behavior should be limited to TileLayer, as other layers could also support it.\nI added support for dynamic attribution prop in v2.1.0 so I hope this covers your use case.. Thanks!. This library uses React.. Thanks for your PR but please remove this runtime check, this is something that should be covered by Flow.. Run-time checks were the original purpose of prop-types, that have been softly deprecated in favor of Flow.\nAnyways the subject is not about the pros and cons of run-times checks, Flow or others. This library uses Flow and not run-time checks, so thanks for your PR but please respect the existing setup if you want to have it merged.. You can implement whatever logic you want in your application, the purpose of this library is simply to expose Leaflet APIs as React components.. Thanks!. Hi,\nSorry I'm not familiar with MapQuest but you can use the react-leaflet tag in StackOverflow for questions related to using this library.. It is documented in the context page of the docs, and get injected by the withLeaflet() HOC.. Hi,\nSorry for the delay replying, I haven't had time to look into this until today.\nI just published v2.1.0 that should fix the issue, please let me know if you still see these errors.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Please follow the issue template and make sure all the boxes are checked before posting an issue.. Thanks!. Thanks!. popupopen is an event emitted by the containing layer, not the popup itself.\nYou can use the onOpen prop on the Popup component to achieve what you're expecting.. Thanks!. Thanks!. Thanks!. Thanks for reporting this, I switched these dependencies to unpkg so this should work as expected now, please try it out and let me know if you still encounter the issue.. Thanks for the example, this should be fixed in v2.1.1, please try it out.. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Thanks!. Hi,\nPlease only use GitHub issues to report possible bugs in the library.\nYou can use the react-leaflet tag in StackOverflow for questions related to using it.. Thanks for the detailed explanations, I just pushed v2.1.2 that should fix the issue, please try it out and let me know if it works for you.. Thanks!. Hi,\nThanks for you PR but this is the expected behavior, it's up to the application logic to handle this, for example leveraging React's shouldComponentUpdate().. Hey sorry I missed this, basically this is how shallow comparison works, similar to React.PureComponent's behavior I think.\nThe logic doing more custom comparison should likely go one level higher in your own component that renders the Marker.. Hi, please use this CodePen or similar to provide the minimum code necessary to reproduce the issue.. Thanks for the example, that seems to be due to the version of React indeed, v16.3.0 likely had this bug that got fixed, as it seems to work with v16.3.1.. Thanks!. Thanks!. Maybe the example with the icons in the same module could be the single one, what do you think?\nAs long as the icons are not created in the render() method I think it's good either way.. Yes I think a single file sounds good, thanks!. Looks great, thanks for your PR!. Thanks for reporting this, indeed the issue was with the Map's componentDidUpdate() method.\nIt should be fixed now in v2.1.4, please try it out.. Thanks!. Hi, could you please provide an example of the flow working with Leaflet only (not using React-Leaflet)?\nThe error seems to happen deep in the Leaflet stack after calling the remove() method on the map instance.. Thanks for checking it it out.. Thanks!. Thanks!. I changed the behavior in v2.2.0 so that the callback is called after the second render, this should ensure any ref is bound at that time, please try it out.. Thanks!. Thanks!. Thanks!. Thanks!. Thanks!. Thanks!. Good catch, thanks!. This handler seems extraneous considering it's set in MapLayer, no?\n. Could you rename it to just Pane to match Leaflet API please?\n. MapPane -> Pane\n. No need to create an extra PropType if it is as simple as a string I think.\n. MapPane -> Pane\n. No need for this._name and this.state._isMounted, we could just have this.state.name to check if the children should be rendered.\n. Could be much simple I think, no need to try to get these values from props, but is this method even useful?\njs\ngetParentPane (): ?string {\n  const { map, pane } = this.context\n  return pane ? map.getPane(pane) : undefined\n}\n. MapPane -> Pane\n. Shouldn't be needed as the the creation of panes with existing names should be prevented.\n. Seems a bit of a hack, is there any other way to cleanup the pane from Leaflet using more public APIs?\n. zIndex should be part of the style, unless there is a particular reason to treat it differently?\n. Shouldn't need that, React can render the styles itself.\n. Shouldn't be needed.\n. Could be simply named getOptions()\n. Yes I think it's better to just rely on style, I prefer to make the components as \"dumb\" as possible with no specific logic and let the applications implement custom behavior on top of them.\n. I see, yes I missed the fact Leaflet is creating a new DOM node rather than using the one provided. It's too bad it doesn't allow it as we could have completely leveraged React for this, but in that case I think your implementation is needed as such.\n. Yes, sorry I missed that from Leaflet's createPane() implementation.\n. I don't like the idea of allowing to update Leaflet's default panes unless there is a way to restore them to their original styles, that would create unexpected behavior, so I'd rather have this library simply prevent from overriding these panes.\nRegarding having \"<Pane name='myCustomPane' /> in two places\", same I don't think it should be allowed, even if it is technically possible I think it would only lead to unexpected behavior when trying to set different styles in each component for example.\n. OK thanks for the explanation, hopefully Leaflet won't remove these anytime soon!\n. Makes sense, thanks.\n. Please remove. Please remove. Yes I agree these files are annoying, but I think this should be part of developers own git config rather than polluting projects with this, especially since there are different files based on each OS and IDE.. Why checking if scrollWheelZoom is a string?. Why checking if touchZoom is a string?. Please leave this one on. Could you use Object.keys() here please? I think there are more browsers supporting it than Object.entries().. Could you move the L.Icon creation outside the render() method or event the component please?\nThis is not recommended because that means recreating the icon every time, so the marker will re-render every time as well.\nIt's not really an issue for this component because it doesn't re-render anyways, but hopefully it would make this example more relevant for other cases.. ",
    "damassi": "Thanks for the detailed response; i'll go ahead and stick with the regular implementation for now.\n. ",
    "gmccrackin": "Awesome!\n. ",
    "soueuls": "Yeah but then that's managed by React instead of Leaflet, I have been playing around with it for few days, and my mind can't figure out how to properly mix them both.\nFor customized markers I tried to do a React.renderToStaticMarkup but I don't think this is the proper way to go.\n. ",
    "AndrewIngram": "I think you've misunderstood. The issue is that merely doing require('leaflet') needs a global window, document, and navigator object, or the import fails. On the server I could use jsdom to set up these globals, but this seems like overkill considering no actual rendering occurs on the server.\n. ",
    "nym": "I am also having this issue, trying to find a way around it. \n. ",
    "revolunet": "here a nice workaround using dynamic import : https://github.com/etalab/adresse.data.gouv.fr/blob/0bc6dd7/pages/map.js#L5-L12. try this solution : https://github.com/etalab/adresse.data.gouv.fr/blob/0bc6dd7/pages/map.js#L5-L12. The cleanest solution i found is here : https://github.com/etalab/adresse.data.gouv.fr/blob/0bc6dd7/pages/map.js#L5-L12. ",
    "scherler": "Hi Paul, I am not sure whether I understand you. If you refer to the setUrl method then I tried that but it is not getting re-rendered.\n. Hi Paul, sorry for not finding the time to come back earlier on this.\nIt is working for the src however if I have different dimensions in the image, it gets distorted. It maybe a problem with the bounds being different, something like the following would fix it, I guess, if it would exist.\npseudo code:\n\nif (this.props.bounds !== prevProps.bounds) {\n  this.getLeafletElement().setBounds(this.props.bounds);\n}\n. Hi Paul, just tried that and yes if I set the key prop than I can use your version as well with different bounds. Thanks.\n. Thanks Paul, I will now look into your suggestion and let you know.\n. Hi Pau, I came up with a Mixin which is capable of what you describe in the earlier comment, you may want to check the pull request.\n. ok, I understand\n. @barbalex @prabuvenkat @RoryShively you can find the PR https://github.com/PaulLeCam/react-leaflet/pull/13 \nI have to admit that I did not looked at this since back then and I guess that would be better implemented as ComposedComponent . ",
    "karlguillotte": "You are welcome. Thanks for creating this integration of Leaflet & React! \n. ",
    "barbalex": "Hm. I must admit that I have not understood how @scherler achieved this.\nI have the same need.\nAnd I can imagine many people would like to make interactive popups.\nIs there some example of how to do this?. @EvertLagerberg  On my Samsung S8+ your example only pinch-zooms when I set dragging to true. That is in Chrome. facepalm\no.k., I guess I'd better rehearse the basics of react :-(\nfor any one who happens to make the same mistake: here is the working example: https://www.webpackbin.com/bins/-KwBpKAnTzjnCFepnsut\nThe difference is: (correct)\n    <TileLayer\n      attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n      url='http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'\n      maxNativeZoom={19}\n      minZoom={0}\n      maxZoom={22}\n    />\n\nversus: (me dreaming)\n    <TileLayer\n      attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n      url='http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'\n      maxNativeZoom=\"19\"\n      minZoom=\"0\"\n      maxZoom=\"22\"\n    />.\n",
    "prabuvenkat": "+1 for this feature. ",
    "RoryShively": "+1. ",
    "ayanez17": "Im trying yo add a D3 graph into the pop up. Is this possible ?. ",
    "tkauer": "@ayanez17 should work, since the popup is a DOM element:\nvar svg = d3.select(\".leaflet-popup-content\").append(\"svg\"). ",
    "andywer": "Hi Paul,\nwe are currently using the handlers onDragOver (just for event.preventDefault()) and onDrop to enable dragging objects from outside into the map. This doesn't work using the Leaflet event handlers (since Leaflet handles d&d in a way that doesn't suite our needs).\nCheers,\nAndy\n. Yeah, thanks for the hint. The mark-up doesn't look as clean now, but I totally understand your point.\nYour idea of changing the listener property names from onLeaflet... to on... sounds good to me.\nCheers\n. Hey, cool. Thank you and have a nice weekend!\n. ",
    "iOiurson": "Nop, i wasn't aware i could do that. I had to switch back to regular Leaflet for delivery reasons (had to get it done :/), but i'm starting a new project, and i'll try just that. What's the actual purpose of key properties ??\n. ",
    "luqmaan": "As an example, I use react-leaflet with Flux: https://github.com/luqmaan/instabus-react/blob/master/client/js/components/MapSection.react.jsx\nI need to use some Leaflet plugins like https://github.com/Leaflet/Leaflet.label, so I had to copypasta the source for Marker and modify its componentWillMount: https://github.com/luqmaan/instabus-react/blob/master/client/js/components/StopMarker.react.jsx#L22-L30.\nInstabus displays transit data, so it uses Leaflet to display vehicles, stops and polylines along a route. I have a StopStore, VehicleStore, RouteStore and PolylineStore: https://github.com/luqmaan/instabus-react/blob/master/client/js/stores/. \n\n. I use a DivIcon that updates a few properties here:\nhttps://github.com/luqmaan/instabus-react/blob/b52e8290455520909b4b10b185a4a9456563b6d3/client/js/components/VehicleMarker.react.jsx#L46-L101\nI wrote this before react-leaflet converted to ES6 class syntax, so instead of inheriting it uses mixins. But in general, the steps to setup a DivIcon are basically the same.\n``` js\ncomponentWillMount() {\n    var {map, position, ...props} = this.props;\nprops.icon = L.divIcon({\n    className: 'vehicle-icon',\n    html: formatVehicleIconHTML(this.props.heading, this.props.routeId, this.props.directionSymbol, this.props.updateStatus),\n});\n\nthis._leafletElement = L.marker(position, props);\n\n}\ncomponentDidUpdate(prevProps) {\n    if (this.props.heading !== prevProps.heading) {\n        var path = this._leafletElement._icon.querySelector('#circle-shape');\n        path.setAttribute('transform',  'rotate(' + this.props.heading + ' 26 26)');\n    }\n}\n``\n. I think you can just get rid of map in the componentWillMount statement\n. Do you have a link to what you've built @gambit3?\n. :+1: \n. Because this relies on a Leaflet plugin, this shouldn't be part of the react-leaflet library. It should live outside. For example see https://github.com/paulserraino/react-geojson-cluster\n. Great idea\n. You should submit a PR @hunterc.\n. :+1: \n. Another approach is to subclass Polyline and make custom changes incomponentDidUpdate.\n. > changes to a GeoJson's data didn't change the'sd` attribute.\nHeres a naive implementation of an  updatable GeoJson component https://github.com/open-austin/austingreenmap/blob/9b0d9ad5ddc245c07c63ab7d2997e74328d73259/client/js/components/GeoJsonUpdatable.jsx.\n. This should be:\njs\nif (!popupContainer) {\nOr at least use consistent style. You switch between if( and if ( throughout this file. :smiling_imp: \n. Missing semicolon.\nIs there a reason you sometimes use semicolons and sometimes don't?\n. You don't need to specify the this argument since you're using a fat arrow.\n. Why do you need to use isEqual in addition to the !== operator?\n. For consistency should this be build:single?\n. Use ' vs \" consistently.\n. I think this would be better as componentDidUpdate(prevProps), as it makes things more clear to anybody that wants to extend BoundsMap.\n. ",
    "moimael": "Your example is really helpful thanks ! \nI'm still unsure how to call method on map itself. For example, what if I want to call locate on my instance of Leaflet.Map ? \nWhere should I do it ? \nI understand the way flux works, but with third-party component which include their own state and event system, I really have a hard time figuring out how to cleanly integrate them.\n. Thanks a lot ! It's starting to take shape :)\n. key property works fine, thx !\n. Yes my bad, I wrote this to quickly, I had a problem elsewhere preventing icon from working. It's working now.\n. Yes that's what the doc said. By moving stuff around I had it working with the same code as above. If the circle is sibling with marker, I get a React error. It seems related to the fact that I have 2 react component (circle + marker) in a ternary expression. It also work if I write twice the same condition : \n{this.props.uiState.hasUserPosition ?\n          <Circle center={this.props.uiState.userPosition} radius={radius} color=\"#FF4E00\"></Circle> : null}\n        {this.props.uiState.hasUserPosition ?\n          <Marker position={this.props.uiState.userPosition} icon={currentPositionMarker}>\n            <Popup>\n              <span>You are within {radius} meters from this point</span>\n            </Popup>\n          </Marker> : null}\nBut not very pretty.\n. ",
    "Otann": "Sorry, I've lost track of this.\nI've decided to switch back to react 0.12 anyway, because Fluxxor does not work with 0.13.\nI suggest to close this, in case I will encounter this issue again, I will notify you.\n. ",
    "Oustad": "Hi, I've seem to have run into the same issue as the orignal poster here.\nUncaught (in promise) Error: Invariant Violation: findComponentRoot(..., .0.1.0.$/vessel/922.2.1.0.0.0.$=11:0.$=10:0): Unable to find element.\nreturn (\n         <Map ref map center={this.props.lastPosition} zoom={5}>\n          <TileLayer\n            url='http://{s}.tile.stamen.com/toner/{z}/{x}/{y}.png'\n            attribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>'\n          />\n          <Marker position={this.props.lastPosition} title={this.props.name} alt={this.props.name}>\n              <Popup>\n                <span>{this.props.name}</span>\n            </Popup>\n          </Marker>\n        </Map>\n);\nFrom debugging it looks like the problem is happening in the following line of html\n<noscript data-reactid=\".0.1.0.$/vessel/922.2.1.0.0.0.$=11:0\">&lt;noscript data-reactid=\".0.1.0.$/vessel/922.2.1.0.0.0.$=11:0.$=10:0\"&gt;</noscript>\nIt also only happens when I use the Popup tag inside of the marker and for some reason it seems to only happen when I also render some charts on the page, in a different component, but with the same parent node. If I remove either the popup or the charts, the error do not occur.\nI'm using ES6 classes for the components and flummox as flux implementation.\n. Problem seems to originate from \nhttps://github.com/PaulLeCam/react-leaflet/blob/master/src/PopupContainer.js#L10\nChanging the tag to anything other than noscript, will make the error go away.\n. Hi,\nthanks for the reply @PaulLeCam, after investigating some more in my app, and looking at the react-leaflet code I found out the problem for my part at least is as you just stated in your last reply.\nSo I agree that this is not a bug, but something that one must take into consideration when implementing use of popup on a map in ones application.\n. Yes, I found the root cause which did the update, and I if I'm going to use popup with content coming from flux stores, it looks like I have to do as you wrote, remove the existing layer and add a new one.\n. ",
    "Frikki": "The problem also occurs when using the browser navigation\u2019s back and forward. It is definitely caused by the PopUpContainer, as removing it causes the error not to be thrown. Also, as noted above by @Oustad, changing its markup to anything but noscript solves the error. Tested without flummox.\n. Thank you! This works. Btw., is there any reason why the onLeafletLoad isn\u2019t implemented?\nI was able to get the load event to fire by modifying the Map component by adding\nrender() {\n  \u2026\n  if ( map )\n    map.on( 'load', this.fireLeafletEvent( 'load', this ) );\n  \u2026\n}\n. Yes. I added the code to obtain the leafletElement before you answered \nhow to get a hold of it.\nOn 04/28/2015 08:32 PM, Paul Le Cam wrote:\n\nI have never tried to use the |load| event, it should be implemented \nas all Leaflet events are simply passed to the Leaflet instance, but \nit's possible this event is fired just before the event handlers are \nactually attached.\nI assume any logic you would put in a |load| handler could be set in \nthe |componentDidMount| of the containing component, but it really \ndepends on your use case.\n\u2014\nReply to this email directly or view it on GitHub \nhttps://github.com/PaulLeCam/react-leaflet/issues/21#issuecomment-97164033.\n. Apparently, @PaulLeCam is not in favor of changing it to a DIV element. See discussion here https://github.com/PaulLeCam/react-leaflet/issues/18\n. Please let the style be a React.Component.prop so we have some chance \nof overriding it.\n\nOn 05/11/2015 02:39 PM, Paul Le Cam wrote:\n\nSorry I misread about the Popup deletion.\nI'm not so up for using a || as a workaround because the \nrendering is made by Leaflet, not React, so the |null|/|| \nrendered by the components are only there because React needs to \nrender something.\nMy main concern is that rendering ||s could affect the expected \nlayout, but |display: none| should avoid that issue, I'll try that!\n\u2014\nReply to this email directly or view it on GitHub \nhttps://github.com/PaulLeCam/react-leaflet/issues/27#issuecomment-100892787.\n. \n",
    "mikefab": "I'm trying to pass a reference to a leaflet map as a prop in a nested custom component. It's not working.\nIn MyMap.jsx I have:\nreturn (\n    <Map ref='map'\n      ref={m => {\n        this.leafletMap = m;  // Set reference here\n      }\n      }\n      center={[0,0]}\n      <TileLayer\n        url={this.state.url}\n        attribution={this.state.attribution}\n      />\n      <MyCustomComponent\n        leafletMap={this.leafletMap}\n        points={geojson}\n      />\n    </Map>\n)\n\nin MyCustomComponent.jsx\ncomponentDidMount() {\n  console.log(this.props.leafletMap) // undefined\n}\n\nTried to follow advice from https://github.com/PaulLeCam/react-leaflet/issues/106#issuecomment-161594328, however,  this.refs is an empty object when inspected from componentDidMount in both MyMap.jsx and MyCustomComponent.jsx.\nAny advice appreciated. Thank you.\nUpdate\nReplaced componentDidMount with createLeafletElement.\nIt works, but I get this warning:\nindex.js:2178 Warning: Failed context type: Invalid context map of type NewClass supplied to ReactWebglLeaflet, expected instance of NewClass.\n    in ReactWebglLeaflet (at MyMap.jsx:207)\n    in div (created by Map)\n    in Map (at MyMap.jsx:175)\n    in div (at MyMap.jsx:172)\n    in MyMap (created by Connect(MyMap))\n    in Connect(MyMap) (at App.js:22)\n    in div (at App.js:21)\n    in Dashboard (at index.js:58)\n    in Provider (at index.js:57)\n\n. ",
    "itoldya": "Leaflet throw an exception ReferenceError: window is not defined when you try to use it in nodejs.\nLeaflet-hedless solves this problem by using jsdom. Leaflet-headless also can export the map as an image, but we do not need that.\nUsing Leaflet-hedless instead Leaflet means the following:\n- components created with the react-leaflet can be rendered on the server, ie can be used for isomorphic applications\n- nothing will change when using in browser\n. ",
    "evantahler": "@itoldya did you ever publish your fork of this project using leaflet-headless?  I'm having the same problems you are :/\n. ",
    "mydearxym": "is this saying that all the third part component write by react.js can not be use in the react-native project? that's so sad ..\n. ",
    "vvavepacket": "Is it possible to load react-leaflet into ReactNative's WebView? . ",
    "filipef101": "bump. ",
    "incarnateTheGreat": "\nIs it possible to load react-leaflet into ReactNative's WebView?\n\nhttps://github.com/reggie3/react-native-webview-leaflet. @PaulLeCam : I'm using v1. Is V2 still in beta?. \"react-leaflet\": \"^1.9.1\",\n\"react-leaflet-control\": \"^1.4.1\",\n\"react-leaflet-markercluster\": \"^1.1.8\",\nreact-leaflet-rotatedmarker\": \"^0.1.0\",\nThese are the Leaflet third-party plugins that I'm using. I'm not sure if they'll break or not, but I'll give it a go. Thank you.\nedit: I just checked here: https://react-leaflet.js.org/docs/en/plugins.html . I'll keep an eye out for updates.. @kontrollanten thank you. I had tested my leaflet dependencies and they were all cacking out. Hopefully those will be upgraded soon, but in the meantime, I hope your PR goes through. :). Thanks for looking in to this, guys.\nI still try updating to v2 and the third-party plugins seem to be causing problems -- primarily RotatedMarker and MarkerClusterer. I'm assuming there's no real way to get around this unless the authors of these plugins solve their respective compatibility issues?. ",
    "vjpr": "After some investigation it seems to be related to this bug in Chrome -> Child elements of  tags not always rendered.\nChildren of noscript are rendered as string literals. \nWorkaround\nChange noscript in PopupContainer to:\nreturn <div style={{display: none}}>{children}</div>;\nI'm using Chrome Version 44.0.2396.0 canary (64-bit).\n. Hi Paul,\nYou might have misread the issue. It's not about removing a Popup.\nThere is a bug in Chrome which is causing this where noscript children are turning into string literals. Not sure how you want to handle this but a div is a simple fix. Otherwise people trying your library will struggle to get a simple example working.\n. ",
    "troutowicz": "@Frikki, I will try later tonight but I'm pretty sure that is already possible... while definitely limited due to Leaflet handling the rendering.\njs\n<Popup maxWidth='300' minWidth='300' >\n  some text\n</Popup>\nhttps://github.com/PaulLeCam/react-leaflet/blob/master/src/Popup.js#L40\nhttps://github.com/Leaflet/Leaflet/blob/master/src/layer/Popup.js#L11\n. Hmm, I would think those props would be getting passed through the bindPopup method which would be used in Leaflet when creating the popup element. I may submit a PR to Leaflet eventually that would allow passing more styling to popups. Wouldn't be a big change, just create a styling option, and make their popup module aware of it.\njs\nL.popup({ style: { ... } });\njs\npopupContainer.bindPopup(content, { style: {...} });\n. @PaulLeCam I load components using the index file.\nExample:\njs\nconst LeafletMap = require('react-leaflet').Map;\nThis works fine using the existing pre-compiled lib directory. Recompiling generates the error.\n. I used npm install; npm run compile\n. @PaulLeCam It would be great if you could recompile in your build environment and update the repo. This repo is broken for me when I compile in my environment, I am developing on OSX. Whenever I compile, the default image path set in index.js never makes it to my components. I end up having to explicitly set the image path in my component.\n. This is strange. Yeah, I'll try to get you an example soon.\n. @PaulLeCam I do not experience the errors after installing v0.6.... I must have been missing a build step.\n. @adanielyan Or the much shorter way...\n\"react-leaflet\": \"PaulLeCam/react-leaflet\"\n. Hi @swennemans \nI came up with a MarkerCluster component for my project. It has some project specific logic in it at the moment, but it should give you an idea on what it takes to reactify leaflet plugins. In my project, I use the component here.\n. GeoJson is a descendant of MapLayer which adds the map prop to all children here. This means you have access to map via this.props.map inside the GeoJson component.\nHow are you trying to use the map prop?\n. What about using refs?\n``` js\n...\nonEachFeature() {\n  // let map = this.refs.map.leafletElement\n}\nrender() {\n  return (\n    \n    ...\n    \n\n  )\n}\n```\nCalling bind is only necessary with ES6 classes.\n. Great :)\n. You can take a look at the version I created for my geoshare project here.\n. ",
    "eelcocramer": "Hi, I just tried these builds but they seem to fail for me.\nvar _react = __webpack_require__(4)\nIn the above line (and lines like these) the var _react is always undefined.\n. Thanks for the response but I switched to the npm / browsify build. It could very well be that I did not load all the dependencies.\n. Hi @web2style did you get leaflet-routing-machine working with react-leaflet?\n. Thanks!\n. ",
    "adanielyan": "I tried the following code, and it worked fine. However it doesn't use the Popup component, but rather calls the Leaflet's bindPopup method directly:\n```\nfunction getGeoJSONComponent(json) {\n    return(\n        \n    );\n}\nfunction onEachFeature(feature, layer) {\n    if (feature.properties && feature.properties.name) {\n        layer.bindPopup(feature.properties.name);\n    }\n}\n```\nI am having difficulties figuring out how the onEachFeature function should be rewritten to use the react-leaflet's Popup component.\n. OK, fair enough. Thanks!\n. I created a pull request with the issue fixed.\n. To use the repo from Github add this line to your package.json file under dependences:\n\"react-leaflet\": \"git+https://github.com/PaulLeCam/react-leaflet.git\"\n. Thanks for the shortcut, I didn't know about it!\n. By the way, the code in lib folder doesn't have this change. Make sure you recompile the repo after pulling it. It was another half an hour of struggling for me.\n. Ok, I think I wasn't clear enough, or maybe I am missing something.\nI want to access the map from onEachFeature() function for my GeoJson layer. So I have this code:\n<Map\n    ...\n    <GeoJson\n        data={geoJSON}\n        color='red'\n        fillColor='green'\n        map={this}\n        onEachFeature={onEachFeature} />\n</Map>\nNow in onEachFeature(feature, layer) function I can access color and fillColor through this.color and this.fillColor respectively. But this.map is undefined even if I add it to <GeoJson> as map={this} along with color and fillColor. \nWhat am I doing wrong?\n. Thanks for responses. Using ref worked like a charm!\n. ",
    "hokkos": "Oh, finally, I extended PopupContainer and couldn't understand why my custom layer was never added to the map: the function componentDidMount was never called. Please push a new version to npm I can't even use the one from github. I had to modify the package by hand.\n. Using the git repository was the first thing I tried, but I don't know why it only download a package with a lib/ directory inside, not the git one with src/ inside.\n. ",
    "swennemans": "@troutowicz and @PaulLeCam thanks for your replies. And @troutowicz thanks for sharing, very useful :)\n. @troutowicz cool app btw :) Works really nice. \nI'm also using alt + leaflet combo it's reassuring that it works smoothly :+1: \n. On further investigation it seems to be a problem with Webpack. \nUsing ExtractTextPlugin for stylesheets is working fine. When using style-loader it goes bad. \n. This can be closed. I can't pinpoint exactly what the problem is with webpack. But different webpack configs result in different outcomes. \n. ",
    "jeans11": "Hep, I found this solution:\n``` javascript\nimport React from \"react\";\nimport Leaflet from \"leaflet\";\nimport {GeoJson}  from \"react-leaflet\";\nexport default class MyGeojson extends GeoJson {\n    componentWillReceiveProps(prevProps) {\n            if (prevProps.data !== this.props.data) {\n                    this.leafletElement.clearLayers();      \n            }       \n    }\n\n    componentDidUpdate(prevProps) {\n            if (prevProps.data !== this.props.data) {\n                    this.leafletElement.addData(this.props.data);\n            }\n    }\n\n}\nMyGeojson.propTypes = {\n  data: React.PropTypes.object.isRequired\n};\n```\n. ",
    "michaeljones": "Thanks for the quick response. It is a pretty niche problem! I'll try to reproduce it for you somewhere public.\n. I'm afraid I don't know how to reproduce it in an environment like jsbin as I don't know how to get react-bootstrap & react-leaflet without npm. The code required for a simple demo is below:\nindex.html\n```\n<!DOCTYPE html>\n\n\n\n\n\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css\" rel=\"stylesheet\" type=\"text/css\" />\n\n    <!-- Leaflet Maps Styling  -->\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css\">\n\n    <meta charset=\"utf-8\">\n    <title>Tabbed Map Example</title>\n\n</head>\n<body>\n\n    <div id=\"tab-container\"></div>\n\n    <script type=\"text/javascript\" src=\"demo.js\"></script>\n\n</body>\n\n\n```\napp.js\n```\nvar React = require('react');\nvar TabbedArea = require('react-bootstrap/lib/TabbedArea');\nvar TabPane = require('react-bootstrap/lib/TabPane');\nconst position = [51.5072, -0.1275];\nconst style = { height: '400px' };\nconst zoom = 5;\nconst tabbedAreaInstance = (\n  \n\n\n\n\nA pretty CSS3 popup.Easily customizable.\n\n\n\n\n\n\n\n\nA pretty CSS3 popup.Easily customizable.\n\n\n\n\n\n);\nReact.render(tabbedAreaInstance, document.getElementById('tab-container'));\n```\nbrowserify command\nbrowserify app.js -t babelify --outfile demo.js\nYou'll need to npm install react-bootstrap, react and react-leaflet. Sorry I couldn't make it easier. Does that seem reasonable?\nThe demo has a set up with two tabs. I've put maps in both tabs to show that it loads properly in the default tab but when you switch to the other tab the tiles do not load properly, even when you pan around a bit it seems confused.\nI'm using Chrome 43 on Ubuntu.\nI hope that is sufficient but please ask if there are details I've missed.\nMichael\n. Wow, thank you for investigating and for the explaining. Kind of you to give such a clear run down. I will attempt to integrate this approach into my set up.\nI guess I'll close this ticket as there isn't really an action point for it. It is such an edge case that it doesn't seem worth trying to add to the documentation for react-leaflet itself.\nMuch appreciated!\n. ",
    "YUzhva": "@treydavis react-leaflet-markercluster looks nice...\nAll you need to do, it's grab all react-leaflet Markers inside that plugin:\n```javascript\nimport MarkerClusterGroup from 'react-leaflet-markercluster';\n// ...\n\n\n\n\n\n```. @mbritton Thank you, it works well.\nAlso I improved implementation, by extending react-leaflet LayerGroup:\nMyCustomMap => that is React Component that I'm using react-leaflet:\n```\nimport React from 'react';\nimport { Map, TileLayer } from 'react-leaflet';\nimport ClusteredMapMarkers from './ClusteredMapMarkers';\nexport default class MyCustomMap extends React.Component {\nconstructor(props){\n    super(props);\n    this.state = {\n      position: [],\n      zoom: 0\n    };\n  }\ncomponentDidMount() {\n    this.setState({position: [51.30, 0.7], zoom: 2});\n  }\nrender() {\n    let position = this.props.position || this.state.position;\n    let zoom = this.props.zoom || this.state.zoom;\n    let maxZoom = this.props.maxZoom || 17;\nconst mapStyle = {\n  height: ~~this.props.height || 310 + 'px'\n};\n\nlet map = null;\nif (position && position.length) {\n  map = (\n    <Map center={position} zoom={zoom} style={mapStyle} attributionControl={false}>\n      <TileLayer\n          url=\"MY_URL\"\n          maxZoom={25}\n          id=\"MY_ID\"\n          accessToken=\"MY_TOKEN\"/>\n      <ClusteredMapMarkers markers={this.props.marks}/>\n    </Map>\n\n  );\n}\n\nreturn (\n  <div className=\"my-custom-map\">\n    {map}\n  </div>\n);\n\n}\n}\n```\nClusteredMapMarkers => Component, that extends LayerGroup of react-reaflet and makes .addLayer() of Clustered by Leaflet.markercluster Plugin to the react-leaflet  ...\n```\nimport {LayerGroup} from 'react-leaflet';\nimport L from 'leaflet';\nimport markerClusterGroup from 'leaflet.markercluster';\nexport default class ClusteredMapMarkers extends LayerGroup {\n  componentWillReceiveProps(nextProps) {\nif(nextProps.markers && nextProps.markers.length) {\n  var pinkMarker = L.icon({\n    iconUrl: 'custom_marker.png',\n    iconSize: [25, 41]\n  });\n  var clusteredMapMarkers = L.markerClusterGroup();\n\n  nextProps.markers.forEach((marker) => {\n    clusteredMapMarkers.addLayer(\n      L.marker([marker.Latitude , marker.Longitude], {icon: pinkMarker})\n    );\n  });\n}\n\nnextProps.map.addLayer(clusteredMapMarkers);\n\n}\n}\n```\nnextProps.map.addLayer(clusteredMapMarkers); - make sence, because it's inside react-leaflet component and it receiving map as a prop.\n.forEach() iteration in that component I user, because I receiving specific .json from back-end.\n. Solution:\nThere is a new package for clustering markers with react-leaflet:\nhttps://www.npmjs.com/package/react-leaflet-markercluster\nES6 Source code. It looks like react need one more component rendering to access that params.\n1) In my practice, I had one issue with states, when I hardcoded them in constructor() {this.state ={}} they was corrupted, so I'm always using this.setState from componentDidMount to setStates in react.\n2) try to access those elements from componentDidUpdate cycle.\n```\ncomponentDidMount() {\n   this.setState({\n      map:null,\n      geoJson:null,\n      bounds:null,\n      countyObj:null,\n      countyData:null,\n      lat: 33.9301310, \n      lng: -84.7667300,\n      tileURL:'http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',\n      zoom: 10,\n      markers:null,\n      routes:null\n    });\n}\ncomponentDidUpdate() {\n   // log status to console and try to access to the elements that you need.\n}\n```\n. @rcwestlake I had the same issue when I configured marker with incorrect iconAnchor.\nLet's say you would like to set a custom icon for a map with a size iconSize: [28, 40], so you need to provide also iconAnchor (that is important) like iconAnchor: [14, 20].. I need to access marker, not inside React Component that renders some map, but inside react-leaflet LayerGroup.\nMarkers are sending to that LayerGroup as children's.\n```javascript\nclass MyComponent extends React.Component {\n  // That is you'r example:\n  bindMarker = (ref) => {\n    if (ref) {\n      console.log('marker element', ref.leafletElement)\n    }\n  }\nrender () {\n    return (\n      \n\n\n\n    )\n  }\n}\nclass MyCustomPlugin extends LayerGroup {\n  componentDidMount() {\n    this.props.children.forEach((reactLeafletMarker) => {\n        // that is where I need to have leafletElement\n        reactLeafletMarker.leafletElement;\n    });\n  }\n}\n```\nThe current solution, that was proposed:\n- Inside plugin (that receiving a list of react-leaflet markers) iterate through them\n- On each react-leaflet marker clone that marker, with sending ref property to marker, so then ref will return leafletElement\n- Push returned leafletElement to the list of leafletElements\n```javascript\nclass MyCustomPlugin extends LayerGroup {\n  componentDidMount() {\n    const listOfLeafletElements = [];\nthis.props.children.forEach((reactLeafletMarker) => {\n  React.cloneElement(reactLeafletMarker, { ref: (marker) => {\n    listOfLeafletElements.push(marker.leafletElement);\n  });\n\n});\n}\n```\nFull example:\nhttps://github.com/YUzhva/react-leaflet-markercluster/pull/16/files#diff-08e906cca00ce6702663aa1e3c2c5263R157\nBut that is kind of heavy solution, because each time when we receiving a list of markers, we need to iterate twice:\n- One iteration is super heavy because it's cloning react-component for getting marker leafletElement.\n- Another iteration, to add those markers from a leafletElements list to map.\nThat would be faster if Marker will have leafletElement from start, so there will be only one iteration that just adding that marker to map.. @PaulLeCam Notice, that MyComponent where you are getting ref.leafletElement and < MyCustomPlugin> - are different components.\nleafletElement should be accessible inside MyCustomPlugin\n(not inside MyComponent where are you writing that bindMarker function, please read above example).\n<Marker {...this.props} /> sending to the <MyCustomPlugin/> as children:\n```javascript\nclass MyCustomPlugin {\nthis.props.children // that is \n}\n```\nAnd that children should have a way to get marker leafletElement.. Okay. I'll try to record a video...\nThank you, for fast responses (=. Video (UPD: link is dead) - it's better to watch on speed 1.25x (=. Yep...\nLooks like there is not way, to make static function that will be accessible from parent component without rendering Marker )=\nThanks, for support.. ",
    "iam4x": "@PaulLeCam We could provide a React Component as fallback for server side rendering, check if window exists render the map or render the fallback? Something like that:\n<Map .... fallback={ReactComponent}>\n  ...\n</Map>\n. ",
    "dougajmcdonald": "Thanks for the workarounds gents, I ended up just using a client side bower package and not the react package, but will switch back now I know the render could be defined conditionally based on the environment\n. ",
    "dmitry": "@dougajmcdonald similar idea I'm using too. It's more flexible and maintainable.\n. Looks like my styles on development machine are loaded right after the map initialized (I haven't checked on production though...), and the container div is sized afterwards again once CSS styles are loaded.\n. ",
    "josebalius": "@dougajmcdonald I was wondering what was the solution for this? You guys are loading leaflet in with bower, and then proceeding to require react-leaflet the same way? Or are you guys also using bower to load react-leaflet? \n. ",
    "sohibul": "May someone give the example of this workaround\n. ",
    "jgimbel": "It's ugly, but it works.\n```\nlet Map, MapComponents\nclass LeafletMap extends Component {\ncomponentDidMount(){\n    //Only runs on Client, not on server render\n    Map = require('react-leaflet').Map\n    MapComponents = require('./mapComponents').default\n    this.forceUpdate()\n  }\nrender () {\n    return (\n      (Map)\n      ? (\n        \n\n\n      )\n      : (null)\n      }\n    )\n  }\n}\n```\n. Here is an example of how to create custom components, and the documentation. \nTLDR; Notice line 5. When creating a custom component, the map and layerContainer props must be passed down.\nThe initial example can be fixed by adding these props to the Marker.\n``` js\nimport React, { Component } from 'react';\nimport { Map, Marker } from 'react-leaflet';\nclass WrappedMarker extends Component {\n  render() {\n    const { map, layerContainer } = this.props; //Given by the Map component\n    return (\n      \n    );\n  }\n}\nexport default class MapView extends Component {\n  render() {\n    return (\n      \n\n\n    );\n  }\n}\n``\n. This component only renders it's children on mount, not on render or update. If you would like a custom  control component that updates, I created [react-leaflet-control](https://github.com/liveby/react-leaflet-control). If your not a fan of installing more external components, you can always copy the ~45 lines of source.\n. I believe how it currently works is the expected result because of how leafletjs works in the background, even though its not intuitive. Proposing to make the styles object a dynamic prop will break theresetStyles` function.\nFor more information...\nleafletjs will do something similar to\nthis.options = { ...this.options, ...this.options.styles }\nwhen you initialize. This is because the options.styles is considered the source and is never changed. Instead the options object is changed when setStyles function is used. (source).\nThis is because leafletjs holds the initial styles for resetStyle. Setting styles={styles} will set the initial styles, so when resetStyles is called, it will use this object to resetStyles. Making the styles prop dynamic will break leafletjs's reference to the initial styles. \n@PaulLeCam A bigger problem tied to GeoJson styles (for me) is that react-leaflet styles are only allowed to be objects, but leaflet allows styles to be objects or functions (source).\n. @benzen your option does not open the popup on mount (If that is what you are wanting), it merely calls bindPopup(<popup>). To do this I made a js fiddle to show how you can handle popups with state/flux/redux here. \nThe problem with this is with the onPopupclose event. When you remove a popup from the map, it calls map.removeLayer(<popup>), which removes the popup from the DOM then popupclose event fires (source). When it fires, react changes state, and then re-renders. This unmounts the Popup Component. In Popup's componentWillUnmount the function this.props.map.removeLayer(this.leafletElement) is then called again(source). This causes the popup to try to remove itself from the DOM again, and throws an error. \nThis could be simply fixed by checking if this.leafletElement._map is still set. This is unset on removeLayer(source)\njs\n  componentWillUnmount() {\n    super.componentWillUnmount();\n    this.removePopupContent();\n+   if(this.leafletElement._map){\n      this.props.map.removeLayer(this.leafletElement);\n+   }\n  }\nWe cannot use this.leafletElement._isOpen because \n1) it is set after map.removeLayer(this) is called (souce) and \n2) it is not compatible with Leaflet 1.0\nthis._map is how Leaflet 1.0 checks if the popup is open(source), and is also compatible with Leaflet 0.7.\n. I am unfamiliar with how I can unbind leaflet from controlling the state. Can you point me towards some docs?\n. I updated the jsfiddle to use those options, and all works. Thanks for the direction. As a note, using multiple popups this way can be risky, as you have to make sure only one popup is open in your state to keep consistency with the leaflet state.\n. If you are willing to use an outside component I created this component react-leaflet-control for this kind of thing.\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport L from 'leaflet';\nimport Control from 'react-leaflet-control';\nexport default (props) => (\n  <Control \n    map={this.props.map}\n    layerContainer={this.props.layerContainer}\n    position='topright'\n\n{\n  (props.freeDraw.mode === L.FreeDraw.MODES.CREATE)\n    ? 'Drawing Search'\n    : 'Draw Search'\n}\n\n\n)\n\n``\n..groupBy( this.categorizeAgent )`\nIs this grouping working correctly?\nFrom the screenshot and code you have given my first guess would be that you are creating a Overlay for every marker. Do you have react-devtools installed? From there you could check how many Overlay components are being created.\n. Here is a jsfiddle exmaple of using geojson.\n. The events example shows how you can use refs to be able to get the raw leaflet element from a child component. From there you can do ...\n``` js\ncomponentDidMount(){\n  const { map, geojson } = this.refs\n  map.leafletElement.setBounds(geojson.leafletElement.getBounds())\n}\n``\n. I found [documentation](http://stackoverflow.com/help/privileges/create-tags) for creating one. It basically needs 2 questions in 6 months asked with the tag, and sunshine with 1,500 reputation to create the first one.\n. Can we add documentation in the readme, or in the PR template to help others find the tag?\n. Yep. I tried without and it didn't pass the server side render test. Let me double check that I have leaflet v1 and see if that fixes it after the change.\n. Please have a look at the Travic CI output. Should the test be updated? It would seem that v1 does not add its own map id in v1 ([source](https://github.com/Leaflet/Leaflet/blob/v1.0.0-rc.2/src/map/Map.js#L710) and [related source](https://github.com/Leaflet/Leaflet/blob/v1.0.0-rc.2/src/dom/DomUtil.js#L17)).\n. Hi, we try to answer how-to questions on StackOverflow, and use issues for bugs in the library. You can use the react-leaflet tag in StackOverflow for how-to questions. They usually get answered with examples in 24 hours.\n. Firstly, we prefer to keep questions in stack overflow, and use issues for bugs. Second, react-leaflet-control is what you are looking for.\n. What version of leaflet.css do you have?\n. You can use [this HoC](http://stackoverflow.com/questions/38212174/is-it-possible-to-pass-context-into-a-component-instantiated-with-reactdom-rende) to pass context. I would suggest using it to continue the store.\nAn example would look like...  `. Your bounds are the same value. When i run this version it loads the first time for me.\nhttps://jsfiddle.net/31r878b8/\n----- Reply message -----\nFrom: \"David Cavaletto\" notifications@github.com\nTo: \"PaulLeCam/react-leaflet\" react-leaflet@noreply.github.com\nCc: \"Subscribed\" subscribed@noreply.github.com\nSubject: [PaulLeCam/react-leaflet] Map throws Invalid LatLng object: (NaN, NaN) error on initial page load with bounds property (#277)\nDate: Sat, Feb 4, 2017 11:54 AM\nI don't know how but I fixed this. I'm not really doing anything differently...\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHubhttps://github.com/PaulLeCam/react-leaflet/issues/277#issuecomment-277462844, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ABVaoGiIJY4W39bY2WeQWQj7_tRx30SBks5rZLszgaJpZM4L3N3a.\n. ",
    "stereobooster": "For future googlers, there is also https://github.com/masotime/react-leaflet-universal\nAnd some attempts to render leaflet on the server:\n  - https://github.com/pimterry/leaflet-map-server-component\n  - https://github.com/jieter/leaflet-headless\n. Found solution\n```js\n// @flow\nimport L from 'leaflet';\nimport {} from 'leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.js'\nimport PropTypes from 'prop-types';\nimport { childrenType, GridLayer } from 'react-leaflet';\nexport default class VectorgridLayer extends GridLayer {\n  static propTypes = {\n    children: childrenType,\n    opacity: PropTypes.number,\n    url: PropTypes.string.isRequired,\n    zIndex: PropTypes.number,\n  };\ncreateLeafletElement(props: Object): Object {\n    const { url, ...options } = props;\nreturn L.vectorGrid.protobuf(url, options);\n\n}\nupdateLeafletElement(fromProps: Object, toProps: Object) {\n    super.updateLeafletElement(fromProps, toProps);\n    if (toProps.url !== fromProps.url) {\n      this.leafletElement.vectorGrid.protobuf(toProps.url);\n    }\n  }\n}\n```\nExample:\njs\n<Map>\n  <VectorgridLayer\n    url= \"https://{s}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/{z}/{x}/{y}.vector.pbf?access_token={token}\"\n    attribution='\u00a9 <a href=\"https://www.mapbox.com/about/maps/\" target=\"_blank\">Mapbox</a> \u00a9 <a href=\"http://www.openstreetmap.org/copyright\" target=\"_blank\">OpenStreetMap</a>'\n  />\n</Map>. Also if anybody needs MapBoxGL integration:\n```js\n// @flow\nimport L from 'leaflet'\nimport {} from 'mapbox-gl-leaflet'\nimport PropTypes from 'prop-types'\nimport { childrenType, GridLayer } from 'react-leaflet'\nexport default class MapBoxGLLayer extends GridLayer {\n  static propTypes = {\n    children: childrenType,\n    opacity: PropTypes.number,\n    accessToken: PropTypes.string.isRequired,\n    style: PropTypes.string,\n    zIndex: PropTypes.number,\n  }\ncreateLeafletElement(props: Object): Object {\n    return L.mapboxGL(props)\n  }\n}\n```\ndepends on:\nhtml\n<script src='https://api.mapbox.com/mapbox-gl-js/v0.35.1/mapbox-gl.js'></script>\n<link href='https://api.mapbox.com/mapbox-gl-js/v0.35.1/mapbox-gl.css' rel='stylesheet' />\nyarn add mapbox-gl-leaflet\nCompared Leaflet.VectorGrid, OpenLayers and MapBoxGL. Only MapBoxGL feels fast.\n. it is not. I do not want to check visibility - I want to control visibility in declarative manner, like this:\njs\n<Popup isOpen={true}>\n<Popup isOpen={false}>\nI know that this lib integrates with third-party, so not all React paradigms are feasible, that's why I'm asking if this is good idea or not. As of now Marker-Popup pair works as uncontrolled component e.g. it maintain it's own internal state and this state updated directly with user interaction, not through react setState.\nWhat I'm suggesting is to implement  controlled component e.g. Popup will open if you set state or property externally.\n. This is not concern of Leaflet, this is concern of React implementation. Html input does not support this behaviour out of the box too, instead React component use event handler and e.preventDefault to achieve Reactive way to do it.. I get your point, way to do this is to implement \"plugin\". Just one note\n\nOne important thing to consider is that Leaflet maintains its own state and handles the interactions with the DOM\n\nhtml <Input> maintains its own state too, but React folks take step further and wrote wrapper to adapt it to React workflow. This is not a general stopper, this is just a choice. . ",
    "rktel": "it works,  too.\nIn index.html: \nInclude  ..rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\"..\nIn React Component\n`import React, { Component } from 'react'\nclass Mapa extends Component {\ncomponentWillMount() {\n    console.log('componentWillMount')\n    Map = require('react-leaflet').Map\n    TileLayer = require('react-leaflet').TileLayer\n    TileLayer = require('react-leaflet').TileLayer\n    Marker = require('react-leaflet').Marker\n    Popup = require('react-leaflet').Popup\n}\n\nrender() {\n    const position = [-12.76767, -76.343434]\n    return (\n\n            <Map center={position} zoom={10} style={{ height: \"100vh\" }}>\n                <TileLayer\n                    attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n                    url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n                />\n                <Marker position={position}>\n                    <Popup>\n                        <span>A pretty CSS3 popup. <br /> Easily customizable.</span>\n                    </Popup>\n                </Marker>\n            </Map>\n\n\n    )\n}\n\n}\nexport default Mapa`. ",
    "quangmydn": "rktel how to extends MapControl with componentWillMount().\nI want add search box by https://github.com/smeijer/leaflet-geosearch.. ",
    "evenfrost": "@PaulLeCam Is there any way to get onLoad event working? I have exactly same issue, and it seems to be webpack's style-loader is causing it. Currently there is no 'better solution to load your styles before', and ExtractTextPlugin is not an option (no hot styles reloading). \n. Seems this is dead end for stateless functional components users as we don't have componentDidMount handler. Would appreciate to see a workaround if somebody had one.\n. Managed to implement workaround with the help of #105. I'm binding to onLoad event in <Map> children, i.e.\njsx\n<TileLayer url={tiles} onLoad={handleLeafletLoad} />\nThen I get map element in handleLeafletLoad handler via event.target._map reference.\n. Same here.\n. This seems to be an issue with webpack style-loadernot operating well together with Leaflet as it loads styles after map initialization (see #46). Possible workaround is to set map container height with inline styles or use invalidateSize() method in componentDidMount handler, though this is not the option for functional React components.\n. Well, it seems event.target itself is a Leaflet element. Don't know how I couldn't have it managed before, but now it works flawlessly.\n. @TylerGriffin99 Sorry, don't remember, it was literally years ago. :sweat_smile:. ",
    "jisaacks": "It would probable be good to add a caveat to the following events section in the docs:\n\nLeaflet exposes its own events, different from React. You can listen to them using React-Leaflet by adding a callback to a property prefixed by on. Ex: onMoveend.\nCheck Leaflet documentation for the events associated to each component.\n\nStating that load/onLoad is not supported.\n\nI wanted to use this to get the mapBounds after rendering, because I only know the center and zoom before rendering.\nIt looks like you can do it like so:\njavascript\n<Map ref={comp => {\n  console.log( comp && comp.leafletElement.getBounds() )\n}} />. ",
    "fyyyyy": "My bad i thought leaflet supported it :)\nIn this case i will extend your base component\nThanks\n. ",
    "afilp": "Hello Paul,\nI am not sure how this works, I also want to use a divIcon instead of a simple icon and there are issues concerning the changes of this icon's HTML, etc. Can you please give an example? OR support the divIcon more inherently within \"react-leaflet\"? I am sure this is me not understanding something, it would be nice though to have an easy way (or example) to just use divIcons (that may change also) for rendering the marker.\nSee also here:\nhttp://stackoverflow.com/questions/30751850/react-and-real-dom-cooperation-in-leafletjs\n. Thanks, please note that I do not use the 'className' property but the 'html' one.\n(http://leafletjs.com/reference.html#divicon)\nI use it as such:\nvar myIcon = L.divIcon({\n          className: '',\n          iconSize: [24, 24],\n          html: `<div id=\"s${car.id}\"></div>`,\n        });\nWill that work?\n. Ok, thanks, it is just that the DivIcon mutates the DOM (like the \"PopUp\" does), so things can get pretty ugly when the HTML of the DivIcon changes (which does).\n. @luqmaan Thanks, I'll check this (note, I use ES6). I assume that the map needs to be a React component, not a window.map property (like the \"normal\" leaflet.js does).\n. ",
    "baziz": "Quadkeys are tile references that are encapsulated in one string, in contrast to the more common tile references that happen with x / y / zoom https://msdn.microsoft.com/en-us/library/bb259689.aspx\nIn order to accommodate that type of URL, I extended your TileLayer component\n``` javascript\nclass CustomTileLayer extends TileLayer {\ncomponentWillMount() {\nsuper.componentWillMount();\nconst { map, url, ...props } = this.props;\nthis.leafletElement.__proto__.getTileUrl = function (tilePoint) {\n\n            this._adjustTilePoint(tilePoint);\n            var myUrl = this._url.replace(/{s}/, 0).replace(/{q}/, \n            this._quadKey(tilePoint.x, tilePoint.y, this._getZoomForUrl()));\n            return myUrl;\n\n            };\n\nthis.leafletElement.__proto__._quadKey = function (x, y, z) {\n\n                var quadKey = [];\n                for (var i = z; i > 0; i--) {\n                    var digit = '0';\n                    var mask = 1 << (i - 1);\n                    if ((x & mask) != 0) {\n                        digit++;\n                    }\n                    if ((y & mask) != 0) {\n                        digit++;\n                        digit++;\n                    }\n                    quadKey.push(digit);\n                }\n                return quadKey.join('');\n            };\n\n} \n```\nwith the TileLayer component containing a url that has {q} in it and relabeled \"CustomTileLayer\"\n. @texas697 Been a couple years man - I'm sorry, I wish I could be of more help, but I think the code should be enough to get you going.  . ",
    "texas697": "@baziz \nI need to use this can you show me how you are using this pplease?. ",
    "michaelryancaputo": "Thanks, I am familiar with the Leaflet API, however, I don't quite understand how I can access getLeafletElement() to modify it.\n. ",
    "gambit3": "I'll actually disagree with the creator of this lib and say that this is exactly what I was looking for when creating a dynamic map using react. \nYou won't get a performance boost thats true but if you wan't to build a map ui using some kind of client side framework in my opinion this is the way to go.\nI've done exactly the same work as I'm doing now before with: vanilla Leaflet and Backbone and the react way seems to be the way to go in terms of code structure and maintenance.\nI've been working with react and react-leaflet for several months now and I can say that this library is  capable of driving a dynamic ui but not out of the box.\nI just issued a dump of some pull request of changes I had to make to make it work the way I needed to. And I know there still some issues.\nSo my answer to the original question would be:\n- you will get all the benefit of the react declarative code structure\n- as the author mentioned this is perfect if you already have a react app around a map and just wan't to display a map and not interact with it very much\n- you won't get any speed boost\n- depending on the size on your project and your requirements you'll run into some issues when building dynamic behaviours and probably you will have to familiarise yourself with the internals of react-leaflet and be able to make improvements to it\n. It's not live yet. I can show you this:\nhttp://mapwidget-staging.elasticbeanstalk.com/24\nwhich is an old backbone version of the map I'm working on.\nThe full map will live inside app.socialbicycles.com which is behind a paywall :(\nThe full map is the same as the widget version but has more features and it's connected to the back end using web-sockets so the markers and basically everything else updates live. This really works great with react-leaflet it's just like writing server side templates and it all magically works!\nI use react state to control marker icon css and html, popup content, popping markers in and out of clusters, rendering reversed polygons depending on zoom, and obviously adding removing markers and polygons.\nThe only thing that I wasn't able to manage using state are map position/center and popup state (open closed). This is tricky but probably solvable.\n. I've notice @PaulLeCam switch do this here:\nhttps://github.com/PaulLeCam/react-leaflet/commit/9945c662b933b6e817ac1e74fe8357d0fde1731f#diff-873cfcc6333674fc88cf194c7eae1641L1\nand assumed this was a convention of some sort he adopted\n. @bohlander I don't know exactly how to hack npm like that since I use a standalone build from /src. If you tweaked package.json my guess is you'd have to go to thenode_modules/react-leaflet dir and run npm compile to rebuild the /lib files inside react-leaflet package. I haven't included /lib/* files in this pr since it would make merging it difficult.\n. Just a habit. I'm not used to es6 yet this is my first time really using it.\n. Sure. I use different style when I write my other code so its easy to miss for me.\n. Again I'm one of those 'heretics' who don't use semicolons when writing my own stuff, so it's easy for me to miss this stuff. Do you perhaps have some recommendations for a linter (which plugs to sublime2 ideally) that would work on es6 and point out those kind of style stuff for me?\n. Well that was the whole point. Say in a render method you'll do something like this\njavascript\nvar positions = _.map(this.props.geoJsonPoints, (point)->{  return [point[1], point[0]})\n// or some other transformation of props that result in a new positions array\nrender <Polygon positions={positions} />\nthan you're constructing a new positions array on each render and !== does not wor. You are re-rendering the polygon even its positions didn't change (leaflet doesn't check that internally either) ie. touching the DOM which is bad for performance and very bad if you are re-rendering often especially polygons.\nYou can obviously work around that in your render method but if you're not aware of it its easy to miss. So this is just a react'y way of not touching the DOM if we don't have to.\n. Sure. The script should probably also live somewhere else and always build the same file. I didn't know how to organise it to be honest, just wanted to share the build script.\n. ",
    "tsemerad": "@gambit3 Were you able to track map zoom state? I want to keep the map's zoom level in a store so that various components can react to it (for example, turn off a layer when zoomed out enough).\n. ",
    "bohlander": "This looks really handy -- any tips on the best way to incorporate this change into my npm installed version of react-leaflet? I've tried tweaking my package.json to refer to the branch containing the pull request, but I don't think this is a good approach, seems like it needs to be explicitly built somehow.\n. Thanks @gambit3 -- I think I might try using your build script and see if I can produce a standalone version of react-leaflet to try instead. Looking forward to these pull requests getting merged!\n. ",
    "tomaszkepa": "js\nWarning: Failed propType: Invalid prop `icon` supplied to `Marker`, expected instance of `<<anonymous>>`. Check the render method of `EventMap`.\n``` js\nimport React, { Component, PropTypes } from 'react';\nimport reactMixin from 'react-mixin';\nimport { ReactScriptLoaderMixin } from 'react-script-loader';\nimport { Map, Marker, TileLayer } from 'react-leaflet';\nclass EventMap extends Component {\nstatic propTypes = {\n    latitude: PropTypes.number.isRequired,\n    longitude: PropTypes.number.isRequired,\n  };\nconstructor(props) {\n    super(props);\nthis.state = {\n  scriptLoading: true,\n  scriptLoadError: false,\n};\n\n}\nonScriptLoaded() {\n    this.setState({scriptLoading: false});\n  }\nonScriptError() {\n    this.setState({scriptLoading: false, scriptLoadError: true});\n  }\ngetScriptURL() {\n    return '//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js';\n  }\nrender() {\n    let renderMap = null;\n    const position = [this.props.latitude, this.props.longitude];\n    const zoom = 14;\nif (!this.state.scriptLoading && !this.state.scriptLoadError) {\n  const Leaflet = window.L;\n\n  renderMap = (\n    <Map center={position} zoom={zoom} minZoom={zoom - 3} maxZoom={zoom + 2}>\n      <TileLayer\n        url=\"http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\"\n        attribution=\"&copy; <a href=&quot;http://osm.org/copyright&quot; target=&quot;_blank&quot;>OpenStreetMap</a> contributors, &copy; <a href=&quot;http://cartodb.com/attributions&quot; target=&quot;_blank&quot;>CartoDB</a>\"\n        />\n      <Marker position={position} icon={Leaflet.divIcon()}/>\n    </Map>\n  );\n}\n\nreturn renderMap;\n\n}\n}\nreactMixin(EventMap.prototype, ReactScriptLoaderMixin);\nexport default EventMap;\n```\n. Ok thx you're right.\n. ",
    "snario": "Eh just ignore this -- the pull request I really need to make is a CONTRIBUTING.md file..\n. What's the progress like on this?\n. ",
    "hannesj": "I'm currently using react-leaflet with the Leaflet beta and haven't seen any issues yet. The only broken things have been due to changed z-indexes in Leaflet's CSS, which doesn't have anything to do with the actual components.\n. Also related to changing classnames is Leaflet/Leaflet#2662\n. @PaulLeCam It already calls unmountComponentAtNode. But only for the last component that has been rendered last in the popup. Now if I change the contents of the popup while it is open, I get memory leaks, as the old render trees are never purged for the components that have been mounted before the last. Do you mean that this is intentional behaviour?\n. ",
    "netsgnut": "I am also trying react-leaflet 0.7.0 with Leafet 1.0.0-beta.1. In the project here there are not much plugins and it seems to work straight out of box.\nFor anyone interested in testing it out, you may want to point your local package.json to my testing branch at \"react-leaflet\": \"netsgnut/react-leaflet#v0.7.0-with-leaflet-1.0b1\". I have just only changed package.json there; everything else is identical with v0.7.0 release.\n. ",
    "PatrickKing": "I just submitted a PR for Leaflet 1.0, based on some small changes to make Popups work.\nReact-leaflet seems to just work with Leaflet 1.0, but I haven't exhaustively tried all its features.\n. The failing tests are due to changes in Leaflet, it now reads clientHeight and clientWidth, which are properties that JSDom does not emulate. The result of the missing numbers is that NaNs are stored for some internal bookkeeping, this gives us the three Invalid LatLng object: (NaN, NaN) errors. \nI'm not sure how to fix this problem short of replacing JSDom and reworking the test suite. \n. After looking into it: I see that Leaflet is not automocked by Jest. I added this to each of the test files (Popup.js and Marker.js) that was seeing failures, and all tests are passing ... \n// Mock a Map function that doesn't work without a real DOM\nimport Leaflet from 'leaflet'\nLeaflet.Map.prototype.getSize = () => {\n  return new L.Point(1024, 768);\n}\nIt works, but is this a good approach? \n. PR updated, sorry for the wait! \n. ",
    "kofronpi": "Leaflet 1.0.0-rc.1 has been released so its new API should be stable now :+1: \n. ",
    "tjwebb": "\nBeing in beta means the API can still change\n\nThat's not what beta means. A new major version number would indicate an incompatible API change. beta just means there will be more bugs than usual.\n+1 Leaflet RC1 :)\n. ",
    "nqbao": "+1 for Leaflet 1.0 support\n. ",
    "lkolek": "+1\n. As I understand, it's all about ref in react.\nSo, you can have a component like this. In componentDidUpdate() method, leaflet instance is taken for invalidateSize() operation.\nclass MapPreview extends Component{\n...\nrender() {\n        return (\n            <Map  key=\"maymap\" \n                   ref=\"map\"\n            >\n...\n</Map>)}\ncomponentDidUpdate(){\n        var map = this.refs.map.leafletElement;\n        map.invalidateSize()\n    }\n}\n. ",
    "ballwood": "Its working reasonably well with 1.0 for the things we've been using it with. One error I did have was with the zoom control but fixed it by doing this if anyone was interested.\n```\nimport { ZoomControl } from 'react-leaflet';\nexport default class FixedZoomControl extends ZoomControl {\n  componentWillUnmount() {\n    this.leafletElement.remove();\n  }\n}\n```\n. cheers @bigsassy that fixed it\n. ",
    "Alappin": "What is the approximate timeline for the first stable release of this library to support leaflet version 1.x?\n. ",
    "marcinlichwala": "The class hierarchy is already quite deep and this is a feature that probably many library users would benefit from. At the moment it is not very intuitive that only one Polyline property makes the component update - it made me dive deep into the lib code to understand why things aren't working the way I would normally expect them to do. I would like to understand if there is any architectural motivation behind not including these properties in update.\n. ",
    "jgoux": "@swennemans Did you find the origine of this issue ? I can't see my vectors too, I'm also using webpack.\nEDIT : I also tried with ExtractTextPlugin without success.\nEDIT2 : No more issue, it wasn't about the CSS, but I used GeoJson coordinates for a Polygon, and the [lat, lng] are inverted in geojson, so I couldn't see it ! :+1: \n. @bradsimantel It has the getBounds() function which will allow me to center my map based on the elements' coordinates inside the FeatureGroup\nDisclamer:  I'm a total newbie with Leaflet, maybe there is an easier solution for my case. :)\n. ",
    "willkan": "I found that in my case, vector layer not display, not matter wheter use ExtractTextPlugin.\nBut when I set the svg style svg {height: auto, width: auto}, it goes to display well.\n. @PaulLeCam I have actually done all the boxes, but the problem still exist. Could you try the the example I mentioned above?. @PaulLeCam Did you mean if I want to properly update the maxZoom , I should directly write some code such as this.refs.map.leafletElement.setMaxZoom(max)?. uhh...okay, thanks.. ",
    "ferdyh": "I'm running into the same issue. Any suggestion on where to set this style?. ",
    "scttnlsn": "RC2 is working great.  Thanks!\n. ",
    "uniphil": "No, the problem is that the src/ directory does not exist on npm install.\n\n. So to be clear, react-leaflet is not extendable by design, and\njsx\nclass CustomizedMarker extends Marker {\nis not allowed.\nIf this is true, then react-leaflet is not for us. Just want to be clear before forking.\n. Hey, sorry for the tone of my previous messages. This library is an awesome step toward making great map apps, so thank you! I shouldn't jump on github issues before I have my morning coffee :smile:\nThe problem I was having with extending the components distributed in lib/ was.... I forgot to put lib/ in the import path haha.\nI still want to make the case for one more reason to considering distributing with the src/ directory: when extending react-leaflet components, stack traces that lead into the react-leaflet uncompiled source are much nicer do dig through. Similar to how leaflet distributes leaflet-src.js. Any chance of it?\n. Awesome, thanks! :cake: \n. Calling fitBounds manually works, but it moves all the bookkeeping logic into our app, which we are trying to avoid with React. The use-case here: We have \"international\", \"country\", and \"project\" views for geocoded data in Asia. We use react-router to draw chrome around the map and features on the map depending on the view. It's nice to just update bounds like the rest of our data and have react/react-leaflet deal with it.\nIf you would prefer, I can modify Map to handle a bounds prop instead of adding this BoundsMap component. In that case:\n- Setting bounds AND (center OR zoom) props is probably a mistake by the user\n  - it would be nice to log a warning. I don't see any warnings currently used, and console statements make the linter complain. Do you have a preferred way to do this? Can I add a warn.js module with /* eslint no-console: 0 */ that exports a warn function?\n  - If this case happens, which props should react-leaflet use to set the view -- bounds, or (center and zoom)?\n. Moved it all to dynamic bounds on <Map>: no validating or branching logic based on props -- last update wins.\n. Since React.Children.map only does a shallow mapping, this cannot be handled automatically.\nThe wrapping component can pass this.props.map down to its child manually and it works.\n. :+1:\n. ",
    "Smallmelo": "@uniphil i'm running into this same problem, and if you closed this ticket because you found a solution, it is unclear to me what it was. can you elaborate? \n. thank you, @jgimbel.  that cleared things up. makes much more sense.\n. @colllin can you share a sample of the solution you came up with?  i'm having trouble animating the entering of geojson.  for simplicity sake, i'm using a MyPolygon component that renders a react-leaflet GeoJson component.  do i need to setStyle in the componentDidMount method? i've tried wrapping the component in the ReactCSSTransition group, but doesn't work.\n. ",
    "taozhi8833998": "in react-leaflet 1.1.1version, the map and layerContainer is not in props of child component. map and layerContainer is not passed to child componet in react-leaflet 1.1.1 version ???. copy that. ok, thx, it works.\nFurther more, I have seen this from react official website\n\nIf you want your application to be stable, don't use context. It is an experimental API and it is likely to break in future releases of React.\n\nThanks for ur help!. ",
    "gothy": "Sorry, for some reason I was importing from 'leaflet' instead of 'react-leaflet' :\\\n. ",
    "samcorcos": "@PaulLeCam Just out of curiosity, is there a reason the CSS is not included automatically? Since it's a requirement, perhaps it should come with the package? I can put together the PR if you think it's a good idea.\n. ",
    "txs": "Still having the rendering issue even when include the css file. I don't think it's a conf issue. I tried to load with css and the issue is still happening!. ",
    "radnor": "If all your markers are receiving new props that cause them to re-render you can add a shouldComponentUpdate(nextProps, nextState) function inside src/Marker.js to determine whether or not the marker should continue on and trigger componentDidUpdate(prevProps).\n. ",
    "hunterc": "@radnor currently I'm creating the markers in the render function each time. If the loop creates a marker with the same props as the previous time, shouldn't the key be used to see if it needs to be removed/re-rendered?\n```\nrender() {\n  let markers = this.props.options.map((item, idx) => {\n    let ref = 'marker-' + idx;\nreturn (\n  <Marker key={item.id} ref={ref} position={item.location}>\n      <Popup>\n        {item.name}\n      </Popup>\n  </Marker>\n);\n\n});\nreturn (\n      \n\n\n            {markers}\n          \n\n\n  );\n}\n```\n. Closing this as it turned out to be an error in a wrapping library.\n. ",
    "ericsoco": "BTW, I noticed the lint step fails on Map and Popup (see Travis failure below ;) ). The content of this PR should be clean.\n. @PaulLeCam agreed. I'll report back when I've gotten this up on its own repo, and maybe we can add a link to it from your documentation in a shiny new Plugins section. Thanks!\n. Interesting tip on changing the key attribute. I'll give that a shot.\nI think you do understand the problem, based on your suggestion -- updating attributes of a react-leaflet component (in subsequent render() calls) does not actually update the component. (I saw this first with adding/removing a class in className, and I think I also saw that changes to a GeoJson's data didn't change the <path>'s d attribute.\nI'm short on time now but can try to boil this down to a working repro if that is useful.\n. @luqmaan that's essentially what I ended up doing, though I did not encapsulate it into a component like you did. @PaulLeCam I'm under the gun right now and can't put together a repro just yet. Will do so as soon as I'm able.\n. @paullecam that's the technique @mourner recommends, in absence of any formal way to update data: https://github.com/Leaflet/Leaflet/issues/1416#issuecomment-13778453\n. Thanks @PaulLeCam -- still working toward a deadline (two projects converging...) so will be a bit but will come back to this as soon as I'm able!\n. ",
    "aauberg": "I see! Very good, thank you for this example!\n. I wondered about that, thanks @PaulLeCam !\n. ",
    "stevenmason": "Cheers for the quick reply version 0.7.0. I'll make a demo project.\n. Okay awesome thank you, I'll update to v0.8.\n. Good point, I needed this functionality for the application I am making, the only reason it seems to work for me is that I set the props open state in the obvious cases where leaflet changes the state for example on click of a marker and clicking on the map.\n. ",
    "RobinMalfait": "Hey\nI'll try this asap, thing is I used a hack :p\nI saw that it had the .left class, so I did something like\ncss\n.left {\n    right: 0!important; \n}\nBut this is probably better, thanks!\n. Hey @PaulLeCam thank you very much!\n. ",
    "yantakus": "There is controls position option: http://leafletjs.com/reference.html#control-positions\nDid it appear recently or I misunderstand smth?\n. I had a local problem with redux-devtools, that caused leaflet not rerender map on state change. So I'm closing it.\n. I've found the way it works:\n```\nimport {MapLayer} from 'react-leaflet';\nimport L from 'leaflet';\nimport 'leaflet-routing-machine';\nexport default class RoutingMachine extends MapLayer {\n  componentWillMount() {\n    super.componentWillMount();\n    const {map, from, to} = this.props;\n    this.leafletElement = L.Routing.control({\n      position: 'topleft',\n      waypoints: [\n        L.latLng(from[0], from[1]),\n        L.latLng(to[0], to[1]),\n      ],\n    }).addTo(map);\n  }\nrender() {\n    return null;\n  }\n}\n```\nIs it right?\n. Unfortunately it doesn't work fully. The markers and the path are displayed, but the routing control (this one: http://take.ms/qhUEC) is empty. Any ideas?\n. I've accidentally figured it out myself: when Map component's zoom option is provided, it just fails silently, without errors in the console. Otherwise (without zoom option) it works well.\nSo in my case it should be:\n<Map center={position}>\n    <TileLayer url={`http://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png',`} />\n    <Marker position={position} />\n    <Routing from={[57.74, 11.94]} to={[57.6792, 11.949]} />\n</Map>\n. And the map itself doesn't work without providing zoom option, which is weird because it isn't a required option.\nSo to be clear, this works:\n<Map center={position} zoom={10}>\n    <TileLayer url={`http://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png',`} />\n    <Marker position={position} />\n</Map>\nAnd this doesn't:\n<Map center={position}>\n    <TileLayer url={`http://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png',`} />\n    <Marker position={position} />\n</Map>\nYou should make it required or add a default value.\n. You are not right, zoom property prevents creation of the map.\nThis configuration:\n<Map center={position}>\n    <TileLayer url={`http://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png',`} />\n</Map>\ndoesn't work, it returns a blank page without any errors in the console while:\n<Map center={position} zoom={13}>\n    <TileLayer url={`http://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png',`} />\n</Map>\nworks well.\nAnd this is a problem for me, because leaflet-routing-machine doesn't work if zoom is provided.\nAny ideas?\n. My question was not about the plugin. I wonder why this library doesn't work for me without zoom parameter while you say it works.\n. Hi, @eelcocramer. Yes, I did. I'm using condition and render separate instances of <Map /> with unique keys. Here's an example:\nrender() {\n    const {position, fromLat, fromLon, toLat, toLon, routingActive, itinerary} = this.state;\n    return (\n      !routingActive ?\n      <Map\n        key=\"map\"\n        zoom={13}\n        center={position}\n        zoomControl={false}\n      >\n        <TileLayer url={`http://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png`} />\n        <ZoomControl position=\"bottomright\" />\n        <Marker position={position} />\n      </Map> :\n      <div className=\"map\">\n        <Map\n          key={`routing-${fromLat}-${fromLon}-${toLat}-${toLon}`}\n          zoomControl={false}\n        >\n          <TileLayer url={`http://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png`} />\n          <ZoomControl position=\"bottomright\" />\n          <Routing\n            coords={{fromLat, fromLon, toLat, toLon}}\n            itineraryReady={this.initItinerary}\n          />\n          {itinerary ? itinerary.route.instructions.map((item, i) => {\n            const coordinate = itinerary.route.coordinates[item.index];\n            const radius = this.state.hoveredPoint === i ? 3 : 2;\n            const color = this.state.hoveredPoint === i ? '#455a64' : '#4495d2';\n            return (\n              <CircleMarker\n                key={coordinate}\n                radius={radius}\n                color={color}\n                fillColor=\"white\"\n                opacity={1}\n                fillOpacity={0.7}\n                center={coordinate}\n                onMouseOver={this.onCircleMouseOver.bind(null, i)}\n                onMouseOut={this.onCircleMouseOut}\n              />\n            );\n          }) : '' }\n        </Map>\n        {this.state.itinerary ?\n          <Itinerary\n            itinerary={this.state.itinerary}\n            map={this.state.map}\n            close={this.unmountItinerary}\n            mouseOver={this.onItineraryMouseOver}\n            hoveredPoint={this.state.hoveredPoint}\n          /> : ''\n        }\n      </div>\n    );\n  }\n. @artemkarpovich Yes, it is solved.\n. This was a very complex app, no way to extract the leaflet part to show and I can't publish its full source code of course. What exactly you want to achieve and what problems do you face? I can try to help if you describe your use-case in detail.. @Benvorth I'm pretty sure I had the problem with markers, but to be honest I don't remember how I solved it (this was more than a year ago). So I'll publish here the source code of all the files related to react-leaflet, I hope this can help you.\n```javascript\n// map-search-result.js: main page of map search and routing\nimport React, {PropTypes} from 'react';\nimport Component from 'components/pure-component';\nimport ImmutablePropTypes from 'react-immutable-proptypes';\nimport { Map, Marker, TileLayer, ZoomControl } from 'react-leaflet';\nimport Routing from 'components/search/routing';\nimport { GEOFABRIK_API_KEY } from 'constants/search';\nimport * as searchActions from 'actions/search';\nimport { connect } from 'react-redux';\nimport { pushState } from 'redux-router';\nimport {isEmpty} from 'lodash';\nimport Itinerary from 'components/search/itinerary';\n@connect(\n  state => ({\n    routingCoords: state.search.get('routingCoords'),\n    router: state.router.location,\n  }),\n  {\n    ...searchActions,\n    pushState,\n  }\n)\nexport default class MapSearchResult extends Component {\n  static propTypes = {\n    item: ImmutablePropTypes.map,\n    results: ImmutablePropTypes.map,\n    routingCoords: PropTypes.object,\n    router: PropTypes.object,\n    fromLat: PropTypes.number,\n    fromLon: PropTypes.number,\n    toLat: PropTypes.number,\n    toLon: PropTypes.number,\n  }\nconstructor() {\n    super();\n    this.state = {\n      position: [],\n      routingActive: false,\n      fromLat: null,\n      fromLon: null,\n      toLat: null,\n      toLon: null,\n      itinerary: undefined,\n    };\n  }\ncomponentWillMount() {\n    const {results, router: {query: {s, fromLat, fromLon, toLat, toLon}}} = this.props;\n    if (s && fromLat && fromLon && toLat && toLon) {\n      this.setState({\n        routingActive: true,\n        fromLat,\n        fromLon,\n        toLat,\n        toLon,\n      });\n    }\n    this.changePosition(results.getIn(['0', 'lat']), results.getIn(['0', 'lon']));\n  }\ncomponentWillReceiveProps(newProps) {\n    const {results, routingCoords, router: {query: {s, fromLat, fromLon, toLat, toLon}}} = newProps;\n    this.changePosition(results.getIn(['0', 'lat']), results.getIn(['0', 'lon']));\n    if (!isEmpty(routingCoords)) {\n      this.setState({\n        fromLat: routingCoords.fromLat,\n        fromLon: routingCoords.fromLon,\n        toLat: routingCoords.toLat,\n        toLon: routingCoords.toLon,\n      });\n    }\n    if (s && fromLat && fromLon && toLat && toLon) {\n      this.setState({\n        routingActive: true,\n      });\n    } else {\n      this.setState({\n        routingActive: false,\n      });\n    }\n    if (\n      fromLat !== this.props.fromLat ||\n      fromLon !== this.props.fromLon ||\n      toLat !== this.props.toLat ||\n      toLon !== this.props.toLon\n    ) {\n      this.setState({\n        fromLat,\n        fromLon,\n        toLat,\n        toLon,\n      });\n    }\n  }\nchangePosition(lat, lon) {\n    const positionLat = parseFloat(lat);\n    const positionLon = parseFloat(lon);\n    this.setState({position: [positionLat, positionLon]});\n  }\ninitItinerary(itinerary) {\n    this.setState({itinerary});\n  }\nrender() {\n    const {position, fromLat, fromLon, toLat, toLon, routingActive} = this.state;\n    return (\n      !routingActive ?\n      \nhttp://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png} />\n        \n\n :\n      \nrouting-${fromLat}-${fromLon}-${toLat}-${toLon}}\n          scrollWheelZoom={false}\n          zoomControl={false}\n        >\n          http://tile.geofabrik.de/${GEOFABRIK_API_KEY}/{z}/{x}/{y}.png} />\n          \n\n\n        {this.state.itinerary ?  : ''}\n      \n    );\n  }\n}\n```\n``` javascript\n// routing.js\nimport {PropTypes} from 'react';\nimport {MapLayer} from 'react-leaflet';\nimport L from 'leaflet';\nimport 'leaflet-routing-machine';\nimport {isEqual} from 'lodash';\nexport default class RoutingMachine extends MapLayer {\n  static propTypes = {\n    itineraryReady: PropTypes.func,\n  };\ncomponentWillMount() {\n    super.componentWillMount();\n    const {coords, map} = this.props;\n    this.leafletElement = L.Routing.control({\n      position: 'topleft',\n      waypoints: [\n        L.latLng(coords.fromLat, coords.fromLon),\n        L.latLng(coords.toLat, coords.toLon),\n      ],\n      collapsible: false,\n      show: false,\n    }).addTo(map);\n    this.leafletElement.on('routeselected', (e) => {\n      this.props.itineraryReady({e});\n      console.log(e);\n    });\n  }\ncomponentWillReceiveProps(newProps) {\n    const {coords} = newProps;\n    if (!isEqual(coords, this.props.coords)) {\n      this.leafletElement.getPlan().setWaypoints([\n        L.latLng(coords.fromLat, coords.fromLon),\n        L.latLng(coords.toLat, coords.toLon),\n      ]);\n    }\n  }\nrender() {\n    return null;\n  }\n}\n```\n```javascript\nimport React, {PropTypes} from 'react';\nimport Component from 'components/pure-component';\nimport L from 'leaflet';\nimport 'leaflet-routing-machine';\nexport default class Itinerary extends Component {\n  static propTypes = {\n    data: PropTypes.object,\n  }\nconstructor() {\n    super();\n    this.formatter = new L.Routing.Formatter({});\n  }\ncomponentDidMount() {\n}\nrender() {\n    const {e} = this.props.data;\n    return (\n      \nRoute\nLength: {this.formatter.formatDistance(e.route.summary.totalDistance)}. Time: {this.formatter.formatTime(e.route.summary.totalTime)}.\n        {e.route.instructions.map((item) => {\n          return (\n            {this.formatter.formatInstruction(item)}\n          );\n        })}\n      \n    );\n  }\n}\n```\n```javascript\n// routing-controls.js\nimport React, {PropTypes} from 'react';\nimport Component from 'components/pure-component';\nimport {connect} from 'react-redux';\nimport * as appActions from 'actions/app';\nimport * as searchActions from 'actions/search';\nimport {pushState} from 'redux-router';\nimport Autosuggest from 'components/common/autosuggest';\nimport {pick} from 'lodash';\nimport cx from 'classnames';\n@connect(\n  state => ({\n    router: state.router.location,\n  }),\n  {\n    ...appActions,\n    ...searchActions,\n    pushState,\n  }\n)\nexport default class RoutingControls extends Component {\n  static propTypes = {\n    hideRouting: PropTypes.func.isRequired,\n    getMapSuggestions: PropTypes.func,\n    activateRouting: PropTypes.func,\n    router: PropTypes.object,\n    pushState: PropTypes.func.isRequired,\n  }\nconstructor() {\n    super();\n    this.state = {\n      hidden: false,\n      togglePushed: false,\n    };\n    this.from = '';\n    this.fromLat = null;\n    this.fromLon = null;\n    this.to = '';\n    this.toLat = null;\n    this.toLon = null;\n  }\nhideRouting() {\n    const {pushState, hideRouting, router: {query}} = this.props;\n    pushState({}, /search, {\n      ...pick(query, ['type', 'q']),\n    });\n    hideRouting();\n  }\nsaveFromCoords(suggestion) {\n    this.from = suggestion.display_name;\n    this.fromLat = suggestion.lat;\n    this.fromLon = suggestion.lon;\n  }\nsaveToCoords(suggestion) {\n    this.to = suggestion.display_name;\n    this.toLat = suggestion.lat;\n    this.toLon = suggestion.lon;\n  }\nactivateRouting() {\n    const {pushState, activateRouting, router: {query}} = this.props;\n    const from = this.from;\n    const fromLat = this.fromLat;\n    const fromLon = this.fromLon;\n    const to = this.to;\n    const toLat = this.toLat;\n    const toLon = this.toLon;\n    pushState({}, /search, {\n      ...query,\n      from,\n      fromLat,\n      fromLon,\n      to,\n      toLat,\n      toLon,\n    });\n    activateRouting({\n      fromLat,\n      fromLon,\n      toLat,\n      toLon,\n    });\n  }\ntoggle() {\n    this.setState({'hidden': !this.state.hidden}, () => setTimeout(() => this.setState({'togglePushed': this.state.hidden}), 1000));\n  }\nreverse() {\n    const {pushState, router: {query, query: {to, toLat, toLon, from, fromLat, fromLon}}} = this.props;\npushState({}, `/search`, {\n  ...query,\n  from: to,\n  fromLat: toLat,\n  fromLon: toLon,\n  to: from,\n  toLat: fromLat,\n  toLon: fromLon,\n});\n\n}\nrender() {\n    const {router: {query: {from, to}}} = this.props;\n    const routingClassName = cx({\n      'routing': true,\n      'routing--hidden': this.state.hidden,\n    });\n    const routingToggleClassName = cx({\n      'routing__toggle': true,\n      ' routing__toggle--pushed': this.state.togglePushed,\n    });\n    return (\n      \n\n\n\n\n\nRoute planning\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGo\n\n\n\n    );\n  }\n}\n```\n// package.json\n...\n    \"leaflet\": \"^0.7.5\",\n    \"leaflet-routing-machine\": \"^2.5.0\",\n    \"react-leaflet\": \"^0.9.0\",\n...\nThis was just a prototype, so don't pay attention the code is so dirty. First of all it works. It would be refactored if the app survive.. ",
    "jayenashar": "hi @PaulLeCam i've disabled the zoom control with zoomControl={false} as above added a <ZoomControl> component with position.  it works as i expect, but I don't see the zoomControl prop in the https://react-leaflet.js.org/docs/en/components.html#map docs.. ",
    "bradsimantel": "Leaflet markers don't have a color option, but they do have an icon option, and React-Leaflet will update your map when the value of that option changes. You can read more about Leaflet's icon here: http://leafletjs.com/reference.html#icon.\n. How would this be different from your LayerGroup implementation? I was planning on trying to get this syntax working for FeatureGroup this weekend (and then opening a pull request).\n. @jgoux: Sorry for the miscommunication! I understand that Leaflet's FeatureGroup has some useful methods that differentiate it from LayerGroup. I was trying to ask @PaulLeCam how he thinks a component wrapper around FeatureGroup that allows for child Marker components might be different from the current wrapper around LayerGroup.\n. This is awesome, @PaulLeCam! Thanks so much! I'll post updates as I try stuff.\n. ",
    "jonboiser": "Hi Paul,\nI like the potential of this library for quickly bootstrapping geospatial apps written in React. Are there are any tasks you can use help with?\n. Cool. I'll take a look at how you've implemented the Zoom control. I think I can help with the docs and website, once I play around with the library. At my company, we started a similar project for the ArcGIS JS API and Leaflet, but think we should deprecate the Leaflet piece, since this library is available.\n. I pushed some code for the AttributionControl to my fork. It seems like coding the other controls will be pretty much the same. I'll tackle the others during the week and submit a PR.\n. Here is one solution I've been working on for the LayersControl. In your Map, you can include multiple layers as children.\njsx\n<Map bounds={this.state.bounds}>\n  <TileLayer\n    attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n    layerName='OpenStreetMap'\n    url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n  />\n  <TileLayer\n    attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n    layerName='OpenStreetMap2'\n    url='http://otile4.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png'\n  />\n  <LayersControl baseLayers={['OpenStreetMap', 'OpenStreetMap2']}/>\n</Map>\nThe difference is that you pass layerName props into the layers, and pass an array matching those names as a prop into LayersControl.\nI'm not sure we can look at all the layers synchronously, so in the LayersControl componentWillMount stage, we listen for these layers being added to the map asynchronously. When the layer is added, we also add it to the control. When we are sure the last layer is added, we remove the event listener.\n. @chriswiggins Could you give a code example of this?\n\nI was wondering if it was possible to pass in a <TileLayer> through to LayersControl\n\nI think I had a similar idea when I first wrote these wrappers (see my earlier comment), but I think it would involve writing some more logic into the guts of LayersControl to pull it off.\n. So you would wrap the LayersControl-composed-with-TileLayers in a Map like this? I think this would be a nice way to work with Leaflet.\n<Map>\n<LayersControl ...layersOpts>\n    <TileLayer type='base' title='Street View' selected='true' ...otherOpts/>\n    <TileLayer type='base' title='Satellite View' ...otherOpts />\n    <ImageOverlay type='Overlay' title='Overlay' ...otherOpts />\n</LayersControl>\n</Map>\n. ",
    "jampy": "Any news on this, since meanwhile there is even a second RC available?\n. > Closing as it's not an issue that can be fixed in this lib\nMaybe a warning or something like that in the README?\nI guess most people using react-leaflet will use Webpack and will run into the same problem, loosing quite some of time to find the reason (like me).... Apparently all base layers are displayed at the same time in 1.1.2. ",
    "cocodrino": "update: I've tried the same code in the doc\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Map, Marker, Popup, TileLayer } from 'react-leaflet';\nconst position = [51.505, -0.09];\nconst map = (\n  \n\n\nA pretty CSS3 popup.Easily customizable.\n\n\n\n);\nReactDOM.render(map, document.getElementById('root'));\n```\nwith identical results, the image matrix is not correct..thanks!!\n. ups..sorry @PaulLeCam...thank you so much!!!\n. thanks @PaulLeCam  sorry for not answer before, this works nice...\n. ",
    "AngusMackHPE": "What's your HTML and CSS look like?\nYou need a bounding div with dimensions to insert the map into, otherwise you see this sort of behaviour.\n. ",
    "tormod17": "We have the same problem, it would be great to see the code you used to get past this.\n. ",
    "artemkarpovich": "Hi, @web2style. I want to create a react-leaflet component for routing-machine, your problem is solved?\n. @web2style, could you show how this problem has been solved? I first worked with leaflet and maps. Thank you.\n. ",
    "Benvorth": "@web2style cloud you please provide a full example? Perhaps in its own repository? I tried to follow your code posted here but didn't quite get it right.... My environment is ES6 + babel + webpack\nThe map-component looks like this:\nimport React from 'react'\nimport L from 'leaflet'\nimport {Map, Marker, Popup, TileLayer} from 'react-leaflet'\nimport 'leaflet/dist/leaflet.css'\nimport 'leaflet-routing-machine/dist/leaflet-routing-machine.css'\nimport Routing from './components/routing'\n\nexport default React.createClass({\n\n  getInitialState () {\n    return {\n      lat: 51.505,\n      lng: -0.09, // London\n      zoom: 13\n    }\n  },\n\n  render () {\n    const {lat, lng, zoom} = this.state\n\n    const position = [lat, lng]\n    let markerIcon = L.icon({\n      iconUrl: require('../img/leafletjs/marker-icon.png'),\n      shadowUrl: require('../img/leafletjs/marker-shadow.png'),\n      iconSize:     [25, 41], shadowSize:   [41, 41], iconAnchor:   [12, 41],\n      shadowAnchor: [20, 41], popupAnchor:  [0, -45]\n    })\n\n    return (\n      <div>\n        <Map center={position} zoom={zoom}>\n          <TileLayer\n            url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n            attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n          />\n          <Marker position={position} icon={markerIcon}>\n            <Popup>\n              <span>A pretty CSS3 popup.<br/>Easily customizable.</span>\n            </Popup>\n          </Marker>\n          <Routing from={[57.74, 11.94]} to={[57.6792, 11.949]} />\n        </Map>\n      </div>\n    )\n  }\n})\n\nAnd the routing.js component like this (following your example):\nimport {MapLayer} from 'react-leaflet'\nimport L from 'leaflet'\nimport 'leaflet-routing-machine'\n\nexport default class RoutingMachine extends MapLayer {\n\n  componentWillMount() {\n    super.componentWillMount()\n    const {map, from, to} = this.props\n    this.leafletElement = L.Routing.control({\n      position: 'topleft',\n      waypoints: [\n        L.latLng(from[0], from[1]),\n        L.latLng(to[0], to[1])\n      ]\n    }).addTo(map)\n  }\n\n  render() {\n    return null\n  }\n}\n\nThis first results in an error:\n\nand after ignoring the error results in a map that looks like this:\n\nWhat am I missing here? I don't understand why the start/end marker icons are missing as well...\nThe <Marker> in London is visible btw...\n. @web2style \ud83d\udc4d. ",
    "seclace": "@Benvorth do you find the solution for this use case? Could you share it with others, please?). @lbrouckman you can access the map by ref to it: ref='map', however it is the react ref component and to get your leaflet map you need to call this.refs.map.leafletElement and then you can add layers to your map directly.. It will be better, if you show your code here :) \nI see you are trying to add routing machine, I added it by this way:\nMap.js:\n```javascript\nimport React, { Component } from 'react';\nimport { Map, TileLayer } from 'react-leaflet';\nimport { MAPBOX_URL } from 'consts';\nimport Routing from './Routing';\nconst position = [53.349183, 83.761164];\nclass MapContainer extends Component {\n  render() {\n    return (\n       this.map = map}>\n        \n\n\n    );\n  }\n}\nMapContainer.propTypes = {};\nMapContainer.defaultProps = {};\nexport default MapContainer;\n```\nRouting.js:\n```javascript\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport L from 'leaflet';\nimport { Popup } from 'react-leaflet';\nimport 'leaflet-routing-machine';\nimport 'leaflet-control-geocoder';\nimport 'leaflet-routing-machine/dist/leaflet-routing-machine.css';\nimport { MAPBOX_TOKEN, MAPBOX_SERVICE_URL } from 'consts';\nclass Routing extends Component {\n  static propTypes = {\n    map: PropTypes.object,\n  };\nconstructor(props) {\n    super(props);\n    this.state = {\n      routingPopUp: null,\n    };\n    this.initializeRouting = this.initializeRouting.bind(this);\n    this.destroyRouting = this.destroyRouting.bind(this);\n    this.createPopupsHandler = this.createPopupsHandler.bind(this);\n    this.setRoutingPopUp = this.setRoutingPopUp.bind(this);\n  }\ncomponentDidUpdate() {\n    this.initializeRouting();\n  }\ncomponentWillUnmount() {\n    this.destroyRouting();\n  }\ninitializeRouting() {\n    if (this.props.map && !this.routing) {\n      const plan = new L.Routing.Plan([\n        L.latLng(53.349183, 83.761164),\n        L.latLng(51.292651, 85.686975)\n      ], {\n        routeWhileDragging: false,\n        geocoder: L.Control.Geocoder.nominatim(),\n      });\n  this.routing = L.Routing.control({\n    plan,\n    serviceUrl: MAPBOX_SERVICE_URL,\n    router: L.Routing.mapbox(MAPBOX_TOKEN),\n  });\n\n  this.props.map.leafletElement.addControl(this.routing);\n  L.DomEvent.on(this.props.map.leafletElement, 'click', this.createPopupsHandler);\n}\n\n}\ndestroyRouting() {\n    if (this.props.map) {\n      this.props.map.leafletElement.removeControl(this.routing);\n      L.DomEvent.off(this.props.map.leafletElement, 'click', this.createPopupsHandler);\n    }\n  }\ncreatePopupsHandler(e) {\n    const position = e.latlng;\n    const startBtnOnClick = () => {\n      this.routing.spliceWaypoints(0, 1, position);\n      this.setRoutingPopUp(null);\n    };\n    const endBtnOnClick = () => {\n      this.routing.spliceWaypoints(this.routing.getWaypoints().length - 1, 1, position);\n      this.setRoutingPopUp(null);\n    };\n    const startBtn = Set begin position;\n    const endBtn = Set end position;\n    const children = (\n      {startBtn}\n      {endBtn}\n    );\n    const onClose = this.setRoutingPopUp;\n    this.setRoutingPopUp({ children, position, onClose });\n  }\nsetRoutingPopUp(routingPopUp) {\n    this.setState({ routingPopUp });\n  }\nrender() {\n    const { routingPopUp } = this.state;\n    if (routingPopUp) return ;\nreturn null;\n\n}\n}\nexport default Routing;\n```\nI know that it's need to be refactored because it looks very hopeless, but for a now It's enough for me and It is working :). ",
    "lbrouckman": "@yantakus using the code you provided, I get the error that map (from `const {coords, map} = this.props) is undefined and so addLayer cannot be called. Thanks! I'm seeing the route show up now, but not the map and getting this error:\n\nAny ideas?\n. ",
    "gryzzly": "One way to get a reference to Leaflet map object is to ref the react-leaflet Map component and access its leafletElement property. You could make your own Map component that would be wrapping react-leaflet:\n``` js\nimport react from 'react';\nimport {Map} from 'react-leaflet';\nexport default react.createClass({\n  displayName: 'Map',\n  componentDidMount() {\n    this.mapApi = this.refs.map.leafletElement; // <= this is the Leaflet Map object\n  },\n  fitBounds() {\n    this.mapApi.fitBounds();// you can access Leaflet methods\n  },\n  render() {\n    // all the props that react-leaflet map accepts can be passed to this wrapper\n    return {this.props.children}\n  }\n});\n```\n. ",
    "Spaxe": "I ran into this exact issue, thanks @PaulLeCam for the suggestion about updating the key. That was more difficult to debug than it should have been.\n. Just in case someone stumbles on this, and needs more help:\n<Map zoomControl={false} >\nis what @PaulLeCam is referring to in http://leafletjs.com/reference.html#map-constructor\n. Could you elaborate what you mean by provider functionality, @ekatzenstein?. Why throw an error where as before it was fine?\nThe issue is that MayLayer.js now has\n// eslint-disable-next-line no-unused-vars\n  MapLayer.prototype.createLeafletElement = function createLeafletElement(props) {\n    throw new Error('createLeafletElement() must be implemented');\n  };\nWhich means any classes subclassing subsequently is now forced to implement a possibly empty function just so it works again.\nEdit: I added createLeafletElement () {} in my subclass and it works again.. @jetaix See code excerpt:\n```\n// React-Leaflet addition\n// See https://github.com/PaulLeCam/react-leaflet/blob/master/src%2FImageOverlay.js\n//\n// Given a Hyrax endpoint URL, this layer adds an ImageOverlay layer on Leaflet\n// and refreshes its image content based on the Hyrax service endpoint.\n// Unlike WMS services, images are constructed client-side, and it offers\n// flexibility of changing colour maps and thresholds without re-querying the\n// server.\nexport default class HyraxMapLayer extends MapLayer {\n// See https://github.com/PaulLeCam/react-leaflet/issues/275\n  createLeafletElement () {}\n```. ",
    "ayozebarrera": "I was thinking maybe its a Leaflet thing... but I haven't tried yet\nAbout the code example.. you just have to add a polyline, remove it from the map and then check the div .leaflet-overlay. \nIf there is a empty svg, that is what I'm talking about.\nI'll try asap\n. Ok, Its a Leaflet thing. Sorry for the issue\n. Great, thanks\n. Problem... not.. but maybe you could clean it? or do you need those unused variables?\n. Hi, still happening to me with ^1.9.1 and I'm ussing maxZoom property.\nBtw, just checked v2 example on codesandbox and updating it with maxZoom={19} will break too!\nWhat I missing?\nThanks!. Sorry about my english. I know it doesn't force or do anything by itself.\nI'll register all events that updates the bounds of the map then :rofl: \nThankyou. Thanks @alexrussell. I tried to explain it but... was hard :p\nAnyway, like I said when I close the issue, I'm registering events on mount and it's working nice for me:\n```jsx\n  componentDidMount() {\n    this.addMapListeners();\n  }\naddMapListeners = () => {\n    if (this.refs.map) {\n      this.refs.map.leafletElement.on('zoomstart', this.onEvent);\n      this.refs.map.leafletElement.on('movestart', this.onEvent);\n    }\n  }\nonEvent = () => {\n    if (this.state.bounds) {\n      this.setState({\n        bounds: null\n      });\n    }\n  }\n```. Thanks @alexrussell. I'm removing them anyway, thanks :). Thanks @PaulLeCam . It does! thanks. ",
    "rbrtmrtn": "I'm trying to do something similar -- every time the map moves I'd like to display the coordinates on screen. I understand how to listen for drags (e.g. <Map onDragend={this.handleDrag} />), but I'm not sure how to get a reference to the Leaflet object to call getCenter() on. My drag callback gets passed what appears to be an event object, but I'm not seeing any obvious references to the map.. Scratch that -- the map is e.target :). Hi @austere-rm, to be honest I can't really remember getting this to work but I think it involved listening to the onDragend event on the Map instance  -- your callback will be passed an event object which has an attribute target. That's the Leaflet map object, and from there you should be able to call the native LeafletgetCenter` method to get the coords. Hope that helps!. ",
    "austere-rm": "@rbrtmrtn would you mind sharing how you did this? I'm trying to render the current map centre also, but having no success. Thanks. Ok thanks @rbrtmrtn, I'll run with that and see how I go\n. @vcarl any plans to publish a component to make the map centre available as a render prop (wishful thinking!)? I'm having a hard time implementing leaflet getCentre() into my react-leaflet map. ",
    "tzi": "For those who struggles to have a complete code example:\n```jsx\nimport React from 'react';\nimport { Map } from 'react-leaflet';\nclass MyComponent extends React.Component {\n  onMove(event) {\n    console.log(event.target.getCenter());\n  }\nrender() {\n    return (\n      \n        {/ ... /}\n      \n    );\n  }\n}\nexport default MyComponent;\n```. ",
    "chriswiggins": "Sorry to dig this up - I'm having issues with understanding how to use the layers control? It seems to \"work\" when I pass actual leaflet objects in as you would normally to L.control.layers, but how do you set a default?\nMuch appreciated - happy to submit a PR with updated Readme instructions and even an example once I get it working :-)\n. Hi,\nWhat do you mean by default? The default options are Leaflet's ones, this library simply passes the props to the relevant Leaflet constructor.\nOK right I see. I was wondering if it was possible to pass in a  through to LayersControl but it looks like as you say it's just a shim around the leaflet options. In the leaflet options for the L.control.layers you need to pass an object where the key is the title shown on the control and the value is a L.TileLayer class. I was hoping instead I could pass a  from here :-)\nThanks for the help\n. @jonboiser I was thinking of something like this:\n<LayersControl ...layersOpts>\n    <TileLayer type='base' title='Street View' selected='true' ...otherOpts/>\n    <TileLayer type='base' title='Satellite View' ...otherOpts />\n    <ImageOverlay type='Overlay' title='Overlay' ...otherOpts />\n</LayersControl>\nCome to think of it, that could actually be fairly straightforward if the LayersControl element \"rendered\" its children and then added to the layers control. I'll have a play today and get back to you all on whether or not this works!\n. So I've given this a go and no immediate luck - mainly because the TileLayers are expecting a map prop to be passed to them however in this implementation thats not what we want to do. I might have to end up modifying lots of components to get this to work. \nAny other ideas around how we could do this?\n. I'm also seeing this exact same issue. I have two base layers and an overlay if thats at all helpful.\nAs per @dkrichards86 's stack trace above, L.Control.Layers tries to call addItem when it is removed, therefore causing issues. I can see why this is useful if dynamically removing/adding layers for the control, however a complete unmount doesn't work with this logic.\nAppreciate any help with this\n. You're amazing Paul. Will give this a go tomorrow.\nCheers\nChris\nOn 8/07/2016, at 8:55 PM, Paul Le Cam notifications@github.com<mailto:notifications@github.com> wrote:\nHi,\nThanks for reporting this, indeed it seems L.Control.Layers tries to add layers to the map when it gets updated after being removed, but the map itself is removed as well so it breaks.\nI pushed a fix in v0.12.1 that should address the issue, please let me know if it works in your case.\n\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHubhttps://github.com/PaulLeCam/react-leaflet/issues/187#issuecomment-231309233, or mute the threadhttps://github.com/notifications/unsubscribe/ACsxEVIUsqT-CRpCXzrx11QljUjjAna9ks5qThBogaJpZM4JGIVk.\n. ",
    "TobyEalden": "Hi - I'm having a similar issue - I have a <GeoJson> overlay as a child of <Map> - how do I configure the <LayersControl> overlays property to reference the <GeoJson> element? Do I need to write some code in componentDidMount to discover the Leaflet element corresponding to the GeoJson layer and manually set the overlays property?\n. ",
    "mojodna": "For straight-up attribution changes, passing options as props works great. However, for the attribution prefix, it's not enough to set options.attributionControl.prefix: \"\" (which would need to be passed as <Map ... {...{\"attributionControl.prefix\": \"\"}} />, if I'm understanding things right). (attributionControl is a boolean and is a bit too much of a hammer.)\n. @MattSidor no, i end up embedding Leaflet directly in my own components instead since I'm not doing anything complicated (or if I am, it's a weird fit with this plugin).. ",
    "derwaldgeist": "How exactly does this work? The context on the top level element is empty, so how could I access the map instance on Map level?. Yep, I did :-). Ok, thanks for the fast response!. ",
    "MattSidor": "I'm struggling with this. My <TileLayer> element has an attribution value, but I want to hide the default \"Leaflet\" prefix. I can create an <AttributionControl> element with prefix={false}, but that just creates a duplicate attribution.\nExample:\nrender() {\n  const position = [this.state.lat, this.state.lng];\n  return (\n    <ReactLeafletMap\n      center={position}\n      zoom={this.state.zoom}\n      zoomControl={false}\n    >\n      <TileLayer\n        attribution=\"[attribution text]\"\n        url=\"[tile url]\"\n      />\n      <AttributionControl position=\"bottomright\" prefix={false} />\n    </ReactLeafletMap>\n  );\n}\n\nScreenshot (two attributions, one without the \"Leaflet\" prefix):\n\n@mojodna, I am curious, were you able to find a good solution for removing the prefix via these React components?. I figured it out!\nDeclare attributionControl={false} in the parent <ReactLeafletMap> component to disable to default attribution, then create a new <AttributionControl> component with prefix={false}, like so:\nrender() {\n  const position = [this.state.lat, this.state.lng];\n  return (\n    <ReactLeafletMap\n      center={position}\n      zoom={this.state.zoom}\n      zoomControl={false}\n      attributionControl={false}\n    >\n      <TileLayer\n        attribution=\"[attribution text]\"\n        url=\"[tile url]\"\n      />\n      <AttributionControl position=\"bottomright\" prefix={false} />\n    </ReactLeafletMap>\n  );\n}\n\nThe actual attribution text, minus the prefix, is still declared in the attribution property of the <TileLayer> component.. ",
    "StephanGeorg": "Should be \n<AttributionControl position=\"bottomright\" prefix=\"\"} />\notherwise\n\nFailed prop type: Invalid prop prefix of type boolean supplied to AttributionControl, expected string.\n. \n",
    "surkova": "I don't know if it's the right approach in React world, but I did the following and it worked:\n``` javascript\nimport React, {Component} from 'react';\nimport {Marker, Popup} from 'react-leaflet';\nclass MyMarker extends Marker {\ncomponentWillMount() {\n    super.componentWillMount();\n  }\nrender () {\n    return (\n        \n\nA pretty CSS3 popup.Easily customizable.\n\n\n    )\n  }\n}\nexport default MyMarker;\n```\nYou were simply missing map, that's passed via const { map, position, ...props } = this.props; in Marker.js\n. Then yet another suggestion:\n``` javascript\nimport React, {Component} from 'react';\nimport {marker} from 'leaflet';\nimport {MapLayer} from 'react-leaflet';\nclass MyMarker extends MapLayer {\n  componentWillMount() {\n    super.componentWillMount();\n    const { map, position, popupText, ...props } = this.props;\n    this.leafletElement = marker(position, props).bindPopup(popupText);\n  }\n  render() {\n    return this.renderChildrenWithProps({\n      layerGroup: this.leafletElement,\n    });\n  }\n}\nexport default MyMarker;\n```\n``` javascript\nconst builtMarker = (function() {\n  const position = [51.520, -0.11];\n  const popupText = \"A pretty CSS3 popup.Easily customizable.\"\n  return (\n    \n  );\n})();\n```\n. ",
    "varya": "@surkova, this does not help. But I updated the repo with componentWillMount anyway, just to demonstrate that this does not work.\n. Thank you very much, but the point is to use Marker react component. Of course it's possible to create markers on the low level, but then the usage of react-leaflet doesn't make any sense.\n. @PaulLeCam, thank you for the answer. This example works. But I'm also wondering how to insert a variable or a set of Markers. This would be nice to have an example in examples with a custom component which outputs a list of markers. I think many will be clear from such an example.\n. Thank you very much! Now it's clear.\nI made a pull request with this code into your set of examples. This is the place where I was looking for an answer before asked here. Maybe someone else will also look there :-)\nhttps://github.com/PaulLeCam/react-leaflet/pull/104\n. ",
    "felixsonyusuftosin": "I have set up map like this\n```\nrender(){\n     return(\n    \n\n\n\n            :\n            null\n        }\n  </Map>\n ) }\n\n```\nWhat i require is to have access to my GeoJSON Layer via\n```\ncomponentDidMount(){\nlet th = this;\nthis.map = this.refs.map.leafletElement;\nthis.geojson = this.refs.geojd.leafletElement \n        console.log(this.geojson);           \n }\n\n```. Please where in the documentation is it said to use context because i cant seem to find it\n. ",
    "topgun743": "I have a question in this regard.\nI have 20 different sets of markers, with each set comprising of minimum 50 markers (in production may be much more than that).\nIn my current application when I iterate over these sets of markers for rendering, it freezes my UI causing frustration to the end user.\nHow can I render these sets on leaflet map asynchronously. What is the best approach?\nAnd also, can the leaflet map L.map instance be approached by multiple simultaneously executing blocks of code?. ",
    "bartekupartek": "I found solution, instead of invoking onLeafletLoad i can get map bounds after componentDidMount:\ncomponentDidMount() {\n  this.mapApi = this.refs.map.leafletElement; // <= this is the Leaflet Map object\n  let bounds = this.mapApi.getBounds();\n},\n. ",
    "colllin": "Do you think it could be an issue specific to ES6?\nI tried ref='thing' and this.refs.thing is undefined. I also tried ref={(ref) => this.thing = ref} as in the example above, and that ref handler never gets called, so, as you would expect, this.thing is undefined.\n. @PaulLeCam Thank you for the detailed and patient response.\nI see now that the ref handler is being called, but after componentDidMount has already been called.\nEither way, I think I was caught in an old (non-react) way of thinking about leaflet, and the approach you suggested sounds better.  I'm going to extend the GeoJson component to create a custom GeoJsonAnimated component.\n. @Smallmelo Looking back at my code, all I can see is that I performed my componentDidMount logic also in componentWillReceiveProps:\ncomponentDidMount\n    this.updateGeomLayer(this.props);\n}\ncomponentWillReceiveProps(nextProps) {\n    this.updateGeomLayer(nextProps);\n}\nupdateGeomLayer(props) {\n    // ...\n}\n. ",
    "christianhaller": "Can you provide a demo or some hints for an animated marker?\n. ",
    "TPABHuKOB": "I solved this problem in this way\n<FeatureGroup onAdd={(e)=> {this.zones=e.target}}>. ",
    "angusmack": "Your container div needs and absolute height and width and you need to make sure you include leaflet CSS file. Can you confirm you are doing these steps?\nI use this lib in my React app and had the  same issue as you before I did this.\n. ",
    "dmcd": "Thanks Angus,\nMy styling wasn't being applied. I've managed to make it work by applying the styling inside index.html like below but I'm not sure why my styling to the react component wasn't being applied (I'm fairly new to this stuff).\nhtml\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <title>React Redux Starter Kit</title>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/leaflet.css\">\n  <style>\n    h1, h2, p {\n      text-align: center;\n    }\n    .leaflet-container {\n      height: 400px;\n      width: 80%;\n      margin: 0 auto;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"root\"></div>\n</body>\n</html>\n. ",
    "jordangarside": "Sorry for posting on this, but didn't want to open a new topic.\nI'm also having this weird rendering issue (I've a bunch of different things: different tiles, setting height, removing everything but the map).\n\nDemo is viewable here.\nCode is viewable here.\nI've seen the size rendering issue before, but this doesn't seem to be it because I've tried invalidating size as well as setting size directly on #map1.\nIt was working before too which is the weirdest thing, also the points on the map are in the correct places.\nIt broke after I added the playing video and won't work anymore even after removing it and it's npm package.\n. Turns out my issue was due to having styling on generic img tags.\n. ",
    "warrenronsiek": "To whom it may concern: adding the .leaflet-container css is super important. Spent several hours trying to make it work without that - I failed. \n. ",
    "ekatzenstein": "Can we add this to the \"Getting Started\" Documentation? I almost gave up on Leaflet until I found this thread.. ",
    "zeroasterisk": "can we pass through a style={{ height: 200 }} to the <Map> component? . ",
    "duhaime": "To those having trouble getting the styles to display correctly, try adding:\n<link href='https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.css' rel='stylesheet'>\nto your index.html file.\nIf you're using webpack and have a file-loader present, you can instead load the css into a component with import 'leaflet/dist/leaflet.css'\n  . ",
    "iofirag": "@duhaime \nyou save my day! with:\nimport 'leaflet/dist/leaflet.css'. ",
    "deepeeess": "@angusmack - thank you very much.  this was exactly what I needed. ",
    "zhen1991": "Hi\nI am having the same problem and can not be fixed while adding style to it??\ndoes any one know another way of how i can fix that ??. HI!\nsorry i dont have any idea how to fix it in React but i hade fix my issue i use polymer 2 by adding  style tag inside dem model :)\n. ",
    "mrinmoydas3011": "I am using GoogleMutant to load Google Map using React-Leaflet. I have set the height and width and have even added the required styles, however, the map only gets rendered when I resize the browser window. Please help!. ",
    "Jcummings81": "Thank you for pointing to the CSS file!  Was going crazy trying to figure out why the tiles were hectic.\nNow have a working react Map component.  Heres the code for anyone struggling.\nimport React from \"react\";\nimport L from \"leaflet\";\nimport Leaflet from 'leaflet/dist/leaflet.css'\nconst style = {\n  width: \"100%\",\n  height: \"300px\"\n};\nclass Map extends React.Component {\n  componentDidMount() {\n    // create map\n    this.map = L.map(\"map\", {\n      center: [40.7610, -111.8829],\n      zoom: 13,\n      layers: [\n        L.tileLayer(\"http://{s}.tile.osm.org/{z}/{x}/{y}.png\", {\n          attribution:\n            '\u00a9 OpenStreetMap contributors'\n        })\n      ]\n    });\n}\nrender() {\n    return ;\n  }\n}\nexport default Map;\n. I'm new to react, bootcamper, trying to use leaflet react for a group project.\nI'm having trouble understanding how to use the leaflet-react components in the context of modern react style.  I believe it has something to do with the automatic provider consumer creation when using leaflet Map.  I have a map using old, non react, style as follows.\nimport React from \"react\";\nimport L from \"leaflet\";\nimport Leaflet from 'leaflet/dist/leaflet.css'\nconst style = {\n  width: \"100%\",\n  height: \"300px\"\n};\nclass Map extends React.Component {\n  componentDidMount() {\n    // create map\n    this.map = L.map(\"map\", {\n      center: [40.7610, -111.8829],\n      zoom: 13,\n      layers: [\n        L.tileLayer(\"http://{s}.tile.osm.org/{z}/{x}/{y}.png\", {\n          attribution:\n            '\u00a9 OpenStreetMap contributors'\n        })\n      ]\n    });\n}\nrender() {\n    return ;\n  }\n}\nexport default Map;\nI would like to refactor to more component style react like this:\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { Map, Marker, Popup, TileLayer } from 'react-leaflet'\nconst position = [51.505, -0.09]\nconst map = (\n  \n\nA pretty CSS3 popup.Easily customizable.\n\n\n)\nrender(map, document.getElementById('map-container'))\nAny suggestions would be much appreciated.. Good morning James,\nSorry about that, new to the customs of stack overflow as well ha ha.\nhere is a link to a simple html example of using a map with the Leaflet\nmaps extension? called World. <\nhttps://jsfiddle.net/cn0rw873/1/#&togetherjs=OdLPzEIlAu >  I'm trying to\nfigure out how to implement this in a react component that only has a main\npublic index html file that I really don't want to alter.  I'd like the JSX\ntranslation of this.  I can use Leaflet alone, but adding in World on top\nof it seems to complicate it. For instance I can create a map with the\nleaflet library alone with L.map  but when I try to use L.Wrld.map react\ngets confused and thinks I'm trying to map over an array.\nThank you for your response.\nOn Mon, Oct 1, 2018 at 7:17 PM James Collins notifications@github.com\nwrote:\n\n@Jcummings81 https://github.com/Jcummings81 That's not really what this\nissue is about... But if you post a fiddle of your current map\nimplementation using vanilla JS I can take a look\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/issues/506#issuecomment-426114713,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AnkE3qf1CsF7srwYtDlTBbU-QrEtwc6Kks5ugr6PgaJpZM4V_HYF\n.\n. Alright great, I'll look into that. Thank you again for your help.\n\nOn Tue, Oct 2, 2018, 7:39 AM James Collins notifications@github.com wrote:\n\nOk yeah https://jsfiddle.net/q2v7t59h/1942/\nYou're gonna need to extend react-leaflet's Map component and override\nthe createLeafletElement function. I'm not familiar with Wrld but it's\npossible that you might also need to override the updateLeafletElement\nfunction although I think that's unlikely.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/issues/506#issuecomment-426277144,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AnkE3nF-96yTDDcZb3hlsNensH8Xc26bks5ug2yTgaJpZM4V_HYF\n.\n. \n",
    "semanser": "Also, don't forget to set up style props with the height and width of your Map component:\nFull working example:\n```js\nimport { Map, TileLayer } from 'react-leaflet'\nimport 'leaflet/dist/leaflet.css'\n    <Map\n      style={{ width: '100%', height: '600px' }}\n    >\n      <TileLayer\n        attribution='&amp;copy <a href=&quot;http://osm.org/copyright&quot;>OpenStreetMap</a> contributors'\n        url='https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'\n      />\n    </Map>\n\n```. ",
    "bwd72": "Yes!  This is key, adding a style element for width and height directly on the  component.  The docs say to add this to the containing div which did not fix the problem (same problem as other posters in this thread).  I did mine inline (same as @semanser above) and it worked great.  \nSo:\n1.  Make sure you import the style sheet:  import \"leaflet/dist/leaflet.css\";\n2.  Add width and height on at least the  component.  I did  and set the actual height on the container.  This was enough.\nHope that helps!\n-BWD.. ",
    "stephanedaviet": "For those interesting in setting up react-leaflet with Google maps, you can write your custom component inspired by the one described below, based on leaflet-plugin by @shramov and google-maps by @Carrooi:\n``` javascript\nimport 'leaflet-plugins/layer/tile/Google';\nimport L from 'leaflet';\nimport MapLayer from 'react-leaflet/lib/MapLayer';\nimport GoogleMapsLoader from 'google-maps';\n// Inspired by TileLayer\n// TODO: See how it works if there is multiple instances of this component in the app\n// TODO: See how it works if Google maps API is loaded elsewhere\n// (this should be handled by google-maps library)\nexport default class GoogleLayer extends MapLayer {\ncomponentWillMount() {\n    super.componentWillMount();\n// Flag to know if the component should be rendered\nthis.state = {\n  googleLoaded: false\n};\n\n// This is a blank layer because MapLayer doesn't support having this undefined\nthis.leafletElement = L.tileLayer('');\n\n// Google settings\nGoogleMapsLoader.LANGUAGE = 'fr';\nGoogleMapsLoader.LANGUAGE = 'FR';\nGoogleMapsLoader.KEY = '<your-google-api-key>';\n\n// Async loading of Google maps API to avoid direct script tag in HTML and\n// be more compliant to React component approach\nGoogleMapsLoader.load(() => {\n  // Remove the previously added blank layer, add your Google layer(s) and flag loaded\n  const GoogleLayer = new L.Google('ROADMAP');\n  this.props.layerContainer.removeLayer(this.leafletElement);\n  this.leafletElement = GoogleLayer;\n  this.props.layerContainer.addLayer(this.leafletElement);\n  this.setState({\n    googleLoaded: true\n  });\n});\n\n}\ncomponentWillUnmount() {\n    super.componentWillMount();\n// Unload on umount, perhaps not necessary but seems a good practice\nGoogleMapsLoader.release(() => {\n  this.setState = {\n    googleLoaded: false\n  };\n});\n\n}\nshouldComponentUpdate() {\n    return super.shouldComponentUpdate()\n        && this.state.googleLoaded;\n  }\nrender() {\n    return null;\n  }\n}\n```\n. ",
    "alex3165": "Hi Paul,\nOk I understand sorry i didn't see the comment before, i will create a\nseparate project then :) . I have another suggestion, could we add\n\"react-pure-render\" to the different layers so that every time we update\nthe main component we don't necessarily update all the react-layers ?\nThanks,\nAlex.\n2015-12-21 10:06 GMT+00:00 Paul Le Cam notifications@github.com:\n\nHi,\nThanks for your PR but this project intends to be a simple interface for\nLeaflet, not implement its plugins, please read this comment\nhttps://github.com/PaulLeCam/react-leaflet/pull/78#issuecomment-144663021\nfor a more detailed explanation.\nAs stated in this previous comment, if you want to add this plugin as a\nseparate project, I'd be glad to reference to it from the documentation\nhere.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/pull/110#issuecomment-166258099\n.\n. \n",
    "mdramos": "simple mistake: If you are not familiar with Leaflet, make sure you read its quick start guide first. You will need to add its CSS to your page to render the components properly.\n. Embarrassing enough, all I had to do was investigate the map component code, notice that it took an id prop, and set that id prop to \"map1\". Switching between renders is now solved.\n. ",
    "stroborobo": "Just for the record, using it and works well. There's just no typing information, so you'll have to use require instead of import:\ntypescript\ndeclare var require: any\nconst { Map, TileLayer } = require('../../node_modules/react-leaflet')\n. ",
    "danzel": "FYI, I've created typescript definitions and submitted them to DefinitelyTyped:\nhttps://github.com/DefinitelyTyped/DefinitelyTyped/pull/13922. ",
    "thynan": "Hi,\nthanks a lot, you just made my day! :) That was exactly what I needed. \n. ",
    "SunyoungKim508": "@thynan did it work? It says that bindLabel doesn't exist.\n. ",
    "Krysler": "Ok, i found solution. As i'm new to React i didn't know how to get leaflet element from react component.\nMy solution was to use 'ref' propery on Map component:\n`componentWillReceiveProps(prevProps){\n    this.refs.map.leafletElement.setZoom(2);\n  }\n`\nThanks\nMike\n. ",
    "camrongodbout": "+1\n. ",
    "pke": "I am familiar with the stack. The sample code is just not displaying a map.\n. Yes same here!\n. Does it really hurt to add a reminder in the readme of this project also, to set the mapContainer height? How many issues you think can you prevent in the future? And contrary to your section of the doc its not enough to add their CSS to the page. The most important part is to set the map container's element height explicitly.\n. Still can't get it to work. My code is the same as in the example. But no tiles for the tile layer are loaded. Using browserify instead of webpack though. Not sure if it does anything different.\n. Thanks Paul for ur efforts. I got it working with plain leaflet now. Trying ur components again.\n. So after some trying, that are my results. Plain leaflet works with that code\n``` es6\nexport default class MapContainer extends React.Component {\n  componentDidMount() {\n    this.map = L.map(this.refs.map).setView(position, 13)\n    L.tileLayer(\"http://{s}.tile.osm.org/{z}/{x}/{y}.png\", {\n      attribution: \"\u00a9 OpenStreetMap contributors\"\n    }).addTo(this.map)\n  }\nrender() {\n    return \n  }\n}\n```\nNo external stylesheet to style \".leaflet-container\" is used. The map is displayed as it should.\nNow with your components instead nothing is displayed except for the zoom controls.\nes6\nexport default class MapContainer extends React.Component {\n  render() {\n    <Map zoom={13} position={position} style={{height:\"100%\",width:\"100%\",position:\"relative\"}}>\n      <TileLayer\n          attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n          url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n      />\n    </Map>\n  }\n}\n. More importantly the information that the map container also needs to have a height set.\n. Hmm installing react-leaflet brings 0.7.0 into the bundle. And has this bug from 0.7.0. How can I force npm to install the newest leaflet bundle with react-leaflet?\n. hmmm. Of course I did that. I have 0.7.7 in my package. react-leaflet uses 0.7.0 thats bundled with it. Using npm 2, mind you. Do I need to de-dup or something to fix that?\n. Something is wrong with my node_modules. Sorry for bothering. Will check.\nEdit: Updated my npm and it looks like almost like your outpu:\n``` bash\n$ npm i -S react-leaflet\nnpm WARN peerDependencies The peer dependency leaflet@^0.7.0 included from react-leaflet will no\nnpm WARN peerDependencies longer be automatically installed to fulfill the peerDependency\nnpm WARN peerDependencies in npm 3+. Your application will need to depend on it explicitly.\nleaflet@0.7.7 node_modules\\leaflet\nreact-leaflet@0.10.1 node_modules\\react-leaflet\n\u2514\u2500\u2500 lodash@4.6.1\n```\n. ",
    "benzen": "I also experience some difficulties with the example for the readme.\nMaybe it's due to my setup, but it's hard to tell.\nHere is an example:\n\nThe map render partially, but there is always a section of the map that doesn't render correctly, like here:\n\nIn theses example i have the devtools open. If I resize the window, the map goes white, and i will never see any change again. The tiles are downloaded, but never rendered.\nI have no error message.\n@pke  Is this the same behavior ?\n@PaulLeCam Any clue on what can go wrong here?\n. I've tried to use the pure leaf-let example, It produce the same result.\nSo i think we are missing some piece here.\nHere is a drupal guy which seems to experience the same problem as we do.\nhttps://www.drupal.org/node/2472299\n. As mentioned by @PaulLeCam we should have read more carrefully the quickstart guide of leaftlet.\nhttp://leafletjs.com/examples/quick-start.html\nIf you define a heigh on the map container, and you also need to import the css provided with leaflet.\n@PaulLeCam I understand that you don't want to repeat everything that is sayed on the leaflet website, but be reader are so much lazy (I didn't noticed that there is a mention about the css).\nI propose to move thoses consideration into the install section of the readme. \n. Here is a PR for this:\nhttps://github.com/PaulLeCam/react-leaflet/pull/124\nI've spoken about the container height, not sure if it's required.\n. After other trials, It seams that the map inside the components get rendered inside a container iwht the class .leaflet-container. That class require a height in order to show something.\nI think that we should make it more abvious to the new comer that he/she need to set a height on a leaflet-container class\n. I totally agree on this with you, and thanks to your efforts, I was able to\nuse this lib to quickly implements everything that I need for my app.\nThe point that i want to make is that making thoses two information more\nevident will help people get started.\nThe way i generally work, is that I try to get something running with just\na quick overview of the read me.\nIn general if it doesn't I will leave and try the next one. which is sad\nsince your lib works pretty well.\nI understand that you don't want to replace the leaftlet docs, it's to big\nfor any of us. But I think the starting point are really important.\nSince this lib require leaflet, we almost need no setup once in a react app.\nIf you really prefer you opinion, I won't go against, nor fork you project.\nI just will have to keep it in mind for other project that will need your\nlib.\nYou made a Great job.\n2016-03-10 6:56 GMT-05:00 Paul Le Cam notifications@github.com:\n\nAgain, this library provides bindings to Leaflet, it is not a\nreplacement for it. This documentation is not intended to replace\nLeaflet's one, it is meant to describe how to use this library after\nyou have setup Leaflet (and React, and Babel, and an HTML page for that\nmatter).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/issues/123#issuecomment-194811614\n.\n\n\nBenjamin DREUX\n. Not saying that this is the problem, but here is an example of similar issue:\nhttps://github.com/reactjs/react-router/issues/2265\n. By bad i was calling the my component inside of it self\n. Here is what i've tryed (here the props map and layerContainer are exclude for clarrity sake):\n(showPopup, onToggle) =>\n    <Marker onClick={onToggle}> {showPopup ? \n        <Popup>\n          <div>\n            <div onClick={onToggle}>close</div>\n              My popup\n          </div>\n        </Popup> \n    : null} </Marker>\nWhen adding the popup all is good. When I try to remove the popup (by clicking on the close text), i've got he following error:\nUncaught TypeError: listeners[i].action.call is not a function   leaflet-src.js:461\nExpected results\nNo error message and the popup disapears\nActual results\nThe console show's\nUncaught TypeError: listeners[i].action.call is not a function   leaflet-src.js:461\nHere is the top lines of stacktrace\nL.Mixin.Events.fireEvent    @   leaflet-src.js:461\nL.Popup.L.Class.extend.onRemove @   leaflet-src.js:3895\nL.Map.L.Class.extend.removeLayer    @   leaflet-src.js:1695\ncomponentWillUnmount    @   Popup.js:99\nStill the popup is removed.\n. @paullecam thanks for you detailed answer, very apperciated.\nAt the end of the day, this issue has the same roots than wanting to\ncontrol the view port from react.\nLeaftlet isn't ment for that, so as you propose, i'll let leaflet handle\nit's stuff, an just keep track of it current state (via events) for the\nrest of my app.\nKeep on with the good work.\nRegards\n2016-06-09 14:53 GMT-04:00 Joel notifications@github.com:\n\nI am unfamiliar with how I can unbind leaflet from controlling the state.\nCan you point me towards some docs?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/issues/169#issuecomment-224991551,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAIihar-1hPfcN-O_4aty2TUPsul-hzdks5qKGErgaJpZM4Iroi3\n.\n\n\nBenjamin DREUX\n. Really nice thanks\n. ",
    "sulihuang": "@benzen  @pke  I have the same problem;\nand  I use this \nimport 'leaflet/dist/leaflet.css'\n. ",
    "idurant": "My issue with rendering was the fact that I was using a parent div. Once removed it worked. Truly the fix was making sure to include the css for .leaf-container when using react-leaflet. The demo used #mapid\nexample from @PaulLeCam jsFiddle:\n.leaflet-container {\n    height: 400px;\n    width: 100%;\n}\ncheers!. worked for me! \nnpm install react-leaftlet --save then\nnpm i leaflet. ",
    "mariusandra": "Thank you for merging! Could you also release a new (patch?) version with this change?\n. ",
    "bigsassy": "I also ran into a similar problem.  Try and inline the height of the map real quick and see if it helps:\n<Map style={{height: \"600px\"}}> // plus whatever other props\n    // stuff\n</Map>\n. Hey Lucas,\nYou want to do something like this:\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport L from 'leaflet';\nimport { MapControl } from 'react-leaflet';\nexport default class CenterControl extends MapControl {  // note we're extending MapControl from react-leaflet, not Component from react\ncomponentWillMount() {\n    const centerControl = L.control({position: 'bottomright'});  // see http://leafletjs.com/reference.html#control-positions for other positions\n    const jsx = (\n      // PUT YOUR JSX FOR THE COMPONENT HERE:\n      \n        // add your JSX \n      \n    );\ncenterControl.onAdd = function (map) {\n  let div = L.DomUtil.create('div', '');\n  ReactDOM.render(jsx, div);\n  return div;\n};\n\nthis.leafletElement = centerControl;\n\n}\n}\n```\nThen use it like this:\n<Map center={center} zoom={13}>\n    <CenterControl/>\n</Map>\nThat'll cause your component to be attached to the map and managed by leaflet.  So leaflet will handle positioning correctly in the right corner, even if there's already other controls in the right corner.\nYou can read more about controls here: http://leafletjs.com/reference.html#control.\n. Oh, sorry!  It should be centerControl.onAdd = function (map) {.  I updated the code above.\nThe legend is from my code, which I copied and modified for the example.  I had forgotten to change it to centerControl in the code above..  If you're curious, here's that custom control from my current project:\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport L from 'leaflet';\nimport { MapControl } from 'react-leaflet';\nexport default class LegendControl extends MapControl {\ncomponentWillMount() {\n    const legend = L.control({position: 'bottomright'});\n    const jsx = (\n      \n        {this.props.children}\n      \n    );\nlegend.onAdd = function (map) {\n  let div = L.DomUtil.create('div', '');\n  ReactDOM.render(jsx, div);\n  return div;\n};\n\nthis.leafletElement = legend;\n\n}\n}\n```\nAnd I used it something like this:\n<Map className=\"map\" center={center} zoom={13} style={{height: \"300px\"}}>\n  <TileLayer\n    url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n    attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n  />\n  <GeoJson data={this.props.data} pointToLayer={this.pointToLayer}/>\n  <LegendControl className=\"supportLegend\">\n    <ul className=\"legend\">\n      <li className=\"legendItem1\">Strong Support</li>\n      <li className=\"legendItem2\">Weak Support</li>\n      <li className=\"legendItem3\">Weak Oppose</li>\n      <li className=\"legendItem4\">Strong Oppose</li>\n    </ul>\n  </LegendControl>\n</Map>\n. If you inline the height, does it work properly then?\n<Map style={{height: \"600px\"}}> // plus whatever other props\n    // stuff\n</Map>\n. Ok, I created it.  I just added it to an existing question about react-leaflet.\nhttp://stackoverflow.com/questions/34643791/react-leaflet-bounds\nEDIT - I added it to a bunch of other old questions too.\n. If anyone is interested in getting notified on new questions on Stack Overflow, you can subscribe to the react-leaflet tag.\nJust go here:\nhttps://stackoverflow.com/questions/tagged/react-leaflet\nThen mouse over the react-leaflet tag on the right side and click subscribe.\n\n. ",
    "HeyHugo": "Hi, just a tip for anyone who like me don't want to set a fixed height for the map. \ncomponentDidMount() {\n    this.mapApi = this.refs.map.leafletElement;\n    setTimeout(() => {\n      this.mapApi.invalidateSize();\n    }, 100);\n}. ",
    "canda": "I have the same issue, I can't have the height fixed, and I don't want to use the setTimeout, it's kind of hackish. Any suggestions?. ",
    "estaub": "@canda In a similar situation, I've used react-measure to get the dimensions I have to work with , and set the \"fixed\" dimensions from that.  I haven't tried it with react-leaflet, though.. ",
    "LucasAlumni": "Thanks bigsassy ! \nJust a little question, what's the legend for you ? : legend.onAdd = function (map).\nBest regards,\n. Thank you very much bigsassy !\n. ",
    "alexanderfrey": "Hello ! @bigsassy Thanks for the excellent example. Everything works so far except that I don't seem to be able to refresh my custom control when changing its properties. My custom control displays different information according to the selected marker on the map. \nProblem is that the content in the custom control does not update when selecting a marker. This mus t be because of the fact the react render function is not implemented / is able to rerender the component on prop change.\nDid anyone come across this problem before ?\nThanks for help \n. @jgimbel Thanks so much ! I will go and check it out. \n. Looks good. I will go and use that one for my custom control. Do you have a suggestion to block panning the map when the mouse is over your react-leaflet-control container ? This is the reason why I was trying to create a custom leaflet control in the first place...\n. ",
    "alex1kirch": "You can use the component https://github.com/alex1kirch/react-leaflet-portal. The component allows to use the leaflet control panel like a normal React child. Features like context are availble because the component child still exists in the React tree.\nDemo: https://react-leaflet-portal.herokuapp.com/#portal. ",
    "yuliakal": "Does anyone have solution for latest version of react-leaflet?. ",
    "clementallen": "@yuliakal Use this plugin: https://github.com/liveby/react-leaflet-control. @rdgomt interesting I've noticed the same using react-scripts@2.1.4 and react-scripts@2.1.5.  I had to downgrade to 2.1.3 and the issue resolved.  If you downgrade to 2.1.3 does it fix it for you too?  Quite frustrating but not really sure where to start with fixing it.... @PaulLeCam I came here to report this same issue.  I can see that tree-shaking is working and that only essential parts of lodash are included in the bundle but because it's lodash it still is a fair size.  Is it possible to look at finding more light-weight alternatives to these functions?  I'm happy to take a look at it if it's something you'd be willing to accept an MR on.. @robinmetral I noticed the react-leaflet-control library didn't link to a github repo too a few months ago, and this has just prompted me to raise a PR to fix it in the repo FYI:\nhttps://github.com/LiveBy/react-leaflet-control/pull/31. ",
    "boromisp": "\nI'm not really happy with this yet, I'd much rather have a more declarative approach. Something like:\n```\nclass MyMap extends Component {\n    state = {\n        selectedLayers: new Set(['tile-layer'])\n    };\nhandleLayersSelected = selectedLayers => this.setState({selectedLayers});\n\nrender() {\n    const { selectedLayers } = this.state;\n    const { handleLayersSelected } = this;\n    return (\n         <Map>\n            <LayersControl\n                baseLayers={{\n                    'tile-layer': 'Tile layer label',\n                    'some-other-layer': 'Other layer label'\n                }}\n                overlays={{\n                    'optional-marker-layer': 'Markers...'\n                }}\n                selected={selectedLayers}\n                onChange={handleLayersSelected}\n            />{selectedLayers.has('tile-layer') ?\n            <TileLayer url={https://...} /> : null}{selectedLayers.has('some-other-layer') ?\n            <OtherBaseLayer ... /> : null}{selectedLayers.has('optional-marker-layer') ?\n            <LayerGroup>\n                {/* markers... */}\n            </LayerGroup> : null}\n        </Map>\n    );\n}\n\n}\n```\nThis would require a custom LayersControl widget.\n\nI put together a sample implementation, which includes:\n- a React-controlled L.Control,\n- a react-leaflet wrapper for that,\n- and the LayersControl re-implemented fully in react.\nhttps://gist.github.com/boromisp/bdc8faf182d43bb95d784312a7eff0fc (Since I'm currently on Windows, these code snippets haven't been built or tested.)\nBut this works around leaflet rather then working with, so this might not be a good fit for this project.\n. Hi, I updated the PR.\nThe ControlledLayer is the glue, that presents the LayersController as a kind of layerContainer to the MapLayer-s, and sends title, type and defaultAdded props to the LayersController for each MapLayer.\nI haven't looked into it yet, but the leaflet 1.0 might bring some new concepts relevant to this, like custom map panes for layer ordering.\nhttps://github.com/Leaflet/Leaflet/issues/1742\nhttp://leafletjs.com/examples/map-panes.html\n. I like the API, but I'm not sure about the implementation.\nInstead of using ref, the ControlledLayer subclasses could implement addLayer and removeLayer which would call the addBaseLayer, addOverlay and removeLayer from props.\nThen the ControlledLayer sets \"this\" as the layerContainer for its child MapLayer, and everything works as expected.\nAlso I believe a \"default added\" prop for the ControlledLayers could be useful, for having some layers turned off by default.\n. The \"default added\" has no separate API, because with Leaflet you can create a layer, and not add it to the map, only the layers control.\nI put together a \"proof of concept\" for my proposal: #136. It has the same API, I only replaced the ref, and added \"defaultAdded\" prop.\n. ",
    "silvenon": "@awe2m2n2s it's pretty weird that you're trying to use a React plugin in Rails. Why not Leaflet directly?\n. ",
    "awe2m2n2s": "Thanks @PaulLeCam! you are just great. Here is how it finally worked within rails:\n1. use \"compiled\" ReactLeaflet from /dist within /vendor/assets/javascript/react-leaflet.js (additionalliy versioning would be smart)\n2. require react-leaflet within application.js\n3. define e.g. Map/TileLayer/Marker/Popup with var Map = ReactLeaflet.Map;\n4. enjoy leaflet with react thanks to @PaulLeCam!!\nreact-rails community find more information via https://github.com/reactjs/react-rails/issues/413\nhere is the code:\nnewmap.js.jsx\nvar NewMap = React.createClass({\n    getInitialState: function() {\n      return {\n          lat: 51.505,\n          lng: -0.09\n      };\n    },\n    render: function() {\n        var Map = ReactLeaflet.Map;\n        var TileLayer = ReactLeaflet.TileLayer;\n        var Marker = ReactLeaflet.Marker;\n        var Popup = ReactLeaflet.Popup;\n        var Position = [this.state.lat, this.state.lng];\n        return (\n            <Map center={Position} zoom={13}>\n              <TileLayer\n                url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n                attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n              />\n              <Marker position={Position}>\n                <Popup>\n                  <span>A pretty CSS3 popup.<br/>Easily customizable.</span>\n                </Popup>\n              </Marker>\n            </Map>\n        );\n    }\n});\nand\nindex.html.erb\n<%= react_component \"NewMap\"%>\n. @silvenon: That's actually true ^^. I guess I just wanted to have it clean and not switch all the time around but please feel free to advice me how and when to work in rails with react plugins and when not. One remark: I wanted to create the webapp with react-rails and then later on switch to react-native for IOS and Android app. I guess therefore I wanted to stay 'within react' if you want so. But please, please! let me know what you think as I am completely new :)\n. ",
    "per-frojdh": "Ah, this makes a lot of sense suddenly.  \nSo, if I understand this correctly, if I would want to add a container to the map, capable of rendering React components inside, I'd have to extend the base L.control with a new class, use that for my leafletElement and render the appropriate children to the container through the React-DOM.\nOr is there some shortcut here I could use?\n. The Popup component was a great find, it helped me a lot.\nThanks a lot for the help and clarification!\n. Try this: https://jsfiddle.net/fa7hd0ko/\nIn this case I switched out the onResize to onDragEnd to produce the error in an easier fashion.\n. ",
    "jumpinjackie": "Excellent!\n. ",
    "alcoheca": "Looking at the closed tickets, it should just work - and in fact it did work for me once.\nI'll put this down to an inordinate & over complicated build system\n. ",
    "josdejong": "Ok thanks, will fiddle around with it.\n. Thanks @stefangordon, good to know. \nI solved it by applying a simple css grayscale transform using a regular, colored tile set:\ncss\n.leaflet-tile-pane {\n  -webkit-filter: grayscale(100%);\n  filter: grayscale(100%);\n}\n. ",
    "stefangordon": "Hey @josdejong, saw your issue when I was looking for tips on how to do the same thing.  I got a custom component working with leaflet-bing, might help you http://www.stefangordon.com/display-bing-tiles-in-react-leaflet/\n. ",
    "jeffshaver": "In MapControl.jsxs componentWillUnmount, you run this.leafletElement.removeFrom(this.props.map). However, in componentWillUnmount, while this.leafletElement is defined, this.leafletElement.removeFrom is undefined. I am not why or how to fix this though.\n. @PaulLeCam I have read that section of the README.md, but I am still not 100% of how this should be implemented. Are there any examples of implementations for other plugins?\n. ",
    "jpkeyw": "Excellent. It appears that this issue has been fixed. Thanks.\n. ",
    "bshenk": "To help give more information into this issue, here's the code that @ayinger1 and I have in question: \n```\n_drawFields = () => {\n        const fields = this.props.data.get('current').fields;\n        let layerGroups = [];\n    // Individual layerGroups\n    _.forIn(fields, (value, key) => {\n        let layers = [], color, strokeWeight = 0, minOpacity = 0.05, maxOpacity = 1,\n            opacity, ref, storeKey, visible = true, data, stroke = false, parentKey = key;\n\n        switch (key) {\n            case 'NaiveRisk':\n                color = \"#D81159\";\n                storeKey = \"naive\";\n                ref = \"sotaGroup\";\n                break;\n            case 'AdvancedRisk':\n                color = \"#FFBC42\";\n                storeKey = \"advanced\";\n                ref = \"erfGroup\";\n                break;\n            case 'Origin':\n                color = \"#218380\";\n                storeKey = \"origin\";\n                ref = \"originGroup\";\n                break;\n            case 'GeoData':\n                color = \"black\";\n                storeKey = \"roads\";\n                ref = \"roadGroup\";\n            default:\n                break;\n        }\n\n        // Check visibility\n        visible = this.props.map.get(storeKey).get('visible');\n\n        if(key === 'GeoData') {\n            data = value.Roads.data;\n        } else {\n            data = value.data;\n        }\n\n        // Opacity calculations\n        // y = ((b-a)*x + a*d - b*c)/(d-c)\n        const arrOfStrengths = Object.keys(data).map(function(key) { return data[key].strength });\n        const minStrength = Math.min.apply(null, arrOfStrengths); //c\n        const maxStrength = Math.max.apply(null, arrOfStrengths); //d\n\n        // Individual layers\n        _.forIn(data, function(value, key) {\n            const lat = value.coordinates[0], lon = value.coordinates[1], width = 0.05, strength = value.strength;\n\n            opacity = ((((maxOpacity-minOpacity)*strength) + (minOpacity*maxStrength) - (maxOpacity*minStrength))/(maxStrength-minStrength));\n\n            const bounds = [\n                [lat+width, lon-width],\n                [lat+width, lon+width],\n                [lat-width, lon+width],\n                [lat-width, lon-width]\n            ];\n\n            if(parentKey === 'GeoData') {\n                layers.push(<Polygon\n                    key={key}\n                    positions={bounds}\n                    stroke={true}\n                    weight={0.3}\n                    color={color}\n                    opacity={opacity}\n                    fillOpacity={0}>\n                </Polygon>)\n            } else {\n                layers.push(<Polygon\n                    key={key}\n                    positions={bounds}\n                    stroke={stroke}\n                    weight={strokeWeight}\n                    color={color}\n                    fillOpacity={opacity}>\n                    <Popup><span>{strength}</span></Popup>\n                </Polygon>)\n            }\n        });\n\n        const group = <LayerGroup key={key} ref={ref}>{layers}</LayerGroup>;\n\n        if(this.refs[ref]) {\n            // Remove from map if hidden\n            if(!visible) {\n                this.leaflet.removeLayer(this.refs[ref].leafletElement);\n            }\n\n            // Create this.refs.groupName for LayerGroup element to pass to props\n            this[ref] = this.refs[ref].leafletElement;\n        }\n\n        layerGroups.push(group);\n    });\n\n    return layerGroups;\n\n}\n```\n{drawFields()} creates on average about 15k+ polygons (split between 6 different layerGroups) and then is added into my react-leaflet Map component. Is attaching refs to the different layerGroups (for show/hide functionality) then passing them down via props the right approach? Is there a faster way using react-leaflet to render _many vectors?\n. ",
    "mgmeyers": "Just to chime in here, as I'm also dealing with a large number of map features. I've upgraded leaflet to 1.0-rc1 and noticed a significant perf boost, and also found that the preferCanvas option works out of the box with react-leaflet\n. ",
    "RassaLibre": "I see. Well, I am not really sure how can I call invalidateSize() on the Map object since the object is not exposed to me and I end up with half rendered map. What is your suggestion then?\nI guess the main problem is using JSX in this case. I could potentially render the Map component to a variable (lets say renderedMap), access the function via renderedMap.leafletElement.invalidateSize() and then in my JSX use {renderedMap}.\n. Aaaaaaaah, that solves my problem! Ok then. Thanks! Then I guess there is no point to talk more about this PR and you can close it. Once again, thanks! :)\n. Hi @texas697, I do something like this. Not sure if this is the best way but it did the magic for me :-)\nclass LeafletMap extends React.Component{\n\n/**\n*\n*/\nconstructor(args){\n    super(args);\n    this.state = {};\n}\n\n/**\n*\n*/\ncomponentDidMount(){\n    this.refs.map.leafletElement.invalidateSize();\n}\n\n/**\n*\n*/\ncomponentDidUpdate(prevProps, prevState){\n    if(this.props.width !== prevProps.width)\n        this.refs.map.leafletElement.invalidateSize();\n}\n\n/**\n*\n*/\nrender(){\n    return(\n        <Map\n            ref=\"map\"\n            style={{width: this.props.width, height: this.props.height}}>\n                <TileLayer url=\"http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\"/>\n        </Map>\n    );\n}\n\n}\nPlease note that string refs are outdated as they can lead to memory leaks. Use functions instead. Hope it helps!. ",
    "nickyromeijn": "Added code samples\n. ",
    "mdebbar": "Thanks for the quick fix @PaulLeCam. That definitely increases my confidence in the library \ud83d\ude04 \nKeep up the good work!\n. Or maybe we want to allow numeric strings e.g. \"0.5\" ?\n. ",
    "neopostmodern": "I disagree. Even if it is \"just an example\" it's the first thing everybody will copy and it's very, very unintuitive if you can't see anything. It will be trivially easy for everybody to start adapting / removing the specific styles if they understand that they are necessary.\nI also don't see any specific downside to including it? Correct me if I'm mistaken there.\n. ",
    "NgoKnows": "I've been trying both an external stylesheet + className, inline styles like you suggested. It ends up looking like this \n. @mikeodell77 do you happen to be using Radium or any other inline style library?\n. ",
    "mikeodell77": "I have been seeing the same thing with my project. Any thoughts?\n. ",
    "Hakaze": "Having the same issue, it seems the initial render of map renders 1 row of tiles. Any change to state or props which causes a re-render triggers the full map.\n. i'm using css modules. I had a feeling that the containers aren't being styled fast enough before the map is rendering. This ticket may be related as well #40 \nI was able to get around this by using the extract text plugin for all of my styles rather than having inline styles loaded through webpack. The only caveat is that I can't use HMR for styles.\n. ",
    "kingy68": "Hey Guys,\nI'm also getting a completely grey map. This it the Map component:\n```\nimport React from 'react'\nimport { Map, TileLayer } from 'react-leaflet'\nclass MapPage extends React.Component {\n  constructor (props, context) {\n    super(props, context)\nthis.state = {\n  lat: 51.505,\n  lng: -0.09,\n  zoom: 13\n}\n\n}\nrender () {\n    return (\n      \n\n    )\n  }\n}\nexport default MapPage\n```\nI then import the Map component into another React component and just add it into the return () function as:\n<MapPage />\nThe map shows up as completely grey, when I click and drag in the map, I get the following two errors:\nleaflet-src.js:6697 Uncaught TypeError: Cannot read property 'subtract' of undefinedL.Draggable.L.Class.extend._onMove @ leaflet-src.js:6697handler @ leaflet-src.js:6380\n22leaflet-src.js:6704 Uncaught TypeError: Cannot read property 'add' of undefinedL.Draggable.L.Class.extend._onMove @ leaflet-src.js:6704handler @ leaflet-src.js:6380\nAlso, the network traffic shows no tile request calls being made.\nCurrently using:\nReact - 0.14.8\nreact-leaflet - 0.11.1\nmaterial-ui - 0.15.0-alpha.2\nbabel - 6.7.2\nWebpack - 1.9.11\nCould it be just because I'm running it on a webpack-dev-server and not deployed onto a proper web server?\n. Managed to solve the issue. Problem was that I left out the center={some position} in the Map tag. I'm guessing center and zoom are required properties when instantiating a Map object in leaflet. Their doco shows this as the example:\n// initialize the map on the \"map\" div with a given center and zoom\nvar map = L.map('map', {\n    center: [51.505, -0.09],\n    zoom: 13\n});\n. ",
    "drwlrsn": "Oh my sweet mercy. For me this issue was caused by\nimg {\n  max-height: 100%\n}\nI also had to pass in styles to the component setting its width and height. Further calling getLeafletElement().invalidateSize() in componentDidMount also did not work.\n. ",
    "dopeboy": "In case it helps anyone, I got this error because of the tiling service I was using (hydaa). Switching to mapbox resolved the issue for me.\n. I might be seeing the same issue as OP. Here's a screenshot:\n.\nHere's the relevant code:\n```\nimport { Map, Marker, Popup, TileLayer } from 'react-leaflet';\n...\nrender() {\n    const position = [51.505, -0.09];\n\n    return (\n        <DocumentTitle title='Map'>\n            <div>\n                <Map center={position} zoom={13} style={{height:400}}>\n                    <TileLayer\n                        url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n                        attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n                    />\n                    <Marker position={position}>\n                        <Popup>\n                            <span>A pretty CSS3 popup.<br/>Easily customizable.</span>\n                        </Popup>\n                    </Marker>\n                </Map>\n            </div>\n        </DocumentTitle>\n    );\n}\n\n```\n. \nrelevant bits in package.json:\n\"engines\": {\n    \"node\": \"6.2.2\",\n    \"npm\": \"3.9.3\"\n  }\n...\n  \"dependencies\": {\n    \"leaflet\": \"^0.7.7\",\n    \"react\": \"15.0.2\",\n    \"react-leaflet\": \"^0.12.1\",\n  },\n@mbritton do you see this too?\nEDIT: resolved via #108 \n. ",
    "Kibo007": "best solution I found is to setTimeout. So problem is css modules are rendered after map it self and since leaflet depend on height it just renders first row since there is no in that moment css you set if you use css modules as well with webpack. So to go around that just set timeout with 0 miliseconds and it will be good. Code is here. Maybe this could be implemented in lib it self.\n```\nimport React, { Component } from 'react';\nimport { render } from 'react-dom';\nimport { Map, TileLayer } from 'react-leaflet';\nimport './mapView.scss';\nclass MapView extends Component {\n  constructor() {\n    super();\n    this.state = {\n      readyToRender: false,\n    };\n  }\nrender() {\n    const stamenTonerTiles =\n      'http://stamen-tiles-{s}.a.ssl.fastly.net/toner-background/{z}/{x}/{y}.png';\n    const stamenTonerAttr =\n      'Map tiles by Stamen Design, CC BY 3.0 \u2014 Map data \u00a9 OpenStreetMap';\n    const mapCenter = [39.9528, -75.1638];\n    const zoomLevel = 12;\nsetTimeout(() => {\n  this.setState({ readyToRender: true });\n}, 0);\n\nreturn (\n  <div>\n    {this.state.readyToRender && (\n      <Map center={mapCenter} zoom={zoomLevel}>\n        <TileLayer attribution={stamenTonerAttr} url={stamenTonerTiles} />\n      </Map>\n    )}\n  </div>\n);\n\n}\n}\nexport default MapView;\n```. ",
    "panuhorsmalahti": "I also have this issue (with latest React, webpack, css modules, leaflet and react-leaflet). My workaround is calling invalidateSize:\ncomponentDidMount() {\n        setTimeout(() => {\n            if (this.leafletMap.current) {\n                this.leafletMap.current.leafletElement.invalidateSize();\n            }\n        }, 100);\n    }. ",
    "FabulousAid": "\nI also have this issue (with latest React, webpack, css modules, leaflet and react-leaflet). My workaround is calling invalidateSize:\ncomponentDidMount() {\n        setTimeout(() => {\n            if (this.leafletMap.current) {\n                this.leafletMap.current.leafletElement.invalidateSize();\n            }\n        }, 100);\n    }\n\nCalling invalidateSize() within componentDidUpdate worked for me. A bit cleaner than using a timeout!. > Same here. I'm using the latest version of create-react-app. Seems to be something related, because I've never had this issue on other environments.\n\n@FabulousAid how did you referenced map within componentDidUpdate?\n\n@rdgomt I used a ref to access the map's functions. I ended up doing this:\n```\nclass MapView extends React.Component {\n  mapRef = React.createRef();\ncomponentDidUpdate() {\n    this.mapRef.current.leafletElement.invalidateSize();\n  }\nrender() {\n    return (\n      \n    );\n  }\n}```. ",
    "rdgomt": "Same here. I'm using the latest version of create-react-app. Seems to be something related, because I've never had this issue on other environments.\n@FabulousAid how did you referenced map within componentDidUpdate?. ",
    "kujon": "\ud83d\udc4d 10k may be an edge case, but the performance starts to suffer around 500 markers already. Go over 1/2k and the map is barely usable.\n. ",
    "patrickml": "@PaulLeCam instead od loading markers I ended up creating polygons to over an area -- I really just needed to map the data to see overlapping areas. Marker/Popups were really just nice to view the data.\nThank you for your time. @kujon Thank you for letting me know about the 500 limit before performance tanking. I will keep that in mind for future projects.\n. ",
    "ankitduseja": "I figured it out. The pstyle needs to be passed as a function instead of an object. Closing the issue.\n. ",
    "fschimandl": "My import looks like this:\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport L from 'leaflet';\nimport $ from 'jquery';\nimport _ from 'underscore';\nimport { Map, Marker, CircleMarker, Polyline, TileLayer, Popup, ZoomControl, GeoJson, LayerGroup, LayersControl, FeatureGroup }  from 'react-leaflet';\nconst { BaseLayer, Overlay } = LayersControl;\nAnything wrong with it?\nThx for help!\n. ",
    "TylerGriffin99": "How did you end up solving this @evenfrost ?. ",
    "jketcham": "I had an issue not directly related to this, but where I was trying to render the Map within a stateless component and it created some odd issues. Sometimes when the component was loaded, an exception would be thrown complaining about the element being undefined when it was trying to get its position. Eventually I just rendered the Map in a class based component and all the issues went away.. fwiw, I ran into this when using flow v0.76.0, and to solve I added the path to the module under the [untyped] section in the flow config file:\n```\n[untyped]\nsuppresses this issue: https://github.com/PaulLeCam/react-leaflet/issues/364\n./node_modules/react-leaflet/.\n```\nalso, at this time the [untyped] section of the flow config is undocumented (sigh), but there's an issue open with a pull request going here: https://github.com/facebook/flow/issues/6749. ",
    "bduffany": "Nevermind, I think the way to do this is\n<Map zoomControl={false}>\nthen add my own ZoomControl. Please let me know if there is a better way!\n. ",
    "rhewitt22": "This is the same way you do this with the core Leaflet library, too. (i.e. there's no better way).. ",
    "nguyendh2601": "L.geoJson( <Object> geojson?, <GeoJSON options> options? )\noptions of GeoJSONare not Path options like CircleMarker.\nL.circleMarker( <LatLng> latlng, <Path options> options? )\nI think we should change componentDidUpdate of _GeoJson.js_ to\ncomponentDidUpdate(prevProps) {\n    this.setStyleIfChanged(prevProps.style, this.props.style);\n }\nWhat do you think @PaulLeCam @boromisp ? I can create PR for this\n. Hi @tiagocedrim,\nAs your code above, you could use bounds to achieve your expectation https://jsfiddle.net/4p7u56wy/\nFYI\n\nbounds: bounds (optional): A rectangle for the map to contain. It will be centered, and the map will zoom in as close as it can while still showing the full bounds. This property is dynamic, if you change it it will be reflected on the map.\n. \n",
    "davidascher": "Apologies for the noise.\nFixed it, by using code like:\n```\n  onEachFeature(feature, layer) {\n    let labelPerCountry = this.labelPerCountry;\n    layer.on({\n      click: function(event) {\n        var popup = L.popup()\n            .setLatLng(event.latlng)\n            .setContent(labelPerCountry(feature))\n            .openOn(layer._map);\n      }\n});\n\n}\n```\nand:\n<Choropleth\n        data={geojson}\n        valueProperty={this.numCasesPerCountry}\n        scale={scale}\n        visible={this.isCountryListed}\n        onEachFeature={this.onEachFeature}\n        steps={5}\n        mode='e'\n        style={style}\n      />\n. ",
    "shackbarth": "FWIW, I've found the best way to strongarm the leaflet events into a more declarative pattern is something like the following:\n```\n  render() {\n    const bounds = SOME_INITIAL_BOUNDS;\n...\n\n<Map\n  bounds={this.state.zoom ? undefined : bounds}\n  center={this.state.zoom ? { lat: this.state.lat, lng: this.state.lng} : undefined}\n  zoom={this.state.zoom}\n  onMoveEnd={this.mapEvent}\n  onZoomEnd={this.mapEvent}\n>\n\n...\n\n}\n  mapEvent(event) {\n    const { lat, lng } = event.target.getCenter();\n    this.setState({ lat, lng, zoom: event.target.getZoom() });\n  }\n```\nBasically, as soon as we use the leaflet events to change the map state we stop using bounds to drive the map, and instead use our reacty state, which follows the leaflet state.. ",
    "Luca1995it": "I found a way to do this, hope it will helps new users:\nhttps://stackoverflow.com/questions/52085768/close-popup-react-leaflet-after-user-click-on-button-in-popup/54874575#54874575. ",
    "thenickcox": "Sorry, appears this is referenced here: https://github.com/PaulLeCam/react-leaflet/issues/115\n. I tried something along these lines\n``` javascript\nimport { Map } from 'react-leaflet';\nimport { map } from 'leaflet';\nexport default class MapWithZoom extends Map {\n  componentWillMount() {\n    super.componentWillMount();\n    this.leafletElement = map(this.props);\n  }\ncomponentDidUpdate(newProps) {\n    console.log(newProps.zoom);\n  }\n}\n```\nThat wasn't working. I'm sure I did something wrong.\n. Sorry, I promise I read the docs and tried things before filing this issue! If anyone else looks here, this is referenced in the Events API docs.\n. Thanks, @arusahni. I think the take-away is that the <Map /> component supports all the events in the official leaflet event docs, simply prefixed with on, e.g., zoomEnd -> onZoomEnd.\n. ",
    "njbarrett": "Thanks @jgimbel I think your component will help achieve what I need.\n. ",
    "banisirohi": "I'm also having tough time integrating leaflet freedraw with react-leaflet. And to make it behave consistent with react-leaflet-draw. Did you able to achieve any solution through react-leaflet-control. I'm clueless how to make it work that way. Thanks.. ",
    "elangobharathi": "@banisirohi I have created a plugin react-leaflet-freedraw for leaflet freedraw integration. Please take a look at it and let me know if you encounter any issues.. ",
    "arusahni": "For those of you who tried clicking the now-broken link in the previous comment, the solution is to add the onZoomend property to your Map component declaration.\ne.g.:\njs\n<Map onZoomend={this.onZoomEvent}>\n</Map>\n. ",
    "hughlomas": "@jgimbel Yes, the grouping is working correctly as verified with console logs.\n@PaulLeCam Thank you for such a quick response, I tried out the fix and it works perfectly!\n. ",
    "calivet": "Thank you very much !\n. ",
    "nehovaysyatopol": "How about anwser?\n2016-06-24 19:14 GMT+03:00 Paul Le Cam notifications@github.com:\n\nClosed #177 https://github.com/PaulLeCam/react-leaflet/issues/177.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/issues/177#event-703389868,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AED-eFGE4RwAIch8bACMlCGkGbhaEZxzks5qPAJugaJpZM4I8szp\n.\n. \n",
    "antoniopuero": "The fix has been released already, but your peerDependency doesn't allow me to install version later than 0.7.x. and another reason is checking for the identity of two objects (leaflet icon), otherwise, setIcon is called every propagation cycle.\n. ",
    "hgenru": "Now I use this hack\nlet center = this.props.center ||\n        this.props.userCurrentPosition ||\n        this._center ||\n        defaultPosition;\n        this._center = center;\n. https://jsfiddle.net/ofmbybbt/1/\n1. Click go to Paris button.\n2. Drag map center\n3. Click go to Paris button again\n. ",
    "jakehm": "Can you put a link to the plugins in the root readme rather than just the readme in the docs?\n. ",
    "dkrichards86": "Thanks for the fix!  Everything is behaving as expected.\n. According to the docs, there is a third party plugin for div icons.\nReact Leaflet Div Icon\nOr, you could just pass in the div icon yourself:\njs\nvar myIcon = L.divIcon({className: 'my-div-icon'});\n<Marker icon={myIcon} />\n. ",
    "heeton": "@jgimbel I tried a nastier version of this, but your example is good, thanks. \n. ",
    "tiagocedrim": "@PaulLeCam What would be the best way to achieve this with the code below ?\nhttps://jsfiddle.net/hqjv5utx/\n. @PaulLeCam Thanks, worked perfectly :metal: \n. Hi @jgimbel thks for the tip :metal: \n. ",
    "TimoRuetten": "You're absolutly right. I will post to Stackoverflow! Thanks\n. Hm ? As far as I can see this is a bug. The bug seems to be that when I set \n[52.516743172151706, 13.726558685302734]\nas center in your component the onViewportChanged get triggered and returns this as center: \n[52.516952093701605, 13.726558685302734]\nThis seems to be a bug for me.. ",
    "cherouvim": "The example you provided is nice, but it doesn't use any custom HTML. Is it possible to have react generated HTML (JSX) into that leaflet divIcon?. ",
    "Yamakaky": "Related: Marker misses the \"title\" property.\n. ",
    "albandiguer": "<3\n. ",
    "Dahlgren": "Leaflet 1.0 was just released, http://leafletjs.com/2016/09/27/leaflet-1.0-final.html \ud83c\udf89 \n. See #229 \n. ",
    "mbritton": "Thanks for the excellent work. Is there an ETA on the rc for react-leaflet that supports the complete Leaflet v1 feature set?\n. It could have been the CSS, but I tested with all of it solidly in place. Even tried it with all the CSS  bundled into the JS. I never had a problem.\nI removed the render from the bottom of the JSX component, renamed the JSX component to .js, and added export default to the class declaration. One of these changes fixed the problem. \n```\nimport React from 'react';\nimport { render } from 'react-dom';\nimport { Map, Marker, Popup, TileLayer } from 'react-leaflet';\nexport default class LeafletMap extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      lat: 33.9301310, \n      lng: -84.7667300,\n      zoom: 13\n    };\n  }\ncomponentDidMount() {\n    //\n  }\nrender() {\n    const position = [this.state.lat, this.state.lng];\n    return (\n      \n\n\nA pretty CSS3 popup.  Easily customizable.\n\n\n\n    );\n  }\n}\n```\n. Try giving Map a ref attribute:\n<Map ref=\"foo\"></Map>\nThen reference in componentDidMount():\nconst map = this.refs['foo'].leafletElement\n. I did something similar, extended FeatureGroup to send map bounds back through the app with an Action. Not sure if this is a best practice, but it works. Wish I knew how to bubble events up the chain in Redux. :D\n. Read the documentation , and have been unable to access the ref of a geojson object despite it being defined at runtime. That is why I posted this issue.\n. ",
    "zavan": "I upgraded from leaflet rc3 to final and now i'm getting: \nGET http://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.0-rc.3/imagesmarker-icon.png 404 (Not Found)\nGET http://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.0-rc.3/imagesmarker-shadow.png 404 (Not Found)\nWhen rendering markers:\nhtml\n<div class=\"leaflet-pane leaflet-marker-pane\">\n  <img src=\"//cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.0-rc.3/imagesmarker-icon.png\" class=\"leaflet-marker-icon leaflet-zoom-animated leaflet-interactive\" tabindex=\"0\" style=\"margin-left: -12px; margin-top: -41px; width: 25px; height: 41px; transform: translate3d(605px, 190px, 0px); z-index: 190; outline: none;\">\n</div>\nDowngrading to rc3 works.\nThe url is different: http://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.0-rc.3/images/marker-icon.png\n. I'm having this problem on 1.0.0-beta.1\n. ",
    "tconroy": "Hey there! great work on these components, they're pretty amazing. Was wondering if you had an ETA on the v1 release? I noticed there's an open PR regarding it ( but appears to be a WIP? ). Going to be using this guy in a production app within a few weeks and would love to use 1.0.\n. awesome work, @PaulLeCam! \ud83d\udc4f \ud83d\udc4f \n. ",
    "prewk": "Hi, where do you want the RC2 bugs reported? In the PR?\n. I wasn't aware there was a distinction between dynamic and non-dynamic props? Doesn't sound very Reacty IMHO, but I'm sure you have your reasons when wrapping a complex library such as Leaflet.\nIs this documented somehow?\n. Ah, you're absolutely right. Sorry for wasting your time and thanks you for a great lib!\n. ",
    "SpaceK33z": "You could also place a button to the bottom right with absolute positioning. Bit a hacky, but it works ;p.\n. ",
    "lifeiscontent": "@jgimbel thanks! Will post questions on SO next time.\n. ",
    "drwelby": "What is the best way to set the options for initializing the map? Could some initialization properties be added? In my case I don't need zoom to be dynamic, but it would be nice to specify the initial zoom as a property such as initZoom={13}, or maybe an entire initOptions object that is only used when first creating the Leaflet element.. ",
    "dkreft": "I think the stack trace demonstrates that it is indeed a problem with the library, specifically the  library's interaction with Node + jsdom. JSFiddles run in a browser, so it's going to be impossible to reproduce the same bug.\nDoes this mean you're unwilling to look into this?\n. Nope. I just relegated myself to putting a div with an id in it and passing\nthat in as the container.\nSad but true.\n-dan\nOn Thu, Sep 1, 2016 at 5:41 AM, Hugh Loughrey notifications@github.com\nwrote:\n\n@dkreft https://github.com/dkreft - I'm getting a similar error 'Error:\nMap container not found.' when testing a Map component using Chai, Mocha\nand Karma - did you ever get the bottom of your issue?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/issues/204#issuecomment-244066287,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAQpaW6tlvTGW0wrG3sPlvIc9axVgEw2ks5qlsfegaJpZM4Jljgv\n.[image: Web Bug from\nhttps://github.com/notifications/beacon/AAQpaZahDVvEQoxwDV3j6QJMXuCgXXZkks5qlsfegaJpZM4Jljgv.gif]\n{\"api_version\":\"1.0\",\"publisher\":{\"api_key\":\"\n05dde50f1d1a384dd78767c55493e4bb\",\"name\":\"GitHub\"},\"entity\":\n{\"external_key\":\"github/PaulLeCam/react-leaflet\",\"title\":\"PaulLeCam/react-leaflet\",\"subtitle\":\"GitHub\nrepository\",\"main_image_url\":\"https://cloud.githubusercontent.com/assets/\n143418/17495839/a5054eac-5d88-11e6-95fc-7290892c7bb5.png\",\"\navatar_image_url\":\"https://cloud.githubusercontent.com/\nassets/143418/15842166/7c72db34-2c0b-11e6-9aed-b52498112777.png\n\",\"action\":{\"name\":\"Open in GitHub\",\"url\":\"https://github.\ncom/PaulLeCam/react-leaflet\"}},\"updates\":{\"snippets\":[{\"\nicon\":\"PERSON\",\"message\":\"@hloughrey in #204: @dkreft - I'm getting a\nsimilar error 'Error: Map container not found.' when testing a Map\ncomponent using Chai, Mocha and Karma - did you ever get the bottom of your\nissue?\"}],\"action\":{\"name\":\"View Issue\",\"url\":\"https://github.\ncom/PaulLeCam/react-leaflet/issues/204#issuecomment-244066287\"}}}\n. \n",
    "hloughrey": "@dkreft - I'm getting a similar error 'Error: Map container not found.' when testing a Map component using Chai, Mocha and Karma - did you ever get the bottom of your issue?\n. ",
    "evansiroky": "@dkreft Thanks for the example of how to use enzyme to test react-leaflet!  I've been looking all around the interwebs and this seems to be the best example out there.\n. See my research into this issue here:  https://github.com/PaulLeCam/react-leaflet/issues/246#issuecomment-258304411. @thomasthiebaud it won't matter where the react-leaflet map component is nested in your structure.  The only way to get react-leaflet map components to mount with enzyme is by attaching it to an existing element which has been inserted in the document body in jsdom or some other document-like thing.  \n@dkreft I did some research and it appears that the core issue is that Leaflet scans the document body to try to find the element to modify, but doesn't find it because of the following:  enzyme attempts to mount by calling react-addons-test-utils.renderIntoDocument which creates a blank div, but does not insert it into a document body.  Therefore, when you mount with the attachTo method and the thing you're attaching to has been inserted into the document body, then everything contained within that element is now searchable and thus Leaflet can find it.\n. ",
    "simeonackermann": "@dkreft i know its a bit old issue, but do you have any solution for this problem? Its seems still not solved.... Thanks, I ignored the attach mode. My simple solution: https://github.com/PaulLeCam/react-leaflet/issues/246#issuecomment-292033126. Based on https://github.com/PaulLeCam/react-leaflet/issues/246#issuecomment-258304411 the solution could be to use attach as mount option.\nFor example the Parent component renders the map, in the test I attach the Parent to an empty div:\n```\nimport React from 'react';\nimport {mount} from 'enzyme';\nit('test map', () => {\n   const div = global.document.createElement('div');\n   global.document.body.appendChild(div);\nconst wrapper = mount(, {attachTo: div});\n});\n```. ",
    "kachkaev": "The same seems to happen when I try wrapping my objects into <LayerControl /> and <Overlay />. More than that, className does not update at least for <Circle />, <Circlemarker /> and <Multipolyline /> when the new value for this prop is passed.\n. Hi Paul,\nI understand that the library is a thin wrapper, but I think that there should be some logic in ordering of layers though. React is declarative and the result of rendering is stateless (i.e. always the same for the given set of React components returned by render()). This creates an expectation that the leaflet markers will always appear in the same order as they are listed inside <Map />. This is currently not the case.\nImagine I have three markers, two of which are currently shown (the very first one is hidden).  Map's children are 2 and 3. I change some prop of the parent component and the map re-renders; now there are three children (1, 2, 3). What react-leaflet will do in this case is keeping two already visible components still without any changes and then adding the third one to the very end of the list. The resulting order will be 2, 3, 1 instead of 1, 2, 3 as it would be expected from React's virtual DOM. In case if the visibility prop for the first marker is true from the beginning, markers will appear as expected: 1, 2, 3.\nI'll try to produce a MWE for className and style in a few days if there is some free time.\n. I tried playing with <LayerGroup /> and even <LayersControl.Overlay /> as well as changing keys, but could not get the desired result. 'Randomising' all keys to always get new re-ordered markers made each render a bit slow. The final solution was in hiding the circles by in changing their radius to minimum and applying opacity=0. All markers do exist at all times regardless of which of them are visible and which are not. This is a pretty dirty hack, but that's the only thing that worked for me after a few hours. The solution introduces a rather pity side-effect though: when a user moves a mouse over a blank space on the map, they sometimes see unwanted tooltips on the side because onMouseenter triggers on 'hidden' elements.\nThe purpose of React is to make all other APIs declarative, stateless and predictive. I know that if I what to use some drawing component tomorrow to draw a circle and a rectangle, it will always be the case that the shapes appear in the same order as the components inside render(), no matter how they are actually managed under the hood (it can be canvas, webgl, svg or whatever else). Same for leaflet: if at any point in time the state of the virtual DOM does not match what a user sees with their eyes, this means that something is not working as expected.\n. Also raised this in https://github.com/PaulLeCam/react-leaflet/issues/205 earlier. IMO the ordering of the layers should be an internal job for a component that wraps Leaflet's API so that the result is stateless and intuitive. Thanks for sharing your workaround @PaulLeCam, I'll use it in my next project with leaflet!. ",
    "gazaston": "@mbritton did you get this figured out?\n. ",
    "samjbmason": "Just following up on this, how is it possible to access the GeoJSON components ref then if it's not available on componentDidMount ?. ",
    "scuerda": "@samjbmason I \"solved\" this with some really ugly counting in componentDidMount.\nWhen I passed in data to my map container component, I recorded the number of geojson features that were to be added.\nIn comonpentDidMount, I added an event handler on the Map component for 'layeradd' and then counted how many polygons had been added and checked against what was expected. Once all were added, I had to setTimeout and then I was able to access GeoJSON feature methods and events within the setTimeout callback.\nUgly stuff, but it got the job done.\ncomponentDidMount() {\n        let count = 0;\n        const map = this.refs.map.leafletElement;\n        map.on('layeradd', () => {\n            count += 1;\n            if (count > this.state.polygonCount) {\n                setTimeout(()=>{this.zoomHome()}, 200)\n            }\n        });\n    }. ",
    "mroutis": "Ok, thanks, @PaulLeCam :ok_hand: \n. ",
    "aparij": "Or you can add babel-polyfill to the dependencies.\n. Well, the thing is I have it and it still doesn't work. Anyways I don't think adding babel-polyfill will help in this case, it's something else.\n. ",
    "dettier": "This is the reason it doesn't work in IE <= 10: https://babeljs.io/docs/usage/caveats/\nYou can just add protoToAssign and loose options in babel configuration to fix this.\nbabel-polyfill won't help with this one.\n. ",
    "webcarrot": "Version 2.0 work in IE >= 9 with https://www.npmjs.com/package/proto-polyfill. ",
    "ernoaapa": "Oh yeah sure! In Leaflet Polygon documentation http://leafletjs.com/reference.html#polygon it says: \n\"You can also create a polygon with holes by passing an array of arrays of latlngs, with the first latlngs array representing the exterior ring while the remaining represent the holes inside.\"\n. ",
    "rjdestigter": "I've got an early working version available here: https://github.com/rjdestigter/react-leaflet/tree/MapPane\nI added pane as a contextType to LayerGroup, GeoJson, Marker, and ImageOverlay which in turn is passed on to leaflet when instantiating the class.\nExample:\n<Map>\n  <MapPane name='foodtrucks'>\n    <LayerGroup>\n       <MyFoodTruckMarkers />\n   </LayerGroup>\n  </MapPane>\n</Map>\n. @PaulLeCam Would you prefer a PR with just the changed and added source code and not a 'built' version?\n. ~~No merge at the moment, pane should should only be passed as an option if it is defined. Leaflet does not override an undefined pane with it's default pane for some of the items (tileLayer for example.)~~\n. Conflicts with next have been resolved.\n. I suggest we still allow using default leaflet panes but don't set their style in that case. Pane doesn't actually really override existing panes, it just receives them from map.getPane and thus won't create them since it already exists.\nTodo's:\n- [x] Remove zIndex prop\n- [x] Disallow usage of existing panes unless they are default leaflet panes\n- [x] Don't apply style to default panes. (Disallow style props for default panes) \n. I also realised className was being completely ignored so I added that in as well. Proper behaviour was added to deal with this.props.name changes.\nAlso, yes, let's disallow using default names. I thought I needed that feature, but if I want other components such as Popup or any component for that matter to be added to a default pane even if it is nested inside a Pane component, I can just use prop.pane for them.\n<Pane name='paris'>\n  <GeoJSON data={...}>\n    <Popup pane={'popupPane'}\nI will disallow default pane names.\n. Ok, done, using default pane names or that of existing panes will throw an error.\n. > but I'm happy to merge this PR as-is and work on it myself if you prefer?\nI'm good with that if you approve of today's changes. The only thing that I'd like to revisit myself is getChildren, but you are welcome to that as well.\nI'm not sure if React.cloneElement is really necessary. map is available through context and if apps using Pane need it to pass down props, they can always extend Pane and override getChildren\n. Also, thanks by the way for letting me collaborate on this project!\n. I acutally went ahead and removed the usage of cloneElement. I tested it using nested Panes and it's working fine. \nAlso when map.createPane is called I store the used name in this.paneName. This was necessary because in some cases componentWillUnmount is called before this.setState({name}) is persisted to local state causing Pane not to remove the pane.\n. The pointToLayer callback is directly passed to leaflet.  L.geoJSON(..., { pointToLayer }. However your callback is returning React.createElement(CircleMarker, ..). Use Leaflet's API instead by returning L.circleMarker(..)\n. I'm really not liking having to copy over code to be able to extend. . @nuragic I agree, but in that case I would still expose the functionality some of the classes implement (as functions maybe) for re-use to allow composition. There isn't at the moment as far I can find. Browsing Leaflet's source code I could only find:\n- createPane, getPane, and getPanes\nCalling L.DomUtil.remove(pane) only removes it from the DOM but not the references leaflet keeps in map._panes and map._paneRenderers\nI had to dig for _paneRenderers. It was keeping a reference to the detached pane node causing leaflet to render layers inside it if the pane was added back again.\nI find this 'hacky' as well but I couldn't find a cleaner method or api for it at the moment.\n. I've added props.pane to allow overriding context.pane. This is usefull when rendering Popup components that might get an incoming 'pane' as context but you want them to render inside another or leaflet's default poup pane.\nLeaflet allows nested panes. getParentPane passes a parent pane node to createPane if that is the case.\n. - [x] Done\n. - [x] Done\n. - [x] Done\n. - [x] Done\n. - [x] Done\n. Syntactic sugar. Since the main purpose of leaflet panes is to have more control over of zIndexes I included it as a prop. Let me know if you want this dropped.\n. - [x] Done\n. Yes, but React in this case is not in charge of the DOM node right?\n. It is prevented by Leaflet. Not preventing in the Pane component allows for using Leaflet's default panes in Pane as well.\n. - [x] Done\n. Since React is unaware of the actual DOM node, I have to apply incoming style changes to the pane node.\n. Basically Pane will ask the map for the pane and call map.createPane if map.getPane returns nothing. So passing name=\"overlayPane\" will not create a pane but return the map's default overlayPane, allowing users to use Pane in combination with default panes.\nHowever on componentWillUnmount only non-default panes are actually removed.\n. This does create a discrepancy if say I have <Pane name='myCustomPane' /> in two places. If one is unmounted, the other React component might still be alive but it's referencing pane is unmounted. We could either:\n- Non-default pane names must be unique and so the pane must not exist yet. map.getPane(name) should return nothing beforemap.createPane` is called for non-default pane names.\n- Or we keep track of how often a non-default pane is used somehow.\n. ",
    "rusffer": "Hi all, \nI had the same issue.\nstoil, it is because you are using styles from newest version of leaflet\nTry to use same version as in example:\nhttps://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/leaflet.css\n. ",
    "stoil": "First of all, I am sorry for my late answer. \nThank you very much rusffer, your solution worked and now the popup works fine.\n. ",
    "Deraen": "Tested and I can confirm that fix works.\n. ",
    "BaptWaels": "Hi,\n\nit should no longer be necessary to set the default icon path with Leaflet v1.0.0\n\nI use : \n- \"leaflet\": \"^1.0.1\"\n- \"react-leaflet\": \"^1.0.0-rc.2\"\nbut I still get this error :\n.../imagesmarker-icon.png Failed to load resource: 404 (Not Found)\n.../imagesmarker-icon.png Failed to load resource: 404 (Not Found)\nWhy do I still get it ?\n. Yes, It tries to load the image from : \nhttp://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/imagesmarker-icon.png 404 (Not Found)\nBut the image doesn't exist\n. Oh great ! I was also using react-leaflet-draw. This package has installed react-leaflet 0.12.1 as dependencies.\nEverything works great now.\nThanks a lot for your help :)\n. ",
    "jacobmischka": "Currently the path is set with some weird CSS magic in leaflet 1.0. If you're using a module bundler like webpack it probably doesn't support it: https://github.com/webpack/css-loader/issues/322\nEdit: Ah nevermind, looks like this was fixed in leaflet 1.0.1.\n. That line was removed from react-leaflet in 1.0.0-rc.1: https://github.com/PaulLeCam/react-leaflet/commit/b0e95ff0d45b88a5e6d995114642d3114dc4b063#diff-1fdf421c05c1140f6d71444ea2b27638L34\nBecause the version number you see is still 0.7.7 it looks like you're using a version of react-leaflet older than 1.0.0-rc.2.\n. ",
    "kylepolich": "Was there a resolution to this?  We're struggling with the same problem.\n. ",
    "IanChen83": "You should add a stylesheet link to your html like\n<link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.1/leaflet.css\">\n. ",
    "Charmatzis": "I have updated with the new version react-leaflet-google v2.1.0.\nNow it uses: \n- \"react-leaflet\": \"^1.0.1\"\n- \"leaflet\": \"^1.0.2\"\n- \"react\": \"^15.4.1\"\n- Leaflet.GridLayer.GoogleMutant. ",
    "mdfischer": "I am having an issue which is perhaps the same thing.  The render function is being called with new props for the WMSTileLayer component:\nrender: function () {\n  var params = this.getWMSParams();\n  return (\n    <div>\n       <WMSTileLayer\n          className={styles.overlay}\n          url={NCWMS_URL}\n          format={params.format}\n          transparent={params.transparent}\n          opacity={params.opacity}\n          styles={params.styles}\n          version={params.version}\n          srs={params.srs}\n          logscale={params.logscale}\n          origin={params.origin}\n          layers={params.layers}\n          time={params.time}\n        />\n     </div>\n  );\n},\nand I have confirmed in the debugging console that params are being correctly set to their updated values by getWMSParams(), however, no WMS request is sent to the url. Thus, the WMS tile layer is not updated on the map and the old layer is left in place.\n. I am using the updated v1.0.0-rc.2 (your 'next' branch).  I have confirmed that the other parameters update appropriately and a new WMS request is sent out (as you solved in issue #237), but then found this new issue with the SRS prop.\n. Actually, this is my mistake.  I didn't realise that the CRS property needs to be set by the parent Map, which the enclosed WMSTileLayer then inherits (successfully).  So, I was seeing the default EPSG:3857 being passed down from the Map on the initial load, because I had no CRS/SRS set.  Sorry for the confusion.\n. ",
    "hzburki": "<WMSTileLayer\n       url=\"http://18.212.81.189:8080/geoserver/Texas/wms?service=WMS\"\n       version='1.1.0'\n       opacity={1}\n       transparent\n       layers=\"Texas:intelligence\"\n       srs=\"EPSG:4326\"\n       format=\"image/png\"\n       cql_filter={cql_filter ? cql_filter : \"INCLUDE;NAME='Texas'\"}\n/>\nI'm using the above code-snippet. When I updated the cql_filter string. The map is cleared of the existing WMSLayer, I can see the request being sent out and executing successfully with 200 status. The params are present in the request sent out but nothing renders on the map. ",
    "jdeniau": "OK well, I got another bug now, but I opened an issue on stackoverflow\n. ",
    "Becherman": "Thank you for this solution! Everything works correctly!\n. ",
    "sunny-g": "Hey @javacoderxxp, the correct link is: https://github.com/PaulLeCam/react-leaflet/blob/master/docs/Extending.md#creating-custom-components\n. @PaulLeCam Would it possible to make the url prop dynamic as well, something like before this conditional:\njs\nif (!isEqual(this.props.url, prevProps.url)) {\n  this.leafletElement.setUrl(this.props.url); // potentially noRedraw set to true to reduce over-redraws\n}\nThis could make it significantly easier to hide/show the layers without having to resort to the imperative Leaflet API for adding/removing layers.\n. ",
    "luzeduardo": "I just corrected the image path. Can you merge this?\n. ",
    "thomasthiebaud": "Ok, thank for the answer. I will try to investigate.\n. ",
    "obetomuniz": "Hey @PaulLeCam \nI mean, use something like <Marker icon={<MyCustomIcon />}> ... </Marker>...It's possible this type of declaration?\n. Awesome @dkrichards86, do you guys have any idea about include it as a built-in feature? it's a good thing to have in terms of customization. Anyway, thank you for sharing the approach, will be useful for me. Maybe it can be added as a tip in the docs. Thoughts?\n. ",
    "wafisher": "My apologies. After spending a while on this, I realized as soon as I wrote the issue to look in package.json. I ran npm install followed by npm run-script examples all from the root directory, for anyone interested.\n. ",
    "joeyrosztoczy": "@PaulLeCam Thanks for the feedback. \nI'll make all those changes this evening and resubmit! \nI think I was using a misleading local copy of eslint as well, so I'll get those guys fixed.\n. ",
    "lorem--ipsum": "That's interesting. Off the top of my head, I'd say it's better to check something that to generate unnecessary divs, especially when those are empty. So checking whether this.props.children is an array is one thing, but simply checking if there are children is an other.\nMaybe something like this :\nconst { children } = this.props;\nreturn Array.isArray(children) ? <div style={{display: 'none'}}>{children}</div> : (children || null);\n?\n. Awesome, thanks a lot !\n. ",
    "IGlautier": "Additionally it appears that the onEachFeature prop is broken.\n. Appears that this was actually nothing to do with react-leaflet. For anyone experiencing similar issues check the zIndex of other html elements, even if not positioned above the leaflet map they seem to interfere. . ",
    "PTihomir": "I have the same issue. But previously it worked. I just updated react-leaflet and it started to work as mentioned in the comment above.\n. My  solution to solve this problem:\n```javascript\nimport L from 'leaflet';\nL.Icon.Default.imagePath = '.';\n// OR\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n});\n```\nbut if anybody has some nicer solution, please share :). ",
    "thj-dk": "I'm aware. I haven't been able to locate this issue in their docs, and I thought that most people here used it with webpack, so I was hoping that some could share a solution.\n. ",
    "danhayden": "looks like this may be linked to https://github.com/Leaflet/Leaflet/issues/4968 and https://github.com/Leaflet/Leaflet/pull/5041. ",
    "grahamb": "Thanks for the workaround, @PTihomir. I had to go with the delete L.Icon.Default.prototype._getIconUrl; option; doing L.Icon.Default.imagePath = '.'; resulted in a . being prepended to a data URI (e.g. .data:img/png;base64......), probably due to something in my webpack config.. ",
    "codeofsumit": "Thank you @PTihomir, this worked:\n``` js\nimport L from 'leaflet';\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n});\n```. ",
    "MatthewPardini": "I used @PTihomir solution, but had to change the import statement to a require variable. I also had to use the delete method as the '.' prepended the path with a '.' and the problem remained.\nvar L = require('leaflet');\nHope this saves someone else some time.. ",
    "yoursdearboy": "You need to use file-loader for webpack.. Hi @Harti @knackjason. I've made a demo to investigate this issue. See the 2nd and 3rd commits for errors descriptions and solutions.\nI think the problem here is with file name generation (specifically with hash). Removing it is a major\n downside of this solution. I'd like to ask webpack community for help and provide this demo but didn't have time yet.. @knackjason Doesn't @PTihomir solution work without this? I'd like to understand why the hash is broken.. ",
    "Harti": "@yoursdearboy mind getting more specific? What options do I put where?. ",
    "knackjason": "@yoursdearboy more details would indeed be appreciated. I am using file-loader (I couldn't even build w/o adding it in b/c of the leaflet CSS), but still have the error we're all dealing with here. Did you figure out a different way to get this working?. @yoursdearboy ah, ok. I see what you doing.\nI combined your idea with the workaround above and have this working with Leaflet 1.3.1 and Webpack 4.8.2:\nwebpack.config.js\njavascript\n...\nmodule: {\n...\n    {\n        test: /\\.(png|svg|jpg|gif)$/,\n        use: [{\n            loader: 'file-loader',\n            options: {\n                name:'img/[name]_[hash:7].[ext]',\n            }\n        }]\n    }]\n},\n...\napp.js\n```javascript\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\n// stupid hack so that leaflet's images work after going through webpack\nimport marker from 'leaflet/dist/images/marker-icon.png';\nimport marker2x from 'leaflet/dist/images/marker-icon-2x.png';\nimport markerShadow from 'leaflet/dist/images/marker-shadow.png';\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n    iconRetinaUrl: marker2x,\n    iconUrl: marker,\n    shadowUrl: markerShadow\n});\n. @yoursdearboy ah, yes that is the case. The extra Webpack config is unnecessary. I'm still pretty new to Webpack, so ... yeah.\nI read through a bunch of Leaflet issues related to this issue the other day. Some of them explain what's going on with the hash getting messed up. These two have most of the information that I was able to track down. It's pretty sad to me that this has been an issue for 2 years now.\nhttps://github.com/Leaflet/Leaflet/issues/4968\nhttps://github.com/Leaflet/Leaflet/pull/5771. @georgiana-gligor @PTihomir is really the one you should be thanking. I'm glad you didn't have to spend the time debugging though. :smile: . ",
    "georgiana-gligor": "Thank you @knackjason, you saved a me a good hour of debugging!. ",
    "Jonahss": "Thank you :). ",
    "louh": "Ah, this helped me. The documentation says to use context, but context is only available for child components!. ",
    "Mloweedgar": "@PaulLeCam great! I tried your solution and It helped me. ",
    "minhlucvan": "or maybe just check your leaflet.css version, it's took me hours actually :sweat_smile:. ",
    "1Paint": "Took a while for me to find out why my onEachFeature function was not binding a tooltip and onClick function.\nThe tooltips and onClick functions were being binded, but my GeoJSON layers were being rendered in Panes. Panes were layered over each other in order of declaration and only the most recent Pane's GeoJSON layer was interactive.. ",
    "kevinSuttle": "Will do. Thanks. . ",
    "shivika": "I am having this same issue using the [number,number] prop format for an array of locations \ncenter={[marker[0], marker[1]]}\nWas your issue resolved?. ",
    "rsolomon": "Context could be preserved using an HOC without resorting to unstable_renderSubtreeIntoContainer, as mentioned in the OP. I don't have time to take this on today, but if someone else comes across this and feels a more immediate need, it should be very possible without using dubiously-named hidden functionality.. No problem. Any chance this could make it into a release?. ",
    "anandgeorge": "Is it possible to serve tiles locally, offline?. Thanks. No. ",
    "reggie3": "@anandgeorge did you have any luck getting offline support working?. ",
    "jbccollins": "@PaulLeCam Thanks for the quick reply. I'll take a look at that branch.. @PaulLeCam Ok. I checked out that branch and It's much better. I can get what I want with just:\njavascript\nexport default class CustomMap extends Map {\n  createLeafletElement (props: Object): Object {\n    return L.customMap(this.container, props);\n  }\n}\nAny idea when this branch will be merged and published?. Hmmm.  Are you saying that it's expected that the key prop would determine the ordering (or lack thereof) of layers? I mean... I guess I could hack together a function that does repeated .bringToFront() calls but I can't imagine that's particularly efficient. Do you have a suggestion as to where I should deal with this? Perhaps by parsing and sorting the \"children\" prop of my custom map component?. @PaulLeCam Gotcha. I'll try z-index. Thanks for the suggestion.. @PaulLeCam It doesn't look like z-index is an option for GeoJSON layers. \nMy solution was to implement a custom ordering system based on a \"priority\" prop.\n```javascript\nimport 'leaflet-custom';\nimport { Map } from 'react-leaflet';\nimport L from 'leaflet';\nexport default class CustomBaseMap extends Map {\ncreateLeafletElement (props: Object): Object {\n    return L.customMap(this.container, props);\n  }\ncomponentDidUpdate (prevProps: Object) {\n    /\n     * Leaflet GeoJSON layers have no concept of z-index. To achieve a similar\n     * effect we use a \"priority\" prop to determine the order in which\n     * \"bringToFront()\" calls are made. This should behave very similarly to z-index.\n     /\n    this.updateLeafletElement(prevProps, this.props);\n    const layers = this.leafletElement._layers;\n    Object.values(layers)\n      .filter((layer) => {\n        return typeof layer.options.priority !== \"undefined\";\n      })\n      .sort((layerA, layerB) => {\n        return layerA.options.priority - layerB.options.priority;\n      })\n      .forEach((layer) => {\n        layer.bringToFront();\n      });\n  }\n}\n```\n. Ok looks like this is kindof a duplicate of https://github.com/PaulLeCam/react-leaflet/issues/488 but that had no satisfying resolution\n@PaulLeCam you say there\n\nWhen creation custom components, you should extend one of the base classes, not one that is meant to be consumed directly\n\nMeaning that to effectively 'extend' TileLayer I actually have to extend GridLayer and then copy/paste the createLeafletElement and updateLeafletElement functions from TileLayer into my custom component.\nThis feels wrong especially given that it means as leaflet and react-leaflet are updated I will need to manually keep my copy/pasted snippets up to date. Consider the use case where I don't want to change the createLeafletElement or updateLeafletElement functions. If all I want to do is add some code to the componentDidMount lifecycle function in TileLayer I would expect that I could do that just like I did in v1.\nUnless I'm fundamentally missing something here this seemingly intended change feels like a major usability and maintainability regression from v1 \u2639\ufe0f \n@PaulLeCam you said in #488 \n\nI don't think it's a good idea to have two GeoJSON exports, it's more confusing than anything.\nIf you want to implement your custom GeoJSON, you can start by copying over the current implementation and change what you need.\n\nHow would you feel about a changing the name of the extendable export so that it's more clear what's going on? Something like this:\n```javascript\nimport { TileLayer as LeafletTileLayer } from 'leaflet'\nimport { withLeaflet } from './context'\nimport GridLayer from './GridLayer'\nimport type { GridLayerProps } from './types'\ntype LeafletElement = LeafletTileLayer\ntype Props = { url: string } & GridLayerProps\nclass TileLayer extends GridLayer {\n  createLeafletElement(props: Props): LeafletElement {\n    return new LeafletTileLayer(props.url, this.getOptions(props))\n  }\nupdateLeafletElement(fromProps: Props, toProps: Props) {\n    super.updateLeafletElement(fromProps, toProps)\n    if (toProps.url !== fromProps.url) {\n      this.leafletElement.setUrl(toProps.url)\n    }\n  }\n}\nexport { TileLayer as ExtendableTileLayer } // ADD THIS LINE!!\nexport default withLeaflet(TileLayer)\n```\nI could update the documentation to describe this behavior and add some example of extending both types of react-leaflet components.. @PaulLeCam I respectfully disagree with your decision.\nFor anyone who finds this issue in the future I have published a fork that lets you extend all components:  https://github.com/jbccollins/react-leaflet-extendable\n. @Jcummings81 That's not really what this issue is about... But if you post a fiddle of your current map implementation using vanilla JS I can take a look. Ok yeah https://jsfiddle.net/q2v7t59h/1942/\nYou're gonna need to extend react-leaflet's Map component and override the createLeafletElement function. I'm not familiar with Wrld but it's possible that you might also need to override the updateLeafletElement function although I think that's unlikely.. ",
    "noblebright": "Looks good to me.  Thanks for the quick turnaround!. ",
    "chexxor": "I'm using an elm-like library, called Pux, which wraps React components. In my code, I pass a single child to Marker, and I verify it is sent to React as a single child, but somewhere it is changed to an Array of one element. I spent hours trying to figure out where this bug lies - my React wrapper, React itself, Leaflet - but I can't figure it out.\nSo, I tried the next-best approach, which is this - changing Marker to accept multiple children.. A Marker is an HTML element. All HTML elements can have multiple children. How is Marker different?\nAlso, the type of Marker's children attribute implies 1 or more nodes, which this patch implements. That furthers my case that this is related to this lib.. Should we change the type of the children attribute to be an instance of Popup, rather than any HTML node? Sounds like this is the only supported value.. Ok, thanks for your consideration. I'll read Leaflet docs, but I hope you add some docs to this lib to clarify how Marker's children works.. ",
    "craigbeck": "I believe this is in reference to tile providers: https://github.com/leaflet-extras/leaflet-providers. ",
    "jetaix": "@Spaxe What do you mean by in my subclass ? . ",
    "caddac": "I don't know how but I fixed this. I'm not really doing anything differently.... That explains why it started working all the sudden when I refactored it. I made the bounds points different. That seems like a weird error for having the bounds be the same value. \nThanks!. ",
    "diegoarcega": "imo it shouldn't throw that error, it wasnt in the previous version.\nit is still a bug :/. Those are already installed @PaulLeCam . @PaulLeCam  all good, sorry it was a problem with cache in CI... thanks!!. ",
    "kylehotchkiss": "+1 i am also getting this error.. ",
    "tedcurrent": "Nevermind. Upon further research, seems like this is a leaflet feature (mentioned in https://github.com/PaulLeCam/react-leaflet/issues/94). Also, what comes to pointer-events: seems to be changeable inline, but the latest TypeScript definitions do not have this included.\nSorry for adding an unnecessary issue.. Tested this and seems to be an issue with interactive only.. Thanks @PaulLeCam it works now! :). ",
    "GibranPolonsky": "`\ncomponentDidMount(){\n        var map = L.map('mapid').fitWorld();\n        L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\n          attribution: '\u00a9 OpenStreetMap contributors'\n        }).addTo(map);\n    }\n\n\n\n\n`. ",
    "pronebird": "My bad it does not seem they are related. I solved problem differently.. ",
    "Shadowman4205": "Thanks for answering, but it s hard for me to implement this  plugin leaflet.curve to react, it is similar to polyline but still i do not understand how reactify it or write plugin.. Which is the relevant section you refer to? I need this fuctionality too. Thank you,but what if i want use both Tooltip and Popup\n<Marker position={[item.lat, item.lng]}>\n              <Popup>\n                    <span>{item.name}</span>\n              </Popup>\n               <Tooltip direction='right' offset={[-8, -2]} opacity={1} permanent>\n                       <span>{item.name}</span>\n                </Tooltip>\n</Marker>\nThis give me error.\nSo i tried this \n<Marker position={[item.lat, item.lng]}>\n            <LayerGroup>\n                   <Popup>\n                          <span>{item.name}</span>\n                    </Popup>\n                     <Tooltip direction='right' offset={[-8, -2]} opacity={1} permanent>\n                           <span>{item.name}</span>\n                       </Tooltip>\n              </LayerGroup>\n</Marker>\nBut i get error Uncaught Error: Unable to find element with ID 210.\nWhen i am using or popup or tooltip only, working fine.\n. Ok i found my mistake, L.curve do not contain setLatLngs.  . ",
    "sedenardi": "Ahhh got it. Thank you for pointing out my mistake.. ",
    "dy2288": "Basically just prefix Leaflet events with 'on', so zoom, becomes onZoom. I believe\n<Map onZoomlevelschange={(e) => { console.log(e); }}> ... </Map> should work.\nThat's what I've been doing with the 'zoom' event.. ",
    "talkhasib": "issue was related to missmatching .css file. ",
    "alterx": "Hey @PaulLeCam , not sure if it's related but I'm seeing some warnings regarding\nDeprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.\nVersions: \n\"leaflet\": \"1.2.0\"\n\"leaflet-routing-machine\": \"3.2.5\". You're right, the root cause is, indeed, inside the leaflet-routing-machine plugin. \nThanks! . ",
    "anvk": "@PaulLeCam thanks a lot for your reply! I tried what you suggested and it worked like a charm. Also I just wanted to mention that you did an outstanding job porting LeafLet to React. Your component works so smooth.\nI have few other questions about the example. I assume that I would need to extend L for any new custom control I want to create (e.g. L.control.myOtherGreatControl). Or I can put all this logic into createLeafletElement() ?\nAlso noticed that code <WatermarkControl position=\"bottomleft\" /> would work. But then controlPosition would not (according to https://github.com/PaulLeCam/react-leaflet/blob/master/docs/API.md#proptypes)\nDo I need to extend componentUnmount() for every component or react-leaflet will take care of that? (once again reading doc here https://github.com/PaulLeCam/react-leaflet/blob/master/docs/How%20it%20works.md#lifecycle-process but not sure if map removes layer for custom components)\nTo be honest I find documentation very dry and cryptic. I re-read it multiple times and tried few different things until wrote a message here. Maybe it is just me, but a separate page even with this example, possibly another very simple example of some custom control counter (or other dynamic changing property on a map) could be so beneficial for anyone who wants to use react-leaflet.\n. Amazing! Thanks a lot for all your help.\nOnce have some extra time will try to submit my ideas for some documentation if they make sense in a PR. ",
    "Eightyplus": "Oh, the same thing occurs with leaflet.\nhttp://jsfiddle.net/friesgaard/d9q9wzwf/. But here I get an 404, which I didn't see when using react-leaflet.\n\n. After updating the map server on our behalf to a higher zoom level, I must conclude it works in leaflet and not in react-leaflet.\nReact-leaflet\nhttps://jsfiddle.net/friesgaard/vfa15L8c/10/\nleaflet\nhttp://jsfiddle.net/vk2m5hha/. _layersMaxZoom is not set eventough maxZoom is set.\n\n. It work when maxZoom={20} is also set on <TileLayer\nhttps://jsfiddle.net/friesgaard/vfa15L8c/11/\nAccording leaflet documentation, setting maxZoom on map \"overrides any maxZoom set on map layers\"...\nhttp://leafletjs.com/reference.html#map-maxzoom\n. Great it helped, took some debugging and guesswork. Your fix has solved the issue.. ",
    "NeoLegends": "I'm also facing this issue here, I'm using react-leaflet v2.1.2. As soon as I zoom to max zoom level the tiles disappear and the img DOM nodes are unmounted. It doesn't matter where I set the max zoom level to, as soon as I hit it, the tiles disappear.\nAny ideas?. This seems to be an issue with leaflet itself. Please see https://github.com/Leaflet/Leaflet/issues/6059 for a workaround.. ",
    "HeeL": "@PaulLeCam yes, thank you, now it's been fixed. ",
    "larpo": "Seems like 70cd9f32bb6 moved the plugin from .babelrc to webpack conf.. ",
    "seanes": "I ran into the same issue when bumping version of babel-cliand babel-coreand am curious as to the cause is related. v. 1.1.2, cf.\nSeems like some functions are missing. Ultimately rendering removeLayerControl is not a function\nEdit: I tried with an older version of babel-cliand babel-core and it did not seem to have an impact. \nI also can verify that this is breaking after upgrading from 1.1.1 to 1.1.2. ",
    "zdila": "Thanks. With 1.1.3 it works correctly.. ",
    "Ognian": "Sorry, understood this https://github.com/PaulLeCam/react-leaflet/issues/45\nto late, therefore I'm closing this issue. I understand that this will not change soon.... ",
    "petervojtek": "hmm, now I see the setOpacity is called in super-class. I Will have to double check my code, as it is more likely that is where the issue can be.. ok, so it seems the root of issue may be the same as was in #151, i.e. that TileLayer .updateLeafletElement is missing something like this: super.updateLeafletElement(fromProps, toProps); and thus the GridLayer.setOpacity is not executed.. thanks, I confirm 1.1.4 fixed this issue. ",
    "mikew": "Quite shifty changing this in a bugfix release. ",
    "rcwestlake": "@YUzhva. Thanks for this. I'll give it a shot later today or tomorrow. . This resolved the issue. I needed to add an explicit iconSize and iconAnchor. Thanks @YUzhva. I'll close this issue. . ",
    "fastlorenzo": "Hi Paul,\nI installed it via npm and received the following error while using geojson: GeoJSON is not a function. After changing the call to GeoJson it worked.\nI'll check the version of leaflet when I'm back home and update the thread.\nLorenzo Bernardi\n\nOn 3 Apr 2017, at 08:31, Paul Le Cam notifications@github.com wrote:\nClosed #307.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I checked and the leaflet package (that was installed by another package) was indeed outdated. \nSorry for the convenience and thanks for that great package! . \n",
    "awinograd": "The CI seems to be failing for non PR related reasons. Thanks @paullecam! Hope it's helpful to others as well . another option would be to do:\nif (typeof props[ prop ] === 'function'). ",
    "tharakawj": "This will be helpful to anyone who encountered this issue. http://stackoverflow.com/questions/43465480/react-router-link-doesnt-work-with-leafletjs/43594791. ",
    "dragGH102": "@PaulLeCam @tharakawj that fix applies only to v4 apparently and <MemoryRouter>  is not even available in v3 (which I'm using).\nAny clue?\n\nUncaught Error: Links rendered outside of a router context cannot navigate.\n\nwhen clicking on Link @\n      <Popup>\n        <span>\n          <Link to=\"/\">test link</Link>\n        </span>\n      </Popup>\n\n. @awjreynolds how did you got that working?\nIf I try:\n```\nimport { Map } from 'react-leaflet';\nimport L from 'leaflet';\n\n```\nthe map is shown as gray and I get a lot of errors in console:\nUncaught TypeError: Cannot read property 'x' of undefined\n    at Point._add (reactBoilerplateDeps.dll.js:88974)\n    at Point.add (reactBoilerplateDeps.dll.js:88969)\n    at NewClass.layerPointToLatLng (reactBoilerplateDeps.dll.js:92083)\n    at NewClass._fireDOMEvent (reactBoilerplateDeps.dll.js:92503)\n    at NewClass._handleDOMEvent (reactBoilerplateDeps.dll.js:92464)\n    at HTMLDivElement.handler (reactBoilerplateDeps.dll.js:90467). ",
    "awjreynolds": "The Map component properties does not include csr. Happy to put together a pull request once I've got this working in my project. \nexport default class Map extends MapComponent {\n  static propTypes = {\n    animate: PropTypes.bool,\n    bounds: boundsType,\n    boundsOptions: PropTypes.object,\n    center: latlngType,\n    children: childrenType,\n    className: PropTypes.string,\n    id: PropTypes.string,\n    maxBounds: boundsType,\n    maxZoom: PropTypes.number,\n    minZoom: PropTypes.number,\n    style: PropTypes.object,\n    useFlyTo: PropTypes.bool,\n    zoom: PropTypes.number,\n  }. In that case that makes a lot of sense. Thank you for your feedback. I'll close this.. @allthesignals It has to do with putting everything into a Layergroup. It's not very clear from the example. I can post code tomorrow. When I have time I'll put a pull request in on the example show map usage within LayerControl.. @allthesignals Hope this helps\n```  renderInterfaceLoop (interfaceLoop) {\n    return (\n      !interfaceLoop.devices || !interfaceLoop.devices.length\n        ? null\n        : \n\n            { this.renderDeviceMarker(interfaceLoop) }\n            { _.map(interfaceLoop.devices, this.renderDeviceMarker) }\n            { interfaceLoop.links.map(this.renderDeviceLink) }\n          \n\n    );\n  }\nrender () {\n    const bounds = [[0, 0], [520, 1024]];\n    const _props = isOnDevice()\n      ? {\n        ref: 'loopmap',\n        crs: Leaflet.CRS.Simple,\n        bounds: bounds,\n        dragging: false,\n        doubleClickZoom: false,\n        maxBounds: bounds,\n        zoomControl: false,\n        scrollWheelZoom: false\n      }\n      : {\n        ref: 'loopmap',\n        crs: Leaflet.CRS.Simple,\n        bounds: bounds,\n        dragging: true,\n        doubleClickZoom: true,\n        maxBounds: bounds,\n        zoomControl: true,\n        scrollWheelZoom: true\n      };\nreturn (\n  <div className='loop-map' >\n    <Map { ..._props } >\n      <LayersControl position='topright'>\n        <BaseLayer checked name='Site Map'>\n          <ImageOverlay url='/images/Rotork_Default_Map.jpg' bounds={ bounds } interactive={ false } />\n        </BaseLayer>\n        { this.props.interfaces ? _.map(this.props.interfaces, this.renderInterfaceLoop) : null }\n      </LayersControl>\n    </Map>\n  </div>\n);\n\n}\n```. ",
    "dchambers": "Ah, yes, so I was looking at this:\nhttps://github.com/PaulLeCam/react-leaflet/blob/master/docs/Components.md#marker\n. ",
    "bardiaombre": "@stereobooster on your mapbox-gl, i cannot access childrenType  as of react-leaflet 1.1. any solution to how to fix it.\n\n. ",
    "allthesignals": "@awjreynolds were you able to get anywhere on this? I'm having the same issue. Not sure if it has something to do with the map properties types? https://github.com/PaulLeCam/react-leaflet/blob/master/example/components/custom-component.js\nIn the example, it sets up prop types, but not sure where the documentation for that is.\nThanks!. Thank you! \nI wrote a separate ReactClass and use it in the render() of the parent component... I was confused who to get passed props to update, but this seems to work fine. \nconst PointsMap = ({ position, zoom, points, center }) => {\n  return (\n      <Map center={center} zoom={zoom}>\n        <TileLayer\n          attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n          url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n        />\n        {\n          points.map((point, index) => \n          <Marker position={[point.lat, point.lng]} key={index}>\n          </Marker>\n        )}\n      </Map>)\n}. ",
    "vietnugent": "I'm facing similar error after upgrading react-leaflet 1.14 ->1.6.6, react 15.4.2->15.6.1.  Still debugging...\n```\n const foo = ;\n\n\n\n       //{ null } : ok\n      // {[foo]} : error\n    \n\n\n```\nUncaught Error: LayerGroup.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.. To reproduce click the first button -> second -> first.  Then check layer control.\nhttps://www.webpackbin.com/bins/-KvBfuAhP4myQjGEpKs7. ",
    "sixertoy": "Hey, same here and different behaviors\nIn my case i've got a backoffice managin many \"graphical maps\" with differents datas under a single react-leaflet component.\nI've observed that a\n<LayersControl.Overlay checked key={`layerscontrol-${key}`} name={key}>\n    <LayerGroup>{parsegroups[key] || null}</LayerGroup>\n</LayersControl.Overlay>\nthrows when parsegroups[key] (array) contains only one item. @omrivardi have you tried with <React.Fragment> instead of <div> ?. ",
    "omrivardi": "had a similar problem. \nSolved but inserting a div in between:\n<LayerGroup>\n   <div>\n    {layerJsx} // an array of jsx elements\n  </div>\n</LayerGroup>. ",
    "draganSm": "@stereobooster I've managed to open the popup with the following code (just the prototype):\n~~~\nconst targets = targetList.map(target => (\n      \n !target.valid && setTimeout(() => x(ref, [target.lat, target.lng]))}>\n          \n\n));\n~~~\n~~~\nfunction x(ref, pos) {\n  ref.context.map.openPopup(ref.leafletElement, pos);\n}\n~~~\nI know ... setTimeout in reder... Didn't find a better implementation yet.\n. I've managed to find a \"workaround\" but the solution is far from the production code:\n```\nimport React, { Component } from 'react';\nimport { render, unmountComponentAtNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { CircleMarker, Map as LeafletMap, Marker, Polygon, Popup, Tooltip, WMSTileLayer } from 'react-leaflet';\nimport L from 'leaflet';\nimport inside from 'point-in-polygon';\nimport MapMask from './MapMask';\nimport styles from './Map.less';\nclass Map extends Component {\n  componentDidMount() {\n    this.element = this.ref.leafletElement;\n  }\nhandleClick(e) {\n    const point = e.latlng;\n    const { handleMapClick, mask } = this.props;\n    if (inside([point.lat, point.lng], mask) && handleMapClick) {\n      handleMapClick(e.latlng.lat, e.latlng.lng);\n    }\n  }\nrender() {\n    const { children, className, layers, markerPosition, mask, // markerPosition comes from the store\n      maxLat, maxLong, minLat, minLong, minZoom, targets, url } = this.props;\n    const polygon = L.polygon(mask);\n    const areaBounds = polygon.getBounds();\n    if (markerPosition) {\n      const popup = L.popup()\n      .setLatLng(markerPosition)\n      .setContent('')\n      .openOn(this.element);\n      setImmediate(() => {\n        this.popup = popup;\n        render({children}, this.popup._contentNode);\n        // this.popup.update();\n        this.popup._updateLayout(); // I know ... it's private\n        this.popup._updatePosition();\n      });\n    } else if (this.popup) {\n      setImmediate(() => {\n        unmountComponentAtNode(this.popup._contentNode);\n        this.popup.remove();\n        this.popup = null;\n      });\n    }\n    // const marker = markerPosition\n    //   ? (\n    //     \n    //       {children}\n    //     \n    //   )\n    //   : null;\n    const marker = null;\n    const dots = targets.map(items => (\n      \n\n{items.target.name}\n\n\n{items.target.name}\n\n));\n    return ( this.handleClick(e)}\n      ref={(ref) => { this.ref = ref; }}\n    >\n      \n\n\n      {marker}\n      {dots}\n    );\n  }\n}\n```\nIs there any way to avoid the async setImmediate method?. ",
    "pvhieuit": "I found this in jsfiddle\n```javascript\n// Create your own class, extending from the Marker class.\nclass ExtendedMarker extends Marker {\n  // \"Hijack\" the component lifecycle.\n  componentDidMount() {\n    // Call the Marker class componentDidMount (to make sure everything behaves as normal)\n    super.componentDidMount();\n// Access the marker element and open the popup.\nthis.leafletElement.openPopup();\n\n}\n}\n`````\njavascript\n  render() {\n    const position = [this.state.lat, this.state.lng];\n    return (\n      <Map center={position} zoom={this.state.zoom}>\n        <TileLayer\n          attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n          url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n        />\n        <ExtendedMarker position={position}>\n          <Popup>\n            <span>A pretty CSS3 popup. <br/> Easily customizable.</span>\n          </Popup>\n        </ExtendedMarker>\n      </Map>\n    );\n  }. ",
    "pans0911": "i think i have the same error,if i change one of the array,the polygon will not change ,if i delete or add one in the array,the poloygon will change.\nthe way my  is \n                        `\n\nlet newPoints = this.state.points;\nlet firstPoints = this.state.points;\nfirstPoints = firstPoints.splice(this.state.pointIndex, 1, point[0]);\nnewPoints[this.state.pointIndex] = point[0];\n//TODO \u6570\u636e\u95ee\u9898 https://github.com/PaulLeCam/react-leaflet/issues/319\n//\u6ca1\u529e\u6cd5\uff0c\u5e95\u5c42\u7684object\u5bf9\u6bd4\u6709\u95ee\u9898\nthis.setState({\npoints: firstPoints,\n});\nsetTimeout(() => {\nthis.setState({\npoints: newPoints,\ndrawStatus: true,\nchangePoints: [],\n})\n}, 100)\n\n`. @PaulLeCam thank you, i solve it.\njs\ngetNewPoints(Points, Index, point) {\n    let arr = [];\n    Points.map((item, index) => {\n        if (index !== Index) {\n            arr.push(item)\n        } else {\n            arr.push(point)\n        }\n    });\n    return arr\n}\njs\nlet newPoints = this.getNewPoints(this.state.points, this.state.pointIndex, point[0]);\nthis.setState({\n    points: newPoints,\n}). ",
    "resson-ntranquilla": "@PaulLeCam , yes I can confirm that I was mutating the array, not passing a new one.. Was able to determine that the bug was in my code.. ",
    "stunningpixels": "Getting this too. @neeraj022 make sure you include the leaflet CSS file and give the map height, <link rel=\"stylesheet\" href=\"http://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.css\"> fixed it for me. ",
    "neeraj022": "Thanks...working for me now.. Didn't include leaflet.css in the css file. . ",
    "Roconda": "How did you fix this @neeraj022 ?. ",
    "ggwc82": "@Roconda you need to add that link rel to your index.html, and also make sure you have this in your index.css:\n.leaflet-container {\n    height: 400px;\n    width: 100%;\n}\nI spent the better half of a day trying to figure out what my issue was, @PaulLeCam the instructions need to be clearer to make sure you include the leaflet.css file.. ",
    "hqzh": "import 'leaflet/dist/leaflet.css';. ",
    "DirtyHairy": "Thanks alot for the quick merge :smile:. ",
    "markhepburn": "Ok, that works for me too, thanks for your prompt response.. Looks great, thanks for your prompt response!. PR incoming.\n(First thing I noticed was \"404\" in the URL and thought \"crap, has my ticket just been lost?\" :)). Looks great, thanks.. ",
    "resetko": "@PaulLeCam Can you suggest how to achieve desired behavior? . ",
    "rsancheza09": "@PaulLeCam do you have a simple example of how can we implement your suggestion?\nThanks. Thanks man. I did something like that. But in my case it is not working. I sent you by twitter a piece of code.\nRegards. ",
    "TroySchmidt": "I think this probably revolves around an issue I am seeing.  If I add a bunch of geoJSON objects to the map then if the timing is off on when it is bring up and setting the zoom and animation to the tiled baselayer, it will be in the wrong location.  Then once I zoom out and back in it is shown in the right location. \n. +1 For using Storybook to push to a static site.  Also, the project MaterialUI has a very good site with example demos + API setup.  It is good that the documentation is building off the source code so as the code updates the API documentation site updates from that and then demo examples are added adhoc.. ",
    "alexrussell": "@PaulLeCam I think this is actually an issue with react-leaflet rather than leaflet. That said, it's kind of a limitation caused by React/JS itself. The issue here is that 're-setting' the centre or the bounds, etc. to the same value that they already have won't 'force' the map to re-centre (say, if it's been moved by the user in the intervening time). This is because passing these scalars into react-leaflet (even as part of an array) doesn't register as changed values, and so the map doesn't re-render, as it is not the prop itself that is checked against the previous value, but the lat/lng after transformation are checked separately. (See here.)\nThe way I have seen it done before (maybe in a Mapbox React lib (yes - see disclaimer paragraph here and its corresponding issue) is to only check the lat/lng having changed by object reference, rather than checking for lat and lng having changed separately. For values that are just scalar, like zoom, if the value is sent in as an array containing one value (icky, I know) then the array can be checked for having changed by reference.\nObviously, because react-leaflet is tied into Leaflet, we can't just use an array for lat/lng, as it can also accept a LatLng object, but the principle is the same - just check object reference equality against the previous prop.\nAlso obviously, this will come at a perf/usability cost for people who don't know that that's how this works - if they \"generate\" a LatLng object or an array for the center prop in their render method, it'll be different each time and so the map will update and force re-centre. Obviously the idea would be to store the lat/lng object or array in the composing component's state so that you pas the same reference each time. But maybe that's too complex for the more novice users, I dunno.. @ayozebarrera remember to remove them on componentWillUnmount - I dunno how required it is with Leaflet, but it's just good practice to always remove any event listeners you set on componentDidMount in componentWillUnmount.. @PaulLeCam ahh this looks cool. I'll check it out, thanks.. ",
    "qrohlf": "@PaulLeCam I'm not sure how this isn't a bug in the library - leaflet itself doesn't exhibit this behavior, I've included reproduction steps, and it seems like a pretty clear mechanic that one of the methods that <Popup /> or <Marker /> is calling in componentDidUpdate is causing Leaflet to re-do the map layout stuff when it shouldn't. \nI can investigate this myself if you don't have time, but I'm not sure why you closed the issue without explaining why this isn't a bug in react-leaflet. . @PaulLeCam I have confirmed that vanilla Leaflet dos not exhibit this behavior, meaning this is a possible bug in the library. I'd appreciate it if you could re-open this issue.. @mjclawar That makes sense, it looks like this is an issue with leaflet itself: https://github.com/Leaflet/Leaflet/issues/2937. My mistake.\nI'm opening an issue with leaflet since I believe this is undesired behavior (the popup should auto-pan when opened, but adding or removing sibling markers shouldn't re-trigger a popup to pan into view when the user isn't interacting with it at all).. ",
    "mjclawar": "@qrohlf Looks like the actual argument that prevents it from panning for your example is autoPan. This defaults to true.\nkeepInView just forces the popup to stay in the map view.\nIf you add autoPan={false} to the first Popup component in your example, you'll get the intended behavior.\nIf you set keepInView={true} with no autoPan argument in the first Popup component in your example, you won't be able to move the map.. ",
    "EvertLagerberg": "@PaulLeCam Sorry about that. I updated the jsfiddle.. @PaulLeCam Would you consider opening this ticket again?. Could this be a related issue: https://github.com/Leaflet/Leaflet/issues/5310 ?. ",
    "rouzbeh": "I have encountered this problem. For some reason, moving the map via touch (as opposed to mouse on desktop or remote adb) triggers the moveend event a lot of times instead of just once. I am not sure why this happens, or even if it is due to react-leaflet.\nEDIT: For me, on the JSfiddle, moving a map on android a few times does trigger the bug.. My best guess about what happens is: \n1- The map is moved\n2- setState is called and causes the component to re-render\n3- The re-rendering somehow causes the moveend event to be called again\n4- Goto 1\nAnd we overflow the stack on mobile devices. For some reason, this does not happen on desktop (chrome on mac).. ",
    "kimmobrunfeldt": "I can confirm this is still reproducible with latest master. Chrome 47.0.2526.83, Android 4.2.2, Samsung SM-G3500 model. Trying to debug why it happens.. I'm not sure if this fixed it, but I noticed that we were using onMoveEnd attribute for the Map element instead of onViewportChanged. Now that I changed to use onViewportChanged, it can't seem to get the error again. However I'm not 100% sure if this really worked, since it was sometimes hard to reproduce. Time will tell in our Sentry.io if we stop getting \"Maximum call stack size exceeded\" errors. . ",
    "borisrorsvort": "@PaulLeCam I feel that since react-leaflet is trying to wrap leaflet in a react way, it should update (and do what needs to be done internally) on props change, including dimensions. We should probably not have to touch the leaflet internals for this.. ",
    "arnauorriols": "\nThis is out of the scope of this library, it's up to your application to handle this.\n :-1: 1\n\nI need to express my discontent with this. I second @borisrorsvort opinion that this is indeed a responsibility of this library. Maybe not the whole React community shares these design principles, but I'm 100% sure I'm not alone in thinking that using refs is an anti-pattern. React components should try as much as possible to maintain the declarative philosophy of React.. ",
    "billscheidel": "I'm sure something is going on, but I can't track it down.  Is there any other way to get the underlying Leaflet object?  Without the Leaflet object I can't invalidate the size properly, get visible markers, etc.. Not sure why, but the callback version of ref works while the string version throws the error.. ",
    "andersodt": "Great! Looks like it's working well for me. Thank you for fixing this so quickly, and thank you for your work on this project.. ",
    "mhyassin": "This isn't working again for some reason!. ",
    "gmarcos87": "It's not all lodash but it's a lot, you can see in this repository a replica of the dependencies. The total weight of the bundle is 36kb.. ",
    "corneliusgdahling": "Did you even read the issue? flyTofrom leaflet works just as expected. useFlyTo prop from react-leaflet however does not use the leaflet flyTo animation. That is the whole point. Working implementation where I use .flyTo directly on an instance of the leaflet map. However, when I try something similar but just using the useFlyTo prop in react-leaflet it does not work, as you can see here.. ",
    "SleipRecx": "@corneliusgdahling Yo go girl !!. ",
    "valstu": "If I would like to make some property dynamic lets say minNativeZoom on TileLayer dynamic what would be the best approach to that?. ",
    "jahed": "@valstu extend the component and implement it yourself by overriding updateLeafletElement or fork the project and apply the fix directly. I've taken the former approach, it's relatively straight forward. The difficult part is remembering which props are already dynamic and which aren't.. I understand the previous response on this ticket:\nhttps://github.com/PaulLeCam/react-leaflet/issues/94\nHowever, className is a very standard prop in React, so not supporting the same behaviour in React and going the route Leaflet has taken, IMO is extremely confusing and frustrating when debugging this library among other standard React components.\nIf the plan really is to not implement this, I suggest leaving a warning somewhere obvious in the documentation. Possibly under the Vector Layers section.. For anyone who's looking for a quick fix, just extend the individual components as needed. It may be flaky in certain circumstances, but so far it's worked fine for me:\n```js\nimport { Polygon as LeafletPolygon } from 'react-leaflet'\nimport { difference } from 'lodash'\nexport default class Polygon extends LeafletPolygon {\n    updateLeafletElement(fromProps, toProps) {\n        super.updateLeafletElement(fromProps, toProps)\n    if (toProps.className !== fromProps.className) {\n        const fromClasses = fromProps.className.split(' ')\n        const toClasses = toProps.className.split(' ')\n        this.leafletElement._path.classList.remove(...difference(fromClasses, toClasses))\n        this.leafletElement._path.classList.add(...difference(toClasses, fromClasses))\n    }\n}\n\n}\n```. ",
    "aproberts01": "Any resolution? I am having the same issue. . ",
    "0x80": "Never mind. I found the documentation about the events. https://github.com/PaulLeCam/react-leaflet/blob/master/docs/API.md \nonMouseover fires \ud83d\udc4d . ",
    "quesurifn": "@PaulLeCam Can you give an example? I looked at that and couldn't get it to work? \n```\nconst image = {\n                iconUrl: require('../public/marker-icon.png'),\n                shadowUrl: require('../public/marker-shadow.png'),\n                iconSize:     [38, 95], // size of the icon\n                shadowSize:   [50, 64], // size of the shadow\n                iconAnchor:   [22, 94], // point of the icon which will correspond to marker's location\n                shadowAnchor: [4, 62],  // the same for the shadow\n                popupAnchor:  [-3, -76]// point from which the popup should open relative to the iconAnchor\n            }\n    const markers = this.props.locations.map((e, index) => (\n        <Marker key={index} position={[e.lat, e.lng]} icon={image} />\n    ));\n\n```. ",
    "evo3cx": "i have a same problem and this my solution, thanks @PaulLeCam  for insight \n```\nimport Leaflet from 'leaflet'\nconst image = Leaflet.Icon({\n               iconUrl: require('../public/marker-icon.png'),\n               shadowUrl: require('../public/marker-shadow.png'),\n               iconSize:     [38, 95], // size of the icon\n               shadowSize:   [50, 64], // size of the shadow\n               iconAnchor:   [22, 94], // point of the icon which will correspond to marker's location\n               shadowAnchor: [4, 62],  // the same for the shadow\n               popupAnchor:  [-3, -76]// point from which the popup should open relative to the iconAnchor\n           })\n```\n. ",
    "joeferraro": "@evo3cx I had to use new Leaflet.Icon. ",
    "HsiehYuho": "\nnew Leaflet.Icon\n@joeferraro Thank you so much!! \n. https://codepen.io/anon/pen/mQRYPK\n\nI think it is the version of React. (I change the version of React to 16.3.0 and React-Dom 16.3.3)\nBecause my project is not compatible with the newest version of React. \nYou may update the minimum required version of React. :)\nI am not sure why the context is not created. :( \n. It seems work with v16.3.1! Thank you :) . ",
    "11samype": "Sorry about that. I have updated my comment.\nhttps://www.webpackbin.com/bins/-KrBZ-3qiOr0SMun_B-K\n. I'll try one more time: https://www.webpackbin.com/bins/-KrGeo-xgj73pzuZdDBU\nI really want to get this example to work. Even if it is an issue on my end I would appreciate a pointer. Would love to use this lib.. Nevermind, found my issue.. ",
    "NekitoSP": "I expect this behavior because changing props is part of React lifecycle. And what this wrapper (react-leaflet) about.\nGetting started.md\n\nIt does not replace Leaflet, only leverages React's lifecycle methods to call the relevant Leaflet handlers.. Thanks!. \n",
    "tusbar": "See #359 . @PaulLeCam thank you for your fast input on this.\nRegarding lib and dist in the repository, if you believe that it is in the scope of this PR, I would be happy to remove it. :)\nConcerning babel-runtime, I have been trying to read as much as possible on the matter, and I don\u2019t see it anywhere being used in react component libraries (react-router-dom, redux, react-redux, react-intl, react-i18next, etc.)\nAs far as I understand, babel-transform-babel-runtime gets rid of all the helpers generated on a per-module basis and uses the ones defined in babel-runtime (which gets aliased as core-js). It also adds scoped polyfills for Set, Map, Symbol, Promise, etc., and none seem to be used in react-leaflet. It will also include the regenerator runtime when using generators or async functions, which is not the case in react-leaflet.\nSo I am not sure it\u2019s even needed for the commonjs build. The output seems lighter with babel-runtime but it requires about 6.5KB gzipped of babel-runtime.\nAs for the es/jsnext build, the idea is to expose the same transpiled code, without transforming the import/exports.. So I\u2019ve removed babel-transform-runtime as I do not believe that it is necessary (I\u2019ll revert if you tell me otherwise).\nI\u2019ve made sure that all babel configuration lies in .babelrc (umd configuration was duplicated in webpack.babel.config) \u2013\u00a0which required the webpack configuration to stop using es6 modules.\nAnd I\u2019ve enabled scope hoisting for the umd build (that removes unnecessary closures) to lighten the umd builds.. @PaulLeCam I have removed the generated code from the repository and switched the umd build to use rollup. (Yeah I thought about doing that, but thought it would be too much for this PR \u2013\u00a0I already had the rollup config lying around \ud83d\ude04). The rollup build is much lighter than the current build of webpack.\nBefore, with webpack:\n$ ll dist\ntotal 688\n-rw-r--r--  1 tusbar  staff   263K Aug 16 21:30 react-leaflet.js\n-rw-r--r--  1 tusbar  staff    77K Aug 16 21:30 react-leaflet.min.js\nAfter, with rollup (and lodash-es):\n$ ll dist\ntotal 504\n-rw-r--r--  1 tusbar  staff   192K Aug 16 21:31 react-leaflet.js\n-rw-r--r--  1 tusbar  staff    50K Aug 16 21:31 react-leaflet.min.js\nRegarding lodash and lodash-es, I\u2019m all for it.. Ok, I\u2019ve cleaned up the commits and moved everything in order.\nLet me know if everything is here. \nTo ease the review, the first commit only removes all the generated code (and updates .{git,npm}ignore), everything else happens in the last 3 commits. :). Thank you for merging this is @PaulLeCam!\nWill you create a new release for it? :). @PaulLeCam done. :). Yeah, the syntax error is definitely due to the node version. Though it is fixable: #376.. Random thought: what could be nice is to have the UMD bundles be available as release downloads (automatically added by the CI), so we don\u2019t have to let the users build their own UMD builds (and we can get rid of node 6 ;))\nI\u2019ve done something like that in the past: https://github.com/armateam/extension/releases, generated by https://github.com/armateam/extension/blob/master/circle.yml#L40-L42.. ",
    "diligiant": "it does. Thank you!. Yes, that will do (that's close to plugin example)\nimport type { LatLng, Layer } from 'leaflet' => /*:: import type { LatLng, Layer } from 'leaflet';*/.\nBut import { type LatLng, type Layer } from 'leaflet' won't as expected.. @PaulLeCam, I got an answer to my issue and hzoo suggests to hold off using this plugin (\"pretty buggy\") and place the flow syntax into a .js.flow file.. @WaNgeL-SaTaR looks like an npm cache \"issue\". Can you retry and if it doesn't work check what npm view react-leaflet says?\nLast version should be 1.6.3 (should = is for us). @WaNgeL-SaTaR npm web site lists the right package version so I guess the problem is on your side (and I have no idea how to fix this.). Found the explanation:\nlint default is all=off, therefore the message I get as, unlike you, I didn't change lint settings (I didn't have this section - old config).\nYou're probably on the right side of history ;)\nAdding\n[lints]\nall=warn\nfixes the problem (to whom it may concern\u2026). Does leaflet behave like you expect if you use it directly?. ",
    "ulrichSchreiner": "hi,\nsame problem in LayersControl.js \n~~~\nimport React, { cloneElement, Component, Children, /:: type ChildrenArray/, /:: type Element/ } from 'react';\n~~~\nand Map.js:\n~~~\nimport { latLngBounds, DomUtil, Map as LeafletMap, /:: type CRS/, /:: type Renderer/ } from 'leaflet';\n~~~\nthere are always 2 hanging commas.. ",
    "Drusy": "It's now working using v1.6.3, thx @PaulLeCam !. ",
    "WaNgeL-SaTaR": "npm i react-leaflet@1.6.3, \u0441auses\nnpm ERR! code ETARGET\nnpm ERR! notarget No matching version found for react-leaflet@1.6.3\nnpm ERR! notarget In most cases you or one of your dependencies are requesting\nnpm ERR! notarget a package version that doesn't exist.. Last version: '1.6.2': \n```\n$: npm view react-leaflet\n{ maintainers: [ 'paul_lecam paul@ulem.net' ],\n  keywords: [ 'react-component', 'react', 'leaflet', 'map' ],\n  'dist-tags': { latest: '1.6.2', next: '1.0.0-rc.3' },\n  author: 'Paul Le Cam paul@ulem.net',\n  description: 'React components for Leaflet maps',\n  repository: \n   { type: 'git',\n     url: 'git+https://github.com/PaulLeCam/react-leaflet.git' },\n  users: { markthethomas: true, smoojitter: true, uptonking: true },\n  bugs: { url: 'https://github.com/PaulLeCam/react-leaflet/issues' },\n  license: 'MIT',\n  versions: \n   [ '0.1.0-dev',\n     '0.2.0-dev',\n     '0.2.0',\n     '0.2.1',\n     '0.2.2',\n     '0.3.0',\n     '0.4.0-beta.1',\n     '0.4.0-rc.1',\n     '0.4.0',\n     '0.4.1',\n     '0.5.0',\n     '0.6.0',\n     '0.6.1',\n     '0.6.2',\n     '0.7.0',\n     '0.8.0-rc.1',\n     '0.8.0-rc.2',\n     '0.8.0-rc.3',\n     '0.8.0',\n     '0.8.1',\n     '0.9.0',\n     '0.10.0',\n     '0.10.1',\n     '0.10.2',\n     '0.11.0',\n     '0.11.1',\n     '0.11.2',\n     '0.11.3',\n     '0.11.4',\n     '0.11.5',\n     '0.11.6',\n     '0.11.7',\n     '0.12.0',\n     '0.12.1',\n     '0.12.2',\n     '0.12.3',\n     '1.0.0-beta.1',\n     '1.0.0-beta.2',\n     '1.0.0-beta.3',\n     '1.0.0-rc.1',\n     '1.0.0-rc.2',\n     '1.0.0-rc.3',\n     '1.0.0',\n     '1.0.1',\n     '1.0.2',\n     '1.0.3',\n     '1.1.0',\n     '1.1.1',\n     '1.1.2',\n     '1.1.3',\n     '1.1.4',\n     '1.1.5',\n     '1.1.6',\n     '1.1.7',\n     '1.2.0',\n     '1.2.1',\n     '1.2.2',\n     '1.3.0',\n     '1.3.1',\n     '1.4.0',\n     '1.4.1',\n     '1.5.0',\n     '1.6.0',\n     '1.6.1',\n     '1.6.2' ],\n  name: 'react-leaflet',\n  time: \n   { modified: '2017-08-21T13:51:52.546Z',\n     created: '2014-10-18T09:36:59.076Z',\n     '0.1.0-dev': '2014-10-18T09:36:59.076Z',\n     '0.2.0-dev': '2014-11-17T07:39:12.504Z',\n     '0.2.0': '2014-11-30T11:15:43.628Z',\n     '0.2.1': '2014-12-01T21:49:44.502Z',\n     '0.2.2': '2015-01-14T08:00:25.415Z',\n     '0.3.0': '2015-01-21T20:23:57.125Z',\n     '0.4.0-beta.1': '2015-03-08T19:07:51.786Z',\n     '0.4.0-rc.1': '2015-03-11T09:17:08.291Z',\n     '0.4.0': '2015-03-28T14:34:42.237Z',\n     '0.4.1': '2015-04-06T09:20:24.407Z',\n     '0.5.0': '2015-05-02T16:39:22.571Z',\n     '0.6.0': '2015-05-18T22:31:58.273Z',\n     '0.6.1': '2015-05-22T07:43:11.061Z',\n     '0.6.2': '2015-06-14T09:43:32.901Z',\n     '0.7.0': '2015-09-08T20:09:41.991Z',\n     '0.8.0-rc.1': '2015-09-16T07:27:05.866Z',\n     '0.8.0-rc.2': '2015-09-22T07:31:46.335Z',\n     '0.8.0-rc.3': '2015-09-29T07:40:23.170Z',\n     '0.8.0': '2015-10-07T22:31:21.197Z',\n     '0.8.1': '2015-10-21T20:19:27.178Z',\n     '0.9.0': '2015-11-12T22:57:29.876Z',\n     '0.10.0': '2015-12-22T11:50:38.822Z',\n     '0.10.1': '2016-02-22T23:24:58.265Z',\n     '0.10.2': '2016-03-12T15:34:33.445Z',\n     '0.11.0': '2016-04-09T14:52:06.655Z',\n     '0.11.1': '2016-04-17T09:25:28.520Z',\n     '0.11.2': '2016-04-25T07:17:07.333Z',\n     '0.11.3': '2016-04-28T19:20:13.753Z',\n     '0.11.4': '2016-05-05T07:21:54.401Z',\n     '0.11.5': '2016-05-14T10:53:34.200Z',\n     '0.11.6': '2016-06-09T22:30:04.553Z',\n     '0.11.7': '2016-06-14T22:03:07.131Z',\n     '0.12.0': '2016-06-25T09:46:10.073Z',\n     '0.12.1': '2016-07-08T07:44:02.603Z',\n     '1.0.0-beta.1': '2016-07-30T09:08:18.337Z',\n     '1.0.0-beta.2': '2016-08-20T09:22:53.519Z',\n     '1.0.0-beta.3': '2016-08-26T07:20:44.252Z',\n     '0.12.2': '2016-09-09T06:51:09.771Z',\n     '0.12.3': '2016-09-21T20:32:24.501Z',\n     '1.0.0-rc.1': '2016-09-28T07:02:19.065Z',\n     '1.0.0-rc.2': '2016-10-20T20:54:33.993Z',\n     '1.0.0-rc.3': '2016-11-04T08:03:16.023Z',\n     '1.0.0': '2016-11-14T22:33:36.390Z',\n     '1.0.1': '2016-11-26T10:27:43.808Z',\n     '1.0.2': '2016-12-19T01:11:48.597Z',\n     '1.0.3': '2017-01-07T10:38:33.156Z',\n     '1.1.0': '2017-01-11T22:47:20.961Z',\n     '1.1.1': '2017-03-07T00:01:18.679Z',\n     '1.1.2': '2017-03-14T08:02:58.877Z',\n     '1.1.3': '2017-03-15T19:09:15.164Z',\n     '1.1.4': '2017-03-22T07:51:03.028Z',\n     '1.1.5': '2017-04-05T07:29:06.953Z',\n     '1.1.6': '2017-04-10T07:47:37.873Z',\n     '1.1.7': '2017-05-20T10:14:42.843Z',\n     '1.2.0': '2017-05-24T08:22:58.928Z',\n     '1.2.1': '2017-06-01T21:26:38.008Z',\n     '1.2.2': '2017-06-07T07:28:18.941Z',\n     '1.3.0': '2017-06-11T10:03:10.056Z',\n     '1.3.1': '2017-06-20T22:45:05.239Z',\n     '1.4.0': '2017-06-28T19:57:28.566Z',\n     '1.4.1': '2017-07-25T07:11:11.051Z',\n     '1.5.0': '2017-08-10T07:30:53.141Z',\n     '1.6.0': '2017-08-20T14:13:14.119Z',\n     '1.6.1': '2017-08-20T20:26:49.533Z',\n     '1.6.2': '2017-08-21T07:32:34.183Z' },\n  readmeFilename: 'README.md',\n  homepage: 'https://github.com/PaulLeCam/react-leaflet',\n  version: '1.6.2',\n  main: 'lib/index.js',\n  module: 'es/index.js',\n  'jsnext:main': 'es/index.js',\n  scripts: \n   { clean: 'rimraf lib es dist',\n     'build:cjs': 'babel src --out-dir lib',\n     'build:es': 'cross-env BABEL_ENV=jsnext babel src --out-dir es',\n     'build:umd': 'cross-env BABEL_ENV=rollup NODE_ENV=development rollup -c -o dist/react-leaflet.js',\n     'build:umd:min': 'cross-env BABEL_ENV=rollup NODE_ENV=production rollup -c -o dist/react-leaflet.min.js',\n     build: 'npm run clean && npm run build:cjs && npm run build:es && npm run build:umd && npm run build:umd:min',\n     jest: 'cross-env BABEL_ENV=development NODE_ENV=test jest',\n     lint: 'eslint ./src',\n     flow: 'flow check',\n     test: 'npm run lint && npm run flow && npm run jest',\n     start: 'npm run test && npm run build',\n     prepublishOnly: 'npm run build',\n     examples: 'webpack-dev-server --config ./example/webpack.config.babel.js --progress' },\n  dependencies: { lodash: '^4.0.0', 'lodash-es': '^4.0.0', warning: '^3.0.0' },\n  peerDependencies: \n   { leaflet: '^1.2.0',\n     'prop-types': '^15.5.0',\n     react: '^15.0.0',\n     'react-dom': '^15.0.0' },\n  devDependencies: \n   { 'babel-cli': '^6.26.0',\n     'babel-core': '^6.26.0',\n     'babel-eslint': '^7.2.3',\n     'babel-jest': '^20.0.3',\n     'babel-loader': '^7.1.2',\n     'babel-plugin-dev-expression': '^0.2.1',\n     'babel-plugin-external-helpers': '^6.22.0',\n     'babel-plugin-lodash': '^3.2.11',\n     'babel-plugin-syntax-jsx': '^6.18.0',\n     'babel-plugin-transform-flow-comments': '^6.22.0',\n     'babel-plugin-transform-flow-strip-types': '^6.22.0',\n     'babel-plugin-transform-proto-to-assign': '^6.26.0',\n     'babel-plugin-transform-react-display-name': '^6.25.0',\n     'babel-plugin-transform-react-jsx': '^6.24.1',\n     'babel-preset-env': '^1.6.0',\n     'babel-preset-stage-1': '^6.24.1',\n     'cross-env': '^5.0.5',\n     eslint: '^4.5.0',\n     'eslint-config-prettier': '^2.3.0',\n     'eslint-plugin-flowtype': '^2.35.0',\n     'eslint-plugin-import': '^2.7.0',\n     'eslint-plugin-node': '^5.1.1',\n     'eslint-plugin-prettier': '^2.2.0',\n     'eslint-plugin-promise': '^3.5.0',\n     'eslint-plugin-react': '^7.2.1',\n     'flow-bin': '^0.53.1',\n     'jest-cli': '^20.0.3',\n     leaflet: '^1.2.0',\n     prettier: '^1.5.3',\n     'prop-types': '^15.5.0',\n     react: '^15.6.1',\n     'react-dom': '^15.6.1',\n     rimraf: '^2.6.1',\n     rollup: '^0.47.6',\n     'rollup-plugin-babel': '^3.0.2',\n     'rollup-plugin-commonjs': '^8.1.0',\n     'rollup-plugin-node-resolve': '^3.0.0',\n     'rollup-plugin-replace': '^1.1.1',\n     'rollup-plugin-uglify': '^2.0.1',\n     webpack: '^3.5.5',\n     'webpack-dev-server': '^2.7.1' },\n  jest: \n   { collectCoverage: true,\n     transform: { '.*': '/node_modules/babel-jest' } },\n  gitHead: '8b645e81d40dd47ce3dfa4bcd1db12a6f9817072',\n  dist: \n   { integrity: 'sha512-tDVPlJ0vMhx8+q4WEZeeN6FFoo8nPWQkQYB2s1CLfUdKwdfFMkK5hB+HK6CRmSOzODDht08oZ0qZAI5J6pLbxg==',\n     shasum: '8c7170b0b7e165cf9521f8c0918faeac1f3bf358',\n     tarball: 'http://nexus.infotech.team/repository/npm/react-leaflet/-/react-leaflet-1.6.2.tgz' },\n  directories: {} }\n```. Just now successfully install 1.6.3... I think it npm cache issue.. ",
    "pbock": "Yes, thanks, I should have mentioned: Leaflet behaves as expected, so this seems to be down to react-leaflet.\nIt looks like the exit transition was added in Leaflet 1.0.0. Playing around with the version numbers a bit, Leaflet also seems to have changed its mind several times on whether there should be an enter transition, an exit transition, or both.. I see, thanks for the explanation!\nIf disabling the transition is an option (or even desired), this can also be worked around by adding\ncss\n.leaflet-fade-anim .leaflet-popup {\n  transition: none;\n  /* \u2026 (browser prefixes as needed) */\n}\nto the page CSS.. ",
    "zeckdude": "That seems pretty lame to just say it's not possible to wait for the transition to finish before unmounting the React element. Is there no way to set a timeout to match the CSS transition time period that unmounts once the time period has passed?\nMy current solution will need to be to disable the animation but I refuse to believe that React is the new hotness and can't display the fancy animations.. ",
    "zemadz": "True, latlngList.js is arrayOf(latlng), but the import was previously import latlngList from './propTypes/latlng' (should have imported ./propTypes/latlngList).\nI didn't know/notice that there is a latlngList.js, will change my fix to use that.. ",
    "ghostd": "Thanks, the errors are fixed with the new version.. ",
    "tomjn": "That's unfortunate, and tbh a tad blunt. but I would recommend the following:\n\nmake this clear in the new issue template, that's a full day I could have gotten an answers or feedback wasted. Don't waste your users time, e.g.:\n\n<!-- For questions and general questions, please use the react-leaflet tag on Stack Overflow --!>`\n<!-- https://stackoverflow.com/questions/tagged/react-leaflet --!>\n - add a note on the kind of performance one can expect to the readme, aka a ballpark figure of how many markers it can comfortably hold. There are things you can do and you can send people to stack overflow. It could be as simple as \"React Leaflet allows you to add hundreds of markers\", which sets expectations without mentioning numbers\nBut as an aside, speaking as a Stack Exchange moderator, Stack Exchange explicitly forbids what you've just suggested to me, but since it's StackOverflow that's the exception, but that doesn't mean everything is appropriate there:\nhttps://stackoverflow.com/help/product-support\n\n\nHow do I? -- Stack Overflow (tell them what tags to use -- your product and language at minimum)\nI got this error, why? -- Stack Overflow\nI got this error and I'm sure it's a bug -- file an issue (on your own site)\nI have an idea/request -- file an issue (on your own site)\nWhy do you? -- your own community (developer forum etc)\nWhen will you? -- your own community\n\n\nSo feature requests, questions about your plans for the library, questions about why you built it a certain way, would all get closed as off topic and out of scope.. ",
    "thisissami": "@tusbar tagging you here since (looking through this repos history) it looks like you switched the build to use rollup, and accordingly I'm betting you might have some idea around what's going on. . Hey! Whoops I feel silly. The output I got did warn me that I should use the latest version of Node, and somehow in my mind I thought that they latest of v6 would do. Whoops! \n@tusbar I implemented the changes from #376 and that 100% worked for me. :) Didn't need to upgrade my version of node! :) \ud83d\udc4d  to having that integrated in the codebase - super easy change to open up builds for a larger userbase! (though of course just upgrading to v8 is super easy too, especially with nvm). Thanks for the quick responses guys!. ",
    "AlexVestin": "<FeatureGroup ref={ (fGroup) => { this.fGroup=fGroup; } >\n and then \nthis.fGroup.getChildContext()[\"layerContainer\"].toGeoJSON();. Check out this webpackbin:\nhttps://www.webpackbin.com/bins/-KtmfcJ1eZYVr_cJs7MT. I should have read the original question better, sorry.\nYes, you can do a ref on the Circle and then use circle.leafletElement.getBounds() to get its bounds. After that you can check if the other layers are inside the circle by looping through the featuregroup, using bounds.contains(layer._latlng) to check if they're inside.\nI would recommend putting the circle outside the feature group so you don't check it against itself.. updated the webbin a bit, it's a bit of a hack but it will probably do. getBounds() on a circle seems to return bounds for a square with the same proportions, so if you want geojson strictly in the circle you might have to write your own contains(). ",
    "vinaykhade": "Hi @AlexVestin , I tried implementing your solution in my code, it doesn't seem to work. Could please guide me on how to implement it inside this, on how to implement FeatureGroup in React? Thanks in Advance :)\n`import React, {Component} from 'react';\nimport Geosuggest from 'react-geosuggest';\nimport { Map, Marker, Popup, TileLayer, Circle, FeatureGroup } from 'react-leaflet';\nimport Slider from 'react-rangeslider';\nclass App extends React.Component {\nconstructor(props) {\n    super(props);\n    this.state = {\n      lat: 18.572605,\n      lng: 73.878208,\n      zoom: 13,\n      value: 500\n    }\n    this.onSuggestSelect = this.onSuggestSelect.bind(this);\n  }\ncomponentDidMount() {\n    // let x = this.fGroup.getChildContext()[\"layerContainer\"].toGeoJSON();\n    // console.log(x)\n  }\n  onSuggestSelect(suggest) {\n    console.log(suggest)\n    this.setState({\n      lat: suggest.location.lat,\n      lng: suggest.location.lng,\n    })\n  }\nhandleChangeStart = () => {\n    console.log('Change event started')\n  };\nhandleChange = value => {\n    this.setState({\n      value: value\n    })\n  };\nhandleChangeComplete = () => {\n   console.log('Change event completed')\n  };\nrender() {\n    const position = [this.state.lat, this.state.lng];\n    const { value } = this.state\n    return (\n      \n\n\n\n\n\n\nA pretty CSS3 popup.  Easily customizable.\n\n\n\n\n\n\n{value}\n\n\n);\n\n}\n}\nexport default App;\n`. Hi @AlexVestin , thanks for sharing the webpackbin. \nRIght now, i'm getting the geometry type as point, after adding the  inside feature group. \nIs there any way we can get the result where the geometry type is  polygon representing this circle in GeoJSON format. Something similar to getting an array of co-ordinates for this polygon/circle ?I've been going through the documentation, would getBounds be helpful in this scenario ?\n. Hey @AlexVestin , thanks for sharing. I'm trying to implement it, seems circle.leafletElements is coming as undefined. Could you please guide me through this using the webpackbin, it's really helpful. Thanks a lot!. ",
    "kevinhughes27": "That was it! Thanks :smile_cat: . ",
    "uwap": "@PaulLeCam Had the same problem. Updated flow to 0.54. Now it works, but I still get Redundant argument errors.\nError: node_modules/react-leaflet/es/Pane.js.flow:2\n  2: // flowlint sketchy-null-string:off\n                 ^^^^^^^^^^^^^^^^^^^^^^^ Redundant argument. This argument doesn't change any lint settings.. ",
    "extend1994": "Oh I am so sorry! it's a type error. Should be v0.8.0 here \ud83d\ude13 \nSo...there is no distribution before the versions v0.8.0, right? . Basically, CDNJS wants to host the library as completely as possible. That's why I want to know can older versions can be directly used in front-end :). @PaulLeCam Thanks for your quick response! :smiley: \nSorry for late reply... I have been busy these days. :sweat: \nCDNJS uses a mechanism called \"auto-update\" by setting it in package.json to detect new release on npm (or new tag on GitHub) and add it to CDNJS automatically. Here is the more complete doc https://github.com/cdnjs/cdnjs/blob/master/documents/autoupdate.md\nSo I think I just need to add the versions with UMD build?. Got it! I will add it ASAP. Thank you again :). ",
    "bkon": "@PaulLeCam I think I hadn't explained my point well enough; I'm sorry for being vague.\nRe-render is perfectly fine and expected; in fact, we're explicitly triggering re-render as we need to animate the marker on the map. The problem I'm talking about is flyTo or setView triggered on that re-render even through the values of both bounds and boundsOptions are the same. \nNow, the above is still fine, but flyTo is triggered only by boundsOptions and it's inconsistent with the behavior of the bounds prop, which checks for equality by value instead of by reference (here: https://github.com/PaulLeCam/react-leaflet/blob/f803889e05c28d48aedd20c2707fd4dec552b190/src/Map.js#L287). This subtle difference is undocumented and confusing and the only way to triage this issue is to go through the library source.\nReal-life cenario: we were using bounds for a while (passing a literal to the map) without any issues, and then we added boundsOptions with some padding, which resulted in map being re-centered on the initial position every time marker was animated.\nIt's up to you to decide on the solution; as a library consumer I'd suggest either:\n- documenting the specifics of this behavior in the Map API section;\n- making bounds use the same by-reference equality check as boundsOptions;\n- making boundsOptions use the same by-value equality check as bounds.. ",
    "brianpchsu": "I have a similar question regarding the duplicate list. I need to iterate an array and push marker to it. Something similar to my code is:\nhttps://www.webpackbin.com/bins/-Kvmu5PPSjeS4lY-qe_E\nAs you can see, there are duplicate test in the list which should be just one. Is there a different way I should call LayersControl.Overlay? Thanks. \n\n. Never mind. I figured it out. I should have wrapped my markers in . \n\n. ",
    "vcarl": "@igorcalabria I just published a component that makes bounds available as a render prop, if you're still hitting this problem. https://www.npmjs.com/package/react-leaflet-bounds. ",
    "Asher978": "I am encountering the same behavior. All depend are installed. I have even tried setting the height of the map container. Any ideas?\n. Thanks for your help. All worked out! \nSent from my iPhone\n\nOn Oct 4, 2017, at 3:32 AM, Paul Le Cam notifications@github.com wrote:\nUse the code from https://www.webpackbin.com/bins/-Kl_ZeUx4I05ETYoT26O\nWhatever issue you're having comes from your config, not this lib.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "danielrasmuson": "I hit this problem. I was able to resolve it by adding the stylesheet to index.html\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.css\" />. ",
    "vire": "Had the same issue, it was because the import of leaflet.css has changed due to webpack setup changes... \nThis is so hard to debug, you still see tiles but has no idea why it's distorted...\nMaybe if leaflet would have some cssStylePresence check in development mode or, it would help.... ",
    "torgeir": "I believe I fixed a similar issue by passing the reference to the same viewport object that got emitted in onViewportChanged, and not creating a new viewport object on each render. Might be worth a shot... ",
    "sairus2k": "It's Leaflet itself issue. It fixed already but not released yet Leaflet/Leaflet#5830. ",
    "uxtx": "@PaulLeCam updated per your suggestions here - thanks for the feedback.. I'm happy to -but this is a standard cruft meta-data file automagically created in mac environments - without it - most contributors on macs may inadvertently slip up and commit .DS_Store files.. works for me!. ",
    "joefraley": "Also the contributing guide link in the issue template is broken. ",
    "Jinoooo": "This plugin does render an image using the map.  My question is if I can extend the <Map /> and customize its view the same way.\nHere is the plugin code:\n```\n;(function (factory) {\n  var L\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['leaflet'], factory)\n  } else if (typeof module !== 'undefined') {\n    // Node/CommonJS\n    L = require('leaflet')\n    module.exports = factory(L)\n  } else {\n    // Browser globals\n    if (typeof window.L === 'undefined') {\n      throw new Error('Leaflet must be loaded first')\n    }\n    factory(window.L)\n  }\n}(function (L) {\n  /*\n   * L.RasterCoords\n   * @param {L.map} map - the map used\n   * @param {Array} imgsize - [ width, height ] image dimensions\n   * @param {Number} [tilesize] - tilesize in pixels. Default=256\n   /\n  L.RasterCoords = function (map, imgsize, tilesize) {\n    this.map = map\n    this.width = imgsize[0]\n    this.height = imgsize[1]\n    this.tilesize = tilesize || 256\n    this.zoom = this.zoomLevel()\n    if (this.width && this.height) {\n      this.setMaxBounds()\n    }\n  }\nL.RasterCoords.prototype = {\n    /\n     * calculate accurate zoom level for the given image size\n     */\n    zoomLevel: function () {\n      return Math.ceil(\n        Math.log(\n          Math.max(this.width, this.height) /\n          this.tilesize\n        ) / Math.log(2)\n      )\n    },\n    /\n     * unproject coords to the raster coordinates used by the raster image projection\n     * @param {Array} coords - [ x, y ]\n     * @return {L.LatLng} - internal coordinates\n     /\n    unproject: function (coords) {\n      return this.map.unproject(coords, this.zoom)\n    },\n    /\n     * project coords back to image coordinates\n     * @param {Array} coords - [ x, y ]\n     * @return {L.LatLng} - image coordinates\n     */\n    project: function (coords) {\n      return this.map.project(coords, this.zoom)\n    },\n    /\n     * sets the max bounds on map\n     /\n    setMaxBounds: function () {\n      var southWest = this.unproject([0, this.height])\n      var northEast = this.unproject([this.width, 0])\n      this.map.setMaxBounds(new L.LatLngBounds(southWest, northEast))\n    }\n  }\nreturn L.RasterCoords\n}))\n```\nand here is how to use it:\n``\n    var img = [\n      3831, // original width of imagekarta.jpg`\n      3101  // original height of image\n    ]\n// create the map\nvar map = L.map(mapid, {\n  minZoom: minZoom,\n  maxZoom: maxZoom\n})\n\n// assign map and image dimensions\nvar rc = new L.RasterCoords(map, img)\n\n// set the view on a marker ...\nmap.setView(rc.unproject([1589, 1447]), 4)\n\n// the tile layer containing the image generated\nL.tileLayer('./tiles/{z}/{x}/{y}.png', {\n  noWrap: true,\n  attribution: 'xyz'\n}).addTo(map)\n\n```\nWould be great to know the best approach to incorporate this plugin.. Can you please let me know how I can overwrite the map's view only?. Where should I override the setview method for Map component?  Should it be in componentDidMount()?  The problem is by then the map has been constructed already!. ",
    "acpower7": "any update on this? @PaulLeCam  no offense, but your answers aren't helpful at all :( please give some guidance on how we can use that plugin with your library.. Can you instruct how to use it with your library?\nthx. you are the most useless project maintainer i've seen on github. i have read many of your comments on opened issues, every single one of them has a net value below zero. you'd be more helpful if you shut down this project for good.. ",
    "mzmrk": "Working example based on code from: https://commenthol.github.io/leaflet-rastercoords/\nMade that example shorter to keep it concise. Enjoy.\n```\nimport React from 'react'\nimport { Map, TileLayer, Marker, Popup } from 'react-leaflet'\nimport Leaflet from 'leaflet'\nimport RasterCoords from 'leaflet-rastercoords'\nclass MapExtended extends Map {\n  createLeafletElement(props) {\n    let LeafletMapElement = super.createLeafletElement(props);\n    let img = [\n      3831, // original width of image karta.jpg\n      3101  // original height of image\n    ]\n// assign map and image dimensions\nlet rc = new RasterCoords(LeafletMapElement, img)\n\n// set the view on a marker ...\nLeafletMapElement.setView(rc.unproject([1589, 1447]), 4)\n\n// the tile layer containing the image generated with gdal2tiles --leaflet ...\n// Leaflet.tileLayer('https://commenthol.github.io/leaflet-rastercoords/example/tiles/{z}/{x}/{y}.png', {\n//   noWrap: true,\n//   attribution: 'Map <a href=\"https://commons.wikimedia.org/wiki/' +\n//   'File:Karta_%C3%B6ver_Europa,_1672_-_Skoklosters_slott_-_95177.tif\">' +\n//   'Karta \u00f6ver Europa, 1672 - Skoklosters</a> under ' +\n//   '<a href=\"https://creativecommons.org/publicdomain/zero/1.0/deed.en\">CC0</a>'\n// }).addTo(LeafletMapElement)\n\nreturn LeafletMapElement;\n\n}\n}\nexport default class LeafletMap extends React.Component {\n  render() {\n    return (\n      \n        {/ the tile layer containing the image generated with gdal2tiles --leaflet ... /}\n        ' +\n          'Karta \u00f6ver Europa, 1672 - Skoklosters under ' +\n          'CC0'}\n        />\n      \n    )\n  }\n}\n``\nDon't forget aboutcreateLeafletElementprops parameter if you need access to props.\nIf you try to useTileLayerfrom  'react-leaflet' on map, it will overwriteLeaflet.tileLayerfromcreateLeafletElement`. So watch out on that or just declare TileLayer in MapExtended directly.. ",
    "xaviershay": "Thanks @mzmrk, I was having a really difficult time figuring this out. Your example worked for me!. ",
    "maka-io": "Figured it out, so simple! Just... import the library.. ",
    "FeNoMeNa": "This bug is related with permanent and interactive behavior of the tooltip.. Thanks for the fix! Now interactive works correctly, but when I set permanent then the component prints the following error on unmount\nWarning: unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. Instead, have the parent component update its state and rerender in order to remove this component.. I'm sorry, the bug is related with the marker cluster component (internal implementation). The issue can be closed, thanks!. @PaulLeCam,\nthere is an issue when some external resource fire tooltipopen or tooltipclose events. Actually these events are fired from onAdd / onRemove methods in Leaflet/Tooltip.js. When the onTooltipClose callback in the Tooltip component is invoked we are getting this error:\nWarning: unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. Instead, have the parent component update its state and rerender in order to remove this component.\nReact 16 related issue.. ",
    "skipjack": "\nThanks for the P.S., great to know this library is useful!\n\nNo problem, and fwiw I've dug into the code a bit and really like how things are laid out. Hoping I can find some time to contribute, whether it's via a plugin or to the main repo, at some point!\n\nIt's pushed in v1.7.6, please try it out!\n\nTested it out and the original error is resolved but now I'm getting a different one:\n\nDOMException: Failed to execute 'remove' on 'DOMTokenList': The token provided must not be empty.\n\nWhen you do the .split(' '), I think multiple spaces and leading/trailing spaces need to be taken into account. This error is thrown when className is changed to something like blah  blah--something which can happen if you use template strings to apply classes, e.g. \njs\nclassName={ `base-class ${modifier} ${className}` }\nAnd only one of modifier or className exists. Originally I was thinking splitting on a regex would address this but maybe a simple .filter would be better, e.g.\njs\nfromProps.className.split(' ').filter(cls => !!cls)\nWhat do you think?. I tested the .filter and it does fix the issue. I'd be happy to submit a PR if you're ok with that approach.. Great, thanks for your help on this!. ",
    "adamabernathy": "@PaulLeCam still unable to get it to work.  Updated to 1.7.6 today.  Any insight?. Even after modling my code after yours, no luck. I'm using create-react-app v1.4.3 right out of the box.\nreturn (\n  <Map center={this.state.mapCenter} zoom={this.state.zoomLevel}>\n    <TileLayer attribution={attrib} url={tiles} />\n      <CircleMarker center={[40.65, -111.5]} color=\"darkblue\" weight={4} radius={20}>\n      <Popup>\n        <span>Popup in CircleMarker</span>\n      </Popup>\n    </CircleMarker>\n  </Map>\n). https://www.webpackbin.com/bins/-Kzk2qfnjLlk8qOu4uIp\n. Figured it out.  Changed the CDN on the CSS and it worked. Thanks for your help Paul.. ",
    "Raiche": "Using circleMarker in my current project, however recently the fill attribute stopped functioning. \nIt was functioning earlier, however after a recent update of packages it stopped showing. \nThis is my implementation code, the stroke circle is showing however the fill won't display. \n<CircleMarker\n                            center={[item.coordinates.latitude, item.coordinates.longitude]}\n                            fill={true}\n                            stroke={true}\n                            fillColor={\"white\"}\n                            radius={10}\n                            fillOpacity={1}\n                            color={\"black\"}\n                            weight={6}\n                        >\nany idea's would be greatly appreciated.. Seems like the error only occurs on developement systems. \nDifferent cause is likely. \nClosed issue.. ",
    "jeffchan": "No problem. Appreciate the quick review, and thanks for your great work.. ",
    "mraak": "Wow! Great attitude. And the submission form that seems like it's taken from government bureau of issue submission. . It's your own example in that fiddle and Leaflet default behavior of course works as expected: http://jsfiddle.net/LnzN2/1383/. ",
    "rubenmoya": "Not sure if this is what you mean, but I did a little proof of concept using react-leaflet and carto.js 4 https://codesandbox.io/s/mqm0j22o38. There is a CARTO blog post related to this: https://carto.com/blog/inside/cartojs-and-react/. ",
    "eugenekgn": "This is a really good example, I was using <TileLayer> instead of  that was initial problem. But this is a very well put together example, you guys should really document this recipe or have more comprehensive documentation. . @rubenmoya but you guys should really have a section for this on your website as part of documentation or GitHub or better yet both. We really appreciate this post, but it could be difficult to find.. ",
    "dgana": "I agree with @eugenekgn this should be documented!. ",
    "grillorafael": "{\n  \"presets\": [\"react-app\", \"stage-1\"],\n  \"plugins\": [\"dev-expression\", \"lodash\", \"transform-proto-to-assign\"]\n}\nAdding stage-1 and all those plugins seems to make it work. ",
    "dskgry": "Also happens when working with webpack as soon as the node_modules folder is not excluded from the babel-loader rule. \nmodule: { \n            rules: [\n                {\n                    test: /\\.js$/,\n                    exclude: /(node_modules)/,      <--- removing this line will cause the same error.\n                    use: [{\n                        loader: 'babel-loader',\n                    }]\n                },\n            ]\n}. ",
    "ricxsar": "I see. Thank you for the response. I will now close the issue.. ",
    "michael-p": "Thanks for the super-fast release! :)\nOne small thing might be the addition of closeOnEscapeKey for Popup - see #436.. Ok, that's subtle :) That explains why I got a different exception on Codepen than when testing locally. To see the original problem (why I opened this issue) add a <Circle radius={1.0} center={[-20, 20.0]} /> to the Map and set the preferCanvas={true} prop on the LeafletMap (that's important, it works with SVG-Renderer).\nI updated the original Codepen accordingly. When unmounting the LeafletMap there is an exception in the console.\nThank you for looking into this, I appreciate it!. Seems to work now, thank you! I haven't noticed any problems in our App related to that change but will let you know in case I happen to find something.. ",
    "keul": "Another idea: provide a live example page instead of referring only to local hosted examples. Seems that docusaurus can do this: https://docusaurus.io/docs/en/custom-pages.html. Looks good, thanks. For testing: hope to be able to migrate to v2 this week as my env is still a v1. ...OK, migration to v2 has been super-easy!\nNow it works as expected \ud83c\udf89 . @landru29 did you exported your component decorated with withLeaflet?. @PaulLeCam: any feedback on this?. I found an alternative way that's requires less changes.\nI tried fixing this need by simply relying on class inheritance, so just overriding the createLeafletElement method.:\n```javascript\nimport { LayersControl as BaseLayersControl } from 'react-leaflet';\nclass LayersControl extends BaseLayersControl {\n  createLeafletElement(props) {\n    // my stuff\n  }\n}\n```\nHowever this is not working because the exported structure from the LayersControl module is the decorated version of LayersControl:\nhttps://github.com/PaulLeCam/react-leaflet/blob/b8af25513f975617d3c1a9b584711c8c5ae43651/src/LayersControl.js#L193-L198\nBut with a very simple change this can work. It just need to exports also the non-decorated ones, putting an export keyword here:\nhttps://github.com/PaulLeCam/react-leaflet/blob/b8af25513f975617d3c1a9b584711c8c5ae43651/src/LayersControl.js#L117\n. ",
    "tanvirraj": "Hey @PaulLeCam . First of All Thanks for this Project . I use this everyday in my daily job. \nToday i come here to find some  issues , so that i can contribute, And Found this . \nI think there are many ways we can improve this. \nFirst think about documentation. Currently there are 15 examples. but the problem is if i have to see what examples do what i have to pull it and run . One thing we can do is to give a https://codesandbox.io/  link so anyone can see live example. \nIf you agree i will run all the example code in codesandbox and make doc little bit update with like \n\n\nsimple Marker with Popup (source code)(demo)\n\n\nEvent handling (source code)(demo)\n\n\nthis way . \nwhat do you think. . Thanks. i like your idea . i will also search if we can do with Docusaurus. \nyou can have look on codesandbox with embedding . \njust like this https://codesandbox.io/docs/embedding/. can you explain more, what you wants to actually want . \nafter reading your code, it seems that you doing something wrong . \ni advice you please read this any of source code \nyou will get a very clear idea \nhttps://react-leaflet.js.org/docs/en/examples.html. ",
    "koltclassic": "I'd love to help out with improving the site / documentation! It looks like the makers of component-playground have a react-specific implementation here. Would that make sense for this use case? Something like Storybook may also be useful.. I have a partially-completed Storybook version of the documentation in progress; would this be useful in the meantime? It seems like a relatively simple process to deploy Storybook to a static site (using something like storybook-deployer) \n\n. ",
    "moklick": "Hey! Did you saw the Open Logos project? Maybe you can get a logo there :). ",
    "farahabdi": "Thanks for the response. I am new React so if you could give me some specific pointers:\nI have the following leafletjs code that I want to convert to react-leaflet:\n```\n    var img = [\n      3840,  // original width of image\n      2160   // original height of image\n    ]\n    var map = L.map('map', {\n      minZoom: 0,\n      maxZoom: 2,\n      center: [0, 0],\n      zoom: 0,\n      crs: L.CRS.Simple\n    });\n// dimensions of the image\nvar w = 3860,\n    h = 2180,\n    url = 'https://i.imgur.com/xxxxx.jpg';\n\n// calculate the edges of the image, in coordinate space\nvar southWest = map.unproject([0, h], map.getMaxZoom()-1);  // {lat: -1100, lng: 10}\nvar northEast = map.unproject([w, 0], map.getMaxZoom()-1);  //  {lat: -10, lng: 1960}\n\nconst sw = {lat: -1100, lng: 10}\nconst ne = {lat: -10, lng: 1960}\nvar bounds = new L.LatLngBounds(sw, ne);\n\n// add the image overlay, \n// so that it covers the entire map\nL.imageOverlay(url, bounds).addTo(map);\n\n// tell leaflet that the map is exactly as big as the image\nmap.setMaxBounds(bounds);\n\n```\nI have this so far\n```\nimport { Map, ImageOverlay } from 'react-leaflet'\n....\nconst southWest = {lat: -1100, lng: 10}\nconst northEast = {lat: -10, lng: 1960}\nconst map = (\n  \n\n\n)\n...\n```\nPlease advise how to fix bolded. How do I inject \"CRS.Simple\" in the constructor? I searched the repo and there are no references to CRS.Simple.\nregards. ",
    "paulincai": "Confirmed by Leaflet: https://github.com/Leaflet/Leaflet/issues/6007. ",
    "benn983": "Code si correct, infact I tried to downgrade Leaflet to 1.2.x and react-leaflet to 1.7.8 and everything works fine.\nThe problem is that the popup which have to appears on the screen when I click on marker\u2019s icon, doesn\u2019t appear anymore and return that error. I think that this error regards leaflet library beacuse only downgrading react-leaflet the error persist.\n. Any ideas?. Hi, I've tried to update leaflet to 1.3.1 version but nothing happened.... There is a different error but regards as before to the position of the popup, because it can't define a Point to create the popup\n. ",
    "jonathanchrisp": "Hey @PaulLeCam, I've had another look at this today. I double checked to see if I could replicate the original issue raised in #415 and can't. The issue above appears regardless of which leaflet version you use.\nleaflet - 1.2.0 & react-leaflet 1.7.4 - no issue\nleaflet - 1.3.1 & react-leaflet 1.7.4 - no issue\nleaflet - 1.2.0 & react-leaflet 1.8.0 - issue\nleaflet - 1.3.1 & react-leaflet 1.8.0 - issue\nHowever, just to note we're not using React 16 within our project, we're still using React ^15.6.0 so perhaps this could be why I can't replicate the problem above. For now, we're going to revert to react-leaflet 1.7.4, I'll see if I can create some jsfiddles tomorrow to test the various dependencies, I'll let you know if I find out more. . @PaulLeCam Tested v1.8.1 and looks good. Thanks for sorting this out \ud83c\udf89 \ud83d\udc4d . Hey @PaulLeCam, is there any chance we could merge this in the next few days? If you need me to version I'd more than happy to do so. No worries if not, as I can downgrade back to 1.7.4.. Node 6 build failing on Travis CI with: \nerror @shellscape/koa-static@4.0.4: The engine \"node\" is incompatible with this module. Expected version \">= 7.6.0\".\nerror Found incompatible module\n@PaulLeCam - don't know whether you've seen this before or whether its inconsistent, but if you can re-run that would be great.. @PaulLeCam Updated as discussed. Just to note, I took another look at the Leaflet source code regarding the string value that can be passed for scrollWheelZoom and touchZoom and it appears to only check for the 'center' value so I've made the above conditionals stricter.. Hey @PaulLeCam, I've reset the conditional logic for scrollWheelZoom and touchZoom in the latest commit. \nIn terms of your first point, I'm not entirely sure what you mean. However, the logic checks whether the changed value is true OR a string type. In terms of the leaflet code, regardless of the value passed (true or center), we just need to enable/disable the handler. \nIt checks the value passed down when performing an action  e.g. scrollWheelZoom's _performZoom\nLet me know if you want me to update anything else.. Hey @PaulLeCam, apologies, now I know what you mean. Thanks for the detailed explanation above. I've updated the functionality in the latest commit.. Hey @PaulLeCam, just checking (no rush) but is there anything else to add here? . Hey @felixflow, I opened a PR a few days ago which cover this functionality and all the other map handlers, you can see this in #452. . scrollWheelZoom accepts a boolean value or a string in the latest leaflet documentation . As above - link . ",
    "mhasbie": "Do forgive me for my sins. I'm quite new at this. I have absolutely no idea what I was doing. There I've created new PR #446. Hope I did it correctly this time.\n. ",
    "SabirAmeen": "https://github.com/developit/preact/issues/857\nThink this is the issue with Preact.. ",
    "toby-griffiths": "OK.  It turns out that the problem was caused by including the leaflet CSS in the component's imports.\nI've now just included a link to the CDN hosted leaflet.css file and it's working OK, but it would be good if this could be patched to work with create-react-app webpack config.. ",
    "benneq": "I've copied some code from google, and now it's working without CDN:\n```\nimport * as React from \"react\";\nimport { Map, TileLayer, Marker, Popup } from \"react-leaflet\";\nimport 'leaflet/dist/leaflet.css';\nimport L from 'leaflet';\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n    iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n    iconUrl: require('leaflet/dist/images/marker-icon.png'),\n    shadowUrl: require('leaflet/dist/images/marker-shadow.png')\n});\nexport const MyMapComponent = (props) => {\n    return (\n        \n\n\n              A pretty CSS3 popup.  Easily customizable.\n            \n\n\n    )\n}\n```. @RossKinsella Did you get it working somehow?. @RossKinsella It's not urgent, but it would be nice if you could provide some code for it eventually \ud83d\ude04 \nIt looks like MapQuest is now powered by MapBox. And MapBox is much cheaper \ud83d\ude2e \nWould still be nice if you could provide some code to get MapQuest working with react-leaflet. \nThank you!. I already figured out a simple solution:\n<Map>\n  <TileLayer url=\"https://{s}.tiles.mapbox.com/v4/mapquest.streets-mb/{z}/{x}/{y}.png?access_token=...\">\n</Map>\nI just used my legacy leaflet MapQuest map and opened Chrome's Network tab. There you can see where it loads the tiles from. Then I just copied the request URLs and added some variables: {s} and {z}/{x}/{y}.. You can access it. You have 3 options:\n\nPull request for @types/react-leaflet \ud83d\ude03 \nProvide some global declaration for it in your code\nUse a hacky any cast: import * as RL from 'react-leaflet'; and then use it: (RL as any).withLeaflet(...). I copied and modified some code I found on the internet. I'm not sure if this solution is \"good\", but at least it's working: https://stackoverflow.com/a/54504646/1321564. \n",
    "kylebebak": "@PaulLeCam \nJust a suggestion: document this somewhere. I'm going to guess people new to this library don't know where to find this information.\n. @lambdakris \nIn case you're interested:\n```js\nimport React from 'react'\nimport { Map, ImageOverlay, Marker, Popup } from 'react-leaflet'\nimport L from 'leaflet'\nconst bounds = [[0, 0], [1900, 2546]]\nconst style = { height: '80vh', width: '75vw' }\nexport default class SimpleExample extends React.Component {\n  render() {\n    return (\n      \n\n    <Marker position={[1000, 1000]}>\n      <Popup>\n        A pretty CSS3 popup. <br /> Easily customizable.\n      </Popup>\n    </Marker>\n  </Map>\n)\n\n}\n}\n```\n. ",
    "yoloOnTheBattlefield": "try going back to  \"react-leaflet\": \"^1.7.8\", I had the same issue when I installed the project with npm, then I used yarn and everything went fine.. ",
    "sguergachi": "Thanks, I\u2019ll try it!. ",
    "nuragic": "I'm using v1.9.1 and this is still an issue apparently... \ud83d\ude15 . TBH I also disliked the idea of having to copy/paste the entire component code in order to modify some specific behavior, but then I realised that it's better to do so. Creating more levels of inheritance on top of the public API, which already have some of them to mimic how leaflet is built, is way worst in the end (see https://link.medium.com/iIALeQx38Q).\nTip: use https://github.com/flowtype/flow-remove-types if your source code is vanilla JS.\nAlso take care of your final production bundle size by not including those react-leaflet components that you're not using anymore.\n. I need the event data so onOpen is useless in this case.\nI know that Layer fires popupopen, but it's also fired by... obviously Popup.\nDon't you think it's a bug?\n. Nevermind... I figured it out as my Popup is wrapped in a FeatureGroup. Thanks for your time.. ",
    "andersonveiga": "No problem \ud83e\udd17. ",
    "hoetmaaiers": "Care to share the solution?. ",
    "olabalboa": "Creating a new pull request based on v1.9.0. ",
    "Valerz": "Yeah you can, you just specify the file you want. \nFor example:\nconst svgIcon = L.icon({\n      iconUrl: require('something.svg'),\n    })\nFurther reading here: http://leafletjs.com/examples/custom-icons/. What are you trying to achieve?\nOn Wed., 4 Apr. 2018, 19:08 BrandNew, notifications@github.com wrote:\n\nI am not sure how to use with react-leaflet. How would I go about doing\nthe same thing with react-leaflet? Also, what is L?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/issues/465#issuecomment-378533230,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AO_jBc9I7Fi1JSgCCDzPWjKqAtyv-30Rks5tlI2VgaJpZM4TFL2P\n.\n. L is the leaflet object where you can assign the URL path to your custom marker.\n\nconst customMarker = L.icon({\niconUrl: require('pathtoicon'),\n})\nreturn (\n <Marker icon={customMarker} >\n /*whatever inside marker */\n </Marker>\n). ",
    "vegtelenseg": "I am not sure how to use with react-leaflet. How would I go about doing the same thing with react-leaflet? Also, what is L?. I want to change what gets rendered by the Marker, that is when I do <Marker ...props> </Marker> instead of this resulting to a blue image, I would like to do something like <Marker iconToRender={pathToIcon} ...props> </Marker.. Great. It works. Thanks so much. Closing this.... ",
    "P45QU10U": "OK. It's fixed.. ",
    "kroltan": "Maybe this component was written before they existed, but nowadays we can use Portals to easily achieve what the ReactDOM.render approach attempted to solve, which is, placing elements in a location not matching the containing tree.\nIt will handle all peculiarities and work transparently for the library's user.. This seems to be fixed in v2, but the documentation is outdated.. @suricactus What version?. ",
    "suricactus": "Not sure if this is fixed, because when using redux's connect on component inside react-leaflet's <Popup /> I continue to get the following error:\nbrowser.js:38 Uncaught Error: Could not find \"store\" in either the context or props of \"Connect(LabelAirport)\". Either wrap the root component in a <Provider>, or explicitly pass \"store\" as a prop to \"Connect(LabelAirport)\".. ",
    "fullhdpixel": "Well, can you help understand why the methods invalidateSize() and flyToBounds nor setView are exposed?\nIm following this as an example: https://github.com/PaulLeCam/react-leaflet/blob/master/example/components/events.js\nIt should be possible to access these methods, right?\n. This worked because I had used StyledComponents which obstructed the use of ref:\n```\n this.mapRef = ref}\n...\n/>\n\ncenterPolyline = () => {\n    const {bounds} = this.state\n    if (bounds) {\n      this\n        .mapRef\n        .leafletElement\n        .invalidateSize()\n      this\n        .mapRef\n        .leafletElement\n        .flyToBounds(bounds)\n    }\n  }\n```\n. Hello, can this be merged?. ",
    "kontrollanten": "I've created a PR which updates those lifecycle methods https://github.com/PaulLeCam/react-leaflet/pull/485 I hope it can be accepted, even though your plans to not support them in v1, @PaulLeCam :-). Can I reopen the PR with only this bug fix https://github.com/PaulLeCam/react-leaflet/pull/485/commits/4c98d88ec01fdfb1c48c1c78b1fc7bce70f5c94c ?. Sometimes the element doesn't exist upon unmount, which causes error. There's similar checks upon unmount for other ReactLeaflet components, so I guess there has been issues with them as well. I haven't been able to reproduce the error by myself, I've just seen it in my sentry logs. ",
    "weyert": "@john-aws Have you ever been able to fix this problem? I am having a similar issue that the map is not correctly loading like this.. ",
    "john-aws": "@weyert Hi, I elected to stop using Mobx ES.next observer decorators and instead used observer functions instead, for example:\n```\nconst MyMarker = observer(class MyMarker extends React.Component {\n  static propTypes = {\n    map: PropTypes.object,\n    position: PropTypes.object,\n    color: PropTypes.string,\n  };\n  render() {\n    return (\n      \n\n\n\n    );\n  }\n});\nexport default MyMarker;\n```. ",
    "sanfilippopablo": "react-leaflet-draw extends LayersControl: https://github.com/alex3165/react-leaflet-draw/blob/master/src/EditControl.js\nreact-leaflet-bing extends TileLayer: https://github.com/Charmatzis/react-leaflet-bing/blob/master/src/Bing.js\nBoth of those components are wrapped by withLeaflet.. OK, sure. But let's say I want to extend the GeoJSON to have all its current functionality and a little more. For example, to reload the layer if the data prop changes. I could extend GeoJSON and add this method:\nes6\nupdateLeafletElement(fromProps, toProps) {\n    super.updateLeafletElement(fromProps, toProps);\n    if (!isEqual(fromProps.data, toProps.data)) {\n      this.leafletElement.clearLayers();\n      this.leafletElement.addData(toProps.data);\n    }\n  }\nBut I can't extend GeoJSON, because the only export already uses forwardRef. What if we added a named export here. Then I can extend it and use withLeaflet in my component.. @bsotodo interesting. Still, doesn't solve the issue.\n@PaulLeCam fair enough. Would you accept a PR explaining that in docs?. ",
    "bsotodo": "I am not sure, but if this is releated to the issue that one can't assign propTypes to components returned from React.ForwardRef: It was fixed in React 16.4.1: https://github.com/facebook/react/blob/master/CHANGELOG.md#1641-june-13-2018\n. ",
    "hpierre74": "I ran into the same error, you need to add 'leaflet' to your depencies : \nyarn add leaflet\nnpm i leaflet. ",
    "behnamazimi": "I did it truely! \nstill this error. even when I ctrl+click on the file names , it goes to the file inner!. ",
    "alexghinea-adswizz": "Facing the same issue here.\nUsing Webpack 4.12 and Typescript 2.9.2 with react-leaflet 2.0.0-rc.2\". ",
    "augnustin": "yarn add leaflet worked for me . ",
    "tarksin": "Does not work for me; same error. \nUsing  \"react-leaflet\": \"^2.0.0\" in packages.json\nModule not found: Can't resolve 'leaflet' in '/home/.../..../...../client/node_modules/react-leaflet/es'\n. ",
    "sergiotapia": "same. ",
    "gitstephanie": "Still no solution? I'm getting the same error:\n'Can't resolve 'leaflet' in '/home/.../..../...../client/node_modules/react-leaflet/es''\nyarn add leaflet //\nnpm i leaflet --> didn't help. ",
    "747823": "To clarify for anyone reading, react-leaflet has react, react-dom, and leaflet as peerDependencies which means they have to be npm installed separately or you will get this error. This is in fact noted on the installation instructions in the docs: https://react-leaflet.js.org/docs/en/installation.html\nI would recommend doing --save on all the dependencies too, but that may depend on your use case.. @phaux There already is one... when you npm install react-leaflet there's an es folder and a module field in the package.json. If the bundler you are using supports that (e.g. webpack 4 in production mode) you will already get the advantages of it.. ",
    "danyhiol": "This is what I have done so far:\n```\nimport PropTypes from 'prop-types';\nimport { MapLayer, withLeaflet, childrenType } from 'react-leaflet';\nimport L from 'leaflet';\nimport '../EdgeMarker/EdgeMarker';\nclass EdgeMarkerComp extends MapLayer{\nstatic childContextTypes = {\n    layerContainer: PropTypes.object\n  }\ngetChildContext () {\n    return {\n      layerContainer: this.leafletElement\n    }\n  }\ncreateLeafletElement(props) {\n    const { options } = props;\n    console.log(\"Options: \", options);\n    return new L.EdgeMarker(options);\n  }\n}\nexport default withLeaflet(EdgeMarkerComp);\n```\nOn my map:\n```\nconst options = {\n      icon: L.icon({ // style markers\n          iconUrl: 'images/edge-arrow-marker-black.png',\n          clickable: true,\n          iconSize: [48, 48],\n          iconAnchor: [24, 24]\n      }),\n      rotateIcons: true, \n      layerGroup: null \n};\n\n\n\n```\nAny help???. ",
    "samankhademi": "also i try this\n```\nimport React from 'react';\nimport withStyles from 'isomorphic-style-loader/lib/withStyles';\nimport s from './Home.css';\nif (process.env.BROWSER) {\n  var L = require(\"leaflet\");\n  var Map = require('react-leaflet').Map;\n  var TileLayer = require('react-leaflet').TileLayer;\n  var Marker = require('react-leaflet').Marker;\n  var Popup = require('react-leaflet').Popup;\n}\nclass Home extends React.Component {\n  constructor(props){\n    super(props);\n    this.state = {\n      lat: 51.505,\n      lng: -0.09,\n      zoom: 13,\n    }\n  }\n  render() {\n    const position = [this.state.lat, this.state.lng]\n    return (\n      \n        {process.env.BROWSER && (\n          \n\n\n                A pretty CSS3 popup.  Easily customizable.\n              \n\n\n        )}\n      \n    );\n  }\n}\nexport default withStyles(s)(Home);\n```\nand i get this error in CSR\n```\nUnhandled Rejection (TypeError): Object(...) is not a function\nObject../node_modules/react-leaflet/es/context.js\nD:\\project\\react-starterkit\\node_modules\\react-leaflet\\es\\context.js:8\n5 | // $FlowFixMe: import\n   6 | forwardRef } from 'react';\n   7 | \n\n8 | var _createContext = createContext({}),\n   9 |     Consumer = _createContext.Consumer,\n  10 |     Provider = _createContext.Provider;\n  11 | \n\nObject../node_modules/react-leaflet/es/index.js\nD:\\project\\react-starterkit\\node_modules\\react-leaflet\\es\\index.js:1\n\n1 | export { LeafletConsumer, LeafletProvider, withLeaflet } from './context';\n  2 | \n  3 | export { default as AttributionControl } from './AttributionControl';\n  4 | export { default as Circle } from './Circle';\n\nObject../src/routes/home/Home.js\nD:\\project\\react-starterkit\\src\\routes\\home\\Home.js:6\n  3 | import s from './Home.css';\n  4 | if (process.env.BROWSER) {\n  5 |   const L = require(\"leaflet\");\n\n6 |   var Map = require('react-leaflet').Map;\n  7 |   var TileLayer = require('react-leaflet').TileLayer;\n  8 |   var Marker = require('react-leaflet').Marker;\n  9 |   var Popup = require('react-leaflet').Popup;\n```. update in: https://stackoverflow.com/questions/51265189/react-leaflet-map-error-in-server-side-rendering. \n",
    "sneakycrow": "Ah, that does seem to be the problem. Alright, I had a misunderstanding of how ref's are applied. Thanks!. ",
    "mattgbrich": "This might be my bad for mis-reading the docs. I noticed the line that says \n\u2139\ufe0f All other properties are passed as parameters and dynamic, they will cause the layer to redraw if they change.\nI thought it was applying to all Raster Layers, but looks like maybe it only applies to WMSTileLayer?. That makes sense, thanks for the clarification!. ",
    "Ben-Ho": "Hello,\ni found out setTitle is not supported. Don't know how I came up with this.\nBut there is a possible solution to accomplish this by changing options.title and reseting the icon. I'm afraid this is to hacky for react-leaflet as its depending on internal structures of leaflet.\nMaybe I'll start a pull-request for leaflet first :-D. ",
    "mottab": "Thank you,\nI solved it.\nimport React, { Component } from 'react'\nimport { Map, TileLayer, ImageOverlay} from 'react-leaflet'\nimport Leaflet from 'leaflet'\nimport 'leaflet-imageoverlay-rotated'\n\nclass ImageOverlayRotated extends Map {\n  createLeafletElement(props) {\n    let LeafletMapElement = super.createLeafletElement(props);\n    let topleft    = new Leaflet.latLng(25.19369224545977, 55.27024269104004);\n    let topright   = new Leaflet.latLng(25.19413882386311, 55.271347761154175);\n    let bottomleft = new Leaflet.latLng(25.192905875160584, 55.27065575122833);\n    let overlay = new Leaflet.imageOverlay.rotated(\"./zoning.svg\", topleft, topright, bottomleft, {\n      opacity: 0.7,\n      interactive: true\n    }).addTo(LeafletMapElement)\n    return LeafletMapElement;\n  }\n}\n\nexport default class ImageOverlayExample extends Component {\n  state = {\n    play: true,\n  }\n\n  onTogglePlay = () => {\n    this.setState({ play: !this.state.play })\n  }\n\n  render() {\n    return (\n      <div className=\"map\">\n        <ImageOverlayRotated\n        onClick={this.onTogglePlay}\n        bounds={[[25.192905875160584,55.27024269104004,0],[25.19413882386311,55.27176082134247,0]]}\n        style={{width: \"858px\", height: \"650px\"}}\n        >\n          <TileLayer\n            noWrap={true}\n            attribution=\"&amp;copy <a href=&quot;http://osm.org/copyright&quot;>OpenStreetMap</a> contributors\"\n            url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n          />\n        </ImageOverlayRotated>\n      </div>\n    )\n  }\n}\n\n. Make sure you changed both the bounds, topright, topleft and bottomleft variables to your own custom positions.. ",
    "saadbinsaeed": "@mottab I copied and pasted the same code. Just changed the image URL. I can see my image on map but I am unable to rotate or transform it. . ",
    "shierro": "Hi @PaulLeCam , can you help me with an issue regarding offline support? https://stackoverflow.com/questions/52810382/enable-react-leaflet-to-use-be-usable-offline\nThanks!. ",
    "chazsolo": "Thanks for the response, and happy to leave as is. I'd suggest to update the documentation for Pane to reflect this, at least - took me longer than I'd like to admit to narrow this one down considering non-marker components work without passing the pane name around.. Check this codepen: https://codepen.io/chazsolo/pen/NBmzPB?editors=0110\nYou weren't updating positions in state which is what the polyline was using for data.. I've not used setState functionally before, but that seems to be your problem. Change\nthis.setState(prevState => {\n  const newSample = [...prevState.sample];\n  newSample[0].positions.push(newMarker);\n  return {sample: newSample};\n});\nto\nthis.setState({\n  sample: [{\n    ...this.state.sample[0],\n    positions: [\n      ...this.state.sample[0].positions,\n      newMarker\n    ]\n  }]\n})\nYour polyline will update correctly . ",
    "felixdrp": "Add next line to html header helped me a lot. (Change version if you need it)\n<link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.3.4/dist/leaflet.css\" />\nThanks for the check list :-)\n. ",
    "melvinchng": "Thanks for the response. From your codepen, the Polyline works the way you have your state updated. However, I found out that the way I have my state updated works for Circle components, but not Polyline.  \nCodepen: https://codepen.io/melvinchng/pen/MBRqXP?editors=0110\n. ",
    "CloudPower97": "@PaulLeCam Just wanted to let you know that this bug is present in version 2.1.3 as well :disappointed: . ",
    "rubenspgcavalcante": "Got the same problem while trying to make react-leaflet-ant-path support the v2.\nTrying to extend the Path Component results in this error:\nCannot read property 'layerContainer' of undefined\nWhile trying to extend the Layer, it throws this error:\nTypeError: Super expression must either be null or a function\n[Update]\nFigured out that in here:\nhttps://github.com/PaulLeCam/react-leaflet/blob/c1e7fdc10f38c70e7c2cb266086931c13b55315e/src/MapLayer.js#L21-L23\nThe this.props is assuming the value of this.leafletElement.\nThe getter is getting a wrong context. Hi @PaulLeCam,\nSorry but I don't share your point of view. You see, this part can't be covered by flow if you're not using it (and you can't enforce any app/lib, that uses react-leaflet as dependency, to use flow).\nSo still thinking that the run-time check is valid :)\nWhat do you say? \ud83e\udd14 . Another thing, even if your app proper use flow (I'm not a expert on it tho), don't know if flow will be able to check on the minified/distribution version of react-leaflet. Sorry, but isn't about Flow or not flow, but being more explicit than implicit.\nThis is the following error when not using withLeaflet:\nUncaught TypeError: Cannot read property 'layerContainer' of undefined\n    at MyComponent.get (MapLayer.js:73)\n    at MyComponent.componentDidMount (MapLayer.js:40)\n    at commitLifeCycles (react-dom.development.js:14524)\n    at commitAllLifeCycles (react-dom.development.js:15738)\n    at HTMLUnknownElement.callCallback (react-dom.development.js:145)\n    at Object.invokeGuardedCallbackDev (react-dom.development.js:195)\n    at invokeGuardedCallback (react-dom.development.js:248)\n    at commitRoot (react-dom.development.js:15908)\n    at completeRoot (react-dom.development.js:17296)\n    at performWorkOnRoot (react-dom.development.js:17224)\nWithout the checking, there's no reason for this PR.\nAt least it will be documented for lost developers, who are extending something from your lib (and I'm not sure if even Flow can check this), that the error above is about the missing HOC.\nJust my 2 cents \ud83d\udc4d \n. ",
    "ChrisLowe-Takor": "PR  #511 . ",
    "RossKinsella": "It's possible to specify the tileset leaflet is running. Check out their\nAPI, I gave it a URL for Google's tiles in my app. I'd give you a snippet\nbut AFK\nOn Mon, 4 Feb 2019, 1:10 pm Benjamin Makus <notifications@github.com wrote:\n\n@RossKinsella https://github.com/RossKinsella Did you get it working\nsomehow?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/PaulLeCam/react-leaflet/issues/518#issuecomment-460244587,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AF-LSfl1V_-gJ6rsFWZnRx50eeDBLNUNks5vKDFigaJpZM4W3KXw\n.\n. @benneq I got the google tileset running using: https://gitlab.com/IvanSanchez/Leaflet.GridLayer.GoogleMutant\n\nunder the hood, these tilesets are running the same protocal. Something similar should be possible if you dig into the source code. ",
    "mpivaa": "Ah sorry, didn't see in the docs.\nBut should it be optional if I don't want a custom context? Like in the example below, flow complains about the leaflet prop on Map.\n```js\n// @flow\nimport React, { Component } from 'react'\nimport { Map, TileLayer, Marker, Popup } from 'react-leaflet'\nexport default class SimpleExample extends Component<{}> {\n  render() {\n    return (\n      \n\n    )\n  }\n}\n```\nIf I just pass <Map leaflet={{}} /> it works.. ",
    "phdog": "Same here\nP.S. https://github.com/PaulLeCam/react-leaflet/issues/453 here's what solved my problem. ",
    "anujsinghwd": "@phdog \ni found the solution use custom marker. this resolve your issue.. ",
    "yanickrochon": "Right, so this is an issue, how was this resolved?. ",
    "ostrgard": "\nThanks for the example, this should be fixed in v2.1.1, please try it out.\n\nThank you for the extremely quick fix. It is indeed fixed!. ",
    "radeno": "@PaulLeCam changed. You are right, Object.entries is still young, could be polyfilled in user project. But for wide support i will change it.. ",
    "v1zix": "Tested with the most recent update, working well for me!. ",
    "pferreir": "Hi,\nThanks for having had a look at the PR. I'm not sure I understand, could you maybe elaborate a bit on how you would obtain the same effect with shouldComponentUpdate?\nThe only workaround that I can think of and doesn't imply patching the Marker class is subclassing it.. Hi @PaulLeCam, just pinging you to make sure that you got the last comment. This really looks to me like a bug (comparing LatLng objects with !==).. Thanks a lot for your answer, @PaulLeCam. I see what you mean, I am indeed re-creating the Marker object too often. I still think that avoiding this pitfall would be useful, but I understand your reluctance in going that way. Thanks once again!. ",
    "thaithcock": "Hi there,\nIt's dangerous to use the array index in a map as the key prop, as it can cause buggy behavior. Read more about that here.\nTry using item.deviceName as your key.. ",
    "rlahoda": "I pulled the icon declarations into another file. This is how I approached it in my own project but was trying to have it in the component for simplicity in the example. Let me know if this works for you. Thanks!. I created a second version that has the icons declared in the component in their own exports. This might be more straightforward since they show the icons in the same file\n. the custom-icons2 isn't referenced anywhere. If you want to keep both, I can create another pr to add mention of the file to the docs md file.. I'm fine with either. From an example standpoint, having everything in one file makes sense because the user doesn't have to search around for the second file with the icons in it. I didn't think of how to do it all in one file like that until after making the 2-file version. I'd rather the single file version if it's all the same to you. If that's good with you, I'll make the change and resubmit. . I removed the second custom-icons2.js file and the extra icons.js file and added the two icons into the single custom-icons.js component. Let me know if you'd like any additional changes.\nThanks!. ",
    "fqborges": "Fixed! Thanks for your efforts, amazing work.\nAnd sorry for the delay, I was off since xmas weekend.. ",
    "vadzim": "Oops.. The problem is much more interesting)\nPath has a field declaration leafletElement: LeafletElement. This declaration actually assigns undefined to this.leafletElement after calling super(props). The declaration itself was added to make flow check pass.\nSo it turns that this.leafletElement is created twice only for flow to shut up.. fixed. ",
    "bradcrawford": "I will see what I can do @PaulLeCam . https://codesandbox.io/s/ywn94996wj\n@PaulLeCam, you're correct, it seems to be a leaflet bug so I will raise it on the leaflet github page.. ",
    "jhe01": "Solved this by creating another GeoJSON with type of MultiPoint ..\nThanks ... ",
    "landru29": "Ok, That's the problem.\nwithLeaflet is not exported in package @types/react-leaflet, so it's not possible to invoke in typescript. ",
    "robinmetral": "\nThese components are base classes used by other components. They can be extended to create custom components but should not be used directly.\n\nNext time I'll read every single line before posting.. In case others end up in my situation: if you don't want to create your own custom component that extends MapControl, have a look at the react-leaflet-control plugin. There's no GitHub repo but it was updated 5 months ago to a V2.0.0.\nInstall it: npm i -S react-leaflet-control\nUse it:\n```javascript\nimport React, { Component } from \"react\"\nimport { Map as LeafletMap, TileLayer } from \"react-leaflet\"\nimport Control from \"react-leaflet-control\"\nclass Map extends Component {\n  render() {\n    return (\n      \n\n    // use react-leaflet-control to show a simple custom control on the map\n    <Control position=\"topright\">\n      <button onClick={this.props.triggered}>Trigger</button>\n    </Control>\n\n  </LeafletMap>\n  )\n\n}\n}\nexport default Map\n```. Thanks @clementallen I couldn't find any repo!. Thanks @ZhangYiJiang :rocket: Of course it's still compatible, and there are workarounds in the issue you mentioned. Looking forward to a cleaner fix.. ",
    "ZhangYiJiang": "@robinmetral There is a bug that affects v2 which I'm trying to fix right now https://github.com/LiveBy/react-leaflet-control/issues/27 . ",
    "borgdrone7": "Solved.. "
}