{
    "narqo": "Maybe there should be Immutable.is() static method, which would have the same semantic ES6's Object.is() has?\nThe API may look like this: Immutable.is(obj1, obj2) to check whether objects are equal by value. \n. You're absolutely right. Somehow I decided that Object.is() compares objects by there values, not by \"identity\". My bad, sorry.\nIn any case: :+1: to the issue ;)\n. Maybe there should be Immutable.is() static method, which would have the same semantic ES6's Object.is() has?\nThe API may look like this: Immutable.is(obj1, obj2) to check whether objects are equal by value. \n. You're absolutely right. Somehow I decided that Object.is() compares objects by there values, not by \"identity\". My bad, sorry.\nIn any case: :+1: to the issue ;)\n. ",
    "rtfeldman": "I wouldn't want to confuse people; Object.is only differs from === in the specific cases of NaN, 0, and -0 (and handles object comparisons in the same way as ===), whereas the deepEquals I'm referring to would compare the contents of objects, like what Underscore's _.isEqual does.\n. @Aetet I have a WIP branch that implements it, but needs a bunch of tests before it can go on master. I haven't had time to work on it, and realistically won't in the near future.\n. There doesn't seem to be much demand for this, so I'm going to close this for now.\n. Which function are you referring to?\n. Ah. Fair point...I don't especially care one way or the other. Any other opinions on this? @raorao?\n. I agree about \"constructor in spirit\" (which was why I named it that way.)\nActually it just occurred to me that this seems easily solvable by the library end user, e.g. var immutable = require(\"seamless-immutable.js\") - although @mvolkmann please feel free to correct me if I'm missing something. :smiley: \n. Well, it's just as easy if you use RequireJS, Browserify, Webpack, Node, etc. - and of course if you're just attaching it to window, you can always go window.immutable = Immutable, so I think that's frictionless enough that this is worth closing.\nThanks for pointing this out!\n. Clarified the comment in b90a14a61e76c54d01347aec581d226f3df59112\n. Awsesome!\nThe best practice I've seen (which is what React does) is to make it envify-friendly.\nBasically you do this:\nif (process.env.NODE_ENV === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\n...then run envify on it twice, once with {NODE_ENV: \"development\"} and once with {NODE_ENV: \"production\"} to get two output files: seamless-immutable.development.js and seamless-immutable.production.min.js\nIn the development build, envify will replace the above with this:\nif (\"development\" === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\n....whereas in the production build, it will instead replace it with this:\nif (\"production\" === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\nUglify will then see that this conditional will always fail and will strip this code out entirely, meaning the production build will not only avoid adding the extra attributes, it won't even run any conditionals to tell if it's in prod mode!\nThis implicitly means we'd need to introduce a build process to generate the two different files for library consumers.\n. That makes sense to me. Let's not check in changes to the compiled files on every commit, though, as that will make the diffs miserable.\nInstead just leave them out of normal commits, and once per release I'll include updated compiled files in the commit that bumps the version number.\nSound good?\n. Wow, this is awesome! Thanks so much for doing this. Makes it pretty clear that prodMode would make a big performance difference.\n. Thanks for your awesome work on this @crudh! I'm going to close this issue now that we have some benchmarks, but will tag #6 to remember this is worth revisiting once Prod Mode exists.\n. Yep, it should be deeply immutable. This is a bug. The guarantees of immutability are important to maintain...I'll fix this in a jiffy. Thanks!\n. Oh nice! I think this should be a very inexpensive check to do...I'll take a crack at it real quick.\n. Changed in c7887bbb4b0bcb6141dbc32aafde72869b505883\n. Fixed in https://github.com/rtfeldman/seamless-immutable/commit/c7887bbb4b0bcb6141dbc32aafde72869b505883\n. Just that it's time-consuming both from an implementation and from a performance perspective. It would entail building up an intermediate data structure just to track where things need to end up, then converting that back into a cloned object with references appropriately reconnected...\nThis came up because I accidentally called Immutable on a React component (which contained a circular reference), and it just threw a stack overflow, which made it harder to figure out what I'd done wrong. As soon as I realized the root cause, it was easy to fix, so having a check that results in an exception is all I need to avoid that particular issue in the future. :smile: \n. That said, if it's something someone actually needs, I'm not aware of any reason it couldn't be done.\n. Great point! It could also then console.error(object) so you could actually see the problematic object in question.\n. Resolved by https://github.com/rtfeldman/seamless-immutable/pull/119\n. Currently no plans for cursors, sorry!\n. Indeed!\n. I dig it! Test duplication is no problem, but from an API perspective I'd prefer if this were an optional boolean passed to merge to enable deep merging.\nWould love to see a Pull Request for this. :+1: \n. Good points all around. My preference is to change the existing merge as follows:\n1. It now always takes exactly one or exactly two arguments.\n2. The first argument works the same as always: you can pass it one object to merge, or an array of them.\n3. The second argument is optional, and is a configuration object that currently supports only {deep: true}\nSound good?\n. Looks great! Thanks for adding this.\n. I haven't come across this use case yet, but it turns out you can already do this pretty cleanly with asMutable:\n``` javascript\nvar item = Immutable({name: \"bob\"});\n// new Item is immutable, obj is mutable\nvar newItem = (function(obj) {\n   obj.name = \"henry\";\n   return obj;\n})(item.asMutable());\n```\n. @seanhess Seems like this would address your use case, yeah? :smiley: \n. True! Fixed:\n``` javascript\nvar item = Immutable({name: \"bob\"});\n// new Item is immutable, obj is mutable\nvar newItem = (function(obj) {\n   obj.name = \"henry\";\n   return Immutable(obj);\n})(item.asMutable());\n```\n. Glad it was helpful! :smile_cat: \n. I considered it, but the trouble is that doing this can mask bugs. For example:\n``` javascript\nfunction foo() {\n  var array = [3, 1, 4];\narray.sort()\nreturn array;\n}\n```\nIf you change that first line to be Immutable([3, 1, 4]), what should happen?\nCurrently array.sort() throws an exception, letting you know that some code that made sense with a mutable array no longer makes sense. If instead array.sort() just returns a sorted, immutable array, then now an unsorted array will be returned here, and you have a bug to track down - a potentially nasty one, if there is a lot of logic surrounding this code.\nI prefer this API because you can take an immutable array and write any number of helper functions that return sorted ones, but the only way to make bugs like this easy to find is to override the mutable methods to throw an exception. :smiley: \n. Thanks @alanhogan! :blush: \n@dariocravero Generally I'm using Underscore functions like _.sortBy and just calling Immutable on the result. No need to call .asMutable() in that case!\n. @tylercollier Good news! :smile_cat: https://github.com/rtfeldman/seamless-immutable#performance\n. Ahh got it, yeah that's correct. Sorry for the confusion!\nThat said, I'd honestly rather not add that complication to dev mode. :x\n. Nice catch! Thanks for fixing this.\n. This is because currently seamless-immutable does not copy over prototypes, and as such always returns a vanilla Object.\nCopying over prototypes is a bit of a double-edged sword. Something like .toISOString() should work as normal on an immutable object, so there's not much downside there. However, other methods might attempt to mutate the object and then fail silently (depending on whether Strict Mode is enabled). There's an element of \"buyer beware\" to copying prototypes.\nThat said, I suppose there's not much difference between deciding to use a prototype with mutating methods and just attempting to mutate an immutable object yourself, so  on balance this seems like a reasonable change to make. At the very least, it ought to address the proximal issue of Date.toISOString becoming unavailable.\n. Upon further investigation, there are pitfalls to the prototype-only approach. For example, Date (the motivating example, no less!) won't actually work as intended using this approach, because of how Date stores its internal data.\nIn light of that, I'm leaning toward this not being a good idea after all. It seems like it could lead to surprising bugs, where you can call most methods on most prototypes and have everything work as expected, but good luck tracking down the first bug that comes up because a prototype method relied on a non-enumerable hidden member...\n. That seems totally reasonable, yeah. We already do an instanceof check for Array, so we could certainly do another for Date and handle as appropriate.\n. Resolved by #31\n. The core issue with prototypes is https://github.com/rtfeldman/seamless-immutable/issues/25#issuecomment-92147785 - specifically, that there's no way to detect whether prototypes are relying on hidden properties, which cannot be discovered and cloned. The resulting bugs could have really nasty symptoms to identify; things as vague as \"the cloned version doesn't quite work the same way as the original for some reason.\"\nI could see offering a workaround similar to custom mergers, where you could pass a custom cloning function as an argument to Immutable(), and within that do whatever you like  (at your own risk, of course) with regards to prototype and anything else.\nThen if you wanted that prototype behavior everywhere you could just set Immutable to be some function that wraps the original Immutable() with a call that always passes your custom cloning function.\nThoughts?\n. Cool. This is admittedly not a high priority for me in terms of implementation, but I'm on board with the approach! :smiley: \n. :+1:  Makes sense...giving it another optional parameter is no big deal since it no longer accepts varargs, and the performance impact should be trivial (one extra conditional per iteration) in the normal case.\n. Excellent! Thanks for the fix.\n. Nah. The point of merge is to replace fields with fresh values, not (necessarily) to expand on existing values.\n. I dig it! Looks good.\n. Looks great!\nOnly one request: it should be pretty easy to parameterize the tests such that they check both the dev and the prod builds...something like this:\n``` javascript\n[\n  {buildName: \"development build\", src: \"../../seamless-immutable.development.js\"},\n  {buildName: \"production build\",  src: \"../../seamless-immutable.production.min.js\"}\n].forEach(function(config) {\n  var Immutable = require(config.src);\n// ...other requires go here\ndescribe(config.buildName, function() {\n// ...all the current tests go here\n\n});\n});\n```\nThanks a ton for doing this! Really excellent work. :smiley_cat: \n. This is fantastic! Love it. :heart_eyes_cat: \nThat approach with TestUtil seems totally fine.\n. Looks great! Nice and straightforward.\n. Looks like there are some cross-browser test failures: https://travis-ci.org/#L600\nPossibly new Date(dateObject) doesn't pass through time zone in all browsers?\n. If you don't mind, a new PR would be great. :smiley: \n. Seems it's not just .toISOString()! IE now reports different .getTime() numbers: https://travis-ci.org/rtfeldman/seamless-immutable#L616\nMaybe using a different constructor is in order?\n. Yep! Want to make sure the build is green before I bump the version to 2.3.1 and do a prod build. :smiley: \n. Ah, good point! No it won't. Updated in 1ccdc276875ef3b09ac2e1071dc7a907e17fa7f9\n. All set! :+1: \nThanks for the fixes!\n. Makes sense!\n. @crudh Unless this is urgent for you, I'm going to wait to cut a new release for this, because @raorao has some work to address https://github.com/rtfeldman/seamless-immutable/issues/16 using your proposed solution coming soon.\n. Yep, @crudh's explanation is exactly the reason behind banning the mutable methods. If there were a desire to add an alternative to concat for single elements, I'd call it something else, like append.\nA separate question is whether a method like that is worth adding to the API. Is there a common use case where this would be a significant upgrade over concat? I have not encountered any yet, and I'm hesitant to expand the API without strong motivating use cases because that's how libraries get bloated. :smile: \n. This is now fixed more efficiently by https://github.com/rtfeldman/seamless-immutable/commit/af6a8dfd7e2f1939e5108aae118b9270cb9bff3a\n. From reading icepick's description, it looks like both libraries are doing the same thing at a high level: providing immutable data structures that are backwards-compatible with vanilla JS arrays and objects, and which intelligently do shallow rather than deep cloning because shallow yields equivalent results for immutable data structures. \nIt looks like the main differences are:\n- seamless-immutable has higher test coverage\n- seamless-immutable has an optional production build that doesn't actually freeze the objects, which runs faster\n- each library has its own set of convenience methods\n. I'd rather keep the README focused, but now it's easy enough to link someone with the same question to this discussion! :smile: \n. Hm...seems to work fine in a Node REPL:\n``` javascript\n\nvar Immutable = require(\"seamless-immutable\")\nundefined\nvar array = Immutable([\"foo\", \"foo2\", \"bar\", \"bar2\", \"baz\", \"baz2\"]);\nundefined\narray\n[ 'foo', 'foo2', 'bar', 'bar2', 'baz', 'baz2' ]\n```\n\nMy first guess would be that Ember modifies Array.prototype in some way that is incompatible with seamless-immutable...do you know if that's something Ember does?\n. @dagda1 This is happening because you're importing the seamless-immutable source, not the compiled version (which has process stripped out). Try importing one of these instead:\nseamless-immutable development mode (with freezing and helpful exception messages)\nseamless-immutable production mode (minified, and runs faster, but doesn't freeze objects or offer helpful exception messages)\n. @dagda1 Did this fix the issue you were having?\n. There's currently logic to do this in some situations: merge determines whether changes were made and then returns the unmodified original object if not.\nThe question here is how far it ought to go in deciding whether any changes were made. It currently considers the example you gave a change because it does referential equality checking to determine that. If instead it did deep (value-based) equality checking, it would realize that this was not actually a change and you'd get the result you were hoping for. :smiley: \nThis isn't yet possible because the deepEquals branch hasn't landed, but assuming it had, there's still a tradeoff to consider. Doing this check on every merge can get expensive, especially when merging large data structures. It would probably still unlock a considerable performance boost in the case of shouldComponentUpdate, but could be a substantial performance hit in other use cases.\nMy general feeling is that once deepEquals is in (which has been on the backburner for me, but which mainly just needs tests at this point), merge should use it by default for this purpose, but should accept an optional alternative \"change-detector\" function so you can save yourself from a huge performance hit on large data structures.\n. Yeah, that seems like a good implementation. I'd change the second line to this, though:\njavascript\nif (merger && mergerResult === currentObj[key]) return;\nThat way the conditional can still pass if the value happens to be falsy in both places.\nAs far as merge goals, the goals with deepEquals would be (1) to change the default implementation to use deepEquals for change detection over ===, and (2) to allow users to specify a custom function to do this if necessary.\n. Looks good! A nice first step.\n. This is by design. One of the invariants of the library is that once you invoke Immutable, what you get back is immutable, and continuing to use its methods will only yield further immutable results.\nHowever, since you can pass seamless-immutable's data structures to other JS libraries, if you really want a mutable copy back, you can just pass them to other libraries that are not designed for immutability.\nFor example:\njavascript\n_.map(Immutable([1,2,3]), function() {\n   return React.createElement( \"div\", null );\n});\n// no error\n. map does indeed return a collection of elements which may be completely unrelated to the original elements. However, map is still supposed to return the same type of collection you began with. If you call [].map you get back an Array, if you call $().map you get back a jQuery object, and if you call Immutable([]).map, you get back a seamless-immutable array. This is the standard map behavior.\nI sympathize with the fact that this map implementation doesn't work with React components, because I use seamless-immutable with React and find it annoying that this doesn't Just Work. I manage this annoyance by using _.map when it finally comes time to turn my seamless-immutable arrays into React components, but naturally it would be less trouble in this particular use case if I didn't have to.\nThat said, I don't think it makes sense to couple this library to React, and I don't see a strong case for changing map on its own merits. When libraries start developing implicit dependencies on other libraries, unexpected consequences tend to snowball into unpleasant surprises. I value the simplicity and consistency of this library, and hope to maintain it.\nAs such, I appreciate your perspective, but the current design still makes the most sense to me overall. :smiley: \n. For that example, I would just use concat:\njavascript\n // equivalent to Immutable([1, 2, 3, 4])\nImmutable([1,2,3]).concat([4])\nThe Object and Array methods that do not mutate are still available, although they return Immutable instances instead of normal arrays and objects.\nThe non-mutating array methods seamless-immutable supports are map, filter, slice, concat, reduce, and reduceRight, and for objects just keys.\nDoes that help?\n. Keep in mind that the function map accepts does receive index, so you can just do:\n``` javascript\nvar indexToUpdate = 2, newVal = \"THREE\";\nImmutable([\"one\", \"two\", \"three\", \"four\"]).map(function(val, index) {\n  return (index === indexToUpdate) ? newVal : val;\n});\n```\nAdmittedly more verbose than mutableArray[indexToUpdate] = newVal, but in my experience this hasn't come up all that often.\n. Yeah, it all depends on your use case...for our use case, we haven't encountered any performance problems where the underlying culprit turned out to be using immutable data structures over mutable ones. Of course, you may be dealing with much larger data than we do. :smile: \n. Yeah, merge and without are definitely the most common ways.\nFor the nested case, just use merge to override a to have a new value that includes a new value of b. If you really needed to, you could get fancier with a custom merger, but I've personally had no issues just using vanilla merge.\n. Interesting! Would you mind adding a test case that evilly adds a method to Array.prototype and no longer explodes?\n. Also, you can just run grunt to rebuild both the development and production builds automatically.\n. Awesome - thanks for the fix!\n. This is now released in version 2.4.1\n. Sure enough! Good catch.\nThe solution that comes immediately to mind is to change development mode as follows:\n1. Freeze Dates\n2. Add a list of banned mutating methods for Dates similar to what currently exists for Arrays and Objects, and just do the same banning procedure for Dates.\nThoughts?\n. Fixed by #78 \n. Thanks! One request: mind moving the instanceof check to the end of the conditional instead of the beginning? It's the least likely of the three to pass, after all.\n. Awesome! Thanks for the fix.\n. We talked about adding a way to support opting in but it's very low on my priority list at the moment. :smiley: \nIf you wanted to make a Pull Request for that, though, I would definitely be open to it!\n. Yeah, I don't like the idea of breaking current invariants for this.\nHowever, I could see adding a method like this:\njavascript\n// Takes an array of allowed prototypes, and returns a new version of `Immutable`\n// which will preserve those prototypes when it encounters them.\nImmutable.withPreservedPrototypes\nThen you could just go:\njavascript\nvar Immutable = require(\"seamless-immutable\").withPreservedPrototypes([ ... ]);\n. Hm...what would a code example look like with this in action?\n. I think a cleaner approach would be:\n1. Have Immutable accept a second argument for options, like merge does (this would be a breaking change, as currently it assumes if it gets multiple arguments you want an array; I'm fine with that breaking hange)\n2. If it gets a second argument of {prototype: foo} then use foo as the prototype for the resulting object.\n3. Add a method instantiateEmptyObject() (in the same way the other custom methods are added) and have it either return {} if no prototype was specified, and Object.create(options.prototype) if one was specified.\n4. Have the various methods call this.instantiateEmptyObject() instead of just using {}\nThoughts?\n. To clarify, what I meant by not wanting to break current invariants is just that there'd be no chance any existing uses of Immutable would suddenly \"play by different rules\" and possibly introduce surprising bugs.\nI'm okay with a breaking API change, though, especially for something that I suspect is not used very often. :smiley: \n. Thanks! I saw it but haven't had time to take a proper look because it's crunch time at work and I'm swamped.\nI'll definitely try to take a look this week!\n. Not sure I follow the question - we just use process.env.NODE_ENV in the source to  hook into envify when generating the production and development builds.\nI can totally see explaining how that works in the source, because I can see how that would be unclear. Is that what you are referring to?\n. I still don't quite follow. This is how you do it for Node in general, but in the specific case of seamless-immutable, it's only used by envify when building the development and production builds.\nYou won't see NODE_ENV in the outputted development build or production build, because envify strips it out. Does that clarify?\n. Thanks for clarifying! A few thoughts:\n1. The current source can't be used in development or production on a normal web page, as until envify has been done, references to process.env will still be around waiting to break. So I don't think that's the right default at the moment.\n2. Not everyone needs the performance optimizations provided by \"prod mode,\" but this is a library built around strong guarantees of immutability, so I think the default should be that those strong guarantees are enforced. They are enforced in the development build, but not in the production build, so I think the development build is the better default.\n3. I haven't looked at that part of React's source, but I'm guessing they code defensively around process.env so that things won't break if envify hasn't been run. I'm open to that approach so long as the post-envify, post-uglify production build doesn't end up with any lingering unnecessary checks as a result. This isn't a priority for me, but a PR would certainly be welcome!\n. Sounds good! :+1: \n. This looks great! Two things before merge:\n- I had one minor inline code suggestion\n- Let's document the prototype option in the README\nOther than that, really excellent work! :tada: Sorry I took so long getting to reviewing it.\n. No plans, sorry! :smiley: \n. We actually discussed this at length over on https://github.com/rtfeldman/seamless-immutable/issues/25 - have a look!\n. I'd do what @robjens suggested! :+1: \nHappy to accept a PR adding this technique to the README, but closing this issue in the meantime. \n. @wesleytodd Instead of doing a = Immutable(a.asMutable().push(val)), I would do a variant of what @jokeyrhyme suggested:\njs\na = Immutable(a).concat([4])\nThe main reason I went with the \u201cexplode when you try to mutate\u201d design was to avoid pernicious bugs when changing over previously mutable code to use Immutable. This way if you ever forget to change something over from the old style to the new style, you'll at least get an error!\nAs far as adding a separate set of methods to add this functionality, I like keeping the API intentionally simple, and I don't think something like Immutable(a).afterPush(4) is enough added convenience over Immutable(a).concat([4]) to justify adding it.\nThanks for the spirited discussion! You folks are excellent. :smiley_cat: \n. Nope! Just hadn't had time to take a look at it. Now I feel bad because it's a one-line change that wouldn't affect our build process and sounds like it would improve yours.\nThanks!\n. Sorry I took so long to respond to this.\nI totally understand the idea here, but to me the invariant that calls to Immutable() consistently result in values that are immutable is more important than this convenience of not having to call .asMutable() or use something like _.map. I think the value of API consistency wins here.\nThanks for raising this point, and for the discussion, but I'm going to close this just to be totally clear on where I stand on this: calls to Immutable() should always return values that are immutable.\n. The development build definitely cannot work in IE8 because IE8 does not support Object.freeze. I can't think of any reason why the production build would not work, however.\nI don't personally have the bandwidth to test this, but if someone else can verify this, I can update the README to note that the production build works in IE8.\n. Thanks @lewisje - sounds like the resolution here is that it can't work.\n. Hm, I don't quite follow the case where this could cause a problem for seamless-immutable.\nCould you show a code example where this would lead seamless-immutable to behave undesirably?\n. Thanks for figuring out the right path forward on this!\nI used this idea to make an envify-friendly version of this PR (notice there's no diff in the production build; envify builds things such that the compiled output will lead minification to strip out the comparison of one string literal to another), instead of keeping this check around in the production build.\nI'm going to close this, but thanks again for demonstrating how to solve this!\n. Happy to accept PRs for these! I believe @jlongster may have already made some progress on this?\n. Closing thanks to https://github.com/rtfeldman/seamless-immutable/pull/69\n. There isn't currently. I haven't tried making a custom PropTypes immutability checker, but if it can be done concisely without bringing in React as a dependency, I'd be open to a PR to add it!\n. That could work with objects, but not with arrays; they need to be instanceof Array in order to be backwards-compatible with normal arrays.\nI'm open to adding a helper function intended to be used with React (as long as it doesn't necessitate a React depdendency!) but I don't want to add an extra step to the creation of every single object - even for people using seamless-immutable outside React - for the sake of a React convenience, if that makes sense.\n. I'd have been open to this back in the 1.0 days, but I can't justify a breaking change like this now that we're at 4.0. :)\nSorry!\n. Thanks!\n. Generally looks good! Sorry I took so long reviewing it.\nI left a couple of comments, and there's also a merge conflict to resolve.\n. Thanks for this! :tada: \n. Thanks for bringing this up!\nUnfortunately, there would be a significant performance cost to enabling this; merge would have to keep track of whether any modifications had been made, and inspect every current value before merging along the way.\nI don't think the performance overhead is worth making this work.\n. Hm, sure enough! It looks like we're already doing this and incurring the performance cost, so I guess it's empirically not a performance problem. :laughing: My bad!\nI'll look into this.\n. Fixed and published as 4.0.2. Thanks for reporting this @tusharmath, and sorry I didn't look far enough into it the first time around!\n. @zuk can you open a separate issue for that?\n. Is the proposed solution that the Immutable would hold a mutable object?\n. What I meant was - could there possibly be any other solution to the stated\nproblem besides leaving it as a mutable object?\nOn Thu, Oct 29, 2015, 4:19 AM Tushar Mathur notifications@github.com\nwrote:\n\nI am not sure about this. There could be so many cases where you want to\nstore it as an immutable. Though in this case we don't need it to be\nimmutable.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/72#issuecomment-152150200\n.\n. If asynchronous is a solution, that can already be done; if you pass an immutable instance to Immutable, it just uses the one it's given and doesn't recurse.\n\nAs a next step, I'd suggest trying that (just iterate over the object you're given and recurse asynchronously until you've built up what you need) and see if that solves the problem.\n. Yeah, this is a longstanding known issue - see https://github.com/rtfeldman/seamless-immutable/issues/16#issuecomment-63890477 from 2014 - and I've always worked around it with _.map for React components.\nThere are two high-level ways to address this:\n1. Don't change the prod build behavior, but in the dev build check for this situation and give a nicer error so it's clearer where you need to use the workaround.\n2. Change both dev and prod to support circular references.\nObviously the latter is massively more work, and I'm wary of what the performance implications might be. :smile: \n. yep, I'm gonna go with both #119 and #120 - left some comments on both \ud83d\ude03 \n. https://github.com/rtfeldman/seamless-immutable/pull/119 has been merged and released as version 6.0.0; #120 will presumably be 6.0.1 once it's merged.\n. Fixed and published as 6.0.1! Big ups to @davidblurton for the implementation.\nI'm going to wait about a week before announcing this release, so people have a chance to kick the tires and see if we missed anything. \ud83d\ude38 \n. The production build has all references to NODE_ENV stripped out by envify, so this won't be a concern there.\nIs there a reason you couldn't address the performance concern by using the prod build?\n. Closing now that #75 exists; let's continue discussion there.\n. So it looks like the only way to do this in a way that doesn't result in a regression for prod builds is to use const instead of var and then add a build step for turning the const back into a var for development mode: https://github.com/facebook/react/issues/812#issuecomment-161201458\nThoughts?\n. Closing as stale; feel free to reopen if desired!\n. I'm surprised by this too! Assuming it wouldn't have noticeable performance costs, I'd be happy to accept a PR that fixed this.\n. I'd definitely be open to a pull request for this, but I'm gonna close the issue in the meantime. Thanks!\n. Hell yeah! :metal:\nThis looks awesome! Sorry I took so long getting to this.\n. Hi @nikki93, we actually had this discussion awhile back; here are my thoughts: https://github.com/rtfeldman/seamless-immutable/issues/42#issuecomment-109204580\nThanks for raising this, but it's settled. :smile: \n. Ah. Not sure if I've expressed this elsewhere, but I'm not okay with T containing mutable objects. One of my goals for the library is for you to be able to rely on Immutable things being actually immutable, and allowing any mutable objects inside would break that. :smiley: \n. I like this idea, and I wish I'd thought of it back when I first made the library! (A production-specific build was not on the radar back then.)\nAt this point, though, this would be a monumental breaking change for the sake of a performance improvement it's not clear would make a difference for people using the library today.\nThis seems unlikely to be the right move in the foreseeable future, so I'm going to close this rather than leave it in limbo. Great thought, though!\n. Sounds good! Nice catch, and would love a PR! :+1: \nCan you @-mention me on the PR?\n. Awesome, thanks!\n. @tiil Ah, spoke too soon - test failures. (Apparently I didn't have Travis set up to build PRs - sorry about that!)\nI reverted this on master. Can you address the test failures and make a fresh PR?\n. @tiil I'm surprised this approach fixes https://github.com/rtfeldman/seamless-immutable/issues/82 - would you mind adding a test case to confirm that it's fixed?\n. Thanks! :smiley: \n. Closing as stale; feel free to reopen if desired!\n. This was an early design decision (https://github.com/rtfeldman/seamless-immutable/issues/5) - is there a use case where the current behavior is causing a problem?\n. Love it, thanks @jakubholynet !\n. @InsomniacFury Correct - the production build does not make objects immutable. \nThe idea is that in development you will have used the immutable guarantees to end up with code that does not mutate anything, and by the time you reach production, the guarantees are implicit by the code you've written, and no longer need to be enforced.\nIf you want stronger guarantees in production, there's absolutely no reason you can't keep using the dev build. In fact, when the library was first released, the dev build was all there was! :smiley: \n. @InsomniacFury Just that it does extra work on instantiation - namely freezing and banning methods.\n. Is there a common use case this makes nicer? I like to keep the library as simple as possible, so my default is not to add new functionality unless there's a strong motivating case for it. :smiley: \n. Okay, I'm on board. Happy to accept a PR for this!\n. Implemented! Will release as 5.1.0 once cross-browser tests pass.\n. Hi @ryanfields and @bholloway,\nYou want to use either the development build or the production build - the source build, which has process in it, should not be used in the browser.\nSorry if that was unclear! :smile: \n. A PR would be great!\n. Oh weird. Thought I did that. Probably a good idea, yeah, but ultimately something I ought to do.\n. Published as 5.0.1.\n. Thanks @crudh!\n. Appreciate the suggestion, but one of the design goals for seamless-immutable is to free yourself from worrying about whether anything you pass to Immutable will be mutated; it simply won't be. The production build being \"all or nothing\" means you should only use it when you're confident enforcement wouldn't have done anything anyway.\nThis change would make it so you'd instead have to start thinking about when enforcement applied on a case-by-case basis, and avoiding that is important to me.\nThanks for the idea, but I'm not open to changing the current behavior on this. :smile: \n. > Also, I would like to add your library has helped provide ~85% performance gain for operation I am employing it for. :+1:\nAwesome, glad to hear it! :smile_cat: \n. So to clarify, the request is for a new seamless-immutable.development.min.js file, which is a minified version of seamless-immutable.development.js?\n. I'm worried this will create confusion as to which version to use in which circumstance. All the other use cases I'm aware of have been either folks using the existing production build, or else the development build run through their own minification process.\nI realize it would be convenient for your use case, but I would rather keep this simple: use the development.js build for development and the production.min.js build for production. Apologies!\n. Thanks for the idea, but I prefer minified files to be as small as possible, including removing comments...and I'm not super worried about license enforcement. :smile: \n. Good call! Link to the license seems reasonable; that's only a few extra bytes. Would happily accept a PR for that! :smiley: \n. Old tests pass for me too.\nLooks great, thanks!\n. @jakubholynet Hm, appears that tests are breaking in Firefox. I fixed some linter errors in the hopes that's all it was, but it appears to be more than that.\nMind taking a look?\n. @jakubholynet They are still broken, as far as I can tell. If you run npm run zuul-local and then visit the address printed to the console in Firefox, it will run the tests!\n. Ended up getting things fixed. Thanks for the PR! :smile_cat: \n. Fair enough. Happy to accept a PR for this! :smile: \n. Ha, that's what I get for copy/pasting. :grin: \nThanks!\n. Please do! :D\n. Closing in favor of that PR.\n. So I started setting up semantic-release and it wants my npm username and password. I'm not comfortable providing those. Know of any way around that requirement?\n. Hm, the thing I'm not comfortable with is giving away access to my npm account. I didn't realize this entailed that, to be honest. Is there no way around that?\n. @tusharmath sorry I didn't follow up about this, but unfortunately this is still a deal-breaker for me:\n\nThe token gives your CLI the ability to do things like publish and unpublish packages, and manage owners and teams.\n\nI'm like the idea of auto-generating changelogs, but I'm not willing to give this level of permission to a third-party tool for that convenience.\nI really, really appreciate your work on this, but I don't think I'm going to be able to finish the steps necessary for this to happen.\n. Yep, this is working as intended. Thanks to all who responded explaining why this works the way it does!\n. It's only being called when the \"production\" environment variable is being set; it's designed to work with https://www.npmjs.com/browse/keyword/envify\nSkipping freezing for the production build is the whole point! :smile: \n. Not without a compelling motivating use case. :wink: \n. Hm, yeah I can't say I'm on board with the idea of adding a redundant concat - I'd definitely recommend using concat for this!\n. Cool - this seems like a good resolution; I'm gonna close this issue, but feel free to open another to discuss specific feature requests!\n. Hm, this would be a performance regression given that call and apply are significantly slower than direct invocation.\nWas there a reason the Object.getOwnPropertyDescriptor approach discussed in #76 wouldn't work?\n. @lzrski hm, looks like build fails on Android: https://travis-ci.org/rtfeldman/seamless-immutable\n. Looks great, thanks!\n. Thanks for taking the time to write this up, but I prefer to keep the API small and compact, so I'd rather not add this. :smiley: \n. Hm...I honestly have not looked into these things enough to know what the problem could be.\n. Cool! Seems like a useful addition. :smiley_cat: \n. Awesome! If @alex3165 if you'd like to open a PR to seamless-immutable to add a link to the typings in our README, I would be happy to accept it.\nThanks for all the hard work on this!\n. No there isn't. :smile: \n. Looks great! Thanks for the level of detail on this. :heart_eyes_cat: \n. @lzrski published as 5.1.1!\n. I see your point, but I honestly don't think this is worth a breaking change to the existing set behavior. I also don't think it's worth adding an additional function, as I prefer to keep the API small, so I think there's just going to be some learning curve if you're coming from Immutable.js :smile: \n. This is because JavaScript objects only use strings for keys, not numbers.\n. JavaScript treats a[1] as the same as a[\"1\"] when a is an object.\n. I honestly don't know. I tend to focus on concrete use cases; is this blocking you on a particular project?\n. People have asked for this before, and it looks like the implementation is simple and well-tested. Thanks!\n. @evgenykochetkov I expect to merge https://github.com/rtfeldman/seamless-immutable/pull/119 soon and will release once that's in.\n. Actually, never mind - that one is a breaking change, and I think giving this its own minor version bump is worthwhile. Released as 5.2.0!\n. No reason except that I don't use AMD. Happy to accept a PR! :smile: \n. Thanks for the question! I'm not sure what this would mean in the context of an immutable library, though; the original object never changes, so I don't think those handlers would ever file. :smile: \n. I'd definitely publish as a separate package. I'd like to keep the core decoupled from extras where possible. \ud83d\ude04 \n. Lovely, thank you! \ud83d\ude3b \nTwo minor suggestions:\n1. Could you refactor level to be stackRemaining and decrement instead of incrementing? (Default to 64 instead of 0, and error when you reach 0.) That way if someone genuinely does have something that needs 65 stack frames, they can opt into upping the limit with an intuitive API.\n2. Could you add something to the README documenting this?\nThanks so much for this!\n. Beautiful! \ud83d\ude3b  Thanks so much @shamrin!\n. \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 Thanks a ton @davidblurton!!!\n. Sure, makes sense to me! \ud83d\ude03 \n. Released in 6.1.0. Thanks again @ericclemmons!\n. This seems like a \"here there be dragons\" case. What's the motivation here? Why is this needed?\n. > Call methods of immutable objects and its properties to analize saved states.\nWhy do those need to be methods? Why not implement them as standalone functions that accept the immutable data as arguments?\n. Sorry, but it seems like the right answer here is to stick to using Immutable values as plain old data, which makes great sense to me. I'm gonna close this.\nThank you for the discussion!\n. Why not just transform the argument before calling Immutable on it?\n. This use case seems too narrow to justify the added complexity, sorry!\n. new Immutable seems better, assuming it can be done in a way that doesn't break stuff (not sure which tests are failing, and whether it's the test's fault or the new logic's fault \ud83d\ude09 )\n. Oh right...if you use new, you have to get an object back; it can't return plain strings, numbers, null, etc. - all of which are currently supported (and passed through unchanged).\nLet's just go with \"from\" after all haha\n. Looks good! Last request would be a quick mention in the README. \ud83d\ude38 \n. Lovely, thank you! :smile:\n. @ericclemmons published as 6.1.0!\n. > I realize that a feature that would allow this sort of nested mutation might go against the philosophy of this module, but I thought I'd suggest it anyway :smile:.\nAs you predicted, I'm not open to introducing mutations. \ud83d\ude09  Appreciate the thoughtful post though!\n. Those benchmarks are using seamless-immutable's development build (they must be, since the prod build wouldn't pass the tests he posted), and the development build goes out of its way to freeze things and bans mutating methods.\nThe production build doesn't do these things. It's very close to \"using plain old arrays and objects\" in terms of performance, and I don't feel like trying to do better than that is a good goal for the library. \ud83d\ude04 \nThanks for the post!\n. That's cool! @guigrpa I appreciate your showing your work. \ud83d\ude38 \n. Seems reasonable as long as it's only for numbers. Calling String.valueOf on e.g. null would seem more likely to mask errors than avoid them.\nI'd gladly accept a PR for this! \ud83d\ude04 \n. Fixed by https://github.com/rtfeldman/seamless-immutable/pull/158\n. Gotcha...I think a feature request for \"avoid clobbering existing fields\" makes sense.\nWant to open one? \ud83d\ude04 \n. Thanks for your work on this @lzrski!\nLooking at this implementation, I think something like #81 is the right solution to #130. One problem with this approach is that you'll get opposite behavior in development builds compared to production builds; in development mode, your property gets added with no problem, but in production mode, it gets overridden! This is error-prone to say the least. \ud83d\ude09 \n81 seems to be the best solution to this (assuming it can work; seems like there might be issues with arrays, but not sure without experimenting), and that seems like the right path to go down here.\nThanks again!\n. Looks great, thanks @kalafut!\n. No plans, but seems plausible.\n. I just looked into this in more depth and I realized it should be closed as a duplicate of https://github.com/rtfeldman/seamless-immutable/issues/124\n. Done! Sorry for the oversight. \ud83d\ude05 \n. I considered it, but I don't think this makes sense from a design perspective.\nI think it's important that the contents of a seamless-immutable value be actually immutable unless there are extremely good reasons for them not to be. The more exceptions to that rule that exist (currently Dates, functions, and React components - all for specific practical reasons that come up very often), the harder debugging gets.\nConsidering almost everyone either uses Immutable.js or seamless-immutable, not both at once, I don't think this comes up anywhere near enough to justify special-casing.\nThanks for bringing it up though!\n. Closing since https://github.com/cdnjs/cdnjs/pull/8579 has been merged. \ud83c\udf89 \n. This has been pending changes for about two months, so I'm going to close it as stale.\nPlease feel free to reopen with those changes! :). @lelandmiller really sorry I took so long getting to this! Looks good to me.\nIf you can resolve the merge conflicts I'll merge and publish this.\n. There is now! See https://github.com/rtfeldman/seamless-immutable/pull/158\n. This seems worth special-casing in the same way we currently do with Dates.\n. The only breaking change was cycle detection...so you're almost certainly fine to upgrade. \ud83d\ude04 \nhttps://github.com/rtfeldman/seamless-immutable/pull/119\n. Seems reasonable, and deep-equals seems like a trivially small dependency to add.\nIf you wouldn't mind resolving the merge conflicts, I'd be happy to merge this!\n. @tommoor FYI @variant77's fix has been merged and released as 6.1.2!\n. Looks good! So sorry for the delay in merging this @variant77!\n. Released as 6.1.2 @brunolemos @variant77 \n. Feel free to open a PR, but I don't think this is worth tracking as an issue.\n. @marbemac don't worry about the dist files; I always rebuild them before publishing. \ud83d\ude04 \n. @marbemac can you reset the dist files to what's on master and push that to resolve the merge conflict?\n. Thanks @marbemac! Published as 6.1.3.\n. > I still think this is a valid issue\nI respectfully disagree. \ud83d\ude42\nFrom the original:\n\nA .merge with {deep: true} of two identical objects that contain an array is returning a new object.\n\nI expect that changing this behavior would be a serious performance regression. You would have to do comparisons at every single step of the merge, to check whether anything had changed. That is not free, and we should not act as though it were!\n. @qzb that's only in there so that the development and production builds can be built using envify - once the builds are complete, that variable will be gone.\nIf you use either the development build or the production build, process should not be there, and you should be all set! \ud83d\ude03 \n. Great, thank you @lelandmiller!\n. Released as 6.1.4! \ud83c\udf89 \n. Wow, this looks great @saivann! \ud83d\ude3b Thank you so much!\n. Lovely, thank you!\n. After a lot of thought, I don't think outright migrating to this syntax is the right move. I think it would be better to make this opt-in, for example:\njs\nvar Immutable = require(\"seamless-immutable\").static;\nMaking this give you a new version of Immutable that doesn't override methods seems like the best way to go. It preserves backwards compatibility and would be easy to opt into.\nWhat do you think?. @saivann This is great! \ud83d\ude0d Thank you so much!\nMy only request would be to simplify it to just:\njs\nvar Immutable = require(\"seamless-immutable\").static;\nI don't anticipate adding more configuration options later, so having an init function feels like overkill.\nSound good?. @saivann Thanks! I'm going to pair this with #177 and release as 7.0.0. Released as 7.0.0.. Great, thanks @8balloon!. > Sorry if this isn't the right forum. Not sure where else to ask as this is an esoteric issue.\nSorry, but it's not the right forum. \ud83d\ude42\nI'd try StackOverflow!. It's done this way for people using seamless-immutable on Node: it respects Node's production flag automatically, whereas in the browser you can load whichever is appropriate.. > As a side note, would be nice to have some more common structure for production builds, like dist/seamless-immutable.js (production version) and dist/seamless-immutable.min.js (production minified version).\nWe already have that, except it's at the project root rather than in a dist/ folder. \ud83d\ude42\nArguably a dist folder would be a slightly better place to put them, but I don't think that slight improvement is worth breaking everyone's builds the next time they upgrade.. The third option is sticking with the status quo, which seems to have the fewest downsides.. Great, thanks @nazar-pc!. This would defeat the purpose of envify, which is the whole reason those are in there. It gets compiled out of the production build, which is what's supposed to be used in the browser instead of the source.\nDoes https://github.com/rtfeldman/seamless-immutable/pull/165 resolve this?. Thanks @krzysztofpniak!. I'See https://github.com/rtfeldman/seamless-immutable/pull/160. Happy to accept a PR for them!. Thanks @sbalay!. Nice, thank you @thomasdashney!. I've never used the browser field but it seems reasonable. I assume Webpack/Browserify/etc will respect this as the default.\nIf so, do they permit overriding it? In other words, is someone going to have a harder time using seamless-immutable with one of those build tools if this field exists?\nAlso, this should definitely point to the development build. That's the safer default because it actually takes steps to enforce immutability. People should opt into the \"safety features removed\" prod build if they need the perf boost.. > As for development build - well, you can't point there right now (see #166).\n166 is about the source build, not the development build. \ud83d\ude42\nThe development build does not contain any search results for \"process\".\nThe webpack docs suggest browser would take precedence in webpack. They also mention that there is a way to override that, so I'm okay with this as long as it points to the development build instead of the production build.. > In my opinion something that goes into build system should be production, since artifacts will likely be used in production. While those who need development version can still manually specify what they need explicitly.\nThat makes sense if there's no difference between development and production, but that's not true here.\nThe production build improves performance by removing the safety checks that make the immutable invariants work, under the assumption that people would have caught any problems in development. That's only a reasonable assumption to make if people have been using the development build by default, which means it's important that the production build is opt-in, not the other way around.\ntl;dr Making the production build the default would be dangerously irresponsible and I'm not going to do it. \ud83d\ude42. @nazar-pc yep, please do!. Thanks @nazar-pc!. @saivann I pushed what theoretically seems like a fix for that credentials complaint.\nThat said, if you can get all the tests passing locally on Lodash 3.10, that should be good enough. \ud83d\ude42. I need a lot more information than this.\nPlease feel to reopen with a description that someone can act on. \ud83d\ude42. What happens if you go into node_modules/seamless-immutable/package.json and delete the \"browser\": entry?. Hm, ok - what if you leave the browser entry there, but add another entry that's exactly the same as the browser one except it says \"react-native\" instead of \"browser\"?. @messense please reopen if 7.0.1 doesn't fix this!. Thanks!\nHowever, I don't understand why the source works but the development build fails. I'd like to understand this fix better before applying it...what is it about the development build that react native rejects it?. @jgkim ah, got it!\nIn that case, it seems like it would make more sense to fix this by removing these from .npmignore:\nseamless-immutable.development.min.js\nseamless-immutable.development.js\nseamless-immutable.production.min.js\n...and then having both react-native and browser point to the development build.\nWhat do you think?. Yeah maybe main should be node?\nI think since we know about react-native it makes sense to include it alongside browser, just to be explicit.. @jgkim If you make those changes above, can you rebase on top of master? I pushed (what ought to be) a fix for Travis builds getting credentials errors on PRs.. Thanks @jgkim!. \ud83d\udc4d to adding Immutable.sortBy (statically, not as an override - I want to preserve the \"don't surprisingly change mutable methods to be non-mutating\" behavior) if anyone wants to make a PR!. Great, thank you @dentrado!. Thanks!. It was closed without comment because it was opened without a description. The title was \"Expose isImmutable method,\" which is not much to go on considering the method is already exposed. I didn't want any contributors to waste their time trying to guess what you wanted, so I closed it.\nI don't know what \"Was using the method on the wrong immutable library\" means, but I opened https://github.com/rtfeldman/seamless-immutable/issues/192 about the missing documentation. \ud83d\ude42. Thanks @arthur31416!. @dentrado Thanks! Would you mind adding a test to cover the behavior of rejected promise values?\nAlso, no need to check in the built files; I'll do that before publishing the next release. \ud83d\ude42. Out now! 7.1.0. Lovely, thank you @mbjurman! \ud83d\ude0d . Thanks @ryantemple!. > notice that in es6 this has finally been admitted into the language and is no longer considered a bad practice to my best knowledge\nUnfortuantely not.\nMore to the point, I appreciate the effort here, but I'm not okay with this from a design perspective. I think consistency of immutability is the right default, and making it so that prototype comes along by default means that it's super easy to call Immutable on something and be surprised that it's not actually immutable (because the prototype methods access mutable state).\nI'm okay allowing this on an opt-in basis, but I am not okay with making it the default.\nSorry you spent so much time on this! \ud83d\ude05 . There are not, but any normal linter should work with it just fine!. According to the docs, blobs are immutable.\n\nA Blob object represents a file-like object of immutable, raw data.\n\nThis suggests we should be able to treat them as such, just like how we currently treat strings!. It's because merge creates a new object. They may have the same contents, but they won't be reference equal (===) \ud83d\ude42. Thanks @dentrado!. Published as 7.1.1. @LukeusMaximus should be fixed in 7.1.1. Nice catch - thanks @felipeptcho!. Seems reasonable!. @lukewestby published as 7.1.2. Thanks @fobos! Sorry I missed this.. Thanks @madnight! . I wouldn't want to confuse people; Object.is only differs from === in the specific cases of NaN, 0, and -0 (and handles object comparisons in the same way as ===), whereas the deepEquals I'm referring to would compare the contents of objects, like what Underscore's _.isEqual does.\n. @Aetet I have a WIP branch that implements it, but needs a bunch of tests before it can go on master. I haven't had time to work on it, and realistically won't in the near future.\n. There doesn't seem to be much demand for this, so I'm going to close this for now.\n. Which function are you referring to?\n. Ah. Fair point...I don't especially care one way or the other. Any other opinions on this? @raorao?\n. I agree about \"constructor in spirit\" (which was why I named it that way.)\nActually it just occurred to me that this seems easily solvable by the library end user, e.g. var immutable = require(\"seamless-immutable.js\") - although @mvolkmann please feel free to correct me if I'm missing something. :smiley: \n. Well, it's just as easy if you use RequireJS, Browserify, Webpack, Node, etc. - and of course if you're just attaching it to window, you can always go window.immutable = Immutable, so I think that's frictionless enough that this is worth closing.\nThanks for pointing this out!\n. Clarified the comment in b90a14a61e76c54d01347aec581d226f3df59112\n. Awsesome!\nThe best practice I've seen (which is what React does) is to make it envify-friendly.\nBasically you do this:\nif (process.env.NODE_ENV === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\n...then run envify on it twice, once with {NODE_ENV: \"development\"} and once with {NODE_ENV: \"production\"} to get two output files: seamless-immutable.development.js and seamless-immutable.production.min.js\nIn the development build, envify will replace the above with this:\nif (\"development\" === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\n....whereas in the production build, it will instead replace it with this:\nif (\"production\" === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\nUglify will then see that this conditional will always fail and will strip this code out entirely, meaning the production build will not only avoid adding the extra attributes, it won't even run any conditionals to tell if it's in prod mode!\nThis implicitly means we'd need to introduce a build process to generate the two different files for library consumers.\n. That makes sense to me. Let's not check in changes to the compiled files on every commit, though, as that will make the diffs miserable.\nInstead just leave them out of normal commits, and once per release I'll include updated compiled files in the commit that bumps the version number.\nSound good?\n. Wow, this is awesome! Thanks so much for doing this. Makes it pretty clear that prodMode would make a big performance difference.\n. Thanks for your awesome work on this @crudh! I'm going to close this issue now that we have some benchmarks, but will tag #6 to remember this is worth revisiting once Prod Mode exists.\n. Yep, it should be deeply immutable. This is a bug. The guarantees of immutability are important to maintain...I'll fix this in a jiffy. Thanks!\n. Oh nice! I think this should be a very inexpensive check to do...I'll take a crack at it real quick.\n. Changed in c7887bbb4b0bcb6141dbc32aafde72869b505883\n. Fixed in https://github.com/rtfeldman/seamless-immutable/commit/c7887bbb4b0bcb6141dbc32aafde72869b505883\n. Just that it's time-consuming both from an implementation and from a performance perspective. It would entail building up an intermediate data structure just to track where things need to end up, then converting that back into a cloned object with references appropriately reconnected...\nThis came up because I accidentally called Immutable on a React component (which contained a circular reference), and it just threw a stack overflow, which made it harder to figure out what I'd done wrong. As soon as I realized the root cause, it was easy to fix, so having a check that results in an exception is all I need to avoid that particular issue in the future. :smile: \n. That said, if it's something someone actually needs, I'm not aware of any reason it couldn't be done.\n. Great point! It could also then console.error(object) so you could actually see the problematic object in question.\n. Resolved by https://github.com/rtfeldman/seamless-immutable/pull/119\n. Currently no plans for cursors, sorry!\n. Indeed!\n. I dig it! Test duplication is no problem, but from an API perspective I'd prefer if this were an optional boolean passed to merge to enable deep merging.\nWould love to see a Pull Request for this. :+1: \n. Good points all around. My preference is to change the existing merge as follows:\n1. It now always takes exactly one or exactly two arguments.\n2. The first argument works the same as always: you can pass it one object to merge, or an array of them.\n3. The second argument is optional, and is a configuration object that currently supports only {deep: true}\nSound good?\n. Looks great! Thanks for adding this.\n. I haven't come across this use case yet, but it turns out you can already do this pretty cleanly with asMutable:\n``` javascript\nvar item = Immutable({name: \"bob\"});\n// new Item is immutable, obj is mutable\nvar newItem = (function(obj) {\n   obj.name = \"henry\";\n   return obj;\n})(item.asMutable());\n```\n. @seanhess Seems like this would address your use case, yeah? :smiley: \n. True! Fixed:\n``` javascript\nvar item = Immutable({name: \"bob\"});\n// new Item is immutable, obj is mutable\nvar newItem = (function(obj) {\n   obj.name = \"henry\";\n   return Immutable(obj);\n})(item.asMutable());\n```\n. Glad it was helpful! :smile_cat: \n. I considered it, but the trouble is that doing this can mask bugs. For example:\n``` javascript\nfunction foo() {\n  var array = [3, 1, 4];\narray.sort()\nreturn array;\n}\n```\nIf you change that first line to be Immutable([3, 1, 4]), what should happen?\nCurrently array.sort() throws an exception, letting you know that some code that made sense with a mutable array no longer makes sense. If instead array.sort() just returns a sorted, immutable array, then now an unsorted array will be returned here, and you have a bug to track down - a potentially nasty one, if there is a lot of logic surrounding this code.\nI prefer this API because you can take an immutable array and write any number of helper functions that return sorted ones, but the only way to make bugs like this easy to find is to override the mutable methods to throw an exception. :smiley: \n. Thanks @alanhogan! :blush: \n@dariocravero Generally I'm using Underscore functions like _.sortBy and just calling Immutable on the result. No need to call .asMutable() in that case!\n. @tylercollier Good news! :smile_cat: https://github.com/rtfeldman/seamless-immutable#performance\n. Ahh got it, yeah that's correct. Sorry for the confusion!\nThat said, I'd honestly rather not add that complication to dev mode. :x\n. Nice catch! Thanks for fixing this.\n. This is because currently seamless-immutable does not copy over prototypes, and as such always returns a vanilla Object.\nCopying over prototypes is a bit of a double-edged sword. Something like .toISOString() should work as normal on an immutable object, so there's not much downside there. However, other methods might attempt to mutate the object and then fail silently (depending on whether Strict Mode is enabled). There's an element of \"buyer beware\" to copying prototypes.\nThat said, I suppose there's not much difference between deciding to use a prototype with mutating methods and just attempting to mutate an immutable object yourself, so  on balance this seems like a reasonable change to make. At the very least, it ought to address the proximal issue of Date.toISOString becoming unavailable.\n. Upon further investigation, there are pitfalls to the prototype-only approach. For example, Date (the motivating example, no less!) won't actually work as intended using this approach, because of how Date stores its internal data.\nIn light of that, I'm leaning toward this not being a good idea after all. It seems like it could lead to surprising bugs, where you can call most methods on most prototypes and have everything work as expected, but good luck tracking down the first bug that comes up because a prototype method relied on a non-enumerable hidden member...\n. That seems totally reasonable, yeah. We already do an instanceof check for Array, so we could certainly do another for Date and handle as appropriate.\n. Resolved by #31\n. The core issue with prototypes is https://github.com/rtfeldman/seamless-immutable/issues/25#issuecomment-92147785 - specifically, that there's no way to detect whether prototypes are relying on hidden properties, which cannot be discovered and cloned. The resulting bugs could have really nasty symptoms to identify; things as vague as \"the cloned version doesn't quite work the same way as the original for some reason.\"\nI could see offering a workaround similar to custom mergers, where you could pass a custom cloning function as an argument to Immutable(), and within that do whatever you like  (at your own risk, of course) with regards to prototype and anything else.\nThen if you wanted that prototype behavior everywhere you could just set Immutable to be some function that wraps the original Immutable() with a call that always passes your custom cloning function.\nThoughts?\n. Cool. This is admittedly not a high priority for me in terms of implementation, but I'm on board with the approach! :smiley: \n. :+1:  Makes sense...giving it another optional parameter is no big deal since it no longer accepts varargs, and the performance impact should be trivial (one extra conditional per iteration) in the normal case.\n. Excellent! Thanks for the fix.\n. Nah. The point of merge is to replace fields with fresh values, not (necessarily) to expand on existing values.\n. I dig it! Looks good.\n. Looks great!\nOnly one request: it should be pretty easy to parameterize the tests such that they check both the dev and the prod builds...something like this:\n``` javascript\n[\n  {buildName: \"development build\", src: \"../../seamless-immutable.development.js\"},\n  {buildName: \"production build\",  src: \"../../seamless-immutable.production.min.js\"}\n].forEach(function(config) {\n  var Immutable = require(config.src);\n// ...other requires go here\ndescribe(config.buildName, function() {\n// ...all the current tests go here\n\n});\n});\n```\nThanks a ton for doing this! Really excellent work. :smiley_cat: \n. This is fantastic! Love it. :heart_eyes_cat: \nThat approach with TestUtil seems totally fine.\n. Looks great! Nice and straightforward.\n. Looks like there are some cross-browser test failures: https://travis-ci.org/#L600\nPossibly new Date(dateObject) doesn't pass through time zone in all browsers?\n. If you don't mind, a new PR would be great. :smiley: \n. Seems it's not just .toISOString()! IE now reports different .getTime() numbers: https://travis-ci.org/rtfeldman/seamless-immutable#L616\nMaybe using a different constructor is in order?\n. Yep! Want to make sure the build is green before I bump the version to 2.3.1 and do a prod build. :smiley: \n. Ah, good point! No it won't. Updated in 1ccdc276875ef3b09ac2e1071dc7a907e17fa7f9\n. All set! :+1: \nThanks for the fixes!\n. Makes sense!\n. @crudh Unless this is urgent for you, I'm going to wait to cut a new release for this, because @raorao has some work to address https://github.com/rtfeldman/seamless-immutable/issues/16 using your proposed solution coming soon.\n. Yep, @crudh's explanation is exactly the reason behind banning the mutable methods. If there were a desire to add an alternative to concat for single elements, I'd call it something else, like append.\nA separate question is whether a method like that is worth adding to the API. Is there a common use case where this would be a significant upgrade over concat? I have not encountered any yet, and I'm hesitant to expand the API without strong motivating use cases because that's how libraries get bloated. :smile: \n. This is now fixed more efficiently by https://github.com/rtfeldman/seamless-immutable/commit/af6a8dfd7e2f1939e5108aae118b9270cb9bff3a\n. From reading icepick's description, it looks like both libraries are doing the same thing at a high level: providing immutable data structures that are backwards-compatible with vanilla JS arrays and objects, and which intelligently do shallow rather than deep cloning because shallow yields equivalent results for immutable data structures. \nIt looks like the main differences are:\n- seamless-immutable has higher test coverage\n- seamless-immutable has an optional production build that doesn't actually freeze the objects, which runs faster\n- each library has its own set of convenience methods\n. I'd rather keep the README focused, but now it's easy enough to link someone with the same question to this discussion! :smile: \n. Hm...seems to work fine in a Node REPL:\n``` javascript\n\nvar Immutable = require(\"seamless-immutable\")\nundefined\nvar array = Immutable([\"foo\", \"foo2\", \"bar\", \"bar2\", \"baz\", \"baz2\"]);\nundefined\narray\n[ 'foo', 'foo2', 'bar', 'bar2', 'baz', 'baz2' ]\n```\n\nMy first guess would be that Ember modifies Array.prototype in some way that is incompatible with seamless-immutable...do you know if that's something Ember does?\n. @dagda1 This is happening because you're importing the seamless-immutable source, not the compiled version (which has process stripped out). Try importing one of these instead:\nseamless-immutable development mode (with freezing and helpful exception messages)\nseamless-immutable production mode (minified, and runs faster, but doesn't freeze objects or offer helpful exception messages)\n. @dagda1 Did this fix the issue you were having?\n. There's currently logic to do this in some situations: merge determines whether changes were made and then returns the unmodified original object if not.\nThe question here is how far it ought to go in deciding whether any changes were made. It currently considers the example you gave a change because it does referential equality checking to determine that. If instead it did deep (value-based) equality checking, it would realize that this was not actually a change and you'd get the result you were hoping for. :smiley: \nThis isn't yet possible because the deepEquals branch hasn't landed, but assuming it had, there's still a tradeoff to consider. Doing this check on every merge can get expensive, especially when merging large data structures. It would probably still unlock a considerable performance boost in the case of shouldComponentUpdate, but could be a substantial performance hit in other use cases.\nMy general feeling is that once deepEquals is in (which has been on the backburner for me, but which mainly just needs tests at this point), merge should use it by default for this purpose, but should accept an optional alternative \"change-detector\" function so you can save yourself from a huge performance hit on large data structures.\n. Yeah, that seems like a good implementation. I'd change the second line to this, though:\njavascript\nif (merger && mergerResult === currentObj[key]) return;\nThat way the conditional can still pass if the value happens to be falsy in both places.\nAs far as merge goals, the goals with deepEquals would be (1) to change the default implementation to use deepEquals for change detection over ===, and (2) to allow users to specify a custom function to do this if necessary.\n. Looks good! A nice first step.\n. This is by design. One of the invariants of the library is that once you invoke Immutable, what you get back is immutable, and continuing to use its methods will only yield further immutable results.\nHowever, since you can pass seamless-immutable's data structures to other JS libraries, if you really want a mutable copy back, you can just pass them to other libraries that are not designed for immutability.\nFor example:\njavascript\n_.map(Immutable([1,2,3]), function() {\n   return React.createElement( \"div\", null );\n});\n// no error\n. map does indeed return a collection of elements which may be completely unrelated to the original elements. However, map is still supposed to return the same type of collection you began with. If you call [].map you get back an Array, if you call $().map you get back a jQuery object, and if you call Immutable([]).map, you get back a seamless-immutable array. This is the standard map behavior.\nI sympathize with the fact that this map implementation doesn't work with React components, because I use seamless-immutable with React and find it annoying that this doesn't Just Work. I manage this annoyance by using _.map when it finally comes time to turn my seamless-immutable arrays into React components, but naturally it would be less trouble in this particular use case if I didn't have to.\nThat said, I don't think it makes sense to couple this library to React, and I don't see a strong case for changing map on its own merits. When libraries start developing implicit dependencies on other libraries, unexpected consequences tend to snowball into unpleasant surprises. I value the simplicity and consistency of this library, and hope to maintain it.\nAs such, I appreciate your perspective, but the current design still makes the most sense to me overall. :smiley: \n. For that example, I would just use concat:\njavascript\n // equivalent to Immutable([1, 2, 3, 4])\nImmutable([1,2,3]).concat([4])\nThe Object and Array methods that do not mutate are still available, although they return Immutable instances instead of normal arrays and objects.\nThe non-mutating array methods seamless-immutable supports are map, filter, slice, concat, reduce, and reduceRight, and for objects just keys.\nDoes that help?\n. Keep in mind that the function map accepts does receive index, so you can just do:\n``` javascript\nvar indexToUpdate = 2, newVal = \"THREE\";\nImmutable([\"one\", \"two\", \"three\", \"four\"]).map(function(val, index) {\n  return (index === indexToUpdate) ? newVal : val;\n});\n```\nAdmittedly more verbose than mutableArray[indexToUpdate] = newVal, but in my experience this hasn't come up all that often.\n. Yeah, it all depends on your use case...for our use case, we haven't encountered any performance problems where the underlying culprit turned out to be using immutable data structures over mutable ones. Of course, you may be dealing with much larger data than we do. :smile: \n. Yeah, merge and without are definitely the most common ways.\nFor the nested case, just use merge to override a to have a new value that includes a new value of b. If you really needed to, you could get fancier with a custom merger, but I've personally had no issues just using vanilla merge.\n. Interesting! Would you mind adding a test case that evilly adds a method to Array.prototype and no longer explodes?\n. Also, you can just run grunt to rebuild both the development and production builds automatically.\n. Awesome - thanks for the fix!\n. This is now released in version 2.4.1\n. Sure enough! Good catch.\nThe solution that comes immediately to mind is to change development mode as follows:\n1. Freeze Dates\n2. Add a list of banned mutating methods for Dates similar to what currently exists for Arrays and Objects, and just do the same banning procedure for Dates.\nThoughts?\n. Fixed by #78 \n. Thanks! One request: mind moving the instanceof check to the end of the conditional instead of the beginning? It's the least likely of the three to pass, after all.\n. Awesome! Thanks for the fix.\n. We talked about adding a way to support opting in but it's very low on my priority list at the moment. :smiley: \nIf you wanted to make a Pull Request for that, though, I would definitely be open to it!\n. Yeah, I don't like the idea of breaking current invariants for this.\nHowever, I could see adding a method like this:\njavascript\n// Takes an array of allowed prototypes, and returns a new version of `Immutable`\n// which will preserve those prototypes when it encounters them.\nImmutable.withPreservedPrototypes\nThen you could just go:\njavascript\nvar Immutable = require(\"seamless-immutable\").withPreservedPrototypes([ ... ]);\n. Hm...what would a code example look like with this in action?\n. I think a cleaner approach would be:\n1. Have Immutable accept a second argument for options, like merge does (this would be a breaking change, as currently it assumes if it gets multiple arguments you want an array; I'm fine with that breaking hange)\n2. If it gets a second argument of {prototype: foo} then use foo as the prototype for the resulting object.\n3. Add a method instantiateEmptyObject() (in the same way the other custom methods are added) and have it either return {} if no prototype was specified, and Object.create(options.prototype) if one was specified.\n4. Have the various methods call this.instantiateEmptyObject() instead of just using {}\nThoughts?\n. To clarify, what I meant by not wanting to break current invariants is just that there'd be no chance any existing uses of Immutable would suddenly \"play by different rules\" and possibly introduce surprising bugs.\nI'm okay with a breaking API change, though, especially for something that I suspect is not used very often. :smiley: \n. Thanks! I saw it but haven't had time to take a proper look because it's crunch time at work and I'm swamped.\nI'll definitely try to take a look this week!\n. Not sure I follow the question - we just use process.env.NODE_ENV in the source to  hook into envify when generating the production and development builds.\nI can totally see explaining how that works in the source, because I can see how that would be unclear. Is that what you are referring to?\n. I still don't quite follow. This is how you do it for Node in general, but in the specific case of seamless-immutable, it's only used by envify when building the development and production builds.\nYou won't see NODE_ENV in the outputted development build or production build, because envify strips it out. Does that clarify?\n. Thanks for clarifying! A few thoughts:\n1. The current source can't be used in development or production on a normal web page, as until envify has been done, references to process.env will still be around waiting to break. So I don't think that's the right default at the moment.\n2. Not everyone needs the performance optimizations provided by \"prod mode,\" but this is a library built around strong guarantees of immutability, so I think the default should be that those strong guarantees are enforced. They are enforced in the development build, but not in the production build, so I think the development build is the better default.\n3. I haven't looked at that part of React's source, but I'm guessing they code defensively around process.env so that things won't break if envify hasn't been run. I'm open to that approach so long as the post-envify, post-uglify production build doesn't end up with any lingering unnecessary checks as a result. This isn't a priority for me, but a PR would certainly be welcome!\n. Sounds good! :+1: \n. This looks great! Two things before merge:\n- I had one minor inline code suggestion\n- Let's document the prototype option in the README\nOther than that, really excellent work! :tada: Sorry I took so long getting to reviewing it.\n. No plans, sorry! :smiley: \n. We actually discussed this at length over on https://github.com/rtfeldman/seamless-immutable/issues/25 - have a look!\n. I'd do what @robjens suggested! :+1: \nHappy to accept a PR adding this technique to the README, but closing this issue in the meantime. \n. @wesleytodd Instead of doing a = Immutable(a.asMutable().push(val)), I would do a variant of what @jokeyrhyme suggested:\njs\na = Immutable(a).concat([4])\nThe main reason I went with the \u201cexplode when you try to mutate\u201d design was to avoid pernicious bugs when changing over previously mutable code to use Immutable. This way if you ever forget to change something over from the old style to the new style, you'll at least get an error!\nAs far as adding a separate set of methods to add this functionality, I like keeping the API intentionally simple, and I don't think something like Immutable(a).afterPush(4) is enough added convenience over Immutable(a).concat([4]) to justify adding it.\nThanks for the spirited discussion! You folks are excellent. :smiley_cat: \n. Nope! Just hadn't had time to take a look at it. Now I feel bad because it's a one-line change that wouldn't affect our build process and sounds like it would improve yours.\nThanks!\n. Sorry I took so long to respond to this.\nI totally understand the idea here, but to me the invariant that calls to Immutable() consistently result in values that are immutable is more important than this convenience of not having to call .asMutable() or use something like _.map. I think the value of API consistency wins here.\nThanks for raising this point, and for the discussion, but I'm going to close this just to be totally clear on where I stand on this: calls to Immutable() should always return values that are immutable.\n. The development build definitely cannot work in IE8 because IE8 does not support Object.freeze. I can't think of any reason why the production build would not work, however.\nI don't personally have the bandwidth to test this, but if someone else can verify this, I can update the README to note that the production build works in IE8.\n. Thanks @lewisje - sounds like the resolution here is that it can't work.\n. Hm, I don't quite follow the case where this could cause a problem for seamless-immutable.\nCould you show a code example where this would lead seamless-immutable to behave undesirably?\n. Thanks for figuring out the right path forward on this!\nI used this idea to make an envify-friendly version of this PR (notice there's no diff in the production build; envify builds things such that the compiled output will lead minification to strip out the comparison of one string literal to another), instead of keeping this check around in the production build.\nI'm going to close this, but thanks again for demonstrating how to solve this!\n. Happy to accept PRs for these! I believe @jlongster may have already made some progress on this?\n. Closing thanks to https://github.com/rtfeldman/seamless-immutable/pull/69\n. There isn't currently. I haven't tried making a custom PropTypes immutability checker, but if it can be done concisely without bringing in React as a dependency, I'd be open to a PR to add it!\n. That could work with objects, but not with arrays; they need to be instanceof Array in order to be backwards-compatible with normal arrays.\nI'm open to adding a helper function intended to be used with React (as long as it doesn't necessitate a React depdendency!) but I don't want to add an extra step to the creation of every single object - even for people using seamless-immutable outside React - for the sake of a React convenience, if that makes sense.\n. I'd have been open to this back in the 1.0 days, but I can't justify a breaking change like this now that we're at 4.0. :)\nSorry!\n. Thanks!\n. Generally looks good! Sorry I took so long reviewing it.\nI left a couple of comments, and there's also a merge conflict to resolve.\n. Thanks for this! :tada: \n. Thanks for bringing this up!\nUnfortunately, there would be a significant performance cost to enabling this; merge would have to keep track of whether any modifications had been made, and inspect every current value before merging along the way.\nI don't think the performance overhead is worth making this work.\n. Hm, sure enough! It looks like we're already doing this and incurring the performance cost, so I guess it's empirically not a performance problem. :laughing: My bad!\nI'll look into this.\n. Fixed and published as 4.0.2. Thanks for reporting this @tusharmath, and sorry I didn't look far enough into it the first time around!\n. @zuk can you open a separate issue for that?\n. Is the proposed solution that the Immutable would hold a mutable object?\n. What I meant was - could there possibly be any other solution to the stated\nproblem besides leaving it as a mutable object?\nOn Thu, Oct 29, 2015, 4:19 AM Tushar Mathur notifications@github.com\nwrote:\n\nI am not sure about this. There could be so many cases where you want to\nstore it as an immutable. Though in this case we don't need it to be\nimmutable.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/72#issuecomment-152150200\n.\n. If asynchronous is a solution, that can already be done; if you pass an immutable instance to Immutable, it just uses the one it's given and doesn't recurse.\n\nAs a next step, I'd suggest trying that (just iterate over the object you're given and recurse asynchronously until you've built up what you need) and see if that solves the problem.\n. Yeah, this is a longstanding known issue - see https://github.com/rtfeldman/seamless-immutable/issues/16#issuecomment-63890477 from 2014 - and I've always worked around it with _.map for React components.\nThere are two high-level ways to address this:\n1. Don't change the prod build behavior, but in the dev build check for this situation and give a nicer error so it's clearer where you need to use the workaround.\n2. Change both dev and prod to support circular references.\nObviously the latter is massively more work, and I'm wary of what the performance implications might be. :smile: \n. yep, I'm gonna go with both #119 and #120 - left some comments on both \ud83d\ude03 \n. https://github.com/rtfeldman/seamless-immutable/pull/119 has been merged and released as version 6.0.0; #120 will presumably be 6.0.1 once it's merged.\n. Fixed and published as 6.0.1! Big ups to @davidblurton for the implementation.\nI'm going to wait about a week before announcing this release, so people have a chance to kick the tires and see if we missed anything. \ud83d\ude38 \n. The production build has all references to NODE_ENV stripped out by envify, so this won't be a concern there.\nIs there a reason you couldn't address the performance concern by using the prod build?\n. Closing now that #75 exists; let's continue discussion there.\n. So it looks like the only way to do this in a way that doesn't result in a regression for prod builds is to use const instead of var and then add a build step for turning the const back into a var for development mode: https://github.com/facebook/react/issues/812#issuecomment-161201458\nThoughts?\n. Closing as stale; feel free to reopen if desired!\n. I'm surprised by this too! Assuming it wouldn't have noticeable performance costs, I'd be happy to accept a PR that fixed this.\n. I'd definitely be open to a pull request for this, but I'm gonna close the issue in the meantime. Thanks!\n. Hell yeah! :metal:\nThis looks awesome! Sorry I took so long getting to this.\n. Hi @nikki93, we actually had this discussion awhile back; here are my thoughts: https://github.com/rtfeldman/seamless-immutable/issues/42#issuecomment-109204580\nThanks for raising this, but it's settled. :smile: \n. Ah. Not sure if I've expressed this elsewhere, but I'm not okay with T containing mutable objects. One of my goals for the library is for you to be able to rely on Immutable things being actually immutable, and allowing any mutable objects inside would break that. :smiley: \n. I like this idea, and I wish I'd thought of it back when I first made the library! (A production-specific build was not on the radar back then.)\nAt this point, though, this would be a monumental breaking change for the sake of a performance improvement it's not clear would make a difference for people using the library today.\nThis seems unlikely to be the right move in the foreseeable future, so I'm going to close this rather than leave it in limbo. Great thought, though!\n. Sounds good! Nice catch, and would love a PR! :+1: \nCan you @-mention me on the PR?\n. Awesome, thanks!\n. @tiil Ah, spoke too soon - test failures. (Apparently I didn't have Travis set up to build PRs - sorry about that!)\nI reverted this on master. Can you address the test failures and make a fresh PR?\n. @tiil I'm surprised this approach fixes https://github.com/rtfeldman/seamless-immutable/issues/82 - would you mind adding a test case to confirm that it's fixed?\n. Thanks! :smiley: \n. Closing as stale; feel free to reopen if desired!\n. This was an early design decision (https://github.com/rtfeldman/seamless-immutable/issues/5) - is there a use case where the current behavior is causing a problem?\n. Love it, thanks @jakubholynet !\n. @InsomniacFury Correct - the production build does not make objects immutable. \nThe idea is that in development you will have used the immutable guarantees to end up with code that does not mutate anything, and by the time you reach production, the guarantees are implicit by the code you've written, and no longer need to be enforced.\nIf you want stronger guarantees in production, there's absolutely no reason you can't keep using the dev build. In fact, when the library was first released, the dev build was all there was! :smiley: \n. @InsomniacFury Just that it does extra work on instantiation - namely freezing and banning methods.\n. Is there a common use case this makes nicer? I like to keep the library as simple as possible, so my default is not to add new functionality unless there's a strong motivating case for it. :smiley: \n. Okay, I'm on board. Happy to accept a PR for this!\n. Implemented! Will release as 5.1.0 once cross-browser tests pass.\n. Hi @ryanfields and @bholloway,\nYou want to use either the development build or the production build - the source build, which has process in it, should not be used in the browser.\nSorry if that was unclear! :smile: \n. A PR would be great!\n. Oh weird. Thought I did that. Probably a good idea, yeah, but ultimately something I ought to do.\n. Published as 5.0.1.\n. Thanks @crudh!\n. Appreciate the suggestion, but one of the design goals for seamless-immutable is to free yourself from worrying about whether anything you pass to Immutable will be mutated; it simply won't be. The production build being \"all or nothing\" means you should only use it when you're confident enforcement wouldn't have done anything anyway.\nThis change would make it so you'd instead have to start thinking about when enforcement applied on a case-by-case basis, and avoiding that is important to me.\nThanks for the idea, but I'm not open to changing the current behavior on this. :smile: \n. > Also, I would like to add your library has helped provide ~85% performance gain for operation I am employing it for. :+1:\nAwesome, glad to hear it! :smile_cat: \n. So to clarify, the request is for a new seamless-immutable.development.min.js file, which is a minified version of seamless-immutable.development.js?\n. I'm worried this will create confusion as to which version to use in which circumstance. All the other use cases I'm aware of have been either folks using the existing production build, or else the development build run through their own minification process.\nI realize it would be convenient for your use case, but I would rather keep this simple: use the development.js build for development and the production.min.js build for production. Apologies!\n. Thanks for the idea, but I prefer minified files to be as small as possible, including removing comments...and I'm not super worried about license enforcement. :smile: \n. Good call! Link to the license seems reasonable; that's only a few extra bytes. Would happily accept a PR for that! :smiley: \n. Old tests pass for me too.\nLooks great, thanks!\n. @jakubholynet Hm, appears that tests are breaking in Firefox. I fixed some linter errors in the hopes that's all it was, but it appears to be more than that.\nMind taking a look?\n. @jakubholynet They are still broken, as far as I can tell. If you run npm run zuul-local and then visit the address printed to the console in Firefox, it will run the tests!\n. Ended up getting things fixed. Thanks for the PR! :smile_cat: \n. Fair enough. Happy to accept a PR for this! :smile: \n. Ha, that's what I get for copy/pasting. :grin: \nThanks!\n. Please do! :D\n. Closing in favor of that PR.\n. So I started setting up semantic-release and it wants my npm username and password. I'm not comfortable providing those. Know of any way around that requirement?\n. Hm, the thing I'm not comfortable with is giving away access to my npm account. I didn't realize this entailed that, to be honest. Is there no way around that?\n. @tusharmath sorry I didn't follow up about this, but unfortunately this is still a deal-breaker for me:\n\nThe token gives your CLI the ability to do things like publish and unpublish packages, and manage owners and teams.\n\nI'm like the idea of auto-generating changelogs, but I'm not willing to give this level of permission to a third-party tool for that convenience.\nI really, really appreciate your work on this, but I don't think I'm going to be able to finish the steps necessary for this to happen.\n. Yep, this is working as intended. Thanks to all who responded explaining why this works the way it does!\n. It's only being called when the \"production\" environment variable is being set; it's designed to work with https://www.npmjs.com/browse/keyword/envify\nSkipping freezing for the production build is the whole point! :smile: \n. Not without a compelling motivating use case. :wink: \n. Hm, yeah I can't say I'm on board with the idea of adding a redundant concat - I'd definitely recommend using concat for this!\n. Cool - this seems like a good resolution; I'm gonna close this issue, but feel free to open another to discuss specific feature requests!\n. Hm, this would be a performance regression given that call and apply are significantly slower than direct invocation.\nWas there a reason the Object.getOwnPropertyDescriptor approach discussed in #76 wouldn't work?\n. @lzrski hm, looks like build fails on Android: https://travis-ci.org/rtfeldman/seamless-immutable\n. Looks great, thanks!\n. Thanks for taking the time to write this up, but I prefer to keep the API small and compact, so I'd rather not add this. :smiley: \n. Hm...I honestly have not looked into these things enough to know what the problem could be.\n. Cool! Seems like a useful addition. :smiley_cat: \n. Awesome! If @alex3165 if you'd like to open a PR to seamless-immutable to add a link to the typings in our README, I would be happy to accept it.\nThanks for all the hard work on this!\n. No there isn't. :smile: \n. Looks great! Thanks for the level of detail on this. :heart_eyes_cat: \n. @lzrski published as 5.1.1!\n. I see your point, but I honestly don't think this is worth a breaking change to the existing set behavior. I also don't think it's worth adding an additional function, as I prefer to keep the API small, so I think there's just going to be some learning curve if you're coming from Immutable.js :smile: \n. This is because JavaScript objects only use strings for keys, not numbers.\n. JavaScript treats a[1] as the same as a[\"1\"] when a is an object.\n. I honestly don't know. I tend to focus on concrete use cases; is this blocking you on a particular project?\n. People have asked for this before, and it looks like the implementation is simple and well-tested. Thanks!\n. @evgenykochetkov I expect to merge https://github.com/rtfeldman/seamless-immutable/pull/119 soon and will release once that's in.\n. Actually, never mind - that one is a breaking change, and I think giving this its own minor version bump is worthwhile. Released as 5.2.0!\n. No reason except that I don't use AMD. Happy to accept a PR! :smile: \n. Thanks for the question! I'm not sure what this would mean in the context of an immutable library, though; the original object never changes, so I don't think those handlers would ever file. :smile: \n. I'd definitely publish as a separate package. I'd like to keep the core decoupled from extras where possible. \ud83d\ude04 \n. Lovely, thank you! \ud83d\ude3b \nTwo minor suggestions:\n1. Could you refactor level to be stackRemaining and decrement instead of incrementing? (Default to 64 instead of 0, and error when you reach 0.) That way if someone genuinely does have something that needs 65 stack frames, they can opt into upping the limit with an intuitive API.\n2. Could you add something to the README documenting this?\nThanks so much for this!\n. Beautiful! \ud83d\ude3b  Thanks so much @shamrin!\n. \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 Thanks a ton @davidblurton!!!\n. Sure, makes sense to me! \ud83d\ude03 \n. Released in 6.1.0. Thanks again @ericclemmons!\n. This seems like a \"here there be dragons\" case. What's the motivation here? Why is this needed?\n. > Call methods of immutable objects and its properties to analize saved states.\nWhy do those need to be methods? Why not implement them as standalone functions that accept the immutable data as arguments?\n. Sorry, but it seems like the right answer here is to stick to using Immutable values as plain old data, which makes great sense to me. I'm gonna close this.\nThank you for the discussion!\n. Why not just transform the argument before calling Immutable on it?\n. This use case seems too narrow to justify the added complexity, sorry!\n. new Immutable seems better, assuming it can be done in a way that doesn't break stuff (not sure which tests are failing, and whether it's the test's fault or the new logic's fault \ud83d\ude09 )\n. Oh right...if you use new, you have to get an object back; it can't return plain strings, numbers, null, etc. - all of which are currently supported (and passed through unchanged).\nLet's just go with \"from\" after all haha\n. Looks good! Last request would be a quick mention in the README. \ud83d\ude38 \n. Lovely, thank you! :smile:\n. @ericclemmons published as 6.1.0!\n. > I realize that a feature that would allow this sort of nested mutation might go against the philosophy of this module, but I thought I'd suggest it anyway :smile:.\nAs you predicted, I'm not open to introducing mutations. \ud83d\ude09  Appreciate the thoughtful post though!\n. Those benchmarks are using seamless-immutable's development build (they must be, since the prod build wouldn't pass the tests he posted), and the development build goes out of its way to freeze things and bans mutating methods.\nThe production build doesn't do these things. It's very close to \"using plain old arrays and objects\" in terms of performance, and I don't feel like trying to do better than that is a good goal for the library. \ud83d\ude04 \nThanks for the post!\n. That's cool! @guigrpa I appreciate your showing your work. \ud83d\ude38 \n. Seems reasonable as long as it's only for numbers. Calling String.valueOf on e.g. null would seem more likely to mask errors than avoid them.\nI'd gladly accept a PR for this! \ud83d\ude04 \n. Fixed by https://github.com/rtfeldman/seamless-immutable/pull/158\n. Gotcha...I think a feature request for \"avoid clobbering existing fields\" makes sense.\nWant to open one? \ud83d\ude04 \n. Thanks for your work on this @lzrski!\nLooking at this implementation, I think something like #81 is the right solution to #130. One problem with this approach is that you'll get opposite behavior in development builds compared to production builds; in development mode, your property gets added with no problem, but in production mode, it gets overridden! This is error-prone to say the least. \ud83d\ude09 \n81 seems to be the best solution to this (assuming it can work; seems like there might be issues with arrays, but not sure without experimenting), and that seems like the right path to go down here.\nThanks again!\n. Looks great, thanks @kalafut!\n. No plans, but seems plausible.\n. I just looked into this in more depth and I realized it should be closed as a duplicate of https://github.com/rtfeldman/seamless-immutable/issues/124\n. Done! Sorry for the oversight. \ud83d\ude05 \n. I considered it, but I don't think this makes sense from a design perspective.\nI think it's important that the contents of a seamless-immutable value be actually immutable unless there are extremely good reasons for them not to be. The more exceptions to that rule that exist (currently Dates, functions, and React components - all for specific practical reasons that come up very often), the harder debugging gets.\nConsidering almost everyone either uses Immutable.js or seamless-immutable, not both at once, I don't think this comes up anywhere near enough to justify special-casing.\nThanks for bringing it up though!\n. Closing since https://github.com/cdnjs/cdnjs/pull/8579 has been merged. \ud83c\udf89 \n. This has been pending changes for about two months, so I'm going to close it as stale.\nPlease feel free to reopen with those changes! :). @lelandmiller really sorry I took so long getting to this! Looks good to me.\nIf you can resolve the merge conflicts I'll merge and publish this.\n. There is now! See https://github.com/rtfeldman/seamless-immutable/pull/158\n. This seems worth special-casing in the same way we currently do with Dates.\n. The only breaking change was cycle detection...so you're almost certainly fine to upgrade. \ud83d\ude04 \nhttps://github.com/rtfeldman/seamless-immutable/pull/119\n. Seems reasonable, and deep-equals seems like a trivially small dependency to add.\nIf you wouldn't mind resolving the merge conflicts, I'd be happy to merge this!\n. @tommoor FYI @variant77's fix has been merged and released as 6.1.2!\n. Looks good! So sorry for the delay in merging this @variant77!\n. Released as 6.1.2 @brunolemos @variant77 \n. Feel free to open a PR, but I don't think this is worth tracking as an issue.\n. @marbemac don't worry about the dist files; I always rebuild them before publishing. \ud83d\ude04 \n. @marbemac can you reset the dist files to what's on master and push that to resolve the merge conflict?\n. Thanks @marbemac! Published as 6.1.3.\n. > I still think this is a valid issue\nI respectfully disagree. \ud83d\ude42\nFrom the original:\n\nA .merge with {deep: true} of two identical objects that contain an array is returning a new object.\n\nI expect that changing this behavior would be a serious performance regression. You would have to do comparisons at every single step of the merge, to check whether anything had changed. That is not free, and we should not act as though it were!\n. @qzb that's only in there so that the development and production builds can be built using envify - once the builds are complete, that variable will be gone.\nIf you use either the development build or the production build, process should not be there, and you should be all set! \ud83d\ude03 \n. Great, thank you @lelandmiller!\n. Released as 6.1.4! \ud83c\udf89 \n. Wow, this looks great @saivann! \ud83d\ude3b Thank you so much!\n. Lovely, thank you!\n. After a lot of thought, I don't think outright migrating to this syntax is the right move. I think it would be better to make this opt-in, for example:\njs\nvar Immutable = require(\"seamless-immutable\").static;\nMaking this give you a new version of Immutable that doesn't override methods seems like the best way to go. It preserves backwards compatibility and would be easy to opt into.\nWhat do you think?. @saivann This is great! \ud83d\ude0d Thank you so much!\nMy only request would be to simplify it to just:\njs\nvar Immutable = require(\"seamless-immutable\").static;\nI don't anticipate adding more configuration options later, so having an init function feels like overkill.\nSound good?. @saivann Thanks! I'm going to pair this with #177 and release as 7.0.0. Released as 7.0.0.. Great, thanks @8balloon!. > Sorry if this isn't the right forum. Not sure where else to ask as this is an esoteric issue.\nSorry, but it's not the right forum. \ud83d\ude42\nI'd try StackOverflow!. It's done this way for people using seamless-immutable on Node: it respects Node's production flag automatically, whereas in the browser you can load whichever is appropriate.. > As a side note, would be nice to have some more common structure for production builds, like dist/seamless-immutable.js (production version) and dist/seamless-immutable.min.js (production minified version).\nWe already have that, except it's at the project root rather than in a dist/ folder. \ud83d\ude42\nArguably a dist folder would be a slightly better place to put them, but I don't think that slight improvement is worth breaking everyone's builds the next time they upgrade.. The third option is sticking with the status quo, which seems to have the fewest downsides.. Great, thanks @nazar-pc!. This would defeat the purpose of envify, which is the whole reason those are in there. It gets compiled out of the production build, which is what's supposed to be used in the browser instead of the source.\nDoes https://github.com/rtfeldman/seamless-immutable/pull/165 resolve this?. Thanks @krzysztofpniak!. I'See https://github.com/rtfeldman/seamless-immutable/pull/160. Happy to accept a PR for them!. Thanks @sbalay!. Nice, thank you @thomasdashney!. I've never used the browser field but it seems reasonable. I assume Webpack/Browserify/etc will respect this as the default.\nIf so, do they permit overriding it? In other words, is someone going to have a harder time using seamless-immutable with one of those build tools if this field exists?\nAlso, this should definitely point to the development build. That's the safer default because it actually takes steps to enforce immutability. People should opt into the \"safety features removed\" prod build if they need the perf boost.. > As for development build - well, you can't point there right now (see #166).\n166 is about the source build, not the development build. \ud83d\ude42\nThe development build does not contain any search results for \"process\".\nThe webpack docs suggest browser would take precedence in webpack. They also mention that there is a way to override that, so I'm okay with this as long as it points to the development build instead of the production build.. > In my opinion something that goes into build system should be production, since artifacts will likely be used in production. While those who need development version can still manually specify what they need explicitly.\nThat makes sense if there's no difference between development and production, but that's not true here.\nThe production build improves performance by removing the safety checks that make the immutable invariants work, under the assumption that people would have caught any problems in development. That's only a reasonable assumption to make if people have been using the development build by default, which means it's important that the production build is opt-in, not the other way around.\ntl;dr Making the production build the default would be dangerously irresponsible and I'm not going to do it. \ud83d\ude42. @nazar-pc yep, please do!. Thanks @nazar-pc!. @saivann I pushed what theoretically seems like a fix for that credentials complaint.\nThat said, if you can get all the tests passing locally on Lodash 3.10, that should be good enough. \ud83d\ude42. I need a lot more information than this.\nPlease feel to reopen with a description that someone can act on. \ud83d\ude42. What happens if you go into node_modules/seamless-immutable/package.json and delete the \"browser\": entry?. Hm, ok - what if you leave the browser entry there, but add another entry that's exactly the same as the browser one except it says \"react-native\" instead of \"browser\"?. @messense please reopen if 7.0.1 doesn't fix this!. Thanks!\nHowever, I don't understand why the source works but the development build fails. I'd like to understand this fix better before applying it...what is it about the development build that react native rejects it?. @jgkim ah, got it!\nIn that case, it seems like it would make more sense to fix this by removing these from .npmignore:\nseamless-immutable.development.min.js\nseamless-immutable.development.js\nseamless-immutable.production.min.js\n...and then having both react-native and browser point to the development build.\nWhat do you think?. Yeah maybe main should be node?\nI think since we know about react-native it makes sense to include it alongside browser, just to be explicit.. @jgkim If you make those changes above, can you rebase on top of master? I pushed (what ought to be) a fix for Travis builds getting credentials errors on PRs.. Thanks @jgkim!. \ud83d\udc4d to adding Immutable.sortBy (statically, not as an override - I want to preserve the \"don't surprisingly change mutable methods to be non-mutating\" behavior) if anyone wants to make a PR!. Great, thank you @dentrado!. Thanks!. It was closed without comment because it was opened without a description. The title was \"Expose isImmutable method,\" which is not much to go on considering the method is already exposed. I didn't want any contributors to waste their time trying to guess what you wanted, so I closed it.\nI don't know what \"Was using the method on the wrong immutable library\" means, but I opened https://github.com/rtfeldman/seamless-immutable/issues/192 about the missing documentation. \ud83d\ude42. Thanks @arthur31416!. @dentrado Thanks! Would you mind adding a test to cover the behavior of rejected promise values?\nAlso, no need to check in the built files; I'll do that before publishing the next release. \ud83d\ude42. Out now! 7.1.0. Lovely, thank you @mbjurman! \ud83d\ude0d . Thanks @ryantemple!. > notice that in es6 this has finally been admitted into the language and is no longer considered a bad practice to my best knowledge\nUnfortuantely not.\nMore to the point, I appreciate the effort here, but I'm not okay with this from a design perspective. I think consistency of immutability is the right default, and making it so that prototype comes along by default means that it's super easy to call Immutable on something and be surprised that it's not actually immutable (because the prototype methods access mutable state).\nI'm okay allowing this on an opt-in basis, but I am not okay with making it the default.\nSorry you spent so much time on this! \ud83d\ude05 . There are not, but any normal linter should work with it just fine!. According to the docs, blobs are immutable.\n\nA Blob object represents a file-like object of immutable, raw data.\n\nThis suggests we should be able to treat them as such, just like how we currently treat strings!. It's because merge creates a new object. They may have the same contents, but they won't be reference equal (===) \ud83d\ude42. Thanks @dentrado!. Published as 7.1.1. @LukeusMaximus should be fixed in 7.1.1. Nice catch - thanks @felipeptcho!. Seems reasonable!. @lukewestby published as 7.1.2. Thanks @fobos! Sorry I missed this.. Thanks @madnight! . ",
    "n1k0": "+1, that would greatly help checking if two immutable structures actually differ. \nNit: How about a shorter name, eg. equals, or eq?\n. +1\n. +1, that would greatly help checking if two immutable structures actually differ. \nNit: How about a shorter name, eg. equals, or eq?\n. +1\n. ",
    "abritinthebay": "semantically equals is nicer - easy to discover on an object too (\"What's this do? Oh.. it's an equals function\").\n. Agree with @rtfeldman here.\nTo quote the description of Array.map:\n\nThe map() method creates a new array with the results of calling a provided function on every element in this array.\n\nWell... now make it for Immutables:\n\nThe map() method creates a new Immutable with the results of calling a provided function on every element in this Immutable.\n\nThis is in fact the only logical thing to do - you're operating on a specific type and returning a similar but different type would be... a bit wacky to say the least.\n. semantically equals is nicer - easy to discover on an object too (\"What's this do? Oh.. it's an equals function\").\n. Agree with @rtfeldman here.\nTo quote the description of Array.map:\n\nThe map() method creates a new array with the results of calling a provided function on every element in this array.\n\nWell... now make it for Immutables:\n\nThe map() method creates a new Immutable with the results of calling a provided function on every element in this Immutable.\n\nThis is in fact the only logical thing to do - you're operating on a specific type and returning a similar but different type would be... a bit wacky to say the least.\n. ",
    "Aetet": "Hello, @rtfeldman . What is status for deep equality between objects? What is api for that right now? \n. Hello, @rtfeldman . What is status for deep equality between objects? What is api for that right now? \n. ",
    "juanger": "@rtfeldman Hi, are you still interested in this? If so, I'd like to give it a try, rebase your branch and write tests\n. @rtfeldman Hi, are you still interested in this? If so, I'd like to give it a try, rebase your branch and write tests\n. ",
    "theogravity": "i'm also interested in this feature as well, have some deeply nested objects and want to do something like this in react:\n```\nshouldComponentUpdate(nextProps) {\n    // this.props.obj is immutable\nreturn this.props.obj.equals(nextProps.obj)\n}\n``. This is amazing - thank you for the work. It's working great and things feel cleaner than it did before.. this would be also useful for redux-devtools where the log monitor is also picking up the methods, making the redux log difficult to read through. In the meantime, I've done the following for usingseamless-immutablewithredux-devtoolsandredux-devtools-log-monitor` (it's not ideal perf-wise, but does the job):\n```\nimport React from 'react'\nimport { createDevTools } from 'redux-devtools'\nimport LogMonitor from 'redux-devtools-log-monitor'\nimport DockMonitor from 'redux-devtools-dock-monitor'\nimport MultipleMonitors from 'redux-devtools-multiple-monitors'\n// clone without prototype methods so the seamless-immutable methods aren't exposed in the logs\n// http://stackoverflow.com/questions/728360/how-do-i-correctly-clone-a-javascript-object\nfunction clone(obj) {\n  var copy\n// Handle the 3 simple types, and null or undefined\n  if (null == obj || \"object\" != typeof obj) return obj\n// Handle Date\n  if (obj instanceof Date) {\n    copy = new Date()\n    copy.setTime(obj.getTime())\n    return copy\n  }\n// Handle Array\n  if (obj instanceof Array) {\n    copy = []\n    for (var i = 0, len = obj.length; i < len; i++) {\n      copy[i] = clone(obj[i])\n    }\n    return copy\n  }\n// Handle Object\n  if (obj instanceof Object) {\n    copy = {}\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr])\n    }\n    return copy\n  }\n}\nexport default createDevTools(\n  \n\n\n\n\n)\n```. Have you tried using the static version of the library?\nEg\n```\nconst Immutable = require('seamless-immutable').static\nconst data = Immutable.from({ myData: []})\nlet newData = Immutable.set(data, 'myData', ['blah'])\n```\nThe static version of the API should not have methods attached AFAIK. i'm also interested in this feature as well, have some deeply nested objects and want to do something like this in react:\n```\nshouldComponentUpdate(nextProps) {\n    // this.props.obj is immutable\nreturn this.props.obj.equals(nextProps.obj)\n}\n``. This is amazing - thank you for the work. It's working great and things feel cleaner than it did before.. this would be also useful for redux-devtools where the log monitor is also picking up the methods, making the redux log difficult to read through. In the meantime, I've done the following for usingseamless-immutablewithredux-devtoolsandredux-devtools-log-monitor` (it's not ideal perf-wise, but does the job):\n```\nimport React from 'react'\nimport { createDevTools } from 'redux-devtools'\nimport LogMonitor from 'redux-devtools-log-monitor'\nimport DockMonitor from 'redux-devtools-dock-monitor'\nimport MultipleMonitors from 'redux-devtools-multiple-monitors'\n// clone without prototype methods so the seamless-immutable methods aren't exposed in the logs\n// http://stackoverflow.com/questions/728360/how-do-i-correctly-clone-a-javascript-object\nfunction clone(obj) {\n  var copy\n// Handle the 3 simple types, and null or undefined\n  if (null == obj || \"object\" != typeof obj) return obj\n// Handle Date\n  if (obj instanceof Date) {\n    copy = new Date()\n    copy.setTime(obj.getTime())\n    return copy\n  }\n// Handle Array\n  if (obj instanceof Array) {\n    copy = []\n    for (var i = 0, len = obj.length; i < len; i++) {\n      copy[i] = clone(obj[i])\n    }\n    return copy\n  }\n// Handle Object\n  if (obj instanceof Object) {\n    copy = {}\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr])\n    }\n    return copy\n  }\n}\nexport default createDevTools(\n  \n\n\n\n\n)\n```. Have you tried using the static version of the library?\nEg\n```\nconst Immutable = require('seamless-immutable').static\nconst data = Immutable.from({ myData: []})\nlet newData = Immutable.set(data, 'myData', ['blah'])\n```\nThe static version of the API should not have methods attached AFAIK. ",
    "mvolkmann": "Immutable\n. Linters complain when you call a function that starts uppercase rather than using the \"new\" keyword.\nvar data = new Immutable(thing); // linter likes\nvar data = Immutable(thing); // linter complains\nvar data = immutable(thing); // linter likes\n. I know when I see an uppercase function name I immediately think it is a constructor function.\n. Ah, that's certainly true. But if you want to make it usable in browsers that don't support ES6 modules, I guess you'll want to expose that as a global variable.\n. Immutable\n. Linters complain when you call a function that starts uppercase rather than using the \"new\" keyword.\nvar data = new Immutable(thing); // linter likes\nvar data = Immutable(thing); // linter complains\nvar data = immutable(thing); // linter likes\n. I know when I see an uppercase function name I immediately think it is a constructor function.\n. Ah, that's certainly true. But if you want to make it usable in browsers that don't support ES6 modules, I guess you'll want to expose that as a global variable.\n. ",
    "raorao": "Personally I like the uppercase function name, since Immutable is a constructor in spirit. Perhaps there should just be a lower case version of the function in the public interface for the linted among us. \n. @rtfeldman renamed the stuff that you flagged. all tests passing locally using zuul.\n. duplicate.\n. Personally I like the uppercase function name, since Immutable is a constructor in spirit. Perhaps there should just be a lower case version of the function in the public interface for the linted among us. \n. @rtfeldman renamed the stuff that you flagged. all tests passing locally using zuul.\n. duplicate.\n. ",
    "alanhogan": "sounds legit\n. I've been wondering about how to do this kind of thing for ever. Very nice solution. No non-JS syntax needed. \nAlan\n\nOn Mar 19, 2015, at 2:27 PM, Richard Feldman notifications@github.com wrote:\nAwsesome!\nThe best practice I've seen (which is what React does) is to make it envify-friendly.\nBasically you do this:\nif (process.env.NODE_ENV === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\n...then run envify on it twice, once with {NODE_ENV: \"development\"} and once with {NODE_ENV: \"production\"} to get two output files: seamless-immutable.development.js and seamless-immutable.production.min.js\nIn the development build, envify will replace the above with this:\nif (\"development\" === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\n....whereas in the production build, it will instead replace it with this:\nif (\"production\" === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\nUglify will then see that this conditional will always fail and will strip this code out entirely, meaning the production build will not only avoid adding the extra attributes, it won't even run any conditionals to tell if it's in prod mode!\nThis implicitly means we'd need to introduce a build process to generate the two different files for library consumers.\n\u2014\nReply to this email directly or view it on GitHub.\n. Is it undesirable or impossible for immutable data structures to handle cycles?\n. A better question is: why do you think it is unwise to support circular references? I am merely curious, of course\n. Yep, makes total sense. seems smart to me\n. Great explanation. Richard, you\u2019re an A+ maintainer. \n. sounds legit\n. I've been wondering about how to do this kind of thing for ever. Very nice solution. No non-JS syntax needed. \n\nAlan\n\nOn Mar 19, 2015, at 2:27 PM, Richard Feldman notifications@github.com wrote:\nAwsesome!\nThe best practice I've seen (which is what React does) is to make it envify-friendly.\nBasically you do this:\nif (process.env.NODE_ENV === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\n...then run envify on it twice, once with {NODE_ENV: \"development\"} and once with {NODE_ENV: \"production\"} to get two output files: seamless-immutable.development.js and seamless-immutable.production.min.js\nIn the development build, envify will replace the above with this:\nif (\"development\" === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\n....whereas in the production build, it will instead replace it with this:\nif (\"production\" === \"development\") {\n  // do some stuff we wouldn't do in prod mode\n}\nUglify will then see that this conditional will always fail and will strip this code out entirely, meaning the production build will not only avoid adding the extra attributes, it won't even run any conditionals to tell if it's in prod mode!\nThis implicitly means we'd need to introduce a build process to generate the two different files for library consumers.\n\u2014\nReply to this email directly or view it on GitHub.\n. Is it undesirable or impossible for immutable data structures to handle cycles?\n. A better question is: why do you think it is unwise to support circular references? I am merely curious, of course\n. Yep, makes total sense. seems smart to me\n. Great explanation. Richard, you\u2019re an A+ maintainer. \n. \n",
    "diegovilar": "Agreed. Those constraints are mostly not supposed to be runtime errors and should be catch in development.\n. Agreed. Those constraints are mostly not supposed to be runtime errors and should be catch in development.\n. ",
    "crudh": "I'm interested in working on this but I am a bit unsure on how to pass the flag to the library?\nWould you use the export code:\nif (typeof module === \"object\") {\n    module.exports = Immutable;\n  } else if (typeof exports === \"object\") {\n    exports.Immutable = Immutable;\n  } else if (typeof window === \"object\") {\n    window.Immutable = Immutable;\n  } else if (typeof global === \"object\") {\n    global.Immutable = Immutable;\n  }\nTo do different things depending on the environment, like (using global and window as examples):\n```\n  var prodMode = false;\nif (typeof module === \"object\") {\n    module.exports = Immutable;\n  } else if (typeof exports === \"object\") {\n    exports.Immutable = Immutable;\n  } else if (typeof window === \"object\") {\n    window.Immutable = Immutable;\n    prodMode = window.SEAMLESS_PROD_MODE === true;\n  } else if (typeof global === \"object\") {\n    global.Immutable = Immutable;\n    prodMode = global.SEAMLESS_PROD_MODE === true;\n  }\n```\nOr is there a better way?\n. Should we then move seamless-immutable.js to a src directory to indicate that it shouldn't be used directly? And place the output files of envify in the root?\n. Sounds good!\n. I created seamless versions of all the tests (except the sum test that uses reduce on an object, not sure what an eqiuvalent would be in seamless) and put it here. Please let me know if I can improve any of them. \nThe Put all and Remove all tests puts/removes all properties one by one. So I did that with the seamless implementations too. But I also created Batch-versions of them that calls merge and without once with an array instead. Seems like what you would do in a real application.\nAnd it would be interesting to see the tests with a Prod Mode.\nThese are the results:\n```\nGet nth\nhashtrie(10)                  :     10988624.32 +/- 0.89% op/s\nhamt(10)                      :     11662756.60 +/- 0.92% op/s\nhamt_plus(10)                 :     10689406.32 +/- 0.89% op/s\npersistent-hash-trie(10)      :      9868732.28 +/- 0.97% op/s\nmori hash_map(10)             :      2337573.70 +/- 0.85% op/s\nimmutable(10)                 :      9873107.21 +/- 0.70% op/s\nseamlessImmutable(10)         :     11640944.63 +/- 0.59% op/s\nput nth\nhashtrie(10)                  :      1851101.94 +/- 0.52% op/s\nhamt(10)                      :      1396350.78 +/- 0.75% op/s\nhamt_plus(10)                 :      1359048.46 +/- 0.82% op/s\npersistent-hash-trie(10)      :       333296.20 +/- 0.68% op/s\nmori hash_map(10)             :      2069530.07 +/- 0.82% op/s\nimmutable(10)                 :      1987496.81 +/- 0.57% op/s\nseamlessImmutable(10)         :       103734.16 +/- 0.63% op/s\nPut All\nhashtrie(10)                  :       298151.58 +/- 0.58% op/s\nhamt(10)                      :       245611.96 +/- 0.59% op/s\nhamt_plus(10)                 :       228329.11 +/- 0.56% op/s\npersistent-hash-trie(10)      :        46293.96 +/- 0.79% op/s\nmori hash_map(10)             :        98024.61 +/- 0.58% op/s\nimmutable(10)                 :       164094.88 +/- 0.57% op/s\nseamlessImmutable(10)         :         9432.17 +/- 0.56% op/s\nseamlessImmutableBatch(10)    :        50610.03 +/- 0.65% op/s\nPut All (transient)\nhamt(10)                      :       187368.43 +/- 0.66% op/s\nhamt_plus(10)                 :       367960.47 +/- 0.66% op/s\nmori hash_map(10)             :       130079.97 +/- 0.70% op/s\nimmutable(10)                 :       220634.84 +/- 0.60% op/s\nseamlessImmutable(10)         :        59298.56 +/- 0.67% op/s\nremove nth\nhashtrie(10)                  :      2192759.16 +/- 0.63% op/s\nhamt(10)                      :      2022976.44 +/- 0.60% op/s\nhamt_plus(10)                 :      1557230.87 +/- 0.71% op/s\npersistent-hash-trie(10)      :       171527.96 +/- 0.79% op/s\nmori hash_map(10)             :      1402983.09 +/- 0.67% op/s\nimmutable(10)                 :      2168393.04 +/- 0.66% op/s\nseamlessImmutable(10)         :        70445.80 +/- 0.72% op/s\nRemove All\nhashtrie(10)                  :       281865.17 +/- 0.69% op/s\nhamt(10)                      :       245017.59 +/- 0.78% op/s\nhamt_plus(10)                 :       190793.16 +/- 0.66% op/s\npersistent-hash-trie(10)      :        29254.94 +/- 0.73% op/s\nmori hash_map(10)             :       184961.04 +/- 0.63% op/s\nimmutable(10)                 :       268382.34 +/- 0.78% op/s\nseamlessImmutable(10)         :         7364.39 +/- 1.14% op/s\nseamlessImmutableBatch(10)    :       115008.51 +/- 1.26% op/s\nRemove All (transient)\nhamt(10)                      :       205820.55 +/- 0.57% op/s\nhamt_plus(10)                 :       334430.04 +/- 0.58% op/s\nmori hash_map(10)             :        97248.60 +/- 0.94% op/s\nimmutable(10)                 :       533887.03 +/- 0.63% op/s\nseamlessImmutable(10)         :        79780.72 +/- 0.53% op/s\nCount\nhashtrie(10)                  :       471568.80 +/- 0.46% op/s\nhamt(10)                      :     14029433.73 +/- 0.47% op/s\nhamt_plus(10)                 :     13548777.96 +/- 0.62% op/s\npersistent-hash-trie(10)      :       186148.73 +/- 0.76% op/s\nmori hash_map(10)             :     75418087.81 +/- 0.70% op/s\nimmutable(10)                 :     78292673.71 +/- 1.07% op/s\nseamlessImmutable(10)         :      1038235.14 +/- 0.62% op/s\nSum\nhashtrie(10)                  :       459645.40 +/- 0.55% op/s\nhamt(10)                      :      9921932.32 +/- 0.43% op/s\nhamt_plus(10)                 :      9604783.60 +/- 0.67% op/s\npersistent-hash-trie(10)      :       279183.30 +/- 0.69% op/s\nmori hash_map(10)             :      1263520.34 +/- 0.54% op/s\nimmutable(10)                 :      2336308.25 +/- 0.71% op/s\nKeys\nhashtrie(10)                  :       275352.68 +/- 0.60% op/s\nhamt(10)                      :      4441970.69 +/- 0.83% op/s\nhamt_plus(10)                 :      5865476.21 +/- 0.60% op/s\npersistent-hash-trie(10)      :       217769.70 +/- 0.53% op/s\nmori hash_map(10)             :       451105.71 +/- 0.69% op/s\nimmutable(10)                 :            0.00 +/- 0.00% op/s\nseamlessImmutable(10)         :      1032501.82 +/- 0.57% op/s\n``\n. I commented out everything inmakeImmutableexcept foraddImmutabilityTag` and ran the tests again. Seems like a 50% increase for most tests, and up to 100% for some.\n```\nGet nth\nseamlessImmutable(10)         :     13306890.75 +/- 0.81% op/s\nput nth\nseamlessImmutable(10)         :       156080.34 +/- 0.87% op/s\nPut All\nseamlessImmutable(10)         :        14119.24 +/- 1.01% op/s\nseamlessImmutableBatch(10)    :        60817.56 +/- 0.91% op/s\nPut All (transient)\nseamlessImmutable(10)         :        79070.08 +/- 1.06% op/s\nremove nth\nseamlessImmutable(10)         :        99218.78 +/- 1.04% op/s\nRemove All\nseamlessImmutable(10)         :        10465.64 +/- 1.20% op/s\nseamlessImmutableBatch(10)    :       157722.65 +/- 1.31% op/s\nRemove All (transient)\nseamlessImmutable(10)         :        97212.40 +/- 1.20% op/s\nCount\nseamlessImmutable(10)         :      1849054.44 +/- 1.25% op/s\nKeys\nseamlessImmutable(10)         :      2132544.74 +/- 0.52% op/s\n```\n. @wmertens: not sure they are interested since seamless isn't hashtrie based? I guess that's why they haven't got a vanilla JS entry either.\nBut if you can check with them and get an ok I will clean up my branch, add regular JS and submit a PR.\n. @wmertens: hehe, ok :) yeah, it's an unfair comparison. Even for simple things like getting a count (the count test) then for a vanilla/seamless object you need Object.keys which is o(N) where the more complex libraries can hold their own count.\n. Now that there is a dev/prod mode maybe it would make sense to check this only in development mode? That way most cases can be found without sacrificing any performance.\nA really simple way would be to do a test before making it immutable, like:\nJSON.stringify(object);\nIf it contains a circular reference it will throw a TypeError with the message \"Converting circular structure to JSON\".\n. Ok! Instead of a boolean, what to you think about a mergeWith function or similar that takes a config object first (which the normal merge can use under the covers) so more config can be added later if needed?\nobj1.mergeWith({deep: true}, obj2);\nI have a use case where I would like to supply a custom merger sometimes, that could fit into this strategy.\nBut if you don't like it I will do a PR with the boolean.\n. @RangerMauve I agree in general, but if the With in the function name is for merging with the config I think it is natural if the mandatory config is first. Especially if it is a merge with multiple objects like:\nobj1.mergeWith({deep: true}, obj2, obj3, obj4, obj5);\nBut it doesn't matter much either way. Any thoughts @rtfeldman?\n. Sounds good to me!\n. I'm no expert at this but as far as I can tell something like this could work:\nIn the Immutable function, the new object is created with:\nvar clone = {};\nInstead the following can be done:\nvar clone = Object.create(Object.getPrototypeOf(obj);\nBut that won't work for Date, and as far as I can tell Date would require a special case in the Immutable function. So combined we would get:\n...\n} else if (obj instanceof Date) {\n  var clone = new Date(obj);\n  return makeImmutable(clone)\n} else {\n  var clone = Object.create(Object.getPrototypeOf(obj);\n  ...\nBut Object.create is a lot slower than {}. This makes it faster:\nvar prototype = Object.getPrototypeOf(obj);\nvar clone = prototype ? Object.create(prototype) : {};\nA bit slower in Chrome but still much slower in Firefox (but mainly since FF is much faster at doing {}). Source\nBut I don't know how much the performance of this single thing affects the entire process of making an object immutable.\nSo am I on the right track? And is there a faster/better way of checking for a prototype?\n. Yes, that sounds reasonable.\nBut instead of a generic solution for prototypes maybe a special case for Date handling could be useful? Since it is an built in type that is frequently used, and by using the new Date(obj) to clone it there shouldn't be any technical problem?\n. The last commit message should read: \"Only freeze and ban properties if in dev mode.\"\n. Now all tests are run for both the development build and the production build. There are a few exceptions, like checking if the object is frozen, where we only run it for one build. But then I have added a simple test for the other build too.\nI only placed the build config in the .spec.js files. Then I passed the config into the test functions in ImmutableObject/ and ImmutableArray/* so they could require in the correct Immutable build.\nI had to do some changes to TestUtil so that it uses the correct Immutable build depending on the config. Basically instead of exporting an object it exports a function that takes the chosen Immutable and returns an object with functions that uses the correct Immutable. This seemed like the cleanest way to do it, but I'm open to suggestions :smile: \n. @rtfeldman: Seems like it! Replacing the .toISOString() comparisons with .getTime() comparisons should solve the problem. You want me to add it to the current PR, a new one or do you want to do it yourself?\n. I just got access to an IE11 and tested it (and in a Firefox) and saw the problem with using the constructor:\nnew Date(originalDate).\nBut the following works in both:\nnew Date(originalDate.getTime()).\nI have seen a lot of examples doing it the first way and as far as I understood it should then use the .valueOf method on the date which generates the same output as .getTime in all browsers. So not sure why the first way fails, but I will change it to the second way.\nThanks for the suggestion @rtfeldman. A PR is coming, sorry for the mess.\n. The constructor new Date(originalDate) throws away the millseconds in some browsers (IE, FF) but not other (Chrome, others?).\nUsing new Date(originalDate.getTime()) preserves the milliseconds. This is fixed in PR #33.\n. Tested, and it works, in latest Chrome, Firefox and IE.\n. Remember to do a grunt build after merge to generate the new prod and dev files.\n. @rtfeldman: Ok! But will Travis run Grunt to generate the new prod/dev files? If it uses the current commited ones in master the tests will continue to fail.\n. Sounds good, no urgency for me!\n. I think the biggest drawback is that you have to do push differently for normal and immutable arrays, and there isn't anything telling you that you are doing it wrong if you push on an immutable array and don't take care of the result.\nIt can be especially confusing if you have a code base where you use both regular arrays and immutable arrays.\n. Yeah, it is easy to differ visually. But if you are working with code that uses both mutable and immutable arrays and you do a push on an immutable array now you get an error and you are made aware of it during development.\nWith this change you might by mistake do a push on an immutable array and forget to handle the result and get no warning about it. It might then lead to bugs that can be tricky to locate the source of.\nSo you have a valid point, but I'm not personally convinced that the benefits are greater than the drawbacks. And if push should be changed in this way then maybe all other banned mutating methods should be changed in the same way too?\n. @rtfeldman cases like this could be handled by a custom merger if we add the following to addToResult in the merge function:\nRight now it looks like:\njavascript\nvar mergerResult = merger && merger(currentObj[key], immutableValue, config);\nIf we extend that to:\njavascript\nvar mergerResult = merger && merger(currentObj[key], immutableValue, config);\nif (mergerResult && mergerResult === currentObj[key]) return;\nThen if a merger returns something and it is the same thing as the property in the currentObj we could abort addToResult.\nCombining that with a custom merger that returns the array from the currentObj if they contain the same items:\n``` javascript\nfunction equalityArrayMerger(current, other) {\n  if (!(current instanceof Array) || !(other instanceof Array)) return;\n  if (current.length !== other.length) return;\nfor (var i = 0; i < current.length; i++) {\n    if (current[i] !== other[i]) return;\n  }\nreturn current;\n}\n```\nwould give the desired results.\nBut not sure if it is worth adding if there is another long term goal with deepEquals? It's a minor change but it will add another check in the addToResult function. And this was only a quick test, I haven't checked how/if it affects other things.\n. @cr0cK: now that PR #41 has been merged you should be able, after the next release, to pass in the following or similar to the merge to get your example to work:\n``` javascript\nfunction equalityArrayMerger(current, other) {\n  if (!(current instanceof Array) || !(other instanceof Array)) return;\n  if (current.length !== other.length) return;\nfor (var i = 0; i < current.length; i++) {\n    if (current[i] !== other[i]) return;\n  }\nreturn current;\n}\n...\n\ni2 = i.merge(o2, {merger: equalityArrayMerger})\n{ a: [ 1, 2 ] }\ni === i2\ntrue\n```\n\nIt will override the merge for array properties and return the same reference if they contain the same list of values in both objects.\nNote that it will not work with current master until a grunt build has been run.\n. @cr0cK: it's released now. And if you use Node/Browserify I have added the equalityArrayMerger in this project if you prefer that instead of copying the function above.\nAs for the default behaviour I agree with what @rtfeldman said above, as long as it is easy to get back to the current behaviour when a deep check isn't needed or is too expensive.\n. @ianp: If you want to do a deep merge then the second argument shouldn't be true, it should be {deep: true} like:\njavascript\nobj.merge({streams: {a: { loading: true }}}, {deep: true});\nIt produces the desired results:\njavascript\n{\n  streams: {\n    a: {name: 'Conversations', channel: [Object], loading: true},\n    b: {name: '@Mentions', channel: [Object], loading: false},\n    c: {name: 'Facebook', channel: [Object], loading: false}\n  },\n  streamOrder: ['c', 'a', 'b']\n}\n. @alesch: Does it work if you do: import I from 'seamless-immutable'?\n. I'm using babel and browserify and the following works for me:\n``` javascript\nimport I from \"seamless-immutable\";\nconst l = I([1, 2, 3]);\nconsole.log(l);   // [1, 2, 3, __immutable_invariants_hold: true]\n``\n. @alesch: nice! my IDE complains also if I do:import I from \"seamless-immutable\";but if I do:import immutable from \"seamless-immutable\";it doesnt. It's because functions with a name that starts with an uppercase letter are supposed to be constructor functions and used withnew`.\n. @rtfeldman any thoughts on this? I noticed now that I forgot to mention you in the PR.\n. What do you mean? If you merge A with B and both contain the array named C then the result will contain the array from B. Do you want the result to ignore the array from B and keep the array from A?\n. This is my output when I test with 3.0.0 and 4.0.2: \nvar o = immutable({arr: [{id: 2}]});\no = o.merge({arr: [{id: 3}]});\n// o is {arr: [{id: 3}]}\n. @rtfeldman :+1: nice, 4 minutes from report to release :smile: \n. @estaub yes, they will work. All objects and arrays are normal javascript objects and arrays with the exception that they are frozen and mutating methods throw errors.\n. From the project description:\n\nIn the development build, objects are frozen. (Note that Safari is relatively slow to iterate over frozen objects.) The development build also overrides unsupported methods (methods that ordinarily mutate the underlying data structure) to throw helpful exceptions.\nThe production (minified) build does neither of these, which significantly improves performance.\n\nSo if you use the main /src/seamless-immutable.js it just works and respects your NODE_ENV setting if you run it in node. If you run it in a browser you can either use the same file if you have a build environment where you have configured it or you can use the /seamless-immutable.development.js or /seamless-immutable.production.js directly which requires no setup of NODE_ENV.\n. If you want to use the default /src/seamless-immutable.js and configure your build to set the correct mode then do as they suggest in React: https://facebook.github.io/react/downloads.html#npm (check the note for npm). It works in the same way for seamless-immutable.\n. @lelandmiller looks like a bug and a legit fix to me! @rtfeldman ?\n. @chadly that's strange. I added the following test case:\n``` javascript\n    it(\"merges arrays with the same result as chained merges\", function() {\n      var expected = Immutable({ username: \"homer.simpson\", city: \"Springfield\", kids: 3 })\n  var original = Immutable({ username: \"homer.simpson\"});\n  var toMerge1 = { username: \"HoMeR.SiMpSoN\", city: \"Springfield\" };\n  var toMerge2 = { username: \"homer.simpson\", kids: 3 };\n\n  var actualChainedMerges = original.merge(toMerge1).merge(toMerge2);\n  var actualArrayMerge = original.merge([toMerge1, toMerge2]);\n\n  TestUtils.assertJsonEqual(actualChainedMerges, expected);\n  TestUtils.assertJsonEqual(actualArrayMerge, expected);\n});\n\n```\nand it works and produces the correct result in both cases.\n. Using lodash works fine otherwise:\n```\nimport _get from 'lodash/get';\nconst foo = get(state, 'bar.baz.foo', '');\n``\n. @slashwhatever the result in your example is a javascript object, not a collection of any type. So you have to check the number of keys in the object withObject.keys(myImmutable).lengthor use something like.size` from lodash.\nIf you make an array immutable you can just use .length on it or again _.size from lodash.\n. @slashwhatever yes, but the reasoning of seamless is that the types should be plain javascript types, with as few modifications as possible. So _.size is probably the best suggestion for this use case.\n. I'm interested in working on this but I am a bit unsure on how to pass the flag to the library?\nWould you use the export code:\nif (typeof module === \"object\") {\n    module.exports = Immutable;\n  } else if (typeof exports === \"object\") {\n    exports.Immutable = Immutable;\n  } else if (typeof window === \"object\") {\n    window.Immutable = Immutable;\n  } else if (typeof global === \"object\") {\n    global.Immutable = Immutable;\n  }\nTo do different things depending on the environment, like (using global and window as examples):\n```\n  var prodMode = false;\nif (typeof module === \"object\") {\n    module.exports = Immutable;\n  } else if (typeof exports === \"object\") {\n    exports.Immutable = Immutable;\n  } else if (typeof window === \"object\") {\n    window.Immutable = Immutable;\n    prodMode = window.SEAMLESS_PROD_MODE === true;\n  } else if (typeof global === \"object\") {\n    global.Immutable = Immutable;\n    prodMode = global.SEAMLESS_PROD_MODE === true;\n  }\n```\nOr is there a better way?\n. Should we then move seamless-immutable.js to a src directory to indicate that it shouldn't be used directly? And place the output files of envify in the root?\n. Sounds good!\n. I created seamless versions of all the tests (except the sum test that uses reduce on an object, not sure what an eqiuvalent would be in seamless) and put it here. Please let me know if I can improve any of them. \nThe Put all and Remove all tests puts/removes all properties one by one. So I did that with the seamless implementations too. But I also created Batch-versions of them that calls merge and without once with an array instead. Seems like what you would do in a real application.\nAnd it would be interesting to see the tests with a Prod Mode.\nThese are the results:\n```\nGet nth\nhashtrie(10)                  :     10988624.32 +/- 0.89% op/s\nhamt(10)                      :     11662756.60 +/- 0.92% op/s\nhamt_plus(10)                 :     10689406.32 +/- 0.89% op/s\npersistent-hash-trie(10)      :      9868732.28 +/- 0.97% op/s\nmori hash_map(10)             :      2337573.70 +/- 0.85% op/s\nimmutable(10)                 :      9873107.21 +/- 0.70% op/s\nseamlessImmutable(10)         :     11640944.63 +/- 0.59% op/s\nput nth\nhashtrie(10)                  :      1851101.94 +/- 0.52% op/s\nhamt(10)                      :      1396350.78 +/- 0.75% op/s\nhamt_plus(10)                 :      1359048.46 +/- 0.82% op/s\npersistent-hash-trie(10)      :       333296.20 +/- 0.68% op/s\nmori hash_map(10)             :      2069530.07 +/- 0.82% op/s\nimmutable(10)                 :      1987496.81 +/- 0.57% op/s\nseamlessImmutable(10)         :       103734.16 +/- 0.63% op/s\nPut All\nhashtrie(10)                  :       298151.58 +/- 0.58% op/s\nhamt(10)                      :       245611.96 +/- 0.59% op/s\nhamt_plus(10)                 :       228329.11 +/- 0.56% op/s\npersistent-hash-trie(10)      :        46293.96 +/- 0.79% op/s\nmori hash_map(10)             :        98024.61 +/- 0.58% op/s\nimmutable(10)                 :       164094.88 +/- 0.57% op/s\nseamlessImmutable(10)         :         9432.17 +/- 0.56% op/s\nseamlessImmutableBatch(10)    :        50610.03 +/- 0.65% op/s\nPut All (transient)\nhamt(10)                      :       187368.43 +/- 0.66% op/s\nhamt_plus(10)                 :       367960.47 +/- 0.66% op/s\nmori hash_map(10)             :       130079.97 +/- 0.70% op/s\nimmutable(10)                 :       220634.84 +/- 0.60% op/s\nseamlessImmutable(10)         :        59298.56 +/- 0.67% op/s\nremove nth\nhashtrie(10)                  :      2192759.16 +/- 0.63% op/s\nhamt(10)                      :      2022976.44 +/- 0.60% op/s\nhamt_plus(10)                 :      1557230.87 +/- 0.71% op/s\npersistent-hash-trie(10)      :       171527.96 +/- 0.79% op/s\nmori hash_map(10)             :      1402983.09 +/- 0.67% op/s\nimmutable(10)                 :      2168393.04 +/- 0.66% op/s\nseamlessImmutable(10)         :        70445.80 +/- 0.72% op/s\nRemove All\nhashtrie(10)                  :       281865.17 +/- 0.69% op/s\nhamt(10)                      :       245017.59 +/- 0.78% op/s\nhamt_plus(10)                 :       190793.16 +/- 0.66% op/s\npersistent-hash-trie(10)      :        29254.94 +/- 0.73% op/s\nmori hash_map(10)             :       184961.04 +/- 0.63% op/s\nimmutable(10)                 :       268382.34 +/- 0.78% op/s\nseamlessImmutable(10)         :         7364.39 +/- 1.14% op/s\nseamlessImmutableBatch(10)    :       115008.51 +/- 1.26% op/s\nRemove All (transient)\nhamt(10)                      :       205820.55 +/- 0.57% op/s\nhamt_plus(10)                 :       334430.04 +/- 0.58% op/s\nmori hash_map(10)             :        97248.60 +/- 0.94% op/s\nimmutable(10)                 :       533887.03 +/- 0.63% op/s\nseamlessImmutable(10)         :        79780.72 +/- 0.53% op/s\nCount\nhashtrie(10)                  :       471568.80 +/- 0.46% op/s\nhamt(10)                      :     14029433.73 +/- 0.47% op/s\nhamt_plus(10)                 :     13548777.96 +/- 0.62% op/s\npersistent-hash-trie(10)      :       186148.73 +/- 0.76% op/s\nmori hash_map(10)             :     75418087.81 +/- 0.70% op/s\nimmutable(10)                 :     78292673.71 +/- 1.07% op/s\nseamlessImmutable(10)         :      1038235.14 +/- 0.62% op/s\nSum\nhashtrie(10)                  :       459645.40 +/- 0.55% op/s\nhamt(10)                      :      9921932.32 +/- 0.43% op/s\nhamt_plus(10)                 :      9604783.60 +/- 0.67% op/s\npersistent-hash-trie(10)      :       279183.30 +/- 0.69% op/s\nmori hash_map(10)             :      1263520.34 +/- 0.54% op/s\nimmutable(10)                 :      2336308.25 +/- 0.71% op/s\nKeys\nhashtrie(10)                  :       275352.68 +/- 0.60% op/s\nhamt(10)                      :      4441970.69 +/- 0.83% op/s\nhamt_plus(10)                 :      5865476.21 +/- 0.60% op/s\npersistent-hash-trie(10)      :       217769.70 +/- 0.53% op/s\nmori hash_map(10)             :       451105.71 +/- 0.69% op/s\nimmutable(10)                 :            0.00 +/- 0.00% op/s\nseamlessImmutable(10)         :      1032501.82 +/- 0.57% op/s\n``\n. I commented out everything inmakeImmutableexcept foraddImmutabilityTag` and ran the tests again. Seems like a 50% increase for most tests, and up to 100% for some.\n```\nGet nth\nseamlessImmutable(10)         :     13306890.75 +/- 0.81% op/s\nput nth\nseamlessImmutable(10)         :       156080.34 +/- 0.87% op/s\nPut All\nseamlessImmutable(10)         :        14119.24 +/- 1.01% op/s\nseamlessImmutableBatch(10)    :        60817.56 +/- 0.91% op/s\nPut All (transient)\nseamlessImmutable(10)         :        79070.08 +/- 1.06% op/s\nremove nth\nseamlessImmutable(10)         :        99218.78 +/- 1.04% op/s\nRemove All\nseamlessImmutable(10)         :        10465.64 +/- 1.20% op/s\nseamlessImmutableBatch(10)    :       157722.65 +/- 1.31% op/s\nRemove All (transient)\nseamlessImmutable(10)         :        97212.40 +/- 1.20% op/s\nCount\nseamlessImmutable(10)         :      1849054.44 +/- 1.25% op/s\nKeys\nseamlessImmutable(10)         :      2132544.74 +/- 0.52% op/s\n```\n. @wmertens: not sure they are interested since seamless isn't hashtrie based? I guess that's why they haven't got a vanilla JS entry either.\nBut if you can check with them and get an ok I will clean up my branch, add regular JS and submit a PR.\n. @wmertens: hehe, ok :) yeah, it's an unfair comparison. Even for simple things like getting a count (the count test) then for a vanilla/seamless object you need Object.keys which is o(N) where the more complex libraries can hold their own count.\n. Now that there is a dev/prod mode maybe it would make sense to check this only in development mode? That way most cases can be found without sacrificing any performance.\nA really simple way would be to do a test before making it immutable, like:\nJSON.stringify(object);\nIf it contains a circular reference it will throw a TypeError with the message \"Converting circular structure to JSON\".\n. Ok! Instead of a boolean, what to you think about a mergeWith function or similar that takes a config object first (which the normal merge can use under the covers) so more config can be added later if needed?\nobj1.mergeWith({deep: true}, obj2);\nI have a use case where I would like to supply a custom merger sometimes, that could fit into this strategy.\nBut if you don't like it I will do a PR with the boolean.\n. @RangerMauve I agree in general, but if the With in the function name is for merging with the config I think it is natural if the mandatory config is first. Especially if it is a merge with multiple objects like:\nobj1.mergeWith({deep: true}, obj2, obj3, obj4, obj5);\nBut it doesn't matter much either way. Any thoughts @rtfeldman?\n. Sounds good to me!\n. I'm no expert at this but as far as I can tell something like this could work:\nIn the Immutable function, the new object is created with:\nvar clone = {};\nInstead the following can be done:\nvar clone = Object.create(Object.getPrototypeOf(obj);\nBut that won't work for Date, and as far as I can tell Date would require a special case in the Immutable function. So combined we would get:\n...\n} else if (obj instanceof Date) {\n  var clone = new Date(obj);\n  return makeImmutable(clone)\n} else {\n  var clone = Object.create(Object.getPrototypeOf(obj);\n  ...\nBut Object.create is a lot slower than {}. This makes it faster:\nvar prototype = Object.getPrototypeOf(obj);\nvar clone = prototype ? Object.create(prototype) : {};\nA bit slower in Chrome but still much slower in Firefox (but mainly since FF is much faster at doing {}). Source\nBut I don't know how much the performance of this single thing affects the entire process of making an object immutable.\nSo am I on the right track? And is there a faster/better way of checking for a prototype?\n. Yes, that sounds reasonable.\nBut instead of a generic solution for prototypes maybe a special case for Date handling could be useful? Since it is an built in type that is frequently used, and by using the new Date(obj) to clone it there shouldn't be any technical problem?\n. The last commit message should read: \"Only freeze and ban properties if in dev mode.\"\n. Now all tests are run for both the development build and the production build. There are a few exceptions, like checking if the object is frozen, where we only run it for one build. But then I have added a simple test for the other build too.\nI only placed the build config in the .spec.js files. Then I passed the config into the test functions in ImmutableObject/ and ImmutableArray/* so they could require in the correct Immutable build.\nI had to do some changes to TestUtil so that it uses the correct Immutable build depending on the config. Basically instead of exporting an object it exports a function that takes the chosen Immutable and returns an object with functions that uses the correct Immutable. This seemed like the cleanest way to do it, but I'm open to suggestions :smile: \n. @rtfeldman: Seems like it! Replacing the .toISOString() comparisons with .getTime() comparisons should solve the problem. You want me to add it to the current PR, a new one or do you want to do it yourself?\n. I just got access to an IE11 and tested it (and in a Firefox) and saw the problem with using the constructor:\nnew Date(originalDate).\nBut the following works in both:\nnew Date(originalDate.getTime()).\nI have seen a lot of examples doing it the first way and as far as I understood it should then use the .valueOf method on the date which generates the same output as .getTime in all browsers. So not sure why the first way fails, but I will change it to the second way.\nThanks for the suggestion @rtfeldman. A PR is coming, sorry for the mess.\n. The constructor new Date(originalDate) throws away the millseconds in some browsers (IE, FF) but not other (Chrome, others?).\nUsing new Date(originalDate.getTime()) preserves the milliseconds. This is fixed in PR #33.\n. Tested, and it works, in latest Chrome, Firefox and IE.\n. Remember to do a grunt build after merge to generate the new prod and dev files.\n. @rtfeldman: Ok! But will Travis run Grunt to generate the new prod/dev files? If it uses the current commited ones in master the tests will continue to fail.\n. Sounds good, no urgency for me!\n. I think the biggest drawback is that you have to do push differently for normal and immutable arrays, and there isn't anything telling you that you are doing it wrong if you push on an immutable array and don't take care of the result.\nIt can be especially confusing if you have a code base where you use both regular arrays and immutable arrays.\n. Yeah, it is easy to differ visually. But if you are working with code that uses both mutable and immutable arrays and you do a push on an immutable array now you get an error and you are made aware of it during development.\nWith this change you might by mistake do a push on an immutable array and forget to handle the result and get no warning about it. It might then lead to bugs that can be tricky to locate the source of.\nSo you have a valid point, but I'm not personally convinced that the benefits are greater than the drawbacks. And if push should be changed in this way then maybe all other banned mutating methods should be changed in the same way too?\n. @rtfeldman cases like this could be handled by a custom merger if we add the following to addToResult in the merge function:\nRight now it looks like:\njavascript\nvar mergerResult = merger && merger(currentObj[key], immutableValue, config);\nIf we extend that to:\njavascript\nvar mergerResult = merger && merger(currentObj[key], immutableValue, config);\nif (mergerResult && mergerResult === currentObj[key]) return;\nThen if a merger returns something and it is the same thing as the property in the currentObj we could abort addToResult.\nCombining that with a custom merger that returns the array from the currentObj if they contain the same items:\n``` javascript\nfunction equalityArrayMerger(current, other) {\n  if (!(current instanceof Array) || !(other instanceof Array)) return;\n  if (current.length !== other.length) return;\nfor (var i = 0; i < current.length; i++) {\n    if (current[i] !== other[i]) return;\n  }\nreturn current;\n}\n```\nwould give the desired results.\nBut not sure if it is worth adding if there is another long term goal with deepEquals? It's a minor change but it will add another check in the addToResult function. And this was only a quick test, I haven't checked how/if it affects other things.\n. @cr0cK: now that PR #41 has been merged you should be able, after the next release, to pass in the following or similar to the merge to get your example to work:\n``` javascript\nfunction equalityArrayMerger(current, other) {\n  if (!(current instanceof Array) || !(other instanceof Array)) return;\n  if (current.length !== other.length) return;\nfor (var i = 0; i < current.length; i++) {\n    if (current[i] !== other[i]) return;\n  }\nreturn current;\n}\n...\n\ni2 = i.merge(o2, {merger: equalityArrayMerger})\n{ a: [ 1, 2 ] }\ni === i2\ntrue\n```\n\nIt will override the merge for array properties and return the same reference if they contain the same list of values in both objects.\nNote that it will not work with current master until a grunt build has been run.\n. @cr0cK: it's released now. And if you use Node/Browserify I have added the equalityArrayMerger in this project if you prefer that instead of copying the function above.\nAs for the default behaviour I agree with what @rtfeldman said above, as long as it is easy to get back to the current behaviour when a deep check isn't needed or is too expensive.\n. @ianp: If you want to do a deep merge then the second argument shouldn't be true, it should be {deep: true} like:\njavascript\nobj.merge({streams: {a: { loading: true }}}, {deep: true});\nIt produces the desired results:\njavascript\n{\n  streams: {\n    a: {name: 'Conversations', channel: [Object], loading: true},\n    b: {name: '@Mentions', channel: [Object], loading: false},\n    c: {name: 'Facebook', channel: [Object], loading: false}\n  },\n  streamOrder: ['c', 'a', 'b']\n}\n. @alesch: Does it work if you do: import I from 'seamless-immutable'?\n. I'm using babel and browserify and the following works for me:\n``` javascript\nimport I from \"seamless-immutable\";\nconst l = I([1, 2, 3]);\nconsole.log(l);   // [1, 2, 3, __immutable_invariants_hold: true]\n``\n. @alesch: nice! my IDE complains also if I do:import I from \"seamless-immutable\";but if I do:import immutable from \"seamless-immutable\";it doesnt. It's because functions with a name that starts with an uppercase letter are supposed to be constructor functions and used withnew`.\n. @rtfeldman any thoughts on this? I noticed now that I forgot to mention you in the PR.\n. What do you mean? If you merge A with B and both contain the array named C then the result will contain the array from B. Do you want the result to ignore the array from B and keep the array from A?\n. This is my output when I test with 3.0.0 and 4.0.2: \nvar o = immutable({arr: [{id: 2}]});\no = o.merge({arr: [{id: 3}]});\n// o is {arr: [{id: 3}]}\n. @rtfeldman :+1: nice, 4 minutes from report to release :smile: \n. @estaub yes, they will work. All objects and arrays are normal javascript objects and arrays with the exception that they are frozen and mutating methods throw errors.\n. From the project description:\n\nIn the development build, objects are frozen. (Note that Safari is relatively slow to iterate over frozen objects.) The development build also overrides unsupported methods (methods that ordinarily mutate the underlying data structure) to throw helpful exceptions.\nThe production (minified) build does neither of these, which significantly improves performance.\n\nSo if you use the main /src/seamless-immutable.js it just works and respects your NODE_ENV setting if you run it in node. If you run it in a browser you can either use the same file if you have a build environment where you have configured it or you can use the /seamless-immutable.development.js or /seamless-immutable.production.js directly which requires no setup of NODE_ENV.\n. If you want to use the default /src/seamless-immutable.js and configure your build to set the correct mode then do as they suggest in React: https://facebook.github.io/react/downloads.html#npm (check the note for npm). It works in the same way for seamless-immutable.\n. @lelandmiller looks like a bug and a legit fix to me! @rtfeldman ?\n. @chadly that's strange. I added the following test case:\n``` javascript\n    it(\"merges arrays with the same result as chained merges\", function() {\n      var expected = Immutable({ username: \"homer.simpson\", city: \"Springfield\", kids: 3 })\n  var original = Immutable({ username: \"homer.simpson\"});\n  var toMerge1 = { username: \"HoMeR.SiMpSoN\", city: \"Springfield\" };\n  var toMerge2 = { username: \"homer.simpson\", kids: 3 };\n\n  var actualChainedMerges = original.merge(toMerge1).merge(toMerge2);\n  var actualArrayMerge = original.merge([toMerge1, toMerge2]);\n\n  TestUtils.assertJsonEqual(actualChainedMerges, expected);\n  TestUtils.assertJsonEqual(actualArrayMerge, expected);\n});\n\n```\nand it works and produces the correct result in both cases.\n. Using lodash works fine otherwise:\n```\nimport _get from 'lodash/get';\nconst foo = get(state, 'bar.baz.foo', '');\n``\n. @slashwhatever the result in your example is a javascript object, not a collection of any type. So you have to check the number of keys in the object withObject.keys(myImmutable).lengthor use something like.size` from lodash.\nIf you make an array immutable you can just use .length on it or again _.size from lodash.\n. @slashwhatever yes, but the reasoning of seamless is that the types should be plain javascript types, with as few modifications as possible. So _.size is probably the best suggestion for this use case.\n. ",
    "RangerMauve": "What about a method on Immutable that looks like Immutable.setProduction(true/false), and then have people explicitly enable it and define their own way of detecting production mode?\n. IMO it's usually nicer to have configs or optional flags as the last argument in a function and not the first.\n. @crudh That's a good point, actually. And it'd work well once rest paramters become mainstream.\n. Should arrays be concatenated together?\n. Just to interject, the docs say that the arguments to concat don't have to be an array, so the square brackets can be left out, and it'll look more like your push code.\n. @bradwestfall array is immutable. .concat() always returns a new array. Your example should instead be:\njavascript\nlet array = Immutable([1,2,3]).concat([4])\nlet array2 = array.concat([5])\nconsole.log(array2) // [1,2,3,4,5]\n. What about a method on Immutable that looks like Immutable.setProduction(true/false), and then have people explicitly enable it and define their own way of detecting production mode?\n. IMO it's usually nicer to have configs or optional flags as the last argument in a function and not the first.\n. @crudh That's a good point, actually. And it'd work well once rest paramters become mainstream.\n. Should arrays be concatenated together?\n. Just to interject, the docs say that the arguments to concat don't have to be an array, so the square brackets can be left out, and it'll look more like your push code.\n. @bradwestfall array is immutable. .concat() always returns a new array. Your example should instead be:\njavascript\nlet array = Immutable([1,2,3]).concat([4])\nlet array2 = array.concat([5])\nconsole.log(array2) // [1,2,3,4,5]\n. ",
    "wmertens": "@crudh could you put that in a PR for that benchmark (maybe along with regular JS objects)? I'd be interested in trying it out myself...\n. @crudh turns out they make the benchmark too slow, see referenced issue :-) \n. Hmm, lodash only dropped support for ie8 and below. So either you found a\nbug in lodash or you need to load the es5 shim?\nOn Tue, Jan 31, 2017, 10:56 PM Ryan Temple notifications@github.com wrote:\n\nI'm still seeing the same error as above - the only test that seems to\nbreak locally is the omitBy test here\nhttps://github.com/rtfeldman/seamless-immutable/blob/master/test/ImmutableObject/test-without.js#L176\nwhich I've raised a PR for #196\nhttps://github.com/rtfeldman/seamless-immutable/pull/196\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/179#issuecomment-276505662,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AADWlrzUVyv2v-vCufqXdpexQpuKta3Kks5rX64mgaJpZM4LKEr4\n.\n. @crudh could you put that in a PR for that benchmark (maybe along with regular JS objects)? I'd be interested in trying it out myself...\n. @crudh turns out they make the benchmark too slow, see referenced issue :-) \n. Hmm, lodash only dropped support for ie8 and below. So either you found a\nbug in lodash or you need to load the es5 shim?\n\nOn Tue, Jan 31, 2017, 10:56 PM Ryan Temple notifications@github.com wrote:\n\nI'm still seeing the same error as above - the only test that seems to\nbreak locally is the omitBy test here\nhttps://github.com/rtfeldman/seamless-immutable/blob/master/test/ImmutableObject/test-without.js#L176\nwhich I've raised a PR for #196\nhttps://github.com/rtfeldman/seamless-immutable/pull/196\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/179#issuecomment-276505662,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AADWlrzUVyv2v-vCufqXdpexQpuKta3Kks5rX64mgaJpZM4LKEr4\n.\n. \n",
    "jeffbski": "Has the benchmark been redone to use prod mode yet? It would be interesting to see how things compare.\n. +1\n. I believe the question is asking whether there is anything like the Immutable.js cursor library for seamless. https://github.com/facebook/immutable-js/tree/master/contrib/cursor\nWith immutable.js and cursors you can easily create an atom that when you update things via the cursor the listeners fire automatically telling you of new state. Things are still immutable and all. Using immstruct makes that real easy to setup. \nWith the js-atom approach above you have to make changes from the top, possibly using a deep path, while with the cursor approach, you get cursors which are pointing to deep structure and you call update right on them which in turn causes new immutable atom to be created and listeners to fire.\n. Maybe something like immutable.js's withMutations() would be a nice addition to the api for this?\n. Has the benchmark been redone to use prod mode yet? It would be interesting to see how things compare.\n. +1\n. I believe the question is asking whether there is anything like the Immutable.js cursor library for seamless. https://github.com/facebook/immutable-js/tree/master/contrib/cursor\nWith immutable.js and cursors you can easily create an atom that when you update things via the cursor the listeners fire automatically telling you of new state. Things are still immutable and all. Using immstruct makes that real easy to setup. \nWith the js-atom approach above you have to make changes from the top, possibly using a deep path, while with the cursor approach, you get cursors which are pointing to deep structure and you call update right on them which in turn causes new immutable atom to be created and listeners to fire.\n. Maybe something like immutable.js's withMutations() would be a nice addition to the api for this?\n. ",
    "vegetabill": "FYI I was creating an immutable copy of a Backbone object that was using the backbone-associations add-on and ran into this. immutablejs handles them fine but I liked the sound of this library for all the reasons mentioned in your blog: http://noredinktech.tumblr.com/post/107617838018/switching-from-immutable-js-to-seamless-immutable\n. FYI I was creating an immutable copy of a Backbone object that was using the backbone-associations add-on and ran into this. immutablejs handles them fine but I liked the sound of this library for all the reasons mentioned in your blog: http://noredinktech.tumblr.com/post/107617838018/switching-from-immutable-js-to-seamless-immutable\n. ",
    "seanhess": "@natew I think cursors can be implemented separately from the data structure. See here: https://github.com/kualico/easy-cursors\n. Cool! But wouldn't newItem be mutable afterward? \n. I still think something more terse might be a good addition to the library, but nothing I can't fix with my own function. Thanks for being awesome!\n. @natew I think cursors can be implemented separately from the data structure. See here: https://github.com/kualico/easy-cursors\n. Cool! But wouldn't newItem be mutable afterward? \n. I still think something more terse might be a good addition to the library, but nothing I can't fix with my own function. Thanks for being awesome!\n. ",
    "dariocravero": "Thanks for the explanation. It makes sense :). So how are you going about those when you're using methods like sort? Are you doing something like this?\nlet array = Immutable([3, 1, 4])\narray = Immutable(array.asMutable().sort())\n. Good stuff :) Will give it a go then!\n. Hi all,\nI understand the need to keep things as tight as possible but this is a big issue when you're trying to use custom types that use the prototype.\nFor instance, I'm building a lookup mechanism on top of route name matcher called Houkou and I would like to keep the object of patterns immutable.\nHowever, the way I see it, whatever happens within the Houkou object is its responsibility.\nThe problem with the current approach is that every Houkou object I instantiate gets its prototype stripped away. And not only its own prototype but those of its properties are gone too. So, for instance, I'm loosing validate, match and deeper in the structure its regex's methods.\nEven though I can assign these myself when creating my Houkou instance, it quickly becomes quite unmanageable when you have to track every dependency on the library that you're using for methods that need to be rewired... :(\nI understand the goals of seamless-immutable. Probably a solution in this case would be to deal with RegExp objects in the same way #31 deals with Date objects. A simpler approach would be to allow an immutable object to be created up to certain level or to exclude certain objects.\nWhat are your thoughts on this?\nThanks,\nDar\u00edo\n. @rtfeldman I'm sorry I haven't come back to you on this before.\nI think that might be a good starting point. That would at least allow us to whitelist more complex objects at will.\n. Good stuff! Don't worry, I'll see if I can give it a go at some stage. As a\nmatter of fact, this constrain made me reevaluate my data structures and\nallowed me to simplify things big time, so it was already a win :)\nOn Wed, 24 Jun 2015 22:58 Richard Feldman notifications@github.com wrote:\n\nCool. This is admittedly not a high priority for me in terms of\nimplementation, but I'm on board with the approach! [image: :smiley:]\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/25#issuecomment-115023547\n.\n. Thanks for the explanation. It makes sense :). So how are you going about those when you're using methods like sort? Are you doing something like this?\n\nlet array = Immutable([3, 1, 4])\narray = Immutable(array.asMutable().sort())\n. Good stuff :) Will give it a go then!\n. Hi all,\nI understand the need to keep things as tight as possible but this is a big issue when you're trying to use custom types that use the prototype.\nFor instance, I'm building a lookup mechanism on top of route name matcher called Houkou and I would like to keep the object of patterns immutable.\nHowever, the way I see it, whatever happens within the Houkou object is its responsibility.\nThe problem with the current approach is that every Houkou object I instantiate gets its prototype stripped away. And not only its own prototype but those of its properties are gone too. So, for instance, I'm loosing validate, match and deeper in the structure its regex's methods.\nEven though I can assign these myself when creating my Houkou instance, it quickly becomes quite unmanageable when you have to track every dependency on the library that you're using for methods that need to be rewired... :(\nI understand the goals of seamless-immutable. Probably a solution in this case would be to deal with RegExp objects in the same way #31 deals with Date objects. A simpler approach would be to allow an immutable object to be created up to certain level or to exclude certain objects.\nWhat are your thoughts on this?\nThanks,\nDar\u00edo\n. @rtfeldman I'm sorry I haven't come back to you on this before.\nI think that might be a good starting point. That would at least allow us to whitelist more complex objects at will.\n. Good stuff! Don't worry, I'll see if I can give it a go at some stage. As a\nmatter of fact, this constrain made me reevaluate my data structures and\nallowed me to simplify things big time, so it was already a win :)\nOn Wed, 24 Jun 2015 22:58 Richard Feldman notifications@github.com wrote:\n\nCool. This is admittedly not a high priority for me in terms of\nimplementation, but I'm on board with the approach! [image: :smiley:]\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/25#issuecomment-115023547\n.\n. \n",
    "tylercollier": "What about an option for whether an error should be thrown? I am appreciative of the thrown error as I change from ImmutableJS to this library. But after the transition, my code is cluttered using _.sortBy() instead of the built-in sort().\nWhile the workaround is not terrible, I thought I'd voice my opinion so others who find this issue know there's at least 1 other person wishing for it!\n. Thanks for the link to that section of the doc, which I read (and admit to not reading before, but you already had me sold on performance from your blog post :-) I think you saw my original comment, which was phrased as an option that I might toggle one way in dev and another in production, but I rephrased it because that's not what I'm really after. What I'd like is an option I can set. My concern here is convenience for me as a developer rather than performance. I'm guessing you have a build step that pulls those checks out when you create a minified production build, rather than an option I can set?\n. What about an option for whether an error should be thrown? I am appreciative of the thrown error as I change from ImmutableJS to this library. But after the transition, my code is cluttered using _.sortBy() instead of the built-in sort().\nWhile the workaround is not terrible, I thought I'd voice my opinion so others who find this issue know there's at least 1 other person wishing for it!\n. Thanks for the link to that section of the doc, which I read (and admit to not reading before, but you already had me sold on performance from your blog post :-) I think you saw my original comment, which was phrased as an option that I might toggle one way in dev and another in production, but I rephrased it because that's not what I'm really after. What I'd like is an option I can set. My concern here is convenience for me as a developer rather than performance. I'm guessing you have a build step that pulls those checks out when you create a minified production build, rather than an option I can set?\n. ",
    "nin-jin": "You can add method sorted(fn) that returns sorted copy of array.\n. You can add method sorted(fn) that returns sorted copy of array.\n. ",
    "Nickman87": "I like the idea of introducing additional methods to support the same functionality as original mutation methods, but have them return an immutable result instead as @nin-jin suggested.\nMaybe even more obvious like sort_immutable() so you should know what to expect from it?\nThis would remove the need for custom functions doing the same thing but requiring an additional dependency in your code.\n. I like the idea of introducing additional methods to support the same functionality as original mutation methods, but have them return an immutable result instead as @nin-jin suggested.\nMaybe even more obvious like sort_immutable() so you should know what to expect from it?\nThis would remove the need for custom functions doing the same thing but requiring an additional dependency in your code.\n. ",
    "tusharmath": "What should the custom merger return if I want to delete a particular key?\n. Must needed.\n. This is a little wierd because u see \u2014\n``` javascript\nvar obj = Immutable({\n  a: {aa: 1},\n  b: {bb: 2}\n})\nvar obj2 = obj.merge({b: {bb: 2}}, {deep: true})\nconsole.log(obj.b === obj2.b, obj.a === obj2.a) // actually returns true for both cases.\n```\nSo you are doing a check here right? I can get the same behavior by just wrapping the whole object inside another temp object.\n. @rtfeldman No need for sorry. Thanks a ton for fixing it so quickly.\n. I am not sure about this. There could be so many cases where you want to store it as an immutable. Though in this case we don't need it to be immutable.\n. No. As per the above profiling it seems like the recursive conversion to Immutable takes a lot of time. I started facing this issue when I had a huge array of numbers that I wanted to plot on a graph.\nHow about doing it asynchronously?\n. I don't think there is anything here that seamless-immutable should be concerned with. The co module handles generators specially and that's why it works for the other two cases. If the module realises that the returned value is an generator then it will start iterating over it.\nIn the printImmutableGenerator what happens is the map function iteratively converts the value (generator) into an immutable, which obviously your co module doesn't understand. \nSo the solution is to use the native map function on the immutable \u2014\njavascript\nconst printImmutableGenerator = function*() {\n  const immutableArr = Immutable([4, 5, 6]);\n  yield Array.prototype.map.call(immutableArr, function*(n) {\n    console.log(n);\n  });\n};\nOUTPUT: 4, 5, 6\n. Ping @rtfeldman \n. I can understand, so you basically need to configure two env variables \u2014 NPM_TOKEN & GH_TOKEN in your travis build.\n1. NPM_TOKEN would be available at ~/.npmrc.\n2. GH_TOKEN can be created here \u2014 https://github.com/settings/tokens\n. Take a look at this link \u2014 https://www.npmjs.com/settings/tokens\n\nWhen you log into npm via the Command Line Interface (CLI), we create a unique identifier that we give to your computer, which is stored in your .npmrc file. The token gives your CLI the ability to do things like publish and unpublish packages, and manage owners and teams. You can share tokens with, for example, CI systems to allow them to download and publish your packages.\n. @rtfeldman Let me know if you need something else from me.\n. @sandro-pasquali  How is this supposed to behave like an immutable? The very fact that a generator generates values means that its not static and hence a mutable. \n. @mglazer-cengage also take a look at https://github.com/tusharmath/reactive-storage. It will expose the store as an Observable. \n\napologies for a little bit of self promotion\n. What should the custom merger return if I want to delete a particular key?\n. Must needed.\n. This is a little wierd because u see \u2014\n``` javascript\nvar obj = Immutable({\n  a: {aa: 1},\n  b: {bb: 2}\n})\nvar obj2 = obj.merge({b: {bb: 2}}, {deep: true})\nconsole.log(obj.b === obj2.b, obj.a === obj2.a) // actually returns true for both cases.\n```\nSo you are doing a check here right? I can get the same behavior by just wrapping the whole object inside another temp object.\n. @rtfeldman No need for sorry. Thanks a ton for fixing it so quickly.\n. I am not sure about this. There could be so many cases where you want to store it as an immutable. Though in this case we don't need it to be immutable.\n. No. As per the above profiling it seems like the recursive conversion to Immutable takes a lot of time. I started facing this issue when I had a huge array of numbers that I wanted to plot on a graph.\nHow about doing it asynchronously?\n. I don't think there is anything here that seamless-immutable should be concerned with. The co module handles generators specially and that's why it works for the other two cases. If the module realises that the returned value is an generator then it will start iterating over it.\nIn the printImmutableGenerator what happens is the map function iteratively converts the value (generator) into an immutable, which obviously your co module doesn't understand. \nSo the solution is to use the native map function on the immutable \u2014\njavascript\nconst printImmutableGenerator = function*() {\n  const immutableArr = Immutable([4, 5, 6]);\n  yield Array.prototype.map.call(immutableArr, function*(n) {\n    console.log(n);\n  });\n};\nOUTPUT: 4, 5, 6\n. Ping @rtfeldman \n. I can understand, so you basically need to configure two env variables \u2014 NPM_TOKEN & GH_TOKEN in your travis build.\n1. NPM_TOKEN would be available at ~/.npmrc.\n2. GH_TOKEN can be created here \u2014 https://github.com/settings/tokens\n. Take a look at this link \u2014 https://www.npmjs.com/settings/tokens\n\nWhen you log into npm via the Command Line Interface (CLI), we create a unique identifier that we give to your computer, which is stored in your .npmrc file. The token gives your CLI the ability to do things like publish and unpublish packages, and manage owners and teams. You can share tokens with, for example, CI systems to allow them to download and publish your packages.\n. @rtfeldman Let me know if you need something else from me.\n. @sandro-pasquali  How is this supposed to behave like an immutable? The very fact that a generator generates values means that its not static and hence a mutable. \n. @mglazer-cengage also take a look at https://github.com/tusharmath/reactive-storage. It will expose the store as an Observable. \n\napologies for a little bit of self promotion\n. ",
    "ivan-kleshnin": "I think that's pretty easy to differ visually:\njs\nrobots.push(robot); // mutable push\n...\nlet count = robots.push(robot) // mutable push\n...\nrobots = robots.push(robot); // immutable push\n...\nlet robots2 = robots.push(robot); // immutable push\nIt's a good tone today to use concat instead of push. So when you see push you're going to be especially attentive in any case. That's from code-reading point of view. From code-development point of view... you need to know where you data is mutable and where is immutable to not get immutable exceptions right? \npush behaves differently just in the same manner as x[0] = 1 behaves differently (throws warnings or do mutation). If second is not confusing for you, first also shouldn't.\nI'm not saying your arguments are meaningless. They are good. \nI'm saying that from my personal opinion benefits are greater than drawbacks.\n. > And if push should be changed in this way then maybe all other banned mutating methods should be changed in the same way too?\nMaybe. I can recall only push being needed all the time but, yeah, banned. What else?\nMaybe a bigger picture will guide the best decision here.\n. Well, I was pretty sure about this proposal being rejected so no disappointment here :smile: \nThank you guys for discussion :thumbsup: hope to give this lib a better try soon. \n. I think that's pretty easy to differ visually:\njs\nrobots.push(robot); // mutable push\n...\nlet count = robots.push(robot) // mutable push\n...\nrobots = robots.push(robot); // immutable push\n...\nlet robots2 = robots.push(robot); // immutable push\nIt's a good tone today to use concat instead of push. So when you see push you're going to be especially attentive in any case. That's from code-reading point of view. From code-development point of view... you need to know where you data is mutable and where is immutable to not get immutable exceptions right? \npush behaves differently just in the same manner as x[0] = 1 behaves differently (throws warnings or do mutation). If second is not confusing for you, first also shouldn't.\nI'm not saying your arguments are meaningless. They are good. \nI'm saying that from my personal opinion benefits are greater than drawbacks.\n. > And if push should be changed in this way then maybe all other banned mutating methods should be changed in the same way too?\nMaybe. I can recall only push being needed all the time but, yeah, banned. What else?\nMaybe a bigger picture will guide the best decision here.\n. Well, I was pretty sure about this proposal being rejected so no disappointment here :smile: \nThank you guys for discussion :thumbsup: hope to give this lib a better try soon. \n. ",
    "holyjak": "Thanks a lot! Perhaps it would be useful to add this to the README?\n. Thanks. I need to think through it to see whether filter, concat etc. cover\nall modification cases. I guess eg. replacing an element at a given index\ncould be achieved with map though that is cumbersome.\n5. juni 2015 19:30 skrev \"Richard Feldman\" notifications@github.com:\n\nFor that example, I would just use concat:\n// equivalent to Immutable([1, 2, 3, 4])\nImmutable([1,2,3]).concat([4])\nThe Object and Array methods that do not mutate are still available,\nalthough they return Immutable instances instead of normal arrays and\nobjects.\nThe non-mutating array methods seamless-immutable supports are map, filter,\nslice, concat, reduce, and reduceRight, and for objects just keys.\nDoes that help?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/43#issuecomment-109370637\n.\n. So if I should sum it up, seamless-immutable supports most/all mutation cases though sometimes you need to think carefully how to combine the available methods to achieve it.\n\nMy particular use case is: If an array has an element with a given id, remove it and re-insert it to the end with an increased count; otherwise just append it. So I'd need to do something like:\njavascript\nvar _ = require(\"lodash\");\nvar log = Immutable([]);\nfunction add(idToFind) {\nvar foundIdx = _.find(log, { id: idToFind });\nvar count = 1;\nif (foundIdx) {\n  log = log.slice(0, foundIdx).concat(log.slice(foundIdx+1));\n  // With icepick I could do: `log = i.splice(log, foundIdx, 1);`\n  count += 1;\n}\nlog = log.concat({id: idToFind, count: count});\n} //fn\nIn some cases, when performance is important - e.g. when I need to \"change\" an element of a long array relatively often - then I have to use a less straightforward solution. For example:\n``` javascript\n// This is slow as it iterates over the whole array each time, not stopping after the element is found:\nlog = log.map(function(val, idx) { if(val.id === idToFind) return {id: val.id, count: val.count+1}; else return val; });\n// This is hopefully faster since it only needs to iterate on average over 1/2 of the array\n// (even though we still need to combine a few operations):\nvar foundIdx = _.find(log, { id: idToFind });\nvar val = log[idToFind]; var newval = {id: val.id, count: val.count+1};\nlog = log.slice(0, foundIdx).concat(newval).concat(log.slice(foundIdx+1))\n```\nOn the other hand it might me better to just use mutable data structures for this and only use immutability where changes are infrequent.\n. I see I was mistaken, dev mode is the default.\n. Hello, my question is: In Node, what are the ways to switch on the dev or the prod mode? \nI have seen the NODE_ENV in the code without really understand when it is effective so likely the line 3 isn't true.\n. Sorry for a late response. Thanks, @oliverwoodings, for the clarifying on my behalf and for the response. I was interested both in being able to switch between dev/prod manually (depending on what I require) and in a build step. I have the answers I need but perhaps they should be included in the docs [more visibly] as well? Thank you all!\n. I guess we want something that can be used like this:\n```\nReact.createClass({\n  propTypes: {\n    array: Immutable.PropTypes.array,\n    object: Immutable.PropTypes.object\n}});\nThen we can simply implement it this way: ```\nfunction validate(type, props, propName, componentName) {\n     componentName = comopnentName || 'ANONYMOUS';\n      var msg = componentName + \".props.\" + propName + \" is not \";\n      if (type === Array && ! (props[propName] instanceof Array)) return new Error(msg + ' an array');\n      if (type === Object && (! (props[propName] instanceof Object) || props[propName] instanceof Array)) return new Error(msg + 'an Object');\n      if (!Immutable.isImmutable(props[propName])) {\n        return new Error(msg + ' immutable');\n      }\n      return null;\n    }\nImmutable.PropTypes = {\n  array: validate.bind(undefined, Array),\n  object: validate.bind(undefined, Object)\n};\n``````\n(If we want to support also .isRequred then we can follow http://www.ian-thomas.net/custom-proptype-validation-with-react/ . Or/and it is possible to combine with the all(...arrayOfValidators) validator from react-prop-types)\n. I understand the desire to keep the library small and appreciate it.\nI am not sure how common my use case is. In each case, accepting a function instead of values provides the ultimate power to the user. My particular use case was to filter out properties, that did not satisfy a condition: \nconst unknownProducts = _.chain(products).keys().reject(knownProduct).value();\nconst onlyKnownProducts = products.without(unknownProducts);\n// I would have preferred:\nconst onlyKnownProducts = products.without((product, productId) => ! knownProduct(productId));\nI do not think that it would either be complex or require many lines of code to add this functionality:\n```\nfunction without(keysToRemove) {\n    // Calling .without() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\nvar remove;\nif (keysToRemove instanceof function) {\n      remove = keysToRemove; \n    } else {\n      var keysToRemoveArray = (keysToRemove instanceof Array) ? \n         keysToRemove : Array.prototype.slice.call(arguments);\n      remove = function(val, key) { return keysToRemoveArray.indexOf(key) >= 0; }\n    }\nvar result = this.instantiateEmptyObject();\n\nfor (var key in this) {\n  if (this.hasOwnProperty(key) && ! remove(this[key], key)) {\n    result[key] = this[key];\n  }\n}\n\n```\nBut you are of course the arbiter of the usefulness vs. cost :-)\n. My pleasure\nOn Thu, 14 Jan 2016 at 17:39, Richard Feldman notifications@github.com\nwrote:\n\nOld tests pass for me too.\nLooks great, thanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/pull/93#issuecomment-171694853\n.\n. Yes. How to run the tests in FF?\nOn Fri, 15 Jan 2016 at 00:54, Richard Feldman notifications@github.com\nwrote:\n@jakubholynet https://github.com/jakubholynet Hm, appears that tests\nare breaking in Firefox. I fixed some linter errors in the hopes that's all\nit was, but it appears to be more than that.\nMind taking a look?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/pull/93#issuecomment-171820697\n.\n. Hi @rtfeldman, as mentioned I'd be happy to help with the failing tests but I need you to tell me how to run them :-)\n\nOr have you actually fixed them? The commits seem to indicate that ...\n. the pass for me:\n\n. @rtfeldman So this is duplicate of #124 but that was closed with \"won't fix\" with the explanation that Immutable should only store plain old data - i.e. that regular expressions, Errors etc. can not be included in an Immutable data structure. Correct?\nPerhaps, if that is the case, it should be clearly documented in the README and, even better, an exception should be thrown when trying to include any other then supported type of data (i.e. fail quickly and with a clear error message then later with a mysterious error). What do you think?\nAlso, according to the README, it is possible to include \"mutable\" elements of type Date, function, React component. That provides a simple workaround: instead of using prop: RegExp(..), I could use () => new RegExp(). But wouldn't it be even better to expand this and allow the user to define what \"mutable\" data can be part of an Immutable data structure? Something like I proposed in 4. above or something similar (a list of types/paths to leave as they are ...).\nThoughts?\n. It also causes Babel to fail:\n```\n$ babel-node\n\nvar Immutable = require(\"seamless-immutable\");\n(new Immutable.ImmutableError(\"xxxx\")).stack\nTypeError: Function.prototype.toString is not generic\n    at Function.toString (native)\n    at Function.toString (/Users/me/Work/project/node_modules/babel/node_modules/babel-core/node_modules/core-js/modules/$.redefine.js:26:62)\n    at Function.prepareStackTrace (/Users/me/Work/project/node_modules/babel/node_modules/babel-core/node_modules/source-map-support/source-map-support.js:303:16)\n    at repl:3:37\n    at Object.exports.runInThisContext (vm.js:54:17)\n    at _eval (/Users/me/Work/project/node_modules/babel/lib/_babel-node.js:86:26)\n```\n\nA standard error works without a problem: ```\n\n(new Error(\"xxx\")).stack\n'Error: xxx\\n    at repl:3:1\\n    at Object.exports.runInThisContext (vm.js:54:17)\\n    at _eval (/Users/me/Work/project/node_modules/babel/lib/_babel-node.js:86:26)\\n    at REPLServer.replEval (/Users/me/Work/project/node_modules/babel/lib/_babel-node.js:169:14)\\n    at bound (domain.js:280:14)\\n    at REPLServer.runBound as eval\\n    at REPLServer. (repl.js:393:12)\\n    at emitOne (events.js:77:13)\\n    at REPLServer.emit (events.js:169:7)\\n    at REPLServer.Interface._onLine (readline.js:210:10)'```\n\nTo troubleshoot the actual exception, you can temporarily do something like this (ES6):\njs\nError.prepareStackTrace = function(error, stack) {\n    return stack.map(frame => `${frame.getTypeName() || ''}.${frame.getFunctionName() || \"<anonymous fn>\"} at ${frame.getFileName()}:${frame.getLineNumber()}`).join(\"\\n\");\n};. Fixing for Node: Couldn't we just do\njs\nvar util = undefined;\ntry { util = require(\"util\"); } catch () {}\n...\nif (util) {\n  util.inherits(Immutable, Error);\n} else {\n  ImmutableError.prototype = Error.prototype; // + do something to fix it in the browser if necessary\n}. Thanks a lot! Perhaps it would be useful to add this to the README?\n. Thanks. I need to think through it to see whether filter, concat etc. cover\nall modification cases. I guess eg. replacing an element at a given index\ncould be achieved with map though that is cumbersome.\n5. juni 2015 19:30 skrev \"Richard Feldman\" notifications@github.com:\n\nFor that example, I would just use concat:\n// equivalent to Immutable([1, 2, 3, 4])\nImmutable([1,2,3]).concat([4])\nThe Object and Array methods that do not mutate are still available,\nalthough they return Immutable instances instead of normal arrays and\nobjects.\nThe non-mutating array methods seamless-immutable supports are map, filter,\nslice, concat, reduce, and reduceRight, and for objects just keys.\nDoes that help?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/43#issuecomment-109370637\n.\n. So if I should sum it up, seamless-immutable supports most/all mutation cases though sometimes you need to think carefully how to combine the available methods to achieve it.\n\nMy particular use case is: If an array has an element with a given id, remove it and re-insert it to the end with an increased count; otherwise just append it. So I'd need to do something like:\njavascript\nvar _ = require(\"lodash\");\nvar log = Immutable([]);\nfunction add(idToFind) {\nvar foundIdx = _.find(log, { id: idToFind });\nvar count = 1;\nif (foundIdx) {\n  log = log.slice(0, foundIdx).concat(log.slice(foundIdx+1));\n  // With icepick I could do: `log = i.splice(log, foundIdx, 1);`\n  count += 1;\n}\nlog = log.concat({id: idToFind, count: count});\n} //fn\nIn some cases, when performance is important - e.g. when I need to \"change\" an element of a long array relatively often - then I have to use a less straightforward solution. For example:\n``` javascript\n// This is slow as it iterates over the whole array each time, not stopping after the element is found:\nlog = log.map(function(val, idx) { if(val.id === idToFind) return {id: val.id, count: val.count+1}; else return val; });\n// This is hopefully faster since it only needs to iterate on average over 1/2 of the array\n// (even though we still need to combine a few operations):\nvar foundIdx = _.find(log, { id: idToFind });\nvar val = log[idToFind]; var newval = {id: val.id, count: val.count+1};\nlog = log.slice(0, foundIdx).concat(newval).concat(log.slice(foundIdx+1))\n```\nOn the other hand it might me better to just use mutable data structures for this and only use immutability where changes are infrequent.\n. I see I was mistaken, dev mode is the default.\n. Hello, my question is: In Node, what are the ways to switch on the dev or the prod mode? \nI have seen the NODE_ENV in the code without really understand when it is effective so likely the line 3 isn't true.\n. Sorry for a late response. Thanks, @oliverwoodings, for the clarifying on my behalf and for the response. I was interested both in being able to switch between dev/prod manually (depending on what I require) and in a build step. I have the answers I need but perhaps they should be included in the docs [more visibly] as well? Thank you all!\n. I guess we want something that can be used like this:\n```\nReact.createClass({\n  propTypes: {\n    array: Immutable.PropTypes.array,\n    object: Immutable.PropTypes.object\n}});\nThen we can simply implement it this way: ```\nfunction validate(type, props, propName, componentName) {\n     componentName = comopnentName || 'ANONYMOUS';\n      var msg = componentName + \".props.\" + propName + \" is not \";\n      if (type === Array && ! (props[propName] instanceof Array)) return new Error(msg + ' an array');\n      if (type === Object && (! (props[propName] instanceof Object) || props[propName] instanceof Array)) return new Error(msg + 'an Object');\n      if (!Immutable.isImmutable(props[propName])) {\n        return new Error(msg + ' immutable');\n      }\n      return null;\n    }\nImmutable.PropTypes = {\n  array: validate.bind(undefined, Array),\n  object: validate.bind(undefined, Object)\n};\n``````\n(If we want to support also .isRequred then we can follow http://www.ian-thomas.net/custom-proptype-validation-with-react/ . Or/and it is possible to combine with the all(...arrayOfValidators) validator from react-prop-types)\n. I understand the desire to keep the library small and appreciate it.\nI am not sure how common my use case is. In each case, accepting a function instead of values provides the ultimate power to the user. My particular use case was to filter out properties, that did not satisfy a condition: \nconst unknownProducts = _.chain(products).keys().reject(knownProduct).value();\nconst onlyKnownProducts = products.without(unknownProducts);\n// I would have preferred:\nconst onlyKnownProducts = products.without((product, productId) => ! knownProduct(productId));\nI do not think that it would either be complex or require many lines of code to add this functionality:\n```\nfunction without(keysToRemove) {\n    // Calling .without() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\nvar remove;\nif (keysToRemove instanceof function) {\n      remove = keysToRemove; \n    } else {\n      var keysToRemoveArray = (keysToRemove instanceof Array) ? \n         keysToRemove : Array.prototype.slice.call(arguments);\n      remove = function(val, key) { return keysToRemoveArray.indexOf(key) >= 0; }\n    }\nvar result = this.instantiateEmptyObject();\n\nfor (var key in this) {\n  if (this.hasOwnProperty(key) && ! remove(this[key], key)) {\n    result[key] = this[key];\n  }\n}\n\n```\nBut you are of course the arbiter of the usefulness vs. cost :-)\n. My pleasure\nOn Thu, 14 Jan 2016 at 17:39, Richard Feldman notifications@github.com\nwrote:\n\nOld tests pass for me too.\nLooks great, thanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/pull/93#issuecomment-171694853\n.\n. Yes. How to run the tests in FF?\nOn Fri, 15 Jan 2016 at 00:54, Richard Feldman notifications@github.com\nwrote:\n@jakubholynet https://github.com/jakubholynet Hm, appears that tests\nare breaking in Firefox. I fixed some linter errors in the hopes that's all\nit was, but it appears to be more than that.\nMind taking a look?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/pull/93#issuecomment-171820697\n.\n. Hi @rtfeldman, as mentioned I'd be happy to help with the failing tests but I need you to tell me how to run them :-)\n\nOr have you actually fixed them? The commits seem to indicate that ...\n. the pass for me:\n\n. @rtfeldman So this is duplicate of #124 but that was closed with \"won't fix\" with the explanation that Immutable should only store plain old data - i.e. that regular expressions, Errors etc. can not be included in an Immutable data structure. Correct?\nPerhaps, if that is the case, it should be clearly documented in the README and, even better, an exception should be thrown when trying to include any other then supported type of data (i.e. fail quickly and with a clear error message then later with a mysterious error). What do you think?\nAlso, according to the README, it is possible to include \"mutable\" elements of type Date, function, React component. That provides a simple workaround: instead of using prop: RegExp(..), I could use () => new RegExp(). But wouldn't it be even better to expand this and allow the user to define what \"mutable\" data can be part of an Immutable data structure? Something like I proposed in 4. above or something similar (a list of types/paths to leave as they are ...).\nThoughts?\n. It also causes Babel to fail:\n```\n$ babel-node\n\nvar Immutable = require(\"seamless-immutable\");\n(new Immutable.ImmutableError(\"xxxx\")).stack\nTypeError: Function.prototype.toString is not generic\n    at Function.toString (native)\n    at Function.toString (/Users/me/Work/project/node_modules/babel/node_modules/babel-core/node_modules/core-js/modules/$.redefine.js:26:62)\n    at Function.prepareStackTrace (/Users/me/Work/project/node_modules/babel/node_modules/babel-core/node_modules/source-map-support/source-map-support.js:303:16)\n    at repl:3:37\n    at Object.exports.runInThisContext (vm.js:54:17)\n    at _eval (/Users/me/Work/project/node_modules/babel/lib/_babel-node.js:86:26)\n```\n\nA standard error works without a problem: ```\n\n(new Error(\"xxx\")).stack\n'Error: xxx\\n    at repl:3:1\\n    at Object.exports.runInThisContext (vm.js:54:17)\\n    at _eval (/Users/me/Work/project/node_modules/babel/lib/_babel-node.js:86:26)\\n    at REPLServer.replEval (/Users/me/Work/project/node_modules/babel/lib/_babel-node.js:169:14)\\n    at bound (domain.js:280:14)\\n    at REPLServer.runBound as eval\\n    at REPLServer. (repl.js:393:12)\\n    at emitOne (events.js:77:13)\\n    at REPLServer.emit (events.js:169:7)\\n    at REPLServer.Interface._onLine (readline.js:210:10)'```\n\nTo troubleshoot the actual exception, you can temporarily do something like this (ES6):\njs\nError.prepareStackTrace = function(error, stack) {\n    return stack.map(frame => `${frame.getTypeName() || ''}.${frame.getFunctionName() || \"<anonymous fn>\"} at ${frame.getFileName()}:${frame.getLineNumber()}`).join(\"\\n\");\n};. Fixing for Node: Couldn't we just do\njs\nvar util = undefined;\ntry { util = require(\"util\"); } catch () {}\n...\nif (util) {\n  util.inherits(Immutable, Error);\n} else {\n  ImmutableError.prototype = Error.prototype; // + do something to fix it in the browser if necessary\n}. ",
    "dagda1": "Yes, you are right, ember does modify the prototype.  You can turn that off though.\nThanks\n. I've stopped ember extending the prototypes and I get a new error:\n\nUncaught ReferenceError: process is not defined\n\nWhich references this code:\nif (process.env.NODE_ENV === \"development\") {\n      // Make all mutating methods throw exceptions.\n      for (var index in bannedMethods) {\n        banProperty(obj, bannedMethods[index]);\n      }\nIs this library node only?\nHere is the updated jsbin\n. Sorry, yes, thanks\n. Yes, you are right, ember does modify the prototype.  You can turn that off though.\nThanks\n. I've stopped ember extending the prototypes and I get a new error:\n\nUncaught ReferenceError: process is not defined\n\nWhich references this code:\nif (process.env.NODE_ENV === \"development\") {\n      // Make all mutating methods throw exceptions.\n      for (var index in bannedMethods) {\n        banProperty(obj, bannedMethods[index]);\n      }\nIs this library node only?\nHere is the updated jsbin\n. Sorry, yes, thanks\n. ",
    "cr0cK": "Thank you @crudh, It looks nice :)\nWhat do you think about to make this behavior as the default one?\n. Thank you @crudh, It looks nice :)\nWhat do you think about to make this behavior as the default one?\n. ",
    "jedwards1211": "Why do some kind of deepEquals test when you could just use recursive merging to determine if anything has changed?  Here's a rough 17-line deep merge implementation (not thoroughly tested, and one would want to make it customizable):\njavascript\nfunction mergeDeep(a, b) {\n  if (a instanceof Object || a instanceof Array) {\n    if (!b) return a;\n    var remade;\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        var merged = mergeDeep(a[key], b[key]);\n        if (merged !== a[key]) {\n          if (!remade) remade = a.asMutable();\n          remade[key] = merged;\n        }\n      }\n    }\n    return remade ? Immutable(remade) : a;\n  }\n  return b;\n}\nHere was my testcase that works with this mergeDeep but not merge(..., {deep: true}):\n``` javascript\nvar a = Immutable({\n  plots: [\n    {\n      traces: [\n        {channel: 'a'},\n        {channel: 'b'}\n      ]\n    }\n  ]\n});\nvar b = mergeDeep(a, {\n  plots: [\n    {\n      traces: [\n        {channel: 'a'},\n        {channel: 'b', min: 0, max: 100}\n      ]\n    }\n  ]\n});\nconsole.log(a.plots[0].traces[0] === b.plots[0].traces[0]); // should be true\nconsole.log(a.plots[0].traces[1] === b.plots[0].traces[1]); // should be false\n```\nNote that since this function treats arrays like number-keyed maps, mergeDeep(Immutable([1,2,,,5]), [,3,4]) would produce [1,3,4,,5] with this implementation, which is exactly analogous to map merging (and I believe the way Immutable.js mergeDeep works).  Another common merge type would be for the output to be deep equal to b, but with all original values from a that were equal:\njavascript\nfunction updateDeep(a, b) {\n  if (a instanceof Object || a instanceof Array) {\n    if (!b) return a;\n    var remade;\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        var updated = updateDeep(a[key], b[key]);\n        if (updated !== a[key]) {\n          if (!remade) remade = a.asMutable();\n          remade[key] = updated;\n        }\n      }\n    }\n    for (var key in a) {\n      if (!b.hasOwnProperty(key)) {\n        if (!remade) remade = a.asMutable();\n        delete remade[key];\n      }\n    }\n    return remade ? Immutable(remade) : a;\n  }\n  return b;\n}\n. Let's back up a moment here: seamless-immutable has already changed the behavior of these standard JS methods.  It has to; they can't perform any mutations.  It tries valiantly to make immutables look and feel as much like mutables as it can, but it could never go all the way.  Therefore if users call any of those methods expecting usual JS behavior, they'll be surprised anyway.\nSo seamless-immutable might as well change the API however it wants.  If push, pop, etc. return a new immutable, it won't be more surprising to the user than throwing an error, and I think users will get used to it easily, since plenty of people have gotten used to it being the standard behavior of Immutable.js.\n. Thanks @rtfeldman!\n. In any case this was one of the primary reasons I went back to Immutable.js.  I was tempted to fork this project, but didn't have time.\n. @sudhakar With over 9000 stars on Immutable.js, which allows mutable objects to be stored inside immutable objects, it's clear plenty of people think the most useful behavior is not to automatically immutablize everything.\n\"Makes sense\" is vague; a more concrete design goal is to make a library convenient for common use cases.  I'd argue that mapping to mutable objects is a fairly common use case, as in my above example, and it's one that Immutable.js is a lot more convenient for.\n. I know you're not the owner :)\nWhat I'm talking about map and filter doing is a bit more subtle.  The way they work in Immutable.js is to return an immutable array containing the exact objects returned by your mapper function: if it returns mutable objects, you get an immutable array with mutable objects as elements.  Oftentimes when your source object is immutable all the way down, your mapper function will just return the result of some Immutable.js method calls on the elements, which return other immutables, meaning map will return a fully immutable array anyway.  But if your mapper function returns something completely different, like React elements as in my example, you'll get an immutable array containing (mutable) React elements.\n. In any case, you might have noticed that Feldman hasn't commented on these threads at all...I think he's not even interested.  I'd be happy if someone made a competing fork\n. @pbc using Ramda is kind of nifty.  What I really want to know is how well Immutable.js performs compared to copying JS objects.  Supposedly it can share most of the unchanged data between objects saving time and memory.\n. Yes...I'm trying to argue that it shouldn't be necessary to do that\n. Okay, well, I will stick with ImmuableJS then.\n. I wouldn't recommend using WeakMap or Map even with polyfills...the polyfills aren't perfect and can cause memory leaks in some situations, especially if the same object is used as a key in many different Maps/WeakMaps.\n. @scriptguru when you use objects as keys with the ES2015 Map polyfill, it just stores the values inside a hidden property tree on the key objects anyway.  That's the only way it's possible to simulate object keys in ES5. I think the sole reason old browsers aren't supported is that they don't have an Object.defineProperty method, so the Map data can't be created in a hidden/non-enumerable property.\nBut that's no matter for this method.  All you have to do is temporarily tack the output immutable onto each input object/array in a property with a name that no one's going to use, like _$_$_$immutable, and then remove those properties when done converting the tree into an immutable.  I'd be a lot more comfortable with this than with a recursion counter or JSON.stringify() -- the graph structure of the input should be converted to an immutable with the same graph structure, and using a Map or keys on the input objects is the only way to do that.\n. Why do some kind of deepEquals test when you could just use recursive merging to determine if anything has changed?  Here's a rough 17-line deep merge implementation (not thoroughly tested, and one would want to make it customizable):\njavascript\nfunction mergeDeep(a, b) {\n  if (a instanceof Object || a instanceof Array) {\n    if (!b) return a;\n    var remade;\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        var merged = mergeDeep(a[key], b[key]);\n        if (merged !== a[key]) {\n          if (!remade) remade = a.asMutable();\n          remade[key] = merged;\n        }\n      }\n    }\n    return remade ? Immutable(remade) : a;\n  }\n  return b;\n}\nHere was my testcase that works with this mergeDeep but not merge(..., {deep: true}):\n``` javascript\nvar a = Immutable({\n  plots: [\n    {\n      traces: [\n        {channel: 'a'},\n        {channel: 'b'}\n      ]\n    }\n  ]\n});\nvar b = mergeDeep(a, {\n  plots: [\n    {\n      traces: [\n        {channel: 'a'},\n        {channel: 'b', min: 0, max: 100}\n      ]\n    }\n  ]\n});\nconsole.log(a.plots[0].traces[0] === b.plots[0].traces[0]); // should be true\nconsole.log(a.plots[0].traces[1] === b.plots[0].traces[1]); // should be false\n```\nNote that since this function treats arrays like number-keyed maps, mergeDeep(Immutable([1,2,,,5]), [,3,4]) would produce [1,3,4,,5] with this implementation, which is exactly analogous to map merging (and I believe the way Immutable.js mergeDeep works).  Another common merge type would be for the output to be deep equal to b, but with all original values from a that were equal:\njavascript\nfunction updateDeep(a, b) {\n  if (a instanceof Object || a instanceof Array) {\n    if (!b) return a;\n    var remade;\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        var updated = updateDeep(a[key], b[key]);\n        if (updated !== a[key]) {\n          if (!remade) remade = a.asMutable();\n          remade[key] = updated;\n        }\n      }\n    }\n    for (var key in a) {\n      if (!b.hasOwnProperty(key)) {\n        if (!remade) remade = a.asMutable();\n        delete remade[key];\n      }\n    }\n    return remade ? Immutable(remade) : a;\n  }\n  return b;\n}\n. Let's back up a moment here: seamless-immutable has already changed the behavior of these standard JS methods.  It has to; they can't perform any mutations.  It tries valiantly to make immutables look and feel as much like mutables as it can, but it could never go all the way.  Therefore if users call any of those methods expecting usual JS behavior, they'll be surprised anyway.\nSo seamless-immutable might as well change the API however it wants.  If push, pop, etc. return a new immutable, it won't be more surprising to the user than throwing an error, and I think users will get used to it easily, since plenty of people have gotten used to it being the standard behavior of Immutable.js.\n. Thanks @rtfeldman!\n. In any case this was one of the primary reasons I went back to Immutable.js.  I was tempted to fork this project, but didn't have time.\n. @sudhakar With over 9000 stars on Immutable.js, which allows mutable objects to be stored inside immutable objects, it's clear plenty of people think the most useful behavior is not to automatically immutablize everything.\n\"Makes sense\" is vague; a more concrete design goal is to make a library convenient for common use cases.  I'd argue that mapping to mutable objects is a fairly common use case, as in my above example, and it's one that Immutable.js is a lot more convenient for.\n. I know you're not the owner :)\nWhat I'm talking about map and filter doing is a bit more subtle.  The way they work in Immutable.js is to return an immutable array containing the exact objects returned by your mapper function: if it returns mutable objects, you get an immutable array with mutable objects as elements.  Oftentimes when your source object is immutable all the way down, your mapper function will just return the result of some Immutable.js method calls on the elements, which return other immutables, meaning map will return a fully immutable array anyway.  But if your mapper function returns something completely different, like React elements as in my example, you'll get an immutable array containing (mutable) React elements.\n. In any case, you might have noticed that Feldman hasn't commented on these threads at all...I think he's not even interested.  I'd be happy if someone made a competing fork\n. @pbc using Ramda is kind of nifty.  What I really want to know is how well Immutable.js performs compared to copying JS objects.  Supposedly it can share most of the unchanged data between objects saving time and memory.\n. Yes...I'm trying to argue that it shouldn't be necessary to do that\n. Okay, well, I will stick with ImmuableJS then.\n. I wouldn't recommend using WeakMap or Map even with polyfills...the polyfills aren't perfect and can cause memory leaks in some situations, especially if the same object is used as a key in many different Maps/WeakMaps.\n. @scriptguru when you use objects as keys with the ES2015 Map polyfill, it just stores the values inside a hidden property tree on the key objects anyway.  That's the only way it's possible to simulate object keys in ES5. I think the sole reason old browsers aren't supported is that they don't have an Object.defineProperty method, so the Map data can't be created in a hidden/non-enumerable property.\nBut that's no matter for this method.  All you have to do is temporarily tack the output immutable onto each input object/array in a property with a name that no one's going to use, like _$_$_$immutable, and then remove those properties when done converting the tree into an immutable.  I'd be a lot more comfortable with this than with a recursion counter or JSON.stringify() -- the graph structure of the input should be converted to an immutable with the same graph structure, and using a Map or keys on the input objects is the only way to do that.\n. ",
    "ntkoopman": "I don't think this makes much sense for the map function.\nFor the other functions I can understand this rational, because they return parts of the array itself, which are guaranteed to be immutable, but map can return things not related to the immutable structure. To me, this is very unexpected behaviour.\nYou are also suggesting using a non-standard map implementation for a library that has 'backwards-compatible' in the first line of its summary.\n. I don't think this makes much sense for the map function.\nFor the other functions I can understand this rational, because they return parts of the array itself, which are guaranteed to be immutable, but map can return things not related to the immutable structure. To me, this is very unexpected behaviour.\nYou are also suggesting using a non-standard map implementation for a library that has 'backwards-compatible' in the first line of its summary.\n. ",
    "Jan-Jan": "@abritinthebay  +1\n. @abritinthebay  +1\n. ",
    "agurtovoy": "I'd like to reopen this discussion in the light that nowadays seamless-immutable treats functions, errors, dates, and React components as immutable even though they are not in order to make the library play nicely with the rest of the code out there.\nHere's a problem I ran into yesterday when using seamless-immutable together with Draft.js:\nconst editorState = Immutable( { content: Draft.convertToRaw( ContentState.createFromText( text ) ) } );\n...\nconst state =  Draft.convertFromRaw( editorState.content );\n//             ^^^^^^^^^^^^^^^^^^^^\n// TypeError: block.getKey is not a function\n//    at node_modules/draft-js/lib/BlockMapBuilder.js:24:21\n//    at Array.map (native)\n//    at Array.<anonymous> (node_modules/seamless-immutable/src/seamless-immutable.js:132:38)\n//    at Object.createFromArray (node_modules/draft-js/lib/BlockMapBuilder.js:22:30)\n//    at Function.createFromBlockArray (node_modules/draft-js/lib/ContentState.js:163:36)\n//    at convertFromRawToDraftState (node_modules/draft-js/lib/convertFromRawToDraftState.js:89:23)\nThe reason the above fails is that Draft.js' createFromBlockArray uses .map to convert an array of raw objects into an array of prototype-based objects, which seamless-immutable promptly strips down to raw immutable data, no methods, thus block.getKey is not a function.\nI worked around it by running editorState.content through Immutable.asMutable( ..., { deep: true } ), but this was thoroughly unexpected and IMHO incompatible with the library's promise of \"data structures which are backwards-compatible with normal Arrays and Objects.\"\nI think it makes a lot of sense to make plain-old-js-objects returned from .map immutable, but we've gotta pass everything else through as-is.\nThoughts?\n. I'd like to reopen this discussion in the light that nowadays seamless-immutable treats functions, errors, dates, and React components as immutable even though they are not in order to make the library play nicely with the rest of the code out there.\nHere's a problem I ran into yesterday when using seamless-immutable together with Draft.js:\nconst editorState = Immutable( { content: Draft.convertToRaw( ContentState.createFromText( text ) ) } );\n...\nconst state =  Draft.convertFromRaw( editorState.content );\n//             ^^^^^^^^^^^^^^^^^^^^\n// TypeError: block.getKey is not a function\n//    at node_modules/draft-js/lib/BlockMapBuilder.js:24:21\n//    at Array.map (native)\n//    at Array.<anonymous> (node_modules/seamless-immutable/src/seamless-immutable.js:132:38)\n//    at Object.createFromArray (node_modules/draft-js/lib/BlockMapBuilder.js:22:30)\n//    at Function.createFromBlockArray (node_modules/draft-js/lib/ContentState.js:163:36)\n//    at convertFromRawToDraftState (node_modules/draft-js/lib/convertFromRawToDraftState.js:89:23)\nThe reason the above fails is that Draft.js' createFromBlockArray uses .map to convert an array of raw objects into an array of prototype-based objects, which seamless-immutable promptly strips down to raw immutable data, no methods, thus block.getKey is not a function.\nI worked around it by running editorState.content through Immutable.asMutable( ..., { deep: true } ), but this was thoroughly unexpected and IMHO incompatible with the library's promise of \"data structures which are backwards-compatible with normal Arrays and Objects.\"\nI think it makes a lot of sense to make plain-old-js-objects returned from .map immutable, but we've gotta pass everything else through as-is.\nThoughts?\n. ",
    "bitinn": "Given the lack of object mutation method, am I right to say the common (and fastest) way to update (or diff) immutable object is to use merge/without? I have a feeling using asMutable then mutate object and then wrap them into an immutable again will be at least O(n).\nPS: assume I want to modify a nested immutable object { a: { b: 1 } }, what's the best way to set b = 2 in seamless-immutable case?\n. Given the lack of object mutation method, am I right to say the common (and fastest) way to update (or diff) immutable object is to use merge/without? I have a feeling using asMutable then mutate object and then wrap them into an immutable again will be at least O(n).\nPS: assume I want to modify a nested immutable object { a: { b: 1 } }, what's the best way to set b = 2 in seamless-immutable case?\n. ",
    "dgieselaar": "@rtfeldman: there's a pattern w/ gulp-cached and gulp-remember which looks a little like this:\njavascript\nstream\n  .pipe(cache())\n  .pipe(doStuffOnUncachedItemsOnly())\n  .pipe(remember())\n  .pipe(doStuffOnAllItems())\nPerhaps something similar would would solve this problem as well:\njavascript\ncollection\n  .map(mapFn)\n  .only(filterFn)\n    .map(mapFilteredFn)\n  .all()\nJust thinking out loud here. \n. @rtfeldman: there's a pattern w/ gulp-cached and gulp-remember which looks a little like this:\njavascript\nstream\n  .pipe(cache())\n  .pipe(doStuffOnUncachedItemsOnly())\n  .pipe(remember())\n  .pipe(doStuffOnAllItems())\nPerhaps something similar would would solve this problem as well:\njavascript\ncollection\n  .map(mapFn)\n  .only(filterFn)\n    .map(mapFilteredFn)\n  .all()\nJust thinking out loud here. \n. ",
    "bradwestfall": "I know it's an old thread, buy why does .concat not work after the fact\njs\nlet array = Immutable([1,2,3]).concat([4])\narray.concat([5])\nconsole.log(array) // [1,2,3,4]\n. oh, duh. Thanks\n. I know it's an old thread, buy why does .concat not work after the fact\njs\nlet array = Immutable([1,2,3]).concat([4])\narray.concat([5])\nconsole.log(array) // [1,2,3,4]\n. oh, duh. Thanks\n. ",
    "starInEcust": "How about splice?\n// pretty ugly\nlog.slice(0, foundIdx).concat(newval).concat(log.slice(foundIdx+1)). How about splice?\n// pretty ugly\nlog.slice(0, foundIdx).concat(newval).concat(log.slice(foundIdx+1)). ",
    "mkawalec": "@rtfeldman done, and thanks for letting me know, in case I find any other bugs :dancers: \n. @rtfeldman done, and thanks for letting me know, in case I find any other bugs :dancers: \n. ",
    "scriptguru": "Why would it work with date objects?\nI thought it was supposed to work only with data that can be serialized to JSON and deserialized from JSON natively.\nStill it's possible to store date as a timestamp to workaround this.\n. The thing is, it doesn't do anything fancy, and this bug appears with any component\n``` js\n    render() {\n    return (\n        <ul className=\"generalMenu\">\n            {\n                ( this.props.items || [] ).map( ( item ) => <li key={ item.cssClass } className={ item.cssClass }><Link to={ item.link }>{ item.title }</Link></li> )\n            }\n        </ul>\n    );\n}\n\n```\n. Hm, this is an interesting point. I see what's the problem now, thanks for explanation.\nTo me it looks like some checks have to be added to seamless-immutable to avoid this issue.\nI understand that seamless-immutable hasn't been created for React, but let's face it - it's becoming popular largely thanks to React, so it shouldn't cause extreme problems when being used with it.\nReact promotes ImmutableJS, which is obviously not as convenient as seamless-immutable, but at least it doesn't cause infinite recursion or something like that.\nAs a workaround, I think for now I can just use lodash map method, which IIRC doesn't use the native method, but definitely this issue should be addressed since in most examples regarding React usage native methods like map are being used.\nUPDATE: as expected, it works fine when using lodash map method.\nAs I understand, React uses circular references and that's how infinite recursion happens. Probably that's what should be detected, not the React itself (however, detecting React could be an easy first step for solving the problem if the good solution is not obvious).\n. Good idea, thanks\n. Yes, I know it's not an easy fix. One of the possible solutions would be to use WeakMap or Map, using all objects that are being converted to immutable as keys, but unfortunately it won't work in older browsers, so it's not really an option. That's why I suggested to include a quick fix that would resolve it just for usage with React, just because it's a major use case.\nOr at least a note could be added to the Readme.md on this particular issue, helping people to avoid this problem.\n. I think this problem can be solved with one of following approaches or their combination:\n1. Recursion counter. If we go let's say 50 levels deep, it's a bad sign. The counter is basically free for CPU, but cannot really detect circular references - just how deep we are.\n2. Using JSON.stringify() on an object with circular references will throw an error, and this can be used to detect them. However, it will also throw an error in some other cases too - when in encounters something that cannot be converted to JSON. And I guess it's way more expensive than counter.\nI think, counter with some reasonable limit, and with possibility to adjust the limit would work the best. Currently a property that is being used as an immutability marker has value true. However, it could store the maximum allowed recursion level, that user can optionally set when making an object immutable.\n. Why would it work with date objects?\nI thought it was supposed to work only with data that can be serialized to JSON and deserialized from JSON natively.\nStill it's possible to store date as a timestamp to workaround this.\n. The thing is, it doesn't do anything fancy, and this bug appears with any component\n``` js\n    render() {\n    return (\n        <ul className=\"generalMenu\">\n            {\n                ( this.props.items || [] ).map( ( item ) => <li key={ item.cssClass } className={ item.cssClass }><Link to={ item.link }>{ item.title }</Link></li> )\n            }\n        </ul>\n    );\n}\n\n```\n. Hm, this is an interesting point. I see what's the problem now, thanks for explanation.\nTo me it looks like some checks have to be added to seamless-immutable to avoid this issue.\nI understand that seamless-immutable hasn't been created for React, but let's face it - it's becoming popular largely thanks to React, so it shouldn't cause extreme problems when being used with it.\nReact promotes ImmutableJS, which is obviously not as convenient as seamless-immutable, but at least it doesn't cause infinite recursion or something like that.\nAs a workaround, I think for now I can just use lodash map method, which IIRC doesn't use the native method, but definitely this issue should be addressed since in most examples regarding React usage native methods like map are being used.\nUPDATE: as expected, it works fine when using lodash map method.\nAs I understand, React uses circular references and that's how infinite recursion happens. Probably that's what should be detected, not the React itself (however, detecting React could be an easy first step for solving the problem if the good solution is not obvious).\n. Good idea, thanks\n. Yes, I know it's not an easy fix. One of the possible solutions would be to use WeakMap or Map, using all objects that are being converted to immutable as keys, but unfortunately it won't work in older browsers, so it's not really an option. That's why I suggested to include a quick fix that would resolve it just for usage with React, just because it's a major use case.\nOr at least a note could be added to the Readme.md on this particular issue, helping people to avoid this problem.\n. I think this problem can be solved with one of following approaches or their combination:\n1. Recursion counter. If we go let's say 50 levels deep, it's a bad sign. The counter is basically free for CPU, but cannot really detect circular references - just how deep we are.\n2. Using JSON.stringify() on an object with circular references will throw an error, and this can be used to detect them. However, it will also throw an error in some other cases too - when in encounters something that cannot be converted to JSON. And I guess it's way more expensive than counter.\nI think, counter with some reasonable limit, and with possibility to adjust the limit would work the best. Currently a property that is being used as an immutability marker has value true. However, it could store the maximum allowed recursion level, that user can optionally set when making an object immutable.\n. ",
    "jjulicher": "I can't think of any issues that come to mind. sounds good.\n. I can't think of any issues that come to mind. sounds good.\n. ",
    "virajsanghvi": "I'm likely going to try this approach this weekend, but there's some weirdness in that multiple arguments to Immutable() are considered an Array and I'd rather not break existing consumers. Another option I'm thinking about is a special method that does this on Immutable like isMutable, but that's also not ideal.\nBecause my options for implementation of this feature are subpar, what do you think about supporting the original intent of #25, but logging a warning when encountering a prototype in development? I'm guessing there are probably a lot of folks that rely on this not happening at the moment? If so, changing that behavior would be breaking, so this probably isn't feasible either, but thought I'd ask.\n. My main issues with that approach are:\n1. If someone created a project specific version of seamless-immutable with this approach, they'd have to keep that list up to date\n2. If someone was encapsulating the creation of these objects, it gets tricky if another component creates other Immutable objects where these are nested children. (This is probably unavoidable)\nHow would you feel about something like:\njavascript\n// Similar to Immutable(), but during clone of objects, attaches a __immutable_preserve_prototype \n// tag to the cloned object. The application of this tag is used elsewhere in the library to ensure \n// the prototype is preserved on clones.\nImmutable.withPreservedPrototype(obj) // could be better named\nIf the entire library recognized this tag and acted appropriately, you could use Immutable normally, wrap objects in arrays, and get the expected result. This handles #1, and mostly #2 (having to have factories to create Immutable objects of a specific type is required in either case).\nAnyways, let me know what you think of that. I'm not completely sold on it, but feels easiest to consume and implement. Happy to hear out other options. Will try to implement one of these in the next day.\n. Sorry for the late response. I just tried out something similar to what I'm thinking: https://github.com/virajsanghvi/seamless-immutable/commit/5e2b065f757a8747ef6a61528782f72393d0741d\nJust wanted to be on the same page before cleaning this up/adding tests for PR. See the test for a general idea of how it would be used.\nBasically the idea is a custom constructor method used explicitly for the purpose of preserving the prototype. We can use the invariant that all existing Immutable objects have Object.prototype to determine when we've encountered an object created from this custom constructor, and preserve its prototype during cloning.\nThere are three main points of contention that I can see:\n- Is the performance implication of Object.getPrototypeOf ok in the common case? I imagine it just returns __proto__, but not sure.\n- What is the relation of ImmutableWithPrototype to Immutable? Should they share a common constructor, so you could pass Arrays, dates, etc to ImmutableWithPrototype, or should it just take in Objects and throw otherwise? (The current implementation of copying Immutable was just to try this out)\n- The name ImmutableWithPrototype kind of sucks- I'm open to suggestions.\nAnyways, let me know what you think. Also, if you have a benchmark suite I could use, I'd like to see the overall perf implications of Object.getPrototypeOf and Object.create. \n. I'm a fan. This was preferable, but I thought you were against changing the interface for Immutable per a previous comment (I may have described it unclearly). Anyways, I'll get this up in the next few days when I have a free hour.\n. Forgot to link here, but submitted #51 a couple days ago which handles what we talked about above.\n. Closing as the functionality to support this is now available in 3.0.0\n. Thanks for your help with adding this!\n. I'm likely going to try this approach this weekend, but there's some weirdness in that multiple arguments to Immutable() are considered an Array and I'd rather not break existing consumers. Another option I'm thinking about is a special method that does this on Immutable like isMutable, but that's also not ideal.\nBecause my options for implementation of this feature are subpar, what do you think about supporting the original intent of #25, but logging a warning when encountering a prototype in development? I'm guessing there are probably a lot of folks that rely on this not happening at the moment? If so, changing that behavior would be breaking, so this probably isn't feasible either, but thought I'd ask.\n. My main issues with that approach are:\n1. If someone created a project specific version of seamless-immutable with this approach, they'd have to keep that list up to date\n2. If someone was encapsulating the creation of these objects, it gets tricky if another component creates other Immutable objects where these are nested children. (This is probably unavoidable)\nHow would you feel about something like:\njavascript\n// Similar to Immutable(), but during clone of objects, attaches a __immutable_preserve_prototype \n// tag to the cloned object. The application of this tag is used elsewhere in the library to ensure \n// the prototype is preserved on clones.\nImmutable.withPreservedPrototype(obj) // could be better named\nIf the entire library recognized this tag and acted appropriately, you could use Immutable normally, wrap objects in arrays, and get the expected result. This handles #1, and mostly #2 (having to have factories to create Immutable objects of a specific type is required in either case).\nAnyways, let me know what you think of that. I'm not completely sold on it, but feels easiest to consume and implement. Happy to hear out other options. Will try to implement one of these in the next day.\n. Sorry for the late response. I just tried out something similar to what I'm thinking: https://github.com/virajsanghvi/seamless-immutable/commit/5e2b065f757a8747ef6a61528782f72393d0741d\nJust wanted to be on the same page before cleaning this up/adding tests for PR. See the test for a general idea of how it would be used.\nBasically the idea is a custom constructor method used explicitly for the purpose of preserving the prototype. We can use the invariant that all existing Immutable objects have Object.prototype to determine when we've encountered an object created from this custom constructor, and preserve its prototype during cloning.\nThere are three main points of contention that I can see:\n- Is the performance implication of Object.getPrototypeOf ok in the common case? I imagine it just returns __proto__, but not sure.\n- What is the relation of ImmutableWithPrototype to Immutable? Should they share a common constructor, so you could pass Arrays, dates, etc to ImmutableWithPrototype, or should it just take in Objects and throw otherwise? (The current implementation of copying Immutable was just to try this out)\n- The name ImmutableWithPrototype kind of sucks- I'm open to suggestions.\nAnyways, let me know what you think. Also, if you have a benchmark suite I could use, I'd like to see the overall perf implications of Object.getPrototypeOf and Object.create. \n. I'm a fan. This was preferable, but I thought you were against changing the interface for Immutable per a previous comment (I may have described it unclearly). Anyways, I'll get this up in the next few days when I have a free hour.\n. Forgot to link here, but submitted #51 a couple days ago which handles what we talked about above.\n. Closing as the functionality to support this is now available in 3.0.0\n. Thanks for your help with adding this!\n. ",
    "Mosho1": "Is this a priority? I would love to have this, could make a PR.\n. Is this a priority? I would love to have this, could make a PR.\n. ",
    "oliverwoodings": "I believe what @jakubholynet means is how do you switch between using the dev build and and production build. The package.json file for seamless-immutable points to the development build, which in my opinion is not ideal. Really it should point to the actual source. If users want to perform optimisations  based on environment (i.e. using envify or webpack's define plugin), they should be able to do it themselves in their build step. This is how React does it and it works well; it gives the developer the power to choose. \nTo answer @jakubholynet 's question, if you are using webpack you can alias seamless-immutable to get  different builds. Personally I have my webpack config set up like so:\njs\nmodule.exports = {\n  plugins: [\n    new webpack.DefinePlugin({\n      \"process.env.NODE_ENV\": '\"' + (process.env.NODE_ENV || \"development\") + '\"'\n    })\n  ],\n  resolve: {\n    alias: {\n      \"seamless-immutable$\": path.resolve(__dirname, \"node_modules/seamless-immutable/src/seamless-immutable.js\")\n    }\n  }\n};\n. Yeah so what they do in React is something like this:\n``` js\nvar DEV = process && process.env && process.env.NODE_ENV === \"development\";\nvar PROD = process && process.env && process.env.NODE_ENV === \"production\";\nif (DEV) {\n  //do dev-only stuff\n}\n```\nThe envify-uglify combo will cause all those conditional statements to be removed in production, so no lingering checks.\nI'll see if i can get a PR in some time!\n. I believe what @jakubholynet means is how do you switch between using the dev build and and production build. The package.json file for seamless-immutable points to the development build, which in my opinion is not ideal. Really it should point to the actual source. If users want to perform optimisations  based on environment (i.e. using envify or webpack's define plugin), they should be able to do it themselves in their build step. This is how React does it and it works well; it gives the developer the power to choose. \nTo answer @jakubholynet 's question, if you are using webpack you can alias seamless-immutable to get  different builds. Personally I have my webpack config set up like so:\njs\nmodule.exports = {\n  plugins: [\n    new webpack.DefinePlugin({\n      \"process.env.NODE_ENV\": '\"' + (process.env.NODE_ENV || \"development\") + '\"'\n    })\n  ],\n  resolve: {\n    alias: {\n      \"seamless-immutable$\": path.resolve(__dirname, \"node_modules/seamless-immutable/src/seamless-immutable.js\")\n    }\n  }\n};\n. Yeah so what they do in React is something like this:\n``` js\nvar DEV = process && process.env && process.env.NODE_ENV === \"development\";\nvar PROD = process && process.env && process.env.NODE_ENV === \"production\";\nif (DEV) {\n  //do dev-only stuff\n}\n```\nThe envify-uglify combo will cause all those conditional statements to be removed in production, so no lingering checks.\nI'll see if i can get a PR in some time!\n. ",
    "mheiber": "Thanks for the Webpack example. How can I specify which build to use using Browserify?\n. Thanks for the Webpack example. How can I specify which build to use using Browserify?\n. ",
    "tleunen": "If your webpack configuration uses the default mainFields, or use defaults values, with browser first before main, the development build from seamless-immutable will be used, even though you set NODE_ENV to prod.\nSee https://webpack.js.org/configuration/resolve/#resolve-mainfields\nThe default target of webpack is web, so therefore, every use will use the development version by default.. In my use case, I'm using both Immutable.js and seamless-immutable, because I'm using Draft.js, which use Immutable.js but in the rest of my application uses seamless-immutable.\nI was able to prevent seamless-immutable to change the immutable.js structure by adding a __immutable_invariants_hold property and a asMutable function on my object but this is a very hacky solution.\nIn a more general case though, what is the best way to add \"complex\" objects (in opposite of plain objects) in a seamless-immutable structure? I agree an immutable structure should be plain objects only but sometimes I have to put a complex object in there :/\n. If your webpack configuration uses the default mainFields, or use defaults values, with browser first before main, the development build from seamless-immutable will be used, even though you set NODE_ENV to prod.\nSee https://webpack.js.org/configuration/resolve/#resolve-mainfields\nThe default target of webpack is web, so therefore, every use will use the development version by default.. In my use case, I'm using both Immutable.js and seamless-immutable, because I'm using Draft.js, which use Immutable.js but in the rest of my application uses seamless-immutable.\nI was able to prevent seamless-immutable to change the immutable.js structure by adding a __immutable_invariants_hold property and a asMutable function on my object but this is a very hacky solution.\nIn a more general case though, what is the best way to add \"complex\" objects (in opposite of plain objects) in a seamless-immutable structure? I agree an immutable structure should be plain objects only but sometimes I have to put a complex object in there :/\n. ",
    "robjens": "AFAIK (just got to learn this library), the only supported types are Object and Array.\nImmutable List isn't to be found. Also the amount of available methods is seriously trimmed down. \nHowever, that having said, there is a way to accomplish what you desire, I've used ES5 function notation here...\njavascript\nImmutable([1 2 3]).flatMap(function(x) { return x == 1 ? x + 1 : x; });\nShould do the trick.\n. AFAIK (just got to learn this library), the only supported types are Object and Array.\nImmutable List isn't to be found. Also the amount of available methods is seriously trimmed down. \nHowever, that having said, there is a way to accomplish what you desire, I've used ES5 function notation here...\njavascript\nImmutable([1 2 3]).flatMap(function(x) { return x == 1 ? x + 1 : x; });\nShould do the trick.\n. ",
    "ianp": "FWIW a simpler example based on the one from your docs seems to do the right thing for me:\njs\nImmutable({all: \"your base\", are: {belong: \"to them\"}}).merge({are: {belong: \"to us\"}}).merge({all: \"the world\"})\nproduces:\njs\n{all: \"the world\", are: { belong: \"to us\"} }\n. Right you are, told you it was probably me doing something daft! Thanks!\n. FWIW a simpler example based on the one from your docs seems to do the right thing for me:\njs\nImmutable({all: \"your base\", are: {belong: \"to them\"}}).merge({are: {belong: \"to us\"}}).merge({all: \"the world\"})\nproduces:\njs\n{all: \"the world\", are: { belong: \"to us\"} }\n. Right you are, told you it was probably me doing something daft! Thanks!\n. ",
    "dallonf": "That sounds like it would cause some very odd behavior and differences from mutable counterparts:\n```\nvar mutableArray = [\"a\", \"b\", \"c\"];\nconsole.log(mutableArray.push(\"d\")); // Prints 4, the new length of the array\nvar immutableArray = Immutable([\"a\", \"b\", \"c\"]);\nconsole.log(mutableArray.push(\"d\")); // Prints [\"a\", \"b\", \"c\", \"d\"], the copy of the array\n```\nIt's pretty rare that you would actually use the return value of push(), for example, but if you did, this would be a major headache and it'd be hard to find out what was going on.\nAlthough maybe if you rename the proxy method (pushImmutable or pushCopy or something), this could be very useful!\n. That sounds like it would cause some very odd behavior and differences from mutable counterparts:\n```\nvar mutableArray = [\"a\", \"b\", \"c\"];\nconsole.log(mutableArray.push(\"d\")); // Prints 4, the new length of the array\nvar immutableArray = Immutable([\"a\", \"b\", \"c\"]);\nconsole.log(mutableArray.push(\"d\")); // Prints [\"a\", \"b\", \"c\", \"d\"], the copy of the array\n```\nIt's pretty rare that you would actually use the return value of push(), for example, but if you did, this would be a major headache and it'd be hard to find out what was going on.\nAlthough maybe if you rename the proxy method (pushImmutable or pushCopy or something), this could be very useful!\n. ",
    "danprince": "Yeah, that's a really good point. It would of course be possible to rename the proxied method, but fundamentally it'd be confusing in the end. I often forget that some of those mutable methods return slightly odd things.\n| Method | Returns |\n| --- | --- |\n| push | Length of new array |\n| pop | Removed last item |\n| sort | Sorted array |\n| splice | Array containing deleted items |\n| shift | Removed first item |\n| unshift | Length of new array |\n| reverse | Reversed array |\nOnly sort and reverse would keep consistent behavior between both versions. It would be possible to tag these as proxyableMethods and only apply this proxy to them?\nOr rename to Ipush/pushImmutable/whatever then make that explicit within the immutable error for the banned methods. Then update the docs to make it explicit that these copying methods return the state of the object/array after applying the mutable change to a copy, so that there's no confusion as to what they return.\nI agree, it would be very useful to have these methods, but not at the cost of adding unnecessary complexity, which might be the long and short of hiding them behind suffixed names? I'd be interested to hear what other people think about that suggestion?\n. What about prefixing them with after? That way the semantics of the operation can't be confused and it can be made clear that these methods return the state of the array after the operation, rather than whatever they usually return. This way they will still work whilst method chaining.\n``` js\nImmutable([1, 2, 3]).afterPush(4); // [1, 2, 3, 4]\nImmutable([3, 2, 1]).afterSort(); // [1, 2, 3]\nImmutable(['a', 'b', 'c']).afterReverse(); // ['c', 'b', 'a']\nvar ns = Immutable([1, 2, 3, 4, 5])\n  .slice(2)\n  .map(n => 2 * 2)\n  .afterPush(3)\n  .afterSort();\n// [3, 6, 8, 10]\n``\n. It sounds like you might be thinking of Clojure's atoms. Atoms normally wrap an immutable then watch for it being replaced from by anupdate(orreset`) method.\nIf you pair together js-atom with seamless-immutable, you can simulate this behaviour.\n``` js\nimport Atom from 'js-atom';\nimport Immutable from 'seamless-immutable';\nconst arr = Immutable([1, 2, 3]);\nconst atom = Atom(arr);\natom.addWatch('someKey', (, , old, new) => {\n  console.log('update', old, new);\n});\natom.update(arr => arr.concat([4]));\n// 'update' [1, 2, 3] [1, 2, 3, 4]\n```\n. Yeah, that's a really good point. It would of course be possible to rename the proxied method, but fundamentally it'd be confusing in the end. I often forget that some of those mutable methods return slightly odd things.\n| Method | Returns |\n| --- | --- |\n| push | Length of new array |\n| pop | Removed last item |\n| sort | Sorted array |\n| splice | Array containing deleted items |\n| shift | Removed first item |\n| unshift | Length of new array |\n| reverse | Reversed array |\nOnly sort and reverse would keep consistent behavior between both versions. It would be possible to tag these as proxyableMethods and only apply this proxy to them?\nOr rename to Ipush/pushImmutable/whatever then make that explicit within the immutable error for the banned methods. Then update the docs to make it explicit that these copying methods return the state of the object/array after applying the mutable change to a copy, so that there's no confusion as to what they return.\nI agree, it would be very useful to have these methods, but not at the cost of adding unnecessary complexity, which might be the long and short of hiding them behind suffixed names? I'd be interested to hear what other people think about that suggestion?\n. What about prefixing them with after? That way the semantics of the operation can't be confused and it can be made clear that these methods return the state of the array after the operation, rather than whatever they usually return. This way they will still work whilst method chaining.\n``` js\nImmutable([1, 2, 3]).afterPush(4); // [1, 2, 3, 4]\nImmutable([3, 2, 1]).afterSort(); // [1, 2, 3]\nImmutable(['a', 'b', 'c']).afterReverse(); // ['c', 'b', 'a']\nvar ns = Immutable([1, 2, 3, 4, 5])\n  .slice(2)\n  .map(n => 2 * 2)\n  .afterPush(3)\n  .afterSort();\n// [3, 6, 8, 10]\n``\n. It sounds like you might be thinking of Clojure's atoms. Atoms normally wrap an immutable then watch for it being replaced from by anupdate(orreset`) method.\nIf you pair together js-atom with seamless-immutable, you can simulate this behaviour.\n``` js\nimport Atom from 'js-atom';\nimport Immutable from 'seamless-immutable';\nconst arr = Immutable([1, 2, 3]);\nconst atom = Atom(arr);\natom.addWatch('someKey', (, , old, new) => {\n  console.log('update', old, new);\n});\natom.update(arr => arr.concat([4]));\n// 'update' [1, 2, 3] [1, 2, 3, 4]\n```\n. ",
    "jokeyrhyme": "I've just started using this library, having played with Facebook's immutable.js previously.\nI have an Immutable Array, and I want to get a new Immutable Array that includes the contents of the previous one, with the addition of a new item at the end. The first thing I tried is #push() which throws an error and now I am here.\nTo achieve this, should I do something like this?\njs\nvar array = Immutable([1, 2, 3]);\narray = Immutable(array.asMutable().concat([4]));\n. I've just started using this library, having played with Facebook's immutable.js previously.\nI have an Immutable Array, and I want to get a new Immutable Array that includes the contents of the previous one, with the addition of a new item at the end. The first thing I tried is #push() which throws an error and now I am here.\nTo achieve this, should I do something like this?\njs\nvar array = Immutable([1, 2, 3]);\narray = Immutable(array.asMutable().concat([4]));\n. ",
    "sudhakar": ":+1: Started with seamless-immutable & after failing to easily splice, tried porting it to immutable-js. Now my app has become even more complex with all that get, setIn etc, I am now back here.\nHow about ruby sort of suffix for immutable methods like splice$ or splice_ ?\n. Unfortunate that it breaks React's common usage pattern. But for a immutable lib, it makes sense to immute all methods which creates new objects.\nHowever, it would be awesome if there's an api to avoid creating immutables when it is not required..\n. @jedwards1211 I dont have a strong opinion on this. I am all up for having mutable methods being part of the API. Changing the map or filter methods to return mutable objects is a big call. @rtfeldman might be the right person to decide on that.\nBTW, there's already a thread open to have mutuable api. See more discussion on #56 & chime in with your proposal so that others in community can throw in their thoughts.\nNote that I am not a maintainer/owner of this repo. I am just a user like who wants to use it with React ;)\n. What does your Menu component look like? Might be related to https://github.com/rtfeldman/seamless-immutable/issues/59\n. Ah.. this.props.items is immutable menu. When you call map, the return value(which is array of react elements) is also casted into immutable see https://github.com/rtfeldman/seamless-immutable/blob/master/src/seamless-immutable.js#L97 same as reported in #59 \nI havent personally tested it though but it looks like Immutable()-izing React elements causes overflows\n. IMHO infinite recursion is certainly a bug. Atleast better error should be thrown when circular references are found. Probably you may want to update issue title to get better visibility\n. Oops..Just title change is good enough..It helps to identify in issues list. On first glance, your issue wasn't  entirely clear.\nBTW, its not a major problem per se. Just that it fails to handle a special case with react. I would simply rephrase it as \"Using Map method with react causes infinite loop\". (oh pls do remove all bold text in description. Its too noisy)\nAlso it is not a simple fix. Where references needs to be deeply compared or whatever. Other solution would be to publish methods which will return Mutable data. Again these are major changes that needs to be carefully considered & it might even be against the target goals of the library.\nSorry my last comment was little vague. So lets be nice here ;)\n. :+1: Started with seamless-immutable & after failing to easily splice, tried porting it to immutable-js. Now my app has become even more complex with all that get, setIn etc, I am now back here.\nHow about ruby sort of suffix for immutable methods like splice$ or splice_ ?\n. Unfortunate that it breaks React's common usage pattern. But for a immutable lib, it makes sense to immute all methods which creates new objects.\nHowever, it would be awesome if there's an api to avoid creating immutables when it is not required..\n. @jedwards1211 I dont have a strong opinion on this. I am all up for having mutable methods being part of the API. Changing the map or filter methods to return mutable objects is a big call. @rtfeldman might be the right person to decide on that.\nBTW, there's already a thread open to have mutuable api. See more discussion on #56 & chime in with your proposal so that others in community can throw in their thoughts.\nNote that I am not a maintainer/owner of this repo. I am just a user like who wants to use it with React ;)\n. What does your Menu component look like? Might be related to https://github.com/rtfeldman/seamless-immutable/issues/59\n. Ah.. this.props.items is immutable menu. When you call map, the return value(which is array of react elements) is also casted into immutable see https://github.com/rtfeldman/seamless-immutable/blob/master/src/seamless-immutable.js#L97 same as reported in #59 \nI havent personally tested it though but it looks like Immutable()-izing React elements causes overflows\n. IMHO infinite recursion is certainly a bug. Atleast better error should be thrown when circular references are found. Probably you may want to update issue title to get better visibility\n. Oops..Just title change is good enough..It helps to identify in issues list. On first glance, your issue wasn't  entirely clear.\nBTW, its not a major problem per se. Just that it fails to handle a special case with react. I would simply rephrase it as \"Using Map method with react causes infinite loop\". (oh pls do remove all bold text in description. Its too noisy)\nAlso it is not a simple fix. Where references needs to be deeply compared or whatever. Other solution would be to publish methods which will return Mutable data. Again these are major changes that needs to be carefully considered & it might even be against the target goals of the library.\nSorry my last comment was little vague. So lets be nice here ;)\n. ",
    "wesleytodd": "FWIW, I agree with @jedwards1211.  The point of this library IS the changes, so I think this kind of change is a good thing.\nAlso, from a new users perspective, this is a big deal.  Having to call .asMutable ~~or wrap in a try/catch before passing it to any component that is un-trusted~~ all the time is not great.  ~~And a throw in production if something calls one of these methods is really bad.~~\nEDIT: an hour more in and I realized that I am doing alot of a = Immutable(a.asMutable().push(val)) type stuff.  Which, IMHO, is that this library should be doing for me.  Really what I want is a = a.push(val), as per this issue, otherwise what is the point of wrapping my arrays in this lib?\nEDIT 2: Realized after some sleep that the throw wouldn't happen in production.\n. FWIW, I agree with @jedwards1211.  The point of this library IS the changes, so I think this kind of change is a good thing.\nAlso, from a new users perspective, this is a big deal.  Having to call .asMutable ~~or wrap in a try/catch before passing it to any component that is un-trusted~~ all the time is not great.  ~~And a throw in production if something calls one of these methods is really bad.~~\nEDIT: an hour more in and I realized that I am doing alot of a = Immutable(a.asMutable().push(val)) type stuff.  Which, IMHO, is that this library should be doing for me.  Really what I want is a = a.push(val), as per this issue, otherwise what is the point of wrapping my arrays in this lib?\nEDIT 2: Realized after some sleep that the throw wouldn't happen in production.\n. ",
    "planttheidea": "I also want to chime in, because taking the \"people have gotten used to immutable.js\" comment one step further, I believe returning the new object is (if you look at it without your JavaScript-trained glasses on) the expected behavior.\nconst foo = [];\nconst bar = foo.push('foo');\nNo developer that didn't know of the mutable quirks of JavaScript would look at that and say that bar is obviously equal to 0. The same is true for splice, reverse, sort, etc. Also, in the larger context of this being an immutable library, the fact that with the current behavior you can (and do) perform a mutation in production seems counter to its inherent goal.\nThere are easy-to-implement immutable versions of all the functions you call out, made especially easy with ES2015. It seems to be a big miss that a library dedicated to immutability is only propagating it in the most literal sense of the word, and not in the larger context of developing with the methodology.\n. I also want to chime in, because taking the \"people have gotten used to immutable.js\" comment one step further, I believe returning the new object is (if you look at it without your JavaScript-trained glasses on) the expected behavior.\nconst foo = [];\nconst bar = foo.push('foo');\nNo developer that didn't know of the mutable quirks of JavaScript would look at that and say that bar is obviously equal to 0. The same is true for splice, reverse, sort, etc. Also, in the larger context of this being an immutable library, the fact that with the current behavior you can (and do) perform a mutation in production seems counter to its inherent goal.\nThere are easy-to-implement immutable versions of all the functions you call out, made especially easy with ES2015. It seems to be a big miss that a library dedicated to immutability is only propagating it in the most literal sense of the word, and not in the larger context of developing with the methodology.\n. ",
    "alesch": "Using new it works, but it is ugly:\n``` javascript\nimport I from 'seamless-immutable'\nlet l = new I([1,2,3]);\nconsole.log(l);   // [ 1, 2, 3 ]\n```\nWhen using Ramda I do: import * as R from 'ramda' and it exposes all its functions under R.\nI guess the difference is that seamless is not exposing a namespace, but a function.\n. You are right, it works for me too with node. It was my IDE's linter complaining ?!?\nIn the beginning I tried using nesh, and there import I from ... does not work. But a regular require does.\nSorry about that and thanks for your help!\n. Super!\n. Using new it works, but it is ugly:\n``` javascript\nimport I from 'seamless-immutable'\nlet l = new I([1,2,3]);\nconsole.log(l);   // [ 1, 2, 3 ]\n```\nWhen using Ramda I do: import * as R from 'ramda' and it exposes all its functions under R.\nI guess the difference is that seamless is not exposing a namespace, but a function.\n. You are right, it works for me too with node. It was my IDE's linter complaining ?!?\nIn the beginning I tried using nesh, and there import I from ... does not work. But a regular require does.\nSorry about that and thanks for your help!\n. Super!\n. ",
    "jbmeslin": "Hi, \nhow replace a require('seamless-immutable').static with and ES6 import  ?. today,  i do something like this:\n//reducer.js\n```\n       return state.merge({\n            nestedObject: utils.updateNested(state.nestedObject, state.index, action.val),\n            otherVal: {}\n    });\n\n```\n//utils.js\n```\n    static updateNested(nestedObject, index, val) {\n        return nestedObject.updateIn(['list', index], (item) => {\n    return item.merge({\n        attr1: val.,\n        att2: undefined  // or other props in val     \n    });\n\n});\n\n}\n```\n. The withMutations function is used when we need to update a tree with a loop ? All changes are done first in a mutable object and at the end apply on the initial object ? I think if we can have a deepMerge function which one do something like withMutations it will be great. \nI say that because in a large team, in a large application, some dev are not (javascript) expert and making the choice to use a withMutations or not can be tricky. \n. Hi, \nhow replace a require('seamless-immutable').static with and ES6 import  ?. today,  i do something like this:\n//reducer.js\n```\n       return state.merge({\n            nestedObject: utils.updateNested(state.nestedObject, state.index, action.val),\n            otherVal: {}\n    });\n\n```\n//utils.js\n```\n    static updateNested(nestedObject, index, val) {\n        return nestedObject.updateIn(['list', index], (item) => {\n    return item.merge({\n        attr1: val.,\n        att2: undefined  // or other props in val     \n    });\n\n});\n\n}\n```\n. The withMutations function is used when we need to update a tree with a loop ? All changes are done first in a mutable object and at the end apply on the initial object ? I think if we can have a deepMerge function which one do something like withMutations it will be great. \nI say that because in a large team, in a large application, some dev are not (javascript) expert and making the choice to use a withMutations or not can be tricky. \n. ",
    "unindented": "@rtfeldman are there any objections that prevent this from being merged into master?\n. @rtfeldman are there any objections that prevent this from being merged into master?\n. ",
    "pbc": "I have just run into this problem when trying to create a list of file uploads which needs to store the original File objects because without them you won't be able to send the files.\n. I found another solution. Regular objects + RamdaJS\n- http://ramdajs.com/0.17/index.html\n- http://ramdajs.com/0.17/docs/\nMy favourite method is \"evolve\" because it solves so many problems and it's all immutable\n. I have just run into this problem when trying to create a list of file uploads which needs to store the original File objects because without them you won't be able to send the files.\n. I found another solution. Regular objects + RamdaJS\n- http://ramdajs.com/0.17/index.html\n- http://ramdajs.com/0.17/docs/\nMy favourite method is \"evolve\" because it solves so many problems and it's all immutable\n. ",
    "davidspiess": "I stumbled upon the same issue. One way to get around it, would be using lodash instead of the native map function...\njs\n_.map(items, (item, i) => <div key={i}>{item}</div>);\n...or convert it to a mutable array before performing the map\njs\nitems.asMutable().map((item, i) => <div key={i}>{item}</div>);\n. I stumbled upon the same issue. One way to get around it, would be using lodash instead of the native map function...\njs\n_.map(items, (item, i) => <div key={i}>{item}</div>);\n...or convert it to a mutable array before performing the map\njs\nitems.asMutable().map((item, i) => <div key={i}>{item}</div>);\n. ",
    "lewisje": "The worse problem with IE8 is that Object.defineProperty only works on DOM nodes, and even a polyfill won't give IE8 the ability to make ordinary object members non-writable and non-deletable; to be more specific, you can make a sham version of Object.defineProperty that goes through the motions, so that you can load seamless-immutable without having it throw errors, but the objects it returns won't actually be immutable because there is no support in the engine for that.\nes5-sham does exactly this, by the way, and something similar with Object.freeze and Object.isSealed and the like; it does have an admirable version of Object.isExtensible that tries its hardest to extend an object, just to see whether it can be done.\n. I didn't notice that closed issue, and I don't actually use the library; I just read the source and remembered how some tutorials on memoization implement it with properties on the functions themselves.\n. The worse problem with IE8 is that Object.defineProperty only works on DOM nodes, and even a polyfill won't give IE8 the ability to make ordinary object members non-writable and non-deletable; to be more specific, you can make a sham version of Object.defineProperty that goes through the motions, so that you can load seamless-immutable without having it throw errors, but the objects it returns won't actually be immutable because there is no support in the engine for that.\nes5-sham does exactly this, by the way, and something similar with Object.freeze and Object.isSealed and the like; it does have an admirable version of Object.isExtensible that tries its hardest to extend an object, just to see whether it can be done.\n. I didn't notice that closed issue, and I don't actually use the library; I just read the source and remembered how some tutorials on memoization implement it with properties on the functions themselves.\n. ",
    "damonmcminn": "I have tried similar in Node 4.1.1, Node 0.12.7 and babel-node running on 4.1.1. I have also explicitly used an IIFE to ensure strict mode.\njavascript\nvar list = Immutable([1,2,3])\nlist.pop()\nconsole.log(list) // => [1,2]\n. Many thanks!\n. I have tried similar in Node 4.1.1, Node 0.12.7 and babel-node running on 4.1.1. I have also explicitly used an IIFE to ensure strict mode.\njavascript\nvar list = Immutable([1,2,3])\nlist.pop()\nconsole.log(list) // => [1,2]\n. Many thanks!\n. ",
    "davidchase": "I've run into the same issue myself... and this issue https://github.com/rtfeldman/seamless-immutable/issues/50 seems related\n. I've run into the same issue myself... and this issue https://github.com/rtfeldman/seamless-immutable/issues/50 seems related\n. ",
    "neverfox": "Is there anything holding this back?\n. Is there anything holding this back?\n. ",
    "SamHowie": "No worries :)\nYour solution is a lot simpler. I like it!\nI assume both Browserify and Webpack add a global process object to the window? If not your approach may lead to a Type Error as process/process.env will be undefined.\n. No worries :)\nYour solution is a lot simpler. I like it!\nI assume both Browserify and Webpack add a global process object to the window? If not your approach may lead to a Type Error as process/process.env will be undefined.\n. ",
    "ellis": "I was just looking for this too, also for arrays.\n. I was just looking for this too, also for arrays.\n. ",
    "henit": "I have not looked that close at the code yet, so just asking here.\nIs there any base object that the immutable objects inherit from? Or is the original objects sent in to the Immutable() function changed directly? If there is some base object available, it could just be used for instanceof check in PropTypes and any other case where it might be required to check if an object is immutable..\nSomething like\npropTypes: {\n    myobject: React.PropTypes.instanceOf(Immutable())\n}\ngiven that the function without arguments (or something similar) return a base object\n. Totally understandable. Unfortunately I don't have the time to contribute with the PR myself at the moment, but maybe in the future.\n. I have not looked that close at the code yet, so just asking here.\nIs there any base object that the immutable objects inherit from? Or is the original objects sent in to the Immutable() function changed directly? If there is some base object available, it could just be used for instanceof check in PropTypes and any other case where it might be required to check if an object is immutable..\nSomething like\npropTypes: {\n    myobject: React.PropTypes.instanceOf(Immutable())\n}\ngiven that the function without arguments (or something similar) return a base object\n. Totally understandable. Unfortunately I don't have the time to contribute with the PR myself at the moment, but maybe in the future.\n. ",
    "CosticaPuntaru": "it can have an alias ...\n. it can have an alias ...\n. ",
    "haggholm": "Refers to #64 (apparently the commit comment didn\u2019t do the trick, sorry).\nI\u2019m not sure whether adding methods like this is really the right thing to do, but I followed to the model of merge. Perhaps it would be better to follow a lodash-like model of exported functions to avoid conflicts with named properties.\n. Sorry I took even longer getting back! Added to README, changed a few random values to use JSC, not sure if that\u2019s precisely what you meant: haven\u2019t used JSC before (though if it\u2019s inspired by QuickCheck, I expect to do so again).\n. It can be done with arrays; I added it to arrays. I also found some weird edge cases where the object versions didn't work properly (with nested paths); I didn't nail it down, as my main concern was making the tests pass for my added methods, but wonkiness seemed to ensue sometimes when e.g. merging a complex object with a {foo: NaN} value. The new version is a bit more straightforward (IMO) and doesn't use merge(), so it's not affected, but it could use more digging. I can't take more company time for it right now, though!\n. Refers to #64 (apparently the commit comment didn\u2019t do the trick, sorry).\nI\u2019m not sure whether adding methods like this is really the right thing to do, but I followed to the model of merge. Perhaps it would be better to follow a lodash-like model of exported functions to avoid conflicts with named properties.\n. Sorry I took even longer getting back! Added to README, changed a few random values to use JSC, not sure if that\u2019s precisely what you meant: haven\u2019t used JSC before (though if it\u2019s inspired by QuickCheck, I expect to do so again).\n. It can be done with arrays; I added it to arrays. I also found some weird edge cases where the object versions didn't work properly (with nested paths); I didn't nail it down, as my main concern was making the tests pass for my added methods, but wonkiness seemed to ensue sometimes when e.g. merging a complex object with a {foo: NaN} value. The new version is a bit more straightforward (IMO) and doesn't use merge(), so it's not affected, but it could use more digging. I can't take more company time for it right now, though!\n. ",
    "johnste": "Could this also be made to work with arrays as well? Currently it's cumbersome to update an item in an array.\n. Could this also be made to work with arrays as well? Currently it's cumbersome to update an item in an array.\n. ",
    "zuk": "Looks like this is still happening for objects with nested arrays. For example:\nvar a = Immutable({foo: []})\nvar b = Immutable({foo: []})\nvar ab = a.merge(b, {deep: true})\nab === a  // => false\nWithout a nested array it works as expected:\nvar a = Immutable({foo: {}})\nvar b = Immutable({foo: {}})\nvar ab = a.merge(b, {deep: true})\nab === a  // => true\n. Sure, opened it as #94\n. Added a failing test case for this in AkiraMD/seamless-immutable@98a912dd1d60e2fe7c805f6455c7e1c045ef0a88\n. Oh boy... started trying to fix this myself, but to be honest the current codebase is kind of a horror show. I understand the imperative not to make seamless-immutable dependent on too many libraries, but there's a whole lot of reinventing the wheel going on here. Using something like lodash for a lot of the type and equality checking stuff might help. I'm going to look in to some other libraries to manage an immutable Redux state now.\n. Looks like this is still happening for objects with nested arrays. For example:\nvar a = Immutable({foo: []})\nvar b = Immutable({foo: []})\nvar ab = a.merge(b, {deep: true})\nab === a  // => false\nWithout a nested array it works as expected:\nvar a = Immutable({foo: {}})\nvar b = Immutable({foo: {}})\nvar ab = a.merge(b, {deep: true})\nab === a  // => true\n. Sure, opened it as #94\n. Added a failing test case for this in AkiraMD/seamless-immutable@98a912dd1d60e2fe7c805f6455c7e1c045ef0a88\n. Oh boy... started trying to fix this myself, but to be honest the current codebase is kind of a horror show. I understand the imperative not to make seamless-immutable dependent on too many libraries, but there's a whole lot of reinventing the wheel going on here. Using something like lodash for a lot of the type and equality checking stuff might help. I'm going to look in to some other libraries to manage an immutable Redux state now.\n. ",
    "geowarin": "Hi!\nI just wanted to contribute my two cents to this issue.\nFirst, let me say that I love seamless-immutable and this issue currently prevents me to use it at a massive scale for react applications.\nThere are two workarounds for this issue:\njs\nmyImmutableArray.asMutable().map((item,key) => <li key={key}>item.value</li>)\nOr, as mentioned above:\njs\n_.map(myImmutableArray, (item,key) => <li key={key}>item.value</li>)\nIn my opinion, we are loosing the notion of \"seamless\" here.\nI'm setting up projects for people new to React to get them started easily.\nBasically, I will tell them: \"This is seamless until you use it in a React component\".\nThat's a leaky abstraction.\nI wonder if the use case of mapping elements to another immutable collection is as frequent as you think.\nBy mapping elements, you are basically transforming your Array<X> to another Array<Y>.\nSo it's a conscious decision and most of the time, I'll be using a transform for read-only operations.\nIntroducing a mapToImmutable() function and letting map() return a mutable array is another solution to this problem.\nWhat do you think?\n. PR #120 is indeed a great solution!\n. Hi!\nI just wanted to contribute my two cents to this issue.\nFirst, let me say that I love seamless-immutable and this issue currently prevents me to use it at a massive scale for react applications.\nThere are two workarounds for this issue:\njs\nmyImmutableArray.asMutable().map((item,key) => <li key={key}>item.value</li>)\nOr, as mentioned above:\njs\n_.map(myImmutableArray, (item,key) => <li key={key}>item.value</li>)\nIn my opinion, we are loosing the notion of \"seamless\" here.\nI'm setting up projects for people new to React to get them started easily.\nBasically, I will tell them: \"This is seamless until you use it in a React component\".\nThat's a leaky abstraction.\nI wonder if the use case of mapping elements to another immutable collection is as frequent as you think.\nBy mapping elements, you are basically transforming your Array<X> to another Array<Y>.\nSo it's a conscious decision and most of the time, I'll be using a transform for read-only operations.\nIntroducing a mapToImmutable() function and letting map() return a mutable array is another solution to this problem.\nWhat do you think?\n. PR #120 is indeed a great solution!\n. ",
    "shamrin": "I agree with @geowarin that having browser hang and then fail with stack overflow when doing Immutable([1,2,3]).map(function() { return <div /> }) is a very serious issue.\nPlease consider reviewing two recent approaches to fixing this problem:\n- PR #120 that skips making React components immutable.\n- PR #119 that detects cycles during development and refers to this issue in browser console.\n. Done!\nI've also written about this problem in wiki. Error message now links to it: https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected\n. @davidblurton Interesting approach to solving #73.\nHave you considered simply checking for isReactComponent property? It was sugggested here: \nhttps://discuss.reactjs.org/t/how-to-determine-if-js-object-is-react-component/2825/5\n. You are right, React elements no longer can be detected by a simple property check.\u00b9 Your approach seems to be the correct way. It's even mentioned in \"React Components, Elements, and Instances\" blog post:\n\nAll React elements require an additional $$typeof: Symbol.for('react.element') field declared on the object for security reasons.\n\n\u00b9 _isReactElement property was removed, at the same time as $$typeof was introduced - before React v0.14.0-rc1.\n. I agree with @geowarin that having browser hang and then fail with stack overflow when doing Immutable([1,2,3]).map(function() { return <div /> }) is a very serious issue.\nPlease consider reviewing two recent approaches to fixing this problem:\n- PR #120 that skips making React components immutable.\n- PR #119 that detects cycles during development and refers to this issue in browser console.\n. Done!\nI've also written about this problem in wiki. Error message now links to it: https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected\n. @davidblurton Interesting approach to solving #73.\nHave you considered simply checking for isReactComponent property? It was sugggested here: \nhttps://discuss.reactjs.org/t/how-to-determine-if-js-object-is-react-component/2825/5\n. You are right, React elements no longer can be detected by a simple property check.\u00b9 Your approach seems to be the correct way. It's even mentioned in \"React Components, Elements, and Instances\" blog post:\n\nAll React elements require an additional $$typeof: Symbol.for('react.element') field declared on the object for security reasons.\n\n\u00b9 _isReactElement property was removed, at the same time as $$typeof was introduced - before React v0.14.0-rc1.\n. ",
    "davidblurton": "Yes, please test it out and mention me if you have any issues. \n. Tests pass but error with \nError:\nZuul tried to run tests in saucelabs, however no saucelabs credentials were provided.\nSee the zuul wiki (https://github.com/defunctzombie/zuul/wiki/Cloud-testing) for info on how to setup cloud testing.\n. The property isReactComponent doesn't seem to be defined on ES6 classes. \nTo check for classes you'd have to do React.Component.isPrototypeOf(object) but that involves taking a dependency on react.\n. I've added some tests for React elements and components. This along with the cycle detection should make things a lot smoother. \nOne problem I had was that the property that causes the issue, _owner, isn't filled in until the component is mounted in the dom. In other words, I was unable to reproduce the stack overflow in my tests. Instead I tested that React elements and components aren't modified. \nCI build still failing with Zuul error. \n. Yes, please test it out and mention me if you have any issues. \n. Tests pass but error with \nError:\nZuul tried to run tests in saucelabs, however no saucelabs credentials were provided.\nSee the zuul wiki (https://github.com/defunctzombie/zuul/wiki/Cloud-testing) for info on how to setup cloud testing.\n. The property isReactComponent doesn't seem to be defined on ES6 classes. \nTo check for classes you'd have to do React.Component.isPrototypeOf(object) but that involves taking a dependency on react.\n. I've added some tests for React elements and components. This along with the cycle detection should make things a lot smoother. \nOne problem I had was that the property that causes the issue, _owner, isn't filled in until the component is mounted in the dom. In other words, I was unable to reproduce the stack overflow in my tests. Instead I tested that React elements and components aren't modified. \nCI build still failing with Zuul error. \n. ",
    "fxck": "basically adding umd.. like this perhaps https://github.com/fxck/seamless-immutable/commits/master it's failing tests now though.. but it works\n. basically adding umd.. like this perhaps https://github.com/fxck/seamless-immutable/commits/master it's failing tests now though.. but it works\n. ",
    "veggiemonk": ":+1: \n. :+1: \n. ",
    "amannn": "I'd like to do something like this:\njs\nlet o = Immutable({arr: [{id: 2}]});\no = o.merge({arr: [{id: 3}]}, {mergeArray: false});\n// o is {arr: [{id: 3}]}\nSo the array from B should override the array from A.\nWith the current implementation the result is {arr: [{id: 2}, {id: 3}]}\n. Oh, you're of course totally right! Sorry for the annoyance \u2013 I mixed this up with another library. Everything works as expected.\n. I'd like to do something like this:\njs\nlet o = Immutable({arr: [{id: 2}]});\no = o.merge({arr: [{id: 3}]}, {mergeArray: false});\n// o is {arr: [{id: 3}]}\nSo the array from B should override the array from A.\nWith the current implementation the result is {arr: [{id: 2}, {id: 3}]}\n. Oh, you're of course totally right! Sorry for the annoyance \u2013 I mixed this up with another library. Everything works as expected.\n. ",
    "nikki93": "Thanks! I will say though that what I proposed is different: you do get back an Immutable, but not a deep one. So it is an Immutable array of objects that are mutable, or so. Basically what I was saying is in general map does T a -> T b which says nothing about b. The question then becomes 'can T contain mutable objects?'\n. Thanks! I will say though that what I proposed is different: you do get back an Immutable, but not a deep one. So it is an Immutable array of objects that are mutable, or so. Basically what I was saying is in general map does T a -> T b which says nothing about b. The question then becomes 'can T contain mutable objects?'\n. ",
    "borisd": "Perhaps its worth to add mapImmutable() as the current implementation prevents new comers from using the library as it breaks the regular React approach of:\ntodos.map(todo => <Todo todo={ todo } />\n. Perhaps its worth to add mapImmutable() as the current implementation prevents new comers from using the library as it breaks the regular React approach of:\ntodos.map(todo => <Todo todo={ todo } />\n. ",
    "ramivalta": "I'm on it, apologies for not running the tests before submitting.\n. This must be because Object.keys is an ES5 feature, and some old browsers (namely IE8) doesn't support it. Would you be against introducing a dependency on es5-shim (https://github.com/es-shims/es5-shim)?\n. Actually we could just use lodash.keys since lodash is already a devDependency.\n. @rtfeldman Sorry for not being responsive. This PR merely works around #82 by always turning currentValue into an Immutable before calling merge on it - it's not pretty but it doesn't break any tests unlike the previous attempt. I'll try to provide a test case soon.\n. I'm on it, apologies for not running the tests before submitting.\n. This must be because Object.keys is an ES5 feature, and some old browsers (namely IE8) doesn't support it. Would you be against introducing a dependency on es5-shim (https://github.com/es-shims/es5-shim)?\n. Actually we could just use lodash.keys since lodash is already a devDependency.\n. @rtfeldman Sorry for not being responsive. This PR merely works around #82 by always turning currentValue into an Immutable before calling merge on it - it's not pretty but it doesn't break any tests unlike the previous attempt. I'll try to provide a test case soon.\n. ",
    "davidkpiano": "Extremely tiny nit: isMergeableObject :wink: \n. Extremely tiny nit: isMergeableObject :wink: \n. ",
    "InsomniacFury": "Along those lines, I am confused. \nThe production version seems to me that it effectively leaves objects immutable, which invalidates the concept of this library.  I understand that the production version is useful when performance is a problem, but from what I can tell it stops delivering making objects immutable.\nI could be missing something fundamental.\n. @rtfeldman thanks for the response.  That makes sense. I saw that in the docs Safari was called out as having a slow Object.freeze().   Are there any other performance implications that has lead to the production version not enforcing the immutability?\n. Cool, thanks for your consideration.\n. @rtfeldman correct.\n. Along those lines, I am confused. \nThe production version seems to me that it effectively leaves objects immutable, which invalidates the concept of this library.  I understand that the production version is useful when performance is a problem, but from what I can tell it stops delivering making objects immutable.\nI could be missing something fundamental.\n. @rtfeldman thanks for the response.  That makes sense. I saw that in the docs Safari was called out as having a slow Object.freeze().   Are there any other performance implications that has lead to the production version not enforcing the immutability?\n. Cool, thanks for your consideration.\n. @rtfeldman correct.\n. ",
    "bholloway": "+1\n. Thanks @rtfeldman. I was using in JSBin so that should solve my issue.\nHowever there might be a problem in the bower.json in that case, since it points to the src file. I would say it 99% of cases a Bower package goes straight to Web, rather than being used/built in a Node-like environment.\nI am happy give you a PR for that fix and some clarification in the Docs but if you are opposed, or it is quicker for you to change yourself, then just let me know.\n. +1\n. Thanks @rtfeldman. I was using in JSBin so that should solve my issue.\nHowever there might be a problem in the bower.json in that case, since it points to the src file. I would say it 99% of cases a Bower package goes straight to Web, rather than being used/built in a Node-like environment.\nI am happy give you a PR for that fix and some clarification in the Docs but if you are opposed, or it is quicker for you to change yourself, then just let me know.\n. ",
    "fenduru": "@rtfeldman if you're not worried about license enforcement, then you should use a license that does not mandate that * Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\nThe intuitive use of this repository would be to ship with the .production.min.js file, which by default is in violation of your own license\n. An alternative approach that jquery uses is to have a small comment linking to the full license:\nhttps://github.com/jquery/jquery/blob/2.2.0/dist/jquery.min.js\n. @rtfeldman if you're not worried about license enforcement, then you should use a license that does not mandate that * Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\nThe intuitive use of this repository would be to ship with the .production.min.js file, which by default is in violation of your own license\n. An alternative approach that jquery uses is to have a small comment linking to the full license:\nhttps://github.com/jquery/jquery/blob/2.2.0/dist/jquery.min.js\n. ",
    "estaub": "(noob here, hopefully not too off-topic) It would be good to know (without testing) whether static object/array methods like Object.keys() will work.  Nothing in the readme leads me to guess one way or the other.\n. (noob here, hopefully not too off-topic) It would be good to know (without testing) whether static object/array methods like Object.keys() will work.  Nothing in the readme leads me to guess one way or the other.\n. ",
    "danny-andrews": "I actually don't think enumerating the modified built-in methods is that important anymore. The purpose of the library implies it's going to be doing that stuff. It's more important to know which methods have been added to the prototype (which is already documented). Although, from the examples, it's not clear that Array.prototype is modified, since the Immutable.METHOD_NAME version is used. Example: https://github.com/rtfeldman/seamless-immutable#flatmap.. I actually don't think enumerating the modified built-in methods is that important anymore. The purpose of the library implies it's going to be doing that stuff. It's more important to know which methods have been added to the prototype (which is already documented). Although, from the examples, it's not clear that Array.prototype is modified, since the Immutable.METHOD_NAME version is used. Example: https://github.com/rtfeldman/seamless-immutable#flatmap.. ",
    "strawbrary": "Ah sorry my mistake. Thanks for helping me out and that great explanation @tusharmath.\n. Ah sorry my mistake. Thanks for helping me out and that great explanation @tusharmath.\n. ",
    "danfma": "I made a pull request to this.\n. I made a pull request to this.\n. ",
    "smashercosmo": "But I think it's intentional, isn't it? Objects are frozen only in development mode. Because in production it will result in performance issues.\n. @LinusU That kind of data manipulation should occur only in reducers. I would keep sets and entities in different state slices and handle them with different reducers. And you won't need mergeIn for it.\n. @rtfeldman Would it be possible to cut a release?. But I think it's intentional, isn't it? Objects are frozen only in development mode. Because in production it will result in performance issues.\n. @LinusU That kind of data manipulation should occur only in reducers. I would keep sets and entities in different state slices and handle them with different reducers. And you won't need mergeIn for it.\n. @rtfeldman Would it be possible to cut a release?. ",
    "camjc": "@smashercosmo I think the issue is that it is not freezing in non-node environments (like a browser).\n@danfma Is that right?\n. @smashercosmo I think the issue is that it is not freezing in non-node environments (like a browser).\n@danfma Is that right?\n. ",
    "meta-meta": "@rtfeldman why not freeze in production? Is performance that much worse? Seems like this would lead to subtle bugs in edge cases when in production, we visit some old haunted code path without test coverage... Much like Luke's training scene in Empire. He decapitates Vader, which he assumes has been wrapped in immutable machinery only to discover his own face in place of Anakin's.\n. @rtfeldman why not freeze in production? Is performance that much worse? Seems like this would lead to subtle bugs in edge cases when in production, we visit some old haunted code path without test coverage... Much like Luke's training scene in Empire. He decapitates Vader, which he assumes has been wrapped in immutable machinery only to discover his own face in place of Anakin's.\n. ",
    "jschr": "+1, would also love to have a complimentary withoutIn method as well to delete nested keys.\nie. \njs\nImmutable({ a: { b: 1, c: 2 } }).withoutIn(['a'], 'b')\n// -> Immutable({ a: { c: 2 } })\n. +1, would also love to have a complimentary withoutIn method as well to delete nested keys.\nie. \njs\nImmutable({ a: { b: 1, c: 2 } }).withoutIn(['a'], 'b')\n// -> Immutable({ a: { c: 2 } })\n. ",
    "LinusU": "@rtfeldman I just found out the hard way that there isn't a mergeIn method, I just assumed it was there :)\nI think that there are some very compelling use cases. A common pattern in redux is to have a object with all entities, and then use different set that just contains the ids that corresponds to those objects. e.g. I have this object\njs\n{\n  entities: {\n    '1': { ... },\n    '2': { ... },\n    '3': { ... },\n    ...\n  },\n  sets: {\n    active: [1, 6, 9, 31, ...]\n    needAction: [1, 3, 5, 6, ...]\n  }\n}\nTo then add more entities is a simple merge on the entities obejct. But it's important that it's not a deep merge so that removed properties will get properly removed when updating the entities. A mergeIn function would be perfect now\njs\nfetch('/animals?needAction=true')\n  .then(res => res.json())\n  .then(Immutable)\n  .then(animals => {\n    return state\n      .setIn(['sets', 'needAction'], animals.map(animal => animal.id))\n      .mergeIn(['entities'], animals.asObject(animal => [animal.id, animal]))\n  }\n}\n. Yes it should be done in a reducer, I just wanted to show some code that made more sense for people not coming from redux...\nI'm not use that I agree on having them in different reducers though, since the two properties are tightly coupled I don't see why they couldn't be manipulated by the same reducer?\n. RegExp is immutable by default as far as I understand it.\n``` js\nvar a = new RegExp('a')\na.flags\n// \"\"\na.flags = 'g'\n// \"g\"\na.flags\n// \"\" (still empty)\na.source\n// \"a\"\na.source = 'b'\n// \"b\"\na.source\n// \"a\" (not modified)\n``\n. @rtfeldman I just found out the hard way that there isn't amergeIn` method, I just assumed it was there :)\nI think that there are some very compelling use cases. A common pattern in redux is to have a object with all entities, and then use different set that just contains the ids that corresponds to those objects. e.g. I have this object\njs\n{\n  entities: {\n    '1': { ... },\n    '2': { ... },\n    '3': { ... },\n    ...\n  },\n  sets: {\n    active: [1, 6, 9, 31, ...]\n    needAction: [1, 3, 5, 6, ...]\n  }\n}\nTo then add more entities is a simple merge on the entities obejct. But it's important that it's not a deep merge so that removed properties will get properly removed when updating the entities. A mergeIn function would be perfect now\njs\nfetch('/animals?needAction=true')\n  .then(res => res.json())\n  .then(Immutable)\n  .then(animals => {\n    return state\n      .setIn(['sets', 'needAction'], animals.map(animal => animal.id))\n      .mergeIn(['entities'], animals.asObject(animal => [animal.id, animal]))\n  }\n}\n. Yes it should be done in a reducer, I just wanted to show some code that made more sense for people not coming from redux...\nI'm not use that I agree on having them in different reducers though, since the two properties are tightly coupled I don't see why they couldn't be manipulated by the same reducer?\n. RegExp is immutable by default as far as I understand it.\n``` js\nvar a = new RegExp('a')\na.flags\n// \"\"\na.flags = 'g'\n// \"g\"\na.flags\n// \"\" (still empty)\na.source\n// \"a\"\na.source = 'b'\n// \"b\"\na.source\n// \"a\" (not modified)\n```\n. ",
    "braco": "parent: { [parentId]: { children: { [id]: { ... } } } }\nstate.mergeIn(['parent', parentId, 'children', id], { merge me })\nIs there anything that would be as clean as mergeIn above? It would be nice to have a completely flattened state, but this isn't always desirable.\nwithoutIn(), and some array methods would also be nice.\nDealing with deeply nested items is a pain, and there are already some patterns to build from starting with setIn(). Immutable.js has lots of methods like mergeDeep(), so there is precedence API wise. I'm finding the time originally saved by having normal objects with seamless is being eaten away by actually manipulating the data.\nMaybe an alternative, more decorated version of seamless that adds convenience methods?\n. @rtfeldman: just FYI, docs were updated to use production seamless-immutable, claims it's still faster:\nhttps://github.com/guigrpa/timm\n. parent: { [parentId]: { children: { [id]: { ... } } } }\nstate.mergeIn(['parent', parentId, 'children', id], { merge me })\nIs there anything that would be as clean as mergeIn above? It would be nice to have a completely flattened state, but this isn't always desirable.\nwithoutIn(), and some array methods would also be nice.\nDealing with deeply nested items is a pain, and there are already some patterns to build from starting with setIn(). Immutable.js has lots of methods like mergeDeep(), so there is precedence API wise. I'm finding the time originally saved by having normal objects with seamless is being eaten away by actually manipulating the data.\nMaybe an alternative, more decorated version of seamless that adds convenience methods?\n. @rtfeldman: just FYI, docs were updated to use production seamless-immutable, claims it's still faster:\nhttps://github.com/guigrpa/timm\n. ",
    "tad-lispy": "I know it only answers to the specific case in your example, but how about:\njavascript\nthis.setState({arr: this.state.arr.concat(newElement)})\nRead more about concat at MDN.\n. That's true, that delete would be useful, however the name doesn't seem safe - it can easily collide with reserved keyword. I would actually call it without.\nIn one of my projects I came up with this helper function:\njavascript\nremove_item = function(index, array) {\n    return array.slice(0, index).concat(array.slice(index + 1));\n};\nThen you can remove 3rd item by calling:\njavascript\narr = remove_item(2, arr)\nI can make a PR to use it as a method of immutable array. What do you think, @rtfeldman ?\nAs for the push - is there anything wrong with concat?\n. The CI build is still failing, this time when trying to run Zuul tests. Is there anything I can do about it?\n. @rtfeldman no, not really. I guess I was too lazy to read my own issue.\nShould be better now.\n. I did some research and actually the complete list of platforms that are failing is:\n1.  android 4.0 on Linux\n2.  android 5.1 on Linux\n3.  internet explorer 10 on Windows 2012\n4.  internet explorer 11 on Windows 10\n5.  internet explorer 9 on Windows 2008\n6.  opera 12 on Windows 2003\n7.  safari 6 on Mac 10.8\nThey all fail at the same two tests:\n1.  ImmutableArray :: #asMutable :: returns a deep mutable copy if provided the deep flag\n2.  ImmutableObject :: #asMutable :: returns a deep mutable copy if provided the deep flag\nThe errors are:\n| Platform | Error |\n| --- | --- |\n| IE | Object.getOwnPropertyDescriptor: argument is not an Object |\n| Safari | Requested property descriptor of a value that is not an object. |\n| Opera | Object.getOwnPropertyDescriptor: first argument not an Object |\n| Android | Object.getOwnPropertyDescriptor called on non-object |\nWhich practically boils down to the same thing.\nWhy\nAccording to ES 5.1 standard if first argument to Object.getOwnPropertyDescriptor is not an Object it throws a TypeError exception. That's what we get in failing platforms.\nAccording to ES 2015 standard the first argument is always coerced to object.\nAll failing platforms seem to behave according to ES 5 standard. In our case the function causing the errors is asDeepMutable, which just passes whatever it gets to Object.getOwnPropertyDescriptor. It is being called by two other functions asMutableArray and asMutableObject. Both iterate indiscriminately over elements / keys and pass them to asDeepMutable. So when the value is not an object (e.g. a number, null, etc.) the ES 5 platforms are throwing errors.\nThe solution is probably to check the type of argument passed to asDeepMutable.\nPR comming soon :)\n. You are welcome and thanks for Seamless. It is so much fun to work with.\n. Maybe it's a good reason to revisit #81?\n. Given prior discussion at #131 it seems like correct solution to this problem is to add Immutable specific methods to the constructor (aka making them static). This was previously proposed in #81 .\n\nDo you think that methods should be defined only on the constructor, or also on instances?\nThe constructor only approach seems more elegant, but would be a serious breaking change.\nWith constructor + instance approach, we still have to figure out how collisions with original object properties should be resolved. Also things like that:\njavascript\nimmutable_instance.merge({ without: \"data\" })\n. Didn't thought about development vs. production aspect before. I fully agree - #81 is the ultimate way. Thanks for taking time to look at it.\n. I know it only answers to the specific case in your example, but how about:\njavascript\nthis.setState({arr: this.state.arr.concat(newElement)})\nRead more about concat at MDN.\n. That's true, that delete would be useful, however the name doesn't seem safe - it can easily collide with reserved keyword. I would actually call it without.\nIn one of my projects I came up with this helper function:\njavascript\nremove_item = function(index, array) {\n    return array.slice(0, index).concat(array.slice(index + 1));\n};\nThen you can remove 3rd item by calling:\njavascript\narr = remove_item(2, arr)\nI can make a PR to use it as a method of immutable array. What do you think, @rtfeldman ?\nAs for the push - is there anything wrong with concat?\n. The CI build is still failing, this time when trying to run Zuul tests. Is there anything I can do about it?\n. @rtfeldman no, not really. I guess I was too lazy to read my own issue.\nShould be better now.\n. I did some research and actually the complete list of platforms that are failing is:\n1.  android 4.0 on Linux\n2.  android 5.1 on Linux\n3.  internet explorer 10 on Windows 2012\n4.  internet explorer 11 on Windows 10\n5.  internet explorer 9 on Windows 2008\n6.  opera 12 on Windows 2003\n7.  safari 6 on Mac 10.8\nThey all fail at the same two tests:\n1.  ImmutableArray :: #asMutable :: returns a deep mutable copy if provided the deep flag\n2.  ImmutableObject :: #asMutable :: returns a deep mutable copy if provided the deep flag\nThe errors are:\n| Platform | Error |\n| --- | --- |\n| IE | Object.getOwnPropertyDescriptor: argument is not an Object |\n| Safari | Requested property descriptor of a value that is not an object. |\n| Opera | Object.getOwnPropertyDescriptor: first argument not an Object |\n| Android | Object.getOwnPropertyDescriptor called on non-object |\nWhich practically boils down to the same thing.\nWhy\nAccording to ES 5.1 standard if first argument to Object.getOwnPropertyDescriptor is not an Object it throws a TypeError exception. That's what we get in failing platforms.\nAccording to ES 2015 standard the first argument is always coerced to object.\nAll failing platforms seem to behave according to ES 5 standard. In our case the function causing the errors is asDeepMutable, which just passes whatever it gets to Object.getOwnPropertyDescriptor. It is being called by two other functions asMutableArray and asMutableObject. Both iterate indiscriminately over elements / keys and pass them to asDeepMutable. So when the value is not an object (e.g. a number, null, etc.) the ES 5 platforms are throwing errors.\nThe solution is probably to check the type of argument passed to asDeepMutable.\nPR comming soon :)\n. You are welcome and thanks for Seamless. It is so much fun to work with.\n. Maybe it's a good reason to revisit #81?\n. Given prior discussion at #131 it seems like correct solution to this problem is to add Immutable specific methods to the constructor (aka making them static). This was previously proposed in #81 .\n\nDo you think that methods should be defined only on the constructor, or also on instances?\nThe constructor only approach seems more elegant, but would be a serious breaking change.\nWith constructor + instance approach, we still have to figure out how collisions with original object properties should be resolved. Also things like that:\njavascript\nimmutable_instance.merge({ without: \"data\" })\n. Didn't thought about development vs. production aspect before. I fully agree - #81 is the ultimate way. Thanks for taking time to look at it.\n. ",
    "kelly-kellerheikkila": "Arrays are more difficult to work with using seamless-immutable than objects. I basically have to push new elements to immutable arrays using the approach @ablakey describes. It would be great if seamless-immutable supported something like push() and delete() with arrays, just like it does with set() and without() for objects. At this point, I am forced to convert them to mutables for those objects, and then reconvert back to immutable.\n. Arrays are more difficult to work with using seamless-immutable than objects. I basically have to push new elements to immutable arrays using the approach @ablakey describes. It would be great if seamless-immutable supported something like push() and delete() with arrays, just like it does with set() and without() for objects. At this point, I am forced to convert them to mutables for those objects, and then reconvert back to immutable.\n. ",
    "ablakey": "To respond to the original suggestion: for adding to an array, yes concat works. I wasn't aware of it here and I'm happy with it.\nThe conversation has mutated (hah!)  to talking about other methods for arrays, so I'd like to +1 adding some methods that compensate for the fact that most of the valuable methods in Array.prototype mutate and are therefore not supported with seamless-immutable.\n.without() and maybe set()  Are at the top of my wish list.\nFor example, I want to delete a record from a list.  I have to make the array mutable, remove it, then make the array immutable again.\nHappy to contribute if this is something you want to pursue.\n. To respond to the original suggestion: for adding to an array, yes concat works. I wasn't aware of it here and I'm happy with it.\nThe conversation has mutated (hah!)  to talking about other methods for arrays, so I'd like to +1 adding some methods that compensate for the fact that most of the valuable methods in Array.prototype mutate and are therefore not supported with seamless-immutable.\n.without() and maybe set()  Are at the top of my wish list.\nFor example, I want to delete a record from a list.  I have to make the array mutable, remove it, then make the array immutable again.\nHappy to contribute if this is something you want to pursue.\n. ",
    "slashwhatever": "Did this ever get implemented or discussed?\n. Thanks for the input @crudh. The fact we have to do something different for objects vs arrays is kinda my point. ImmutableJS allows you to use the same method name regardless of the type you're working with.\n. @crudh understood :)\n. Did this ever get implemented or discussed?\n. Thanks for the input @crudh. The fact we have to do something different for objects vs arrays is kinda my point. ImmutableJS allows you to use the same method name regardless of the type you're working with.\n. @crudh understood :)\n. ",
    "OEvgeny": "@rtfeldman good point :smile: \n. @rtfeldman good point :smile: \n. ",
    "tyoh": "+1\n. +1\n. ",
    "zivni": "Well, this my first try. but it isn't very good:\n```\ndeclare module seamlessImmutable {\n    interface ImmutableCommonMethods{\n        setIn?(keys: Array, value: any): T | U;\n        merge?(obj: U): T & U;\n    }\ninterface ImmutableObjectMethods<T> extends ImmutableCommonMethods<T> {\n    set?<U extends T>(key: string, value: any): U;\n    asMutable?(): T;\n    without?<U>(key: string): U;\n    without?<U>(keys: string[]): U;\n    without?<U>(...args: string[]): U;\n    without?<U>(keyFunction: (value: any, key: string) => boolean): U;\n}\n\ninterface ImmutableArrayMethods<T> extends ImmutableCommonMethods<T> {\n    set?<T>(index: number, value: any): Array<T>;\n    asMutable?(): Array<T>;\n    asObject?<U>(toKeyValue: (item: T) => Array<Array<any>>): U;\n    flatMap?<U>(mapFunction: (item: T) => Array<U>)\n\n}\n\n}\n    declare function SI(obj: T, options?): T & seamlessImmutable.ImmutableObjectMethods;\n    declare function SI(obj: Array, options?): Array & seamlessImmutable.ImmutableArrayMethods;\n```\n. I made a small change to what @jonaskello did to this:\n```\ndeclare module SeamlessImmutable {\n    interface DeepMutate {\n        deep: boolean\n    }\ninterface ImmutableCommonMethods<T>{\n    setIn?<U extends T>(keys: Array<string|number>, value: any): T | U;\n    merge?<U>(obj: U): T & U;\n}\n\ninterface ImmutableObjectMethods<T> extends ImmutableCommonMethods<T> {\n    set?<U extends T>(key: string, value: any): U;\n    asMutable?(): T;\n    asMutable?(DeepMutate): T;\n    without?<U>(key: string): U;\n    without?<U>(keys: string[]): U;\n    without?<U>(...args: string[]): U;\n    without?<U>(keyFunction: (value: any, key: string) => boolean): U;\n}\n\ninterface ImmutableArrayMethods<T> extends ImmutableCommonMethods<T> {\n    set?<T>(index: number, value: any): Array<T>;\n    asMutable?(): Array<T>;\n    asMutable?(DeepMutate): Array<T>;\n    asObject?<U>(toKeyValue: (item: T) => Array<Array<any>>): U;\n    flatMap?<U>(mapFunction: (item: T) => Array<U>)\n\n}\n\n}\ndeclare module 'seamless-immutable' {\n  type Immutable = {\n    (obj: Array, options?: any): Array & SeamlessImmutable.ImmutableArrayMethods;\n    (obj: T, options?: any): T & SeamlessImmutable.ImmutableObjectMethods;\n    isImmutable(target: any): boolean;\n    ImmutableError(message: string): Error;\n  }\nvar Immutable:Immutable;\n  export = Immutable;\n}\n```\nThis way I can import using import * as SI  from \"seamless-immutable\"\nand use it with state = SI<MyType>({...})\nbut I can also type my functions / variables:\nlet state: MyType & SeamlessImmutable.ImmutableObjectMethods<MyType >;\n...\nstate = SI<MyType>({...})\nand can create helper functions:\n```\nexport function update(obj:T & SeamlessImmutable.ImmutableObjectMethods, update:any):T {\n    return obj.merge(update);\n}\nexport function removeProperty(obj:T & SeamlessImmutable.ImmutableObjectMethods, propertyName:string):T{\n    return obj.without(propertyName);\n}\n```\nI only wish I could find a way to declare ImmutableObjectMethods<T> to include T's members so I wouldn't need to use the & operator everywhere\n. Thanks for the update.\nI like to keep the typing (interfaces and so) in a separate module. that way I can just reference the directly without import.\nWith  type Immutable = { <T>(obj: Array<T>, options?: any)... as I posted above I can use SI(myObj) without the from function.\nHere is my typing after I've included missing typing that @jonaskello  added:\n```\ndeclare module SeamlessImmutable {\n    interface DeepMutate {\n        deep: boolean\n    }\n    interface ImmutableCommonMethods {\n        setIn?(keys: Array, value: any): T | U;\n        merge?(obj: U, options?: DeepMutate): T & U;\n    }\ninterface ImmutableObjectMethods<T> extends ImmutableCommonMethods<T> {\n    set?<U extends T>(key: string, value: any): U;\n    asMutable?(): T;\n    asMutable?(AsMutableOptions): T;\n    without?<U>(key: string): U;\n    without?<U>(keys: string[]): U;\n    without?<U>(...args: string[]): U;\n    without?<U>(keyFunction: (value: any, key: string) => boolean): U;\n}\n\ninterface ImmutableArrayMethods<T> extends ImmutableCommonMethods<T>, Array<T> {\n    set?<T>(index: number, value: any): Array<T>;\n    asMutable?(): Array<T>;\n    asMutable?(DeepMutate): Array<T>;\n    asObject?<U>(toKeyValue: (item: T) => Array<Array<any>>): U;\n    flatMap?<U>(mapFunction: (item: T) => Array<U>)\n}\n\n}\ndeclare module 'seamless-immutable' {\n    type Immutable = {\n        (obj: Array, options?: any): SeamlessImmutable.ImmutableArrayMethods;\n        (obj: T, options?: any): T & SeamlessImmutable.ImmutableObjectMethods;\n        isImmutable(target: any): boolean;\n        ImmutableError(message: string): Error;\n        from(obj: Array, options?: any): SeamlessImmutable.ImmutableArrayMethods;\n        from(obj: T, options?: any): T & SeamlessImmutable.ImmutableObjectMethods;\n    }\nvar Immutable: Immutable;\nexport = Immutable;\n\n}\n```\n. Well, this my first try. but it isn't very good:\n```\ndeclare module seamlessImmutable {\n    interface ImmutableCommonMethods{\n        setIn?(keys: Array, value: any): T | U;\n        merge?(obj: U): T & U;\n    }\ninterface ImmutableObjectMethods<T> extends ImmutableCommonMethods<T> {\n    set?<U extends T>(key: string, value: any): U;\n    asMutable?(): T;\n    without?<U>(key: string): U;\n    without?<U>(keys: string[]): U;\n    without?<U>(...args: string[]): U;\n    without?<U>(keyFunction: (value: any, key: string) => boolean): U;\n}\n\ninterface ImmutableArrayMethods<T> extends ImmutableCommonMethods<T> {\n    set?<T>(index: number, value: any): Array<T>;\n    asMutable?(): Array<T>;\n    asObject?<U>(toKeyValue: (item: T) => Array<Array<any>>): U;\n    flatMap?<U>(mapFunction: (item: T) => Array<U>)\n\n}\n\n}\n    declare function SI(obj: T, options?): T & seamlessImmutable.ImmutableObjectMethods;\n    declare function SI(obj: Array, options?): Array & seamlessImmutable.ImmutableArrayMethods;\n```\n. I made a small change to what @jonaskello did to this:\n```\ndeclare module SeamlessImmutable {\n    interface DeepMutate {\n        deep: boolean\n    }\ninterface ImmutableCommonMethods<T>{\n    setIn?<U extends T>(keys: Array<string|number>, value: any): T | U;\n    merge?<U>(obj: U): T & U;\n}\n\ninterface ImmutableObjectMethods<T> extends ImmutableCommonMethods<T> {\n    set?<U extends T>(key: string, value: any): U;\n    asMutable?(): T;\n    asMutable?(DeepMutate): T;\n    without?<U>(key: string): U;\n    without?<U>(keys: string[]): U;\n    without?<U>(...args: string[]): U;\n    without?<U>(keyFunction: (value: any, key: string) => boolean): U;\n}\n\ninterface ImmutableArrayMethods<T> extends ImmutableCommonMethods<T> {\n    set?<T>(index: number, value: any): Array<T>;\n    asMutable?(): Array<T>;\n    asMutable?(DeepMutate): Array<T>;\n    asObject?<U>(toKeyValue: (item: T) => Array<Array<any>>): U;\n    flatMap?<U>(mapFunction: (item: T) => Array<U>)\n\n}\n\n}\ndeclare module 'seamless-immutable' {\n  type Immutable = {\n    (obj: Array, options?: any): Array & SeamlessImmutable.ImmutableArrayMethods;\n    (obj: T, options?: any): T & SeamlessImmutable.ImmutableObjectMethods;\n    isImmutable(target: any): boolean;\n    ImmutableError(message: string): Error;\n  }\nvar Immutable:Immutable;\n  export = Immutable;\n}\n```\nThis way I can import using import * as SI  from \"seamless-immutable\"\nand use it with state = SI<MyType>({...})\nbut I can also type my functions / variables:\nlet state: MyType & SeamlessImmutable.ImmutableObjectMethods<MyType >;\n...\nstate = SI<MyType>({...})\nand can create helper functions:\n```\nexport function update(obj:T & SeamlessImmutable.ImmutableObjectMethods, update:any):T {\n    return obj.merge(update);\n}\nexport function removeProperty(obj:T & SeamlessImmutable.ImmutableObjectMethods, propertyName:string):T{\n    return obj.without(propertyName);\n}\n```\nI only wish I could find a way to declare ImmutableObjectMethods<T> to include T's members so I wouldn't need to use the & operator everywhere\n. Thanks for the update.\nI like to keep the typing (interfaces and so) in a separate module. that way I can just reference the directly without import.\nWith  type Immutable = { <T>(obj: Array<T>, options?: any)... as I posted above I can use SI(myObj) without the from function.\nHere is my typing after I've included missing typing that @jonaskello  added:\n```\ndeclare module SeamlessImmutable {\n    interface DeepMutate {\n        deep: boolean\n    }\n    interface ImmutableCommonMethods {\n        setIn?(keys: Array, value: any): T | U;\n        merge?(obj: U, options?: DeepMutate): T & U;\n    }\ninterface ImmutableObjectMethods<T> extends ImmutableCommonMethods<T> {\n    set?<U extends T>(key: string, value: any): U;\n    asMutable?(): T;\n    asMutable?(AsMutableOptions): T;\n    without?<U>(key: string): U;\n    without?<U>(keys: string[]): U;\n    without?<U>(...args: string[]): U;\n    without?<U>(keyFunction: (value: any, key: string) => boolean): U;\n}\n\ninterface ImmutableArrayMethods<T> extends ImmutableCommonMethods<T>, Array<T> {\n    set?<T>(index: number, value: any): Array<T>;\n    asMutable?(): Array<T>;\n    asMutable?(DeepMutate): Array<T>;\n    asObject?<U>(toKeyValue: (item: T) => Array<Array<any>>): U;\n    flatMap?<U>(mapFunction: (item: T) => Array<U>)\n}\n\n}\ndeclare module 'seamless-immutable' {\n    type Immutable = {\n        (obj: Array, options?: any): SeamlessImmutable.ImmutableArrayMethods;\n        (obj: T, options?: any): T & SeamlessImmutable.ImmutableObjectMethods;\n        isImmutable(target: any): boolean;\n        ImmutableError(message: string): Error;\n        from(obj: Array, options?: any): SeamlessImmutable.ImmutableArrayMethods;\n        from(obj: T, options?: any): T & SeamlessImmutable.ImmutableObjectMethods;\n    }\nvar Immutable: Immutable;\nexport = Immutable;\n\n}\n```\n. ",
    "panKt": "+1, would be great to have it here!\n. +1, would be great to have it here!\n. ",
    "jonaskello": "Here is what I have come up with so far. It only allows usage of the lib in typescript. It does not provide compile time error for accessing read-only data.\nseamless-immutable.d.ts:\n``` js\ndeclare module 'seamless-immutable' {\ntype Immutable = {\n    (obj:any, options?:any):any;\n    isImmutable(target:any):boolean;\n    ImmutableError(message:string):Error;\n  }\nvar Immutable:Immutable;\n  export = Immutable;\n}\n```\nUsage:\n``` js\nimport * as Immutable from 'seamless-immutable';\nvar array = Immutable([\"totally\", \"immutable\", {hammer: \"Can\u2019t Touch This\"}]);\narray[1] = \"I'm going to mutate you!\"\n```\nThe last line in usage will give a runtime error. It would of course be much better if it gave a compile time error. @zivni your typings look interesting but I am not sure how to use them?\n. Here is a version that combines the additions @Ciantic made with the methods defined by @zivni. It enables typed usage of the original type plus the extra methods that SI provides. I think what is left is to remove the mutation methods that SI bans. However I am not sure how to solve that or if it is even possible?\n``` js\ndeclare module 'seamless-immutable' {\ninterface ImmutableCommonMethods{\n    setIn?(keys: Array, value: any): T | U;\n    merge?(obj: U): T & U;\n  }\ninterface ImmutableObjectMethods extends ImmutableCommonMethods {\n    set?(key: string, value: any): U;\n    asMutable?(): T;\n    without?(key: string): U;\n    without?(keys: string[]): U;\n    without?(...args: string[]): U;\n    without?(keyFunction: (value: any, key: string) => boolean): U;\n  }\ninterface ImmutableArrayMethods extends ImmutableCommonMethods {\n    set?(index: number, value: any): Array;\n    asMutable?(): Array;\n    asObject?(toKeyValue: (item: T) => Array>): U;\n    flatMap?(mapFunction: (item: T) => Array)\n  }\ntype Immutable = {\n    (obj: Array, options?: any): Array & ImmutableArrayMethods;\n    (obj: T, options?: any): T & ImmutableObjectMethods;\n    isImmutable(target: any): boolean;\n    ImmutableError(message: string): Error;\n  }\nvar Immutable:Immutable;\n  export = Immutable;\n}\n```\n. Here are the latest typings we have, although we do not use them on our project yet:\n``` js\ndeclare module 'seamless-immutable' {\n    interface AsMutableOptions {\n        deep:boolean;\n    }\ninterface ImmutableCommonMethods<T> {\n    setIn<U extends T>(keys:Array<string|number>, value:any):T | U;\n    merge<U>(obj:U):T & U;\n}\n\nexport interface ImmutableObjectMethods<T> extends ImmutableCommonMethods<T> {\n    asMutable():T;\n    asMutable(asMutableOptions:AsMutableOptions):T;\n    set<U extends T>(key:string, value:any):U;\n    setIn<U extends T>(key:Array<string>, value:any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any) => any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any, additionalParameter1:any) => any, arg1:any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any) => any, arg1:any, arg2:any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any) => any, arg1:any, arg2:any, arg3:any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any, additionalParameter4:any) => any, arg1:any, arg2:any, arg3:any, arg4:any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any) => any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any, additionalParameter1:any) => any, arg1:any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any) => any, arg1:any, arg2:any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any) => any, arg1:any, arg2:any, arg3:any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any, additionalParameter4:any) => any, arg1:any, arg2:any, arg3:any):U;\n    without<U>(key:string):U;\n    without<U>(keys:string[]):U;\n    without<U>(...args:string[]):U;\n    without<U>(keyFunction:(value:any, key:string) => boolean):U;\n}\n\nexport interface ImmutableArrayMethods<T> extends ImmutableCommonMethods<T>, Array<T> {\n    set<T>(index:number, value:any):Array<T>;\n    asMutable():Array<T>;\n    asMutable(asMutableOptions:AsMutableOptions):Array<T>;\n    asObject<U>(toKeyValue:(item:T) => Array<Array<any>>):U;\n    flatMap<U>(mapFunction:(item:T) => Array<U>):U;\n}\n\nexport function from<T>(obj: Array<T>, options?: any): Array<T> & ImmutableArrayMethods<T>;\nexport function from<T>(obj: T, options?: any): T & ImmutableObjectMethods<T>;\n\nexport function isImmutable(target: any): boolean;\nexport function ImmutableError(message: string): Error;\n\n}\n```\nIf I recall correctly we had trouble with the default exported function so we skipped doing typings for that and instead went with using the from() method as it is a named export which is easier to do typings for. So usage would be something like:\n``` js\nimport * as SI from 'seamless-immutable'\nconst myImmutable = SI.from(myObj);\n```\nAs a side note I am also looking into alternate ways of achieving immutability in typescript. I have found two ways so far. First you can in ts 2.0 (or at least in 1.9 pre-release) declare your interfaces as readonly like this:\njs\ninterface Foo {\n    readonly x:string,\n    readonly y:number\n}\nSecond you can try to achieve immutability by tslint rules. I am doing some work on that here.\n. @zivni You may already be aware of this but if you want your typings global like that I would recommend using the namespace syntax instead. The module without quotes syntax is not preferred anymore (since ts 1.5). So instead of declare module SeamlessImmutable { ...} I would recommend declare namespace SeamlessImmutable { ...}. They are totally equivalent so technically it does not matter. You can read more in the official ts documentation:\n\nA note about terminology: It\u2019s important to note that in TypeScript 1.5, the nomenclature has changed. \u201cInternal modules\u201d are now \u201cnamespaces\u201d. \u201cExternal modules\u201d are now simply \u201cmodules\u201d, as to align with ECMAScript 2015\u2019s terminology, (namely that module X { is equivalent to the now-preferred namespace X {).\n. @dsebastien I was under the impression that the way moving forward is that the typings author should make a PR to the DefinitelyTyped repo, not produce his own npm package. Microsoft will then export DefinitelyTyped to @types npm packages automatically. Could you quote where it says they should be put in their own package?\n. Sine typescript 2.0 It is now possible to achieve immutability at compile-time by just using the readonly keyword and ReadonlyArray. That is what I have been doing lately. I also made tslint-immutable which uses tslint rules to make sure that readonly is enforced.. Here is what I have come up with so far. It only allows usage of the lib in typescript. It does not provide compile time error for accessing read-only data.\n\nseamless-immutable.d.ts:\n``` js\ndeclare module 'seamless-immutable' {\ntype Immutable = {\n    (obj:any, options?:any):any;\n    isImmutable(target:any):boolean;\n    ImmutableError(message:string):Error;\n  }\nvar Immutable:Immutable;\n  export = Immutable;\n}\n```\nUsage:\n``` js\nimport * as Immutable from 'seamless-immutable';\nvar array = Immutable([\"totally\", \"immutable\", {hammer: \"Can\u2019t Touch This\"}]);\narray[1] = \"I'm going to mutate you!\"\n```\nThe last line in usage will give a runtime error. It would of course be much better if it gave a compile time error. @zivni your typings look interesting but I am not sure how to use them?\n. Here is a version that combines the additions @Ciantic made with the methods defined by @zivni. It enables typed usage of the original type plus the extra methods that SI provides. I think what is left is to remove the mutation methods that SI bans. However I am not sure how to solve that or if it is even possible?\n``` js\ndeclare module 'seamless-immutable' {\ninterface ImmutableCommonMethods{\n    setIn?(keys: Array, value: any): T | U;\n    merge?(obj: U): T & U;\n  }\ninterface ImmutableObjectMethods extends ImmutableCommonMethods {\n    set?(key: string, value: any): U;\n    asMutable?(): T;\n    without?(key: string): U;\n    without?(keys: string[]): U;\n    without?(...args: string[]): U;\n    without?(keyFunction: (value: any, key: string) => boolean): U;\n  }\ninterface ImmutableArrayMethods extends ImmutableCommonMethods {\n    set?(index: number, value: any): Array;\n    asMutable?(): Array;\n    asObject?(toKeyValue: (item: T) => Array>): U;\n    flatMap?(mapFunction: (item: T) => Array)\n  }\ntype Immutable = {\n    (obj: Array, options?: any): Array & ImmutableArrayMethods;\n    (obj: T, options?: any): T & ImmutableObjectMethods;\n    isImmutable(target: any): boolean;\n    ImmutableError(message: string): Error;\n  }\nvar Immutable:Immutable;\n  export = Immutable;\n}\n```\n. Here are the latest typings we have, although we do not use them on our project yet:\n``` js\ndeclare module 'seamless-immutable' {\n    interface AsMutableOptions {\n        deep:boolean;\n    }\ninterface ImmutableCommonMethods<T> {\n    setIn<U extends T>(keys:Array<string|number>, value:any):T | U;\n    merge<U>(obj:U):T & U;\n}\n\nexport interface ImmutableObjectMethods<T> extends ImmutableCommonMethods<T> {\n    asMutable():T;\n    asMutable(asMutableOptions:AsMutableOptions):T;\n    set<U extends T>(key:string, value:any):U;\n    setIn<U extends T>(key:Array<string>, value:any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any) => any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any, additionalParameter1:any) => any, arg1:any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any) => any, arg1:any, arg2:any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any) => any, arg1:any, arg2:any, arg3:any):U;\n    update<U extends T>(key:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any, additionalParameter4:any) => any, arg1:any, arg2:any, arg3:any, arg4:any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any) => any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any, additionalParameter1:any) => any, arg1:any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any) => any, arg1:any, arg2:any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any) => any, arg1:any, arg2:any, arg3:any):U;\n    updateIn<U extends T>(key:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any, additionalParameter4:any) => any, arg1:any, arg2:any, arg3:any):U;\n    without<U>(key:string):U;\n    without<U>(keys:string[]):U;\n    without<U>(...args:string[]):U;\n    without<U>(keyFunction:(value:any, key:string) => boolean):U;\n}\n\nexport interface ImmutableArrayMethods<T> extends ImmutableCommonMethods<T>, Array<T> {\n    set<T>(index:number, value:any):Array<T>;\n    asMutable():Array<T>;\n    asMutable(asMutableOptions:AsMutableOptions):Array<T>;\n    asObject<U>(toKeyValue:(item:T) => Array<Array<any>>):U;\n    flatMap<U>(mapFunction:(item:T) => Array<U>):U;\n}\n\nexport function from<T>(obj: Array<T>, options?: any): Array<T> & ImmutableArrayMethods<T>;\nexport function from<T>(obj: T, options?: any): T & ImmutableObjectMethods<T>;\n\nexport function isImmutable(target: any): boolean;\nexport function ImmutableError(message: string): Error;\n\n}\n```\nIf I recall correctly we had trouble with the default exported function so we skipped doing typings for that and instead went with using the from() method as it is a named export which is easier to do typings for. So usage would be something like:\n``` js\nimport * as SI from 'seamless-immutable'\nconst myImmutable = SI.from(myObj);\n```\nAs a side note I am also looking into alternate ways of achieving immutability in typescript. I have found two ways so far. First you can in ts 2.0 (or at least in 1.9 pre-release) declare your interfaces as readonly like this:\njs\ninterface Foo {\n    readonly x:string,\n    readonly y:number\n}\nSecond you can try to achieve immutability by tslint rules. I am doing some work on that here.\n. @zivni You may already be aware of this but if you want your typings global like that I would recommend using the namespace syntax instead. The module without quotes syntax is not preferred anymore (since ts 1.5). So instead of declare module SeamlessImmutable { ...} I would recommend declare namespace SeamlessImmutable { ...}. They are totally equivalent so technically it does not matter. You can read more in the official ts documentation:\n\nA note about terminology: It\u2019s important to note that in TypeScript 1.5, the nomenclature has changed. \u201cInternal modules\u201d are now \u201cnamespaces\u201d. \u201cExternal modules\u201d are now simply \u201cmodules\u201d, as to align with ECMAScript 2015\u2019s terminology, (namely that module X { is equivalent to the now-preferred namespace X {).\n. @dsebastien I was under the impression that the way moving forward is that the typings author should make a PR to the DefinitelyTyped repo, not produce his own npm package. Microsoft will then export DefinitelyTyped to @types npm packages automatically. Could you quote where it says they should be put in their own package?\n. Sine typescript 2.0 It is now possible to achieve immutability at compile-time by just using the readonly keyword and ReadonlyArray. That is what I have been doing lately. I also made tslint-immutable which uses tslint rules to make sure that readonly is enforced.. \n",
    "Ciantic": "I'm looking for this as well, but my idea is a bit like the last one above I think.\nUse seamless-immutable as a wrapper, and then use lodash or other things to \"mutate\" and after that freeze again with Immutable.\nThis way I don't need any API basically more than it's just a function that returns the same thing it took in I think...\nThat is the theory at least.\n. @jonaskello I think you should define with generic and return with it too:\n```\ndeclare module \"seamless-immutable\" {\ntype Immutable = {\n    (obj: T, options?: any): T;\n    isImmutable(target: any): boolean;\n    ImmutableError(message: string): Error;\n  }\nvar Immutable: Immutable;\n  export = Immutable;\n}\n```\nSo that it type checks / autocompletes the object it returns.\n. @jonaskello I couldn't get the simple d.ts working when transpiling to es6, only thing working is in this format:\ntypescript\ndeclare module \"seamless-immutable\" {\n    export default function <T>(obj: T, options?: any): T;\n    export function isImmutable(target: any): boolean;\n    export function ImmutableError(message: string): Error;\n    // ...\n}\nBtw, I've been thinking about something awesome, if JavaScript had API like this:\n``` typescript\nvar frozenObject = Object.freeze({ something: [1,2,3,4,5] });\nvar mutatedFrozenObject = Object.mutate(frozenObject, (mutateObject) => {\n    mutateObject.something[1] = 99;\n    mutateObject.newValue = \"test\";\n});\nmutatedFrozenObject === {\n    something: [1, 99, 3, 4, 5],\n    newValue: \"test\"\n};\n```\nThe API would be probably simple enough for JavaScript engines to optimize the mutation function to work really fast, and it would allow to use all normal libraries to mutate frozen object.\nBest of all, it would be 100% type safe way to mutate.\n. I'm looking for this as well, but my idea is a bit like the last one above I think.\nUse seamless-immutable as a wrapper, and then use lodash or other things to \"mutate\" and after that freeze again with Immutable.\nThis way I don't need any API basically more than it's just a function that returns the same thing it took in I think...\nThat is the theory at least.\n. @jonaskello I think you should define with generic and return with it too:\n```\ndeclare module \"seamless-immutable\" {\ntype Immutable = {\n    (obj: T, options?: any): T;\n    isImmutable(target: any): boolean;\n    ImmutableError(message: string): Error;\n  }\nvar Immutable: Immutable;\n  export = Immutable;\n}\n```\nSo that it type checks / autocompletes the object it returns.\n. @jonaskello I couldn't get the simple d.ts working when transpiling to es6, only thing working is in this format:\ntypescript\ndeclare module \"seamless-immutable\" {\n    export default function <T>(obj: T, options?: any): T;\n    export function isImmutable(target: any): boolean;\n    export function ImmutableError(message: string): Error;\n    // ...\n}\nBtw, I've been thinking about something awesome, if JavaScript had API like this:\n``` typescript\nvar frozenObject = Object.freeze({ something: [1,2,3,4,5] });\nvar mutatedFrozenObject = Object.mutate(frozenObject, (mutateObject) => {\n    mutateObject.something[1] = 99;\n    mutateObject.newValue = \"test\";\n});\nmutatedFrozenObject === {\n    something: [1, 99, 3, 4, 5],\n    newValue: \"test\"\n};\n```\nThe API would be probably simple enough for JavaScript engines to optimize the mutation function to work really fast, and it would allow to use all normal libraries to mutate frozen object.\nBest of all, it would be 100% type safe way to mutate.\n. ",
    "pleimann": "@zivni You can declare a type which is the intersection of MyType and SeamlessImmutable.ImmutableObjectMethods so you won't need to use the '&' everywhere.\n```\ninterface MyType {\n    code: number;\n    message: string;\n};\ntype ImmutableMyType = MyType & SeamlessImmutable.ImmutableObjectMethods;\nlet mt: ImmutableMyType = {\n    code: 1000,\n    message: 'It works!'\n};\nmt = mt.merge({message: 'It still works!'});\n```\n. @zivni You can declare a type which is the intersection of MyType and SeamlessImmutable.ImmutableObjectMethods so you won't need to use the '&' everywhere.\n```\ninterface MyType {\n    code: number;\n    message: string;\n};\ntype ImmutableMyType = MyType & SeamlessImmutable.ImmutableObjectMethods;\nlet mt: ImmutableMyType = {\n    code: 1000,\n    message: 'It works!'\n};\nmt = mt.merge({message: 'It still works!'});\n```\n. ",
    "dsebastien": "Did you guys make any progress on this one?\nWe've decided to use seamless-immutable @ work but we would like to have typings.\nI'm willing to help work on the typings, so if you have any update, don't hesitate to share (gist?)\n. Thanks a lot @jonaskello. I spent all morning battling against those typings and couldn't find a way to re-export a type corresponding to the Immutable object returned by seamless-immutable... just like you said.\nYour comment helped me move forward.\nHere's what I've ended up with:\n```\ndeclare module \"seamless-immutable\" {\n                interface ImmutableCommonMethods{\n                               setIn?(propertyPath: Array, value: any): Immutable;\n                               merge?(part: T): Immutable;\n                }\n            export interface ImmutableObject<T> extends ImmutableCommonMethods<T> {\n                           set(property: string, value: any): Immutable<T>;\n                           setIn(propertyPath:Array<string>, value:any):Immutable<T>;\n\n                           asMutable(): T;\n                           asMutable(opts:AsMutableOptions): T;\n\n                           update(property:string, updaterFunction:(value:any) => any):Immutable<T>;\n                           update(property:string, updaterFunction:(value:any, additionalParameter1:any) => any, arg1:any):Immutable<T>;\n                           update(property:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any) => any, arg1:any, arg2:any):Immutable<T>;\n                           update(property:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any) => any, arg1:any, arg2:any, arg3:any):Immutable<T>;\n                           update(property:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any, additionalParameter4:any) => any, arg1:any, arg2:any, arg3:any, arg4:any):Immutable<T>;\n\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any) => any):Immutable<T>;\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any, additionalParameter1:any) => any, arg1:any):Immutable<T>;\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any) => any, arg1:any, arg2:any):Immutable<T>;\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any) => any, arg1:any, arg2:any, arg3:any):Immutable<T>;\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any, additionalParameter4:any) => any, arg1:any, arg2:any, arg3:any):Immutable<T>;\n\n                           without(property:string):Immutable<T>;\n                           without(propertyPath:string[]):Immutable<T>;\n                           without(...properties:string[]):Immutable<T>;\n                           without(filter:(value:any, key:string) => boolean):Immutable<T>;\n            }\n\n            export interface ImmutableArray<T> extends ImmutableCommonMethods<T> {\n                           set(index: number, value: any): ImmutableArray<T>;\n                           asMutable(): Array<T>;\n                           asMutable(opts:AsMutableOptions): Array<T>;\n                           asObject(toKeyValue: (item: T) => Array<Array<any>>): ImmutableArray<T>;\n                           flatMap(mapFunction: (item: T) => ImmutableArray<T>): any;\n\n                           // TODO review methods (missing ones for arrays?)\n            }\n\n            interface Options {\n                           prototype?: any;\n            }\n\n            interface AsMutableOptions {\n                           deep: boolean;\n            }\n\n            // an immutable object is both of Type T (i.e., looks like a normal T) and of type Immutable<T>\n            export type Immutable<T> = T & (ImmutableObject<T> | ImmutableArray<T>);\n\n            // TODO it would be ideal to be able to expose that type and have the variable available from client code\n            // couldn't figure out how to do this unfortunately\n            /*\n            export type SeamlessImmutable = {\n                           <T>(obj: T, options?: Options): T & ImmutableObject<T>;\n                           <T>(obj: Array<T>, options?: Options): Array<T> & ImmutableArray<T>;\n                           from:SeamlessImmutable;\n                           isImmutable(target: any): boolean;\n                           ImmutableError(message: string): Error;\n            };\n\n            export const Immutable: SeamlessImmutable;\n            */\n\n            export function from<T>(obj: T, options?: Options): T & ImmutableObject<T>;\n            export function from<T>(obj: Array<T>, options?: Options): Array<T> & ImmutableArray<T>;\n\n            export function isImmutable(target: any): boolean;\n            export function ImmutableError(message: string): Error;\n\n}\n```\nI'll try to take some time and publish those typings as an npm package.\nI also made a \"global\" version for cases where seamless-immutable is loaded as a script tag (i.e., when it attaches Immutable to the window object).\n. The advantage of the above is that in my code I can import the same way you mentionned, but also import the Immutable type separately, which makes for a nicer TS API:\nimport * as SeamlessImmutable from \"seamless-immutable\";\nimport {Immutable} from \"seamless-immutable\";\n...\nconst immutablePerson:Immutable<Person> = SeamlessImmutable.from(new Person());\n...\n. Actually I think typings should be in their own package. That's the way the TypeScript team pushes forward now with TS 2.0+ (see here: https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/)\nThe reason is that people don't necessarily want to release a new version of a library because the typings are incomplete or buggy. I guess there are pros and cons to both approaches\n. @jonaskello might be the latest news, I don't know ^^\n@mnasyrov well I believe in TypeScript so I see its value, but developers of pure JS libs might simply not care enough ^^\n. Did you guys make any progress on this one?\nWe've decided to use seamless-immutable @ work but we would like to have typings.\nI'm willing to help work on the typings, so if you have any update, don't hesitate to share (gist?)\n. Thanks a lot @jonaskello. I spent all morning battling against those typings and couldn't find a way to re-export a type corresponding to the Immutable object returned by seamless-immutable... just like you said.\nYour comment helped me move forward.\nHere's what I've ended up with:\n```\ndeclare module \"seamless-immutable\" {\n                interface ImmutableCommonMethods{\n                               setIn?(propertyPath: Array, value: any): Immutable;\n                               merge?(part: T): Immutable;\n                }\n            export interface ImmutableObject<T> extends ImmutableCommonMethods<T> {\n                           set(property: string, value: any): Immutable<T>;\n                           setIn(propertyPath:Array<string>, value:any):Immutable<T>;\n\n                           asMutable(): T;\n                           asMutable(opts:AsMutableOptions): T;\n\n                           update(property:string, updaterFunction:(value:any) => any):Immutable<T>;\n                           update(property:string, updaterFunction:(value:any, additionalParameter1:any) => any, arg1:any):Immutable<T>;\n                           update(property:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any) => any, arg1:any, arg2:any):Immutable<T>;\n                           update(property:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any) => any, arg1:any, arg2:any, arg3:any):Immutable<T>;\n                           update(property:string, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any, additionalParameter4:any) => any, arg1:any, arg2:any, arg3:any, arg4:any):Immutable<T>;\n\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any) => any):Immutable<T>;\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any, additionalParameter1:any) => any, arg1:any):Immutable<T>;\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any) => any, arg1:any, arg2:any):Immutable<T>;\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any) => any, arg1:any, arg2:any, arg3:any):Immutable<T>;\n                           updateIn(propertyPath:Array<string>, updaterFunction:(value:any, additionalParameter1:any, additionalParameter2:any, additionalParameter3:any, additionalParameter4:any) => any, arg1:any, arg2:any, arg3:any):Immutable<T>;\n\n                           without(property:string):Immutable<T>;\n                           without(propertyPath:string[]):Immutable<T>;\n                           without(...properties:string[]):Immutable<T>;\n                           without(filter:(value:any, key:string) => boolean):Immutable<T>;\n            }\n\n            export interface ImmutableArray<T> extends ImmutableCommonMethods<T> {\n                           set(index: number, value: any): ImmutableArray<T>;\n                           asMutable(): Array<T>;\n                           asMutable(opts:AsMutableOptions): Array<T>;\n                           asObject(toKeyValue: (item: T) => Array<Array<any>>): ImmutableArray<T>;\n                           flatMap(mapFunction: (item: T) => ImmutableArray<T>): any;\n\n                           // TODO review methods (missing ones for arrays?)\n            }\n\n            interface Options {\n                           prototype?: any;\n            }\n\n            interface AsMutableOptions {\n                           deep: boolean;\n            }\n\n            // an immutable object is both of Type T (i.e., looks like a normal T) and of type Immutable<T>\n            export type Immutable<T> = T & (ImmutableObject<T> | ImmutableArray<T>);\n\n            // TODO it would be ideal to be able to expose that type and have the variable available from client code\n            // couldn't figure out how to do this unfortunately\n            /*\n            export type SeamlessImmutable = {\n                           <T>(obj: T, options?: Options): T & ImmutableObject<T>;\n                           <T>(obj: Array<T>, options?: Options): Array<T> & ImmutableArray<T>;\n                           from:SeamlessImmutable;\n                           isImmutable(target: any): boolean;\n                           ImmutableError(message: string): Error;\n            };\n\n            export const Immutable: SeamlessImmutable;\n            */\n\n            export function from<T>(obj: T, options?: Options): T & ImmutableObject<T>;\n            export function from<T>(obj: Array<T>, options?: Options): Array<T> & ImmutableArray<T>;\n\n            export function isImmutable(target: any): boolean;\n            export function ImmutableError(message: string): Error;\n\n}\n```\nI'll try to take some time and publish those typings as an npm package.\nI also made a \"global\" version for cases where seamless-immutable is loaded as a script tag (i.e., when it attaches Immutable to the window object).\n. The advantage of the above is that in my code I can import the same way you mentionned, but also import the Immutable type separately, which makes for a nicer TS API:\nimport * as SeamlessImmutable from \"seamless-immutable\";\nimport {Immutable} from \"seamless-immutable\";\n...\nconst immutablePerson:Immutable<Person> = SeamlessImmutable.from(new Person());\n...\n. Actually I think typings should be in their own package. That's the way the TypeScript team pushes forward now with TS 2.0+ (see here: https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/)\nThe reason is that people don't necessarily want to release a new version of a library because the typings are incomplete or buggy. I guess there are pros and cons to both approaches\n. @jonaskello might be the latest news, I don't know ^^\n@mnasyrov well I believe in TypeScript so I see its value, but developers of pure JS libs might simply not care enough ^^\n. ",
    "MarkusKramer": "Nice work. @dsebastien could you add your file to tsd/npm so that anyone can use it easily?\n. Nice work. @dsebastien could you add your file to tsd/npm so that anyone can use it easily?\n. ",
    "mnasyrov": "It may be better to include the typings into seamless-immutable package itself (https://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html), thus no external tsd/npm package will be required.\n. @dsebastien I think it is good when something forces authors to keep complete and reliable typings). \n. It may be better to include the typings into seamless-immutable package itself (https://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html), thus no external tsd/npm package will be required.\n. @dsebastien I think it is good when something forces authors to keep complete and reliable typings). \n. ",
    "cvle": "I'm experimenting with the types from @dsebastien.\nI added this definition:\nexport function from<T, U>(obj: Array<T>, options?: Options): Array<T & U> & ImmutableArray<T>;\nThis lets me do the following:\nconst articleList = SeamlessImmutable.from<Article, ImmutableObject<Article>>(new Array<Article>(...articles));\narticleList[0].set(\"title\", \"anotherTitle\");\nWhich is quite handy, otherwise I would need to do some ugly type casting to get the correct type for the elements in the array.\nMaybe the types in ImmutableArray can be more strict like in set(index: number, value: any): ImmutableArray<T>;, my thought was it should be set(index: number, value: T): ImmutableArray<T>;, but I'm a relative new user of this library, so I'm not really sure.\nIt'd be awesome if someone has the time to work on a PR on https://github.com/DefinitelyTyped/DefinitelyTyped.\n. I'm experimenting with the types from @dsebastien.\nI added this definition:\nexport function from<T, U>(obj: Array<T>, options?: Options): Array<T & U> & ImmutableArray<T>;\nThis lets me do the following:\nconst articleList = SeamlessImmutable.from<Article, ImmutableObject<Article>>(new Array<Article>(...articles));\narticleList[0].set(\"title\", \"anotherTitle\");\nWhich is quite handy, otherwise I would need to do some ugly type casting to get the correct type for the elements in the array.\nMaybe the types in ImmutableArray can be more strict like in set(index: number, value: any): ImmutableArray<T>;, my thought was it should be set(index: number, value: T): ImmutableArray<T>;, but I'm a relative new user of this library, so I'm not really sure.\nIt'd be awesome if someone has the time to work on a PR on https://github.com/DefinitelyTyped/DefinitelyTyped.\n. ",
    "alex3165": "I have opened this PR https://github.com/DefinitelyTyped/DefinitelyTyped/pull/11717 from @dsebastien work, I did some questionable choices and I am happy to reply to any questions. I hope it will help :)\n. For information the PR has been merged, feel free to open a new PR on DefinitelyTyped to improve the type definition file in case there are some quirks.\n. If you use typings to manage your type declaration file :\ntypings install dt~seamless-immutable --save --global\nor now with typescript 2 you can use npm to manage the types :\nnpm install --save-dev @types/seamless-immutable\nThen you have to import seamless-immutable like this :\nimport * as SI from 'seamless-immutable';\n. Try:\n// for an object\nSI.from({});\n// for an array\nSI.from([])\n. I have just ported the last type definition file from above to the definitelyTyped registry and cleaned it a bit so I am not too sure about this from choice. It is something that need to be fixed or documented indeed.\n. I have opened this PR https://github.com/DefinitelyTyped/DefinitelyTyped/pull/11717 from @dsebastien work, I did some questionable choices and I am happy to reply to any questions. I hope it will help :)\n. For information the PR has been merged, feel free to open a new PR on DefinitelyTyped to improve the type definition file in case there are some quirks.\n. If you use typings to manage your type declaration file :\ntypings install dt~seamless-immutable --save --global\nor now with typescript 2 you can use npm to manage the types :\nnpm install --save-dev @types/seamless-immutable\nThen you have to import seamless-immutable like this :\nimport * as SI from 'seamless-immutable';\n. Try:\n// for an object\nSI.from({});\n// for an array\nSI.from([])\n. I have just ported the last type definition file from above to the definitelyTyped registry and cleaned it a bit so I am not too sure about this from choice. It is something that need to be fixed or documented indeed.\n. ",
    "cubabit": "How are you supposed to use the type definition in https://github.com/alex3165/DefinitelyTyped/blob/14740e2ee4239622065cbc674d793586f5cf24b7/seamless-immutable/seamless-immutable.d.ts?\nI have tried these:\nimport Immutable from \"seamless-immutable\";\nimport {Immutable} from \"seamless-immutable\";\nimport * as Immutable from \"seamless-immutable\";\nbut neither give me an Immutable function I can use:\nconst state = Immutable({});\nTypeScript says error TS2349: Cannot invoke an expression whose type lacks a call signature.\n. Thanks, but now If I try and do:\nconst initialState = SI.Immutable({});\nI get:\nsrc/reducers/bookings/reducer.ts(10,22): error TS2349: Cannot invoke an expression whose type lacks a call signature.\nsrc/reducers/calendar/reducer.ts(10,25): error TS2339: Property 'Immutable' does not exist on type 'typeof SeamlessImmutable'.\nI thought, looking at the code at https://github.com/rtfeldman/seamless-immutable there should be an Immutable function available?\n. OK great - Thank you! At least I can get moving now! But why does using the typescript definition mean you can't used the documented interface?\n. How are you supposed to use the type definition in https://github.com/alex3165/DefinitelyTyped/blob/14740e2ee4239622065cbc674d793586f5cf24b7/seamless-immutable/seamless-immutable.d.ts?\nI have tried these:\nimport Immutable from \"seamless-immutable\";\nimport {Immutable} from \"seamless-immutable\";\nimport * as Immutable from \"seamless-immutable\";\nbut neither give me an Immutable function I can use:\nconst state = Immutable({});\nTypeScript says error TS2349: Cannot invoke an expression whose type lacks a call signature.\n. Thanks, but now If I try and do:\nconst initialState = SI.Immutable({});\nI get:\nsrc/reducers/bookings/reducer.ts(10,22): error TS2349: Cannot invoke an expression whose type lacks a call signature.\nsrc/reducers/calendar/reducer.ts(10,25): error TS2339: Property 'Immutable' does not exist on type 'typeof SeamlessImmutable'.\nI thought, looking at the code at https://github.com/rtfeldman/seamless-immutable there should be an Immutable function available?\n. OK great - Thank you! At least I can get moving now! But why does using the typescript definition mean you can't used the documented interface?\n. ",
    "draunkin": "@alex3165  I had just installed the definitions from npm install @types/seamless-immutable and I get a different file than that hosted on DefinitelyTyped. It seems the one installed using @types... is out of date as I could not get it to work properly with an error stating the from function was not available. The new definition you have at DefinitelyTyped works because it declares the 'seamless-immutable' module correctly.\nTook me a while to figure out what was going on, not sure the process but maybe you have to update the one installed by @types...\nHope this helps anyone else struggling with it.  Cheers\n. Thanks so much for this.  I was developing some reporting in our application which uses data that is not frequently accessed and only then did I realise this was happening to some of my objects which have since been serialized into the db.\n... well can't reverse time but so glad you've already got a solution for it!\n. @alex3165  I had just installed the definitions from npm install @types/seamless-immutable and I get a different file than that hosted on DefinitelyTyped. It seems the one installed using @types... is out of date as I could not get it to work properly with an error stating the from function was not available. The new definition you have at DefinitelyTyped works because it declares the 'seamless-immutable' module correctly.\nTook me a while to figure out what was going on, not sure the process but maybe you have to update the one installed by @types...\nHope this helps anyone else struggling with it.  Cheers\n. Thanks so much for this.  I was developing some reporting in our application which uses data that is not frequently accessed and only then did I realise this was happening to some of my objects which have since been serialized into the db.\n... well can't reverse time but so glad you've already got a solution for it!\n. ",
    "MichaelTontchev": "@jonaskello readonly is great, but the problem is that it can't be made recursive yet, pending https://github.com/Microsoft/TypeScript/issues/10725\nAs to your library, I haven't used it yet, but it looks nice. I just wish that you could limit the linting rules to certain files: https://github.com/jonaskello/tslint-immutable/issues/25. @jonaskello readonly is great, but the problem is that it can't be made recursive yet, pending https://github.com/Microsoft/TypeScript/issues/10725\nAs to your library, I haven't used it yet, but it looks nice. I just wish that you could limit the linting rules to certain files: https://github.com/jonaskello/tslint-immutable/issues/25. ",
    "babakness": "Commenting to follow this conversation.. Commenting to follow this conversation.. ",
    "toranb": "I ended up writing a new type definition file for seamless-immutable 7 that works well with TypeScript 2.4\nI've had success writing product types like you see below\n```ts\nimport { ImmutableObject } from 'seamless-immutable';\ntype ImmutableState = ImmutableObject & T;\nexport default ((state: ImmutableState, action: Action): ImmutableState => {\n  switch(action.type) {\n    case 'ASSIGN_USER': {\n      return state.merge({number: action.number});\n    }\n    default: {\n      return state || initialState;\n    }\n  }\n});\n```\nFor anyone interested, I threw together a full example app with redux/typescript 2.4/seamless 7.1.2. @Connormiha I'm down to add something for it - my hacking was mostly for methods I was using (if this is something you are interested in providing type defs for I'd be willing to update it). Might ping me on that repo instead to start a thread about it. I'm trying to gauge if this project is truly supported right now or if it's in maintenance mode for the most part. I do see a merge now for Aug but overall it seems like this project isn't being worked on. I've tried to contact @rtfeldman via email/twitter to confirm if he has plans to pass it on or if he is still maintaining it (no word yet)\nAny feedback would be greatly appreciated -thank you in advance . I ended up writing a new type definition file for seamless-immutable 7 that works well with TypeScript 2.4\nI've had success writing product types like you see below\n```ts\nimport { ImmutableObject } from 'seamless-immutable';\ntype ImmutableState = ImmutableObject & T;\nexport default ((state: ImmutableState, action: Action): ImmutableState => {\n  switch(action.type) {\n    case 'ASSIGN_USER': {\n      return state.merge({number: action.number});\n    }\n    default: {\n      return state || initialState;\n    }\n  }\n});\n```\nFor anyone interested, I threw together a full example app with redux/typescript 2.4/seamless 7.1.2. @Connormiha I'm down to add something for it - my hacking was mostly for methods I was using (if this is something you are interested in providing type defs for I'd be willing to update it). Might ping me on that repo instead to start a thread about it. I'm trying to gauge if this project is truly supported right now or if it's in maintenance mode for the most part. I do see a merge now for Aug but overall it seems like this project isn't being worked on. I've tried to contact @rtfeldman via email/twitter to confirm if he has plans to pass it on or if he is still maintaining it (no word yet)\nAny feedback would be greatly appreciated -thank you in advance . ",
    "Connormiha": "@toranb  What about Immutable.static?. @toranb  What about Immutable.static?. ",
    "Poordeveloper": "But a[1] and a['1'] both work, how do you explain?\n. But a[1] and a['1'] both work, how do you explain?\n. ",
    "philippotto": "+1\nWe use seamless-immutable in combination with redux and have some data in typed arrays for which support would be nice. . +1\nWe use seamless-immutable in combination with redux and have some data in typed arrays for which support would be nice. . ",
    "skrat": "This is rather weird, I think seamless-immutable shouldn't be coercing objects with unknown types to either lists or maps. We also need to store typed array in an immutable map but there doesn't seem to be a way.. This is rather weird, I think seamless-immutable shouldn't be coercing objects with unknown types to either lists or maps. We also need to store typed array in an immutable map but there doesn't seem to be a way.. ",
    "Darmody": "Sorry, it's my misunderstand.\n. Sorry, it's my misunderstand.\n. ",
    "MartinSnyder": "\nI believe the question is asking whether there is anything like the Immutable.js cursor library for seamless. https://github.com/facebook/immutable-js/tree/master/contrib/cursor\n\nI believe Issue #18 is relevant.  In it, @rtfeldman says there are no plans for cursors to be part of this library.\n. I just made a gist of a cursor I wrote around seamless-immutable.  Happy to submit a PR or publish an add-on if there is interest, but I don't want to clog the pipes with something that isn't needed.\nIn response to the original question, the top-level (Data) object allows subscribers to invoke \"onChange\" which is then invoked any time the managed data is updated via a cursor.\nhttps://gist.github.com/MartinSnyder/2e7d2ecde16d910f25926fc8f59fe25b\n. I finally got around to doing this. Presenting seamless-immutable-cursor:\nhttps://github.com/MartinSnyder/seamless-immutable-cursor\nVersion 0.1.1 is published to npm:\nhttps://www.npmjs.com/package/seamless-immutable-cursor\n. > I believe the question is asking whether there is anything like the Immutable.js cursor library for seamless. https://github.com/facebook/immutable-js/tree/master/contrib/cursor\nI believe Issue #18 is relevant.  In it, @rtfeldman says there are no plans for cursors to be part of this library.\n. I just made a gist of a cursor I wrote around seamless-immutable.  Happy to submit a PR or publish an add-on if there is interest, but I don't want to clog the pipes with something that isn't needed.\nIn response to the original question, the top-level (Data) object allows subscribers to invoke \"onChange\" which is then invoked any time the managed data is updated via a cursor.\nhttps://gist.github.com/MartinSnyder/2e7d2ecde16d910f25926fc8f59fe25b\n. I finally got around to doing this. Presenting seamless-immutable-cursor:\nhttps://github.com/MartinSnyder/seamless-immutable-cursor\nVersion 0.1.1 is published to npm:\nhttps://www.npmjs.com/package/seamless-immutable-cursor\n. ",
    "meandmax": "This seems to work for us so far but we are not sure if we doing this right. Immutable.js from FB has an existing module declaration but certainly immutable.js is not an option for us ...\nhttps://github.com/TechnologyAdvice/flow-interfaces/blob/master/interfaces/immutable.d.js \n``` js\ndeclare module 'seamless-immutable' {\n  declare class SeamlessImmutable {\n    static (collection: any, prototype?: Object, depth?: number): any,\n    / array functions /\n    flatMap(fn: Function): Array,\n    asObject(fn: Function): Object,\n    asMutable(): Array,\n/* object functions */\nmerge(collection: Array<any> | Object, deep?: Object): Object,\nset(key: string, value: any): Object,\nsetIn(keyPath: Array<string>, value: any): Object,\nupdate(key: string, fn: Function): Object,\nupdateIn(keyPath: Array<string>, fn: Function): Object,\nwithout(fn: Function): Object,\nwithout(keys: Array<string>): Object,\nwithout(...keys: Array<string>): Object,\nasMutable(): Array<any> | Object\n\n}\n  declare var exports: typeof SeamlessImmutable;\n}\n```\n. This seems to work for us so far but we are not sure if we doing this right. Immutable.js from FB has an existing module declaration but certainly immutable.js is not an option for us ...\nhttps://github.com/TechnologyAdvice/flow-interfaces/blob/master/interfaces/immutable.d.js \n``` js\ndeclare module 'seamless-immutable' {\n  declare class SeamlessImmutable {\n    static (collection: any, prototype?: Object, depth?: number): any,\n    / array functions /\n    flatMap(fn: Function): Array,\n    asObject(fn: Function): Object,\n    asMutable(): Array,\n/* object functions */\nmerge(collection: Array<any> | Object, deep?: Object): Object,\nset(key: string, value: any): Object,\nsetIn(keyPath: Array<string>, value: any): Object,\nupdate(key: string, fn: Function): Object,\nupdateIn(keyPath: Array<string>, fn: Function): Object,\nwithout(fn: Function): Object,\nwithout(keys: Array<string>): Object,\nwithout(...keys: Array<string>): Object,\nasMutable(): Array<any> | Object\n\n}\n  declare var exports: typeof SeamlessImmutable;\n}\n```\n. ",
    "grabbou": "Hm, here's what I came up with so far (to cover only few methods I had):\njs\ndeclare class ImmutableArray<T> extends Array {\n  concat(item: (T | Array<T>)): ImmutableArray<T>;\n  slice(idx: number, len: ?number): ImmutableArray<T>;\n  updateIn<U>(keyPath: Array<string | number>, func: (item: U) => U): ImmutableArray<T>;\n  update(key: (string | number), func: (item: T) => T): ImmutableArray<T>;\n}\nso that:\njs\nconst arr: ImmutableArray<string> = Immutable(['a', 'b']);\narr.slice(0).concat('c').concat(['d']).update(2, s => s); // no errors here\nworks.\nMade them in like 5 minutes, someone might find it useful to implement proper e2e declarations, just like for lodash. \nI might try to convert that properly to declaration and send over a PR or just include as a 3rd party package. Would you be interested in helping out @meandmax?\n. Hm, here's what I came up with so far (to cover only few methods I had):\njs\ndeclare class ImmutableArray<T> extends Array {\n  concat(item: (T | Array<T>)): ImmutableArray<T>;\n  slice(idx: number, len: ?number): ImmutableArray<T>;\n  updateIn<U>(keyPath: Array<string | number>, func: (item: U) => U): ImmutableArray<T>;\n  update(key: (string | number), func: (item: T) => T): ImmutableArray<T>;\n}\nso that:\njs\nconst arr: ImmutableArray<string> = Immutable(['a', 'b']);\narr.slice(0).concat('c').concat(['d']).update(2, s => s); // no errors here\nworks.\nMade them in like 5 minutes, someone might find it useful to implement proper e2e declarations, just like for lodash. \nI might try to convert that properly to declaration and send over a PR or just include as a 3rd party package. Would you be interested in helping out @meandmax?\n. ",
    "ajhyndman": "@meandmax Do you mind if I use your definitions as the basis of a PR against seamless-immutable?  I think it would make seamless-immutable more attractive if it supported flow out of the box.\n. I have played around with this a bit more.  I have had some success with an intersection-based declaration.\n``` js\n// libs/seamless-immutable.d.js\ndeclare module 'seamless-immutable' {\n  declare type Immutable> = T & {\n    // Array methods\n    flatMap(fn: Function): Array;\n    asObject(fn: Function): Object;\n    asMutable(): Array;\n    // Object methods\n    merge(collection: Array | Object, deep?: Object): Object;\n    set(key: string, value: any): Object;\n    setIn(keyPath: Array, value: any): Object;\n    update(key: string, fn: Function): Object;\n    updateIn(keyPath: Array, fn: Function): Object;\n    without(fn: Function): Object;\n    without(keys: Array): Object;\n    without(...keys: Array): Object;\n    asMutable(): Array | Object;\n  };\ndeclare function from> (spec: T): Immutable;\ndeclare type Default = {\n    from: typeof from;\n    isImmutable: (x: *) => boolean\n  };\ndeclare module.exports: Default;\n}\n```\n. Hey @MoeSattler,\nYou should be able to take one of these declarations, copy it into a file (named something like seamless-immutable.flow.js) and drop it into a flow/libs/ (or any other name) directory inside your project.  You can then add a reference to that directory under the [libs] heading in your .flowconfig file.\nIf I didn't explain that well enough, there are full directions for adding declaration files here:\nhttps://flowtype.org/docs/declarations.html#pointing-your-project-to-declarations\n. @MoeSattler Calling Immutable.from() on your data should now return an instance of an Immutable<-your-object-type-> which has methods available on it.\nThat said, I'm not a huge fan of my declaration.  I've recently been experimenting with pretending the seamless-immutable methods don't exist and using another library like Ramda to do my data manipulation.\n. You could implement something a bit cheaper, yep!  I haven't bothered extracting the exception handling and recursive logic yet (or looking for something similar).\nSeamless-immutable is a pretty small, single file anyway.  If you find something great, I'd be keen to hear about it.\n. Oh, I like the list of similar libraries they link in the readme, too.  Thanks!\n. This is the latest iteration of my version:\nhttps://github.com/ajhyndman/fantasia/blob/master/flow/libs/seamless-immutable.d.js\nFeel free to use it to make a PR against the flow-typed repo.. @azundo Cool!\nHave you considered trying to upgrade from the intersection type to a type spread?  That syntax wasn't present in Flow at the time I took a stab at this before, but should model what's happening a bit better.\ni.e.\njavascript\n  declare export type Immutable<T: fromType> = {\n    ...T;\n    // Array methods\n    flatMap(fn: Function): Array<any>;\n    // .... I'm also working with Draft.js and have the same issue!\nI wonder if a solution to #142 might be able to accomodate this use case too, via a slight API tweak.\n. From my uninformed perspective, it looks like the real culprit here is that the Immutable.from factory is clobbering any pre-existing prototypes on objects we are freezing at any level of nesting.\nI assume that the motivation is to remove any unexpected avenues through which mutation could sneak in.  This seems sensible in most cases, but is destructive to some third-party APIs.\nI notice that the seamless-immutable API accepts a custom prototype in it's options object for this purpose.  I wonder if instead of accepting a single prototype to apply to everything, some of these issues might go away if the API accepts a function which can accept the pre-existing prototype and discard, preserve or augment it?\nThis seems like a reasonably accessible and non-invasive escape hatch to expose.  Any thoughts?\nhttps://github.com/rtfeldman/seamless-immutable/compare/master...ajhyndman:transform-prototype\n. @meandmax Do you mind if I use your definitions as the basis of a PR against seamless-immutable?  I think it would make seamless-immutable more attractive if it supported flow out of the box.\n. I have played around with this a bit more.  I have had some success with an intersection-based declaration.\n``` js\n// libs/seamless-immutable.d.js\ndeclare module 'seamless-immutable' {\n  declare type Immutable> = T & {\n    // Array methods\n    flatMap(fn: Function): Array;\n    asObject(fn: Function): Object;\n    asMutable(): Array;\n    // Object methods\n    merge(collection: Array | Object, deep?: Object): Object;\n    set(key: string, value: any): Object;\n    setIn(keyPath: Array, value: any): Object;\n    update(key: string, fn: Function): Object;\n    updateIn(keyPath: Array, fn: Function): Object;\n    without(fn: Function): Object;\n    without(keys: Array): Object;\n    without(...keys: Array): Object;\n    asMutable(): Array | Object;\n  };\ndeclare function from> (spec: T): Immutable;\ndeclare type Default = {\n    from: typeof from;\n    isImmutable: (x: *) => boolean\n  };\ndeclare module.exports: Default;\n}\n```\n. Hey @MoeSattler,\nYou should be able to take one of these declarations, copy it into a file (named something like seamless-immutable.flow.js) and drop it into a flow/libs/ (or any other name) directory inside your project.  You can then add a reference to that directory under the [libs] heading in your .flowconfig file.\nIf I didn't explain that well enough, there are full directions for adding declaration files here:\nhttps://flowtype.org/docs/declarations.html#pointing-your-project-to-declarations\n. @MoeSattler Calling Immutable.from() on your data should now return an instance of an Immutable<-your-object-type-> which has methods available on it.\nThat said, I'm not a huge fan of my declaration.  I've recently been experimenting with pretending the seamless-immutable methods don't exist and using another library like Ramda to do my data manipulation.\n. You could implement something a bit cheaper, yep!  I haven't bothered extracting the exception handling and recursive logic yet (or looking for something similar).\nSeamless-immutable is a pretty small, single file anyway.  If you find something great, I'd be keen to hear about it.\n. Oh, I like the list of similar libraries they link in the readme, too.  Thanks!\n. This is the latest iteration of my version:\nhttps://github.com/ajhyndman/fantasia/blob/master/flow/libs/seamless-immutable.d.js\nFeel free to use it to make a PR against the flow-typed repo.. @azundo Cool!\nHave you considered trying to upgrade from the intersection type to a type spread?  That syntax wasn't present in Flow at the time I took a stab at this before, but should model what's happening a bit better.\ni.e.\njavascript\n  declare export type Immutable<T: fromType> = {\n    ...T;\n    // Array methods\n    flatMap(fn: Function): Array<any>;\n    // .... I'm also working with Draft.js and have the same issue!\nI wonder if a solution to #142 might be able to accomodate this use case too, via a slight API tweak.\n. From my uninformed perspective, it looks like the real culprit here is that the Immutable.from factory is clobbering any pre-existing prototypes on objects we are freezing at any level of nesting.\nI assume that the motivation is to remove any unexpected avenues through which mutation could sneak in.  This seems sensible in most cases, but is destructive to some third-party APIs.\nI notice that the seamless-immutable API accepts a custom prototype in it's options object for this purpose.  I wonder if instead of accepting a single prototype to apply to everything, some of these issues might go away if the API accepts a function which can accept the pre-existing prototype and discard, preserve or augment it?\nThis seems like a reasonably accessible and non-invasive escape hatch to expose.  Any thoughts?\nhttps://github.com/rtfeldman/seamless-immutable/compare/master...ajhyndman:transform-prototype\n. ",
    "ghost": "@grabbou @ajhyndman \nCan you explain to a newbie how to use this?\nI am completely new to flow, and I am unfortunately blocked by seamless-immutable. I really just want seamless tow work with flow.\n. @ajhyndman \nThanks! done that.\nSo how do I declare my data as Immutable? Just adding it to [libs] doesn't seem to fix it (used your solution)\n. @ajhyndman \nCouldn't you in that case just use Object.freeze() instead of seamless?\n. @ajhyndman https://github.com/scottcorgan/immu\n. @saivann would the config be opt-in or opt-out?. Love this! Thanks so much!. @grabbou @ajhyndman \nCan you explain to a newbie how to use this?\nI am completely new to flow, and I am unfortunately blocked by seamless-immutable. I really just want seamless tow work with flow.\n. @ajhyndman \nThanks! done that.\nSo how do I declare my data as Immutable? Just adding it to [libs] doesn't seem to fix it (used your solution)\n. @ajhyndman \nCouldn't you in that case just use Object.freeze() instead of seamless?\n. @ajhyndman https://github.com/scottcorgan/immu\n. @saivann would the config be opt-in or opt-out?. Love this! Thanks so much!. ",
    "rgbkrk": "Would anyone be interested in contributing their definitions to https://github.com/flowtype/flow-typed?. Would anyone be interested in contributing their definitions to https://github.com/flowtype/flow-typed?. ",
    "KROT47": "With ES modules support:\n```js\n/ @flow /\ndeclare module 'seamless-immutable' {\n  declare type fromType = Object | Array<*>;\ndeclare export type Immutable = T & {\n    // Array methods\n    flatMap(fn: Function): Array;\n    asObject(fn: Function): Object;\n    asMutable(): Array;\n    // Object methods\n    merge(collection: Array | Object, deep?: Object): Object;\n    set(key: string, value: any): Object;\n    setIn(keyPath: Array, value: any): Object;\n    update(key: string, fn: Function): Object;\n    updateIn(keyPath: Array, fn: Function): Object;\n    without(fn: Function): Object;\n    without(keys: Array): Object;\n    without(...keys: Array): Object;\n    asMutable(): Array | Object;\n  };\ndeclare export function from (spec: T): Immutable;\ndeclare export function isImmutable(x: *): boolean;\ndeclare export default typeof from;\n}\n```. With ES modules support:\n```js\n/ @flow /\ndeclare module 'seamless-immutable' {\n  declare type fromType = Object | Array<*>;\ndeclare export type Immutable = T & {\n    // Array methods\n    flatMap(fn: Function): Array;\n    asObject(fn: Function): Object;\n    asMutable(): Array;\n    // Object methods\n    merge(collection: Array | Object, deep?: Object): Object;\n    set(key: string, value: any): Object;\n    setIn(keyPath: Array, value: any): Object;\n    update(key: string, fn: Function): Object;\n    updateIn(keyPath: Array, fn: Function): Object;\n    without(fn: Function): Object;\n    without(keys: Array): Object;\n    without(...keys: Array): Object;\n    asMutable(): Array | Object;\n  };\ndeclare export function from (spec: T): Immutable;\ndeclare export function isImmutable(x: *): boolean;\ndeclare export default typeof from;\n}\n```. ",
    "azundo": "I've been trying to improve upon these a bit to allow type aliasing of the immutable object itself for things like redux state and to restrict inputs to merge,update,without` to valid objects/keys. Still very much a work in progress but this improves things for simple objects:\n```\n/ @flow /\ndeclare module 'seamless-immutable' {\n  declare type fromType = Object | Array<*>;\n  declare export type Immutable = T & {\n    // Array methods\n    flatMap(fn: Function): Array;\n    asObject(fn: Function): Object;\n    asMutable(): Array;\n    // Object methods\n    merge(collection: Array<$Shape> | $Shape, deep?: Object): Object;\n    set(key: $Keys, value: any): Object;\n    setIn(keyPath: Array, value: any): Object;\n    update(key: $Keys, fn: Function): Object;\n    updateIn(keyPath: Array, fn: Function): Object;\n    without(fn: Function): Object;\n    without(keys: Array<$Keys>): Object;\n    without(...keys: Array<$Keys>): Object;\n    asMutable(): Array | Object;\n  };\ndeclare export function from (spec: T): Immutable;\ndeclare export function isImmutable(x: *): boolean;\ndeclare export default {\n    from(spec: T): Immutable,\n    isImmutable(x: *): boolean,\n  };\n}\n```\nUsage is something like:\n```\nimport Immutable from 'seamless-immutable';\nimport type {Immutable as ImmutableType} from 'seamless-immutable';\ntype MyState = {\n  requiredProp: string,\n  optionalProp?: number,\n};\nconst immutableState: ImmutableType = Immutable.from(\n  ({requiredProp: \"foo\"}: MyState)\n);\nimmutableState.merge({optionalProp: 42}); // no error\nimmutableState.merge({optionalProp: \"42\"}); // ERROR\nimmutableState.merge({badProp: \"other\"}); // ERROR\nimmutableState.set('badProp', 42); // ERROR\n```\nStill has many, many shortcomings, the updateIn or setIn keypaths are not validated, nor are the values passed to set or returned from the update function. Removing required properties using without is also possible  - would likely have to two generic types similar to Props and RequiredProps for that to work.. @ajhyndman Ah, yep, that makes sense. Unfortunately it seems like $Shape doesn't do deep matching so my updates are less useful than I was hoping as type checking fails for deep merging: https://github.com/facebook/flow/issues/2542. Awesome, thanks @chrisbull will check it out. The operation I couldn't get to typecheck was deep merging. Something like:\n```\ntype NestedState = {\n  propA: string,\n  propB: string,\n}\ntype TopLevelState = {\n  otherProp: string,\n  nested: NestedState,\n}\nconst state = ImmutableType = Immutable.from({\n  otherProp: 'bar',\n  nested: {\n    propA: 'A',\n    propB: 'B',\n  },\n});\nstate.merge({nested: {propB: 'C'}}, {deep: true}); // should pass\nstate.merge({nested: {propC: 'C'}}, {deep: true}); // should fail\n```\nHad a hard time finding anything that would meet both of those conditions for arbitrarily nested states.\n. I've been trying to improve upon these a bit to allow type aliasing of the immutable object itself for things like redux state and to restrict inputs to merge,update,without` to valid objects/keys. Still very much a work in progress but this improves things for simple objects:\n```\n/ @flow /\ndeclare module 'seamless-immutable' {\n  declare type fromType = Object | Array<*>;\n  declare export type Immutable = T & {\n    // Array methods\n    flatMap(fn: Function): Array;\n    asObject(fn: Function): Object;\n    asMutable(): Array;\n    // Object methods\n    merge(collection: Array<$Shape> | $Shape, deep?: Object): Object;\n    set(key: $Keys, value: any): Object;\n    setIn(keyPath: Array, value: any): Object;\n    update(key: $Keys, fn: Function): Object;\n    updateIn(keyPath: Array, fn: Function): Object;\n    without(fn: Function): Object;\n    without(keys: Array<$Keys>): Object;\n    without(...keys: Array<$Keys>): Object;\n    asMutable(): Array | Object;\n  };\ndeclare export function from (spec: T): Immutable;\ndeclare export function isImmutable(x: *): boolean;\ndeclare export default {\n    from(spec: T): Immutable,\n    isImmutable(x: *): boolean,\n  };\n}\n```\nUsage is something like:\n```\nimport Immutable from 'seamless-immutable';\nimport type {Immutable as ImmutableType} from 'seamless-immutable';\ntype MyState = {\n  requiredProp: string,\n  optionalProp?: number,\n};\nconst immutableState: ImmutableType = Immutable.from(\n  ({requiredProp: \"foo\"}: MyState)\n);\nimmutableState.merge({optionalProp: 42}); // no error\nimmutableState.merge({optionalProp: \"42\"}); // ERROR\nimmutableState.merge({badProp: \"other\"}); // ERROR\nimmutableState.set('badProp', 42); // ERROR\n```\nStill has many, many shortcomings, the updateIn or setIn keypaths are not validated, nor are the values passed to set or returned from the update function. Removing required properties using without is also possible  - would likely have to two generic types similar to Props and RequiredProps for that to work.. @ajhyndman Ah, yep, that makes sense. Unfortunately it seems like $Shape doesn't do deep matching so my updates are less useful than I was hoping as type checking fails for deep merging: https://github.com/facebook/flow/issues/2542. Awesome, thanks @chrisbull will check it out. The operation I couldn't get to typecheck was deep merging. Something like:\n```\ntype NestedState = {\n  propA: string,\n  propB: string,\n}\ntype TopLevelState = {\n  otherProp: string,\n  nested: NestedState,\n}\nconst state = ImmutableType = Immutable.from({\n  otherProp: 'bar',\n  nested: {\n    propA: 'A',\n    propB: 'B',\n  },\n});\nstate.merge({nested: {propB: 'C'}}, {deep: true}); // should pass\nstate.merge({nested: {propC: 'C'}}, {deep: true}); // should fail\n```\nHad a hard time finding anything that would meet both of those conditions for arbitrarily nested states.\n. ",
    "chrisbull": "@azundo Found this...\nhttps://gist.github.com/mizchi/3054bca701dff4b5e28efd9133c66818\nseems to be working great for me thus far.\n```\nimport Immutable, { type Immutable as ImmutableType } from 'seamless-immutable'\ntype LoginState = {\n  authToken: string,\n  error: any,\n  fetching: boolean,\n  loading: boolean,\n}\ntype _LoginState = ImmutableType\nconst INITIAL_STATE: _LoginState = Immutable({\n  authToken: '',\n  error: null,\n  fetching: false,\n  loading: false,\n})\nexport const request = (state: _LoginState): _LoginState =>\n  state.merge({ fetching: true })\n```\n. @azundo Found this...\nhttps://gist.github.com/mizchi/3054bca701dff4b5e28efd9133c66818\nseems to be working great for me thus far.\n```\nimport Immutable, { type Immutable as ImmutableType } from 'seamless-immutable'\ntype LoginState = {\n  authToken: string,\n  error: any,\n  fetching: boolean,\n  loading: boolean,\n}\ntype _LoginState = ImmutableType\nconst INITIAL_STATE: _LoginState = Immutable({\n  authToken: '',\n  error: null,\n  fetching: false,\n  loading: false,\n})\nexport const request = (state: _LoginState): _LoginState =>\n  state.merge({ fetching: true })\n```\n. ",
    "akread": "I tried out some of the example type definitions here but none of them seem to work properly for arrays. Is no one using seamless immutable for arrays as well?\nI'm working on some more advanced typing for a project now and will share when I get further along.. I tried out some of the example type definitions here but none of them seem to work properly for arrays. Is no one using seamless immutable for arrays as well?\nI'm working on some more advanced typing for a project now and will share when I get further along.. ",
    "ericclemmons": "I'm curious about this as well.  It just came up as we were looking to leverage this project within our Redux reducers.\n. I wish dot-delimited keys worked to have something like this:\njs\nstate.deepMerge({\n  \"attr1\": val,\n  \"attr2\": undefined,\n  \"some.deep.attr\": { otherVal },\n  \"some.other.deep\": \"awwww snap!\",\n});\nThat's what I dig about selectn, but that's just a selector lib.\n. Work is being done in #126...\n. However, new Immutable(...) would also satisfy this rule, but would fail 4 tests:\n2104 passing (8s)\n  4 failing\nWhat would you prefer?  Immutable.from or supporting instantiation via new Immutable?\n. @rtfeldman I agree.  I'll post up more info. I'm a fan of new Immutable  personally, but I know some people are completely anti-instantiation.  But those people aren't the ones with the new-cap rule ;)\n. Replacing the tests to use new Immutable yields:\n```\n  2104 passing (9s)\n  4 failing\n1) Development build ImmutableArray returns only immutables when you call its reduce() method:\n  AssertionError: expected '{}' to equal '0.10615249630063772'\n  + expected - actual\n\n  -{}\n  +0.10615249630063772\n\n  at Function.assert.strictEqual (node_modules/chai/lib/chai/interface/assert.js:178:32)\n  at assertJsonEqual (test/TestUtils.js:13:12)\n  at Object.assertImmutable (test/TestUtils.js:22:5)\n  at Function.<anonymous> (test/ImmutableArray/test-compat.js:179:19)\n  at Function.<anonymous> (test/TestUtils.js:121:18)\n  at check (test/TestUtils.js:103:13)\n  at test/TestUtils.js:117:7\n  at Context.<anonymous> (test/ImmutableArray/test-compat.js:177:7)\n\n2) Development build ImmutableArray returns only immutables when you call its reduceRight() method:\n  AssertionError: expected '{}' to equal '0.8079638944473118'\n  + expected - actual\n\n  -{}\n  +0.8079638944473118\n\n  at Function.assert.strictEqual (node_modules/chai/lib/chai/interface/assert.js:178:32)\n  at assertJsonEqual (test/TestUtils.js:13:12)\n  at Object.assertImmutable (test/TestUtils.js:22:5)\n  at Function.<anonymous> (test/ImmutableArray/test-compat.js:179:19)\n  at Function.<anonymous> (test/TestUtils.js:121:18)\n  at check (test/TestUtils.js:103:13)\n  at test/TestUtils.js:117:7\n  at Context.<anonymous> (test/ImmutableArray/test-compat.js:177:7)\n\n3) Production build ImmutableArray returns only immutables when you call its reduce() method:\n  AssertionError: expected '{}' to equal 'false'\n  + expected - actual\n\n  -{}\n  +false\n\n  at Function.assert.strictEqual (node_modules/chai/lib/chai/interface/assert.js:178:32)\n  at assertJsonEqual (test/TestUtils.js:13:12)\n  at Object.assertImmutable (test/TestUtils.js:22:5)\n  at Function.<anonymous> (test/ImmutableArray/test-compat.js:179:19)\n  at Function.<anonymous> (test/TestUtils.js:121:18)\n  at check (test/TestUtils.js:103:13)\n  at test/TestUtils.js:117:7\n  at Context.<anonymous> (test/ImmutableArray/test-compat.js:177:7)\n\n4) Production build ImmutableArray returns only immutables when you call its reduceRight() method:\n  AssertionError: expected '{}' to equal '\"\"'\n  + expected - actual\n\n  -{}\n  +\"\"\n\n  at Function.assert.strictEqual (node_modules/chai/lib/chai/interface/assert.js:178:32)\n  at assertJsonEqual (test/TestUtils.js:13:12)\n  at Object.assertImmutable (test/TestUtils.js:22:5)\n  at Function.<anonymous> (test/ImmutableArray/test-compat.js:179:19)\n  at Function.<anonymous> (test/TestUtils.js:121:18)\n  at check (test/TestUtils.js:103:13)\n  at test/TestUtils.js:117:7\n  at Context.<anonymous> (test/ImmutableArray/test-compat.js:177:7)\n\n```\nFrom what I can tell it's the nonMutatingArrayMethods\n. Oh right!  Travis is failing do to the Zuul testing (likely because my repo doesn't have the env vars yours does for testing).\nLet me know what else you'd like @rtfeldman :)\n. @rtfeldman Let me know if you'd like any other changes!\n\nhttps://github.com/ericclemmons/seamless-immutable/blob/123-from/README.md#immutablefrom \n. I'm curious about this as well.  It just came up as we were looking to leverage this project within our Redux reducers.\n. I wish dot-delimited keys worked to have something like this:\n\njs\nstate.deepMerge({\n  \"attr1\": val,\n  \"attr2\": undefined,\n  \"some.deep.attr\": { otherVal },\n  \"some.other.deep\": \"awwww snap!\",\n});\nThat's what I dig about selectn, but that's just a selector lib.\n. Work is being done in #126...\n. However, new Immutable(...) would also satisfy this rule, but would fail 4 tests:\n2104 passing (8s)\n  4 failing\nWhat would you prefer?  Immutable.from or supporting instantiation via new Immutable?\n. @rtfeldman I agree.  I'll post up more info. I'm a fan of new Immutable  personally, but I know some people are completely anti-instantiation.  But those people aren't the ones with the new-cap rule ;)\n. Replacing the tests to use new Immutable yields:\n```\n  2104 passing (9s)\n  4 failing\n1) Development build ImmutableArray returns only immutables when you call its reduce() method:\n  AssertionError: expected '{}' to equal '0.10615249630063772'\n  + expected - actual\n\n  -{}\n  +0.10615249630063772\n\n  at Function.assert.strictEqual (node_modules/chai/lib/chai/interface/assert.js:178:32)\n  at assertJsonEqual (test/TestUtils.js:13:12)\n  at Object.assertImmutable (test/TestUtils.js:22:5)\n  at Function.<anonymous> (test/ImmutableArray/test-compat.js:179:19)\n  at Function.<anonymous> (test/TestUtils.js:121:18)\n  at check (test/TestUtils.js:103:13)\n  at test/TestUtils.js:117:7\n  at Context.<anonymous> (test/ImmutableArray/test-compat.js:177:7)\n\n2) Development build ImmutableArray returns only immutables when you call its reduceRight() method:\n  AssertionError: expected '{}' to equal '0.8079638944473118'\n  + expected - actual\n\n  -{}\n  +0.8079638944473118\n\n  at Function.assert.strictEqual (node_modules/chai/lib/chai/interface/assert.js:178:32)\n  at assertJsonEqual (test/TestUtils.js:13:12)\n  at Object.assertImmutable (test/TestUtils.js:22:5)\n  at Function.<anonymous> (test/ImmutableArray/test-compat.js:179:19)\n  at Function.<anonymous> (test/TestUtils.js:121:18)\n  at check (test/TestUtils.js:103:13)\n  at test/TestUtils.js:117:7\n  at Context.<anonymous> (test/ImmutableArray/test-compat.js:177:7)\n\n3) Production build ImmutableArray returns only immutables when you call its reduce() method:\n  AssertionError: expected '{}' to equal 'false'\n  + expected - actual\n\n  -{}\n  +false\n\n  at Function.assert.strictEqual (node_modules/chai/lib/chai/interface/assert.js:178:32)\n  at assertJsonEqual (test/TestUtils.js:13:12)\n  at Object.assertImmutable (test/TestUtils.js:22:5)\n  at Function.<anonymous> (test/ImmutableArray/test-compat.js:179:19)\n  at Function.<anonymous> (test/TestUtils.js:121:18)\n  at check (test/TestUtils.js:103:13)\n  at test/TestUtils.js:117:7\n  at Context.<anonymous> (test/ImmutableArray/test-compat.js:177:7)\n\n4) Production build ImmutableArray returns only immutables when you call its reduceRight() method:\n  AssertionError: expected '{}' to equal '\"\"'\n  + expected - actual\n\n  -{}\n  +\"\"\n\n  at Function.assert.strictEqual (node_modules/chai/lib/chai/interface/assert.js:178:32)\n  at assertJsonEqual (test/TestUtils.js:13:12)\n  at Object.assertImmutable (test/TestUtils.js:22:5)\n  at Function.<anonymous> (test/ImmutableArray/test-compat.js:179:19)\n  at Function.<anonymous> (test/TestUtils.js:121:18)\n  at check (test/TestUtils.js:103:13)\n  at test/TestUtils.js:117:7\n  at Context.<anonymous> (test/ImmutableArray/test-compat.js:177:7)\n\n```\nFrom what I can tell it's the nonMutatingArrayMethods\n. Oh right!  Travis is failing do to the Zuul testing (likely because my repo doesn't have the env vars yours does for testing).\nLet me know what else you'd like @rtfeldman :)\n. @rtfeldman Let me know if you'd like any other changes!\n\nhttps://github.com/ericclemmons/seamless-immutable/blob/123-from/README.md#immutablefrom \n. \n",
    "krzysztofpniak": "@jeffbski the origin of immutable data structures is in functional programming paradigm. The whole thing is about not writing mutable code. You can check good functional languages like haskell, inside them there are no things like mutable structures.\nIn my opinion multiple setIn / updateIn is the way to go, but the users of the library and its author should be sure that this way is implemented with best performance as it can be(or close to this ;) ).\nSide note:\nseamless-immutable adds its functionality as instance methods. More functional way is to have it as static functions in module scope. Good place to have a look is lodash/fp.\nThat way it could look like:\nconst modifyX = flowRight([\n    setIn(['a, 'b'], 1),\n    setIn([['c', 'd'], 2])\n]);\nconst newState = modifyX(oldState);\n. @jeffbski the origin of immutable data structures is in functional programming paradigm. The whole thing is about not writing mutable code. You can check good functional languages like haskell, inside them there are no things like mutable structures.\nIn my opinion multiple setIn / updateIn is the way to go, but the users of the library and its author should be sure that this way is implemented with best performance as it can be(or close to this ;) ).\nSide note:\nseamless-immutable adds its functionality as instance methods. More functional way is to have it as static functions in module scope. Good place to have a look is lodash/fp.\nThat way it could look like:\nconst modifyX = flowRight([\n    setIn(['a, 'b'], 1),\n    setIn([['c', 'd'], 2])\n]);\nconst newState = modifyX(oldState);\n. ",
    "forty2": "~~I would also find this useful, so I took a shot at it over here: https://github.com/forty2/seamless-immutable/tree/child-prototypes~~\n~~It seems to be working for me, and all tests pass (including the one I added for the new behavior).~~\n~~If @rtfeldman agrees this is a good idea, I'll open a pull request.~~\n~~Edit: it's more difficult than I originally thought -- it doesn't do the right thing after calling set.  I'll see what I can do about that...~~\nEdit 2: After a few hours of playing with this, I'm no longer convinced it's a good idea.  So, yeah, basically pretend I wasn't here... :wink: \n. ~~I would also find this useful, so I took a shot at it over here: https://github.com/forty2/seamless-immutable/tree/child-prototypes~~\n~~It seems to be working for me, and all tests pass (including the one I added for the new behavior).~~\n~~If @rtfeldman agrees this is a good idea, I'll open a pull request.~~\n~~Edit: it's more difficult than I originally thought -- it doesn't do the right thing after calling set.  I'll see what I can do about that...~~\nEdit 2: After a few hours of playing with this, I'm no longer convinced it's a good idea.  So, yeah, basically pretend I wasn't here... :wink: \n. ",
    "Snowshield": "I develop a simulation library.\nIt uses a single state to perform simulation and a set of saved immutables states.\nSo it will need two features.\n1. Call methods of immutable objects and its properties to analize saved states.\n2. Make saved state mutable to perform simulations with it.\nPlus there is non-obvious behavior:\nclass A {}\n  class B {\n    constructor(){\n      this._prop = new A;\n    }\n  }\n  let b       = new B,\n      bClone  = Immutable(b).asMutable(),\n      bPropConstr       = b._prop.constructor,\n      bClonePropConstr  = bClone._prop.constructor,\n      equal   = bPropConstr === bClonePropConstr;\n  console.log(equal); // false\n. > Why do those need to be methods? Why not implement them as standalone functions that accept the immutable data as arguments?\nThese methods can be not pure, use another methods of the object and methods from parent class etc. By skipping prototypes all inner logic turns off. So we should work with object like with json and not like with class instance.\n. Argument object may all propetiies to work properly.\nSecond way is to clone it for N depth, delete props and send cloned to Immutable.\nBut its not equal if object has depth L>N.\n. I develop a simulation library.\nIt uses a single state to perform simulation and a set of saved immutables states.\nSo it will need two features.\n1. Call methods of immutable objects and its properties to analize saved states.\n2. Make saved state mutable to perform simulations with it.\nPlus there is non-obvious behavior:\nclass A {}\n  class B {\n    constructor(){\n      this._prop = new A;\n    }\n  }\n  let b       = new B,\n      bClone  = Immutable(b).asMutable(),\n      bPropConstr       = b._prop.constructor,\n      bClonePropConstr  = bClone._prop.constructor,\n      equal   = bPropConstr === bClonePropConstr;\n  console.log(equal); // false\n. > Why do those need to be methods? Why not implement them as standalone functions that accept the immutable data as arguments?\nThese methods can be not pure, use another methods of the object and methods from parent class etc. By skipping prototypes all inner logic turns off. So we should work with object like with json and not like with class instance.\n. Argument object may all propetiies to work properly.\nSecond way is to clone it for N depth, delete props and send cloned to Immutable.\nBut its not equal if object has depth L>N.\n. ",
    "guigrpa": "My benchmark code is here: https://github.com/guigrpa/timm/blob/master/tools/benchmarks.js\nIn principle I'm using the Production build, so I was also surprised by the results, but they seem to be consistent in Windows and OS X. I don't know the reason for the slow array results.\nOf course, if the benchmarks are wrong I will publish the updated results!\n. My benchmark code is here: https://github.com/guigrpa/timm/blob/master/tools/benchmarks.js\nIn principle I'm using the Production build, so I was also surprised by the results, but they seem to be consistent in Windows and OS X. I don't know the reason for the slow array results.\nOf course, if the benchmarks are wrong I will publish the updated results!\n. ",
    "ronniegong": "so, is seamless-immutable really that slow?. so, is seamless-immutable really that slow?. ",
    "kalafut": "OK, I'll work on it.\n. OK, I'll work on it.\n. ",
    "mariusk": "I'm late to the party, but I just migrated a code base from immutable.js to this and was immediately hit by one member deep in a object hierarchy named set.  On the one hand, migration was easy as some of the common API members have identical names and signatures as immutable.js (setIn), but unless anybody else have better ideas I would suggest some unlikely prefix or postfix for all method names or similar (e.g. setInImm, imSetIn or something like that).\n. I'm late to the party, but I just migrated a code base from immutable.js to this and was immediately hit by one member deep in a object hierarchy named set.  On the one hand, migration was easy as some of the common API members have identical names and signatures as immutable.js (setIn), but unless anybody else have better ideas I would suggest some unlikely prefix or postfix for all method names or similar (e.g. setInImm, imSetIn or something like that).\n. ",
    "suchipi": "Ran into this same issue today (with update). It'd be nice if we could do:\n``` js\nimport Immutable, { merge } from \"seamless-immutable\";\nlet options = Immutable({ merge: \"true\" });\noptions = merge(options, { something: \"else\" });\nconsole.log(options); // { merge: true, something: \"else\" }\n```\n. Does #158 actually fix it? Just adding static methods won't prevent name collision from the instance methods that are also still present. The collision won't be truly fixed until the instance methods are also removed, which would be a breaking change (but a welcome one, in my opinion).\n. To remain completely backwards compatible (\"bugwards compatible\"), the second item in your summary would need to be reverted to the old behavior; for users who need a workaround for data loss, I think the static methods should be recommended instead (or a config key could be added to prioritize user data instead of methods).\nEven though prioritizing user data over instance methods is a nicer API in an ideal world... maintaining backwards compatibility and avoiding a major version bump are important from a package maintainer's perspective, too.. Ran into this same issue today (with update). It'd be nice if we could do:\n``` js\nimport Immutable, { merge } from \"seamless-immutable\";\nlet options = Immutable({ merge: \"true\" });\noptions = merge(options, { something: \"else\" });\nconsole.log(options); // { merge: true, something: \"else\" }\n```\n. Does #158 actually fix it? Just adding static methods won't prevent name collision from the instance methods that are also still present. The collision won't be truly fixed until the instance methods are also removed, which would be a breaking change (but a welcome one, in my opinion).\n. To remain completely backwards compatible (\"bugwards compatible\"), the second item in your summary would need to be reverted to the old behavior; for users who need a workaround for data loss, I think the static methods should be recommended instead (or a config key could be added to prioritize user data instead of methods).\nEven though prioritizing user data over instance methods is a nicer API in an ideal world... maintaining backwards compatibility and avoiding a major version bump are important from a package maintainer's perspective, too.. ",
    "saivann": "I have just submitted #158 to add static methods support in the Immutable constructor.\nvar obj = Immutable.from({});\nImmutable.setIn(obj, ['key'], value);\n. Right so at least now there is a way to avoid this bug using the new syntax. Disabling the old syntax is pretty simple but indeed not a small breaking change.\nPerhaps as a first step the documentation can be updated to only document the new static syntax? We can also easily insert a \"Will be deprecated\" warning in the browser javascript console for the devel build when users continue using the existing instance syntax for a while?\nI am not sure if it is worth to actually disable that syntax in the near future as the disruption of this change is important for current users compared to the likeliness that a user experiences this bug.\n. Oh I see. I got this wrong, it is the custom properties that are getting lost, not the seamless-immutable instance methods. To allow overriding those, I guess we could set writable to true here. This would make new static methods fully working against all cases.\nObject.defineProperty(target, methodName, {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value: value\n    });\nI am happy to submit this, documentation update, test units, and deprecation warning, if @rtfeldman thinks this is a good approach to this problem.\n. PR to complete this fix https://github.com/rtfeldman/seamless-immutable/pull/160\n. Tests appear to be passing on travis, seems like it is getting some configuration error after running them.\nZuul tried to run tests in saucelabs, however no saucelabs credentials were provided.\n. @rtfeldman Bump, just checking if there is any chance this can be included in the library :-) I'm around if you have any comments.\n. @rtfeldman Just rebased with support for static methods in tests and .replace. Should be good to go.\n\nSeems reasonable, and deep-equals seems like a trivially small dependency to add.\n\nYup and actually it's only a devDependency for test units. It is not used in the actual seamless-immutable code (tried to keep it as optimized as possible).\n. @suchipi Thanks, just applied all requested changes and added more test units.\n. @rtfeldman Note; The migration to the new syntax is optional. I can easily drop the console.warn warnings from this PR if you prefer to keep supporting both syntax going forward.\n. @rtfeldman I have dropped the deprecation warning from this pull request such that it is now mostly only #130 bugfix and test units for it, and not a migration scenario.\nThis PR still includes this breaking change. However in my views, losing data or losing access to the method are both undesirable bugs, and this change is the key to allow the user to switch to a static syntax that doesn't have the bug if needs be. Thus in my humble opinion merging this would be an improvement.\nI gave a good hour at exploring the idea of require(\"seamless-immutable\").static; to address #170. This seems like a good idea at first, however this appeared non-trivial to me, as Immutable(), makeImmutableArray(), makeImmutableObject() and such are called generously from within the library. It appears pretty easy to miss a case and introduce bugs, or re-pollute the object. And maybe this may turn into a much bigger refactoring.\nAlthough I do understand that it is great to support previous syntax, I am generally a fan of keeping things simple to ease maintainability and avoid bugs. It seems like there is no argument in favor of the previous syntax beside that it's currently in use (which also suggests it should not be promoted going forward), the static syntax appears superior on all fronts. So I tend to like the idea of migrating :) . But it's just me.. tl;dr; I suggest we only merge bugfixes, and choose between migrating or not migrating on a separate PR.\nEdit: Docs were updated to refer to the static syntax in this PR, I can revert that change if asked for it. Although since it's already released and more stable, sounds like a better choice to me.. @rtfeldman I may have found a simple compromise that is similar to what you are suggesting. I pushed another commit for this\nhttps://github.com/saivann/seamless-immutable/tree/collision#static-or-instance-syntax\nvar Immutable = require(\"seamless-immutable\");\nImmutable.config({\n    use_instance_methods: false\n});. @MoeSattler, the config only defines if seamless-immutable should add sub-methods to all objects it creates. This is opt-in (no change to current Immutable default behavior). In summary, in this PR:\n\n\nSeamless-immutable continues to support the same syntaxes it already supports\nImmutable.setIn(obj, 'key', data)\nobj.setIn('key', data)\n\n\nIn case of collision, user data now has priority over seamless-immutable methods:\n\n\nPreviously:\nvar obj = Immutable({setIn: 'data'})\nobj.setIn; // function, the assigned data is lost\nNow:\nvar obj = Immutable({setIn: 'data'})\nobj.setIn; // 'data', the seamless-immutable method is lost, user can use static functions\n\nUser can opt-in to stop attaching seamless-immutable methods to objects\n\n```\nvar Immutable = require(\"seamless-immutable\");\nImmutable.config({\n    use_instance_methods: false\n});\nvar obj = Immutable({})\nobj.setIn; // undefined, the object is clean\n``. @suchipi Although I can easily make this conditional to theuse_instance_methodsconfig if I am asked for it, I think this is actually a bad idea that I'd like to discourage, because it makes it harder for new users to have bug-free library by default. Users using the static syntax would still be affected unless they also setuse_instance_methods`, which I think we can safely assume most users won't.\nAnd perhaps obvious, but it seems unnecessary to me that we keep backward compatibility with a bug. There is no perfect bug-free backward compatible solution for the existing syntax. But we can however make sure the library is bug-free for new users, while supporting existing syntax and having a solution at hands for any existing users who may be affected this bug. This is what I am recommending in this PR.\n. Actually, I am changing my mind on this ^ . There are security implications with allowing users to run an instance method, while at the same time allowing arbitrary override of those methods. I'll update the PR and try to come up with something better.. OK latest attempt:\n\n\nSeamless-immutable continues to support the same syntaxes it already supports\nImmutable.setIn(obj, 'key', data)\nobj.setIn('key', data)\n\n\nIn case of collision, user data is lost, no matter what syntax (no change with current spec):\n\n\nvar obj = Immutable({setIn: 'data'})\nobj.setIn; // function, the assigned data is lost\n\nUser can opt-in to stop attaching seamless-immutable methods to objects\n\n```\nvar Immutable = require(\"seamless-immutable\").init({\n    use_static: true\n});\nvar obj = Immutable({})\nobj.setIn; // undefined, the object is clean\n```\nThis is pretty in line to what @rtfeldman asked (sorry for all the extra loops before getting there!).\nI still think it'd be great to migrate to one syntax in the future, but can be for later.. @rtfeldman Just added a commit for this, thanks! Looking forward to use seamless-immutable 6.4.0 :). FWIW, this would be pretty useful to me as well! I am often debugging objects in the console, and the instance methods often make it harder, so I end up using JSON.stringify() which isn't as easily browseable.. This issue can be closed - Fixed as of 7.0.0. I am not very familiar with the infrastructure here, any easy way to reproduce the issue?\nI tried to open a pull request and let it run against travis, expecting that I would get relevant output from there (assuming travis had credentials to run cross-browser tests with some third party service). However I am always getting only:\nZuul tried to run tests in saucelabs, however no saucelabs credentials were provided.\nSee the zuul wiki (https://github.com/defunctzombie/zuul/wiki/Cloud-testing) for info on how to setup cloud testing.\nThis is by contrast to https://github.com/rtfeldman/seamless-immutable/pull/178 where there is one travis instance that reported tests that passed, with explicit mentions of different browsers. I am not sure how to get those tests to run while not being rtfeldman :) .. I have just submitted #158 to add static methods support in the Immutable constructor.\nvar obj = Immutable.from({});\nImmutable.setIn(obj, ['key'], value);\n. Right so at least now there is a way to avoid this bug using the new syntax. Disabling the old syntax is pretty simple but indeed not a small breaking change.\nPerhaps as a first step the documentation can be updated to only document the new static syntax? We can also easily insert a \"Will be deprecated\" warning in the browser javascript console for the devel build when users continue using the existing instance syntax for a while?\nI am not sure if it is worth to actually disable that syntax in the near future as the disruption of this change is important for current users compared to the likeliness that a user experiences this bug.\n. Oh I see. I got this wrong, it is the custom properties that are getting lost, not the seamless-immutable instance methods. To allow overriding those, I guess we could set writable to true here. This would make new static methods fully working against all cases.\nObject.defineProperty(target, methodName, {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value: value\n    });\nI am happy to submit this, documentation update, test units, and deprecation warning, if @rtfeldman thinks this is a good approach to this problem.\n. PR to complete this fix https://github.com/rtfeldman/seamless-immutable/pull/160\n. Tests appear to be passing on travis, seems like it is getting some configuration error after running them.\nZuul tried to run tests in saucelabs, however no saucelabs credentials were provided.\n. @rtfeldman Bump, just checking if there is any chance this can be included in the library :-) I'm around if you have any comments.\n. @rtfeldman Just rebased with support for static methods in tests and .replace. Should be good to go.\n\nSeems reasonable, and deep-equals seems like a trivially small dependency to add.\n\nYup and actually it's only a devDependency for test units. It is not used in the actual seamless-immutable code (tried to keep it as optimized as possible).\n. @suchipi Thanks, just applied all requested changes and added more test units.\n. @rtfeldman Note; The migration to the new syntax is optional. I can easily drop the console.warn warnings from this PR if you prefer to keep supporting both syntax going forward.\n. @rtfeldman I have dropped the deprecation warning from this pull request such that it is now mostly only #130 bugfix and test units for it, and not a migration scenario.\nThis PR still includes this breaking change. However in my views, losing data or losing access to the method are both undesirable bugs, and this change is the key to allow the user to switch to a static syntax that doesn't have the bug if needs be. Thus in my humble opinion merging this would be an improvement.\nI gave a good hour at exploring the idea of require(\"seamless-immutable\").static; to address #170. This seems like a good idea at first, however this appeared non-trivial to me, as Immutable(), makeImmutableArray(), makeImmutableObject() and such are called generously from within the library. It appears pretty easy to miss a case and introduce bugs, or re-pollute the object. And maybe this may turn into a much bigger refactoring.\nAlthough I do understand that it is great to support previous syntax, I am generally a fan of keeping things simple to ease maintainability and avoid bugs. It seems like there is no argument in favor of the previous syntax beside that it's currently in use (which also suggests it should not be promoted going forward), the static syntax appears superior on all fronts. So I tend to like the idea of migrating :) . But it's just me.. tl;dr; I suggest we only merge bugfixes, and choose between migrating or not migrating on a separate PR.\nEdit: Docs were updated to refer to the static syntax in this PR, I can revert that change if asked for it. Although since it's already released and more stable, sounds like a better choice to me.. @rtfeldman I may have found a simple compromise that is similar to what you are suggesting. I pushed another commit for this\nhttps://github.com/saivann/seamless-immutable/tree/collision#static-or-instance-syntax\nvar Immutable = require(\"seamless-immutable\");\nImmutable.config({\n    use_instance_methods: false\n});. @MoeSattler, the config only defines if seamless-immutable should add sub-methods to all objects it creates. This is opt-in (no change to current Immutable default behavior). In summary, in this PR:\n\n\nSeamless-immutable continues to support the same syntaxes it already supports\nImmutable.setIn(obj, 'key', data)\nobj.setIn('key', data)\n\n\nIn case of collision, user data now has priority over seamless-immutable methods:\n\n\nPreviously:\nvar obj = Immutable({setIn: 'data'})\nobj.setIn; // function, the assigned data is lost\nNow:\nvar obj = Immutable({setIn: 'data'})\nobj.setIn; // 'data', the seamless-immutable method is lost, user can use static functions\n\nUser can opt-in to stop attaching seamless-immutable methods to objects\n\n```\nvar Immutable = require(\"seamless-immutable\");\nImmutable.config({\n    use_instance_methods: false\n});\nvar obj = Immutable({})\nobj.setIn; // undefined, the object is clean\n``. @suchipi Although I can easily make this conditional to theuse_instance_methodsconfig if I am asked for it, I think this is actually a bad idea that I'd like to discourage, because it makes it harder for new users to have bug-free library by default. Users using the static syntax would still be affected unless they also setuse_instance_methods`, which I think we can safely assume most users won't.\nAnd perhaps obvious, but it seems unnecessary to me that we keep backward compatibility with a bug. There is no perfect bug-free backward compatible solution for the existing syntax. But we can however make sure the library is bug-free for new users, while supporting existing syntax and having a solution at hands for any existing users who may be affected this bug. This is what I am recommending in this PR.\n. Actually, I am changing my mind on this ^ . There are security implications with allowing users to run an instance method, while at the same time allowing arbitrary override of those methods. I'll update the PR and try to come up with something better.. OK latest attempt:\n\n\nSeamless-immutable continues to support the same syntaxes it already supports\nImmutable.setIn(obj, 'key', data)\nobj.setIn('key', data)\n\n\nIn case of collision, user data is lost, no matter what syntax (no change with current spec):\n\n\nvar obj = Immutable({setIn: 'data'})\nobj.setIn; // function, the assigned data is lost\n\nUser can opt-in to stop attaching seamless-immutable methods to objects\n\n```\nvar Immutable = require(\"seamless-immutable\").init({\n    use_static: true\n});\nvar obj = Immutable({})\nobj.setIn; // undefined, the object is clean\n```\nThis is pretty in line to what @rtfeldman asked (sorry for all the extra loops before getting there!).\nI still think it'd be great to migrate to one syntax in the future, but can be for later.. @rtfeldman Just added a commit for this, thanks! Looking forward to use seamless-immutable 6.4.0 :). FWIW, this would be pretty useful to me as well! I am often debugging objects in the console, and the instance methods often make it harder, so I end up using JSON.stringify() which isn't as easily browseable.. This issue can be closed - Fixed as of 7.0.0. I am not very familiar with the infrastructure here, any easy way to reproduce the issue?\nI tried to open a pull request and let it run against travis, expecting that I would get relevant output from there (assuming travis had credentials to run cross-browser tests with some third party service). However I am always getting only:\nZuul tried to run tests in saucelabs, however no saucelabs credentials were provided.\nSee the zuul wiki (https://github.com/defunctzombie/zuul/wiki/Cloud-testing) for info on how to setup cloud testing.\nThis is by contrast to https://github.com/rtfeldman/seamless-immutable/pull/178 where there is one travis instance that reported tests that passed, with explicit mentions of different browsers. I am not sure how to get those tests to run while not being rtfeldman :) .. ",
    "mikeaustin": "FYI, with the inability to use objects as keys for objects, and modern browsers supporting them natively or using polyfills, it's a difficult decision to use seamless-immutable. I've been using immutable.js, but am very curious about using similar, but lighter-weight library.\nI don't even mind contributing, if there is a general sense of what needs to be done. Would you say it's a week worth of work? A month? Thank you and great work.. Soo.. are Maps and Sets supported now? I'd digging around trying to find out.. FYI, with the inability to use objects as keys for objects, and modern browsers supporting them natively or using polyfills, it's a difficult decision to use seamless-immutable. I've been using immutable.js, but am very curious about using similar, but lighter-weight library.\nI don't even mind contributing, if there is a general sense of what needs to be done. Would you say it's a week worth of work? A month? Thank you and great work.. Soo.. are Maps and Sets supported now? I'd digging around trying to find out.. ",
    "corymartin": "This issue is also present with Errors - which is how I found my way here.\nPerhaps a solution like that in #31?\n. This issue is also present with Errors - which is how I found my way here.\nPerhaps a solution like that in #31?\n. ",
    "jamesoh": "No problem, thanks!\nOn Thu, Jun 23, 2016 at 2:40 PM, Richard Feldman notifications@github.com\nwrote:\n\nClosed #136 https://github.com/rtfeldman/seamless-immutable/issues/136.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/136#event-702517213,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ADoFgSBJjxD4spUZ03HGy_pD3O7S0zcIks5qOv1PgaJpZM4I7_dZ\n.\n. No problem, thanks!\n\nOn Thu, Jun 23, 2016 at 2:40 PM, Richard Feldman notifications@github.com\nwrote:\n\nClosed #136 https://github.com/rtfeldman/seamless-immutable/issues/136.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/136#event-702517213,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ADoFgSBJjxD4spUZ03HGy_pD3O7S0zcIks5qOv1PgaJpZM4I7_dZ\n.\n. \n",
    "lelandmiller": "Looks like the build failed to a credentials issue, not test failures:\nZuul tried to run tests in saucelabs, however no saucelabs credentials were provided.\n. Just wanted to ping on this and see if anyone had any feedback.\nThanks :-)\n. Hey, @rtfeldman! just wanted to check in on this again to see if there is anything I could do to possibly get this in a published version of seamless-immutable.\nThanks!\n. Closing and continuing on #156.\n. Sorry for the slow response @rtfeldman. Fixed the merge conflicts, looks like the failure of CI is still due to missing saucelabs credentials.\n. Thank you!\n. Looks like the build failed to a credentials issue, not test failures:\nZuul tried to run tests in saucelabs, however no saucelabs credentials were provided.\n. Just wanted to ping on this and see if anyone had any feedback.\nThanks :-)\n. Hey, @rtfeldman! just wanted to check in on this again to see if there is anything I could do to possibly get this in a published version of seamless-immutable.\nThanks!\n. Closing and continuing on #156.\n. Sorry for the slow response @rtfeldman. Fixed the merge conflicts, looks like the failure of CI is still due to missing saucelabs credentials.\n. Thank you!\n. ",
    "tommoor": "This also happens in our environment - really frustrating as it makes it impossible to create Immutable arrays. I'd love to see your PR specs fixed up and merged!\n. This also happens in our environment - really frustrating as it makes it impossible to create Immutable arrays. I'd love to see your PR specs fixed up and merged!\n. ",
    "variant77": "Thanks for letting more know I was not the only one affected. At some point\nI was losing my mind over it.\nMy PR seem to be just fine, all the tests poss when I run them locally.\nThere is some configuration error in the repo that causes all PRs to fail.\nIf you want to use the fixed version before the PR is merged you can use my\nfork for now and subscribe to this thread to know when to switch back.\nOn Fri, Sep 9, 2016, 01:28 Tom Moor notifications@github.com wrote:\n\nThis also happens in our environment - really frustrating as it makes it\nimpossible to create Immutable arrays. I'd love to see your PR specs fixed\nup and merged!\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/146#issuecomment-245761781,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AByTcZMvKNcMgJBZvBBxjR-D1lHYWlJZks5qoIwQgaJpZM4J0f39\n.\n. @rtfeldman I'd love to get your input on this PR\n. Thanks for letting more know I was not the only one affected. At some point\nI was losing my mind over it.\n\nMy PR seem to be just fine, all the tests poss when I run them locally.\nThere is some configuration error in the repo that causes all PRs to fail.\nIf you want to use the fixed version before the PR is merged you can use my\nfork for now and subscribe to this thread to know when to switch back.\nOn Fri, Sep 9, 2016, 01:28 Tom Moor notifications@github.com wrote:\n\nThis also happens in our environment - really frustrating as it makes it\nimpossible to create Immutable arrays. I'd love to see your PR specs fixed\nup and merged!\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/146#issuecomment-245761781,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AByTcZMvKNcMgJBZvBBxjR-D1lHYWlJZks5qoIwQgaJpZM4J0f39\n.\n. @rtfeldman I'd love to get your input on this PR\n. \n",
    "brunolemos": "@rtfeldman please update the npm package :) \n. @rtfeldman please update the npm package :) \n. ",
    "hilkeheremans": "I haven't checked or tried it out, but my first guess would be that in the \"incorrect\" case, seamless-immutable, when provided with an array in merge, merges from the last element to the first. This would cause homer.simpson to be overwritten with its l33t counterpart. The opposite is happening in the \"correct\" case since you are making two distinct merge calls which get called in that order.\nMight be a good idea to explicitly call that out in the docs.\n. I haven't checked or tried it out, but my first guess would be that in the \"incorrect\" case, seamless-immutable, when provided with an array in merge, merges from the last element to the first. This would cause homer.simpson to be overwritten with its l33t counterpart. The opposite is happening in the \"correct\" case since you are making two distinct merge calls which get called in that order.\nMight be a good idea to explicitly call that out in the docs.\n. ",
    "geirsagberg": "Thanks for the tip, will use that as a workaround!\nHowever, if seamless-immutable had a native getIn, the syntax would be more consistent with setIn etc, and we could also automatically wrap the fallback value as an Immutable.\n. Looks like https://github.com/rtfeldman/seamless-immutable/pull/188 is released, closing this.. Seems to be released now.. Thanks for the tip, will use that as a workaround!\nHowever, if seamless-immutable had a native getIn, the syntax would be more consistent with setIn etc, and we could also automatically wrap the fallback value as an Immutable.\n. Looks like https://github.com/rtfeldman/seamless-immutable/pull/188 is released, closing this.. Seems to be released now.. ",
    "guyellis": "If you want to keep the getIn syntax then building on @crudh idea create a utility method.\n```\nimport _get from 'lodash/get';\nfunction getIn(state, path, alt) {\n  return _get(state, path.join('.'), alt);\n}\nvar foo = getIn(state, ['bar', 'baz', 'foo'], '');\n```\nMight make transition from ImmutableJS easier and keeps syntax similar to what might be implemented in seamless.\n. If you want to keep the getIn syntax then building on @crudh idea create a utility method.\n```\nimport _get from 'lodash/get';\nfunction getIn(state, path, alt) {\n  return _get(state, path.join('.'), alt);\n}\nvar foo = getIn(state, ['bar', 'baz', 'foo'], '');\n```\nMight make transition from ImmutableJS easier and keeps syntax similar to what might be implemented in seamless.\n. ",
    "zackify": "Dang, this was the big thing I was excited about. I was hoping doing state.bar.baz would return undefined if bar didn't exist. I guess that can only be accomplished by using a proxy, which isn't in IE11, so it isn't feasible for me.. Dang, this was the big thing I was excited about. I was hoping doing state.bar.baz would return undefined if bar didn't exist. I guess that can only be accomplished by using a proxy, which isn't in IE11, so it isn't feasible for me.. ",
    "renatorib": "@zackify there is a proposal for this feature called Null Propagation (or Optional Chaining, or Existential Operator, or Null-safe property access)\nhttps://github.com/claudepache/es-optional-chaining\n```js\n// today\nconst street = user && user.address && user.address.street\n// proposal\nconst street = user?.address?.street;\n```\n. @zackify there is a proposal for this feature called Null Propagation (or Optional Chaining, or Existential Operator, or Null-safe property access)\nhttps://github.com/claudepache/es-optional-chaining\n```js\n// today\nconst street = user && user.address && user.address.street\n// proposal\nconst street = user?.address?.street;\n```\n. ",
    "marbemac": "Also wasn't sure if I should include re-built distributions - let me know!\n. Alrighty, updated! I included the dist files as well, but just realized you merged some changes into master earlier today - how would you like to handle it?\n. Sweet! Thanks for reviewing this so quickly.\n. Agreed - I missed that - thanks @huan086.. Also wasn't sure if I should include re-built distributions - let me know!\n. Alrighty, updated! I included the dist files as well, but just realized you merged some changes into master earlier today - how would you like to handle it?\n. Sweet! Thanks for reviewing this so quickly.\n. Agreed - I missed that - thanks @huan086.. ",
    "Stuk": "This can be simplified down to:\njs\nconst promise = Immutable.from(Promise.resolve(123))\nconsole.log(promise);\npromise.then(console.log)\nwhich results in:\n```\n{}\npromise.then(console.log)\n        ^\nTypeError: promise.then is not a function\n   ...\n```\nPromises can be considered immutable, and this library should probable treat them as such. . This can be simplified down to:\njs\nconst promise = Immutable.from(Promise.resolve(123))\nconsole.log(promise);\npromise.then(console.log)\nwhich results in:\n```\n{}\npromise.then(console.log)\n        ^\nTypeError: promise.then is not a function\n   ...\n```\nPromises can be considered immutable, and this library should probable treat them as such. . ",
    "dhirendrarathod2000": "@rtfeldman Any ETA when the fix will be merged to master?. @dentrado @rtfeldman\\\nAny ETA when it will be released?. @rtfeldman Any ETA when the fix will be merged to master?. @dentrado @rtfeldman\\\nAny ETA when it will be released?. ",
    "itaysabato": "I would consider an empty path to mean \"set the given value instead of this object\" and simply return Immutable(value). @gmeans my alternative is to not use this library yet...\nI have implemented my own setIn and mergeIn functions that use native objects and arrays.. @gmeans If the library had a mergeIn method (that creates a new object only if necessary) it would solve my use case and probably yours as well. You can implement it yourself though with code like:\n```js\nfunction mergeIn(target, path, source, config) {\n    var innerTarget = Immutable.getIn(target, path);\n    var innerMerged = Immutable.merge(innerTarget, source, config);\nreturn Immutable.setIn(target, path, innerMerged);\n\n}\n```\nThere are probably some edge cases that need to be addressed - this code is based on what I'm doing without seamless-immutable.\nPersonally, I think this is a basic functionality (the only one I need, in fact) that should be provided by the library.. I would consider an empty path to mean \"set the given value instead of this object\" and simply return Immutable(value). @gmeans my alternative is to not use this library yet...\nI have implemented my own setIn and mergeIn functions that use native objects and arrays.. @gmeans If the library had a mergeIn method (that creates a new object only if necessary) it would solve my use case and probably yours as well. You can implement it yourself though with code like:\n```js\nfunction mergeIn(target, path, source, config) {\n    var innerTarget = Immutable.getIn(target, path);\n    var innerMerged = Immutable.merge(innerTarget, source, config);\nreturn Immutable.setIn(target, path, innerMerged);\n\n}\n```\nThere are probably some edge cases that need to be addressed - this code is based on what I'm doing without seamless-immutable.\nPersonally, I think this is a basic functionality (the only one I need, in fact) that should be provided by the library.. ",
    "nazar-pc": "Also depends on #117\n. What about to add another key browser to package.json with seamless-immutable.production.min.js in it so that it would be possible to find deterministically which file browser should use?\nI've added similar key to Redux already (https://github.com/reactjs/redux/pull/2047), quote from there:\n\nThere was a key browser in jQuery's package.json in past, so I decided that this is a good candidate to use.\nI'm currently checking following keys (based on package.json files of other popular projects) with priority from higher to lower:\n- browser\n- jspm.main\n- main\n\nAs a side note, would be nice to have some more common structure for production builds, like dist/seamless-immutable.js (production version) and dist/seamless-immutable.min.js (production minified version).. > Arguably a dist folder would be a slightly better place to put them, but I don't think that slight improvement is worth breaking everyone's builds the next time they upgrade.\nThere are 2 ways here, neither of which is perfect:\n* move to 7.x and break whatever is needed (existing builds wouldn't break, but people need to update their configs)\n* temporarily till 7.x support both current files locations and dist/{seamless-immutable.js|seamless-immutable.min.js} (sounds awful)\n. Closing this as #177 was merged, which solves issue for me.\nDo you have plans to release a new version anytime soon?. Nice, I see new release already:). #165 resolves different issue I had with this tool.\nClosing this in favor of discussion in #164. I'm not sure if browser key is used/respected by any build tool (mostly because I'm not using them, however I have strong doubts that they do).\nI've seen browser key in jQuery in past (not used anymore) and found it to be a good candidate for such libraries in order to differentiate builds for Node.js and for browsers.\nAs for development build - well, you can't point there right now (see #166).\nSituation with using Bower/NPM packages in browser is awkward. There is no deterministic standard that can answer to the question \"which file should be used in browser\" (AFAIK).\nI my framework (can't speak for anything else) there is an option for combining, minification and caching various frontend assets (this is the reason why I mostly don't use any build tools, it does everything out of the box). It tries its best to make everything completely automatically. When compression is not used, frontend is considered in \"development\" environment (uses browser key in current example as is), but when compression is turned on, \"production\" mode is assumed (and framework will try to find file with the name from browser key with .min suffix added).\nWith above being said I'd like to repeat suggestion from linked issue:\n\nAs a side note, would be nice to have some more common structure for production builds, like dist/seamless-immutable.js (production version) and dist/seamless-immutable.min.js (production minified version).\n\nIn context of your last comment development version might enforce immutability and production might not. However, this is no way established standard behavior and it is a bit surprising that *.min.js file differs from un-suffixed file in some way besides minification (though, might be acceptable when added to readme).. Nice to see webpack supports it, didn't know about this.\nIn my opinion something that goes into build system should be production, since artifacts will likely be used in production. While those who need development version can still manually specify what they need explicitly.\n\nThe webpack docs suggest browser would take precedence in webpack. They also mention that there is a way to override that, so I'm okay with this as long as it points to the development build instead of the production build.\n\nwebpack key might be used in addition to browser, it will have even higher precedence than browser. But I can't imagine why would anyone want development version as webpack's artifact.. > tl;dr Making the production build the default would be dangerously irresponsible and I'm not going to do it. \ud83d\ude42\nAgree, makes sense, should I update this PR now to point to development version?. Updated. Also depends on #117\n. What about to add another key browser to package.json with seamless-immutable.production.min.js in it so that it would be possible to find deterministically which file browser should use?\nI've added similar key to Redux already (https://github.com/reactjs/redux/pull/2047), quote from there:\n\nThere was a key browser in jQuery's package.json in past, so I decided that this is a good candidate to use.\nI'm currently checking following keys (based on package.json files of other popular projects) with priority from higher to lower:\n- browser\n- jspm.main\n- main\n\nAs a side note, would be nice to have some more common structure for production builds, like dist/seamless-immutable.js (production version) and dist/seamless-immutable.min.js (production minified version).. > Arguably a dist folder would be a slightly better place to put them, but I don't think that slight improvement is worth breaking everyone's builds the next time they upgrade.\nThere are 2 ways here, neither of which is perfect:\n* move to 7.x and break whatever is needed (existing builds wouldn't break, but people need to update their configs)\n* temporarily till 7.x support both current files locations and dist/{seamless-immutable.js|seamless-immutable.min.js} (sounds awful)\n. Closing this as #177 was merged, which solves issue for me.\nDo you have plans to release a new version anytime soon?. Nice, I see new release already:). #165 resolves different issue I had with this tool.\nClosing this in favor of discussion in #164. I'm not sure if browser key is used/respected by any build tool (mostly because I'm not using them, however I have strong doubts that they do).\nI've seen browser key in jQuery in past (not used anymore) and found it to be a good candidate for such libraries in order to differentiate builds for Node.js and for browsers.\nAs for development build - well, you can't point there right now (see #166).\nSituation with using Bower/NPM packages in browser is awkward. There is no deterministic standard that can answer to the question \"which file should be used in browser\" (AFAIK).\nI my framework (can't speak for anything else) there is an option for combining, minification and caching various frontend assets (this is the reason why I mostly don't use any build tools, it does everything out of the box). It tries its best to make everything completely automatically. When compression is not used, frontend is considered in \"development\" environment (uses browser key in current example as is), but when compression is turned on, \"production\" mode is assumed (and framework will try to find file with the name from browser key with .min suffix added).\nWith above being said I'd like to repeat suggestion from linked issue:\n\nAs a side note, would be nice to have some more common structure for production builds, like dist/seamless-immutable.js (production version) and dist/seamless-immutable.min.js (production minified version).\n\nIn context of your last comment development version might enforce immutability and production might not. However, this is no way established standard behavior and it is a bit surprising that *.min.js file differs from un-suffixed file in some way besides minification (though, might be acceptable when added to readme).. Nice to see webpack supports it, didn't know about this.\nIn my opinion something that goes into build system should be production, since artifacts will likely be used in production. While those who need development version can still manually specify what they need explicitly.\n\nThe webpack docs suggest browser would take precedence in webpack. They also mention that there is a way to override that, so I'm okay with this as long as it points to the development build instead of the production build.\n\nwebpack key might be used in addition to browser, it will have even higher precedence than browser. But I can't imagine why would anyone want development version as webpack's artifact.. > tl;dr Making the production build the default would be dangerously irresponsible and I'm not going to do it. \ud83d\ude42\nAgree, makes sense, should I update this PR now to point to development version?. Updated. ",
    "rbellamy": "Looks like the build is failing for credentials to saucelabs, which is the source of the compatibility chart... they're all red because of this.\n. Looks like the build is failing for credentials to saucelabs, which is the source of the compatibility chart... they're all red because of this.\n. ",
    "noahehall": "hmm ive actually switched form using Maps with seamless-immutable, but will be interested to know if they will be supported in the future\n. Definitely, ill take a swing at it. I switched to storing everything as an object for now. yeah sorry guys still havent had time to work on this, things at work have been crazy. Finally got some time, picking this up ;). so i got drunk last night and worked on integrating maps,\nyou can see a preview here:\nhttps://github.com/rtfeldman/seamless-immutable/pull/198\ni'll need to do some clean up and refacter it a bit, add some tests, then ill drop the WIP tag from the pull request. hmm ive actually switched form using Maps with seamless-immutable, but will be interested to know if they will be supported in the future\n. Definitely, ill take a swing at it. I switched to storing everything as an object for now. yeah sorry guys still havent had time to work on this, things at work have been crazy. Finally got some time, picking this up ;). so i got drunk last night and worked on integrating maps,\nyou can see a preview here:\nhttps://github.com/rtfeldman/seamless-immutable/pull/198\ni'll need to do some clean up and refacter it a bit, add some tests, then ill drop the WIP tag from the pull request. ",
    "gavin-gmlab": "I'm having this problem also. \nSeems like a .set still works, but a .get does not get the object back properly.\nTried a workaround to create a new map object => newMap = new Map(state.oldMap._mapData) seems to work. Not sure if there are other implications \n. I'm having this problem also. \nSeems like a .set still works, but a .get does not get the object back properly.\nTried a workaround to create a new map object => newMap = new Map(state.oldMap._mapData) seems to work. Not sure if there are other implications \n. ",
    "huan086": "Seems to be intentional, looking at the following example\n```\nImmutable([1, 2, 3]).concat([10, 9, 8]).sort()\n// This will also throw ImmutableError, because an Immutable Array's methods\n// (including concat()) are guaranteed to return other immutable values.\n[1, 2, 3].concat(Immutable([6, 5, 4])).sort()\n// This will succeed, and will yield a sorted mutable array containing\n// [1, 2, 3, 4, 5, 6], because a vanilla array's concat() method has\n// no knowledge of Immutable.\n```\nNeeds to be fixed on the redux-form side.. Seems to be intentional, looking at the following example\n```\nImmutable([1, 2, 3]).concat([10, 9, 8]).sort()\n// This will also throw ImmutableError, because an Immutable Array's methods\n// (including concat()) are guaranteed to return other immutable values.\n[1, 2, 3].concat(Immutable([6, 5, 4])).sort()\n// This will succeed, and will yield a sorted mutable array containing\n// [1, 2, 3, 4, 5, 6], because a vanilla array's concat() method has\n// no knowledge of Immutable.\n```\nNeeds to be fixed on the redux-form side.. ",
    "ryantemple": "I'm still seeing the same error as above - the only test that seems to break locally is the omitBy test here https://github.com/rtfeldman/seamless-immutable/blob/master/test/ImmutableObject/test-without.js#L176 which I've raised a PR for #196 . I'm still seeing the same error as above - the only test that seems to break locally is the omitBy test here https://github.com/rtfeldman/seamless-immutable/blob/master/test/ImmutableObject/test-without.js#L176 which I've raised a PR for #196 . ",
    "messense": "\nDowngraded to v6.1.1 works fine.. And the React Native packager hangs on transforming when this error occurred.. @rtfeldman Works fine after deleting browser entry!. @rtfeldman Still get the error.. It works when I leave the browser entry there, but add another entry that's exactly the same as the main one except it says \"react-native\" instead of \"main\". \nDowngraded to v6.1.1 works fine.. And the React Native packager hangs on transforming when this error occurred.. @rtfeldman Works fine after deleting browser entry!. @rtfeldman Still get the error.. It works when I leave the browser entry there, but add another entry that's exactly the same as the main one except it says \"react-native\" instead of \"main\". ",
    "jgkim": "@rtfeldman Since the build files for broswers are listed in .npmignore, it cannot be found and imported in the react-native (node) environment.. @rtfeldman I guess the react-native environment is somewhat different from the browser environment. Do you think it's appropriate for react-native to fallback to the browser field? If it's the case, why do we need to distinguish main from browser?. Making it explicit is good. :) I think react-native is more similar to node rather than browser. The packager of react-native will transpile and minify the source. However, whichever case we choose, it will work. ;). @rtfeldman Since the build files for broswers are listed in .npmignore, it cannot be found and imported in the react-native (node) environment.. @rtfeldman I guess the react-native environment is somewhat different from the browser environment. Do you think it's appropriate for react-native to fallback to the browser field? If it's the case, why do we need to distinguish main from browser?. Making it explicit is good. :) I think react-native is more similar to node rather than browser. The packager of react-native will transpile and minify the source. However, whichever case we choose, it will work. ;). ",
    "coveralls": "\nCoverage remained the same at 95.942% when pulling 5cd203438fcef6802eb3b7d69d9ce0180e342e1e on jgkim:fix/react-native into ab98236daa8d09a27545d7316fd084675104ec5b on rtfeldman:master.\n. \n\nCoverage remained the same at 95.942% when pulling 9bcdc4bbffbabd2e7feb8d24d06b5f65bed80f6c on jwt-travis into ecad6148fe457321b5b86fdf106b9dab92d6355c on master.\n. \n\nCoverage remained the same at 95.942% when pulling 5cd203438fcef6802eb3b7d69d9ce0180e342e1e on jgkim:fix/react-native into ab98236daa8d09a27545d7316fd084675104ec5b on rtfeldman:master.\n. \n\nCoverage remained the same at 95.942% when pulling 9bcdc4bbffbabd2e7feb8d24d06b5f65bed80f6c on jwt-travis into ecad6148fe457321b5b86fdf106b9dab92d6355c on master.\n. ",
    "niahoo": "I second this. I don't care if the function is called sort or sorted or whatever but we need this.\nWe could also add sortBy('name') and sortBy(item => item.name) helpers ; or it may be beyond the scope of this library.. I second this. I don't care if the function is called sort or sorted or whatever but we need this.\nWe could also add sortBy('name') and sortBy(item => item.name) helpers ; or it may be beyond the scope of this library.. ",
    "LukeusMaximus": "I've had a crack at this in #211 . To perform a modification you can use setIn() to achieve this:\nbundles = Immutable.setIn(bundles, [\"items\", 0, \"name\"], \"new name\")\nwill give:\nbundles: {\ncount: 12,\nitems: [ {\n  name: 'new name',\n  id: '213123123',\n  field: 'sdfdsf',\n  children: []\n}, {}, {} ...]\n}. Yup, all fixed.. Is identifying a web standards promise sufficient? i.e.:\nfunction isPromise(obj) {\n    return obj.constructor === Promise;\n}\nIf not, I'd go with a solution that had the methods isPromise and isThenable to prevent confusion.. I'm unsure how to address the build issues in Travis. Can someone assist?. What's going on with this Travis build? I'm still unable to proceed.. I've had a crack at this in #211 . To perform a modification you can use setIn() to achieve this:\nbundles = Immutable.setIn(bundles, [\"items\", 0, \"name\"], \"new name\")\nwill give:\nbundles: {\ncount: 12,\nitems: [ {\n  name: 'new name',\n  id: '213123123',\n  field: 'sdfdsf',\n  children: []\n}, {}, {} ...]\n}. Yup, all fixed.. Is identifying a web standards promise sufficient? i.e.:\nfunction isPromise(obj) {\n    return obj.constructor === Promise;\n}\nIf not, I'd go with a solution that had the methods isPromise and isThenable to prevent confusion.. I'm unsure how to address the build issues in Travis. Can someone assist?. What's going on with this Travis build? I'm still unable to proceed.. ",
    "jonrh": "Any update on this? Came looking for sorting and found this. @LukeusMaximus PR seems to be stuck on a broken Travis build.. Any update on this? Came looking for sorting and found this. @LukeusMaximus PR seems to be stuck on a broken Travis build.. ",
    "bradennapier": "+1 here - just ran into the need for sorting.  An immutable sort replacement would be a good solution and I believe sort is enough of a required feature.. In your source I found this\njs\n} else {\n      // In JavaScript, only objects are even potentially mutable.\n      // strings, numbers, null, and undefined are all naturally immutable.\n      return true;\n    }\nwhich to me is an issue - my goal is to check if the item is an immutable object so i know if i need to convert it or not\nseems like maybe asMutable should return an object or value that , if immutable has modified, converts it back to an untouched value.  therefore could do Immutable.asMutable(undefined) and simply get back undefined.. Err yeah what's more is this basically completely breaks flow and the entire app - seamless-immutable can not go with flow when using the recommended way or every single file is an error automatically :(\n. +1 here - just ran into the need for sorting.  An immutable sort replacement would be a good solution and I believe sort is enough of a required feature.. In your source I found this\njs\n} else {\n      // In JavaScript, only objects are even potentially mutable.\n      // strings, numbers, null, and undefined are all naturally immutable.\n      return true;\n    }\nwhich to me is an issue - my goal is to check if the item is an immutable object so i know if i need to convert it or not\nseems like maybe asMutable should return an object or value that , if immutable has modified, converts it back to an untouched value.  therefore could do Immutable.asMutable(undefined) and simply get back undefined.. Err yeah what's more is this basically completely breaks flow and the entire app - seamless-immutable can not go with flow when using the recommended way or every single file is an error automatically :(\n. ",
    "nonameolsson": "Any progress on this?. How come there is no find-method? Would have been great!. Any progress on this?. How come there is no find-method? Would have been great!. ",
    "peterpme": "Hey @theogravity thanks for getting back to me! This is great! . Hey @theogravity thanks for getting back to me! This is great! . ",
    "offlinehacker": "I'm using Immutable.equals in my model library to check if some fields in a model have changed from original value.. I'm using Immutable.equals in my model library to check if some fields in a model have changed from original value.. ",
    "dentrado": "ping @rtfeldman. @rtfeldman sure, I've added an additional test now.. I've made a PR that should fix the problem: https://github.com/rtfeldman/seamless-immutable/pull/205. ping @rtfeldman. @rtfeldman sure, I've added an additional test now.. I've made a PR that should fix the problem: https://github.com/rtfeldman/seamless-immutable/pull/205. ",
    "hassanbazzi": "Any idea when this will be released?. Any idea when this will be released?. ",
    "bm-axel": "So this hasn't been released yet? I just downloaded seamless-immutable for the first time today and saw Immutable.getIn in the readme and was surprised to find it not working!. So this hasn't been released yet? I just downloaded seamless-immutable for the first time today and saw Immutable.getIn in the readme and was surprised to find it not working!. ",
    "aight8": "Why was with issue deleted without one comment?\nWas using the method on the wrong immutable library.\nAnyway: documentation missing for isImmutable, and no comment in an issue.. Why was with issue deleted without one comment?\nWas using the method on the wrong immutable library.\nAnyway: documentation missing for isImmutable, and no comment in an issue.. ",
    "arthur31416": "Hi. I just opened a PR to document it. I'd be glad to tweak if necessary.. My bad, this is fixed !. Hi. I just opened a PR to document it. I'd be glad to tweak if necessary.. My bad, this is fixed !. ",
    "nadavsinai": "First of all thank you for your prompt response, I think that this PR should be split into a few, there's a couple of issues:\n1) the first commit Algotec/seamless-immutable@dd5c000  fixes a bug where the config object is ignored when calling set/setIn, this is unrelated to taking existing prototypes and continues your philosophy of making the user explicitly declare the prototype - though making it possible for props to have prototypes at all.\n2) the 2nd and third commits here are the thing we differ about, I come from a perspective where the developer that chooses to use this library has awareness of immutability, the responsibility to make the prototype methods not alter the same object but to return a new one should be documented, but I don't think that loosing object prototypes should be a side-effect of calling for immutability, especially since you make it so unpredictable - main objects can have prototypes (with config) but object props can not? Calling Set will remove prototypes?\nnow about the possibility of using existing prototypes, this can be an opt-in configuration, just like the ability to stop the run-time prototype modification you are doing already.\n3) the call to proto can be changed to\n(typeof Object.getPrototypeOf =='function') ? Object.getPrototypeOf(obj) : obj.__proto__\nwhich brings you into compatibility but shows that you've tried to make it use the official syntax...\nthere is no harm in  getting protoypes  -  read  \nthe harm is done when changing prototypes   write  - and this was something that can be (and should) not be done by your lib, imagine something like getting existing prototype, then using object assign to create a new object with all prototype methods and seamless-immutable methods, then using this new prototype for the object using Object.create\n```\nlet oldProto =  (typeof Object.getPrototypeOf =='function') ? Object.getPrototypeOf(obj) : obj.proto;\nlet newProto = Object.assign({},oldProto ,immtableObjectProto);\nlet clone = Object.create(newProto,obj);\n````\nI can fix this PR to do this, and make this a configurable option, defaults can be as you wish.\n. First of all thank you for your prompt response, I think that this PR should be split into a few, there's a couple of issues:\n1) the first commit Algotec/seamless-immutable@dd5c000  fixes a bug where the config object is ignored when calling set/setIn, this is unrelated to taking existing prototypes and continues your philosophy of making the user explicitly declare the prototype - though making it possible for props to have prototypes at all.\n2) the 2nd and third commits here are the thing we differ about, I come from a perspective where the developer that chooses to use this library has awareness of immutability, the responsibility to make the prototype methods not alter the same object but to return a new one should be documented, but I don't think that loosing object prototypes should be a side-effect of calling for immutability, especially since you make it so unpredictable - main objects can have prototypes (with config) but object props can not? Calling Set will remove prototypes?\nnow about the possibility of using existing prototypes, this can be an opt-in configuration, just like the ability to stop the run-time prototype modification you are doing already.\n3) the call to proto can be changed to\n(typeof Object.getPrototypeOf =='function') ? Object.getPrototypeOf(obj) : obj.__proto__\nwhich brings you into compatibility but shows that you've tried to make it use the official syntax...\nthere is no harm in  getting protoypes  -  read  \nthe harm is done when changing prototypes   write  - and this was something that can be (and should) not be done by your lib, imagine something like getting existing prototype, then using object assign to create a new object with all prototype methods and seamless-immutable methods, then using this new prototype for the object using Object.create\n```\nlet oldProto =  (typeof Object.getPrototypeOf =='function') ? Object.getPrototypeOf(obj) : obj.proto;\nlet newProto = Object.assign({},oldProto ,immtableObjectProto);\nlet clone = Object.create(newProto,obj);\n````\nI can fix this PR to do this, and make this a configurable option, defaults can be as you wish.\n. ",
    "scottmas": "I too would like confirmation of this. . I too would like confirmation of this. . ",
    "stoeckley": "I was looking into this, and I get the impression that Seamless is not a persistent data structure and does not use structural sharing (and also would not be good for functional programming for those reasons). Here is another commenter about more details:\nhttps://www.reddit.com/r/javascript/comments/3r5ppg/why_use_immutablejs_over_mori/cwlh6u8/\nIf you are looking for a more traditional immutable data structure, mori might make more sense.. I was looking into this, and I get the impression that Seamless is not a persistent data structure and does not use structural sharing (and also would not be good for functional programming for those reasons). Here is another commenter about more details:\nhttps://www.reddit.com/r/javascript/comments/3r5ppg/why_use_immutablejs_over_mori/cwlh6u8/\nIf you are looking for a more traditional immutable data structure, mori might make more sense.. ",
    "yoavniran": "hi @rtfeldman \nin a project im working on I have an issue in safari. uploads to server are failing because the Blob I reference in my state is being treated as data instead of an object to skip (like File/React/Error). \nThe reason its a Blob and not a File is that creating a File instance from the binary I get (from a 3rd party API) on Safari fails (its empty) and creating a Blob works.\nI think Blob should be treated the same as File, no? \nId be happy to submit a PR that does the same as isFileObject for Blob.\n. Travis build fails with:\n\nzuul -- test/*.spec.js\n\n\n\ntesting: chrome @ Linux: 45\n\n\ntesting: chrome @ Mac 10.11: 62\n\n\ntesting: internet explorer @ Windows 2008: 9\n\n\ntesting: internet explorer @ Windows 2012: 10\n\n\ntesting: internet explorer @ Windows 10: 11\n\n\ntesting: firefox @ Mac 10.9: 36\n\n\ntesting: firefox @ Windows 10: 56\n\n\ntesting: android @ Linux: 6.0\n\n\ntesting: safari @ Mac 10.12: 11\n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nfailed:  (0 failed, 0 passed)\n\n\nfailed:  (0 failed, 0 passed)\n\n\nfailed:  (0 failed, 0 passed)\n\n\nfailed:  (0 failed, 0 passed)\n\n\n/home/travis/build/rtfeldman/seamless-immutable/node_modules/zuul/bin/zuul:328\n        throw err.message;\n\n        ^\n\nchrome@45: localtunnel server returned an error, please try again\nCan someone help?. hi @rtfeldman - any chance this could get in? we have a bug open and ignoring Blob (as File is) solves it. Id rather not use my fork in Production... . hi @rtfeldman \nin a project im working on I have an issue in safari. uploads to server are failing because the Blob I reference in my state is being treated as data instead of an object to skip (like File/React/Error). \nThe reason its a Blob and not a File is that creating a File instance from the binary I get (from a 3rd party API) on Safari fails (its empty) and creating a Blob works.\nI think Blob should be treated the same as File, no? \nId be happy to submit a PR that does the same as isFileObject for Blob.\n. Travis build fails with:\n\nzuul -- test/*.spec.js\n\n\n\ntesting: chrome @ Linux: 45\n\n\ntesting: chrome @ Mac 10.11: 62\n\n\ntesting: internet explorer @ Windows 2008: 9\n\n\ntesting: internet explorer @ Windows 2012: 10\n\n\ntesting: internet explorer @ Windows 10: 11\n\n\ntesting: firefox @ Mac 10.9: 36\n\n\ntesting: firefox @ Windows 10: 56\n\n\ntesting: android @ Linux: 6.0\n\n\ntesting: safari @ Mac 10.12: 11\n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nrestarting: \n\n\nfailed:  (0 failed, 0 passed)\n\n\nfailed:  (0 failed, 0 passed)\n\n\nfailed:  (0 failed, 0 passed)\n\n\nfailed:  (0 failed, 0 passed)\n\n\n/home/travis/build/rtfeldman/seamless-immutable/node_modules/zuul/bin/zuul:328\n        throw err.message;\n\n        ^\n\nchrome@45: localtunnel server returned an error, please try again\nCan someone help?. hi @rtfeldman - any chance this could get in? we have a bug open and ignoring Blob (as File is) solves it. Id rather not use my fork in Production... . ",
    "cdomigan": "I think the only way currently is:\nvar a = Immutable({x: {y:1, z:2}});\na.update('x', x => x.without('y'));\n// {x: {z:2}}\nAn equivalent to Immutable.JS deleteIn() would be nice!. I think the only way currently is:\nvar a = Immutable({x: {y:1, z:2}});\na.update('x', x => x.without('y'));\n// {x: {z:2}}\nAn equivalent to Immutable.JS deleteIn() would be nice!. ",
    "raduflp": "I would suggest to make it consistent with setIn and updateIn, i.e. using arrays for nested objects paths\nsomething like a.without(['lvl1_key', 'lvl2_key', ...])\ncurrently the syntax above has the same behaviour as a.without('lvl1_key1', 'lvl1_key2' ... )\nI see little value in having 2 ways of achieving the same effect and adds to the confusion when considering the syntax for setIn etc\nmaybe implementing a withoutIn would be a solution to avoid breaking changes. I would suggest to make it consistent with setIn and updateIn, i.e. using arrays for nested objects paths\nsomething like a.without(['lvl1_key', 'lvl2_key', ...])\ncurrently the syntax above has the same behaviour as a.without('lvl1_key1', 'lvl1_key2' ... )\nI see little value in having 2 ways of achieving the same effect and adds to the confusion when considering the syntax for setIn etc\nmaybe implementing a withoutIn would be a solution to avoid breaking changes. ",
    "Aaronius": "@rtfeldman is this something you would accept a pull request for?. One common painpoint we run into because we don't have a withoutIn() can be seen here:\njs\nlet a = Immutable({});\nif (a.getIn(['a', 'b', 'c'])) {\n  a = a.updateIn(['a', 'b', 'c'], (c) => {\n    return c.without('d');\n  });\n}\nIf we don't do the if statement, the a.b.c chain will get created when we do an updateIn(), which isn't what we want. It would be so much simpler to do:\njs\nlet a = Immutable({});\na = a.withoutIn(['a', 'b', 'c', 'd']);\n. No, because it leads to ambiguity:\nconst fruits = Immutable([3, 2, 1]);\nfruits.without(1); // ?\n. @rtfeldman is this something you would accept a pull request for?. One common painpoint we run into because we don't have a withoutIn() can be seen here:\njs\nlet a = Immutable({});\nif (a.getIn(['a', 'b', 'c'])) {\n  a = a.updateIn(['a', 'b', 'c'], (c) => {\n    return c.without('d');\n  });\n}\nIf we don't do the if statement, the a.b.c chain will get created when we do an updateIn(), which isn't what we want. It would be so much simpler to do:\njs\nlet a = Immutable({});\na = a.withoutIn(['a', 'b', 'c', 'd']);\n. No, because it leads to ambiguity:\nconst fruits = Immutable([3, 2, 1]);\nfruits.without(1); // ?\n. ",
    "pladaria": "Just for reference: https://promisesaplus.com/\n\nTerminology\n\n\u201cpromise\u201d is an object or function with a then method whose behavior conforms to this specification.\n\u201cthenable\u201d is an object or function that defines a then method.\n\n\nI think it's fair to assume that an object or function with a then method is a promise. Anyway, if this gives conflicts, this behaviour could be overridden via config.. Just for reference: https://promisesaplus.com/\n\nTerminology\n\n\u201cpromise\u201d is an object or function with a then method whose behavior conforms to this specification.\n\u201cthenable\u201d is an object or function that defines a then method.\n\n\nI think it's fair to assume that an object or function with a then method is a promise. Anyway, if this gives conflicts, this behaviour could be overridden via config.. ",
    "medovob": "Thanks @pladaria but I think you've just highlighted the clear distinction between the two. Its not safe to assume that a \"thenable\" conforms to the Promise specification.\nThere must be a better way to identify a Promise but I'm not sure what that is. Perhaps something like:\njs\nfunction isPromise(obj) {\n  return typeof obj === 'object' &&\n    typeof obj.constructor === \"function\" &&\n    typeof obj.constructor.resolve === 'function';\n }\n. Yeah - that was my initial thought too but I think the problem is that environments might not support   native promises and even in supporting environments, a developer may be using a Promise polyfill or a Promise compliant lib (like RSVP or Bluebird) and these won't necessarily referenced as the the global Promise which is why I was suggesting testing the object for compatibility rather than strict equality.\nYou could also also use the \"resolver\" to return the promise rather than calling then() and have an additional check to make sure that the \"resolved\" object is \"thenable\"\njs\nif (obj.constructor.resolve) {\n  var resolved = obj.constructor.resolve(Immutable(obj));\n  if (typeof resolved.then === \"function\") {\n    return resolved;\n  }\n}. Thanks @pladaria but I think you've just highlighted the clear distinction between the two. Its not safe to assume that a \"thenable\" conforms to the Promise specification.\nThere must be a better way to identify a Promise but I'm not sure what that is. Perhaps something like:\njs\nfunction isPromise(obj) {\n  return typeof obj === 'object' &&\n    typeof obj.constructor === \"function\" &&\n    typeof obj.constructor.resolve === 'function';\n }\n. Yeah - that was my initial thought too but I think the problem is that environments might not support   native promises and even in supporting environments, a developer may be using a Promise polyfill or a Promise compliant lib (like RSVP or Bluebird) and these won't necessarily referenced as the the global Promise which is why I was suggesting testing the object for compatibility rather than strict equality.\nYou could also also use the \"resolver\" to return the promise rather than calling then() and have an additional check to make sure that the \"resolved\" object is \"thenable\"\njs\nif (obj.constructor.resolve) {\n  var resolved = obj.constructor.resolve(Immutable(obj));\n  if (typeof resolved.then === \"function\") {\n    return resolved;\n  }\n}. ",
    "sandro-pasquali": "Another way to look at this is to normalize all values to promises via Promise.resolve():\nlet imm = Immutable(Promise.resolve(<PromiseOrAnythingElse>)) \nSince it would seem that your implementation expects some Immutable-ized values to be Promises and others not, I think this would mean a consistent interface (always Promises) could be achieved. \nThis may or may not be possible in your case of course.... Another way to look at this is to normalize all values to promises via Promise.resolve():\nlet imm = Immutable(Promise.resolve(<PromiseOrAnythingElse>)) \nSince it would seem that your implementation expects some Immutable-ized values to be Promises and others not, I think this would mean a consistent interface (always Promises) could be achieved. \nThis may or may not be possible in your case of course.... ",
    "foray1010": "would prefer if no change after sort, return the same reference. would prefer if no change after sort, return the same reference. ",
    "srph": "Doesn't Immutable.asMutable(obj, {deep: true}) solve toJS?. Doesn't Immutable.asMutable(obj, {deep: true}) solve toJS?. ",
    "maxgalbu": "Yep that's what I wrote before :). Yep that's what I wrote before :). ",
    "gmeans": "I'm running into the same limitation. @itaysabato have you found a pattern to use as an alternative?. I ended up using a regular merge within the setIn:\n```\nexport const saveAddress = (state = initialState, action) => {\n  const { address, address2, city, province, postal, country, index } = action;\nconst existing = Immutable(state.current.addresses[ index ]);\nreturn Immutable.setIn(state, [ 'current', 'addresses', index ], Immutable.merge(existing, {\n    address,\n    address2,\n    city,\n    province,\n    postal,\n    country,\n  }), { deep: true })\n};\n```\nMaybe my use case is slightly different since I'm directly setting an element at a specific index, but I experienced the same issue you had. After the setIn the resulting object only consisted of what was passed into setIn, wiping out all existing values that I would expect to be merged in.\n. I'm running into the same limitation. @itaysabato have you found a pattern to use as an alternative?. I ended up using a regular merge within the setIn:\n```\nexport const saveAddress = (state = initialState, action) => {\n  const { address, address2, city, province, postal, country, index } = action;\nconst existing = Immutable(state.current.addresses[ index ]);\nreturn Immutable.setIn(state, [ 'current', 'addresses', index ], Immutable.merge(existing, {\n    address,\n    address2,\n    city,\n    province,\n    postal,\n    country,\n  }), { deep: true })\n};\n```\nMaybe my use case is slightly different since I'm directly setting an element at a specific index, but I experienced the same issue you had. After the setIn the resulting object only consisted of what was passed into setIn, wiping out all existing values that I would expect to be merged in.\n. ",
    "tomByrer": "I like the idea, but concerned about performance in production.\nCould dev have a temporary wrapper / Proxy ?. I like the idea, but concerned about performance in production.\nCould dev have a temporary wrapper / Proxy ?. ",
    "svieira": "Just a thought. If it's possible to wrap your code in a \"use strict\" context you can get the behavior you want as attempting to mutate a frozen object already causes an error in strict mode:\n```js\n\n!function() { \"use strict\"; Object.freeze({x: 1, y: 2}).x = 3; }()\nVM286:1 Uncaught TypeError: Cannot assign to read only property 'x' of object '#'\n``. Just a thought. If it's possible to wrap your code in a\"use strict\"` context you can get the behavior you want as attempting to mutate a frozen object already causes an error in strict mode:\n\n```js\n\n!function() { \"use strict\"; Object.freeze({x: 1, y: 2}).x = 3; }()\nVM286:1 Uncaught TypeError: Cannot assign to read only property 'x' of object '#'\n```. \n",
    "pedrogarciyalopez": "same problem. same problem. ",
    "fobos": "@rtfeldman ping. @rtfeldman ping. @rtfeldman ping. @rtfeldman ping. ",
    "tsdexter": "@rtfeldman any idea what might be going on here? Here is some more info from dev tools... looks to me like e is definitely a function... not sure how to debug it further? \nhttps://www.dropbox.com/s/4nwxd7r11d37uw4/Screen%20Shot%202017-05-31%20at%2011.20.28%20AM.png?dl=0. @rtfeldman any idea what might be going on here? Here is some more info from dev tools... looks to me like e is definitely a function... not sure how to debug it further? \nhttps://www.dropbox.com/s/4nwxd7r11d37uw4/Screen%20Shot%202017-05-31%20at%2011.20.28%20AM.png?dl=0. ",
    "sachinB94": "Hey, any update on this? I'm facing a similar issue with the react-native release build. Debug build works fine.\n@tsdexter did you find anything?\nusing v7.1.2. Hey, any update on this? I'm facing a similar issue with the react-native release build. Debug build works fine.\n@tsdexter did you find anything?\nusing v7.1.2. ",
    "UX-Unicorn": "Nevermind I figured it out. I was trying to create an asMutable from object that wasn't imutable. Stupid mistake.. Nevermind I figured it out. I was trying to create an asMutable from object that wasn't imutable. Stupid mistake.. ",
    "chj-damon": "@SergeyAlexeev hi there. I'm wondering the same thing as you were. Is it the right way to do so with seamless-immutable? I see there's no difference as what I usually did without it.. @SergeyAlexeev hi there. I'm wondering the same thing as you were. Is it the right way to do so with seamless-immutable? I see there's no difference as what I usually did without it.. ",
    "TomiS": "Hmm, your code looks a lot like it's made for Immutable.js which is not same as seamless-immutable. Are you sure you installed correct library? :). Hmm, your code looks a lot like it's made for Immutable.js which is not same as seamless-immutable. Are you sure you installed correct library? :). ",
    "DonikaV": "Yes. I thougt it is library for using immutable without types error in TS\n;)\n19 \u0418\u044e\u043b 2017 \u0433. 0:19 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \"Tomi Saarinen\" notifications@github.com\n\u043d\u0430\u043f\u0438\u0441\u0430\u043b:\n\nHmm, your code looks a lot like it's made for Immutable.js which is not\nsame as seamless-immutable. Are you sure you installed correct library? :)\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/228#issuecomment-316201222,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AY5vYryhAN56lC5ZDDMsM0xoGIjJGSFYks5sPSFjgaJpZM4OSj4H\n.\n. Yes. I thougt it is library for using immutable without types error in TS\n;)\n\n19 \u0418\u044e\u043b 2017 \u0433. 0:19 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \"Tomi Saarinen\" notifications@github.com\n\u043d\u0430\u043f\u0438\u0441\u0430\u043b:\n\nHmm, your code looks a lot like it's made for Immutable.js which is not\nsame as seamless-immutable. Are you sure you installed correct library? :)\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rtfeldman/seamless-immutable/issues/228#issuecomment-316201222,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AY5vYryhAN56lC5ZDDMsM0xoGIjJGSFYks5sPSFjgaJpZM4OSj4H\n.\n. \n",
    "RusinovAnton": "This should be closed then?. This should be closed then?. ",
    "dbashford": "Tripped me up too, would be a great addition.. Tripped me up too, would be a great addition.. ",
    "ckeeney": "And a nice copy and paste for installing with both yarn and npm would be nice.. And a nice copy and paste for installing with both yarn and npm would be nice.. ",
    "eseQ": "newState.updateIn(['OFFER_CAMPAING', 'data', offers], offers => offers.without('100'));. newState.updateIn(['OFFER_CAMPAING', 'data', offers], offers => offers.without('100'));. ",
    "markhicken": "I totally agree! Do you think it would also make sense to allow removing by value? \njavascript\nconst fruits = Immutable(['apple', 'banana', 'cherry']);\nfruits.without('banana'); // ['apple', 'cherry']. Ok then, maybe it's a rabbit hole but it seems like most of the time, you would know the value but not the index. How about something like this?\njavascript\nconst fruits = Immutable(['apple', 'banana', 'cherry']);\nfruits.without('banana', { byValue: true }); // ['apple', 'cherry']. I totally agree! Do you think it would also make sense to allow removing by value? \njavascript\nconst fruits = Immutable(['apple', 'banana', 'cherry']);\nfruits.without('banana'); // ['apple', 'cherry']. Ok then, maybe it's a rabbit hole but it seems like most of the time, you would know the value but not the index. How about something like this?\njavascript\nconst fruits = Immutable(['apple', 'banana', 'cherry']);\nfruits.without('banana', { byValue: true }); // ['apple', 'cherry']. "
}