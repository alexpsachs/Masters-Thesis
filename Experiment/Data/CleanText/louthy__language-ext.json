{
    "sgoguen": "I second this.  I'll be happy to add the basic NuGet stuff if you come up with a name and create an account.\n. ",
    "AlexArchive": "Thirded :+1: \nPerhaps issue a release for the time being? \nGreat work by the way, @louthy. This is awesome and so much fun to play with. \n. ",
    "louthy": "On NuGet now.  It's the first time I've made a NuGet package, so if I've messed it up, just shout!  Seems to work for me though.  I had to make it 'pre-release' because it relies on Immutable Collections.  I notice MS have open-sourced IC, so maybe there's an easier way of doing this.\nhttps://www.nuget.org/packages/LanguageExt/0.0.1-beta\nThanks for the kind words @ByteBlast, @sgoguen and @tegeek :) \n. Thanks @ButchersBoy :)\n. Yes, very good idea.  Thanks!\n. The intended use is so decision logic (has value, doesn't have value) can be used in a LINQ join for example.  AsEnumerable could be useful in a lazy stream situation, where it's essentially a switch enabling or disabling the stream.  AsEnumerableOne is essentially a direct conversion of the Option monad into an IEnumerable monad.  So it's purely a type conversion really.\nI agree that both are not needed, AsEnumerable().Take(1) = AsEnumberableOne().  It's purely for convenience.\nHappy to take further feedback on this.\n. Thanks for the feedback @brandf - I think you're right, and have made the necessary modifications.\n. @laynor Yes, good point, I completely forgot about that method.\n. There's no huge reason behind it, I wanted something that was closer to how memoization is done in the functional world.  I'm not a huge fan of having to call Lazy<T>.Value.  it's more compositional because it's a Func.  At the moment it's quite a naive implementation, that was definitely done quicker than it should have been, so I'll return to that and improve it.  I also want to provide Func<T,R> memo(Func<T,R>) which will do it properly.  \nI'll probably look into that this evening actually.  And maybe just make the original memo wrap Lazy also.\n. There's a new version submitted with memo<T> and memo<T,R>.\n. > and you have no eviction policy, your cache will just grow and grow and grow; it's effectively a memory leak.\nit's only a memory leak if you keep hold of a reference to the object.  Dereference the Func<T,R> ;-)\nIt's memoization, not a cache, I know that might seem like a trite response.  But I wouldn't expect memo to be used for caching large amounts of stuff.  Maybe it's just me, but I've probably always associated it with 'short term store' because of its name.  For example, you could use a memo in a Select(..) statement to be a cache of already calc'd values for the duration of the process.\nMaybe I should make that explicit in the comments that it's primarily aimed at short-term caching and not for caching all 4billion+ ints ;-).  I'd rather keep the library focussed on doing a few things well than having a spray of stuff.  So if it causes too much confusion I'd rather remove it altogether than try to accommodate complex caching mechanisms.  \nI don't currently see how your example can do anything other than stop the growth of the cache?  It would grow and grow, then become slow and slow I assume?  Apologies if I'm missing something.  To do a large caching system properly you'd want to know about the age of objects, possible size, etc, so that you could defer the decision about what stays in the cache to a 'cache manager function'.\n. You make a compelling case for sure.  Let me sit on it for a few days.  I'm still in two minds.  I've used memoization very successfully in the past, and it's been a useful tool.  I like the compositional nature of it.  However, I had always written the memo function, so had total knowledge of the side-effect.\nOk, food for thought.  Thanks for putting the effort in to finding all those examples, it's very much appreciated :)\n. @jonpryor - I've tried to come up with a pragmatic middle ground.  Have a look and see what you think.\nIt now:\n- Uses a WeakDictionary from the ch.codeplex.com library, this removes the possibility of memory-leaks whilst maintaining the compositional nature of Func<T,R>.  In a unit-test memoizing 0 to Int32.MaxValue, the NUnit runner never jumped above 45mb.\n- memo() must use a reference type for R, so the old memoization function is kept for completeness, except it's now called memoUnsafe, with warnings in the comments about potential memory leaks.\n. Correct. Thanks @alaendle :)\n. Hi Tommi,\nI'm open to the idea of collaboration for sure, but I'm not particularly up for merging projects.  Let me give you a sense of where I'm at with this and hopefully you'll understand why that is.  \nAbout a year ago I wrote the csharp-monad library (which you've seen the repo for on this github account).  It started off with similar goals to you of bringing a lot of the Haskell and F# loveliness to C#.  I had this utopia in mind where I could write everything as LINQ statements and static functions, and make everything lazy like Haskell.  \nThe reality was slightly more awkward to use and I felt not worth the effort the majority of the time.  So whenever possible when I am writing new fresh code that can take a radically different approach, I use F#.\nSo what's this library for?  Well, I am currently the CTO of a software company in London, and we have something in excess of 5 million lines of code in our primary project.  It's a web-app that's been built upon for nearly 10 years.  It's usually very stable, and is pretty well written.  However there are classes of issues which crop up time and time again (as mentioned in the README.md).  \nIt's not possible to go in and refactor everything into a perfect LINQ statement with immutable everything, we have to be pragmatic.  But I do still want to shut those bugs down, and I suspect plenty of other people do too.  And that's what this library is for.  That pragmatic middle ground.  That's the reason I put very little emphasis on using Option<T> in a LINQ expression, and instead highlighted its use for taming the output of a method.  So this library is:\n- To tame null.\n- To make the three possible outcomes of a method usable in an expression (T|null|Exception).\n- Where possible make it easier to use expressions (tuple, out parameter fixups, pattern matching).\n- To remove the friction from programming in a functional style in C#.  That's what the List/Map/Set/etc. stuff is for.\n- To tame concurrency problems by creating a lightweight process model similar to Erlang processes or Akka actors.\nSo bearing all that in mind I took a look at your library (excellent work btw!) to see if there was anything that would cross-over.  As you say you've focussed on the immutable data structures; but I feel those data structures fall into the 'not needed in this lib' area, especially as it seems the Immutable Collections library is heading straight for the BCL and lazy sequences can be implemented using yield.  It's definitely fun to write that stuff (Here's a toy List implementation I did whilst stuck on a train for a few hours, where List<T> is a delegate: https://gist.github.com/louthy/6fee49d3b21f619a8ead), but I feel it falls into the idealist functional programmer's toolkit rather than the pragmatic one I'm trying to build.  I think the parser monad falls into that area too.  \nWith regards to your C# QuickCheck implementation.  Have you thought about breaking that out into a library on its own?  It seems like it could be a very valuable tool that many wouldn't want mixed up with a general framework (or might be missed).\nSo, I hope you understand my position.  This isn't closing the door, as I say I'm open for collaboration.  I just want to make sure it's focussed on solving problems in C# rather than chasing a fundamentalist approach.  Obviously if there's anything in this lib that you'd like to use in Flop, feel free :)\n. >  but the abstractions and APIs are quite lacking. IEnumerable too, although prevalent and very useful, is still very much an imperative abstraction. My ideal framework for C# would contain not only the data structures but also the abstractions and idioms for writing them. Clojure does a very good job in the JVM world defining a bunch functional abstractions and hiding the imperative Java framework.\nDefinitely interested in some specifics here if you don't mind?  I haven't spent any time with Clojure (other than watching Hickey's excellent talks).  Transducers look very interesting, but beyond that, what is there about the IEnumerable abstraction/API (with LINQ) that doesn't work for you?  The API is mostly renamed versions of accepted functional names (Select = map, Where = filter, Aggregate =  fold etc.).  Obviously the structures of lists/seqs in general are different, the cons cell isn't the same.  But that would mostly lead to stack overflows if you were to follow that approach in C# (mainly talking about user code that consumes head/tail recursively).  So, yeah, curious? :)\n\nI also disagree about parser combinators not being practical.\n\nSorry, if I gave the impression that I think they're impractical.  I think parser combinators are awesome, I just don't think they should be a core framework component, that's all.  I may reconsider that later, at least for the core monad implementation itself.  But I was trying not to get too bogged down in the monad baggage early on.  I think although monads have gotten a lot of attention over the past few years, mostly C# programmers aren't crying out for them.  Without higher-kinded types they're just not quite as generally powerful as in Haskell (as well as lots of lovely operators for general case processing of monadic values).  Parser combinators are probably the best example where monads are obviously a better choice than writing idiomatic C#.  \n\nLanguage-ext in many ways does exactly that as well: it makes C# code look and feel a bit more elegant and cleaner.\n\nI think this is probably a lot to do with my early goals.  Reduce common issues and make C# more elegant.  In addition to that, the actor/process library I'm currently adding is to understand that applications have state, so why not put the state into little functional bubbles.  So actors are essentially message/state fold operations.  It may even be possible to treat the message processing loop as an Expression and deploy remotely.  I'm hoping to bring some of Alan Kay's original ideas for OO (message passing) together with core functional components.\nFinally I'd like to write LanguageExt.FSharp which enables easy interop between C# and F# (and the language-ext types, like Option, that are in F# too).  I already have a number of ideas in this area.\nAnyway, interested in your thoughts?  :)\nPaul\n(PS: re-opening this, cos I'm not sure if you'll get the notification if it remains closed.  Feel free to close it again if you like)\n. I'd like to take this discussion up more, but I'm currently juggling about 4 different projects (bizarrely two of the projects are very related to this discussion... one is using parser combinators to do super-powered string interpolation and another is an data-store indexing solution where I've been implementing a few collection types using AVL trees) so I don't really have time to go as in-depth as I'd like.  If you don't mind I'll try and get back to you next week.\nPaul\n. Hi Kasajian.  Option<T> and Lazy<T> don't perform the same role.  Lazy<T> is deferred processing of a function until the value is required (if at all), and Option<T> is a type that can represent a value or not a value (strictly, there's no laziness to it).  A bit like a regular C# reference where it can be a value or be null; however (unlike a null reference) Option<T> explicitly denies access to the contract of the generic parameter type of the Option, if there isn't a value inside.\nThere is a lazy Option type in the library, and that is TryOption<T>, it's lazy out of necessity due to the fact that it needs to be a delegate so that it can catch any thrown exceptions.  Take a look at TryMonadTests.cs to see some examples.\nLazy<T> is closer to 'memoization' in the functional world.  Take a look at memo function in Prelude_Memoize.cs\nhttp://en.wikipedia.org/wiki/Memoization\n. As I say the behaviour is different.  Using a None doesn't turn it into a Some, that is what happens when you use a Lazy.  Option types are in one state, and they stay in that state.  Lazy start in a 'valueless' state and then gain a value on usage.\n. > First off, this is an awesome library.\nThank you :)\n\nI do have a question about why an option's Value property...\n\nI felt quite strongly after writing csharp-monad - where I also implemented the Option type, and I added GetValueOrDefault(), HasValue and Value that the main reason for using Option was to enforce correctness.  Otherwise there's very little difference between a reference type.  There would be one difference of course, and that is that the optional nature of a method's return type is explicitly declared; and I agree that in itself is useful.  However, I'd rather err on the side of correctness.\nHowever you can easily add your own extension methods if you disagree with my views:\nC#\n    public static class OptionValueExt\n    {\n        public static T Value<T>(this Option<T> self) =>\n            match(self,\n                Some: value => value,\n                None: ()    => raise<T>(new ValueIsNoneException())\n            );\n        public static T ValueUnsafe<T>(this OptionUnsafe<T> self) =>\n            matchUnsafe(self,\n                Some: value => value,\n                None: ()    => raise<T>(new ValueIsNoneException())\n            );\n        public static T TryValue<T>(this TryOption<T> self) =>\n            match(self,\n                Some: value => value,\n                None: ()    => raise<T>(new ValueIsNoneException()),\n                Fail: ex    => raise<T>(new InvalidOperationException(\"Value not set\",ex))\n            );\n    }\nThen you can use it like so:\nC#\n    var x = Some(\"thing\");\n    if( x.IsSome )\n    {\n        Console.WriteLine(\"The value is \" + x.Value() );\n    }\nI hope that helps :)\n. There is already implicit coercion, so that isn't currently needed:\n``` C#\n   // This is coerced to Some(\"hello, world\")\n   Option optional1 = \"hello, world\";\n// This is coerced to None\n   string s = null;\n   Option optional2 = s;\n```\nHowever, I have been considering an explicit Option() constructor which does the same.  It's then closer to how its done in other languages like Scala.  The original reason for the implicit conversion was to make the usage of Option types as seamless as possible.  I can see however that some people would like an explicit constructor.\nSo, yeah, it's likely to go in soon.  I am just currently in two minds about whether to remove the implicit coercion.\n. Oh, right I see your point now.  I think however it's still important to have Some\nThe problem with coercion, whether implicit or explicit, is that it can allow an invalid state to wander quite far from its source.  So if Option(null) coerces nicely into None, then it can be returned from a method, and passed around a lot before something raises its hand and says 'hold on, this should be Some'.  If a piece of code is written that says: \"this is definitely a value, so I'm wrapping it in Some\", and it then bombs because actually the value is null.  That's a good thing.  it's not about never blowing up, it's about stopping the propagation of invalid state and about making intentions explicit.\nThat's also why it might be a good idea to drop the implicit coercion.\nI hope that explains my thinking.  It's a bit rambling, sorry.\n. > First change: The overrides which call CheckInitialized ...\nYep, some silly mistakes there.  I've taken a different approach to fixing it:\n``` C#\n        public T Value => \n            CheckInitialised(value);\n    public static implicit operator T(Some<T> value) => \n        value.Value;\n\n    public override string ToString() =>\n        Value.ToString();\n\n    public override int GetHashCode() =>\n        Value.GetHashCode();\n\n    public override bool Equals(object obj) =>\n        Value.Equals(obj);\n\n```\nIt puts slightly more burden on the Value access, but I think overall it's cleaner.  \n\nFor performance reasons, the CLR will not call the default constructor on struct arrays.\n\nIt's not the CLR, it's the C# compiler.  It could easily call the same series of op-codes that it does for classes.  It is however (like you say) an optimisation.  I believe the C# team are discussing default constructors for the final C# 6.  So we'll see how that goes.  Until then Some<T> will always be a weak solution to this problem.  \nI do discuss this on the project home page, and explain its limitations.  I think only using Some<T> for method arguments, and never instantiating them manually is probably the best use of a weak solution.\nThanks for the heads up on the bugs!\n. (Sorry about the slowness of replying, my real-world workload is off the scale at the moment)\nI'm sure I had a good reason for this at the time.  This is the second implementation of Either that I've done (the first in the csharp-monad project).  I seem to remember feeling that the 'subject' of a multivalue type should be first in the list.  Because Left means 'wrong', or 'other', in this sense, I felt it should be last in the list.  But I can see your PoV.\nMy concern with changing this is that it's a horrible breaking change for others using the library.  I guess the other way to think about it, is it's the right way around if you're an Either looking out, rather than a human looking in ;-)\nAnyway, I think I'd like some more views from people already using the library before making any change. \n. Ok, I decided to bite the bullet and change this.  It's a pretty tedious breaking change (I've just been through my own code fixing it up), but I think you're both right overall.  I also had the same comments on my other monad project, so I think it's time to accept that I was wrong and just fix it.\nThere's a new github and nuget release.\n. Hi Tomasz, yes map would make sense, although I think iter would be confusing, as it's not really iteration.  I previously named it apply, which was OK, but still not accurate.  Calling both map would also work, the mappings would be from tuple -> T and tuple -> unit, which is fine (although do would be better if I could use it - unfortunately it's a reserved keyword).  If it returned void then map wouldn't really make sense.  decompose is too long, decom not descriptive enough.\nUltimately there wasn't a big idea behind using with other than a declaration of putting something in context.  There are other with functions which could probably be named map also.\nI will probably revisit some of the API over the next few weeks (to get everything ready for the proper release of C# 6), so I may take your comments on-board.\nThanks for the feedback :)\nPaul\n. Hi @Silv3rcircl3 thanks for bringing this up.  I don't ever use WPF (more of a web-guy), so I just need a bit of clarification on how the data-binding works:\nI can see the ConvertFrom makes sense.  It allows any value to be wrapped in an Option<_>.  But ConvertTo appears to require conversion from Option<T> (?) to destinationType.  \nSo a couple things:\n1. If optionValue is not an IOptionalValue it just returns the value, not converted.  Is that right?\n2. If optionValue.IsNone then it returns null, how does that work when destinationType is a value type?\n3. Does null have the same semantic meaning to the data-binding system as None?\n4. If there is a value, then you're just getting it and returning it.  Shouldn't it Convert.ChangeType(value.Value,destinationType)\nApologies for not knowing this stuff, I tend to steer clear of the big .NET APIs and prefer my own hand-rolled data-binding solutions.\n. Ok, so these are my thoughts:\n1. It's not entirely clear whether your implementation of the TypeProvider is the 'correct' way (or if in fact there is a correct way)\n2. It's not totally clear what the WPF data-binding system will do with the returned value.\n3. I have very little experience in this area and that will make proving the correctness of any changes difficult.\nI already have a prototype version in code, with a slightly cleaned up version of yours.  I think there are still a few too many unknowns here.  So I'll do a little bit more digging.  If you could mock up a small test harness that would be very useful?\nThis is what my version looks like, I've tried to add some bulletproofing in case our assumptions are wrong:\n``` C#\n    public class OptionalTypeConverter : TypeConverter\n    {\n        static readonly Func methods = null;\n        static readonly MethodInfo optional = null;\n    static OptionalTypeConverter()\n    {\n        optional = (from info in typeof(Prelude).GetMethods()\n                    where info.Name == \"Optional\"\n                    select info)\n                   .Single();\n\n        methods = memo((Type valueType) => optional.MakeGenericMethod(valueType));\n    }\n\n    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) =>\n        true;\n\n    public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) =>\n        true;\n\n    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) =>\n        value == null\n            ? None\n            : methods(value.GetType())?.Invoke(null, new[] { value });\n\n    public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) =>\n        value == null\n            ? null\n            : (value as IOptionalValue)?.MatchUntyped(\n                  Some: x => x == null\n                                 ? null\n                                 : destinationType.IsAssignableFrom(x.GetType())\n                                    ? x\n                                    : x.GetType() == typeof(string)\n                                        ? x.ToString()\n                                        : typeof(IConvertible).IsAssignableFrom(destinationType)\n                                            ? Convert.ChangeType(x, destinationType)\n                                            : null,\n                  None: () => null);\n}\n\n```\nThings to note that are different to yours:\n1. The reflection for finding the generic method Optional<T>(...) is now memoized, so it's cached on first use.  That mitigates the performance penalty as much as possible.\n2. ConvertFrom is simplified because of 1.\n3. ConvertTo assumes that value is an IOptionalValue\n4. ConvertTo uses a new MatchUntyped method I have added to IOptionalValue which matches with object values.\n5. ConvertTo first checks if the T of Option<T> to see if it is assignable to the destinationType (therefore not requiring a conversion); if so it returns it as-is.  It then checks if the destinationType is a string (which from me reading seems to be the most common requirement), if so it simply calls ToString().  If not it checks if it's IConvertible; if it is then it calls ChangeType(), if not it returns null.\nThe null is None thing I guess we just need to see how it works in the real world with WPF.  So the test-harness is essential.\nHere's a build with Some<T> and Option<T> using OptionalTypeConvertor and SomeTypeConvertor:\nhttps://www.dropbox.com/s/x20q8rro1ms8tkm/lang-ext-type-conv-1.rar?dl=0\n. Ok, so I did a bit more research, and the proper implementation of a TypeProvider for something like an Option type (i.e. a type that wraps another) is this:\n``` C#\n    public class OptionalTypeConverter : TypeConverter\n    {\n        static readonly Func methods = null;\n        static readonly MethodInfo optional = null;\n    readonly Type optionType;\n    readonly Type simpleType;\n    readonly TypeConverter simpleTypeConverter;\n\n    static OptionalTypeConverter()\n    {\n        optional = (from info in typeof(Prelude).GetMethods()\n                    where info.Name == \"Optional\"\n                    select info)\n                   .Single();\n\n        methods = memo((Type valueType) => optional.MakeGenericMethod(valueType));\n    }\n\n    public OptionalTypeConverter(Type type)\n    {\n        optionType = type;\n        simpleType = type.GetGenericArguments().Single();\n        simpleTypeConverter = TypeDescriptor.GetConverter(simpleType);\n    }\n\n    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) =>\n        sourceType == simpleType\n            ? true\n            : simpleTypeConverter == null\n                ? base.CanConvertFrom(context, sourceType)\n                : simpleTypeConverter.CanConvertFrom(context, sourceType);\n\n    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) =>\n        value == null\n            ? None\n            : value.GetType() == simpleType\n                ? methods(value.GetType())?.Invoke(null, new[] { value })\n                : value is string && String.IsNullOrEmpty(value as string)\n                    ? None\n                    : simpleTypeConverter == null\n                        ? base.ConvertFrom(context, culture, value)\n                        : methods(value.GetType())?.Invoke(\n                            null,\n                            new[] { simpleTypeConverter.ConvertFrom(context, culture, value) }\n                            );\n\n    public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) =>\n        destinationType == simpleType\n            ? true\n            : destinationType == typeof(InstanceDescriptor)\n                ? true\n                : simpleTypeConverter == null\n                    ? base.CanConvertTo(context, destinationType)\n                    : simpleTypeConverter.CanConvertTo(context, destinationType);\n\n    private object ConvertToValueNull(ITypeDescriptorContext context, CultureInfo culture, Type destinationType) =>\n        destinationType == typeof(string)\n            ? String.Empty\n            : base.ConvertTo(context, culture, null, destinationType);\n\n    public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) =>\n        value == null\n            ? ConvertToValueNull(context, culture, destinationType)\n            : (value as IOptionalValue)?.MatchUntyped(\n                  Some: x => destinationType == simpleType\n                                 ? x\n                                 : destinationType == typeof(InstanceDescriptor)\n                                     ? new InstanceDescriptor(\n                                           optionType.GetConstructor(new Type[] { simpleType }),\n                                           new object[] { value },\n                                           true)\n                                     : x == null\n                                         ? ConvertToValueNull(context, culture, destinationType)\n                                         : simpleTypeConverter == null\n                                            ? base.ConvertTo(context, culture, x, destinationType)\n                                            : simpleTypeConverter.ConvertTo(context, culture, x, destinationType),\n                  None: () => ConvertToValueNull(context, culture, destinationType));\n}\n\n```\nWhy anybody would use these methods and put themselves through this torture is beyond me ;)\nAnyway, you can grab a new test build from here:\nhttps://www.dropbox.com/s/yvshwciz9b51kvf/lang-ext-type-conv-3.rar?dl=0\nLet me know if it works for you.\n. > you use value.GetType but it must be simpleType.\nFixed\n\nAnd Prelude contains Optional(T) and Optional(Nullable)\n\nFixed\n\nAnother problem is binding a ListBox to Option>, because Option implements IEnumerable the binding isn't calling the TypeConverter but calls directly IEnumerator IEnumerable.GetEnumerator() from Option.\n\nYou'd have to manually unwrap that I think:\nC#\n    var list = from x in option\n               from y in x\n               select y;\n(You'll get an empty list if option is None)\n\nOne last thing, do you know that the static using has changed?\n\nYep, I know that.  I'd rather not keep chasing the last minute syntax changes, so I'm going to keep it as-is until the final release then I'll go through and update everything.  Although I guess if people are using the later CTP for VS2015 then it could come to a head.  I do make sure I keep nuget up to date though. \n\nCould you explain me when some should be used for member declaration(of course only in the scope of a view model)?\n\nSome<T> is a bit of a problem child due to the problem of uninitialised structs not calling a default ctor.  So I personally only use them for method parameters to enforce non-null arguments.  \n\nSo the some converter should not check for empt string, but rather let the simpletypeconverter handle this case, because it should work for some but not for some.\n\nFixed (I think)\n\nWith all this in mind, I would never bind to Some\n\nI think it's probably best. \n\nHi, just throwing in my tuppence worth, but as a WPF developer, that TypeConverter is pure ugly.\n\nI agree it's ugly, I'm glad I don't have to use .NET binding on a regular basis! ;-)\n\nWhy bind directly to the Option<>, when you can wrap/convert it in some kind of proxy for view-time? \n\nI think mainly because Option<T> should be seen as a fundamental type like Nullable<T>.  It would be very un-DRY to keep having to unwrap I would have thought?  I looked at the source for the Nullable<T> TypeConverter and followed the pattern laid down there.  So that's where the ugliness comes from, ha!  \nI don't doubt there are more optimal ways to do this; but I suspect not everyone needs to have a super high-performance UI for a few textboxes/checkboxs/lists and the like.   I don't mind working on this to get it to work for those use cases.  \n\nYour model/domain layer is mutable. I always strive to have an immutable domain object. If it needs to change, you replace it. Which is the same with Option<>. Even if the backing store (whatever that may be) only updates on application exit, it is good practice.\n\nSound advice.\nLatest version: https://www.dropbox.com/s/d58ggeqfaa77712/lang-ext-type-conv-4.rar?dl=0\n. That would be appreciated, yes.  Then I can create some unit-tests using that as a reference.\nThanks :)\n. @Silv3rcircl3 it's pre-alpha for sure.  At the moment I'm bogged down with other projects, so I don't have time to delve further into this.  The general idea (on top of the other functional friendly aspects of this library) is to build an Erlang-like actor system.  I like the idea of calling them processes, and keeping the idea that each process is an atom of computation.  \nI'm currently not happy with the effectful nature of calls to tell, spawn, pub, etc. I'd like to remove them and replace them with a more functional system that hangs off the return value of the process-function.  Then extend that further by supporting a process IO monad that implements lazy IO like the Haskell IO monad.  It can be implemented using a Free monad which would build IO actions (tell, pub, etc.) and continuations.  The result can then be passed to an interpreter which does the execution (that also allows for dependency injection and unit-testing).\nAll this would mean you could wrap your lovely purely functional code in actors, and the actors can be the state holders with bulletproof messaging between them.\nAnyway, yeah that's the goal.  Hopefully I'll get some time to come back to it.  But if you fancy running with it I'd be happy to help and give feedback.\n. Hi Samir, I see a couple of options for you:\n1. The WeakDictionary is used in exactly one place: the memo function.  You could fork language-ext, delete that function and remove the ConcurrentHashTable folder.  Or...\n2. If you can find an MIT licensed WeakDictionary equivalent, then I would be happy to update the library to use it.  Or...\n3. Feel free to implement the same behaviour of WeakDictionary and submit a pull request.\nTo be clear the behaviour is more than just being a concurrent dictionary, it's a weak-reference concurrent dictionary (with weak keys too).  This is the description of WeakDictionary:\n/// Represents a thread-safe collection of key-value pairs that can be accessed\n/// by multiple threads concurrently and has weak references to the values.\n/// Whenever any of the values held by this dictionary is garbage collected the key-value pair holding the value will be removed from the dictionary.\nMy plan was that usage of the Concurrent Hashtable library would be temporary, so the plan was to take it away.  It's definitely something I will fix eventually, I just can't guarantee when at the moment.\n. Yep, I was convinced I'd changed those!  Ok, I'll sort it.\n. This works fine for me on the NUnit standalone app.  I'm not sure what NCrunch is, but it looks like it's doing some code injection if TestCoverageEventListener is at the top of the stack.  So I suspect it's eagerly evaluating:\nrange(0, Int32.MaxValue).AsQueryable()\nThere is no bug in the test as far as I am concerned.\n. My apologies, I have repro'd this now.  I will re-open.\n. F# doesn't have implicit conversion, but you can provide your own operator to do the job:\n``` F#\nopen System\nopen LanguageExt\nlet inline (!>) (x:^a) : ^b = ((^a or ^b) : (static member op_Implicit : ^a -> ^b) x)\nlet test (a : int Some) = \n    Console.WriteLine a\n    (int)a\nlet addTest1 (a : int Some) (b : int Some) = \n    (int)a + (int)b\nlet addTest2 (a : int Some) (b : int Some) = \n    a.Value + b.Value\nlet strTest (a : string Some) (b : string Some) = \n    a.Value + b.Value\n[]\nlet main argv = \n    let a = test !> 100\n    let b = addTest1 !>2 !>2\n    let c = addTest2 !>2 !>2\n    let d = strTest !>\"Hello\" !>\"World\"\n    0\n``\n. The problem is thatstruct` doesn't support covariance.  So there's no easy fix for this.  \nFor example this below won't work:\n``` C#\n        public static void Foo(Some> val)\n        {\n        }\n    public void SomeCastTest1()\n    {\n        var some = new Some<List<string>>(new List<string>() { \"a\", \"b\", \"c\" });\n        Foo(some);\n    }\n\n```\nBut this will:\nC#\n        public void SomeCastTest2()\n        {\n            Foo(new List<string>() { \"a\", \"b\", \"c\" });\n        }\nSo you could either not pass Some<T> into functions, and only use them to protect function parameters.  Or, you could manually extract the .Value\nC#\n        public void SomeCastTes3()\n        {\n            var some = new Some<List<string>>(new List<string>() { \"a\", \"b\", \"c\" });\n            Foo(some.Value);\n        }\nOr you could implement your own cast method:\nC#\n        public static Some<R> Cast<T, R>(Some<T> value) where T : R =>\n            value.Value;\nThe problem with that is the type-inference system is poor in c# so you end up with lots of type boilerplate:\nC#\n            Foo(Cast<List<string>,IEnumerable<string>>(some));\nSo unfortunately there aren't any perfect solutions here.\n. Hi @donners77 ,\nIf I'm honest I haven't spent too much time thinking about it, no.  I'd be slightly reluctant to add ToSome() as an extension method to T, mainly because it then pollutes the intellisense for everything, and I think that's a bit too much of an intrusion by a library, especially for those who don't use the Some<T> type, but are using other aspects of the library.\nObviously ToSome() works because it's not doing implicit type casting of a T to a Some<T>, it's passing a T to the constructor of Some<T> where the implicit type casting of T happens.  Until struct can do covariant implicit type-casting I think you're stuck with ToSome() as a solution.  You'll just need to create it yourself.\nI guess one way could be to put the extension method into its own namespace.  Perhaps LanguageExt.SomeHelp.  That would mean you could opt into it.  I guess I'd be amenable to this idea.  What do you think?\n. Cool, I've now added this to the LanguageExt.SomeHelp namespace.  Thanks for the suggestion :)\n. Hi @KodrAus - Not sure I entirely follow your examples, but I have added additional functions to the Prelude called curry and par for currying and partial application respectively.  You will need to build from source to use it because I'm not going to be doing a release just yet as I have been making some large changes to the SelectMany binding.\nAnyway, usage is thus:\n``` C#\n    var add = curry((int x, int y) => x + y);\nvar res = add(2)(2);\n\n```\nYou can also create a partially applied function using curry:\nC#\n    var add = curry((int x, int y) => x + y);\n    var add10 = add(10);\n    var res = add10(5);\nYou can do this for functions up to 7 arguments in length.  Obviously it gets a bit unwieldy if you're writing this:\n``` C#\n    var add = curry((int a, int b, int c, int d, int e, int f, int g) \n        => a + b + c + d + e + f + g);\nvar res = add(1)(2)(3)(4)(5)(6)(7);\n\n```\nSo there's a partial application function called par.  It will allow functions of up to 7 parameters, but it also allows you to specify up to N-1 arguments:\n``` C#\n    var add10 = par((int a, int b) => a + b, 10);\n    var res = add10(1);\nvar add30 = par((int a, int b, int c, int d, int e) \n    => a + b + c + d + e, 10, 20);\n\nres = add30(1)(2)(3);\n\n```\nIf you only need to partially apply all but the last one or two arguments in a function then using par will be more efficient than currying with curry and then partially applying.   \nAnyway, I hope that helps.\n. @KodrAus \n\nI hadn't seen that on the readme. \n\nI just wrote it based on your request ;)\nYes, there's an override for each number of args a function might have.  It's just a bit of upfront typing for a prettier end result.  If you need more than 7 parameters for a function then I think you could argue that's a bit of a code smell and you'd benefit from simplifying the interface / wrapping up values into records.\nI mostly chose 7 as the number because I implemented the tuple function first (now Tuple in the latest version); I based it on Tuple.Create(...), which has multiple overrides up to 7 items.  However it has a final override that takes an 8th argument.  The 8th argument is another Tuple, so that might be where you got the 16 number from?  Or it could be that Func itself can take up to 15 args+1 return type.\nIf you feel 7 isn't enough I can add some more?\n. @KodrAus \nI decided to change the par function to just return a multi-argument function rather than a curried function.  I feel that's closer to the real definition of partial application.\nSo instead of this:\n``` C#\nvar four = par((int a, int b, int c, int d) => a  + b + c + d, 10, 20);\nvar res = four(1)(1);\n```\nYou would instead do:\nC#\nvar res = four(1,1);\nIf you want the previous behaviour you can curry the result of par:\n``` C#\nvar four = curry(par((int a, int b, int c, int d) => a  + b + c + d, 10, 20));\nvar res = four(1)(1);\n```\nI have also added overrides for up to 10 generic arguments + 1 return.  My eyes start to go funny when I do any more! \n. Hi @ricardopieper \n\nFirst of all, great work in this library.\n\nThanks...  It's always nice to hear somebody's getting some use from it! :)\nI have added some extra match functions for Option<T> and OptionUnsafe<T> (I'll put others in when I get some time).  As well as tasks I have put in match functions for IObservable<T>.  Unfortunately because the type signatures conflict with the existing match functions, I had to call them MatchAsync.  I really don't like the Async suffix, but I don't really have many options.\nSo, there's:\n``` C#\n    // This is your first request\n    Task MatchAsync(Func> Some, Func None);\n// This is your second\nTask<R> MatchAsync<R>(Func<T, Task<R>> Some, Func<Task<R>> None);\n\n// Same as your first request, but with observable\nIObservable<R> MatchAsync<R>(Func<T, IObservable<R>> Some, Func<R> None);\n\n// Same as your second request, but with observable\nIObservable<R> MatchAsync<R>(Func<T, IObservable<R>> Some, Func<IObservable<R>> None);\n\n```\nThen there are some extension methods to Option<T> and OptionUnsafe<T>\n``` C#\n    // So instead of an Option, this deals with an Optional Task\n    // It runs the task asynchronously (if Some) and returns the result in a new Task\n    Task MatchAsync(this Option> self, Func Some, Func None);\n// This is the same as above, but for observable\nIObservable<R> MatchAsync<T, R>(this Option<IObservable<T>> self, Func<T, R> Some, Func<R> None);\n\n```\nThe next one is a fun one.  It takes a stream of options, and matches them into a new stream\n``` C#\nIObservable<R> MatchAsync<T, R>(this IObservable<Option<T>> self, Func<T, R> Some, Func<R> None)\n\n```\nAlso, if you're doing any async work in general, you may want to take a look at the LanguageExt.Process project.  It's an 'Erlang like' process system (actors).  Each process you spawn is very lightweight, you can spawn 10s of 1000s of them no problem.  They each have an inbox where they process one message at a time, so perfect for designing concurrent systems.  I have plugged it into Redis, so you can do fast inter-system communication, it has atomic message queues, state persistence, etc.  It's still alpha, so be careful, but you may find something interesting in there.  There are 4 samples:\nProcessSample - spawns 3 processes, one logger, one that sends a 'ping' message and one that sends a 'pong' message.  They schedule the delivery of messages every 100 ms.  The logger is simply: Console.WriteLine:\n``` C#\n            // Log process\n            var logger = spawn(\"logger\", Console.WriteLine);\n        // Ping process\n        ping = spawn<string>(\"ping\", msg =>\n        {\n            tell(logger, msg);\n            tell(pong, \"ping\", TimeSpan.FromMilliseconds(100));\n        });\n\n        // Pong process\n        pong = spawn<string>(\"pong\", msg =>\n        {\n            tell(logger, msg);\n            tell(ping, \"pong\", TimeSpan.FromMilliseconds(100));\n        });\n\n        // Trigger\n        tell(pong, \"start\");\n\n```\nThen there's RedisInboxSample.  It sends 100 messages to a process, the process's inbox is persisted to Redis.  The inbox intentionally reads them slowly, so you can quit the app, re-open, and it carries on reading:\n``` C#\n        static void Main(string[] args)\n        {\n            // Connect to the Redis cluster\n            RedisCluster.register();\n            Cluster.connect(\"redis\", \"redis-test\", \"localhost\", \"0\");\n        // Spawn the process\n        var pid = spawn<string>(\"redis-inbox-sample\", Inbox, ProcessFlags.PersistInbox);\n\n        var rnd = new Random();\n        for (var i = 0; i < 100; i++)\n        {\n            tell(pid, \"Message sent: \" + DateTime.Now + \" \" + DateTime.Now.Ticks + \" \" + rnd.Next());\n        }\n    }\n\n    //  Inbox message handleer\n    static void Inbox(string msg)\n    {\n        Console.WriteLine(msg);\n        Thread.Sleep(200);\n    }\n\n```\nA super fast pub/sub system in RedisPublishSample:\n``` C#\n        static void Main(string[] args)\n        {            // Connect to the Redis cluster\n            RedisCluster.register();\n            Cluster.connect(\"redis\", \"redis-test\", \"localhost\", \"0\");\n        // Launch a process that publishes a random number as fast as possible\n        var pid = spawn<Random, int>(\"redis-pubsub-random-test\", Setup, Inbox, ProcessFlags.RemotePublish);\n\n        // Listen to the published results coming back from the Redis channel\n        subscribe<int>(pid, Console.WriteLine);\n\n        // Start it off by sending the first message\n        tell(pid, 0); \n    }\n\n    //  Get the initial state of the process\n    static Random Setup() => new Random();\n\n    //  Inbox message handleer\n    static Random Inbox(Random rnd, int value)\n    {\n        publish(value);\n        tellSelf(rnd.Next());\n        return rnd;\n    }\n\n```\nFinally the RedisStateSample where it persists the process's state after each message.  \n``` C#\n        static void Main(string[] args)\n        {\n            // Connect to the Redis cluster\n            RedisCluster.register();\n            Cluster.connect(\"redis\", \"redis-test\", \"localhost\", \"0\");\n        // Spawn the process\n        var pid = spawn<int, int>(\"redis-state-sample\", Setup, Inbox, ProcessFlags.PersistState);\n\n        // Subscribe locally to the state changes\n        observeState<int>(pid).Subscribe(Console.WriteLine);\n\n        // Start it off by sending the first message\n        tell(pid, 1);\n    }\n\n    //  Get the initial state of the process\n    static int Setup() => 0;\n\n    //  Inbox message handleer\n    static int Inbox(int state, int value)\n    {\n        state += value;\n        tellSelf(value,TimeSpan.FromSeconds(1));\n        return state;\n    }\n\n```\nThis is all checked into the master branch.  It's not on NuGet yet, although I'll probably be doing an alpha release soon.  There's lots of big updates from the past 6 months or so.\n. Yes, it's very much like Akka.  Akka is much more mature than this, and very active, so you should definitely check that out too.  I tried Akka about a year ago; initially I liked it, but became frustrated with it.  It was pre-release, so I'm sure it's improved a lot since then.  I was mainly using the F# wrapper for their API which was quite nice, but limited.  When I looked at the C# API it left me a little cold to be honest.  This is just a personal preference, so don't let that put you off checking it out.\nMy personal view is that the Actor model + functional message loops is the perfect programming model.  \nPurely functional programming without the actor model at some point needs to deal with the world, and therefore needs statefullness.  So you end up with imperative semantics in your functional expressions (unless you use Haskell).  \nNow you could go the Haskell route, but I think there's something quite perfect about having a bag of state that you run expressions on as messages come in.  Essentially it's a fold over a stream.\nThe things that I felt I was missing when I tried Akka was that it didn't seem to acknowledge anything outside of its system.  Now I know that the Actor model is supposed to be a self contained thing, and that's where its power lies, but in the real world you often need to get information out of it, and declaring another class to receive a message was getting a little tedious.  So what I've done is:\nRemove the need to declare new classes for processes (actors)\nIf your process is stateless then you just provide an Action<TMsg> to handle the messages, if your process is stateful then you provide a Func<TState> setup function, and a Func<TState,TMsg, TState> to handle the messages.  This makes it much easier to create new processes and reduces the cognitive overload of having loads of classes for what should be small packets of computation.\nYou still need to create classes for messages and the like, that's unavoidable (Use F# to create a 'messages' project, it's much quicker and easier).  But also, it's desirable, because it's the messages that define the interface and the interaction, not the processing class.\nSo as with my first example, creating something to log string messages to the console is as easy as:\n``` C#\n    var log = spawn(\"logger\", Console.WriteLine);\ntell(log, \"Hello, World\");\n\n```\nOr if you want a stateful, thread-safe cache:\n``` C#\n    public enum CacheMsgType\n    {\n        Add,\n        Remove,\n        Get,\n        Flush\n    }\nclass CacheMsg\n{\n    public CacheMsgType Type;\n    public string Key;\n    public Thing Value;\n}\n\npublic ProcessId SpawnThingCache()\n{\n    return spawn<Map<string, Thing>, CacheMsg>(\n        \"cache\",\n        () => Map<string, Thing>(),\n        (state, msg) =>\n              msg.Type == CacheMsgType.Add    ? state.AddOrUpdate(msg.Key, msg.Value)\n            : msg.Type == CacheMsgType.Remove ? state.Remove(msg.Key)\n            : msg.Type == CacheMsgType.Get    ? state.Find(msg.Key).IfSome(reply).Return(state)\n            : msg.Type == CacheMsgType.Flush  ? state.Filter(s => s.Expiry < DateTime.Now)\n            : state\n    );\n}\n\n```\nThe ProcessId is just a wrapped string path, so you can serialise it and pass it around, then anything can find and communicate with your cache:\n``` C#\n    // Add a new item to the cache\n    tell(cache, new CacheMsg { Type = CacheMsgType.Add, Key = \"test\", Value = new Thing() });\n// Get an item from the cache\nvar thing = ask<Thing>(cache, new CacheMsg { Type = CacheMsgType.Get, Key = \"test\" });\n\n// Remove an item from the cache\ntell(cache, new CacheMsg { Type = CacheMsgType.Remove, Key = \"test\", Value = new Thing() });\n\n```\nThen you periodically want to flush the cache contents.  Just fire up another process, they're basically free (and by using functions rather than classes, very easy to put into little worker modules):\n``` C#\n    public void SpawnCacheFlush(ProcessId cache)\n    {\n        // Spawns a process that tells the cache process to flush, and then sends\n        // itself a message in 10 minutes which causes it to run again.\n        var flush = spawn(\n            \"cache-flush\", _ =>\n            {\n                tell(cache, new CacheMsg { Type = CacheMsgType.Flush });\n                tellSelf(unit, TimeSpan.FromMinutes(10));\n            });\n    // Start the process running\n    tell(flush, unit); \n}\n\n```\nSo as you can see that's a pretty powerful technique.  Remember the process could be running on another machine, and as long as the messages serialise you can talk to them by process ID.  \nWhat about a bit of load balancing?  This creates 100 processes, and as the messages come in to the parent indexer process, it automatically allocates the messages to its 100 child processes in a round-robin fashion:\nC#\n    var load = spawnRoundRobin<Thing>(\"indexer\", 100, DoIndexing);\nAdded a publish system to the processes\nSo if as process needs to announce something it just calls:\nC#\n    publish(msg);\nAnother process can subscribe to that by calling:\nC#\n    subscribe(processId);\n(it can do this in its setup phase, and the process system will auto-unsub when the process dies, and auto-resub when it restarts)\nThen the messages that are published by one process can be consumed by any number of others (via their inbox in the normal way).  I found I was jumping through hoops to do this with Akka.  There are 'official' actor ways of doing this, but sometimes, as I say, you want to jump outside of that system.\nFor example, if your code is outside of the process system, it can get an IObservable stream instead:\nC#\nvar sub =  observe<Thing>(processId).Subscribe( msg => ...);\nA good example of this is the 'Dead Letters' process, it gets all the messages that failed for one reason or another (serialisation problems, the process doesn't exist, the process crashed, etc.).  All it does is call publish(msg).  This is how it's defined:\nC#\n    var deadLetters = spawn<object>(\"dead-letters\",publish);\nThat's it!  For a key piece of infrastructure.  So it's then possible to easily listen and log issues, or hook it up to a process that persists the dead letter messages.\n'Discoverability'\nI was struggling to reliably get messages from one machine to another, or to know the process ID of a remote actor so I could message it.  This was before they did their cluster work I think, so I assume these problems are solved now.  But what I want to do with this is to keep it super light, and lean.  I want to keep the setup options simple, and the 'discoverability' easy.\nSo there's a supervision hierarchy like Akka, where you have a root node, then a child user node, and then you create your processes under the user node.  There's a system node that handles stuff like dead-letters and various other housekeeping tasks.\nC#\n    /root/user/...\n    /root/system/dead-letters\n    etc.\nBut when you create a Redis cluster connection the second argument is the name of the app/service/website, whatever it is that's running.  \nC#\n    RedisCluster.register();\n    Cluster.connect(\"redis\", \"my-stuff\", \"localhost\", \"0\");\nThen your user hierarchy looks like this:\nC#\n    /root/my-stuff/...\nSo you know where things are, and what they're called, and they're easily addressable.  You can just 'tell' the address:\nC#\n    tell(\"/root/my-stuff/hello\", \"Hello!\");\nEven that isn't great if you don't know what the name of the 'app' is running a process.  So processes can register by a single name, that goes into a 'shared hierarchy':\n/root/registered/...\nTo register:\nC#\n    register(myProcessId, \"hello-world\");\nThen anyone else can tell by name:\nC#\n    tell(find(\"hello-world\"), \"Hi!\");\nStyle\nThe final thing was just style really, I wanted something that complemented the Language-Ext style, was  'functional first' rather than as an afterthought.  I think it's looking pretty good (files to look at are Prelude.cs, Prelude_Ask.cs, Prelude_Tell.cs, Prelude_PubSub.cs, Prelude_Spawn.cs).  I like the static access to contextual things, like Process.Sender inside a process gets the ID of the process that sent you the message.  Or calling Process.reply, automatically knows where to send it, even though you're in lambda.\nOne wish-list item is to create a IO monad that captures all of the IO functions like tell, ask, reply, and publish as a series of continuations so that I can create a single transaction from one message loop, and use that transaction to do hyper-robust message sequencing.  Because currently delivery is asynchronous, so sometimes you're at the mercy of the thread-pool.  It would also allow for high quality unit testing of the message-loops, because you could mock the IO functions.\nOk, got a bit carried away typing there!  Think I'll get on with it...\n. Yeah, that's fair reasoning.  I am using it in production right now, but obviously I know it inside out, so I can deal with any issues.  It's definitely too early for me to recommend anyone else use it for production, unless you were going to release in say 3 - 6 months when I know it will be nailed.\nFunnily enough as I was typing the info last night, I realised I could offer both the functional route and the class based route for those that prefer it, by making the object into the state.  It's on the master now.  You simply derive from IProcess\nC#\n    class Logger : IProcess<string>\n    {\n        public void OnMessage(string message)\n        {\n            Console.WriteLine(message);\n        }\n    }\nCreate it like so:\n``` C#\n    var log = spawn(\"logger\");\ntell(log,\"Hello, World\");\n\n```\nIt needs a public constructor to setup, and it will be disposed correctly if you derive it from IDisposable.\n. I removed the need for an OnSetup \\ Setup method because, well, that's what the constructor is for :-)\nYou're right about the new() constraint, I was clearly having a brain freeze there!\nOn your last example, that's not good, because the lifetime of the process must be controlled by the actor system.  When your process throws an exception the parent actor gets to decide what should happen.  At the moment the default behaviour is to reset the process, and send the message that caused the error to the dead-letters process (there will be more 'strategies' available soon),  \nThe reset must shutdown (and dispose) the process, and then set it up again with fresh state before giving it the next message.  So passing in processInstance will break that and give unpredictable results.  Essentially it leaks the state outside of the system.\nThe nice thing about this approach is when your process starts, the ctor is called, then it receives messages until it's shutdown, then Dispose is called.  So it honours the .NET object life-cycle correctly.\n. The actor model is definitely a different 'head space' to be in, but when it all sinks in, and you see the possibilities, it's really, really sweet.\n. > do you think about creating a parser combinator library?\nHeh, have you seen my other older library, csharp-monad?\nhttps://github.com/louthy/csharp-monad\nIt has a pretty complete parsec library.  The error handling is a touch buggy, but it's mostly good.  I went through most of the Haskell parsec library converting the functions over.  Even the expression and operator precedence parsers.\nhttps://github.com/louthy/csharp-monad/tree/master/CSharpMonad/src/parsec\nHere's a couple of basic language parsers from the unit-tests:\nhttps://github.com/louthy/csharp-monad/blob/master/CSharpMonad.UnitTests/src/lex/LexerTests.cs\nhttps://github.com/louthy/csharp-monad/blob/master/CSharpMonad.UnitTests/src/LangTests.cs\nSince then I've built a couple of parsec libraries in F#.  It's sooo much easier, because F# has decent type inference.  Unfortunately the F# version I wrote (which is probably the most complete one I've done) was built for an internal project at my company.  So I can't share that.  I used it to build a super-charged text-interpolation system and built a dynamically typed language that looked a lot like F# for doing deployment.\nBut yeah, I may get around to doing an updated version for lang-ext, and in the style of lang-ext.\nThey are super fun to use, and were probably (for me) the biggest eye opener to the potential of functional programming.  The composable (combinatorial) nature of them really awoke me to the idea that actually pure functional programming is where true modular and reusable programming lies. \n\nAnother quick comment: It's incredible how much you can learn if you convert \"complicated\" code from a language to a more familiar one.\n\nIndeed.  I implemented the csharp-monad library whilst teaching myself Haskell.  I turned my head inside out trying to work out the expression parser:\nhttps://github.com/louthy/csharp-monad/blob/master/CSharpMonad/src/parsec/expr/ExprParser.cs\nHere's the original Haskell version:\nhttp://hackage.haskell.org/package/parsec-3.0.0/docs/src/Text-Parsec-Expr.html\nI was turned onto the whole thing by a series of lectures by Eric Meijer (of LINQ fame).  I'd definitely recommend watching these.  He sometimes loses his way with the presentation, but stick with it, there's moments of gold in there...\nhttps://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1\n. I forgot to answer the reason why it's not in there now.  I wrote the csharp-monad library first, and thought the best way to write good functional code in C# was by exploiting LINQ and writing a monad library.  And it was pretty useful for a while, but after a while it was just a little bit too much effort.  A lot of the reason why it was a bit too much effort was because of the rest of C# and its 'infrastrucure'.  \nThe base class libraries for example, returning void, or using out or null references.  It makes it quite hard to chain together computations.\nSo with lang-ext I decided to come at it from the other angle.  Of getting the foundations right.  I wanted as many of the core constructs that you'd find in a functional language as possible.  I've probably spent as much time on Option<T> in lang-ext as I did on the whole of csharp-monad.  And it's paid off, because now I find it easier to use functional constructs in C# than I do the BCL stuff.  \nI saw parsec as the 'next level up'.  And although you can view most things in computing as a parser or interpreter (think about request/response for example), I felt it needed the basics first.  I guess I'm coming to the end of the basics part because I'm doing the Process library.  Although again that is to try and solve another fundamental with C#: its poor concurrency support.\nSo yeah, it's something I'd like to put in, but hopefully that explains the general direction :)\n. @ricardopieper - A first pass at a parser combinators library is now in git (not on nuget yet)\nhttps://github.com/louthy/language-ext/tree/master/LanguageExt.Parsec\nI'm going to be using this in the Process library for configuration scripts.  If you're interested in examples, here's the parser:\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Process/Config/Parser.cs\nAnd a unit test that uses it:\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Tests/ParsecTests.cs#L460\n. > This is quite similar to Sprache.\n@mpartipilo it's actually based on the Haskell parsec library; I've not seen Sprache but I assume it is too as most parsec libraries are inspired by it.\nhttps://hackage.haskell.org/package/parsec-3.1.9\n\nI might also suggest that as you add more and more to this library you split it from being monolithic...\n\n@gordonwatts Do you mean split it between repos or break the project up into smaller libraries?  There's already quite a well defined split between the Core library, Parsec library and Process library; with separate nu-get packages.  \nA lot of the reason for me keeping it all together is the reason I started writing it in the first place: in the C# world there is very little in terms of 'joined up' functional libraries. \nFor example if you found a great Option library, and a great immutable-map library, the immutable-map wouldn't be able to implement Option<V> Find(K key) because it's not aware of the Option library - or worse, it has its own implementation.  As soon as you find something missing in the what should be the basics for a functional environment then you find yourself patching and filling the gaps, either yourself or with other libraries that are incompatible or awkward in some way.\nSo currently I don't see much value in breaking it up.  But I'm prepared to hear out any reasons people may have :)\n. Hi @tomaszpolanski , thanks for the props :)\nRe: Support for W10, I'm not 100% what's required here?  I'm more of a web guy, so never really deal with phone or Store apps.  If you have any pointers/guidance then I'm happy to help.\n. Hi @tomaszpolanski - Am I to understand that everything is OK now on Win10?\n. Hi @tomaszpolanski - I refer you to this issue:  https://github.com/louthy/language-ext/issues/70\nIt covers to progress of the migration to .NET Core (which I assume will give you W10 support).  There are versions on nuget now, but please take a look at the table in the issue comments for the level of support for things like LanguageExt.Process.Redis.\n. Hi @PrzemyslawLewandowski - yes, good idea.  I will look into it.\n. Does toMailAddress return a Try<T> ?\nIf it doesn't and you want to wrap it, you can use the Try constructor (you'll find it in the Prelude):\n``` C#\n    using static LanguageExt.Prelude;\n...\n\nmatch( Try(() => toMailAdress(addressString)),\n    Succ: m => ...,\n    Fail: e => ...\n);\n\n``\n. This is covered in another issue, so closing it down.\n. Thanks for the heads up, I'll take a look tomorrow.\n. Checked it, and yeah the variants ofIfSome(and others) mean the docs were wrong.  I have fixed the docs rather than change the code.  I'm trying to avoid breaking changes now that the library is in heavy use; and the only way to make it work would be to have uniquely named variants ofIfSome`.  It really is a shame that C#'s type inference is so poor.\n. > For people not used to functional programming things like Fold, Reduce sound strange and it would be of great help to play with the methods and their overloads without the need to search online docs or decompile the code.\nYup I agree, I've been going through as much as I can documenting the code.  There is actually a section in the README.md that goes through this, but it needs more structure.  This library started out as a pet project that kinda got a lot more popular than I expected, so I was caught slightly off-guard by it - the ReadMe was/is more like a blog post and needs breaking out.  It's now quite large, but as the API is settling I am putting more time into the documentation. \n\nMy first thought when reading about implementing actor model was why not use akka instead, and I later found the git issue discussing this.\n\nIt's at the end of the ReadMe ;)  \nBut yeah, all valid points which I hope to work on more over the new few months or so.\n. > Are you open to PR's to help with the code documentation?\nAbsolutely.  As I say I'm trying to cover as much as I can with my limited time, but any help with that process would be appreciated.\n. @Jagged RE: fold and reduce, take a look at List.cs, both fold and reduce are documented there.\nFor a background, fold and reduce are essentially how you do loops with aggregate state in functional programming.  \nTake this imperative example for finding the sum of a list of integers:\nC#\n    var total = 0;\n    var list = List(1,2,3,4,5);\n    foreach(var item in list)\n    {\n        total += item;\n    }\nTrying to do something as simple as summing a list of values functionally is difficult if you can't carry a state value and you're trying to program with expressions:\nC#\n    var res = list.Select( x => .... what goes here? );\nThat's what fold is for.  In a fully functional implementation it would look like this:\nC#\n    S Fold<S,T>(S state, Func<S,T,S> folder, Lst<T> list) =>\n        list.Count == 0\n            ? state\n            : Fold(folder(state,list.Head()), folder, list.Tail());\nThat's why it's the functional way of doing loops, because there is no loop (and therefore no mutation of local variables), just a single recursive expression.  If there are items in the list, it takes the current state and the head item and passes it to the folder function, the result becomes the new state, then it recalls itself with the new state and the tail of the list.  This happens recursively until there are no items left to process, at which point it returns the aggregate state value.\nreduce is fold, except it doesn't take an initial state value, it uses the first item in the list as the initial state value (and therefore can't work with empty lists).  \nThe functional world doesn't really do design-patterns, but if anything is a design-pattern then it's fold.  It's such a common theme, that when you build a recursive expression, 9 times out of 10 you'll realise it can be a fold.  So after a time you end up going straight to fold rather than building recursively.\nThere is also the issue that C# will happily blow up the stack after about 10,000 recursive calls.  So the Language-Ext implementation of fold is actually imperative:\nC#\n    public static S fold<S, T>(IEnumerable<T> list, S state, Func<S, T, S> folder)\n    {\n        foreach (var item in list)\n        {\n            state = folder(state, item);\n        }\n        return state;\n    }\nSo back to the summing integers example:\nC#\n    var list = List(1,2,3,4,5);\n    var total = fold(list, 0, (s,x) => s + x);\nNow imagine doing that for calculating the product:\nC#\n    var list = List(1,2,3,4,5);\n    var total = fold(list, 0, (s,x) => s * x);\nIt wouldn't work, because the first time the folder function is called it will have an s of 0.  So the result will always be zero.  But if you used reduce instead:\nC#\n    var list = List(1,2,3,4,5);\n    var total = reduce(list, (s,x) => s * x);\nThen s will have an initial state of 1 because it will take the first item from the list.\nYou may now wonder why fold is part of Option, Either, etc.  However if you think of Option as a list that has either 0 or 1 items in it, then you can see how you can treat Option, Either, List, Set, Try, etc. the same and provide a common interface.\n. They're both for aggregating a value.  It's only the start condition that's different.\nHere's some food for thought: many of the common list processing functions represented as folds...\n``` C#\npublic static EnumerableExt\n{\n    public static int Sum(this IEnumerable self) =>\n        self.Fold(0, (s,x) => s + x);\npublic static int Count(this IEnumerable<T> self) =>\n    self.Fold(0, (s, _) => s + 1);\n\npublic static IEnumerable<U> Map<T,U>(this IEnumerable<T> self, Func<T, U> map) =>\n    self.Fold(List.empty<U>(), (s,x) => s.Add(map(x)));\n\npublic static IEnumerable<T> Filter<T>(this IEnumerable<T> self, Func<T, bool> pred) =>\n    self.Fold(List.empty<T>(), (s,x) => \n        pred(x) \n            ? s.Add(map(x)) \n            : s\n            );\n\npublic static Unit Iter<T>(this IEnumerable<T> self, Func<T, Unit> action) =>\n    self.Fold(unit, (_, x) => action(x) );\n\npublic static bool Exists<T>(this IEnumerable<T> self, Func<T, bool> pred) =>\n    self.Fold(false, (s, x) => s \n        ? true\n        : pred(x)\n        );\n\npublic static bool ForAll<T>(this IEnumerable<T> self, Func<T, bool> pred) =>\n    self.Fold(true, (s, x) => s \n        ? pred(x)\n        : false\n        );\n\n}\n```\n. > Yep, I get that. It would be interesting to find the roots of the naming of those two methods, to see what inspired them to be called fold and reduce \nI guess catamorphism was too long ;)\n'Piping' and 'LINQ' are two subtly different things. 'Piping' AKA function composition is passing the result of one function to single input parameter of the next.  \nWe have the compose function for that.  To see an example of this in the Samples:\nhttps://github.com/louthy/language-ext/blob/master/Samples/UnitsOfMeasureSample/BallProcess.cs#L50\nC#\n    compose(\n        Accelerate(msg.Time),\n        Move,\n        FloorCeilingDetection,\n        WallsDetection,\n        SetTime(msg.Time));\nThis is what that world look like without the compose:\nC#\n    state = SetTime(msg.Time, WallsDetection(FloorCeilingDetection(Move(Accelerate(msg.Time, state)))));\nYou could expand it to make it a touch clearer:  \nC#\n    state = Accelerate(msg.Time, state);\n    state = Move(state);\n    state = FloorCeilingDetection(state);\n    state = WallsDetection(state);\n    state = SetTime(msg.Time, state);\nYou may also notice that those methods could be written as extension methods for the state type, and you'd end up with this:\nC#\n    state.Accelerate(msg.Time);\n         .Move();\n         .FloorCeilingDetection();\n         .WallsDetection();\n         .SetTime(msg.Time);\nLINQ deals with monads and uses the monadic bind function.  It is also composition, but it can work with the values wrapped within the monad and put them back in a new monad before returning.  That allows the behaviour of the monad to be injected (\"programmable semi-colons\" is the best description I've heard for them).  For example the bindfunction for Option acknowledges the Some / None states, and doesn't perform the bind operation on None values.\nC#\n    Option<U> Bind<T,U>(Option<T> option, Func<T, Option<U>> bind) =>\n        option.IsSome\n            ? bind(option.Value)\n            : None;\nYou can then do monadic binding like so:\nC#\n    Option<int> x = Some(10);\n    Option<int> y = Some(10);\n    Option<int> res = Bind( x, a => Bind(y, b => Some(a + b) );  // Some(20)\nBut that's obviously very clunky and that's where LINQ comes in.  It does monad composition gracefully:\nC#\n    Option<int> x = Some(10);\n    Option<int> y = Some(10);\n    Option<int> res = from a in x\n                      from b in y\n                      select a + b;\n\nI can't help but notice a huge amount of repetition when I searched for Fold (etc). I wonder if there's a way to get the compiler to help us here.  T4 templates? Marking classes as IFoldable etc and using extensions?\n\nI'd rather not.  Fold doesn't change, and neither does the definition of a lot of functions in this library.  So whilst there may be an upfront typing cost, there isn't an ongoing project management cost.\n\nPerhaps we could move the How under remarks and put the What under summary?\n\nSure.  Keep the wording, but splitting them is OK.\n. Mostly if I use imperative code it's for performance or readability reasons.  I will always prefer expressions over statements, but sometimes the cost of LINQ or closures is too great.  Operators are a good example where most consumers of the code would expect you to be as optimal as possible (that's why there's so much type-caching).\nActually the behaviour of Append is wrong.  It needs to be more consistent with the Option<T>.Append in that:\nC#\n    None + Some(rhs) = Some(rhs)\n    Some(lhs) + None = Some(lhs)\n    Some(lhs) + Some(rhs) = Some(lhs + rhs)\nFor TryOption<T> I think it should be:\nC#\n    None + Succ(rhs) = Succ(rhs)\n    Succ(lhs) + None = Succ(lhs)\n    Succ(lhs) + Succ(rhs) = Succ(lhs + rhs)\n    Fail + None = Fail\n    None + Fail = Fail\n    Succ + Fail = Fail\n    Fail + Succ = Fail\n    Fail + Fail = Fail\nThat also means it's not bind.  I'll fix that up now.\n. Try<T> is a delegate, so you should use it like so:\nIn C# 6\nC#\n    Try<int> Divide(int x, int y) => () => \n        x / y;\nIn C# 5 or older\nC#\n    Try<int> Divide(int x, int y)\n    { \n        return () => x / y;\n    }\nCalling Divide with zero for y will return a Try<int> which when matched upon will give a Fail state, otherwise a Succ state, i.e.:\nC#\n    var res = match( Divide(10,0),\n                     Succ: v => v,\n                     Fail: 0 );\nThe primary benefit is that the exception is treated as a return value like anything else, and you can chain the Trys together in a LINQ statement where an exception will cause the expression to 'early out'\nTake a look at the unit tests for more examples: https://github.com/louthy/language-ext/blob/master/LanguageExt.Tests/TryMonadTests.cs\nTryOption<T> gives the 3 possible states a function can return:\n- Some value\n- No value (usually null is used for this)\n- Exceptional value\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Tests/TryOptionMonadTests.cs\n. Try<T> is defined thus:\nC#\n    delegate TryResult<T> Try<T>();\nWhich is equivalent to:\nC#\n    Func<TryResult<T>>\nAll of the support functions for Try<T> (like Match) are extension methods.  C# will do implicit conversion in certain circumstances.  For example, the return value from a function:\nC#\n    Try<T> Foo()\n    {\n        return () => ... ;      // This lambda is implicitly converted.\n    }\nOr an inline lambda where you specify the type of res\nC#\n   Try<int> res = () => 123;   // This lambda is implicitly converted.\nBut not here:\nC#\n   var res = () => 123;   // This won't even compile because C#'s type inference is poor for lambdas.\n   res.Match(...);\nThe main reason for the Try function is to use it mid-expression.\n\nAs I read in the code, Try basically does a catch (Exception e); how would I narrow that down?\n\nThere are extension methods for Exception (can be found in ExceptionMatch.cs) that can be used like so:\n``` C#\n    Exception ex;\nvar res =ex.Match()\n    .With<NotSupportedException>( e => \"Not supported\")\n    .With<NotImplementedException>( e => \"Not implemented\")\n    .Otherwise(\"An error\");\n\n```\nOtherwise can either be a default value (as above), or a map (Func<Exception,R>).  You can also use OtherwiseReThrow().\nIt's not super pretty I'm afraid.  You'd need to do the above in the Fail part of the Try.  I could add something similar to the Try extension methods, let me know if you'd find that useful.\n. @fazouane-marouane \n\nirrelevant to the issue: @louthy Thanks for your awesome work! I've just discovered LanguageExt an hour ago. This project implements all the most needed/helpful paradigms seen in other systems & languages. Thanks for bringing in this into C#\n\nThank you, that's very nice to hear!  :)\n. Thanks @fazouane-marouane I'll add that to the project (and rights).  It could be more optimal by using imperative constructs internally, so I'll go that route.\nI will also add lefts and rights to Prelude so it can be used fluently and functionally.\n@Profpatsch - please keep any suggestions coming.\n. It wouldn't be great, no.  So the implementation I have done is:\nC#\n    public static IEnumerable<L> Lefts<L, R>(this IEnumerable<Either<L, R>> self)\n    {\n        foreach (var item in self)\n        {\n            if (item.IsLeft)\n            {\n                yield return item.LeftValue;\n            }\n        }\n    }\nAnd similar for Rights.  This imperative loop is the quickest way of yielding the results, but also it's lazy (if you don't know C# too well, yield is a coroutines system which works in tandem with foreach via the IEnumerator interface).\nI have just done a check-in with updates based on your suggestions:\n- Rights and Lefts extension methods for IEnumerable<Either<L,R>> and IEnumerable<EitherUnsafe<L,R>>\n- rights and lefts static methods in Prelude\n- partition function that returns a tuple of lefts and rights\n- More variants of ifLeft and ifRight\n- Left variants of iter, forall, fold, exists, map, bind and filter\nNote, the LINQ functions Where, Select and SelectMany will continue to be biased toward Right and will early-out when an Either is in a Left or Bottom state.\nIt's getting a bit late here (2 am), so I will do a nuget release tomorrow with these updates.  So if you want them sooner you'll need to build from source.\n. > if it\u2019s possible with the type system\nA lot of the reason for language-ext is to 'cheat' the type-system in C#.  Unfortunately it's not possible to do higher-kinded polymorphism, so much of this library is doing manually what the GHC does automatically.  It means a hell of a lot of typing unfortunately, but I figured if one person does it once for the most commonly used aspects of functional programming then we all win.\n\nIf you wanted to take it further you\u2019d introduce Bifunctors\n\nYep, I was actually considering it last night when going through the changes from your original suggestion.  It hadn't quite cleared in my mind the best way to do it, but actually it's relatively simple.  So, if you grab the latest source there's now bifunctor, bifoldable, bitraversable, ... support for Either and EitherUnsafe.  Again it's been a manual process rather than being able to define a bifunctor typeclass, but that's just the way it is.\nSo there are now variants of (overloaded functions with the same names):\niter\nmap\nfold\nfilter\nbind\nforall\nexists\nThey all now take two functions Right and Left, so you can write them in a similar style to match (using named arguments) for clarity:\nC#\n    var res = map(either, \n                  Right: r => ..., \n                  Left: l => ... );\nOr fluently\nC#\n    var res = either.Map( Right: r => ..., \n                          Left: l => ... );\nYou might find you'll have to specify the type-arguments more than you'd like, because C#s type-inference isn't too hot.  \nActually, I hope you don't mind me asking: if you've come from a Haskell background why didn't you go straight to F# rather than C#?  You still have limitations of the .NET type-system (so no type-classes), but the type-inference system is soooo much better.\n. As an additional to my comment above, I have added transformer functions for IEnumerable<Either<L,R>> and IEnumerable<EitherUnsafe<L,R>>.  They are:\niterT\nforallT\nfoldT\nexistsT\nmapT\nbindT\nfilterT\nThe transformer functions for all of the other monads are auto-generated by the HKT T4 template.  But it's a bit of a ramshackle system that isn't super flexible, and therefore can't handle variants for Left and bifunctors.  So for those behaviours I need to add them manually.  If you need any other combination of monads let me know.\n. @Profpatsch \n\nMaybe it escalated a little \u2026\n\nHeh, always the way!  Please feel free to raise anything else you're missing.  Mostly people come to this project as C# guys who have 'seen the light' and want to use functional techniques in a language that fights them; so most requests I get are from that perspective.  \nHaving a Haskell guy coming from the other direction is valuable to me, because although I have used Haskell, I have only used it for a few small projects (F# is my go-to functional language now, because although not as nice as Haskell it hits a number of sweet-spots, especially on the interop front).  \nThe Either requests are a good example of a blind spot that I'd had (I think those blind spots exist in the F# implementations too - although I'd need to check).\n. Agreed.  My other github project: csharp-monad was my first attempt at a general case functional library, but I got a little bit caught in the monad trap and the Haskell laziness idea.  Monads are super useful obviously, but there's not really enough grammar in LINQ to make them as nice to use as in Haskell (or indeed F#).  So you can only get so far.  That's where this project was born from, trying to get a lot of the other fundamentals right.\nOne valuable part of it though was the time spent porting the Haskell parsec library; that really opened my eyes.  I'll bring an improved version of that over to LangExt at some point too.\nhttps://github.com/louthy/csharp-monad/tree/master/CSharpMonad/src/parsec\n. Very compatible!\nFrom the source in the blog:\nscala\n    val url = parseURL(Console.readLine(\"URL: \")) getOrElse new URL(\"http://duckduckgo.com\")\nWould be:\nC#\n    var url = parseURL(Console.ReadLine(\"URL: \")).IfFail(new URL(\"http://duckduckgo.com\"));\nNext example:\nscala\n    parseURL(\"http://danielwestheide.com\").map(_.getProtocol)\n    // results in Success(\"http\")\n    parseURL(\"garbage\").map(_.getProtocol)\n    // results in Failure(java.net.MalformedURLException: no protocol: garbage)\nWould be:\nC#\n    parseURL(\"http://danielwestheide.com\").Map(GetProtocol);\n    parseURL(\"garbage\").Map(GetProtocol);\nOr you could use LINQ:\nC#\n    var result = from x in parseURL(\"http://danielwestheide.com\")\n                 select GetProtocol(x);\nNext example (flatMap):\nscala\n    def inputStreamForURL(url: String): Try[InputStream] = parseURL(url).flatMap { u =>\n      Try(u.openConnection()).flatMap(conn => Try(conn.getInputStream))\n    }\nUse LINQ for this:\nC#\n    Try<InputStream> inputStreamForURL(string url) =>\n        from u    in parseURL(url)\n        from conn in u.openConnection()\n        from str  in conn.getInputString()\n        select str;\nNext example (filtering):\nscala\n    def parseHttpURL(url: String) = parseURL(url).filter(_.getProtocol == \"http\")\n    parseHttpURL(\"http://apache.openmirror.de\") // results in a Success[URL]\n    parseHttpURL(\"ftp://mirror.netcologne.de/apache.org\") // results in a Failure[URL]\nBecomes:\nC#\n    Try<URL> parseHttpURL(string url) => parseURL(url).Filter(x => GetProtocol(x) == \"http\");\nOr with LINQ:\nC#\n    Try<URL> parseHttpURL(string url) =>\n        from x in parseURL(url)\n        where GetProtocol(x) == \"http\"\n        select x;\nNext example (iteration):\nscala\n    parseHttpURL(\"http://danielwestheide.com\").foreach(println)\nBecomes:\n``` C#\n    // For writing the inner value 'as-is' \n    parseHttpURL(\"http://danielwestheide.com\").Iter(Console.WriteLine);\n// For transforming the inner value (if it's a Try<Lst<T>> for example)\nparseHttpURL(\"http://danielwestheide.com\").IterT(Console.WriteLine);\n\n```\nNext example (comprehensions):\nscala\n    import scala.io.Source\n    def getURLContent(url: String): Try[Iterator[String]] =\n      for {\n        url <- parseURL(url)\n        connection <- Try(url.openConnection())\n        is <- Try(connection.getInputStream)\n        source = Source.fromInputStream(is)\n      } yield source.getLines()\nUse LINQ for the most elegant looking code:\nC#\n    Try<IEnumerable<string>> getURLContent(string url) =>\n        from u      in parseURL(url)\n        from conn   in u.openConnection()\n        from str    in conn.getInputStream()\n        from source in str.fromInputStream()\n        from lines  in source.getLines()\n        from line   in lines\n        select line;\nNext example (pattern matching):\nscala\n    getURLContent(\"http://danielwestheide.com/foobar\") match {\n      case Success(lines) => lines.foreach(println)\n      case Failure(ex) => println(s\"Problem rendering URL content: ${ex.getMessage}\")\n    }\nBecomes:\nC#\n    getURLContent(\"http://danielwestheide.com/foobar\").Match(\n        Succ: lines => lines.Iter(Console.WriteLine),\n        Fail: ex    => Console.WriteLine(ex.Message)\n    );\nOr more functionally:\nC#\n    match( getURLContent(\"http://danielwestheide.com/foobar\",\n           Succ: lines => lines.Iter(Console.WriteLine),\n           Fail: ex    => Console.WriteLine(ex.Message)\n    );\nNext example, recovering from failure:\nscala\n    import java.net.MalformedURLException\n    import java.io.FileNotFoundException\n    val content = getURLContent(\"garbage\") recover {\n      case e: FileNotFoundException => Iterator(\"Requested page does not exist\")\n      case e: MalformedURLException => Iterator(\"Please make sure to enter a valid URL\")\n      case _ => Iterator(\"An unexpected error has occurred. We are so sorry!\")\n    }\nBecomes:\nC#\n    var content = getURLContent(\"\").IfFail()\n         .With<FileNotFoundException>(_ => List(\"Requested page does not exist\"))\n         .With<MalformedURLException>(_ => List(\"Please make sure to enter a valid URL\"))\n         .Otherwise(_ => List(\"An unexpected error has occurred. We are so sorry!\"));\nGet the latest source for the last example to work,  I streamlined the matching process.\n. By the way, on the getURLContent example from above there is no clean-up of the system resources that would be acquired by opening connections or streams (which appears to be an issue in the Scala version also):\nC#\n    Try<IEnumerable<string>> getURLContent(string url) =>\n      from u      in parseURL(url)\n      from conn   in u.openConnection()\n      from str    in conn.getInputStream()\n      from source in str.fromInputStream()\n      from lines  in source.getLines()\n      from line   in lines\n      select line;\nSo, to deal with that, there's a use function for Try<T> and TryOption<T> (I will add the other monads soon) that wraps the monad value in a LinqDisposable object (so Try<Foo> becomes Try<LinqDisposable<Foo>>.  Then the Select and SelectMany implemetations (which facilitate LINQ) look for LinqDisposable and deal with the clean-up accordingly.  You need to use the Value property to get to the underlying value:\nC#\n    Try<IEnumerable<string>> getURLContent(string url) =>\n        from u      in parseURL(url)\n        from conn   in u.openConnection()\n        from str    in use(conn.getInputStream())\n        from source in use(str.Value.fromInputStream())\n        from lines  in source.Value.getLines()\n        from line   in lines\n        select line;\nIt's certainly not quite as pretty, but required for safe clean-up.\n. > In Haskell normally these things are wrapped in a custom Monad in my experience\nI could do that here, but it would involve creating transformer monads for all of the existing monads, which is quite a lot of effort; having to manually unwrap via .Value is the least worst alternative I think.\nF#'s computation expressions has the use keyword (and the ability to override its behaviour on a monad by monad basis).  Hopefully C# will get some more LINQ grammar in the future (or extensible grammar like in F#)\n. @gordonwatts - I agree mostly with what you're saying.  I think if C# were to implement computation expressions in pretty much the same way as F# then life would be good.  I think I saw some proposal on the Rosyln project for this already actually.  However it doesn't seem to be a priority for C#7 (and their current priorities of pattern matching, record types, tuple support, and fixing the null problem would definitely be my preferred items for them to tackle).\nMoslty I like the LINQ syntax, from x in y is the same as x <- y in Haskell, or let! x = y in F#.  I think combined with let and the additional 'operators' in LangExt (like Map, Fold, etc. and the overridden logical or operator) you can get most of the way to what's needed.  The big one I miss is do.\n\nhaving to write \"var newvalue = from x in monad1 from y in monand2 x + y;\" over and over again, obscuring the simple \"+\" operator which is what is important\n\nPerhaps the new applicative work that's currently going on in the Applicative branch will help?  i.e.\n``` C#\n    var x = Some(10);\n    var y = Some(20);\nvar z = Some((int a,int b) => a + b).Apply(x,y);\n\n```\nNot sure it's much better than:\nC#\n    var z = from a in x\n            from b in y\n            select a + b;\nBut I guess it depends on the use-case.  For a simple addition perhaps not, but for something more complex, maybe.  Especially if you already have a function defined, i.e.:\nC#\n    var z = Some(ComplexFunction).Apply(x,y);\nIf you're mostly working with numbers, I was considering putting in a load of operator overloads for the standard arithmetic operators.  Then you could truly do:\n``` C#\n    var x = Some(10);\n    var y = Some(20);\nvar z = x + y;\n\n```\nLet me know if any of that would be useful to you (or whether you were just using that as an example).  It would require some heavy lifting underneath however.\n\nbut I'd urge you not to shy away from putting together a proposal.\n\nI'd love to, but it's a heck of a lot of work considering all of the implications of new language features.  I'm personally very short of free time at the moment unfortunately, and seeing as it doesn't look like it's on the radar at the moment, could be wasted effort.\n. @gordonwatts Just to follow up on my last email, if you grab the latest source then you can now do this for numeric values:\nC#\n    var x = Some(10);\n    var y = Some(20);\n    var z = x + y;   // Some(30)\nAnd strings:\nC#\n    var x = Some(\"Hello\");\n    var y = Some(\" \");\n    var z = Some(\"World\");\n    var r = x + y + z;   // Some(\"Hello World\")\nAnd lists:\nC#\n    var x = Some(List(1,2,3));\n    var y = Some(List(4,5,6));\n    var z = x + y;   // Some(1,2,3,4,5,6)\nThere's also behaviour for subtract, divide and product:\nSo for example with lists:\nC#\n    var x = Some(List(1,2,3));\n    var y = Some(List(2,3,4));\n    var z = x * y;   // Some(2,4,6,3,6,9,4,8,12)\nFor your own types you can derive from: IAppendable<T>, ISubtractable<T>, IProductable<T>, and IDivisible<T> (There's a convenient INumeric for bespoke numeric types).  \nAll of the core monads support Append, Subtract, Divide and Product.  They will however throw a runtime exception if the underlying type doesn't support the action.  \nI think combined with apply it should get most of the way down the path of dealing with operations on two monadic types.  \nI hope that helps :)\n. The Core relies on Rx-Main, which brings in the other 4.  I have reduced that to only needing Rx-Core (which also brings in Rx-Interfaces) and RxLinq.  This reduces the dependency requirement.\nRx is a definitely a large part of the functional story in .NET; I want LangExt to be part of that story and not ignore it.  There are functions in Option that use it (MatchObservable for example) and some other support functions like delay for scheduling execution of a Func<T>.  The number of 'Observable aware' functions will grow.\nAnd whilst I could split some of the functions out into a LanguageExt.Core.Rx dll; not all can.  The value of the Prelude partial class is that you can write using static LanguageExt.Prelude once and then you get the functional world in C#.  Unfortunately partial classes can't span multiple assemblies, and therefore I'd have to split the Prelude which I'd rather not do.\nLangExt did previously depend on System.Collections.Immutable and a WeakConcurrency project which it now doesn't.  So hopefully the overhead isn't too bad.\n. There were a couple of issues here.  One is a bug in LangExt and one is an issue with your example.\n1. The reason the compiler didn't pick up the correct Some is because you are using an Action type and the Some was specifying it needed an R return value.  Obviously actions don't return, so this wasn't needed. It meant that the compiler couldn't resolve the Some because you hadn't specified a return type.\n2. Your example contains an Action and a Func.  You can only use either Actions or Funcs, not combine the two.\n. Hi @la-yumba - Thanks for the pull-request, and for putting the effort into supporting language-ext, however there are a number of reasons I can't currently accept this pull-request:\n1. Apply is only provided for one of the monadic types.  The main thrust of language-ext is to attempt to create a complete API across all monads (so OptionUnsafe, Either, EitherUnsafe, Try, TryOption, Reader, Writer, State...).  So I prefer to only add features if they're going to be across all monads, or at the very least the core set: Option, OptionUnsafe, Either, EitherUnsafe, Try, TryOption\n2. I also try to maintain a set of functional mirror functions that do the same job as the fluent API, i.e.\nC#\n    var result = apply(apply(Some(add),Some(3)),Some(4));\nIt would also make sense to add variants that make the functional API work better:\nC#\n    var result = apply(Some(add),Some(3),Some(4));\n1. There is no need for a separate project file for Applicatives or their unit tests.  I think it's fine that they're in LangaugeExt.Core and LanguageExt.Tests.\n2. There's unchecked access to the Value property of the Option type which is a bug:\n   https://github.com/louthy/language-ext/pull/36/files#diff-121a151d32da28ae59ac9f9e822ee3c0R14\nIf you can deal with the issues raised above then I will happily accept the changes.  If not, let me know, as it's something I will probably do at some point also.  I'd just rather not double up the work.\n. @la-yumba \n\nmaybe you could create a branch on your repo for this work, that we can\nboth contribute to, and then merge to your master branch when you think\nit's ready?\n\nGood plan, here you go:  https://github.com/louthy/language-ext/tree/Applicative\n. @la-yumba That's great, thanks :)\nCan you also please make sure you comment each function.  It's been a mammoth job going through all the existing code documenting everything.  So reducing that ongoing workload is definitely something I want to achieve. \nThanks again.\n. @la-yumba I have now added documentation as well as applicative support for Option, Either and EitherUnsafe\n. Fixed\n. > shouldn't this be return rhsRes;\nYes, fixed.\n\nPerhaps a throw would be more reasonable? Seems arbitrary. Maybe even returning a None state?\n\n'In theory' it's impossible to get there.  However, I'm also aware of the first law of programming: If it can't possibly happen, it will.  So I've put the relevant throws.\nThanks :)\n. Thanks @Jagged  :)\n. Hi @Jagged - First of all, thanks so much for contributing to the project.  A second pair of eyes is definitely appreciated!  I am unfortunately going to have to reject your pull-request in its current state however.  It is mostly all good, but there are a few things that (if you could) I'd like you to improve:\nSome of the Dispose() modifications you've made are unsafe.  \nThis can fail if called from multiple threads:\nC#\n    public void Dispose() \n    {\n        if( val != null )\n        {\n            //  <--- If another thread calls this Dispose method then val may == null here\n            //       Which would throw a NullReferenceException\n            val.Dispose();\n            val = null;\n        }\n    }\nSo you should do this:\nC#\n    var localVal = val;\n    if( localVal != null )\n    {\n        localVal.Dispose();\n        val = null;\n    }\nIt's up to the IDisposable class to deal with double entry.  So if it was a FileStream for example it may use locks where the LangExt disposables don't need them.\nI don't use that pattern on the Enumerators because mostly you know they'll be called via a foreach and will therefore only be disposed once and Enumerators aren't normally passed between threads.\nDisposable.cs\n- There is a bug in the Dispose, but it should be fixed thus:\nC#\n    public void Dispose()\n    {\n        var value = Value;\n        if (value != null)\n        {\n            value.Dispose();\n            Value = null;\n        }\n    }\n- ~~Don't change readonly fields to properties - please revert.~~  Ignore, just realised why you did it!\nActor.cs\n- I think it's unnecessary to protect against double disposal; it should be the state's Dispose method that deals with it.  So there's no need for isDisposed.  Also removing subscriptions twice won't hurt.  In the unlikely event that Dispose gets called multiple times I can deal with the hit.\n- Obviously the bug fix is welcome though, so I think the Dispose method should be reverted and the DisposeState method be left with your change.\nActorInboxDual.cs - Revert\nActorInboxLocal.cs - Should be:\nC#\n    var ts = tokenSource;\n    ts?.Dispose();\n    tokenSource = null;\nActorInboxRemote.cs - Should be:\nC#\n    var ts = tokenSource;\n    ts?.Cancel();\n    ts?.Dispose();\n    tokenSource = null;\nRedisClusterImpl.cs\n- Please revert - I know it's not great practice to call Dispose from a finaliser, but in reality I've seen a cluster survive across an ASP.NET app-pool recycle which can cause major problems (especially whilst an app is in development and you're dropping out of debugging sessions).  So I want to make absolutely 100% sure that the cluster and connections are shut-down no questions asked.  It's brutal, but necessary.\nList.cs - Fine\nLst.cs - Fine\nMapKV.cs - Fine\nObjectPool.cs - Fine\nPrelude_Obsolete.cs - Fine (if unnecessary due to the methods being obsolete)\nPrelude_Use.cs - Fine\nRWS.cs - Fine\nReader.cs - Fine\nSetT.cs - Fine\nState.cs - Fine\nTry.cs - Fine\nTryOption.cs - Fine\nWriter.cs - Fine\nPrelude_Logging.cs - Fine\nLanguageExt.ProcessJS.csproj - Fine\nAgain, thanks for the contribution.  If you disagree with anything I've written above please let me know and we can discuss it further.\nPaul\n. > I think I've completed all you've asked, though with a little artistic license. =) I noticed that ActorInboxLocal wasn't Cancelling the tokenSource, so added that.\nThanks Will, that all looks great!\n. Hi @orthoxerox - That's super interesting that they're considering changing it.  Normally I'd run with a solution like this, but there's a few reasons I'm not sure this is a good idea:\n- A lot of tuple use is temporary (return values, local vars) and I suspect is more likely to be on the stack than the heap; and therefore is unlikely to be a huge burden.  I have to be honest, I don't know what the criteria is that the CLR uses to decide between heap and stack usage - I assume there's some cleverness in the compiler that can tell if an item is going to be assigned to a non-local variable.  I have read comments from Eric Lippert that as a coder you can't really know.\n- If the CLR team are planning to change it, then introducing a new Tuple type seems unnecessary and may lead to confusion.\n- Quite a lot of this library already relies on struct types for null reference protection; I'm not sure I'd prefer Tuple to be a reference type for that reason.  This library is definitely more about correctness than outright performance (whether it's CPU or memory); in a past life I wrote 3D graphics engines for the Playstation and the like, I remember getting an entire graphics engine running in the 4Kb instruction cache on the PS1 and going insane maintaining it.  My preference these days is to have correct code.  If I could be assured of the same guarantees by using a reference-type and get a performance gain then I'd go for it; but I'd rather not chase it for marginal gains.\n- Finally:  What would it be called?  It's already a bit icky that I have to call the list-type Lst and the stack-type Stck.  Tup, Tple, Tupl ?  \nAnyway, that's my brain dump.  Let me know what you think.\n. Sorry!  I just realised I've been reading this all wrong.  I could have sworn Tuple was already a value-type.  Even after looking at the coreclr source (I assumed I was looking at a branch!).  Wow, can't believe I missed that.  So, it seems they can be null.  That puts a different spin on things...\nMy overarching thoughts on this kind of optimisation is it's usually misplaced.  I've written garbage-collectors in the past, and they're super-fast at allocation.  So heap allocation is almost as quick as stack allocation.  Obviously the generational collection part is where things slow down, but if you're really concerned about collection stalling your app then developing in a managed language may not be the right choice.  Or you can use mitigation strategies like pre-allocating all the objects you need and build a free-list allocator (although clearly that doesn't help with immutable types).  \nHmm.  Ok, let me think this one through a bit.  This now puts the additional 'correctness' spin on things.\nThe new concerns would be:\n- If I re-purposed all of the existing tuple API to generate VTuple instead of Tuple, then anyone using the existing API could have their code broken\n- If I provide implicit conversion operators from VTuple to Tuple and back then that could double the allocation cost for existing users\n- If I provide a brand new API (apart from the epic amount of typing), would it work...\nOk, food for thought...\n. Yup, that's wrong.  Not quite sure how the else part ended up identical, but a lot of ActorSystemState is a legacy from the early system.  Most of that code sits in ActorContext.GetDispatcher() now.  GetItem is purely used by the root actor to for generating the 'system' actors (like user, dead-letters, etc.).  So the else would never be called.\nHowever just to make sure I have made the else throw an exception.\n. @Jagged  Yep, the root process has a name which is either root if it's not part of a cluster or whatever the second parameter is when calling Cluster.connect(...).  So if the name doesn't match the root then the message needs to be dispatched.  It's slightly more complex now that there's dispatch to local, JS (via SignalR) and Redis - that complexity is now dealt with in ActorContext.GetDispatcher().  \nActorSystemState was originally the controller of the whole actor-system as-well as being the root actor.  But the benefits of all messages going through one 'master' process turned into pain-points of messaging deadlocks, so I broke it all out into the static ActorContext.  The root process is now gutted in terms of functionality; it does however need to bootstrap the user and system processes, so it still needed some of the factored out functionality duplicated internally.  That's what GetItem is.  \nI suspect the false clause would never be called, but having the exception throw in there will make absolutely sure.\n. >  but the code in this area is rather opaque, and screaming out for documentation! Or better still, make the code self-documenting thru use of explaining variables, perhaps renaming some routines, and breaking some of the larger ones down into manageable bits.\nNot 100% sure I agree on its opaqueness; obviously I wrote it, so I have a different view on the code.  It's not a trivial system, so there's likely to be 'first look opaqueness', especially when it comes to a paradigm which is foreign to C# (the actor model).  \nI'm also not sure what you're referring to in terms of poorly named functions or large routines?  The way GetItem function which I agree is poorly named made a lot more sense when the ActorSystemState did have its own Key-Value state --- so there may be some legacy names which I agree need fixing.\nI generally prefer smaller functions and conciseness rather than the enterprise naming style of ActorFactoryServiceManager (trite example, but hopefully you get my point).  Sometimes my drive for expression-based code can be terse, but I personally figure the benefits of robust code outweigh the initial difficulty when returning to code.\n\nI'm more than happy to roll up my sleeves and helping with that, but I guess I'm wary of stepping on your toes! You might find some routines unrecognisable when I'm done! =P (but hopefully clearer!!)\n\nI'm happy for you to do this, but I would advise that any changes you're planning to consult me first (rather than just submitting a pull-request).  The main reason is to reduce any wasted effort on your part.  My slight concern based on your comments is that it would just be a 'style war'.  That sounds more aggressive than I mean it to be.  But if as you say you're just picking up the functional baton, my concern is that the issues you see are actually just the difference between OO and functional.  \nI'm primarily interested in pull-requests that add value.  Making the code clearer definitely adds value, but not a huge amount.  The areas that you could add tons of real value (I feel) are:\n- Documentation (especially on the public interface) adds a ton of value for the end user.\n- More unit tests, especially for the core types and functions that doesn't have them.\n- Implementation of missing features (like crash strategies for actors).\n- Audit of the code for potential bugs\nThere has never really been a road-map for the project, because initially I built it for myself and have been adding to it as I needed new features.  If you have suggestions of new features then I'm open to that also.\n\nI've noticed that quite a bit of code still deals with \"raw\" reference types that can be null, having to continually check all over the place. I'd like to see how we might be able to make use of Some{T} etc.\n\nSome<T> is less useful that it should be unfortunately.  For example this code won't compile, even though List<string> is an IEnumerable<string>\n``` C#\n        public static void Foo(Some> val)\n        {\n        }\n    public void SomeCastTest1()\n    {\n        var some = new Some<List<string>>(new List<string>() { \"a\", \"b\", \"c\" });\n        Foo(some);\n    }\n\n```\nSo Some<T> changes can be a breaking change and can also be frustrating to use.  It's annoying for sure.  It can work very well for concrete types, but this library rarely uses them.  So we're back in the null check era.\nPlease don't let my comments put you off.  I really value anyone getting involved and helping to improve the library.  But if you can just bear my concerns in mind that will make the whole process much smoother :)\n. > Update: It's been hardened, see PR. I hope that means we can now use Some wherever we're expecting a non-null argument, and allow us to remove the null checks everywhere.\nI definitely don't want that.  I think you may have missed my previous comment about the covariance issues - that is a major problem for a library that will work with generic types a lot.  Also for a library that could be used in performant situations it's unwise to do unnecessary allocations.  \nI was actually minded to remove Some from the library altogether, because C# doesn't have a concept of a default constructor for struct, so although they're useful as argument checks where a T is implicitly converted to a Some<T>, I can't guarantee that a caller didn't instance the Some via an array or member variable.  e.g.\n``` C#\n    var x = new Some10;    // x == 10 uninitialised Some\nclass Foo\n{\n    Some<object> Bar;    // This is uninitialised also\n}\n\n```\nBreaking changes are definitely a no-no as well.  The library is heavily used now, so we have to have very good reasons for breaking changes.  I don't think this is a good one.\n(Take a look at a previous issue discussion for the full low-down on the problems with Some: https://github.com/louthy/language-ext/issues/22)\n. @Jagged \n\nLittle confused there, structs don't do allocations.\n\nYep, they do.  structs can be either stack or heap based and also have a copying overhead.  It's definitely a concern for some aspects of this library (like the collections for example).  \n\nWorth asking anyway =)\n\nIndeed :)  Any public interface would need a very good reason to be changed,  The last time I did that was implementing the Map, Lst, Stck, Que and Set types to remove the dependency on System.Collections.Immutable and before that it was to make the fold functions consistent across the library.  Where possible I try to mitigate the effects of a change. For example Lst still derives from the same types that System.Collections.Immutable.ImmutableList did.  Or I used the Obsolete attribute to hold on to previous function declarations.  The fold changes meant a re-ordering of the parameters in the fold delegate - there's no way that couldn't be a breaking change - but it was the right thing to do.\n. @Jagged - Good stuff!  Does that Refactoring Extension do all this automatically?  Or are you going through manually?\n. > For instance you often use ternary expressions where a simpler binary expression could do\nYeah this is actually a blind spot for me.  I tend to fall into the ternary operator a lot.\nCool, I've installed it now. Thanks for the heads up :)\n. Hi Will,\nThere are problems here:\nSome.cs - \nThe documentation:\n\nHolds a value that is guaranteed not to be null.\n\nIt's not guaranteed to not be null.  So this is misleading.  For example:\nC#\n    // This holds 100 Some(null)\n    var x = new Some<object>[100];\n\nUse MatchUntyped or Value to access the value.\n\nThis is slightly misleading.  MatchUntyped would be a rarely used method (for example when serialising).\nAccess to the value would mostly be done via implicit conversion:\nC#\n    Some<MyObj> x;\n    MyObj y = x;\nOr by Value (as your comment states):\nC#\n    MyObj y = x.Value;\nSo I think re-wording those comments to remove the reference to MatchUntyped and put the focus on implicit conversion would be better.\nPlease remove the comments below - they're commit notes rather than code documentation, the code is self explanatory: \n// ToString is not allowed to throw exceptions\n    // GetHashCode is not allowed to throw exceptions\n    // Equals is not allowed to throw exceptions\nThe other changes to ToString, GetHashCode and Equals are fine though.\nThe changes to IsSome and IsNone are bugs.  By calling CheckInitialised you remove the chance that the programmer can interrogate the state of the object because it will throw an exception if initialised == false.\nThe change to MatchUntyped is also a bug.  Any call to match throughout the library is there to allow the programmer to deal with failure/invalid states.\nGetUnderlyingType also doesn't need protection with CheckInitialised\nThanks,\nPaul\n. > The changes to IsSome, IsNone and MatchUntyped were supporting hardening Some as much as possible, to fail fast if nulls or initialised snuck in.\nYep, I appreciate the reasoning; it would make Some inconsistent with the rest of the library however and it wouldn't be honouring the IOptional interface.  You could argue that it shouldn't implement IOptional, but seeing as the value is optional, I think it's valid to give those tools to the programmer.\nOne example of where I have personally found this useful is in a text-interpolation library I have written.  It uses reflection to dot into objects that are wrapped in braces, i.e. {Foo.Bar}.  As well as checking for null it also checks for optional values and allows alternatives to be selected when IsNone == true.  i.e. {Foo.Bar|Foo.Alt}.  It needs IsNone, IsSome, and MatchUntyped to handle failure in the same graceful way that the Option and OptionUnsafe types do.  \nThere are a few types in this library that can get into an uninitialised state.  I have co-opted the Haskell term bottom; which means a computation that never completes [1] - but in our world it means you could get an exception on use.  There are occasions, however, that you wouldn't get an exception: it's mostly to facilitate expression based programming (either in LINQ or through the fluent interfaces).\nFor example Either<L,R> can be in three states, not just the two that most people understand as Left and Right.  It also has Bottom.  That can mean 'uninitialised' if declared in an array or as a member variable, or in this scenario:\n``` C#\n    Either a = 100;   // Right(100)\nvar y = from x in a\n        where x < 100\n        select x;\n\nAssert.True( y.IsBottom );\n\n```\nIf the predicate fails and the Either is filtered out, then it still needs a representation as an Either.  IEnumerable can do it by removing the item from the collection, but an Either represents one value always:  Right or Left.  If it used default(L) and put the instance into a Left state then you could have Left(null), which wouldn't be any use at all.  So that's where the third state Bottom comes in.\nSome operations will throw a BottomException, others will not.  Mostly if you're trying to extract the value then you will get an exception.  However operations like Map, Filter, Fold, Iter, Count, Sum etc. will continue because they can treat the Either as 'empty'.  \nC#\n    // y is in a bottom state\n    var z = y.Map( a => a + 1 ).Sum();\n    Assert.True( z == 0 );\nThis allows expressions to continue and just return an Either in the bottom state at the end rather than blowing up with an exception.  \nAnyway, I hope that gives an insight into the potential validity of uninitialised state.  \n[1] https://wiki.haskell.org/Bottom\n. > Also, why does MatchUntyped allow nulls?\nBecause it's intrinsically unsafe.  So as with MatchUnsafe the constraints are lifted.\n\nAlso ToString and GetHashCode are redundantly checking for nulls when Some, which should be impossible for OptionT.\n\nYup, that's wrong.  It's purely a sanity check really.  But you're right, it shouldn't ever happen.\n\nMatchObservable is failing when null is found. Shouldn't it instead allow nulls, as this is the whole point of OptionUnsafe?\n\nCorrect.  That sounds like a bug.\n. I have committed a fix for MatchObservable btw\n. > Just out of curiosity why do you consider it intrinsically unsafe?\nBecause the only time you would use MatchUntyped is when you have an IOptional and you don't know the type underneath it (which could be either Option<T>, OptionUnsafe<T> or Some<T>.  It is purely there to help with serialisation and for libraries that need access to the option value through reflection.  The behaviour is consistent for all 3 types.  \n\nYep the value would be null when uninitialised, but IsSome will also be\nfalse.\n\nIf you read my comments you'll see I changed what I wrote.  However it really doesn't hurt to have a safety net for ToString and GetHashCode.  It's not worth worrying about in my humble opinion.\n\nps. I also have some related changes to always call the appropriate\nCheckNullNone/SomeReturnValue routine (can't quite remember the name,\nplease excuse if wrong), instead of using the one that requires passing in\n\"None\" or \"Some\" continually.  Will drop a PR later.\n\nFine.  I spotted that the other day and hadn't gotten around to fixing it up.\n. Hi @mr-kawaii - Looking into it now.\n. @mr-kawaii - There's a fix submitted to the main branch (I won't get a chance to do a nuget release until next week probably, so grab from source).\nIt failed because ActorContext.GetDispatcher() would always return a local IObservable<T>, and not observe the Redis stream (by 'local', I mean running in the same application).  GetDispatcher is used to find the appropriate interface to communicate with any ProcessId (locally - in the same app, remotely - in another app, JS - via SignalR)    So if you had run your test and subscribed to a Process running remotely then it would have worked.  But because the Process and the subscriber were in the same app, it failed.\nTo keep the consistency of GetDispatcher(), when ProcessFlags.RemotePublish is used, Publish pushes to both Redis and the local stream.  That means the demo project doesn't do what it says any more unfortunately; because if the process is local and you subscribe to it locally, then the messages you receive won't have come from Redis.  The overall behaviour is correct though.\nI'll update the demo project when I get a chance.  \nThanks for the heads up :+1: \n. > I however didn't understand what you meant by...\nEssentially it means if the system doesn't need to use Redis, it won't.  The publish system, whether it's for state-changes or user-triggered via the publish system uses the Redis pub/sub system which doesn't persist in the same way as sending a message to a Process' inbox - if you're not alive and listening for the publish event then you will miss it.  So it's purely an event system.  Whereas sending a message to the inbox of a Process that's offline will go into a persistent queue that will be given to the Process when it wakes up.\nThat means that for local-to-local publish events, the system now goes direct, without going through \nRedis.  So if you're testing the Redis publish system you should have two applications (or two AppDomains).  That's why the current publish demo will need to be updated.\n\nI suggest adding a test so that in future this particular scenario is covered.\n\nOf course.  Going to be busy for a few days, so I'll get to that next week sometime.\n\nMaybe it would be a good idea to document and explain what each of the ProcessFlags\n\nThe intellisense documentation should be relatively clear on this.  Take a look at ProcessFlags.cs - let me know if you feel it's unclear:\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Process/ProcessFlags.cs\n\nBut I personally don't like enum being used as a switch in this way. It's not natural.\n\nA switch?  Do you mean as a flags system?  It's pretty much the standard way to combine binary settings into a value.\n. > var pid = new ProcessId(\"/redis-test/user/redis-pubsub-random-test\");\n\npid.Tell(DateTime.Now.Millisecond);\n\nThat isn't publish.  tell uses the Redis pub-sub system for notifications only (the notification wakes up the inbox so that it looks in the Redis queue for unprocessed messages) and it uses a different key in Redis.\nBut I do see an issue that could have come about from my fix last night (apologies it was 4am at the time!).  Please grab the latest source.\nIf you would like to zip up your examples and attach them to this thread then I'll happily check them for you.\n. It is absolutely possible for the processes to talk cross-AppDomain via Redis.  I suspect your code is wrong, but until you share the code I can't comment.  \n\nif I \"publish\" from redis, I should see one write line in each console (AppDomain), and if I publish from either AppDomain 1 or AppDomain 2, I should see again, one write line in each console.\n\nThe example you give above isn't valid, and I'm not even sure what it is you're trying to do?  I'd advise you to stop manually publishing in Redis and use the system as designed.  I can't support your ad-hoc direct access to Redis.\n\nhaven't tested the latest version as I don't have access to windows until tomorrow.\n\nThere were bug fixes relating to your earlier issue, so I suggest you get the latest code before running any more tests.\nThings to watch out for:\n- Make sure you have called RedisCluster.register() on each AppDomain\n- Make sure you have called Cluster.connect(...) on each AppDomain and that the second parameter is unique for all AppDomains:\nAppDomain 1:\nC#\n    Cluster.connect(\"redis\", \"redis-test-app-dom-1\", \"localhost\", \"0\");\nAppDomain 2:\nC#\n    Cluster.connect(\"redis\", \"redis-test-app-dom-2\", \"localhost\", \"0\");\n- If you want to 'talk' to processes in another domain, then you must know its path. \nAppDomain 1:\nC#\n    var pid = spawn<string>(\"hello\", msg => publish(\"Hello, \"+msg));\nAppDomain2:\nC#\n    var hello = Process.Top[\"redis-test-app-dom-1\"][\"user\"][\"hello\"];\n    observe<string>(hello).Subscribe(Console.WriteLine);\n    tell(hello, \"Jeffrey\");\n. > By the way, where's Process.Top?\nProcess.Top is / - it's the very root that you can use to build your paths from.\n\nI can't just do something like var hello = Process.Top[\"user\"][\"hello\"];\n\nNo, that process path wouldn't exist, you can register processes by name - but only one process on the cluster can have that name.  Otherwise the behaviour is undefined.\nAppDomain 1\nC#\n    var pid = Process.spawn<string>(\"hello\", msg => publish(\"Hello, \"+msg));\n    Process.register(\"hello-registered\", pid, ProcessFlags.PersistAll);\nAppDomain 2:\nC#\n   var pid = Process.find(\"hello-registered\");\n   Process.tell(pid, \"Jeffrey\");\nWhat Process.register(\"hello-registered\", ...) does is to create a proxy process with the process-ID of \"/registered/hello-registered\".  Process.find(\"hello-registered\") merely builds a new ProcessId like so:  Process.Top[\"registered\"][\"hello-registered\"]\nI think because of the issue raised originally, I would avoid using Process.register and Process.find for the moment, and try and get it working with the absolute paths.  Once you have a working solution (with the latest build) then I would try the register and find option.\n. Rejecting for the following reasons:\n1. Don't use Some<T> for all of the reasons previously discussed.\n2. Either<L, Res>.Bottom() would be better as Either<L, Res>.Default where Default is static readonly Either<L,R> Default.  That removes the allocation overhead of the current solution and your replacement.\n. Please stop arguing with me regarding structs and allocation, I know exactly how they work.  Please take a look at Eric Lippert's comments on this:  http://blogs.msdn.com/b/ericlippert/archive/2009/04/27/the-stack-is-an-implementation-detail.aspx\nI will review the PR tomorrow.\n. And this too: http://blogs.msdn.com/b/ericlippert/archive/2010/09/30/the-truth-about-value-types.aspx\n. Hi Will, thanks for understanding.  It's not personal, but I had already made my position clear.  I have a limited amount of free time to do this project, and going over the same point multiple times can suck that time away.  \n\nstruct types are stack allocated unless they're part of another class. They are not heap allocated by themselves. Yes it's an implementation detail, but it's still a fact for today's compilers.\n\nThat still isn't correct.  It's more nuanced.  If they're captured as part of a closure (which is an anonymous class) then there will be allocation.  A lot of this library is based around the use of closures.  So using Some<T> would without a doubt do more allocations than is necessary - I have to be careful to not add a burden where it has little benefit.  Yes it means manually checking for null, and that's annoying, but it's a price that's worth paying for improved performance.\n. PR review:\nThe comment says Value, must be null.  Should be Value, must not be null\nhttps://github.com/louthy/language-ext/pull/56/files#diff-10ea3cb60b61e03c47de7a19e0abf023R108\nPerhaps change the strings of \"Left\", \"leftMap\", etc. into nameof(Left), nameof(leftMap) etc.\nEverything else looks good.\n. > If a closure was going to capture a variable then it was already going to have to allocate space via an anonymous object to hold it. True?\nI'd suggest reading that second link I posted - especially the last few paragraphs.  It would have to allocate twice, once for the anonymous object and once for the struct member that is allocated on the heap.\nPlease I'd really like to drop this now.  I am not going to accept Some in the project.  The memory allocation was one of the reasons I have given several times already, the other was the lack of covariance in generic structs.  They both add up to problems.  So we're wasting time discussing it, sorry.\n\nps I'm about to submit a PR to nuke SomeT from high orbit so I'm not tempted to use it in future... =)\n\nDon't.  People are using this library.  I don't want to fuck them over by dropping features they're using.  Some<T> can be useful for certain circumstances.  It's just not general enough for this library's API.\n. I agree, I've renamed it to Multiply.  No need to keep the old signatures here, this hasn't yet been released.\n. Hi @Woodz, you should work with the extension methods for Try<T>\nC#\n   var res = doRiskyFunction.Match(\n        Succ: val => ...,\n        Fail: ex => ....\n    );\nTryResult is very much an intermediate state that only exists to facilitate the extension methods.\n. Append is primarily to support the monadic types and is named because of mappend in Haskell.  This is to bring familiarity.  Add clashes with the default behaviour of lists, maps and sets.  There is no extension method for numeric types so it doesn't have an API effect. \nIt would like to keep it as Append and IAppendable\n. Sorry, haven't really had time to follow this up.  \n\nHave you seen Tail.Fody\n\nNot that specific plugin no, but I have seen Fody.  I think Tail.Fody whilst useful for the end-user, isn't really that useful for language-ext.  Also I believe that RyuJIT is supposed to do a better job of dealing with tail-calls, so it's probably moot.  It's nearly never an optimisation in C# because loops will always be faster than recursion.  I think for the users of Language-Ext they would prefer the speed benefits of a pure functional interface hiding imperative behind-the-scenes (as long as the behaviour is referentially transparent - as with the fold implementations).\n\nThere's another for adding null checks to all methods, except for where you specify, eg. OptionUnsafe.\nhttps://github.com/Fody/NullGuard\n\nThat's definitely more interesting, but might be a painful process of retrofitting [AllowNull] where it is allowed.  I'd be quite cautious about this, because of possible breaking changes.  I dunno, I'm torn, because it's obviously a very good idea, and I can't stand the fact that the if(arg == null) checks breaks expression based code.\n. My understanding is that you can't opt-in, you can only opt-out by using\n[AllowNull], so that would be a project-wide change.  That is my concern.\nThere's a ton of code that would need to be considered.  Unless you know\notherwise?\nIt seems to defeat the point having to opt-in.\nOn Mon, 9 Nov 2015 at 08:20 Will Mooar notifications@github.com wrote:\n\nIf you're interested, I could put NullGuard just into OptionT and\nUnsafeOptionT, and see what you think from there?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/issues/62#issuecomment-154994482.\n. It seems to me to be the kind of thing that would only be valuable project-wide.  Otherwise when you look at any cs file you won't know whether it's got the protection it needs [without looking at some project settings].  If you're prepared to take it on project-wide that'd be great, but I wouldn't underestimate the amount of work and the cautious approach you'd need to take.\n. Thanks Will, I don't think it's time wasted.  It definitely has potential.\nLet's keep an eye on it.\n\nOn Mon, 9 Nov 2015 at 08:55 Will Mooar notifications@github.com wrote:\n\nClosed #62 https://github.com/louthy/language-ext/issues/62.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/issues/62#event-458603457.\n. Hi @pahomovda - thanks for reporting this.  If you build from the latest source then you'll find this is fixed.\n. The changes to the docs where you put \"if Right\", \"if Left\", etc. should be removed.  It's still a fold regardless of the state of the underlying monad. Imagine a list with zero items in, if you do a fold on that then you just get your input state back; it is however still a fold, and that applies to Option and Either types and any type that can have a 'no value' state.\n\nI'm also not sure replacing every ... == null with isnull(...) is such a great idea.  it's obviously worth doing for generic types, but there are a lot of places where you've it used on reference types and would add the overhead of a function call where it's not really necessary.  I could probably put the AggressiveInlining attribute on the isnull and notnull functions however, which would probably solve that issue; but was there a reason you applied it to all null checks?\n. > Re \"if left/right\" , done. =)\nIt's the same for the other monads too:\nhttps://github.com/louthy/language-ext/pull/65/files#diff-f82b6b3e8bdc33537e9dbbff34b9f63cR604\nhttps://github.com/louthy/language-ext/pull/65/files#diff-d9646d9b4cf5ff61782ddc0f2963e5a2R186\nhttps://github.com/louthy/language-ext/pull/65/files#diff-9063c670a7e6125a3c7c073e64dc00bdR100\nhttps://github.com/louthy/language-ext/pull/65/files#diff-9063c670a7e6125a3c7c073e64dc00bdR100\nhttps://github.com/louthy/language-ext/pull/65/files#diff-ceca91f15305b8784e611d30d8c95851R141\nhttps://github.com/louthy/language-ext/pull/65/files#diff-62b2de3e24de9a5e255d21b4755c4297R536\nhttps://github.com/louthy/language-ext/pull/65/files#diff-3716676838224af20d9e96d45d8a64abR500\nAlso instead of saying, 'fold the Try result' or 'fold the TryOption result', it would be better to say 'fold the Try value'.  Try and TryOption being delegates isn't really relevant, and introducing the idea of a result isn't useful.  They're lazy values rather than delegates that return a value whereas the other non-delegate monads are strict values.\nhttps://github.com/louthy/language-ext/pull/65/files#diff-ceca91f15305b8784e611d30d8c95851R141\nhttps://github.com/louthy/language-ext/pull/65/files#diff-62b2de3e24de9a5e255d21b4755c4297R536\nhttps://github.com/louthy/language-ext/pull/65/files#diff-3716676838224af20d9e96d45d8a64abR500\n. Hi Will, I'm away at the moment, I'll check when I'm back (Tuesday).\nOn Thu, Nov 12, 2015 at 20:00 Will Mooar notifications@github.com wrote:\n\nMorning! Is there anything I've missed holding up this PR?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/pull/65#issuecomment-156218228.\n. Wouldn't even know where to start.  Any thoughts on the best approach? \n. @feugen24 It turns out there's a portability checking tool\n\nhttp://dotnet.readthedocs.org/en/latest/porting/supporting-core.html\n- LanguageExt.Core is ready to go bar Rx.  So I guess as soon as there's a .NET Core version of Rx then I can make the move too.\n- LanguageExt.Process and LanguageExt.Process.Redis is also mainly blocked by Rx, and a few other minor issues like the use of CallContext, but they're fixable relatively easily.\n- LanguageExt.Process.FSharp - ready to go\n- LanguageExt.ProcessJS - ready to go\nThanks for the heads up and the links.  I'll need to do a bit more reading to be sure I know what I'm doing here.  I am surprised that the Process system is as close as it is to being portable, so if that can run cross-platform I'll be very happy.\n. @feugen24 - Ok, it looks like I have a dnxcore50 build that is all happy, even with Rx.  I don't have the means to test it out at the moment.  But if you open up the project.json in LanguageExt.Core then you should be able to build both dnxcore50 and dnx451 builds.\nThat really wasn't a fun process!\n. @feugen24 - Slowly getting through all of the projects.  So far we have:\n| Project | dnx451 | dnx461 | dnxcore50 | blockage |\n| --- | --- | --- | --- | --- |\n| LanguageExt.Core | yes | yes | yes |  |\n| LanguageExt.FSharp | yes | yes | yes |  |\n| LanguageExt.Process | yes | yes | yes |  |\n| LanguageExt.Process.Redis | yes | no | no | StackExchange.Redis |\n| LanguageExt.ProcessJS | yes | yes | no | SignalR |\n| LanguageExt.ProcessJS.Tests | yes | no | no | SignalR |\n| LanguageExt.Tests | yes | no | no | Won't be unblocked until all the others are |\n- StackExchange.Redis are very close : https://github.com/StackExchange/StackExchange.Redis/issues/202\n- SignalR - can't find any evidence of it working with dnxcore50, which seems odd!  No packages resolve for Microsoft.AspNet.SignalR\nThe process continues!\n. @IanYates Thanks for the info Ian.  Do you have a link to where that was mentioned by any chance?\n. @IanYates  Thanks for the heads up, that's good to know.\n. @plouh - Rx isn't a blockage any more.\n. @BrainCrumbz It is available to include in DNX builds, so I believe it has been ported, yes.   I've paused this migration until MS decide themselves what it is they're doing. \n. It's used for ProcessJS, which is a JavaScript actor-system that can talk\ndirectly to the C# Process system via a SignalR hub.\nOn Thu, Jul 28, 2016 at 19:35 Asad Saeeduddin notifications@github.com\nwrote:\n\n@louthy https://github.com/louthy Haven't dug into the codebase, but\nwhat are you using SignalR for?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/70#issuecomment-235985010,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkyfMBiBdd28bFI356euKREpI814aks5qaPZSgaJpZM4GsmFM\n.\n. @masaeedu It already is. As is the Process system. The only thing that isn't on\n.NETCore is ProcessJS (which relies on SignalR)\n\nOn Wed, Oct 19, 2016 at 21:29 Asad Saeeduddin notifications@github.com\nwrote:\n\n@louthy https://github.com/louthy Given that the actor system stuff is\nin a different project, couldn't LanguageExt.Core and the associated nuget\npackage be transitioned to .NET Core now?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/70#issuecomment-254931085,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk0IJLanyMdCUiyXfla__tnebolhlks5q1n2UgaJpZM4GsmFM\n.\n. I don't remember the exact reason, but I did try to get it running for 1.3, so something got in the way.  I'm away from the project for a few days, I'll check later next week.\n. @DamianReeves Curiosity got the better of me.  It seems whatever was blocking me using 1.3 before, now isn't (apart from on LanguageExt.FSharp, which only needs 1.4).  \n\nAnyway, I've deployed v1.9.5 of all the language-ext nuget packages which depends on netstandard13.\n. All compatible with NET Standard 1.3.  Closing.. @la-yumba  Fantastic.  Thanks!\n. @la-yumba Hi Enrico - I'd be honoured!  Feel free to contact me at p.louth@gmail.com \n. @blairconrad - Thanks Blair :+1: \n. No worries, it's the code that talks :)\nOn Wed, 16 Dec 2015 at 00:40 Blair Conrad notifications@github.com wrote:\n\nThank you!\nAnd I'm not sure what that weird \"f\" comment is above. I think I mashed\nthe keyboard when saving the change\u2026\nSorry.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/pull/74#issuecomment-164946298.\n. Thanks!\n. Well spotted!  Thanks.  New version on nuget :)\n. Both Map and Bind are lazy for lists, and will evaluate each time you use them.  You can bake the result in your case by adding .ToList() to the end of the expression that assigns to nl\n\nC#\n    var nl = l.Map(ei => ei.Bind(s => { Console.WriteLine(s); return Prelude.Right<Unit, string>(s); })).ToList();\n. > Normally I would expect \u201ctrue\u201c laziness to evaluate each thunk only once and then use the cached result for each consecutive call;\nIndeed.  Unfortunately that's not the behaviour of IEnumerable and yield return in C#.  I suspect because it is a side-effecting language, so assumptions can't be made about the referential transparency of a computation - which is not the case in Haskell for example.\n. > So .ToList() forces the LINQ thunk to be evaluated?\nIt forces an IEnumerable<T> to be evaluated and stored in a List<T>; you can also use ToArray() which will give you a T[].  If you want to use the immutable list type Lst<T> in lang-ext instead of the mutable System.Collections.Generic.List<T> that you have been using, then Freeze() is the operation to bake-in the evaluated values of an IEnumerable<T>.\n. Hi @Profpatsch - this got me thinking a bit more.  There is a general problem with the laziness and over-evaluation of IEnumerable<T>.  In the list matching functions I tried to minimise it as much as possible, but it would still evaluate the head item and then the head item again to skip to the tail (which is what you saw).  It was something that stuck in my mind at the time as something I wanted to fix...\nI have added 'Enumerable memoization' to lang-ext.  So instead of using .ToList() to force evaluation of the whole enumerable, you can now use seq.Memo()  or memo(seq) where seq is the IEnumerable.\nThey both return an IEnumerable<T>, but they don't evaluate the items in the sequence until they're needed, and once evaluated, they're cached so that repeated attempts to use the IEnumerable don't re-evaluate.\nThey can't be used to evaluate infinite sequences, because you'll run out of memory.\nHere's an example of a problematic evaluation (similar to your example).  The intent of the code is clear, to print the first and second items in the list (from a sequence that is Int32.MaxValue items in size - so doing ToList would fail).  \nThe Items function however has a side effect, which is to write the current value to the console:\n``` C#\n        static void Test()\n        {\n            var list = Items();\n        Console.WriteLine($\" -> {list.Head()}\");\n        Console.WriteLine($\" -> {list.Tail().Head()}\");\n    }\n\n    static IEnumerable<int> Items() =>\n        Range(0, Int32.MaxValue).Select(x =>\n        {\n            Console.WriteLine(x);\n            return x;\n        });\n\n```\nThen output is:\n0\n     -> 0\n    0\n    1\n     -> 1\nClearly the head item has been evaluated twice.  If I change the original to use Memo:\n``` C#\n        static void Test()\n        {\n            var list = Items().Memo();\n        Console.WriteLine($\" -> {list.Head()}\");\n        Console.WriteLine($\" -> {list.Tail().Head()}\");\n    }\n\n```\nThen output is:\n0\n     -> 0\n    1\n     -> 1\nAs expected, but also it didn't need to evaluate the whole sequence to do this.  Perhaps this will be more useful to you than using ToList?  \nEither way, it's useful for language-ext because it improves the IEnumerable match functions.  \nIt's all rolled out to nu-get, version 1.7.26.  I'm re-opening this temporarily to give yourself and anybody else a chance to comment. \n. > I wonder if it would be possible to enable this memoization by default?\nIt would have to be provided by the underlying sequence implementation.  For example I could probably find a way of making it work for lang-ext's Lst<T> (and the other collections in the library), but as far as I am aware there's no way of overriding the default yield return behaviour of C#.  It's debatable how 'correct' that would be even if you could.  I agree with you that memo-by-default with opt-out (if required) would be better than having to opt-in to memoization. \n\nIf it is not, I\u2019m at a loss. It should be very well documented at least, but since this concerns pretty much every function in this library, it would fit into an FAQ best probably.\n\nI'm not sure that's appropriate.  This library isn't here to make excuses for C# and its IEnumerable and yield behaviour.  I think it's quite widely understood (because LINQ is used for SQL query providers mostly) that calling .ToList() or .ToArray() causes evaluation; and repeated evaluation is a desired feature when the underlying sequence (which is often coming from a DB) could have changed.\nThere's no quick fix I'm afraid.  It's just a language quirk.  I will consider the implications of making it the default behaviour for lang-ext.  My concern would be that it could break existing code and it goes against what most people understand re: IEnumerable\n. Thanks Steve, I'm away this weekend, so I'll take a look on Monday.   If you have a suggested fix feel free to submit a pull request.\n. Fixed in nuget release 1.7.28\n. @ncthbrt - Hi Nick, I had actually removed the Serialization attribute when updating the project to support DNX.  It seems the Serialization attribute is on its way out, and isn't supported in DNX.  I guess most serialisation is done with Json.NET or similar these days.\nAnyway, I've now restored it for non-DNX builds.  Please grab the latest version from nu-get: 1.7.29\n. Have you considered converting your Tasks to Observables using Rx?  I'm not near an editor at the moment so can't provide any examples.  Option has various MatchAsync and MatchObservable extensions which may be worth looking at too (not sure if I got around to putting them into Either).  \nI suspect what you actually need is an Async monad type, that can work with the monad transformer system.  That would allow for Async<Option<T>>.  I'll have a think about that tomorrow.\n. @cocogorilla I have added Task<T> extension methods to LanguageExt.Core that turn it into a monad.  And have added the standard set of functions that work with the higher-kinded type system, so you get to work with Option<Task<T>> and Task<Option<T>> as though they were a single value.\nHere's a simple example with Task<int> and Task<Option<int>>.  Note that Action3() returns an Option<int>, so it then needs to be unwrapped in the select.  The result of the computation is Task<Option<int>>.  \n``` C#\n        public void TaskLINQTest2()\n        {\n            var computation = from x in Action1(0)\n                              from y in Action2(x)\n                              from opt in Action3(y)\n                              select from z in opt \n                                     select x + y + z;\n        Assert.True(computation.Result == 10);\n    }\n\n    public async Task<int> Action1(int x)\n    {\n        await Task.Delay(100);\n        return x + 1;\n    }\n\n    public async Task<int> Action2(int x)\n    {\n        await Task.Delay(200);\n        return x + 2;\n    }\n\n    public async Task<Option<int>> Action3(int x)\n    {\n        await Task.Delay(300);\n        return x + 3;\n    }\n\n```\nYou mentioned the TryMonadTests, unfortunately that code didn't work, and has been fixed for both Try<T> and Task<T>.  This is the example with Task<T>:\n``` C#\n        public Task> getURLContent(string url) =>\n            from u in parseUri(url)\n            from conn in openConnection(u)\n            from result in use(\n                getInputStream(conn),\n                stream => use(getSource(stream), getLines)\n                )\n            select result;\n    [Fact]\n    public void UrlTest()\n    {\n        getURLContent(\"http://www.google.com\").IterT(x => Console.WriteLine(x));\n    }\n\n```\nNotice how getURLContent returns Task<IEnumerable<string>>, but I'm able to iterate the wrapped list.  \nYou need to include LanguageExt.Trans if you want to use the transformer functions (the functions that work on wrapped monads and are appended with the T).\nThe available Task<T> functions are:\n| Task<T> extension | Task<M<T>> transformer | M<Task<T>> transformer |\n| --- | --- | --- |\n| Select | n/a | n/a |\n| SelectMany | n/a | n/a |\n| Where | n/a | n/a |\n| Map | MapT | MapT |\n| Filter | FilterT | FilterT |\n| Bind | BindT | BindT |\n| Fold | FoldT | FoldT |\n| Iter | IterT | IterT |\n| Sum | SumT | SumT |\n| Count | CountT | CountT |\n| Exists | ExistsT | ExistsT |\n| ForAll | ForAllT | ForAllT |\n| Prelude | Task<M<T>> transformer | M<Task<T>> transformer |\n| --- | --- | --- |\n| map | mapT | mapT |\n| filter | filterT | filterT |\n| bind | bindT | bindT |\n| fold | foldT | foldT |\n| iter | iterT | iterT |\n| sum | sumT | sumT |\n| count | countT | countT |\n| exists | existsT | existsT |\n| forall | forallT | forallT |\nThe latest is on nu-get now (1.7.37)\n. Sorry I should have said, the test is just an example of use/LINQ/etc with tasks, it doesn't do the bit where it requests anything from the domain (didn't want to get bogged down on the streaming bit).  Let me know if it's still unclear and I'll work on some examples tomorrow.\n\nbtw, awesome work, way above and beyond what I anticipated, and in short\norder as well.\n\nNo probs. I tend to try to fill the gaps in the library as I come across them in real world use, but we all write code differently so when an idea comes along I'll grab it :)\n\nOn Mar 31, 2016, at 23:59, Ethan Nelson notifications@github.com wrote:\nI slightly modified the tests and had trouble getting them to work. I\nthought for certain the second version would work... yet it did not appear\nto.\n[Fact]\npublic void UrlTest()\n{\nvar results = new List();\nvar lines = getURLContent(\"http://www.google.com\").IterT(\n(x) => results.Add(x));\nAssert.NotEmpty(results);\n}\n[Fact]\npublic async void UrlTestAsync()\n{\nvar results = new List();\nvar lines = await getURLContent(\"http://www.google.com\");\nlines.Iter(\n(x) => results.Add(x));\nAssert.NotEmpty(results);\n}\nbtw, awesome work, way above and beyond what I anticipated, and in short\norder as well.\nThanks,\n-Ethan Nelson\nOn Thu, Mar 31, 2016 at 8:34 AM Paul Louth notifications@github.com wrote:\n\n@cocogorilla https://github.com/cocogorilla I have added Task\nextension methods to LanguageExt.Core that turn it into a monad. And have\nadded the standard set of functions that work with the higher-kinded type\nsystem, so you get to work with Option> and Task> as\nthough they were a single value.\nHere's a simple example with Task and Task>. Note that\nAction3() returns an Option, so it then needs to be unwrapped in the\nselect. The result of the computation is Task>.\npublic void TaskLINQTest2()\n{\nvar computation = from x in Action1(0)\nfrom y in Action2(x)\nfrom opt in Action3(y)\nselect from z in opt\nselect x + y + z;\nAssert.True(computation.Result == 10);\n}\npublic async Task Action1(int x)\n{\nawait Task.Delay(100);\nreturn x + 1;\n}\npublic async Task Action2(int x)\n{\nawait Task.Delay(200);\nreturn x + 2;\n}\npublic async Task> Action3(int x)\n{\nawait Task.Delay(300);\nreturn x + 3;\n}\nYou mentioned the TryMonadTests, unfortunately that code didn't work, and\nhas been fixed for both Try and Task. This is the example with\nTask:\npublic Task> getURLContent(string url) =>\nfrom u in parseUri(url)\nfrom conn in openConnection(u)\nfrom result in use(\ngetInputStream(conn),\nstream => use(getSource(stream), getLines)\n)\nselect result;\n[Fact]\npublic void UrlTest()\n{\ngetURLContent(\"http://www.google.com\").IterT(x => Console.WriteLine(x));\n}\nNotice how getURLContent returns Task>, but I'm able\nto iterate the wrapped list.\nYou need to include LanguageExt.Trans if you want to use the transformer\nfunctions (the functions that work on wrapped monads and are appended with\nthe T).\nThe available Task functions are:\nTask extension Task> transformer M> transformer\nSelect n/a n/a\nSelectMany n/a n/a\nWhere n/a n/a\nMap MapT MapT\nFilter FilterT FilterT\nBind BindT BindT\nFold FoldT FoldT\nIter IterT IterT\nSum SumT SumT\nCount CountT CountT\nExists ExistsT ExistsT\nForAll ForAllT ForAllT\nPrelude Task> transformer M> transformer\nmap mapT mapT\nfilter filterT filterT\nbind bindT bindT\nfold foldT foldT\niter iterT iterT\nsum sumT sumT\ncount countT countT\nexists existsT existsT\nforall forallT forallT\nThe latest is on nu-get now (1.7.37)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/issues/81#issuecomment-203988688\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\n. @cocogorilla Hi Ethan, just to follow up on this (I was replying from my phone last night, so couldn't give much info).  The example in the unit tests file was primarily a demo from a previous conversation comparing Scala Try to lang-ext Try, see here: https://github.com/louthy/language-ext/issues/33\n\n\nFor a fully working example, that works better in .NET world you could try this.  It fully disposes the WebClient after use and also demos MapT, SumT and IterT.  \n``` C#\n        Task parseUri(string uri) => \n            new Uri(uri).AsTask();\n    Task<WebClient> getClient() =>\n        Task.FromResult(new WebClient());\n\n    Task<string> getContent(Uri uri, WebClient client) =>\n        client.DownloadStringTaskAsync(uri);\n\n    Task<Lst<string>> getLines(string text) =>\n        Task.FromResult(text.Split('\\n').Freeze());\n\n    Task<Lst<string>> getURLContent(string uri) =>\n        from address in parseUri(uri)\n        from result  in use(\n            getClient(),\n            client => from content in getContent(address, client)\n                      from lines   in getLines(content)\n                      select lines)\n        select result;\n\n    public void UrlTest()\n    {\n        // Iterates all lines of content\n        getURLContent(\"http://www.google.com\").IterT(x => Console.WriteLine(x));\n\n        // Counts the number of lines\n        int numberOfLines = getURLContent(\"http://www.google.com\").CountT();\n\n        // Maps the lines to line-lengths, then sums them\n        int totalSize = getURLContent(\"http://www.google.com\")\n                            .MapT(x => x.Length)\n                            .SumT();\n    }\n\n```\n. @StanJav Thanks Stan :)\n. @dhalsim \n\nNice library and set of tools there! \n\nThanks :)\n\nBut one thing I didn't get is how currying here works. I would expect functions like map have signature like this:\n\nYeah it was a bit of an oversight when I first wrote the library.  The currying and partial-application functions came later.  To be honest I wasn't sure whether I was going to put currying or partial-application in, because C#'s type inference just causes headaches.  \nSo using the par function to partially apply on the map function won't compile (if we assume that the parameters are the right way around):\nC#\n    var dbl = par(map, x => x * 2);\nC#'s type inference is basically terrible, so it can't work this out.  You'd need:\nC#\n    var dbl = par<Option<float>, Func<Option<float>, Option<float>>, Option<float>>(map, x => x * 2);\nNot pretty.  \nBut back to the original point: I'd love to change the parameter ordering, unfortunately I now have to be concerned about being backwards compatible.  Enough people use the library that I try to keep breaking changes to a minimum.  I suspect this might be a step too far to fix it.  I'm interested in hearing others' opinions though.  I suspect not enough people use currying or partial application to desire a change.\nTo try and make the curry situation less onerous there is actually a function called lpar that partially applies a single parameter to the left.\nC#\n    var dbl = lpar(map, x => x * 2);\n(Without the generic types for clarity)\n. @dhalsim I think looking at the link you posted it would make more sense for me to annotate the library with [Pure] attributes.  I had noticed those attributes in the BCL, but wasn't sure what the BCL team were using them for (other than internal tooling); suddenly it's a bit clearer!  \nI'm currently midway through a few large changes on the multi-system branch.  Once that's settled down I'll start the annotations.\n. @dhalsim All pure functions in the Core library are now annotated with the [Pure] attribute which should hopefully solve your problem (v1.8.17-beta on nu-get).\n. Adoption of this package seems fine to me.  The library originally used the ImmutableCollections but I removed the dependency because of the cognitive overhead of the naming.  This library is here to make functional first easier than the BCL.  For example:\nc#\n    Map<string,int>\nis significantly less eye and finger pain compared to \nc#\n    IImmutableDictionary<string, int>\nA map of maps even more so:\nc#\n    Map<string, Map<string,int>>\nCompared to...\nc#\n    IImmutableDictionary<string, IImmutableDictionary<string, int>>\nThe lang-ext libraries has functionality not available in ImmutableCollections and that can't be retro-fitted through extension methods (like range finding).\nIf you need to use ImmutableCollections, use them.  They're just an additional dependency.  You still get the benefit of the lang-ext extension methods (Map, Fold, etc.) because of the extension methods for IEnumerable<T>.  If you need interop, write some extension methods.\n. using LanguageExt.Trans;\nShould do it.\n. This is now mentioned in the documentation.\n\nNice package, though.  It makes for some very robust C#.\n\nCheers :+1: \n. @pnowosie Sorry for the slow reply on this, I've been bogged down with the multi-system refactor for the Process system.  I have updated the IntegerRange and CharRange types to allow zero length ranges.  Will be available on the next deployment 1.8.17-beta (probably over this weekend).\n. @LukeJanPracuj \nAll matching with Option is thread-safe, it's an immutable type.\n. @LukeJanPracuj - I'm not sure if I'm misunderstanding your question, or if you're misunderstanding my response.  \n\nthe object on which we call the Match func\n\nThe 'object' would be the Option, and is immutable, and therefore you can call match on it (or any function you like) without locks and is entirely thread-safe - as is the case with all types in this library.  However if the type that you store your Option in is mutable then you will need a lock for the duration of the operation, i.e:\n``` C#\n    class YourType\n    {\n        Option opt;\n        object sync = new object();\n    public void Map(Func<T,T> map)\n    {\n        lock(sync)\n        {\n            opt = opt.Map(map);\n        }\n    }\n}\n\n```\nIf you just want to get a value from matching, then no locks are required, and there are zero threading issues.  i.e.\n``` C#\n    class YourType\n    {\n        readonly Option opt;\n    public R MapValue<R>(Func<T,R> map)\n    {\n        return opt.Match( Some: map, None: default(R) );\n    }\n}\n\n```\nThat's one of the major benefits of using immutable values.  You can pass them around to different threads without any concerns.\n. @Hinidu - thanks!\n. Unfortunately covariance isn't available for generic structs, and all types like Option, Either, etc. are structs (to remove the null problem).  It's a limitation I'm afraid (until C# can behave a little less shit in this area).  If you need to cast the generic type then the best approach I have found is to use the Map, MapLeft, or BiMap operators.\n. in and out invariance settings are done on interfaces, so for example I could do:\npublic interface ILst<out T> would make it covariant \npublic interface ILst<in T> would make it contravariant\nAnd then derive Lst<T> from ILst<T>\nThe problem is that most operations require inputs and outputs, making the resulting ILst<T> pretty useless.  For example:\nc#\n    ILst<T> Add(T value);\nIt's the nature of immutable value-types to have associated behaviours that require an input and generate a new value; and therefore tripping up on C#'s constraints for covariance and contravariance.  This means out and in aren't available.  \nIf you look at the interfaces that Set, Map, Lst, etc. derive from: IEnumerable<T>, IReadOnlyList<T>, etc.  They all support covariance, but they also have a tiny set of supported operations.  I have just done a quick scan of Lst<T>, and there's only Reverse that would work in a covariant interface, and none of the methods would work in a contravariant one.\nAgain you will either need to Map the collections, or work with the more abstract types from early on so that you don't need a conversion.  Personally I find that I very rarely trip up on this stuff now, but that's probably because I use inheritance much less frequently than I did in my OO days.\n. @Hinidu Indeed it's sometimes a little ugly I'm afraid.  To reduce the amount of clutter from casting I tend to use the as operator (even if it's slightly less efficient):\nc#\n    public static Either<Error, TValue> GetEither<TKey, TValue>(\n        this IDictionary<TKey, TValue> dictionary, TKey key)\n    {\n        return dictionary.TryGetValue(key)\n            .ToEither(() => new KeyNotExistError<TKey, TValue>(key) as Error);\n    }\nOr you could use MapLeft if you want to be more declarative:\nc#\n    public static Either<Error, TValue> GetEither<TKey, TValue>(\n        this IDictionary<TKey, TValue> dictionary, TKey key)\n    {\n        return dictionary.TryGetValue(key)\n            .ToEither(() => new KeyNotExistError<TKey, TValue>(key))\n            .MapLeft(x => x as Error);\n    }\n. @OlduwanSteve Looking into this now\n. @OlduwanSteve This is fixed in v1.8.16-beta, there was some real weirdness with how Options were being serialised by Json.NET.  It would turn Some(123) into \"123\", losing all type info and property names.  So relying on TypeNameHandling.All to provide the type details for deserialisation didn't cut it.  \nAnyway, resolved.\n. @andrevdm\nI've gone through in my head of the options.  The only thing I can think of (without reflection or emit gymnastics) would be:\n``` c#\n    public class NewType : IEquatable>\n    {\n        public readonly T Value;\n        public NewType(T value)\n        {\n            Value = value;\n        }\n    public bool Equals(NewType<T> other) =>\n        !Object.ReferenceEquals(null, other) &&\n        this.GetType() == other.GetType() &&\n        Value.Equals(other.Value);\n\n    public override bool Equals(object obj) =>\n        !Object.ReferenceEquals(null, obj) &&\n        Equals((NewType<T>)obj);\n\n    public override int GetHashCode() =>\n        Value == null ? 0 : Value.GetHashCode();\n\n    public static bool operator ==(NewType<T> lhs, NewType<T> rhs) =>\n        lhs.Equals(rhs);\n\n    public static bool operator !=(NewType<T> lhs, NewType<T> rhs) =>\n        !lhs.Equals(rhs);\n\n}\n\npublic class Metres : NewType<int>\n{\n    public Metres(int value) : base(value)\n    {\n    }\n}\n\npublic class Hours : NewType<int>\n{\n    public Hours(int value) : base(value)\n    {\n    }\n}\n\n```\nThat has the one constructor/value constraint required of newtype, the derived types (Hours and Metres) aren't the same, even though they both wrap int.\n``` c#\n            var m1 = new Metres(1);\n            var m2 = new Metres(1);\n            var m3 = new Metres(2);\n        var h1 = new Hours(1);\n        var h2 = new Hours(1);\n        var h3 = new Hours(2);\n\n        var r1 = m1 == m2;    // true\n        var r2 = m1 == m3;    // false\n        var r3 = m1 == h1;    // This won't compile because Hours and Metres are different\n\n```\nIt's definitely not as robust as Haskell, but it gets some of the way I think.  Ultimately you will always need to declare an actual type if you want compile-time checking.  \nIn terms of pattern-matching.  Well if you have a function that only takes a Metres type, then the work is done.  So having .Value access is probably enough.  If you have something that takes a NewType<T> then you'd need to us if( x is Metres ) ... and cast.  That could definitely be wrapped up in a match or map function.\nIn terms of multiple type-params, you'd need to create a NewType<A,B>, NewType<A,B,C> etc, and update the Equals operators to do compare all values.\nNot 100% sure this is a great fit for lang-ext right now.  But I'll give it some thought.\n. @andrevdm I thought about it, and have decided to add it.  I've super-charged it somewhat compared to the example above: https://github.com/louthy/language-ext/blob/master/LanguageExt.Core/NewType.cs\nTypes derived from NewType<T> are:\n- Equatable\n- Comparable\n- Appendable\n- Subtractable\n- Multiplicable\n- Divisable\n- Foldable\n- Functors (with limitations)\n- Monadic (with limitations)\nUnit tests are here: https://github.com/louthy/language-ext/blob/master/LanguageExt.Tests/NewTypeTests.cs\nIn certain places the C# type system isn't strong enough to do compile-time checks.  And behaviours on NewType like Map must return NewType<T> rather than the sub-class.  So certain operations will throw an exception at runtime if you mix types - this is a probably more 'dynamic' than you'd like, but at least the type checking is there - it's definitely an improvement on working with int:\n- Append and the + operator (works with numeric values and collections), performs runtime checks\n- Subtract and the - operator (works with numeric values and collections), performs runtime checks\n- Divide and the / operator (works with numeric values), performs runtime checks\n- Multiply and the * operator  (works with numeric values and collections), performs runtime checks\n- The comparison operators: <, >, <=, >=, perform runtime checks\n- SelectMany - monadic binding, performs runtime checks\nMap and Select take a NewType<T> and return a NewType<T>, so you can't change the generic type by mapping - this seems like a sensible limitation.  This is also true for SelectMany.  However, internally it relies on derived types having one constructor with one argument: this allows NewType<T> to construct the sub-types with reflection and always maintain the correct sub-type even though it's the base-class performing the operations.\nSo for example:\n``` c#\n    // Declare a new-type called Metres, that only accepts double\n    class Metres : NewType { public Metres(double value) : base(value) }\n// Instantiate a new Metres value\nvar v = new Metres(1);\n\n// Map must return a NewType<double> because Map is in the base-class\nNewType<double> res = v.Map(x => x + 1);\n\n// true -- so even though res is NewType<double>, it is still a Metres type \n// and will maintain the same runtime checks\nDebug.Assert( res is Metres );\n\n```\nYou can cast the type if you need it back as Metres:\nc#\n    Metres res = v.Map(x => x + 1).As<Metres>();\nOr use the built in as operator:\nc#\n    Metres res = v.Map(x => x + 1) as Metres;\nBecause they're monadic you can also LINQ:\n``` c#\nvar m1 = new Metres(100);\nvar m2 = new Metres(100);\nvar res = (from x in m1\n           from y in m2\n           select x + y) as Metres;\n```\nNOTE: Because of the runtime checks, and reflection based invocation of constructors, this will be slower than working with manually built types.\n. @danielcweber \nHi Daniel, thanks for this.  However at this time I won't accept.  I like to keep all of the monadic types in-sync, and so adding BindAsync an MapAsync to Option would also require it adding to:\nOptionUnsafe, Either, EitherUnsafe, Try, TryOption, Lst, Set, Map, Que (and optionally RWS, State, Writer, Reader)\nThere are also the Prelude_... functions with the lower-case static variants (so bindAsync, mapAsync)\nThe reason for trying to keep them all in-sync is the nightmare situation that F# got itself in with List, Seq, Array, where each module supported a different set of functions (that's now resolved I believe); it was massively annoying.  So any new function that comes in needs to be implemented across the board (where possible), to give a consistent and reliable interface.\nA final benefit of this is that I can add the functions to the transformer system, so you should be able to do things like Lst<Option<T>> x;  x.MapAsyncT(...)\nIf you're happy to do those that'd be awesome, but yeah, welcome to my pain ;-)\n. @danielcweber Yep, although I've just noticed that MatchAsync isn't implemented for all.  Leave it with me and I'll sort it.\n. @danielcweber I've made a start on this, you can grab the latest from nu-get 1.8.18-beta\nIt includes:\nMatchAsync for Task<Option<T>>, Option<Task<T>, Task<OptionUnsafe<T>>, Option<TaskUnsafe<T>, Try<Task<T>>, Task<Try<T>>, TryOption<Task<T>>, Task<TryOption<T>>\nThe following are only done for Option<Task<T>>, Task<Option<T>>, OptionUnsafe<Task<T>>, Task<OptionUnsafe<T>>, Either<L, Task<R>>, Task<Either<L, R>>, EitherUnsafe<L, Task<R>>, Task<EitherUnsafe<L, R>>.\n- MapAsync / mapAsync \n- BindAsync / bindAsync\n- IterAsync / iterAsync\n- FoldAsync / foldAsync\n- ForAllAsync / forallAsync\n- ExistsAsync / existsAsync\n- CountAsync / countAsync\n- SumAsync / sumAsync\nI will complete the rest over the next few days, but I figured these would be useful for you now.\n. @bradphelan Hi Brad, thanks for that.  I think that's a bit too specific for the library - I'm not sure of any common functional operator that does something like this.  If I was to try and give it a name I'd probably call it BindUntilT or BindWhileT, because it's essentially doing the monadic bind for the enumerable until a predicate is true (either.IsLeft == true).  But then again the type it returns is fundamentally different, so that's not a great name either.\nThere are various things close to it in the library: \n- IEnumerable<Either<L,R>>.BindT()\n- IEnumerable<Either<L,R>>.Lefts(),\n- IEnumerable<Either<L,R>>.Rights()\n- IEnumerable<Either<L,R>>.Partition()\n- IEnumerable<T>.FoldUntil()\n- IEnumerable<T>.FoldWhile()\n- IEnumerable<T>.Choose()\nThis is a more functional way to implement it with the existing methods.  It's lazy, so not quite the same:\nc#\n    var res = eithers.Partition()\n                     .Map((ls, rs) => ls.Any()\n                        ? Left<string, IEnumerable<int>>(ls.Head())\n                        : Right<string, IEnumerable<int>>(rs));\n. Actually, TakeWhileRight is probably a better name for it.  It then has echos of the Take operator from LINQ.\n. @jonny-novikov Thanks, I'll merge now/\n. @tOmoness Thanks :+1: \n. Sorry, no I won't be using strong names.  There are downsides, and that is\nit's even more time out of my life dealing with builds and deployment.\nEspecially when you appear to have a solution which just involves upgrading\nVS.\nOn Thu, 4 Aug 2016 at 14:59 Diogo Castro notifications@github.com wrote:\n\nCould this issue be reconsidered? Using StrongNamer works, but it requires\nNuget 2.12 which, unfortunately, I can't use yet. It also requires VS2013,\nand some of my coworkers are still using VS2012.\nAs far as I know, there is no downside to signing an assembly.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/100#issuecomment-237561126,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk-pZCU1JzerLK_tRUGlZp10xHV3Uks5qcfAsgaJpZM4JCUAf\n.\n. @vintem @jbarbosa Take a look at this batch file in the root of the project: \n\nhttps://github.com/louthy/language-ext/blob/master/pack.bat \nI run that batch file to build the nuget packages that I use to deploy lang-ext.  If you can provide me with a pull-request that modifies that batch to build both strong and weak nuget packages, then I'm happy to take a look at it.  I just don't personally have time to look into this right now.\n. @jbarbosa I'm semi-sure that it can have problems.  I seem to remember reading about issues with stong-naming with relation to the StackExchange.Redis library (which is used in this project, they have a separate strong-named package: https://www.nuget.org/packages/StackExchange.Redis.StrongName/).  \nOk, found the link: http://blog.marcgravell.com/2014/06/snk-we-need-to-talk.html\n. @gordonwatts It's a slightly awkward one, but a general rule-of-thumb if you want to change the monad itself rather than the value stored within it, then use Bind:\nSo where Map has the signature Func<T, R>; Bind has the signature Func<T, M<R>> where M is the monad.  \nWith your example you're switching from Right to Left and therefore working on the monad, rather than just mapping the values within.\nThis is an example with Bind\nc#\n    public static async Task<Either<Exception, int>> GetCurrentJobNumber() =>\n        (await _server.FetchJSON(GetJobURIStem()))\n            .Bind(job => job.lastBuild == null\n                ? Left<Exception, int>(new ApplicationException(\"No build completed\"))\n                : Right<Exception, int>(job.lastBuild.number));\nIt's still not super pretty because Either requires two generic type params and therefore the type-inference is non-existent.  What I'll often do when using Either is to create some static helper functions for creating the Right and Left states for the common <L,R> pairs.  \nFor example with a couple of functions (and using static ...):\n``` c#\n        static Either Success(int value) =>\n            Right(value);\n    static Either<Exception, int> AppError(string msg) =>\n        Left<Exception, int>(new ApplicationException(msg));\n\n```\nThe code becomes much more declarative:\nc#\n    public static async Task<Either<Exception, int>> GetCurrentJobNumber() =>\n        (await FetchJSON(GetJobURIStem()))\n            .Bind(job => job.lastBuild == null\n                ? AppError(\"No build completed\")\n                : Success(job.lastBuild.number));\nWith cunning use of extension methods targeted at specific types (in this case JenkinsJob):\nc#\n    static Either<Exception, int> EnsureCompletedBuild(this JenkinsJob self) =>\n        self.lastBuild == null\n            ? AppError(\"No build completed\")\n            : Success(self.lastBuild.number);\nThen you have a reusable function that is super clear:\nc#\n    public static async Task<Either<Exception, int>> GetCurrentJobNumber() =>\n        (await FetchJSON(GetJobURIStem()))\n            .Bind(EnsureCompletedBuild);\nYou could go even further and use the NewType system to give meaning to your int (and make it type-safe):\nc#\n    public class JobId : NewType<int> \n    { \n        public JobId(int id) : base(id) { } \n    }\nAnd update the helper functions to use it:\n``` c#\n    static Either EnsureCompletedBuild(this JenkinsJob self) =>\n        self.lastBuild == null\n            ? AppError(\"No build completed\")\n            : Success(new JobId(self.lastBuild.number));\nstatic Either<Exception, JobId> Success(JenkinsBuildId value) =>\n    Right<Exception, JobId>(value);\n\nstatic Either<Exception, JobId> AppError(string msg) =>\n    Left<Exception, JobId>(new ApplicationException(msg));\n\n```\nThen your resulting function looks like this:\nc#\n    public static async Task<Either<Exception, JobId>> GetCurrentJobNumber() =>\n        (await FetchJSON(GetJobURIStem()))\n            .Bind(EnsureCompletedBuild);\nThe final result is a function that declares its intentions entirely.\nHope that helps! :)\n. @Maximusya thanks :)\n. Thanks!\n. Hi @khtan, no problem, it's call Iter for iteration in lang-ext.\n. GroupBy is just an extension method on IEnumerable<T>.  All of the collection-types in lang-ext (Lst<T>, Map<K,V>, Set<T>, Que<T>) are derived from IEnumerable<T> and therefore get the GroupBy extension by default.\nSo just include using System.Linq and you're good to go.\n. @jcoder58 The Process library has so far been through zero optimisation passes, so it's not surprising it's currently lagging behind Akka.  I have mostly (over the past year) been bringing features into the library as it's 'quick enough' and didn't want to prematurely optimise.  I use it for a large project that will over the next 6 months or so probably need some more juice, so expect significant improvements, although Akka parity isn't the priority - the quality of the API and system as a whole is more important for me;  \nThis is personal opinion, so take it with a pinch of salt, but I am really no fan of the very OO/Java-esque style of Akka and that was the main reason I the Process library.  I am also no fan of its untyped leanings;  I have seen in the past the benefits to strongly typing the bridges between disparate systems.  For example the Process library checks whether the actor you're sending a message to can actually receive it, so you get errors at the point-of-use rather than via dead-letters (even when messaging remotely).  Some of the additional work this library does will almost certainly mean it can never get to Akka speeds, but I don't see any reason why it couldn't get to 10x with some careful optimisation.\n. @jcoder58 Yep, sure is.  It's definitely on the near term radar as I also have a very real need to scale it up, probably by the end of the year.\n. @jcoder58 Just a follow up from this.  I have done some initial optimisation (the very low hanging fruit), and have seen a speed up of a factor of 32.73x.  It won't be available for a while, but I thought you'd be interested to know that your example of 45,872 messages/second would be of the order of 1,501,390 messages/second.  \nI think this bodes well for future optimisations.\n. Project has moved to https://github.com/louthy/echo-process. @jerrywiltse Hi Jerry,\n\nIf you say that you intend to keep this library alive and relevant long-term, I will be using it as a foundation for all my first few open source C# projects. I am also very interested in the .net core support\n\nIt will indeed be maintained for the long-term.  It is included in www.meddbase.com which is a decade old project, and I'm using it to bring more control to the OO headache.  It's fundamental to my own long-term project (I'm the CTO), so hopefully that should give you some comfort. \n\nI am also very interested in the .net core support, as I do want to write apps for linux.\n\nI have everything ready to go, but the .NET Core tooling crashes when I compile it.  I have been talking to the team at Microsoft about it, but are yet to rectify it.  However they were able to build it, so I need to get a clean machine.  But in the meantime you can get the latest source and build and it will build .NET Core targets.  The versions deployed to Nu-get already have DNX builds, and therefore should also work on any .NET Core projects.\n\nThis seems to me to be a completely separate set of concerns, although I do see the relationship.\n\nIt's not a separate set of concerns when you consider the primary purpose of this library: to make C# safer to use and to tame the difficulties of using OO for large projects.  The Core is all functional types because as data-types they are safer than say Dictionary<T>, List<T>, or nullable references.  The Process system is there to deal with the problems of shared and mutable state in a concurrent environment.\nThat's why this library is called 'language-ext', rather than 'functional C#', or something like that.  It directly targets the issues I've personally bumped into many times using C#.\n\nHave you considered separating the concurrency model out into it's own project?\n\nI have, but I don't see any value to me, other than making it slightly easier to write documentation for.  The projects are deployed as separate nu-get packages, so there's no requirement to bring in the Process system if you don't need it.\n. @OlduwanSteve Ok, I'll investigate.  Unfortunately I can't deploy new versions at the moment, because the latest .NET Core tooling crashes when compiling the project.  I've talked to the team at Microsoft and they're unable to work out the cause.  My best bet (because they were able to compile the project) is to wait until my new machine arrives (hopefully) next week.  So for now I'd suggest flattening the interface.\n. Fixed in the echo-process project. . @OlduwanSteve Hi Steve, not sure I entirely follow.  It should allow you call the proxy function for the same ProcessId multiple times for different interfaces.  What behaviour are you seeing when you try this?\n. Hi Nick, if you build from source then all of the dependencies will be OK.  Unfortunately I can't deploy new versions at the moment, because the latest .NET Core tooling crashes when compiling the project. I've talked to the team at Microsoft and they're unable to work out the cause (but they were able to compile it themselves). My best bet is to wait until my new machine arrives (hopefully) this week. \n. @ncthbrt Visual Studio is indeed a dog these days.  I have spent the past two days with it locking up for 10-20 seconds at a time every few minutes.  Reeeeallly tedious.  Unfortunately the build issues are in the dotnet build system, so even running from the command line causes the build system to crash.\nOne upside though is that all the very helpful chaps at MS that tried building it, built without problem.  So as soon as my new machine arrives I can get the .NET Core build done and out the door.\n. @ncthbrt Hi Nick, version 1.9.0 is now deployed to nu-get with full .NET Core support (and referencing System.Reactive 3.0.0)\n. Hi Pavel, don't worry I know how to do it.  I think it could be a good addition.  Might be about a week if you can wait?\n\nOn Jul 20, 2016, at 11:01, Pavel Platto notifications@github.com wrote:\nHello!\nI've just encountered the case when I want something like Map with all its goodness like map transformers but the type which I want to use as a key doesn't implement IComparable and so I can't use Map with it \ud83d\ude1e\nAnother benefit of immutable HashMap over Map that many operations could be faster.\nSadly I don't know how to implement it right now but I know that it is possible because Haskell has it.\nPerhaps I could try to do it myself but at least I want to know what do you think about that?\nThanks.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @Hinidu Version 1.9.1 on nu-get now contains two new types: HSet<T> and HMap<K, V>, which are hash-set and hash-map respectively.  There are constructor functions in the prelude:\n\n``` c#\n    using static LanguageExt.Prelude;\n// Construct a hash-map\nHMap<int, string> hmap = HashMap(Tuple(1,\"Hello\"), Tuple(2, \"World\"));\n\n// Construct a hash-set\nHSet<string> hset = HashSet(\"Hello\", \"World\");\n\n```\nAll of the functions available for Map<K, V> are available for HMap<K, V>, as is the case with Set<T> and HSet<T>.  They haven't had a huge amount of testing, but they're built on the existing Map and Lst structures, so I don't expect many problems.  But please let me know if you find any issues.\n. @jcoder58 \nTry this:\nc#\n        static State<Map<bigint, bigint>, bigint> fibState(int n) =>\n            from m in get<Map<bigint, bigint>>()\n            from v in m.ContainsKey(n)\n                ? State<Map<bigint, bigint>, bigint>(m[n])\n                : n == 0 || n == 1\n                    ? State<Map<bigint, bigint>, bigint>(n)\n                    : from x in fibState(n - 1)\n                      from y in fibState(n - 2)\n                      let r = x + y\n                      from s in get<Map<bigint, bigint>>()\n                      from _ in put(tryAdd(s, n, r))\n                      select r\n            select v;\nI have also added the check for whether the number is already in the Map, and the terminator.\nMostly you shouldn't need to build your own lambda that takes state =>, and returns State(x); that is all handled automatically by the bind function and LINQ.  My usage of State(x) above is on the right-hand side of the from statement, therefore I'm using it to construct a new State monad, and it's simply to wrap a pre-calced value.\nOh all those BigInteger types were hurting my eyes, so I included this to make it a bit more readable:\nc#\n    using bigint = System.Numerics.BigInteger;\n. LINQ essentially is support for functors (via Select) and monads (via SelectMany).  So yes, it's exactly the same as do notation in Haskell.  Computation expressions are used for monads too, but they have many more features available beside the monadic bind, so LINQ is a subset and as you say a 'limited form of'. \n. @jcoder58 I will take a look at this soon, but I need to focus on version 2 of lang-ext over the next week or so.  \nDo you have an immediate need?  Much of the behaviour of Lst<T> matches what an immutable array will do.  The main difference will be the underlying implementation, an immutable-array type will be faster for reads than Lst<T>, but much slower for mutation (with SetItem, Filter, Map, Insert, etc.).\n. @wallymathieu Hi Oskar, I'm not quite sure why that is relevant?  This library already has many immutable collections, the issue raised by @jcoder58 is merely requesting an immutable-array type to supplement the Lst<T>, Map<K,V>, Set<T>, Que<T>, Stck<T>, HMap<K, V>, and HSet<T> types.\nSomething I will be implementing in the next few months once v2 is complete.\n. @jcoder58 This will land in version 2 very soon.. @jerrywiltse Thanks!\n. > I am really impressed with your work.\nThanks :)\n\nI was wondering whether there was a technical reason for using Lst instead of List ?\n\nBecause whenever you add a new C# file to a project in VS it auto-adds: using System.Collections.Generic; which has the List<T> type.  If I used List then there would be naming clashes all over the place.  You could argue that it would be easier to remove the using, but the problem is then that it makes using List<T> and Lst<T> in the same code file more difficult.  \nSo it's purely a pragmatic choice to avoid clashing with the BCL.  The same is true of HSet, because there's a HashSet already in the BCL.  There isn't a HashMap (it's called Dictionary), but for the sake of consistency within the library I decided to go with HMap.\n. > If you're interested I might be able to help.\nI'd be interested in anything that would make Some more effective, yes.  I am actually looking into using Roslyn to generate the HKT.cs instead of the quite shonky T4 template system.  But it's still pretty early days [in my full understanding of what's possible].  So feel free to propose any ideas you have.\n. @OzieGamma Yes, that is the case.  But (unknown to many) C# can do ad-hoc polymorphism, which allows for Haskell-like type-class and instances.  I am actually working on this now for lang-ext 2 (Take a look at the type-class branch: https://github.com/louthy/language-ext/tree/type-classes)\nThere are some major limitations though:\n- C#'s type-inference is terrible, which leads to 'a lot' of manual type-annotations.  But if you want to write functions that take Functor<T> so you can call Map, or you want to create a numeric-type and only write your maths functions once (not many times for double, float, int, etc.) then this will work.\n- The instance types must be structs.  That causes boxing for the higher-kinded types like Monad, Functor, Applicative, etc.  It works fine for simple type-classes like Eq, Ord, Monoid, etc.\n- For types like Monad they will return Monad<B> for the standard SelectMany function by default, so that means your Option would become more generic (it's possible to cast).  But also means it can bind any sequence of monads rather than just the ones specified in the extension methods, so double edged sword there.  (btw, this limitation isn't totally true: if you want to return a more specifically typed result then you also need to specify it in the function's generic arguments, that means the type annotations get a bit excessive, and so mostly I'm avoiding that).\nSome real examples:\nEq type-class\n- Type-class definition (an interface): https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/TypeClasses/Eq/Eq.cs\n- Instance definition (a struct): https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/Instances/EqFloat.cs\n- Unit-tests that all call the same IsEqualGeneral function with different numeric types: https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Tests/TypeClassEQ.cs\nMonoid type-class\n- Type-class definition (an interface): https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/TypeClasses/Monoid/Monoid.cs\n- TInt instance (struct), which is in the Ord, Num, and Monoid type-class: https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/Instances/TInt.cs\n- TLst instance (struct), which is in the Monoid and Difference type-class: https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/Instances/TLst.cs\n- TString instance (struct), which is in the Monoid and Ord type-class: https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/Instances/TString.cs\n- Unit-tests that call the same mconcat function with different types that understand the concatenation behaviour for each: https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Tests/TypeClassMonoid.cs\n- Implementation of mconcat and mempty - https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/TypeClasses/Monoid/Monoid_Prelude.cs\nMonad type-class\n- Type-class definition (interface): https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/TypeClasses/Monad/Monad.cs\n- Once only definition of Bind, Fail, Join: https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/TypeClasses/Monad/Monad_Extensions.cs\n\"So, does this mean I can create a new struct derived from Monad<T> and it just work with LINQ etc???\"\nYes.\nHowever, because of the limitations I am still going to manually implement all of the overrides and extension methods (I'm working on a Rosyln based plugin that will do general case extension method generation).  \nSo unfortunately for me the typing required has pretty much doubled, but for the consumers of this library they'll be able to write totally general case code that works with the type-class interfaces and struct instances.\nbtw, I definitely wouldn't advise getting the type-class branch.  The changes are in the very early stages.  It's pretty much a re-write of the core of this library and will take a while to come to fruition. \n. > Option.map the returns Monad. Type accuracy is lost ! So it might be there for convenience if users define their own but doesnt replace the original type ...\nOnly when they're used in their more generic state of Monad<T>, when they're used as Option<T> map will return an Option<T> (https://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/Option/Option.cs#L218).  I'm doing the legwork of providing the explicit overrides and the generic functionality.  \nFor example if I write a function that takes a Monad:\nc#\n    Monad<A> AddMonads<NUM, A>(Monad<A> lhs, Monad<A> rhs) where NUM : struct, Num<A> =>\n      from a in lhs\n      from b in rhs\n      select add<NUM, A>(a,b);\nThen I can call it with any combination of monadic type, but I must expect to get a generic response:\n``` c#\n    Option lhs = 10;\n    Either rhs = 10;\nMonad<int> result = AddMonads<TInt, int>(lhs, rhs);\n\n```\nHowever if I wrote it with a specific monadic type:\nc#\n    Option<A> AddMonads<NUM, A>(Option<A> lhs, Option<A> rhs) where NUM : struct, Num<A> =>\n      from a in lhs\n      from b in rhs\n      select add<NUM, A>(a,b);\nThen I will maintain the type, but lose the ability to call it with any type of monad.  If you want typed variants then you're back in the land of code generation, or lots of typing.  \nAs it stands this library (and all others that try to implement monads) only work on the specialised type, and therefore the benefits are limited.  In fact it severely limits the use of monads, applicatives, and functors, to the point where it's difficult to really call them that if they can't be used generally.  Being able to write functions that work on monads, and not options, eithers, etc. is the goal here.  That is what you get with Haskell and any other language that supports type-class like functionality.\nT4 generation (which is what lang-ext currently uses) is very limited in terms of understanding the inheritance graph.  For example, with Monad<B> Bind(Monad<A> ma, Func<A, Monad<B>> f) you need to provide the basic typed variants:\nc#\n    Option<B> Bind(Monad<A> ma, Func<A, Option<B>> f);\n    Either<L, B> Bind<L>(Monad<A> ma, Func<A, Either<L, B>> f);\n    Try<B> Bind(Monad<A> ma, Func<A, Try<B>> f);\n    ...\nThat allows different monadic types to be combined without losing the specialised type.  If you don't do the type-class stuff I've done, then it becomes (and this is what HKT.tt is like now):\nc#\n    Option<B> Bind(Option<A> ma, Func<A, Option<B>> f);\n    Either<L, B> Bind<L>(Option<A> ma, Func<A, Either<L, B>> f);\n    Try<B> Bind<L>(Option<A> ma, Func<A, Try<B>> f);\n    Option<B> Bind<L>(Either<L, A> ma, Func<A, Option<B>> f);\n    Either<L, B> Bind<L>(Either<L, A> ma, Func<A, Either<L, B>> f);\n    Try<B> Bind<L>(Either<L, A> ma, Func<A, Try<B>> f);\n    Option<B> Bind(Try<A> ma, Func<A, Option<B>> f);\n    Either<L, B> Bind<L>(Try<A> ma, Func<A, Either<L, B>> f);\n    Try<B> Bind(Try<A> ma, Func<A, Try<B>> f);\n    ...\nThen to do add the super-useful transformer functionality you need to do that all again with every combination of transformed monadic types (Option<Option<T>>, Option<Either<L, T>>, etc.)\nIt gets very complicated, very quickly, when working with monadic types that are delegates that require input (like the State  and Reader monad), or when the outer type implements a function that the inner type doesn't, or when trying to work out the default behaviour for functions that return a non-monadic result.  So for example Fold, Count, etc.  I stopped with the T4 template idea when I got to a dozen or so of the most useful functions.  \nThe main issue then is that the types are hard-coded to work with each other.  Bringing in lang-ext and then writing your own monadic type doesn't magically make it work with the lang-ext monads.  But with the type-class system it does.\n. I'm unclear on why you aren't using the one that compiles?\nThe static functions you're after for explicitly defining left and right\nare:  Prelude.Left(...) and Prelude.Right(...)\nOn Thu, 4 Aug 2016 at 11:24 Diogo Castro notifications@github.com wrote:\n\nI'm having an issue where I'm being forced not to use implicit conversions:\npublic interface X { }public class Y : X { }\nEither a = new Y();          // compiles\nEither b = new Y() as X;  // Cannot convert initializer type 'X' to target type 'Either'\nThis looks like a compiler bug in IMO, but I'm hesitant to rush to such a\nharsh conclusion.\nIn any case, because I have an instance of an interface, and not of the\nconcrete class, I have to construct an Either using some other means.\nMaybe I'm missing something, but the constructors are private, and the two\nstatic helpers Right\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/Either.cs#L627\nand Left\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/Either.cs#L631\nare internal.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/121, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk9SEvRWYQZgsZtJf74d31tJ4DPiwks5qcb3ngaJpZM4JcjoM\n.\n. @dcastro It's because implicit operators don't work with interfaces, it's a limitation of C#.  In your IEnumerable example instead use the lang-ext built-in List<T>()\n\nc#\n        Either<Exception, IEnumerable<T>> F<T>()\n        {\n            return List<T>();\n        }\nMake sure you're using static LanguageExt.Prelude.  If not, then you can directly use the Empty field on the Lst<T> type:\nc#\n        Either<Exception, IEnumerable<T>> F<T>()\n        {\n            return Lst<T>.Empty;\n        }\nIf you want to do similar behaviour yourself, try this:\n``` c#\n        static class Empty\n        {\n            public static readonly T[] Enumerable = new T[0];\n        }\n    Either<Exception, IEnumerable<T>> F<T>()\n    {\n        return Empty<T>.Enumerable;\n    }\n\n```\nThat avoids the allocation and implicitly casts.\n. @dbmercer Hi David, it's a property that's useful for implementing white-space significant languages.  See 'The Offside Rule' in this paper. \nIt's not actually used for any parser yet, and in-fact the indented parser is much easier to understand, so that's probably the easiest option if you need that.\n. @dbmercer \nIf you're looking for some real-world examples of using the Parsec library, you can take a look at the LanguageExt.Process system configuration file parser:\nSource: ProcessSystemConfigParser.cs\nExample file that it parses: process.conf\nIt's actually a statically-type mini-language with full support for expressions, operators, etc.\nI'm not sure if you've seen the API documentation yet: louthy.github.io  It was generated by another project I wrote especially for it: best-form, and it uses the Parsec library to parse the raw C# source of lang-ext.  This is the parser: Lang.cs\n. @eggapauli I'm not adding Re-shaper dependencies to lang-ext, it's a massive code smell to include dependencies for tools that have nothing to do with the resulting code.  So, I'm afraid to say that unfortunately the 'fix' is for you to find a way to tell Re-sharper to be less aggressive with its complaints.\n. I should't need to create annotations, because there are no issues with the lang-ext, this is an issue with Resharper.  There are no bugs here for me to deal with - it's a library, not a tooling platform.  \nResharper is giving you spurious error messages, that is a problem in the Resharper product.  If Resharper has no way for you to disable these false positives, or for you to create your own annotations, then I would suggest getting in touch with Jetbrains to find a solution - because it's their code that's at fault.\nIf I start adding bespoke attributes for every tool that has trouble with valid C# code then it will end up in a mess.  I don't personally use Resharper, so I wouldn't even be able to test it; and even if you were to build an annotations package for me, I'd still have to maintain it long term.  \nResharper isn't a 'default tool' (even if lots of people think it is), its popularity doesn't grant it any special status.  Plenty of consumers of this library may wonder what all the 'attribute litter' is lying around throughout the library. \nHowever, if there was an equivalent attribute in the System.Diagnostics.Contracts library, then I'd consider using it because it's already being used for the Pure annotations and it's part of the BCL.  Otherwise, I'm sorry, but it's a no.\n. @architrent Sorry, yes that mechanism is deprecated.  I am yet to update the docs.  It's been replaced with the ProcessConfig system.\nTo use redis for messaging you must first call:\nc#\n    RedisCluster.register();\nThat registers the Redis implementation of ICluster with the core Process library factory.\nTo achieve similar to the docs, then you can use:\nc#\n    ProcessConfig.initialise(\"sys\", \"web-front-end\", \"web-front-end-1\", \"localhost\", \"0\");\n- \"sys\" is the 'system name', but easier to think of it as the name of the cluster as a whole.  That means you can call it with a different value and point it at another Redis db for multiple clusters.  But for now it's easier to call it sys and leave it.\n- \"web-front-end\" is the role, you can have multiple nodes in a role and the role based dispatchers allow you to implement high-availability and load balancing strategies.\n- \"web-front-end-1\" is the name of this node, and should be unique in the cluster\n- \"localhost\" is the Redis connection (can be comma separated for multiple Redis nodes)\n- \"0\" is the Redis catalogue to use (\"0\" - \"15\")\nHowever! I would encourage you to use the configuration file approach, because it offers a ton of useful features for configuring processes and staging environments.  Depending on the type of application you're building, you should call:\nProcessConfig.initialiseFileSystem(); -- for desktop and console apps\n   ProcessConfig.initialiseWeb(); -- for web-apps\nThey both look in the root folder of your application for cluster.conf and process.conf files.\nIn cluster.conf you set-up what the node 'is' in the cluster.  i.e.\ncluster web-front-end-1 as web:\n        role: \"web-front-end\"\n        node-name: \"live1.yourdomain.com\"\n        connection: \"localhost\"\n        database: \"0\"\nThe first line starts the definition of the node in the cluster.  web-front-end-1 is the name of the cluster variable, web is an optional alias.  This allows you to specify multiple staging environments, e.g.\n```\n    cluster test as app:\n        node-name: \"test.yourdomain.com\"\n        ...\ncluster local as app:\n    node-name: \"local.yourdomain.com\"\n    ...\n\ncluster production as app:\n    node-name: \"yourdomain.com\"\n    ...\n\n```\nThe role is the role of the node, i.e. the job that it does in the cluster.  That allows you to have multiple services running that fulfil the same role, and use the role-based dispatchers to do broadcast, round-robin, etc. (useful for load balancing, and high availability strategies) without needing to know the actual name of the nodes you're targeting.\nnode-name is exactly that, but for web-apps make this match your web-app's host-name.  The difference between Process.initialiseFileSystem and Process.initialiseWeb is that Process.initialiseWeb will automatically decide on the cluster specification to use based on the host-name.  If you're doing a web-app the there must be a live HttpContext available, so in Application_BeginRequest do this:\n``` c#\n        bool started = false;\n        object sync = new object();\n        protected void Application_BeginRequest(object sender, EventArgs e)\n        {\n            if (!started)\n            {\n                lock (sync)\n                {\n                    if (!started)\n                    {\n                        // Let Language Ext know that Redis exists\n                        RedisCluster.register();\n                    // Connect to the Redis cluster and setup configuration\n                    ProcessConfig.initialiseWeb();\n\n                    started = true;\n\n                    // start initialising processes after this point because the \n                    // system is live\n                    DoYourSetupOfInitialProcessesHere();\n                }\n            }\n        }\n    }\n\n```\nIt's a touch ugly for web-apps, but it saves a lot of hassle with making sure you're providing the config system with the correct app and host settings.\nBack to the cluster.conf settings...\nconnection is the Redis instance address, you can comma separate these if you're running multiple Redis nodes in a cluster, or with master/slave replication. \ndatabase is the Redis catalogue (\"0\" - \"15\")\nThe process.conf allows you to configure individual Process and Router settings.  For example:\nprocess my-svc:\n        pid: /role/user/my-service\n        flags: [persist-inbox]\nThat declares that anything in the current role (the /role bit) with a leaf of /user/my-service that is spawned will have its inbox persisted to Redis.\nIf you don't want to specify the settings for all .../user/my-service Processes in the role, the you can provide settings for a specific node's Process:\nprocess my-svc:\n        pid: /web-front-end-1/user/my-service\n        flags: [persist-inbox]\nThat will only apply the settings on the /web-front-end-1 node.\nThe conf system doesn't automatically spawn Processes, you can think of it more like CSS, where the settings apply if the Process being spawned matches the config.  So to spawn the Process above in code (with a Redis persisted inbox) call:\nc#\n    spawn<Msg>(\"my-service\", Service.Inbox);\nNote also that the name my-svc is 'registered' in the current role.  So any other service can find it like so: \nc#\n    tell(\"@web-front-end:my-svc\", msg);\nThis avoids the classic problem of knowing where Processes are in a node's hierarchy, and avoids the problems of refactoring hierarchies. So it's a kind of DNS for roles and names.\nIf you're already running within the web-front-end role, then you don't need to qualify the name with a role this will work:\nc#\n    tell(\"@my-svc\", msg);\nIf you don't want to use process.conf, then you can achieve the same like so:\nc#\n    var pid = spawn<Msg>(\"my-service\", Service.Inbox, ProcessFlags.PersistInbox);\n    register(\"my-svc\", pid);\nI'd take a look at some of the samples, as this is all done in those.  This is an example of quite a complex process.conf that uses the strategy system.  Strategies are mini-computations that run when the Process fails, and can match on exception types, and can provide directives to the Process system on how to handle the failure.  It also declares variables that can be read using ProcessConfig.read and ProcessConfig.write.  \nThe PingPong sample has quite a fun config file that shows off the power (it's actually a strictly-typed language), you'll notice declaration of variables, references to vars in the scope of the cluster, and ternary operations.\n. @architrent \nRegistered processes are essentially permanent residents if they have any persistence flags set (persist-inbox, persist-state, remote-publish, remote-state-publish).  The idea is that if a service goes down then other services can still post to them (with the messages backing up in Redis until it comes back online).  \nA process is only removed from Redis (its inbox and meta-data) when you call Process.kill(pid) from outside of the Process, or Process.kill() from within its message-loop.  kill also removes any registration automatically as well.  So you don't need to call Process.deregisterById(pid)\nIf you want to stop a Process locally, but still have it be 'visible' to receive messages whilst it is offline then you can call Process.shutdown(pid).  This unloads the Process from the local tree but leaves the inbox, meta-data, and registration alone.\nWhen you unload your app-domain (not sure if you're web or regular app), then you can call Process.shutdownAll() which does a more managed shutdown.  This is most useful for the IIS app-pool resets where sometimes static data can hang around.  On the whole though there are finalizers in place that will still deal with all of this automatically if you don't do it.  The shutdown of Redis is also handled automatically.\nAgain Process.shutdownAll() is like Process.shutdown() in that it doesn't remove the inboxes or meta-data related to the live Processes.  When you restart your service, and you restart your Processes they will recover their state and inboxes if persisted, and start handling the backlog.\nThere is a Process.PreShutdown observable that you can subscribe to, which has a message-type of ShutdownCancellationToken.  You can use this to cancel a shutdown if necessary.  And Process.Shutdown can be subscribed to for the post-shutdown event.\nOne final thing to note about registered processes is that multiple services can register a Process with the same name.  What happens when you tell a registered name (or in fact any operation on a ProcessId), is it builds a broadcast dispatcher, so that all Processes registered under that name will get the messages you send.  You can use the functions in the Dispatch class to modify this behaviour, e.g.\nc#\n    tell(Dispatch.random(\"@reg-name\"), msg);\n    tell(Dispatch.roundRobin(\"@reg-name\"), msg);\n    tell(Dispatch.leastBusy(\"@reg-name\"), msg);\nIf you're not happy building the \"@role:name\" strings you can use find(role, name). So the above would be:\nc#\n    tell(Dispatch.random(find(\"reg-name\")), msg);\n    tell(Dispatch.roundRobin(find(\"reg-name\")), msg);\n    tell(Dispatch.leastBusy(find(\"reg-name\")), msg);\nThere is also a per-process setting in the conf files that allows you to modify the default dispatch mechanism:\nprocess my-proc:\n        pid: /role/user/my-process\n        dispatch: first\nValid values are: broadcast (default), least-busy, round-robin, random, hash, first, second, third, last.\nTo give you an idea of what's happening behind the scenes, this is the code that runs to register the Process after it has been created:\nc#\nActorContext.System(actor.Id).Settings.GetProcessDispatch(actor.Id)\n    .Match(\n        Some: disp => Process.register(regName, Disp[$\"role-{disp}\"][Role.Current].Append(actor.Id.Skip(1))),\n        None: () => Process.register(regName, actor.Id)\n        );\nSo if you don't specify a dispatch setting (the None branch above) then the Process is registered with its regular path. If you do specify a setting (the Some branch) then a role-dispatcher is built.  That allows functions like tell to work out how to dispatch the message.  And because it's using the role dispatcher system, it always works on 'liveness'.  i.e.  if you use round-robin, then the tell will only send to nodes that are currently alive, or if you use first then the first node (alphabetically) that's alive in the cluster will get the message.\nA final note about the configuration file.  Be a little wary of error line numbers.  What happens internally is that cluster.conf and process.conf are loaded and appended before being parsed, so error line numbers for the process.conf are off by the number of lines in cluster.conf.  I'll fix that up at some point!\n\nI have some other questions about the best way of solving certain problems using language-ext. Do you have a preferred medium for discussing those? They don't belong here, since they aren't issues.\n\nHappy to answer here, or if you want to use the gitter room the link is on the home page.  \nI desperately need to get around to writing a lot of this stuff up; the Process system has grown quite a lot from its humble origins!  The configuration system is pretty new, but very powerful, so that could definitely do with some documentation.\n. @jcoder58 I want to maintain parity between the LanguageExt.Parsec and the Haskell Parsec libraries, so the easiest way for you to achieve this is to take the source of makeTokenParser and build your own variant.\nThe key code is: \nc#\n    var whiteSpace =\n        def.CommentLine == null && def.CommentStart == null ? skipMany(simpleSpace.label(\"\"))\n      : def.CommentStart == null ? skipMany(either(simpleSpace, multiLineComment).label(\"\"))\n      : def.CommentLine == null ? skipMany(either(simpleSpace, oneLineComment).label(\"\"))\n      : skipMany(choice(simpleSpace, oneLineComment, multiLineComment).label(\"\"));\nIf you want to support both one-line comments and multi-line comments then the last line of that is what you need to look at:\nc#\n    skipMany(choice(simpleSpace, oneLineComment, multiLineComment))\nYou'll want to build a parser that returns an IEnumerable<string> for your comments (or IEnumerable<Comment> if you're doing deeper parsing of comments).\nYou may want to take a look at my best-form project that has a C# parser with C# XML comments sub-parser.  It's probably not general enough for what you're looking for, but the sub-parser might be useful to you.\n. @jcoder58 And just to be clear, it's not as simple as you think.  Because white-space and comments could appear in many places.   The way the makeTokenParser parser works is to always clear trailing white-space (and comments) by default to simplify the process of tokenisation.  If you wanted to maintain similar behaviour then every parser would need to return T and an IEnumerable<Comment>; obviously that's possible, but it's a different resulting set of parsers for nearly all parsers in GenTokenParser.\n. @jcoder58 One thing to note with my solution (which was purely made to parse the lang-ext source to build the API reference docs) is that I kind of cheat and set the line-comment string to // (with a space after the last slash).  This causes it to miss the /// XML doc comments.  I then manually inject the documentation parser at the top of each block that's likely to have them:\n- Delegate: https://github.com/louthy/best-form/blob/master/bestform.cs/Lang.cs#L281\n- Enum member: https://github.com/louthy/best-form/blob/master/bestform.cs/Lang.cs#L292\n- Enum: https://github.com/louthy/best-form/blob/master/bestform.cs/Lang.cs#L303\n- Method: https://github.com/louthy/best-form/blob/master/bestform.cs/Lang.cs#L492\n- Conversion operators: https://github.com/louthy/best-form/blob/master/bestform.cs/Lang.cs#L515\n- Class/interface/structs: https://github.com/louthy/best-form/blob/master/bestform.cs/Lang.cs#L573\n- etc.\nSo it's definitely not as robust as a generalised system that can find doc comments anywhere (as mentioned before).  But if you're working with a known code-base, and you know the docs you want are in well defined places in the source, then it can work.\n. If IsFaulted is true then there's an error, otherwise there isn't and the Result is your parsed value.  \nBecause parsers are nested, failures can propagate up the chain which then are not considered errors higher up (say within an either), the parser combinator needs to keep capturing errors in-case it needs to show the full set of expected results later, so sometimes you will see errors from lower down - this is the  expected behaviour of the Parser type and not a bug. \nEnd-of-stream errors means you have built a parser that doesn't know when it's complete.  This can happen by default with parsers like comments parsers.  So often it's just easier to just confirm that the State is also empty if you have a looser parser (that's assuming you expect to parse all available text).\nI have used an extension method in the past to simplify this, which you're welcome to use:\nc#\n    public static class ParserExt\n    {\n        public static Either<ParserError, T> Run<T>(this Parser<T> p, string source)\n        {\n            var res = p(source.ToPString());\n            return res.IsFaulted || res.Reply.State.ToString().Length > 0\n                ? Left<ParserError, T>(res.Reply.Error)\n                : Right<ParserError, T>(res.Reply.Result);\n        }\n    }\n. @jcoder58 This should be fixed in 1.9.2 on nuget now.\n. Please don't prefix issues with [Bug], it does jar a little.  I'll confirm it as a bug if it is the case, but I doubt it, as I have written full languages with the Parsec library.  The example in best-form isn't complete, so there may be some issues if you're following it.  The lang-ext Process config system has a full typed expression parser in it if you want to have a look at that:\nFirst off make sure that your ReservedOpNames, OpStart and OpLetter are sound \nIf it's possible to share your term parser too that'd be useful (that's passed to buildExpressionParser):\nExample file that's parsed:\nhttps://github.com/louthy/language-ext/blob/master/Samples/Strategies/process.conf#L8\n. They're the best kind :)\n. @Maximusya Thanks!\n. @Maximusya Good spot, thanks!\n.  'Railway Oriented Programming' isn't really a thing. It was made up on the fsharpforfunandprofit site to avoid using the word 'monad'. See the 'Forbidden Words' section of their site: http://fsharpforfunandprofit.com/about/\nI understand why they decided to do this, but it can muddy the water somewhat. But any monad that has multiple execution paths based on its state fits into the railway oriented programming mould:\nThe ones in this library that have those multiple execution paths are:\nc#\n    Option<T>\n    OptionUnsafe<T>\n    Either<L, R>\n    EitherUnsafe<L, R>\n    Try<T>\n    TryOption<T>\n    Parser<T>\n    Parser<I, O>\nI wouldn't get too attached to it as a term, not many people know what railway-oriented programming is.\nIf you go to the lang-ext gitter feed, and scroll up to my comments from Mar 11th then you'll see a bigger discussion on this, and an implementation of some of the examples from the fsharpforfunandprofit site.  It's not the first time this has been asked ;)\n. This is a big in my best-form project.  Could you report it there pls? \nhttps://github.com/louthy/best-form\n. Thanks Brian, I'm away at the moment. I'll look into it soon. \n. Heh, sorry, replying very quickly on my phone. Not paying close enough\nattention :)\nOn Thu, Sep 22, 2016 at 18:34 BrainCrumbz notifications@github.com wrote:\n\n... I guess you meant Brain, if that was my team first name \ud83d\ude04\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/141#issuecomment-248957321,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkzf_coRxwjabfNzY9EEzIdwehJx7ks5qsq4ggaJpZM4KEFId\n.\n. I'm currently away, will review this in a few days.  It sounds like a legitimate bug, so if you want to do a pull request then I'll review when I'm back.\n. @spyder94 This is now released to NuGet as v1.9.3\n. Thanks!\n. @monkeyhell That's an unfortunate side-effect of Comparer<T>.Default, which has various fallback strategies if the type isn't IComparable which makes it slightly more flexible.  I'm following the same pattern as the .NET Immutable Collections library, so I'll probably leave it as-is I'm afraid.\n. If you don't need a sorted collection you can use HMap.\n. > I'll just have to get into the mindset that maps are sorted by default\n\nWith immutable structures Map and Set are also slightly more efficient (Because an HMap is a Map<int, Lst<IMapItem<K, V>>> and HSet is a Map<int, Lst<T>>).  So the only reason for using HMap and HSet would be because of the issues around orderable keys as you specified.\n\nUsing this library instead makes everything much easier on the eye. Thanks!\n\nIndeed.  It was a big frustration for me also.  As well as having a coherent functional 'base class library', rather than disparate collections libraries, option types, etc.  None of which can make use of each other.  So I've been trying to bring in as much of what would be considered the core of a functional language's framework.  \nI'm working on v2 now in a separate branch which will hopefully take it to the next level again, with support for Ad Hoc polymorphism, which hasn't really been done before in C#; and if it has it's been in a limited form, whereas I'm hoping to provide a type-class system similar to Haskell.  Microsoft themselves are investigating the technique for a future version of C# (and looking into new grammar to support it), but I wouldn't expect anything until C# 10+.  So in the meantime I'm trying to bring it into lang-ext.  I don't know if that helps with the hard sell ;)\n. @spyder94 Excellent, thanks!\n. There were some broken references from the move from RxMain to System.Reactive.  Please re-sync and try again.\n. I have just tried it from scratch too and it worked fine.  Which version of VS 2015 are you on?  Make sure you have the latest service packs.\n. Great :)\n. Thanks Andrey :)\n. Currently there isn't a way to inject custom deserialisers, no.  That was\nthe initial reason for ActorSystemConfig, I just hadn't gotten around to\ngeneralising it fully.  The only short term suggestion I have is to use a\nDTO object of some sort.\nOn Fri, 30 Sep 2016 at 16:13 spyder94 notifications@github.com wrote:\n\nWe have a message that contains a property that is a\nSystem.Security.Claims.Claim. Deserialization of that message fails with\nthis error message:\nUnable to find a constructor to use for type System.Security.Claims.Claim.\nA class should either have a default constructor, one constructor with\narguments or a constructor marked with the JsonConstructor attribute.\nI can reproduce the issue with the following code:\n```\n    var ss = new JsonSerializerSettings\n    {\n        TypeNameHandling = TypeNameHandling.All,\n        TypeNameAssemblyFormat = FormatterAssemblyStyle.Simple,\n        MissingMemberHandling = MissingMemberHandling.Ignore\n    };\nvar c = new Claim(\"foo\", \"bar\");\nvar so = JsonConvert.SerializeObject(c, ss);\nvar o = JsonConvert.DeserializeObject<Claim>(so, ss);\n\n```\nI can fix the problem in the code above by adding a custom JsonConverter\nfor the Claim class but there doesn't seem to be any way to register that\nconverter in the ActorSystemConfig. I tried registering the converter in\nthe JsonConvert.DefaultSettings but that didn't work. I believe it doesn't\nwork because the ActorSystemConfig.Default.JsonSerializerSettings always\nreturns a new instance of JsonSerializerSettings.\nIs there another way of handling this scenario that I'm missing?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/148, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk_qUeXT8UtASE-LMO88Zz5b1ExzWks5qvScogaJpZM4KLMhc\n.\n. Yep, blatant bug.  If you have a fix ready I'll hang on for that.\n. Thanks!  I'll do a new deployment to nu-get on Weds or Thurs this week.\n. Whilst I think it's a novel idea to have a write-only _ field, I'm not sure the solution to the problem you're trying to solve belongs in this library.  There would also be holes in this solution with locals named _ (which I often use in LINQ and in lambdas).  \n\nAlso have you considered that the [Pure] annotation from the Microsoft Contracts library is a good place to start with code-analysis?  I have annotated everything that's pure (and should therefore return a value) in this code-base, as has Microsoft with the BCL.\n. The 'threading stuff', which I assume you're referring to the Process system is an implementation of the Actor model; it does explicitly state (in the docs) that they're single threaded (and therefore the messages are handled in the order they arrive at the Process inbox).\nI've never used Ruby, so I'm not sure what your final paragraph refers to.\n. @sdedalus Hi David, going to close this for now.  Feel free to re-open if you want to discuss further.\n. I keep meaning to reply to this, but permanently short of time atm!\nI don't think this is a strong enough solution for sum-types in C#. I've\ntried a number of times in the past to create something with a low\ncognitive load, and it's tough. This example suffers from:\n- Having to specify the types, in-order, on every usage (which is annoying\n  at the time, but also a massive pain when refactoring)\n- Lack of default handler variants (which if provided cause an exponential\n  growth in Match overloads)\n- As already discussed above, the inheritance approach has holes in that\n  make the resulting type not as safe as a sum-type in other languages\nThe closest I've seen to a good implementation is here:\nhttps://functionalcsharp.codeplex.com\nIt uses the definition of an interface to describe the sum-type. Then uses\nreflection emit to dynamically create the sum-type implementation. It still\nhas its problems, but if I were to add sum-types to Lang-ext then I'd\nprobably take this approach.\nI appreciate you taking the time to contribute to the project, but I don't\nthink this is strong enough for the library. If you feel like taking the\ninterface approach I'd happily consider for approval.\nP\nOn Thu, Oct 13, 2016 at 15:23 Brad Phelan notifications@github.com wrote:\n\nLove the idea of this extension. However I think \"Union\" is the wrong name\nfor the type. It is a \"discriminated union\" not a \"union\". However that is\na sucky long type name. Possibly better is\nOneOf\nrather than\nUnion\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/154#issuecomment-253527915,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkzN9DUHbFrxbIpJTQMhw957WEIvpks5qzj7KgaJpZM4KSPhE\n.\n. @sdedalus How do you want to manage this going forward?  Should I close this and you do a new pull request when you're ready, and we can discuss on the Issue that's open?  Or keep this pull request open, and you'll update it as you go?\n\nI think it's worth coming back quickly when you have ideas on a potential approach.  I don't want you wasting time going off in a random direction if it's not something I think will work for the library.  \nElegance is the key to a feature like this working.  At the moment it's possible for users to do this:\n``` c#\n    public abstract class Shape { }\npublic class Square : Shape \n{ \n    public readonly Position TopLeft;\n    public readonly double Width;\n}\n\npublic class Triangle : Shape \n{ \n    public readonly Position Vertex1;\n    public readonly Position Vertex2;\n    public readonly Position Vertex3;\n}\n\npublic class Circle : Shape \n{ \n    public readonly Position Position;\n    public readonly double Radius;\n}\n\nvar res = x is Square    ? DrawSquare(x as Square)\n        : x is Triangle  ? DrawTriangle(x as Triangle)\n        : x is Circle    ? DrawCircle(x as Circle)\n        : DefaultBehaviour(x);\n\n```\nObviously this isn't such a great example (it's one where inheritance actually works better); but as an example of how to do sum-type like behaviour for C# it's quite elegant.  It has the initial hit of having to build the types, but that's a once only hit, whereas as the initial proposed solution inflicted the declaration on the programmer every time they used it.\nIt also forces a form of completeness checking, because it's a sequence of ternary operators and therefore you must always have a catch-all case.\nAnd finally it allows for predicate like behaviour:\nc#\n    var res = x is Square && (x as Square).Width > 50 ? DrawBigSquare(x as Square)\n            : x is Square                             ? DrawSmallSquare(x as Square)\n            : x is Triangle                           ? DrawTriangle(x as Triangle)\n            : x is Circle                             ? DrawCircle(x as Circle)\n            : DefaultBehaviour(x);\nObviously it doesn't allow for ad-hoc types like Union<string, int, bool>, but I'd argue that you don't get ad-hoc types in F# (or similar functional first languages).  The original Union proposal was closer to an Either than a sum-type.  \nFor example in F# you'd be writing this:\n``` f#\n    type Thing = \n      | Integer of int \n      | String  of string\n      | Boolean of bool\nlet x = Integer 123\nlet y = String \"Hello\"\nlet z = Boolean true\n\nmatch x with\n | Integer a -> UseInteger a\n | String  a -> UseString a\n | Boolean a -> UseBoolean a\n\n```\nWhich is the equivalent of:\n``` c#\n    public abstract class Thing { }\npublic class Integer : Thing\n{\n    public readonly int Value;\n    public Integer(int value) { Value = value; }\n}\n\npublic class String : Thing\n{\n    public readonly string Value;\n    public String(string value) { Value = value; }\n}\n\npublic class Boolean: Thing\n{\n    public readonly bool Value;\n    public Boolean(int value) { Value = value; }\n}\n\nvar x = new Integer(123);\nvar y = new String(\"Hello\");\nvar z = new Boolean(true);\n\nvar res = x is Integer  ? UseInteger(x as Integer)\n        : x is String   ? UseString(x as String)\n        : x is Boolean  ? UseBoolean(x as Boolean)\n        : UnknownValue(x);\n\n```\nWith pattern-matching about to land in C# a lot of this is moot.  The key difficulty is creating the sum-type in the first place.  That's where the interface approach looks quite nice.  Because the above could be declared like so:\nc#\n    public interface Thing\n    {\n        public Thing Integer(int x);\n        public Thing String(string x);\n        public Thing Boolean(bool x);\n    }\nThere is some messiness to the solution on codeplex though:\nc#\n    var x = DataType.New<Thing>();\nThis generates an object of type Thing.  It would be the equivalent of null because it's not until calling one of the methods that you get a concrete value:\nc#\n    var x = DataType.New<Thing>().Integer(123);\n    var y = DataType.New<Thing>().String(\"Hello\");\n    var z = DataType.New<Thing>().Boolean(true);\nWhich is a little unsatisfactory, as this library - if anything - is about correctness and reducing the possibilities of coder fuck-ups.  \nThe matching story on the codeplex version is quite ugly compared to the examples I gave above using the ternary operators.  \nHowever it does unpack the data, which is quite nice.  That would be good for the Shape example:\n``` c#\n    public interface Shape\n    {\n        Shape Square(Position topLeft, double width);\n        Shape Triangle(Position vertex1, Position vertex2, Position vertex3);\n        Shape Circle(Position position, double radius);\n    }\n// Assuming we had a Prelude function called datatype that does the same as DataType.New\nvar x = datatype<Shape>().Square(pos, width);\nvar y = datatype<Shape>().Triangle(p1, p2, p3);\nvar z = datatype<Shape>().Circle(pos, radius);\n\nvar area = x.Match()\n    .With(_ => _.Square,   (Position _, double width) =>              AreaOfSquare(width))\n    .With(_ => _.Triangle, (Position p1, Position p2, Position p3) => AreaOfTriangle(p1,p2,p3))\n    .With(_ => _.Circle,   (Position _, double radius) =>             AreaOfCircle(radius))\n    .Return<double>();\n\n```\nIt's still hella-ugly compared to the ternary approach, and that's without any predicate functionality!  \nHaving spent the past 20 minutes writing this out (and trying to think of better solutions), I'm definitely erring more towards the position that this is a pointless exercise.  It saves effort on generating the initial type, but the cognitive load is heavy and the existing tools for matching (the ternary operator) is still more powerful and attractive to look at (IMHO).  It is also much more efficient.\nThe main issue with the ternary approach is having to manually downcast the type, that will be handled with C# 7 pattern-matching which is due very soon.  So I think it's going to be a tough sell unless you can find some magic way to de-ugly all this, support predicates, have completeness checking, and be efficient.  \nYour call, but I think it'll be tough!\n. > and honestly I'm having fun putting the type system through it's paces so I'll keep working on it regardless\nYeah, it's always fun pushing the language as far as it can go (it's where this library came from!).  Let me know how you get on.\n. @OlduwanSteve I'm not sure I agree.  None isn't null.  It's a distinct single instance value.  The fact that null can be implicitly coerced to None doesn't also imply equivalence. \nYour pull request appears to be related to Nullable options, whereas your example above isn't.  I am confused as to the refactoring headache you're referring to and the problems caused.  It doesn't make sense to add hacks to deal with lazy refactoring.\n. > I think a good course of action would be to implement them as 'expected'\nI don't agree that your solution is what's expected, Option<T>? is a type that correctly has three states: null, None, Some(x).  \nc#\n    null != None\nI don't think you have made a strong enough case for breaking that.  I'm not quite sure why refactoring from Nullable<T> to Option<T> would require Option<T>?.  It seems a little odd (the only use-case I can think of is in an immutable With method).  But in general, once you have changed the variable's type, I don't then see why you wouldn't (as a natural part of the refactoring process), find all usages of the variable and validate it.\nI'm going to reject this I'm afraid, because it ignores the explicit type declaration by the programmer.\n. You state \"You wouldn't ever use Option? because it's a tautology\",\nbut then your pull-request dealt with Nullable>.  If you have a\nNullable> then it's likely to be for a good reason - like the\nWith use-case that I mentioned before - which explicitly expects a\ntri-state variable; that would break with your change.  I know we have code\nin our code-base that would fail because of that, others might too.\nOn Wed, 12 Oct 2016 at 13:10 OlduwanSteve notifications@github.com wrote:\n\nAs I understand it, the point of Option is to be a 'better' Nullable.\nYou wouldn't ever use Option? because it's a tautology. In addition\nto that, you're actively discouraging the use of null throughout the\nlibrary. Bearing those things in mind, it's not clear to me what's getting\nbroken by the proposed change.\nThe main advantage I see to the proposal is simply that doing this:\nfind all usages of the variable and validate it.\n...is hard and unreliable. Thanks to type inference and anonymous types,\nit's very easy for the type of a variable to be passed on to other\nvariables. Tracing all of that manually is likely to fail at some point. If\nthe compiler does it for you then it's much more reliable.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/155#issuecomment-253196277,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk_MBnTUxVtLUSn11V-NsEpp7aUaCks5qzM47gaJpZM4KSnIq\n.\n. Hi @stefc, what OS and version are you running this on?\n. Ok, looks like a .NET Core specific problem.  I've managed to repro from\nthe package, I'll try and take a look this evening.\n\nOn Wed, 12 Oct 2016 at 08:38 stefc notifications@github.com wrote:\n\nWindows 7 with dotnet core\ndotnet --versions give me the following\nVersion 1.0.0-preview2-003121\nOS Name : Windows\nOS Version: 6.1.7601\nRID: win7-x64\nLanguageExt.Core / .Process package is 1.9.3\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/157#issuecomment-253141218,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk4lHxuDCBlbQ_nQ9WpPLMlvuwYyYks5qzI5tgaJpZM4KTly4\n.\n. @stefc This should be resolved on v1.9.4 on nu-get.\n. @jvitkauskas Thanks!\n. @MiloszKrajewski As mentioned above it's due to the types being structs to protect against null.  If you're programming in a more functional style you'd be using interfaces less anyway.  Working with data-types that are just like product types in functional languages (immutable and with no methods attached), and static 'module like' classes I see this issue very rarely.  I do understand it's a pain point however.  \n\nIntroduction of IOption<A> won't work for this library, it has its own problems, as @Hinidu says it turns your bi-state value into a tri-state value (because null is available), which kills the entire reason for the Option type.  It also causes unnecessary boxing. And finally, even a minimal implementation of IOption<A> can't be covariant or contravariant, because at the very least you'd want a Match function, which has both input and output arguments:\nc#\n    public B Match<B>(Func<A, B> Some, Func<B> None) => ...\nSo the best course of action is to map using option.Map(x => x as A).\n. @bbarvish It's not so much a dogmatic approach, just more in keeping with the functional style.  Certainly interfaces and the OO style can sometimes have benefits, but what I've found with new projects is that my approach is:\nBuild a 'schema' of data types\nThese are very much like record-types in F#.  Classes with nothing but readonly fields and no methods or properties.  If you take a look at an answer I wrote on Stack Overflow about general purpose immutable classes in C# you'll see what these look like.\nWhere there are methods or properties, they have no external dependencies (to the class).  So for example you may have a class called Customer, with a DateOfBirth field, and perhaps a property called Age that calculates the age of the customer from the DateOfBirth.  But I wouldn't have a method called SaveToDb() or something like that.\nThe constructors of these classes validate that incoming data is sound.  That means if you have a reference to an immutable data structure, it can never be in a broken state.  \nThis 'schema' represents all of the data in your application, and you design it in a similar way to designing a RDBMS schema.  It's all about the shape of the data and its constraints, and keeping external dependencies (especially IO related) away.  That means you can safely build your schema project and include the DLL in other projects without any pain-points.  If you're building a multi/micro-service system this is very useful.\nSeparate code and data\nThis is the one thing that the OO world holds onto like some badge of honour.  But it just gets in the way nearly all of the time.  Especially in this world where we're constantly pushing data over the wire.  \nIf every function is really a projection from A to B (input arguments to return type), and A and B can only ever be in valid states (because they're immutable and you validate in the constructor).  Then you can start to create 'islands' of functionality (modules) that are related but separate from the data; rather than grouping all processing with the data.\nSo let's say you had a Customer data-type, you could then have:\n``` c#\n    public static class CustomerBilling\n    {\n        public static Invoice CreateInvoice(Customer c) \n        {\n            // code to generate an empty invoice with pre-populated customer data\n        }\n    }\npublic static class CustomerAccount\n{\n    public static Customer SetContactOptions(Customer c, Option<string> phone, Option<string> email)\n    {\n        return c.With(Phone: phone, Email: email);\n    }\n}\n\npublic static class CustomerDatabase\n{\n    public static Option<int> Write(Customer c) => ...\n    public static Option<Customer> Read(int id) => ...\n}\n\n```\nThis is a slightly contrived and not super informative example (I'm flu'd up atm!).  But hopefully you get the point.  The data is public, immutable, non-corruptible.  The functionality just maps from one state to another.  \nIn the OO world this is considered an anti-pattern: Anaemic Domain Model, but not in the functional world.  This is pretty much how modules and record types work in F#, and is similar in Haskell too.\nI would definitely recommend this video by Rich Hickey.  When you understand that the concept of time is poorly managed in OO then you'll see the value of the approach above.\nDependency injection and IO\nI don't use and actively despise the dependency-injection frameworks that are out there.  It's horrible magic dust that is nearly never to help the architecture of the code or the programmers on the team, it's nearly always to facilitate unit-tests.  By using the approach above everything is unit-testable by default.  The areas that aren't are the classic problems of IO.\nIf you spend any time in Haskell you'll see that they've put a lot of effort into 'managing' the IO problem to maintain referential transparency.  IO often looks like this:\nc#\n    public static class ThingProvider\n    {\n        public static void DoSomethingWithGlobalSideffect(Thing useThisThing);\n    }\nIt's next to impossible to test this correctly.  In the Haskell world you could imagine something like this happening:\nc#\n    public static class ThingProvider\n    {\n        public static World DoSomethingWithGlobalSideffect(World world, Thing useThisThing);\n    }\nThe World in its current state is passed in, and the function maps to a new World with the changes in.  Obviously that isn't exactly how it works out, but it's kind of the theory.\nIt's quite difficult to do this in C#, so I tend to find a pragmatic approach is best.  That is:\n- Load all required data from IO sources into the immutable 'schema' objects\n- Do your pure processing on the immutable objects, which gives you immutable objects back (with no side-effects)\n- Save all changes to the IO destination\nThen unit-test the hell out of the pure bit.  That's where your logic is.  This could be a web-request, a CRUD operation, a file-batch job, whatever.  This is why I built the LanguageExt.Process library.  It allows for a cluster operations like the above.\nIf I do need dependency injection, then I use Funcs rather than interfaces, because that's why functional programming is called what it is :) \nGet over the OO reuse/interface thing\nUnless you're writing a library like this, then it's actually rare to need reusable code.  The other myth is that by abstracting everything out to interfaces you can somehow in the future just replace the implementation and everything will 'just work'.  Unless you're writing a file-system or something that needs multiple implementations of 'a thing' that needs to be hot-swapped, then interfaces are usually overkill, or they're only there for dependency injection reasons.  I manage an enormous (5 million LOC+) web-application, and we got caught in that abstraction trap, for very little gain.  So mostly now I work with concrete data-types with module-like static functionality.  The classic complaint that comes up is that it's a refactoring nightmare if you need to change it.  Actually it isn't, with statically typed languages and a decent IDE, changes are found quickly.  Even when interfaces are used, they tend to be tied closer to the underlying concrete implementation than you'd expect.  \nConclusion\n\nImmutable data types\nStatic 'module like' classes with islands of pure functionality\nPush IO operations to 'the edge' \nDon't use dependency injection frameworks, just use Func\nBuild concrete stuff first, then abstract later if necessary\n\nThis isn't prescriptive, this is just what works for me (and I'm not looking for any arguments here)\nI'd also take a look at fsharpforfunandprofit.  It has a ton of tutorials on how to think functionaly.\n. @MiloszKrajewski You still have the boxing problem.  There's no free ride here I'm afraid.\nI have already added Optional<A> (an interface) to lang-ext for version 2.0 (which is in progress now in the type-classes branch), unfortunately it still won't support invariance and it's not exactly what you need, as I am adding Haskell typeclass-like functionality to the library.  \nOptional<A> will be an abstraction of all optional types (Option<A>, OptionUnsafe<A>, Either<L, R>, EitherUnsafe<L, R>, Try<A>, TryOption<A>, ...).\n- Option<A> source\n- Optional<A> type-class source\n- Optional<A> type-class extensions\nSo unfortunately Milosz, I don't have a good answer for you right now.  I don't want to be making major changes to the Master branch right now, because v2.0 is almost a re-write.  Once I have dealt with v2 I'll look at what could be done here, but it won't be super-high on my priority-list because there is a workaround (using Map). \n\nYet, it is there in other imperative-tinted languages for purely pragmatic reasons: java, fsharp, scala\n\nJust because others make bad decisions, doesn't mean I should too.\n. @masaeedu Hi Asad, could you please provide unit tests for your new functionality.  Thanks,\n. @masaeedu The CI is broken atm, haven't gotten around to fixing it.  I'll grab locally and test.\n. @masaeedu \nLooks good, thanks Asad\n. Yep, it's really used.  All of the monadic types have MatchObservable for asynchronous matching.\nThey could probably be broken out as extensions in a separate project.  It's not going to happen very soon I'm afraid.\n. > So closing the issue?\nYep, I think although in the longer term a dedicated LanguageExt.Reactive project might be a good idea, right now (when I have the bonnet up on a ton of the core library code), it's probably best to leave as-is.\n\nSo I decided to take monads from here rather than csharp-monads.\n\ncsharp-monad was my first attempt at a functional library in C#.  It's OK, but it suffered from not having the supporting framework that is language-ext.  This is much more complete, useful, and maintained.  I keep the csharp-monad library ticking over because it's linked to from the Monads page on Wikipedia, but it's essentially mothballed.\n. No, sorry.\nOn Wed, 11 Apr 2018 at 13:21, Mario De Schaepmeester \nnotifications@github.com wrote:\n\nHey @louthy https://github.com/louthy, Language-Ext looks like a great\nlibrary that I'd like to use, but having to pull in System.Reactive to use\nLanguageExt.Core is really sad \ud83d\ude1e\nWould you please reconsider externalizing the Reactive support to another\npackage? I'd be happy to help out if you still agree this should happen.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/163#issuecomment-380432178,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkxqfKVyW97fFUwfxpU1INuG7RBsKks5tnfVQgaJpZM4KanMv\n.\n. I'm sorry I can't accept this right now.  I am making major changes in another branch and this will cause conflicts that I really don't want to be resolving.  I appreciate the effort, but it's probably best if you shout on the issues page before ploughing ahead with changes. \n. > Usually if there are conflicts you can ask the person making the PR to rebase once you've merged in whatever you're prioritizing.\n\nYou don't understand the scope of the changes being made - it's borderline a re-write.  I really don't want to have to deal with the merge issues.\n. This is something I really don't want to be thinking about at the moment.  My brain is not in this space as I've got a 1000 plates spinning with the new version.  Just a quick glance at your changes and they appear to be dangerous, deleting all the csproj files, which I'm unsure of why (The non-Core sln exists because compiling the .NET Core solution is so slow).  So please leave it for now, I'm not quite sure what your intentions are and I'm not able to dedicate enough time to check.\n. > Having both project.json and csproj is redundant\nNo it isn't.  As the person who spends the most time in the project compiling and testing, I can tell you that the csproj is vital for rapid iteration and testing.  The project.json is the deployment project, and it works great for that because it supports the myriad .NET versions and makes building of nuget packages easy -- but it's slow.\n\nit leads to configuration drift (this has already started happening with your dependencies)\n\nDoesn't matter, as the deployed version comes from one SLN.  The only dependencies are slow moving ones (like Newtonsoft.JSON, Rx.NET, etc), the APIs are static.  So even if they fall behind a bit on the csproj solution, it's fine.  I run the unit-tests before building the nuget packages.  So the project.json can be considered the 'master' solution (even if I spend most of my time in the csproj based solution for coding convenience).\n\nA few months from now you could be stuck consolidating your project.json and csproj \n\nAnother reason I don't want any movement on this until MS sort out their project system.  The settings in the project.jsons were guided by P Carter from the F# team at MS - I'm happy to keep them as-is until MS sort their tooling out. I wasted so much time with DNX and then .NETCore, I am never making the mistake of pre-empting them again.  I'll wait until v1 of the tools are actually ready (and will probably still wait a while after that).\n\nYes, this is a problem lots of people have complained about. \n\nSo you knew about it, and decided to cripple my build process anyway?  Thanks!  I don't want to sound ungrateful, any help on the project is welcome, but it's pretty reckless to come into a mature project and just change the entire project setup without any consideration or consultation of the people who have to maintain and deploy it.  It's a big jump from adding a few composition functions to changing my entire workflow.\n. @orthoxerox \n\nClaudio Russo's and Matt Windsor's concept\n\nIt is, yes. \nI've been fighting the type-system relentlessly over the past few months.  I keep going back and forth between (1) monadic types like Option<A>, Either<L, R>, etc. deriving from a Monad<A> interface; and (2) keeping Option<A>, Either<L, R> non-monadic but providing MOption<A>, MEither<L, R>, etc. type-class instances of a Monad<A>.  \nThe problem with the second approach was that having a separate instance type that derives from Monad<A> wouldn't magically make Bind return a Option<B> if implemented in an MOption<B> : Monad<B> instance (you'd get a return value of Monad<B>).  So initially I thought having separate instances for the higher-order types (like monad) wasn't really going to work.  It works well for things like Eq or Ord, but I figured I'd join them together and deal with the boxing issues and the loss of specificity.  It also allowed LINQ to work.\nHowever, a few nights ago I had a breakthrough when refactoring the NewType<A>, I realised I could get around all of the boxing and casting issues I was having by putting the declared type in its own generic arguments list.  \nSo for example, the old way of declaring a NewType (say Hours) would be:\nc#\n    public class Hours : NewType<int> \n    {\n        public Hours(int x) : base NewType(x) {}\n    }\nNow you do this:\nc#\n    public class Hours : NewType<Hours, int> \n    {\n        public Hours(int x) : base NewType(x) {}\n    }\nThe NewType definition looks like this:\nc#\n    public abstract class NewType<NEWTYPE, A> :\n        IEquatable<NEWTYPE>,\n        IComparable<NEWTYPE>\n        where NEWTYPE : NewType<NEWTYPE, A>\nThat allows the derived type to be used in the base-class member declarations.  Which is awesome, because NewType is supposed to shortcut creating a strongly-typed single value type.  So things like Select and SelectMany look like this:\n``` c#\n        public NEWTYPE Select(Func map) =>\n            New(map(Value));\n    public NEWTYPE SelectMany(\n        Func<A, NewType<NEWTYPE, A>> bind,\n        Func<A, A, A> project) =>\n        New(project(Value, bind(Value).Value));\n\n```\nThat means the end-user of the NewType gets a strongly typed version of Select and SelectMany by default.  The code below previously wouldn't have compiled because the LINQ statement would return a NewType<int> rather than Hours:\nc#\n    // Previously this wouldn't compile, because Select and SelectMany \n    // would return a NewType<A>, not Hours\n    Hours h = from x in new Hours(24)\n              from y in new Hours(24)\n              select x + y;\nThe run-time checks I'd added to the NewType weren't needed anymore, because the compiler is now working with the derived type rather than the base type.  \nIf I create another NewType called Seconds:\nc#\n    public class Seconds : NewType<Seconds, int> \n    {\n        public Seconds(int x) : base NewType(x) {}\n    }\nAnd try to combine Hours and Seconds, then correctly the code doesn't compile, because they're of different types.  Again this would have compiled on the old system, and it relied on run-time checks.\nc#\n    // This won't compile, whereas it previously did because Select and SelectMany were\n    // too generic\n    var res = from x in new Hours(24)\n              from y in new Seconds(60)\n              from x + y;\nThis was the breakthrough that has put me on to the path I'm working on right now:\n- separate type-class instances for monads, functors, etc.  (MOption<A>, FOption<A, B>, MEither<L, R>, etc.)\n- with non-monadic Option<A>, Either<L, R>, etc. \nFunctors are quite interesting actually, because essentially each instance unifies the source and target types into a real functor category:\n``` c#\n    /// Type-class\n    public interface Functor\n    {\n        FB Map(FA ma, Func f);\n    }\n/// Lst<A> to Lst<B> instance\npublic struct FLst<A, B> : \n    Functor<Lst<A>, Lst<B>, A, B>\n{\n    public static readonly FLst<A, B> Inst = default(FLst<A, B>);\n\n    public Lst<B> Map(Lst<A> ma, Func<A, B> f) =>\n        ma.Map(f);\n}\n\n```\nSo you can call the instance directly:\n``` c#\n    Lst list = List(\"100\", \"50\", \"25\");\nLst<int> result = FLst<string, int>.Inst.Map(list, Int32.Parse);\n\n```\nOr write truly generic code that works with functors.  Here's a function that will parse strings bound within any functor and return a functor of the same outer-type, but with the inner-type (string) mapped to an int.\nc#\n     public static FB ParseInts<Functor, FA, FB>(FA input)\n        where Functor : Functor<FA, FB, string, int> => \n        default(Functor).Map(input, Int32.Parse);\nBelow is the function in action with a Lst<string> and an Option<string>.\n``` c#\n    var list = List(\"100\", \"50\", \"25\");\n    var opt = Some(\"100\");\n// Parse a list of strings into a list of ints\nLst<int> res1 = ParseInts<FLst<string, int>, Lst<string>, Lst<int>>(list);\n\n// Parse an option of string into an option of int\nOption<int> res2 = ParseInts<FOption<string, int>, Option<string>, Option<int>>(opt);\n\n```\n\nHave you managed to make query expressions work with generic monads?\n\nThis can't work with the full type-class approach I'm now taking.  However I will be providing all of the generic code for things like Bind, Map, Fold, etc.  So LINQ won't be available, but you'll be able to write generic code (it's a bit ugly though).\nThis is a general case applicative:\nc#\n        public static MC apply<MONADABC, MONADA, MONADB, MONADC, MABC, MA, MB, MC, A, B, C>(MABC x, MA y, MB z)\n            where MONADABC : struct, Monad<MABC, Func<A, B, C>>\n            where MONADA   : struct, Monad<MA, A>\n            where MONADB   : struct, Monad<MB, B>\n            where MONADC   : struct, Monad<MC, C> =>\n                default(MONADABC).Bind<MONADC, MC, C>(x, a =>\n                default(MONADA  ).Bind<MONADC, MC, C>(y, b =>\n                default(MONADB  ).Bind<MONADC, MC, C>(z, c =>\n                default(MONADC  ).Return(a(b, c)))));\nNotice the three Bind invocations, followed by a Return?  That's the equivalent of:\nc#\n        public static MC apply<MONADABC, MONADA, MONADB, MONADC, MABC, MA, MB, MC, A, B, C>(MABC x, MA y, MB z)\n            where MONADABC : struct, Monad<MABC, Func<A, B, C>>\n            where MONADA   : struct, Monad<MA, A>\n            where MONADB   : struct, Monad<MB, B>\n            where MONADC   : struct, Monad<MC, C> =>\n                from a in x\n                from b in y\n                from c in z\n                select a(b, c);\nHere's the general-case definitions for SelectMany.  Take a look at the generic arguments, I'm sure you can see why LINQ has a hard time!\nc#\n        public static MC SelectMany<MonadA, MonadB, MonadC, MA, MB, MC, A, B, C>(\n            this MA self,\n            Func<A, MB> bind,\n            Func<A, B, C> project)\n            where MonadA : struct, Monad<MA, A>\n            where MonadB : struct, Monad<MB, B>\n            where MonadC : struct, Monad<MC, C> =>\n                default(MonadA).Bind<MonadC, MC, C>( self,    t => \n                default(MonadB).Bind<MonadC, MC, C>( bind(t), u => \n                default(MonadC).Return(project(t, u))));\nHowever not all is lost, because now writing types like Option<A> becomes a lot easier.  So for example the SelectMany for Option<A> is now:\nc#\n    public Option<C> SelectMany<B, C>(\n        Func<A, Option<B>> bind,\n        Func<A, B, C> project) =>\n        this.SelectMany<MOption<A>, MOption<B>, MOption<C>, Option<A>, Option<B>, Option<C>, A, B, C>(bind, project);\nSo it calls the general-case version, which uses the MOption instances to invoke the Bind and Return operations.  \nI'm hoping that this allows me to build a much better code-gen system.  if you look at the generic arguments on the call to SelectMany, you should be able to see how easy it is to mix and match monadic types.  Here's a couple of examples going from Option to Either, and Option to TryOption\n``` c#\n    this.SelectMany, MEither, MEither, Option, MEither, MEither, A, B, C>(bind, project);\nthis.SelectMany<MOption<A>, MTryOption<B>, MTryOption<C>, Option<A>, TryOption<B>, TryOption<C>, A, B, C>(bind, project);\n\n```\nThis is where it gets genuinely exciting, because the C# type-system is doing the work, not a load of bespoke code that's trying to plumb everything together.  That makes everything sound as well as quick.\nThe end goal will be:\n- You can add types that you can't control (say int) to type classes (say Num) \n- That you can write totally generic code that works with: monads, functors, foldables, optionals, choices, etc.  And you won't need to know about the specific underlying type; or have to derive that type from an IMonad, or an IFunctor (for example).\n- Provide tons of functionality that works with the provided type classes, so when you create your own instance on a type class, then you'll get a ton of useful stuff for free.  \nHowever you will incur the pain of providing the generic arguments.  I think for those rare cases where you want to write super-generic code, it's worth it.  And once it's all in and proven I'll take it to the Rosyln issues page and try and get pressure put on for a couple of improvements:\n- We should only have to provide generic arguments that aren't in the parameters list\n- Return type inference from the code within the method - this will make nearly all type inference work (and will probably make LINQ work too).\n- Perhaps request a better type inference story in-general for expression-bodied functions\nMost of this new stuff isn't committed yet, it's only on my local.\n. For what benefit?  with is usually a feature of record-types; all 'mutating' of the collection types is handled by the various related functions (like Add).\n. I am unclear what that has to do with Lst, Map, Set, Que, Stck, HMap, and HSet?  \nWhilst I think it's impressive what you've done with the With library, I do feel it's an overengineered solution and will add complexity to this library that I'd rather not maintain long-term.  It doesn't really add any value, if someone wants that functionality then they can just use your library directly surely?  There's no integration piece here from what I can tell.  Unless I'm missing something?\nAnd there's a prettier (but more manual) way of doing record-type With methods, which is how I do them right now:\nhttps://stackoverflow.com/questions/38575646/general-purpose-immutable-classes-in-c-sharp/38596298#38596298\n. @jrouaix Hi, yes I think there's a couple of issues in your code.  \nKey things to note:\n1) You weren't blocking after initialisation on key-press 1, so the server part would shut down immediately\n2) tell(\"Hello! \" + k, actor); the arguments are the wrong way around, they should have been: tell(actor, \"Hello! \" + k);  So you were trying to tell to a Process called Hello! ...\n3) find doesn't actually go and find a process, it generates a ProcessId from the name and role provided.  I know that's a touch misleading, but you can't tell if a process is running by calling find.  exists will do that for you.  But mostly with fault tolerant systems you want to know that it will eventually process it, it doesn't matter if the process is alive now, as long as it will be; so don't go asking, just tell.\n4) The terminated inbox is not what you think it is.  One process can watch another process, when the watched process dies, a message is sent to the watcher process' Terminated inbox.  So Terminated is there to receive 'death messages' from other processes.\nThere were a few other minor bits.  In the process of trying to see your intent, I refactored things out into more manageable chunks.  One big thing to note is that namespacing with a GUID is a very quick way to end up with meta-data and process-queues in Redis that can't ever be recovered after your application dies.  I realise this is just a test-app, but it's worth considering a better way to name your nodes.\n``` c#\nusing System;\nusing LanguageExt;\nusing static LanguageExt.Prelude;\nusing static LanguageExt.Process;\npublic class Program\n{\n    static void WriteLine(string msg) => \n        Console.WriteLine(msg);\n/// <summary>\n/// This is pretty brutal, but because you're namespacing everything with a\n/// GUID, you will end up with lots of orphaned Processes in Redis, that you\n/// can't recover becaus you won't generate the same GUID twice.  This will\n/// wipe everything that has been created, and remove all registrations.  It\n/// should be called before shutdown.  It is much simpler to give your nodes\n/// non-generated names.  But it's your call obviously :)\n/// </summary>\n/// <param name=\"instanceKey\"></param>\n/// <returns></returns>\nstatic Unit KillAllInGeneratedSpace(Guid instanceKey) =>\n    (from c in SystemCluster(\"sys\")\n     from pid in c.QueryProcesses($\"*{instanceKey}*\")\n     select pid)\n    .Iter(pid => kill(pid));\n\nstatic void RunActorService(Guid instanceKey)\n{\n    ProcessConfig.initialise(\"sys\", \"myactors\", $\"server-{instanceKey}\", \"localhost\", \"15\");\n\n    // I have removed the Guid.NewGuid from here.  Processes are namespaced by their node-name \n    // (definied above).  And since you're already using a Guid above, there's no need to do it\n    // here.  That is unless you need more than one actorCreator, but it doesn't appear to be\n    // the case.\n    var actorsService = spawn<string>($\"actorCreator\", ActorCreatorInbox, ProcessFlags.PersistInbox);\n\n    register(\"actorCreator\", actorsService);\n\n    // Wait for the user\n    Console.WriteLine();\n    Console.WriteLine(\"Server running, press any key to exit\");\n    Console.ReadKey();\n}\n\nstatic void ActorCreatorInbox(string actorName) =>\n    Children.Find($\"actor-{actorName}\",\n        Some: pid =>\n        {\n            Console.WriteLine($\"Actor already exists: {actorName}\");\n            return reply(pid);\n        },\n        None:() => \n        { \n            Console.WriteLine($\"Creating actor {actorName}\");\n            var actor = spawn<string>($\"actor-{actorName}\", WriteLine, ProcessFlags.PersistInbox);\n            register(actorName, actor);\n            Console.WriteLine($\"Created actor {actorName}\");\n            return reply(actor);\n        });\n\n\nstatic void RunClientService(Guid instanceKey)\n{\n    ProcessConfig.initialise(\"sys\", \"myactors\", $\"client-{instanceKey}\", \"localhost\", \"15\");\n\n    var randy = new Random();\n    Console.WriteLine();\n    Console.WriteLine(\"Client running.  Press a key to spawn/tell\");\n\n    while (true)\n    {\n        var k = Console.ReadKey();\n        var actorName = $\"actor{randy.Next(10)}\";\n\n        var actor = find(actorName);\n\n        try\n        {\n            // It was hard to understand your intent here, but I suspect it's to spin up actors\n            // as they're requested.  One way you could do that is to instead send all tells\n            // to actorCreator.  It can then fwdChild(actorName) if the child actor exists.  If\n            // not it can create one on the fly.  Although actors are cheap, so you may find\n            // it easier to look at Routers and have some fixed sized round-robin routers or\n            // similar\n            ask<ProcessId>(find(\"actorCreator\"), actorName);\n            tell(actor, $\"Hello! {DateTime.Now}\");\n        }\n        catch(ArgumentException e)\n        {\n            Console.WriteLine(e.Message);\n        }\n    }\n}\n\npublic static void Main(string[] args)\n{\n    Console.WriteLine(\"Type 1 to spawn an actor service, 2 to spawn a client service.\");\n\n    var key = Console.ReadKey();\n\n    RedisCluster.register();\n    var instanceKey = Guid.NewGuid();\n\n    try\n    {\n        if (key.KeyChar == '1')\n            RunActorService(instanceKey);\n        else\n            RunClientService(instanceKey);\n    }\n    finally\n    {\n        // This is the final cleanup, see the comments\n        // for the method above.\n        KillAllInGeneratedSpace(instanceKey);\n    }\n}\n\n}\n```\nLet me know if you have any more problems.\n. > Again, congratulation sur this amazing library!\nOh, and thank you for the kind words :)\n. @jrouaix \nHere's a better version.  The server now routes all messages through actor-router.  That means the client doesn't need to care about what the server is doing, or whether there are processes running or not.  It simply tells the server, and the server will deal with firing up new processes as necessary.\n``` c#\nusing System;\nusing LanguageExt;\nusing static LanguageExt.Prelude;\nusing static LanguageExt.Process;\npublic class Program\n{\n    public class HelloTo\n    {\n        public string To;\n        public string Msg;\n    public HelloTo(string to, string msg)\n    {\n        To = to;\n        Msg = msg;\n    }\n}\n\nstatic void WriteLine(HelloTo msg) => \n    Console.WriteLine($\"{msg.Msg} - {Self.Name}\");\n\n/// <summary>\n/// This is pretty brutal, but because you're namespacing everything with a\n/// GUID, you will end up with lots of orphaned Processes in Redis, that you\n/// can't recover becaus you won't generate the same GUID twice.  This will\n/// wipe everything that has been created, and remove all registrations.  It\n/// should be called before shutdown.  It is much simpler to give your nodes\n/// non-generated names.  But it's your call obviously :)\n/// </summary>\n/// <param name=\"instanceKey\"></param>\n/// <returns></returns>\nstatic Unit KillAllInGeneratedSpace(Guid instanceKey) =>\n    (from c in SystemCluster(\"sys\")\n     from pid in c.QueryProcesses($\"*{instanceKey}*\")\n     select pid)\n    .Iter(pid => kill(pid));\n\nstatic void RunActorService(Guid instanceKey)\n{\n    ProcessConfig.initialise(\"sys\", \"myactors\", $\"server-{instanceKey}\", \"localhost\", \"15\");\n\n    // I have removed the Guid.NewGuid from here.  Processes are namespaced by their node-name \n    // (definied above).  And since you're already using a Guid above, there's no need to do it\n    // here.  That is unless you need more than one actorCreator, but it doesn't appear to be\n    // the case.\n    var actorsService = spawn<HelloTo>($\"actor-router\", ActorRouterInbox, ProcessFlags.PersistInbox);\n\n    register(\"actor-router\", actorsService);\n\n    // Wait for the user\n    Console.WriteLine();\n    Console.WriteLine(\"Server running, press any key to exit\");\n    Console.ReadKey();\n}\n\nstatic void ActorRouterInbox(HelloTo msg) =>\n    Children.Find(msg.To,\n        Some: pid => fwdChild(msg.To),\n        None: () => \n        { \n            Console.WriteLine($\"Creating actor {msg.To}\");\n            var actor = spawn<HelloTo>(msg.To, WriteLine, ProcessFlags.PersistInbox);\n            register(msg.To, actor);\n            Console.WriteLine($\"Created actor {msg.To}\");\n            return fwd(actor, msg);\n        });\n\nstatic void RunClientService(Guid instanceKey)\n{\n    ProcessConfig.initialise(\"sys\", \"myactors\", $\"client-{instanceKey}\", \"localhost\", \"15\");\n\n    var randy = new Random();\n    Console.WriteLine();\n    Console.WriteLine(\"Client running.  Press a key to spawn/tell\");\n\n    while (true)\n    {\n        var k = Console.ReadKey();\n        var actorName = $\"actor{randy.Next(10)}\";\n\n        try\n        {\n            tell(find(\"actor-router\"), new HelloTo(actorName, $\"Hello! {DateTime.Now}\"));\n        }\n        catch(ArgumentException e)\n        {\n            Console.WriteLine(e.Message);\n        }\n    }\n}\n\npublic static void Main(string[] args)\n{\n    Console.WriteLine(\"Type 1 to spawn an actor service, 2 to spawn a client service.\");\n\n    var key = Console.ReadKey();\n\n    RedisCluster.register();\n    var instanceKey = Guid.NewGuid();\n\n    try\n    {\n        if (key.KeyChar == '1')\n            RunActorService(instanceKey);\n        else\n            RunClientService(instanceKey);\n    }\n    finally\n    {\n        // This is the final cleanup, see the comments\n        // for the method above.\n        KillAllInGeneratedSpace(instanceKey);\n    }\n}\n\n}\n```\n. @jrouaix \n\nif I add a node to the server cluster, I end up having actors spawning and processing the message in both of the nodes.\n\nWhat happens when a node registers a Process is that it creates a key in redis under the registered name with a list of Processes that have registered with that name.  So when you tell the registered name, you are in-fact broadcasting to them all.\nYou can use the role dispatchers instead.  Unfortunately I don't think this will work with registered names.  So use this to build the ProcessId:\n``` c#\n    var pid = Role.First[\"server-role\"][\"user\"][\"actor-router\"];\ntell(pid, new HelloTo(actorName, $\"Hello! {DateTime.Now}\"));\n\n```\nThis will always send the message to the first node in the the server-role role.  Note how the relative path is built /user/actor-router.\nOther role disptachers are:\n``` c#\n    // Send to all actor-routers in the server-role\n    var pid = Role.Broadcast[\"server-role\"][\"user\"][\"actor-router\"];\n// Send to the actor-router that has the smallest inbox\nvar pid = Role.LeastBusy[\"server-role\"][\"user\"][\"actor-router\"];\n\n// Send to a random actor-router \nvar pid = Role.Random[\"server-role\"][\"user\"][\"actor-router\"];\n\n// Send to each actor-router in a round-robin fashion \nvar pid = Role.RoundRobin[\"server-role\"][\"user\"][\"actor-router\"];\n\n// Simple indexing based on node name\nvar pid = Role.First[\"server-role\"][\"user\"][\"actor-router\"];\nvar pid = Role.Second[\"server-role\"][\"user\"][\"actor-router\"];\nvar pid = Role.Third[\"server-role\"][\"user\"][\"actor-router\"];\n\n// Can be called from within the server-role if the nodes want to\n// talk to the node 'next' or 'previous' to them.  This is useful for\n// peer-to-peer communication\nvar pid = Role.Next()[\"user\"][\"actor-router\"];\nvar pid = Role.Prev()[\"user\"][\"actor-router\"];\n\n```\nIt's possible to build your own dispatchers.  To see how this is done, take a look at how the built-in ones are implemented.\nI have updated the example below.  NOTE: I have moves the server nodes into a server-role and the client nodes into a client-role.  That makes the querying more efficient, and means you're not delivering messages to nodes that don't care about them.\nServer\nc#\nProcessConfig.initialise(\"sys\", \"server-role\", $\"server-{instanceKey}\", \"localhost\", \"14\");\nClient\nc#\n ProcessConfig.initialise(\"sys\", \"client-role\", $\"client-{instanceKey}\", \"localhost\", \"14\");\nUpdated example:\n``` c#\nusing System;\nusing LanguageExt;\nusing static LanguageExt.Prelude;\nusing static LanguageExt.Process;\nusing System.Linq;\nusing System.Collections.Generic;\npublic class Program\n{\n    public class HelloTo\n    {\n        public string To;\n        public string Msg;\n    public HelloTo(string to, string msg)\n    {\n        To = to;\n        Msg = msg;\n    }\n}\n\nstatic void WriteLine(HelloTo msg) => \n    Console.WriteLine($\"{msg.Msg} - {Self.Name}\");\n\n/// <summary>\n/// This is pretty brutal, but because you're namespacing everything with a\n/// GUID, you will end up with lots of orphaned Processes in Redis, that you\n/// can't recover becaus you won't generate the same GUID twice.  This will\n/// wipe everything that has been created, and remove all registrations.  It\n/// should be called before shutdown.  It is much simpler to give your nodes\n/// non-generated names.  But it's your call obviously :)\n/// </summary>\n/// <param name=\"instanceKey\"></param>\n/// <returns></returns>\nstatic Unit KillAllInGeneratedSpace(Guid instanceKey) =>\n    (from c in SystemCluster(\"sys\")\n     from pid in c.QueryProcesses($\"*{instanceKey}*\")\n     select pid)\n    .Iter(pid => kill(pid));\n\nstatic void RunActorService(Guid instanceKey)\n{\n    ProcessConfig.initialise(\"sys\", \"server-role\", $\"server-{instanceKey}\", \"localhost\", \"14\");\n\n    // I have removed the Guid.NewGuid from here.  Processes are namespaced by their node-name \n    // (definied above).  And since you're already using a Guid above, there's no need to do it\n    // here.  That is unless you need more than one actorCreator, but it doesn't appear to be\n    // the case.\n    var actorsService = spawn<HelloTo>($\"actor-router\", ActorRouterInbox, ProcessFlags.PersistInbox);\n\n    register(\"actor-router\", actorsService);\n\n    // Wait for the user\n    Console.WriteLine();\n    Console.WriteLine(\"Server running, press any key to exit\");\n    Console.ReadKey();\n}\n\nstatic void ActorRouterInbox(HelloTo msg) =>\n    Children.Find(msg.To,\n        Some: pid => fwdChild(msg.To),\n        None: () => \n        { \n            Console.WriteLine($\"Creating actor {msg.To}\");\n            var actor = spawn<HelloTo>(msg.To, WriteLine, ProcessFlags.PersistInbox);\n            Console.WriteLine($\"Created actor {msg.To}\");\n            return fwd(actor, msg);\n        });\n\n\nstatic void RunClientService(Guid instanceKey)\n{\n    ProcessConfig.initialise(\"sys\", \"client-role\", $\"client-{instanceKey}\", \"localhost\", \"14\");\n\n    var randy = new Random();\n    Console.WriteLine();\n    Console.WriteLine(\"Client running.  Press a key to spawn/tell\");\n\n    while (true)\n    {\n        var k = Console.ReadKey();\n        var actorName = $\"actor{randy.Next(10)}\";\n\n        try\n        {\n            tell(Role.First[\"server-role\"][\"user\"][\"actor-router\"], new HelloTo(actorName, $\"Hello! {DateTime.Now}\"));\n        }\n        catch(ArgumentException e)\n        {\n            Console.WriteLine(e.Message);\n        }\n    }\n}\n\npublic static void Main(string[] args)\n{\n    Console.WriteLine(\"Type 1 to spawn an actor service, 2 to spawn a client service.\");\n\n    var key = Console.ReadKey();\n\n    RedisCluster.register();\n    var instanceKey = Guid.NewGuid();\n\n    try\n    {\n        if (key.KeyChar == '1')\n            RunActorService(instanceKey);\n        else\n            RunClientService(instanceKey);\n    }\n    finally\n    {\n        // This is the final cleanup, see the comments\n        // for the method above.\n        KillAllInGeneratedSpace(instanceKey);\n    }\n}\n\n}\n``\n. @stefc There's always a mismatch at the edges of an actor system, and unfortunately you've hit one of those.  I'm struggling to follow your description, but one approach could be this:\n- As you state, you have a correlationId, this should be passed through\n- In yourrefReplyToActor, simplypublish` the response:\nc#\n    public void Inbox(ReplyMsg msg) =>\n       Process.publish(msg);\n- Get your PostCommand to subscribe to the refReplyToActor:\nc#\npublic async Task<State> PostCommand(IDomainCommand domainCommand) \n{\n    var task = Process.observe<AggregateValue>(refReplyToActor)\n                      .Where(x => x.CorrelationId == correlationId)\n                      .Take(1)\n                      .ToTask();\n    tell(commandStore, domainCommand, refReplyToActor) \n    return await task;\n}\nOne thing to note, is that refReplyToActor should be an absolute path, not a registered name, or a router, and it's better if it's local.  The pub-sub code isn't quite a good as it could be and needs some improvement.  \nI think will eventually put in some async variants of ask.  The main reason for not doing it before was to discourage use within actors, but I could protect against that quite easily.  In fact you could probably just use something like this:\nc#\n    public static Task<R> askAsync<R>(ProcessId pid, object message) =>\n        Task.Run(() => ask<R>(pid, message));\nEven though ask is blocking, it does release the thread whilst it's waiting for a reply, so it'll be as efficient as it can be and not hog a ton of threads.  Just make sure you don't use this within a Process message-loop, because otherwise you'll kill the single threadedness of the actor-model.\nLet me know how you get on.\n. > Thanks for an awesome library---this is now a BCL for us on our projects.\n:)\n\nI'd like to combine all the results using logic with this kind of behaviour: none * none = none, none * unit = none and unit * unit = unit, but Unit isn't IMultiplicable- IMultipliable... thingy. How do I get that behaviour from an Option[]?\n\nIt's a shame that version 2 of lang-ext isn't ready for you, because this would be in the MonadPlus category and you'd be able to mplus them.\nThe three rules you gave (btw you missed out what happens when unit * none = ???, I assume it'll be none) seem to imply that you could just use a combination of bind and fold:\nc#\n    static Option<Unit> Evalulate(Option<Unit>[] xs) =>\n        fold(xs, Some(unit), (s, x) => from a in s\n                                       from b in x\n                                       select b);\nDisclaimer: I haven't checked this code works!  Looks OK though.\n\nI've been enjoying using Option as a sort of way to continue the computation\n\nYeah that's totally the point, the bound value (Unit in this case) isn't the controller of that, so bool would make no difference really, it's whether it's None or not that matters.\n. @NickDarvey Had a bit of a brain freeze moment, example updated!\n. @NickDarvey Indeed, there seems to be some weird inference thing going on there.  I fixed it by using the fluent style:\nc#\n        static Option<Unit> Evalulate(Option<Unit>[] xs) =>\n            xs.Fold(Some(unit), (s, x) => from _ in s\n                                          from b in x\n                                          select b);\n\nAs an aside, how do you know which style to pick where? \n\nI guess I usually just think \"What would communicate this idea best to other programmers\".  As much as our jobs is to communicate with a computer about what we want it to do, it's also massively about communicating with other members of the team about our intent.\nSo I try to pick the most elegant looking and easy to read approach.  However it doesn't do to mix styles too much, that can be a problem in its own right.  It's relatively easy for me to pick any style I like in response to an issue on here, but if I jumped around style-wise in the same block of code then it'd be a bit shitty.  But that would also fall foul of the \"What would communicate this idea best to other programmers\" mantra.\n. @Richiban Hi Richard, thanks for this.  But I'm going to reject it.  The code is fine, it's just this is already fixed on the type-classes branch, which will be the next release:\nhttps://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/DataTypes/NewType/NewType.Predicate.cs#L68\n. Good idea.  I'll look into rolling it into the v2 type-classes branch.\n. This is now in v2.0.9-alpha. I am a bit short of time, so I don't have a good answer for you; but obviously you could convert to a list and re-load from a list:\n``` c#\n    var xs = set.ToList();\nvar s = Set.createRange(xs);\n\n```\nI'm in the process of rewriting the core types;  when I get back to the code next week I'll take a look.\n. @NickDarvey Curiosity got the better of me.  As you mention SetItem<T> didn't have [Serializable].  I have now added it if you'd like to test the latest from nuget.  \nPlease let me know how you get on, because I haven't had time to check.\n. @la-yumba Hi Enrico, thanks for getting in touch.  I haven't quite got time to review this at the moment, but rest assured I'm revisiting this with v2 of language-ext.  I'm looking into the best approach for the code-gen part, and considering all options for monad-transformers (including creating transformer types like OptionT, LstT, etc.\n. @la-yumba Hi Enrico, I followed your pattern for the latest transformer type extensions.  The template for generating the extension methods are implemented in terms of the new Trans type, which provides a default and bulletproof way of nesting any types that have a Monad<MA, A> class instance.\nSo for example, nesting Lst and Option as Lst<Option<A>>:\n```c#\n    var mt = Trans>, Lst>, MOption, Option, int>.Inst;\nvar x = List(Some(1), Some(2), Some(3));\nvar y = List(Some(1), Some(2), None);\n\nvar totalx = mt.SumT(x);  // 6\nvar totaly = mt.SumT(y);  // 0\n\nOption<Lst<int>> seqx = mt.Sequence(x); // Some(List(1, 2, 3))\nOption<Lst<int>> seqy = mt.Sequence(y); // None\n\nUsing `Bind` is a bit more heavyweight as I'm sure you can imagine (and that's why they're all wrapped up in extension methods!c#\n    var u = mt.Bind>, Lst>, MOption, Option, int>(\n            x, a => Some(a * 2));\n// u == List(Some(2), Some(4), Some(6))\n\nvar v = mt.Bind<MLst<Option<int>>, Lst<Option<int>>, MOption<int>, Option<int>, int>(\n        y, a => Some(a * 2));\n\n// v == List(Some(2), Some(4), None)\n\n```\n. Oh, from your original comment, this doesn't really make sense unless they're all promoted to sequence types:\n```c#\nvar oa = Some(1);\nvar lb = List(2);\nvar oc = Some(3);\nvar r2 =\n   from a in oa\n   from b in lb\n   from c in oc\n   select a + b + c;\n``\nBecause the outer type would be anOption.  I have had to make all of the core monadic types derive fromIEnumerableso they work with Json.NET.  And whilst that causes a few headaches, it will promote the above expression to anIEnumerable, but if you always work with the same monadic type it doesn't.  That seems like a pretty useful feature.. @StanJav  Cheers.  How quickly do you need it?. @ncthbrt No worries, there's no rush.  It'll be a little while until I get this branch released.  Make sure you grab the latest because I have fixed up a load of references on the csproj build.. @ncthbrt No worries, take your time.  . @ncthbrt Hi Nick, sorry for the slow response.  I've been investigating some different approaches to this.  Mainly because the example code above gave me some concerns.  Namely the mixture of fluent and named-parameters.  It's a confused style I think, and jars with the existingopt.Match(Some: ..., None: ...)andopt.Some(...).None(...)`.\nSo I started thinking about it a bit more, and I remembered an answer I'd given on StackOverflow a while back about 'functional IF' statements.\nThey key difference with yours is that that Cond<A, B> is a delegate that you pass a value to and you get the result of the 'then' or 'else' parts of the expression returned.  One benefit of that is that you can pre-build the conditional computations, re-use them, compose them, etc.  So for example you could build a 'library of policies' to apply to values-of-a-type, or pass them as arguments to functions for inversion of control.\nHere's your example above.  But note I have broken out the 'then' and the 'else' part of the operation to make it a touch easier to read:\n```c#\nstatic async Task>> DownloadVehicles(HttpResponseMessage resp) =>\n    Right>(List().AddRange(JsonConvert.DeserializeObject>(await resp.Content.ReadAsStringAsync())));\nstatic Either> BadGatewayError = new Error();\nThis is the _stand-alone_ conditional computation.  It pre-builds the expression that results in a delegate that you can apply to any value of type `HttpResponseMessage`c#\nstatic readonly Func>>> DownloadIfValid =\n    Cond(y => y.StatusCode == HttpStatusCode.OK)\n        .Then(DownloadVehicles)\n        .Else(BadGatewayError);\nThis is it being used:c#\nprivate Task>> GetAllVehicles(RequiredString bearerToken) =>\n    $\"http://somereallycoolservice.com/api/vehicles\"\n        .WithHeader(\"Authorization\", bearerToken)\n        .WithHeader(\"Accept\", \"application/json\")\n        .AllowAnyHttpStatus()\n        .GetAsync()\n        .Apply(DownloadIfValid);\nThe `Apply` function facilitates the fluent application of the  `HttpResponseMessage` to the `DownloadIfValid` conditional computation.  You could just as easily do this:c#\nprivate Task>> GetAllVehicles(RequiredString bearerToken) =>\n    DownloadIfValid(\n        $\"http://somereallycoolservice.com/api/vehicles\"\n            .WithHeader(\"Authorization\", bearerToken)\n            .WithHeader(\"Accept\", \"application/json\")\n            .AllowAnyHttpStatus()\n            .GetAsync());\nHere's a much simpler example:c#\nvar cond = Cond(x => x == 4)\n               .Then(true)\n               .Else(false);\nThat can be run like so:c#\nbool result = cond(4); // True\nbool result = cond(0); // False\nOr,c#\nbool result = 4.Apply(cond); // True\nbool result = 0.Apply(cond); // False\nBecause of the compositional nature of the type, you can create many variants.  Even one that doesn't have a predicate:c#\n// This says the 'subject' of the operation is a string\nvar subj = Subj();  \n// To turn it into something that can be run you must close with Else\nvar cond = subj.Else(\"no value\"); \n// Run \nvar a = cond(null);  // \"no value\"\nvar b = cond(\"Hello, World\"); // \"Hello, World\"\nTo understand why that is, take a look at the implementation of `Cond` and `Subj`c#\npublic delegate Option Cond(A input);\npublic static Cond Cond(Func pred) =>\n    input =>\n        pred(input)\n            ? Optional(input)\n            : None;\npublic static Cond Subj() =>\n    input =>\n        Optional(input);\n``\nThe 'return type' forCondis anOption.  So even without a conditional predicate theCondoperation can fail (if it sees anull` value).\nIf I followed the example above with integers, then it's impossible for it to fail:\n```c#\nvar cond = Subj().Else(Int32.Max);  \nvar a = cond(0); // 0\nvar b = cond(1); // 1\n...\nOnce you have a 'subject' for testing, then you can use some of the more advanced operators:c#\nvar cond = Subj().Where(x => x >0 && x < 100)\n                      .Then(\"In range\")\n                      .Else(\"Out of range\");\nvar a = cond(0);   // \"Out of range\"\nvar b = cond(100); // \"Out of range\"\nvar c = cond(50);  // \"In range\"\nWhen you look at it like this, you may realise that `Then` is just `Select` or `Map`:c#\nvar cond = Subj().Where(x => x >0 && x < 100)\n                      .Select(\"In range\")\n                      .Else(\"Out of range\");\nAnd can be LINQified:c#\nvar cond = (from x in Subj()\n            where x > 0 && x < 100\n            select \"In range\").Else(\"Out of range\");\nvar a = cond(0);   // \"Out of range\"\nvar b = cond(100); // \"Out of range\"\nvar c = cond(50);  // \"In range\"\nAnother problem I found when looking at your original is I couldn't tell what would happen if I used multiple `Cond` clauses fluently chained.  I was unclear if the `returns` would apply if the first one passed and the second one didn't.  I felt this was unsatisfactory.  I think most people understand that a series of `where` clauses are the equivalent of And, so the behaviour from this is obvious (I hope!):c#\nvar cond = Subj().Where(x => x > 0)\n                      .Where(x => x < 100)\n                      .Then(\"In range\")\n                      .Else(\"Out of range\");\nBut to make it even easier I have added `All` and `Any` operators:c#\nvar cond = Subj().All(x => x > 0, x => x < 100)\n                      .Then(\"In range\")\n                      .Else(\"Out of range\");\n`All` takes an array of predicates, and all must be `true` for the `Then` computation to run.c#\nvar vowels = Subj().Map(Char.ToLower)\n                         .Any(x => x == 'a', x => x == 'e', x => x == 'i', x => x == 'o', x => x == 'u')\n                         .Then(\"Is a vowel\")\n                         .Else(\"Is a consonant\");\n``Anyreturnstrueif any of the predicates aretrue`.  This is Or behaviour.\nOne thing you may have noticed is that the Then and Else all take values.  They can also take delegates that are only invoked based on the state of the computation.  Also any operator that takes a delegate can also return a Task, this applies for Cond, Map, Select, Where, Filter, Any, All, Then, and Else.  This immediately changes the type of expression from Cond<A, B> to CondAsync<A, B>; and in the case of Else from Func<A, B> to Func<A, Task<B>>.  This allows for a synchronous computation to become asynchronous 'mid-expression'.  \nOnce the computation is asynchronous, you can't go back to being synchronous.  However synchronous operations can be done on the result of an asynchronous operation.  i.e.\n```c#\nTask GetIntegerValue(int x) => Task.FromResult(x);\nvar cond = Cond(async x => (await GetIntegerValue(x)) > 0).Then(x => 1).Else(x => 0);\nvar a = await cond(100);  // 1\nvar b = await cond(-100);  // 0\n``\nIn the above examples theThenandElse` operations are synchronous, but the predicate is asynchronous.  \nYou can use any combination of synchronous and asynchronous and it will 'just work'.  Here are some async tests from the unit-tests:\nc#\nvar cond1 = Cond<int>(x => T(x == 4)).Then(true).Else(false);\nvar cond2 = Subj<int>().Where(x => T(x == 4)).Then(true).Else(false);\nvar cond3 = Subj<int>().Any(x => T(x == 4), x => T(x > 4)).Then(true).Else(false);\nvar cond4 = Subj<int>().All(x => T(x > 0), x => T(x < 10)).Then(true).Else(false);\nvar cond5 = Subj<int>().Where(x => T(x == 4)).Then(true).Else(false);\nvar cond6 = Subj<int>().Any(x => T(x == 4), x => T(x > 4)).Then(_ => T(true)).Else(_ => false);\nvar cond7 = Subj<int>().Any(x => T(x == 4), x => T(x > 4)).Then(_ => T(true)).Else(_ => T(false));\nvar cond8 = Subj<int>().Any(x => T(x == 4), x => T(x > 4)).Then(T(true)).Else(false);\nvar cond9 = Subj<int>().Any(x => T(x == 4), x => T(x > 4)).Then(T(true)).Else(T(false));\nvar condA = Cond<int>(x => x == 4).Then(_ => T(true)).Else(false);\nvar condB = Cond<int>(x => x == 4).Then(true).Else(_ => T(false));\nvar condC = Cond<int>(x => x == 4).Then(_ => T(true)).Else(_ => false);\nT is defined as Task.FromResult for convenience:\nc#\nstatic Task<A> T<A>(A value) => \n    Task.FromResult(value);\nWhat's interesting here is that Any and All operators will run their predicates in parallel if they're all of type Task.\nI feel overall this is a stronger solution, which is more composable, causes less memory allocation, and has a more elegant API.  But because I don't use this day-in/day-out and it seems you have been, I'd be interested to know your views on this.  I have implemented it in a separate branch called conditional-type:\n\nCond.cs - the main Cond type and extensions\nCondAsync.cs - the async version of Cond\nUnit tests\n\nPlease let me know your thoughts.\n(after writing all this, I have a sneaky suspicion that I've just re-invented the continuation monad! - so perhaps a name-change is coming.  I've gotten a bit too close to it to judge). @ncthbrt @NickDarvey Thanks for the kind words :)\n@NickDarvey Not sure when I'll get this released at the moment.  I've just started the process of migrating from xproj/csproj/project.json to the new csproj format (in VS2017 RC).  And predictably auto-migration doesn't work, and there seems to be some problems with per-framework references (or the lack of them).  So it could be a while until I sort this out fully.\nThe two files Cond.cs and CondAsync.cs are standalone I think (other than you'll need lang-ext in your project for the Task monad and Option references); so if you're super-keen to get this, then I think that you could just copy the files to your project in the short-term and then remove them when released.\nGoing to close this pull request now.. @ncthbrt Hi Nick, thanks for raising this, I'm still pretty bogged down here, so can't look right now.  But the index should be zero-based like other collection types in .NET.  The code to do it is here if you fancy doing some debugging?\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/Lst.cs#L618\n. @Micha-kun Thanks for this, but it will be covered by the BiFunctor support in lang-ext 2.0 which is being worked on right now in the type-classes branch.  . Although I don't see huge value for a C# library, it's likely to have a low maintenance factor.  So yes, sure, go ahead.  Could you please make your changes from the type-classes branch.  Thanks.. Released in v2.0.31-beta. As with uncurry, it's likely to have limited use, but again it's low maintenance, so yes go ahead.  Again, could you make the changes in the type-classes branch. . I made some changes to your pull request.  The latest is now in v2.0.31-beta.. @leandromoh Hi Leandro, just to let you know that I haven't forgotten about your pull requests.  I have a ton of work to do to get the project stable again after moving to VS2017.  Once completed, I'll be reviewing your reqs.. @leandromoh  Hi Leandro, I have modified this.  In Haskell flip works on two arguments only.  There is a clear reason for that which is composition and application.  It's less important in C# as I mentioned in the original issue.  However I see a value in flipping the first and the last argument.  Especially if C# gets the forward pipe operator that is currently a proposal on Rosyln.  However beyond 3 arguments I think flipping the first and the last argument feels wrong.  So I have modified this to only work on:\n```c#\n    Func>           ---> Func>\n    Func>>  ---> Func>>\nFunc<A, B, R>                 ---> Func<B, A, R>\nFunc<A, B, C, R>              ---> Func<C, B, A, R>\n\n```\nThere's a nice symmetry with 2 or 3 arguments which doesn't exist with more.  \nYou can find it here. @leandromoh Hi Leandro.  I have manually added this to the master branch now.  Sorry for the delay, it's been a crazy period of refactoring and reorganising, and I thought I'd just do this, rather than make you update it.  I'll make sure to mention you in the v2 full release when it's done.  Thanks :). @Micha-kun They are separate nu-get packages already, so you don't need to include the LanguageExt.Process system to use the LanguageExt.Core.  So I disagree with your premise somewhat.  The main reason I kept them all in a single repo was convenience for me.  It allows me to simply press F6 to compile and be confident I haven't broken anything further down the chain.\nHowever!  I am actually in the process of splitting the repos and doing what you suggest.  The key reason is the new csproj/NET Standard builds take forever.  It's so annoying, something that compiles in a few seconds on the old build system, takes minutes on the new.  So to cut down the compile times I'm splitting the project.  I figured it would be a good time to split them into separate repos too, so I can have more focused documentation for the Process system.\nBut just to re-emphasise, the 'monad library' (it's much more than that btw, but I know what you mean) has a nu-get package: LanguageExt.Core  and the Process system has its own separate nuget package: LanguageExt.Process\nIn fact if you look at the README.md, you'll see (right at the top), links to all of the separate packages and what they do :)\nNu-get package | Description\n---------------|-------------\nLanguageExt.Core | All of the core types and functional 'prelude'.  This is all that's needed to get started.\nLanguageExt.FSharp | F# to C# interop library.  Provides interop between the LanguageExt.Core types (like Option, List and Map) to the F# equivalents, as well as interop between core BCL types and F#\nLanguageExt.Parsec | Port of the Haskell parsec library\nLanguageExt.Process | 'Erlang like' actor system for in-app messaging and massive concurrency\nLanguageExt.Process.Redis | Cluster support for the LanguageExt.Process system for cluster aware processes using Redis for queue and state persistence\nLanguageExt.Process.FSharp | F# API to the LanguageExt.Process system\nLanguageExt.ProcessJS | Javascript API to the LanguageExt.Process system.  Supports running of Processes in a client browser, with hooks for two-way UI binding.. @Micha-kun Good point!  I will rectify that.. @jonschoning This will probably be dealt with in V2 of lang-ext.  It will have full support for applicatives.\nhttps://github.com/louthy/language-ext/blob/type-classes/LanguageExt.Core/TypeClasses/Applicative/Applicative.Prelude.cs\nIt also won't need implementations for Either, Option, etc.  (although I probably would add them to remove the inconvenience of the generic parameters).. @jonschoning Yep, I had a version that used an Applicative interface, but unfortunately the solution isn't quite as elegant as Haskell (or the C# monad version).  So I dropped it.  It was a pragmatic decision due to this being an ad-hoc polymorphic solution rather than a type-class and class-instance solution; and therefore any call to apply or its variants can have an ad-hoc Bind and Return implementation and can therefore support both monadic and applicative behaviour.\nI may revisit this again at some point, the new API isn't fully locked down yet.. @StefanBertels Thanks for the heads up.  I'll look into it.  As a side note, HashSet doesn't get you any wins over Set in terms of performance.  So unless you're working with types that aren't comparable then it's worth switching.. @eggapauli Unfortunately Json.net struggles with the immutable types in lang-ext.  There's a couple of options depending on your urgency:\n\nCopy your object to a DTO type and make the types nullable\nWrite a JsonConverter as you mention\nWait for lang-ext v2.0 where I've Implemented ISerializable for all of the core types to deal with Json.NET not 'getting it' (this could be a month away at the moment, but I'm hoping it will be earlier)\n. @eggapauli \n\nFor value types: option.ToNullable()\nFor reference types: option.IfNoneUnsafe(null). I've have manually patched this on echo-process. The name HSet and HMap was really annoying me, it's ugly and compromised by a worse implementation (IMHO).  I didn't like the compromise that was inflicted by Visual Studio's default includes (when this library very often removes the need for the collections in System.Collections.Generic).\nThe simplest solution I've found for dealing with this is:\n\nRemove using System.Collections.Generic\nReplace with using G = System.Collections.Generic\n\nThen use the G prefix for types required from the System.Collections.Generic namespace:\n```c#\n        // System.Collections.Generic\n        G.HashSet a     = new G.HashSet();\n        G.IEnumerable b = Enumerable.Range(0, 100);\n        G.List c        = new G.List(new[] { 1, 2, 3 });\n    // LanguageExt\n    HashSet<int> d       = HashSet(1, 2, 3);\n    Lst<int> e           = List(1, 2, 3);\n\n``\n. > Do you plan to changeLsttoList`, too?\nNo.  I took the plunge with HSet and HMap because they were both very new types in the library, and were likely to be used much less (there is very little benefit to using them other than supporting unorderable keys).\nAlthough I'd prefer to use List<A> rather than Lst<A>, I did notice some conflicts in early versions (I can't remember exactly what the issue was now though!).  So I went for Lst<A> as it's likely to be more commonly used.  I also did the same with Stck<A> instead of Stack<A>, and Que<A> instead of Queue<A>.  (Que<A> sets off my spelling-OCD like you wouldn't believe!)\nThe one thing with all of those contracted names is this: it's still very clear what they are.  The problem with HMap and HSet is that it's unclear what the H means.  Obviously it doesn't take long to learn, but it's better if you can just look at the code and know what's going on.\nAnd with HashMap available, I figured it would be worth the pain to rename both HMap to HashMap and HSet to HashSet.  This is a decision based purely on the fact that I expect HashSet to be used less than Set, and that it's preferable to claim the HashMap name.\nI am always open to suggestions.  I am at the alpha stage with v2, so this is definitely the time to get the ideas to me :)\nThe only other ones I considered was HshMap and HshSet.  But they feel really awkward.  I'm always trying to strike the balance between functionality and elegance.  An elegant API is one that you will turn to over and over.. >  don't see a general difference between List, Stack, Queue and HashSet here.\nI don't remember exactly what the problem was tbh, I just remember there being an issue that made it more awkward than I'd have liked. But you're right that the issues should be the same for all types.\n\nOr do you think HashSet is much less important and conflicts there are (much) more acceptable?\n\nNot all breaking changes are equal.  Yes, version 2 is my opportunity to fix some legacy issues as well as bring in a raft of cool stuff (and I think people understand that major version changes might have breaking changes).  But I know that certain types will be used more than others.  Option, Lst, and Map probably get the heaviest 'hit' of any code in the library, so changing those is very problematic.  HashSet is just likely to be used less, and therefore I am less worried about naming clashes with the BCL.  But C# does have a way of dealing with naming clashes, and that's to namespace or alias.  I realise it's not pretty, but on this one type I will compromise because I think HashSet is the best name.\n\nThe compiler complains that Array is a method as found in Prelude (\"Cannot choose method from method group\"). \n\nI'd like to lobby the Roslyn team to sort this out - I think it's a bug.  It's impossible to dot into a method-group, so the compiler should know that Array.ConvertAll in this instance refers to the type or variable called Array.  It's also impossible to pass arguments to a type:  Array(1,2,3) is obviously calling a method.  I think it may have been missed when the Roslyn team implemented using static for C#6.\nThis is an issue in lang-ext now with the Map function in Prelude (for example).  If you do using LanguageExt.Predude then you can construct a map with Map((1,2),(3,4)).  But the Map static type can't be accessed: Map.create<int, int>().\nUnfortunately there are a few compromises, but I think overall the balance is about right at the moment.. @StefanBertels I hadn't planned, but I can offer a solution I'm sure.  What's the urgency on this?\nI think what I'd want to do is use the new Eq ad-hoc polymorphic types to support this (rather than using IComparer).\nThe problem with using immutable types is that you need to get comparer in at the start, i.e.:  HashSet<string>.Empty.  But obviously that's currently a readonly static property to remove the need for that initial allocation.  The other way would be to pass an Eq in via the constructors:\nc#\n    var set = HashSet(EqStringIgnoreCase.Inst, \"one\", \"two\", \"three\");\nThat works OK, but then you have a problem of type safety:\nc#\n    var setA = HashSet(EqString.Inst, \"one\", \"two\", \"three\");\n    var setB = HashSet(EqStringIgnoreCase.Inst, \"One\", \"Two\", \"Three\");\nBoth are sets of strings, but they behave differently.  The set functions: Union, Intersect, ==, etc. will all exhibit undefined behaviour.\nSo the real type-safe way to do this is to add the Eq to the generic arguments list:\nc#\n    public struct HashSet<EqA, A> : ...\n        where EqA : struct, Eq<A>\n    {\n        ...\n    }\nYou would declare like so:\nc#\n    var setA = HashSet<EqString, string>(\"one\", \"two\", \"three\");\n    var setB = HashSet<EqStringIgnoreCase, string>(\"One\", \"Two\", \"Three\");\nThey would be fundamentally different types, you couldn't intersect setA and setB.\nI'd probably have to provide \n HashSet<A>\n HashSet<EqA, A>\n Set<A>\n Set<OrdA, A>\n HashMap<K, A>\n HashMap<EqA, K, A>\n Map<K, A>\n Map<OrdA, K, A>\nI am happy to do all of this, and if you need it soon then I'll start this evening.  You will need to be using version 2.0 though.  . @StefanBertels This is now complete on v2.0.3-alpha.\n```c#\n    var set = HashSet(\"one\", \"two\", \"three\");\nAssert.True(set.Contains(\"one\"));\nAssert.True(set.Contains(\"ONE\"));\n\nAssert.True(set.Contains(\"two\"));\nAssert.True(set.Contains(\"Two\"));\n\nAssert.True(set.Contains(\"three\"));\nAssert.True(set.Contains(\"thREE\"));\n\n``\nAs mentioned above there are four new types:HashSet,Set,HashMap,Map`.  \nThe first argument should be the 'class instance'.  Which is a term stolen from Haskell.  Essentially it must be a struct that derives from a 'type class' (an interface in C#).  I know C# doesn't have type-classes and class-instances, but it's the easiest way to discuss this stuff (especially if you know a bit of Haskell already).\nThis is what the Eq type-class looks like:\n```c# \n    public interface Eq\n    {\n        /// \n        /// Equality test\n        /// \n        /// The left hand side of the equality operation\n        /// The right hand side of the equality operation\n        /// True if x and y are equal\n        bool Equals(A x, A y);\n    /// <summary>\n    /// Get the hash-code of the provided value\n    /// </summary>\n    /// <returns>Hash code of x</returns>\n    int GetHashCode(A x);\n}\n\nAnd this is the default string equality 'class instance':c#\n    public struct EqString : Eq\n    {\n        public static readonly EqString Inst = default(EqString);\n    /// <summary>\n    /// Equality test\n    /// </summary>\n    /// <param name=\"a\">The left hand side of the equality operation</param>\n    /// <param name=\"b\">The right hand side of the equality operation</param>\n    /// <returns>True if a and b are equal</returns>\n    public bool Equals(string a, string b) =>\n        a == b;\n\n    /// <summary>\n    /// Get hash code of the value\n    /// </summary>\n    /// <param name=\"x\">Value to get the hash code of</param>\n    /// <returns>The hash code of x</returns>\n    public int GetHashCode(string x) =>\n        x == null ? 0 : x.GetHashCode();\n}\n\nBecause `EqString` is a `struct` the methods on it can be called like so:c#\n    default(EqString).Equals(\"one\", \"two\");\nSo by passing an `Eq<A>`, or `Ord<A>` as an argument to `Set`, `HashSet`, `Map`, `HashMap` and constraining it to be a `struct`, I can inject the ordering an equality functionality, with zero run-time cost (the `default(EqA)` gets optimised out in release builds and becomes a direct call).c#\n    public struct Set :\n        where OrdA : struct, Ord\n        ...\n``\nTo your request forStringComparer.OrdinalIgnoreCase, I have added class-instances forOrdinalIgnoreCase,Ordinal,CurrentCultureIgnoreCase, andCurrentCulture`.\n```c#\n    public struct EqStringOrdinalIgnoreCase : Eq\n    {\n        public bool Equals(string a, string b) =>\n            StringComparer.OrdinalIgnoreCase.Equals(a, b);\n    public int GetHashCode(string x) =>\n        StringComparer.OrdinalIgnoreCase.GetHashCode(x);\n}\n\nOne thing to note is that the resulting type-name is a bit long:c#\n    Set set;\n    HashSet hashset;\n```\nThere's nothing stopping you implementing your own class instances though.  Maybe if you have it standardised app-wide:\n```c#\n    public struct EqStr : Eq\n    {\n        public bool Equals(string a, string b) =>\n            StringComparer.OrdinalIgnoreCase.Equals(a, b);\n    public int GetHashCode(string x) =>\n        StringComparer.OrdinalIgnoreCase.GetHashCode(x);\n}\n\nThen the type is a bit easier to manage (although much less declarative!)c#\n    HashSet hashset;\nOne important aspect (which I mentioned in my post above) is that if you use different class-instances for equality and ordering, then the resulting types won't be compatible.  This takes the type-safety to the next level.c#\n    var setA = HashSet(\"one\", \"two\", \"three\");\n    var setB = HashSet(\"one\", \"two\", \"three\");\n// These lines won't compile, because the types aren't compatible.\nvar x = setA == setB;        \nvar y = setA.Intersect(setB);\n\n``\n. @solvingJ isn't this an issue for the JSON.net repo? . Makes more sense now, yes :).  Unfortunately I don't want the additional dependency in theCoreproject (I've been turning myself inside out over the past few weeks trying to get the core types likeOption,Lst,Map`, etc. serialisable (by JSON.NET, which seems to struggle with the immutable structs) without Json.NET included.\nBy the way, you could use Try for your ParseJson implementation.\nc#\npublic static Try<dynamic> ParseJson(string inputMessage) => () =>\n    (dynamic)JObject.Parse(inputMessage);\nYou then get all the benefits of the Try API. \n. @solvingJ Oh, and finally, I'm not sure if you're aware of the JsonConvert.DeserializeObject<T>(...) method?  I'm assuming that you used JObject.Parse because you're getting JSON in an unknown schema.  But just in case you're not aware DeserializeObject<T> will return null if the string can't be deserialised.\nc#\npublic static Option<T> ParseJson<T>(string inputMessage) => \n    JsonConvert.DeserializeObject<T>(inputMessage);\nThen you can get a typed object back:\nc#\n    var x = ParseJson<MyObject>(json);. >  I read something about your efforts on Json.NET and know it must be hard.\nThe main issue with it is that it seems to be a moving target.  I have fixed the serialisation issues twice before and found out last night that it's not working again.  My most recent attempt that has subsequently stopped working was by implementing ISerializable, which is the proper way to serialise types (when a serialiser can't auto-resolve).  It's bizarre, because the Json.NET documentation explicitly says it will use the ISerializable interface if it exists (and it worked for a short period - the unit tests said so ;) ).  \nI realise Json.net has to perform some secret magic behind the scenes to make everything work (and my cases are a little unusual); but that also means it's a bit of a black box of uncertainty.  It could also be the moving target of .NET Core, and perhaps that's affecting Json.NET.  Whatever it is, it's frustrating - for me, and for people who rely on this library and it suddenly fails for no apparent reason.\nFor future reference for anyone that's reading this, I achieved the result I wanted by making everything derive from IEnumerable<T> and had to provide a constructor that takes an IEnumerable<T> which it uses to populate the types.  \n\nFor Option<T> and OptionUnsafe<T> it's either an empty IEnumerable<T> or has exactly one element.\nFor Either<L, R> and EitherUnsafe<L, R> I have created a DTO object called EitherData<L, R> and derived the types from IEnumerable<EitherData<L,R>>\nFor HashSet<T>, Set<T>, Que<T>, Stck<T> they're just regular enumerables\nFor Map<K, V> and HashMap<K, V> I had to change its derivation from IEnumerable<IMapItem<K, R>> to IEnumerable<(K Key, V Value)> because json.net couldn't handle an interface, and it also struggled with the concrete type MapItem<K, V> (which implemented ISerializable).  This is actually a nicer interface for when C#7 is officially live, but it does come with allocation costs.\n\nLuckily it mostly makes sense for all of these types to be IEnumerable, although the Either implementation isn't super-nice.  Still, I'd prefer it to work than not, and hopefully the implementation doesn't 'leak' too much.\n\nThanks again on the hard work you're doing for the library. \n\nMy pleasure.  I'm glad people are finding it useful!\n\nSomeday i hope to contribute.\n\nNo worries on that front.  But if you're ever considering it, then looking for parts of the API not covered by unit tests (and covering them) would be an easy way in.  The same for documentation.  I have a very limited amount of time, and I'll often prioritise features/bug-fixes over docs/tests.  Especially as writing functionally tends to lead to minimal errors.  But it definitely doesn't lead to zero errors!  So more coverage is always welcome.. @NickDarvey Hi Nick, I'm open to advice and pull requests if you can think of a good way of making this work.  I have to be honest that I haven't touched DataContract in a very long time, and even then it wasn't really in anger, so this isn't a specialist area for me.\nThe only requirements are:\n No additional dependencies if possible (outside of the BCL)\n No exposure of inner values, therefore making the types unsafe.\n* No breaking of serialisation with Json.NET, which I think is close to the de facto standard for .NET these days (especially with most people using this library).. > Would you be adverse to exposing Map's readonly value as a private settable like you do with MapItem's key and value?\nNot a massive fan of the idea.  Because obviously this will be for all types that we want to deserialise, and I like the power of readonly.  What did you have in mind?  Do you need additional constructors?\n\nAnd also, how the heck does JSON.Net figure get your Map structure out into an array? Does it automagically use the enumerator?\n\nYes, it does exactly that.  Which causes a few additional headaches.  But it's the only way I could find to bend Json.NET to my whim.  \n\nAs an aside, might it be better if Map serialized as a dictionary rather than an array? Would that be semantically better?\n\nI don't think that's really important.  The serialiser doesn't need to represent the inner workings of the type.   It merely needs a consistent way to get the data in and out.. @StefanBertels  They already do serialise:\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Tests/NewTypeTests.cs#L140. @StefanBertels Hi Stefan, yeah sorry, some Pure attributes were missing from the newer types.  Get the latest and it should be resolved for you.. @StefanBertels Hi Stefan, I'm breaking the Process system out to its own repo (as well as getting it to work with NET Core).  So for the moment the only way to use the Process system is with 1.9.  I'm just looking into it now, I'll see if I can get an alpha release up quicker.. @StefanBertels The Process system has now been broken out to github.com/louthy/echo-process.  It's had very limited testing, so I wouldn't advise using it for anything that will need to be in production within the next month or so.. @emiguelt FlatMap is also known as Bind, and that's what it's called in language-ext:\nc#\n    getType().Bind(getInstance);\nYou can also use LINQ:\nc#\n    from t in getType()\n    from r in getInstance(t)\n    select r;. There was a bug in the HashSet implementation of TrySetItem.  Please get the latest nuget package.\nSetItem is in line with other .NET collection types, in that it will try to set the item (which must already exist).  If the item is missing it throws an exception\nTrySetItem attempts to set the item (which must already exist), and if it succeeds will return the new collection, otherwise returns this.\nAdd will add a new item.  If it already exists, will throw an exception.\nTryAdd will add a new item if one doesn't already exist.  Otherwise returns this.\nAddOrUpdate will add a new item if it's missing, otherwise it will SetItem.\nThe naming is consistent with other .NET types, so I don't think they're misleading ... well, no more so than the rest of the types.  But it's easier to learn one set of poorly named names, than many.  They do all have slightly different semantics.  So I don't necessarily think a single Update is good enough.\n. @NickDarvey Funnily enough I was thinking the other day about how successful the CondAsync and Cond pairing is.  The asynchronous aspects of it are transparent, and it would be great to have OptionAsync, TryAsync, etc.  \nIt's certainly not free though - in terms of implementation time and long term maintenance.  But it's certainly a better approach than current extensions Task<Try<A>>, Try<Task<A>>\nDo you have a specific repro I could look at? . @NickDarvey Hi Nick, I have a solution.  So currently Try<A> has a few MatchAsync methods that allow you to do various combinations of asynchronous calls.  There are extensions for Task<Try<A>> and variants that allow the Succ and Fail branches to return Task<B>.  That's obviously the minimal behaviour you'd want to get a value out of a Try asynchronously.\nThe ideal solution would be:\n\nEvery Try operation has an Async variant\nA TryAsync<A> which provides asynchronous behaviour by default\nExtensions to Task<Try<A>> that make it work exactly like TryAsync<A>\n\nSo that's what I've done, and is available as v2.0.19-alpha on nuget now.\nFor example:\n```c#\n        // Some example method prototypes\n        public TryAsync LongRunningAsyncTaskOp() => TryAsync(10);\n        public Task> LongRunningAsyncOp()    => Task.FromResult(Try(10));\n        public Try LongRunningOp()               => () => 10;\n        public Task MapToTask(int x)             => Task.FromResult(x * 2);\n        public int MapTo(int x)                       => x * 2;\n    public async void Test()\n    {\n        // These run synchronously\n        int a = LongRunningOp().IfFail(0);\n        Try<int> b = LongRunningOp().Map(MapTo);\n\n        // These run asynchronously\n        int u = await LongRunningAsyncTaskOp().IfFail(0);\n        int v = await LongRunningAsyncOp().IfFail(0);\n        int x = await LongRunningOp().IfFailAsync(0);\n        TryAsync<int> y1 = LongRunningOp().MapAsync(MapTo);\n        TryAsync<int> y2 = LongRunningOp().MapAsync(MapToTask);\n        int z1 = await y1.IfFail(0);\n        int z2 = await y2.IfFail(0);\n    }\n\n``\nAs much as possible I've tried to make the step fromTrytoTryAsynctransparent.  So if you return aTaskin theMapfunction of aTry, then it gets 'upgraded' to aTryAsync.  This is similar behaviour to theCond` type.\nAlso where tasks can run in parallel they will.  So for example, if you use the new applicatives:\n```c#\n        TryAsync GetValueOne() => TryAsync(2);\n        TryAsync GetValueTwo() => TryAsync(() => 10);\n    public async void ApplicativeTest()\n    {\n        var op = apply(\n            TryAsync<Func<int, int, int>>((x, y) => x + y),\n            GetValueOne(),\n            GetValueTwo()\n        );\n\n        var res = await op.IfFail(0);\n        Assert.True(res == 12);\n    }\n\n``\nObviously that's a basic example, butGetValueOneandGetValueTwo` will run in parallel, check failure states automatically, and then use the applicative functor to combine the values.  You could imagine the two functions doing something heavyweight that returned lists of results, which are then reduced.  And for the avoidance of doubt the 'reduction' would be asynchronous too.\nOne final point is that you can make a Try<A> into a TryAsync<A> at any point by calling:\nc#\n     TryAsync<A> x = tryValue.ToAsync();\nAnd you can convert a Task<Try<A>> or a Try<Task<A>> to a TryAsync<A> by:\nc#\n     TryAsync<A> x = tryTask.ToTryAsync();\nAgain it will deal with all of the possible failures.  \nI think that should cover all possible combinations of Try and Task and provide convenience functions for when the type isn't in the state you want.  I still need to do this for TryOption (it's a lot of typing!), I'll try to get to that within the next week or so.\nYou will need to be on version 2, which although is alpha, is stable.  But if you're using the Process system then you should probably hold off until I've done some more testing.. @NickDarvey v2.0.20-alpha is up with TryOptionAsync, and all the same extensions as listed above for Try.  \nA couple of things to note:\n\nToTryAsync has been renamed to ToAsync\nTryOption.IfNone(...) (which actually handled None and Fail states), has now been renamed to IfNoneOrFail.  the naming was confusing I think, so it's explicit now.  Obviously that will be a breaking change if you use TryOption at all.\n\nHere's the same version of the examples above for TryAsync and TryOptionAsync.  \n```c#\nclass TryAsyncExamples\n{ \n    // Some example method prototypes\n    public TryAsync LongRunningAsyncTaskOp() => TryAsync(10);\n    public Task> LongRunningAsyncOp()    => Task.FromResult(Try(10));\n    public Try LongRunningOp()               => Try(10);\n    public Task MapToTask(int x)             => Task.FromResult(x * 2);\n    public int MapTo(int x)                       => x * 2;\npublic async void Test()\n{\n    TryAsync<int> j = LongRunningOp().ToAsync();\n    TryAsync<int> k = LongRunningAsyncOp().ToAsync();\n\n    // These run synchronously\n    int a = LongRunningOp().IfFail(0);\n    Try<int> b = LongRunningOp().Map(MapTo);\n\n    // These run asynchronously\n    int u = await LongRunningAsyncTaskOp().IfFail(0);\n    int v = await LongRunningAsyncOp().IfFail(0);\n    int x = await LongRunningOp().IfFailAsync(0);\n    TryAsync<int> y1 = LongRunningOp().MapAsync(MapTo);\n    TryAsync<int> y2 = LongRunningOp().MapAsync(MapToTask);\n    int z1 = await y1.IfFail(0);\n    int z2 = await y2.IfFail(0);\n}\n\n}\nclass TryOptionAsyncExamples\n{\n    // Some example method prototypes\n    public TryOptionAsync LongRunningAsyncTaskOp() => TryOptionAsync(10);\n    public Task> LongRunningAsyncOp()    => Task.FromResult(TryOption(10));\n    public TryOption LongRunningOp()               => TryOption(10);\n    public Task MapToTask(int x)                   => Task.FromResult(x * 2);\n    public int MapTo(int x)                             => x * 2;\npublic async void Test()\n{\n    TryOptionAsync<int> j = LongRunningOp().ToAsync();\n    TryOptionAsync<int> k = LongRunningAsyncOp().ToAsync();\n\n    // These run synchronously\n    int a = LongRunningOp().IfNoneOrFail(0);\n    TryOption<int> b = LongRunningOp().Map(MapTo);\n\n    // These run asynchronously\n    int u = await LongRunningAsyncTaskOp().IfNoneOrFail(0);\n    int v = await LongRunningAsyncOp().IfNoneOrFail(0);\n    int x = await LongRunningOp().IfNoneOrFailAsync(0);\n    TryOptionAsync<int> y1 = LongRunningOp().MapAsync(MapTo);\n    TryOptionAsync<int> y2 = LongRunningOp().MapAsync(MapToTask);\n    int z1 = await y1.IfNoneOrFail(0);\n    int z2 = await y2.IfNoneOrFail(0);\n}\n\n}\n``\nPlease let me know how you get on, and if you have any problems.  I rarely useTaskmyself (because I use the lang-ext Process system).. They're both just convenience methods for different scenarios.  The first one is to make it easy to drop into a function that expects a Action delegate.  Like the side-effecting version ofMatchonOption`.  \nThe second one was added to the library because throw in C# isn't an expression.  But from C#7 they will be. . Unfortunately it isn't possible without compromising the types.  Json.NET doesn't play nice with the lang-ext types, and I've been through 3 or 4 different strategies to try and make it work (some worked until JSON.NET changed and broke it again).  So it has to be the way it is I'm afraid.  \nIt does have some benefits in that the data can then be consumed by a list type rather than a map.  . @StefanBertels That would be a bad idea.  Option doesn't own the T, it is given to the constructor.  And therefore it can't be responsible for its lifetime.  ~~Also because Option is a struct, it gets instantiated and finalised all the time, so it's difficult to know whos~~  (Ignore that second sentence, I have was having a brain freeze!  The first sentence still stands though). @StefanBertels Hi Stefan, sure let me think about it.  I suspect that this probably makes sense:\nc#\n    using(var x = Some(disposableThing))\n    {\n      ...\n    }\nI'm midway through some other changes, so I'll let it settle for the moment and revisit this when it's done.. > My reasoning for why mostly comes from Mark Seemann, an expert in dependency injection and author of Dependency Injection in .NET.\nBe aware, the whole dependency injection framework thing is something that starts me twitching like Chief Inspector Dreyfus from the Pink Panther.  I wouldn't take the advice of a proponent of it based on that primary credential.  Dependency injection frameworks need to be thrown on a fire in my opinion.  DI can be done properly using higher-order functions, actors, and free-monads.  The frameworks are just another example of how the OO world just keeps digging bigger holes for itself.\n</rant>\nI prefer to approach these kinds of questions from a pragmatic point-of-view because this is exactly one of those subjects that the OO world has probably gotten wrong.  The concept of ownership is tentative at best.  If there was truly such an ownership scheme then the disposal would be entirely handled by the IDisposable type - or via some formal ownership concept.  But that isn't the case, something else has to call obj.Dispose() - and there is no formal relationship between the disposable type and any other concept in the language (bar the using statement).  Ultimately, it's the developer that decides when to dispose, either through calling Dispose or wrapping the instantiation with a using.  In my opinion, the 'owner' is the programmer, not some mystical object graph.  \nSo, if we depart with the OO dogma for a second, and start to look at what's actually valuable then I think we'd get to a better solution for all.\nLet's stick with the Option type for now and whether it should be disposable or not...\nOption is not like StreamReader and Stream, Option is very much a value.  Or, to be more precise it's either a value  - Some(x) - or not a value  - None.  The only other precedent for that in the BCL is Nullable, which isn't IDisposable.  So that's one strike against Option being IDisposable.\nIf we consider Option to be invisible and just consider the absence or presence of the value, then it makes perfect sense to call Dispose() on the value (when it's there).  Option could be seen as a totally transparent proxy to the value.  This feels reasonable.\nIf we then take the thought experiment further, what does the code look like if we have a non-disposable Option, but we need to dispose of the bound value.\n```c#\nstatic Option OpenStream(StreamDesc desc) =>  ...;\nstatic Unit Test(StreamDesc desc)\n{\n    var stream = OpenStream(desc);\ntry\n{\n    return UseStream(stream);\n}\nfinally\n{\n    stream.Iter(s => s.Dispose());\n}\n\n}\n```\nThis looks and feels pretty bad.  It's all statement based and can't lend itself to being an expression at all.\nIt could be made slightly less bad by providing an extension method for disposing:\nc#\npublic static Unit Dispose<A>(this Option<A> ma) where A : IDisposable =>\n    ma.Iter(x => x.Dispose());\nIt's improved, but still not pretty:\n```c#\nstatic Unit Test(StreamDesc desc)\n{\n    var stream = OpenStream(desc);\ntry\n{\n    return UseStream(stream);\n}\nfinally\n{\n    stream.Dispose();\n}\n\n}\nNow let's imagine `Option` is disposable and try it with the `using` statement:c#\nstatic Unit Test(StreamDesc desc)\n{\n    using(var stream = OpenStream(desc))\n    {\n        return UseStream(stream);\n    }\n}\nThis is already significantly better.  But it should also work with the `use` function of lang-ext:c#\nstatic Unit Test(StreamDesc desc) =>\n    use(OpenStream(desc), UseStream);\n```\nSuddenly we're in concise functional expression land.  This makes me happy.\nIf we go further an consider Either then that feels right like Option too, because it's still a value.  Or to be more precise either one value - Left(x) or another value - Right(y).\nWhat about collections.  Why shouldn't I be able to dispose all items in a list?  If we agree that nobody really owns the items and it's the programmer that ultimately makes the decision.  Surely we can give the programmer the most efficient disposable mechanism going - so they don't have to repeat the same code over and over?\nWe start to run into problems when we encounter Try, TryOption, etc. that are delegates.  But lang-ext already provides overloads for use that work with Try (which needs expanding to the other delegate types btw).  So, we have precedent too.\nI have pretty much talked myself into it by writing this message.  But I'm open to other opinions.\nPlease let's not turn this into a dependency injection discussion ;). @feugen24 \n\nI saw there is a TryOptionAsync but no OptionAsync.\n\nUntil yesterday Option was strict only, and only stored a value, so running it asynchronously didn't make sense.  It is now possible to write: Some(_ => ....) as well as Some(value) which creates a lazy Option in the same way Try and TryOption are lazy (because they're delegates).  \nHowever there are extensions for dealing with Option<Task<A>> or Task<Option<A>>, but it doesn't quite cover the whole Option API.  Below are the list of async variants.  What you could have done (because IfSome is the same as Iter) is call IterAsync.\n```c#\n    Task MatchAsync(this Option ma, Func> Some, Func None)\n    Task MatchAsync(this Option ma, Func> Some, Func> None)\nTask<Option<B>> MapAsync<A, B>(this Task<Option<A>> self, Func<A, Task<B>> map)\nTask<Option<B>> MapAsync<A, B>(this Option<Task<A>> self, Func<A, Task<B>> map)\nTask<Option<B>> MapAsync<A, B>(this Task<Option<A>> self, Func<A, B> map)\nTask<Option<B>> MapAsync<A, B>(this Option<Task<A>> self, Func<A, B> map)\n\nTask<Option<B>> BindAsync<A, B>(this Option<A> self, Func<A, Task<Option<B>>> bind)\nTask<Option<B>> BindAsync<A, B>(this Task<Option<A>> self, Func<A, Task<Option<B>>> bind)\nTask<Option<B>> BindAsync<A, B>(this Task<Option<A>> self, Func<A, Option<B>> bind)\nTask<Option<B>> BindAsync<A, B>(this Option<Task<A>> self, Func<A, Option<B>> bind)\nTask<Option<B>> BindAsync<A, B>(this Option<Task<A>> self, Func<A, Task<Option<B>>> bind)\n\nTask<Unit> IterAsync<A>(this Task<Option<A>> self, Action<A> Some)\nTask<Unit> IterAsync<A>(this Option<Task<A>> self, Action<A> Some)\n\nTask<int> CountAsync<A>(this Task<Option<A>> self)\n\nTask<S> FoldAsync<A, S>(this Task<Option<A>> self, S state, Func<S, A, S> folder)\nTask<S> FoldAsync<A, S>(this Option<Task<A>> self, S state, Func<S, A, S> folder)\n\nTask<bool> ForAllAsync<A>(this Task<Option<A>> self, Func<A, bool> pred)\nTask<bool> ForAllAsync<A>(this Option<Task<A>> self, Func<A, bool> pred)\n\nTask<bool> ExistsAsync<A>(this Task<Option<A>> self, Func<A, bool> pred)\nTask<bool> ExistsAsync<A>(this Option<Task<A>> self, Func<A, bool> pred)\n\n```\n\nDoes this look ok?\nAlso, are the following equivalent?\n\nYes it looks OK, and they are equivalent. (apart from one returns a value and the other it untyped).  \nI will get to the Option API soon and give it the same async coverage at Try and TryOption, but if there's anything you'd like to see in there sooner, please let me know.. @feugen24 \nv2.0.40 on nu-get now has an OptionAsync<A> type.\nFrom the example in your question you just need to call ToAsync() on the Option, which converts it to an OptionAsync:\nc#\n      Option<int> opt = 4;\n      Unit _ = await opt.ToAsync().IfSome(i => DoWork());\nThe full Option API is available for OptionAsync, so you can do any operation asynchronously.  There are also multiple variants for dealing with delegates that may or may not return a Task (for example Map(Func<A, B>) and Map(Func<A, Task<B>>)\nYou can also construct OptionAsync directly:\n```c#\n        var ma = SomeAsync( => 10);\n        var mb = SomeAsync( => 20);\n    var mr = from a in ma\n             from b in mb\n             select a + b;\n\n    Assert.True(await mr.IfNone(0) == 10);\n\n```\nEventually I will put Async suffixed variants to the Option type (so you won't need to call ToAsync), but this turned out to be a bigger change than I expected and I've run out of time to do much more.\n. > Not sure what to say about OptionAsync, typically developers are used with .CallThisAsync() like most .net libraries, so .IfSomeAsync looks better than .ToAsync().IfSome().\nRead my last sentence. . > Tasks:2 is RanToCompletion\n\nTasks:7 is WaitingForActivation\n\n@feugen24 This issue has been fixed.  Because ifSome needs to return unit, I needed to transform Func<A, Task> into Task<Unit>.  See below:\nc#\npublic static Task<Unit> ifSomeAsync<OPT, OA, A>(OA opt, Func<A, Task> f)\n    where OPT : struct, OptionalAsync<OA, A> =>\n    default(OPT).MatchAsync(opt, a => Task.Run(() => { f(a); return unit; }) , noneIgnoreF);\nBasically the invocation of the inner f(a) wasn't being awaited, and so was returning immediately.  It now looks like this and does as you'd expect. \nc#\npublic static Task<Unit> ifSomeAsync<OPT, OA, A>(OA opt, Func<A, Task> f)\n    where OPT : struct, OptionalAsync<OA, A> =>\n    default(OPT).MatchAsync(opt, a => Task.Run(async () => { await f(a); return unit; }) , noneIgnoreF);\nI've made a few other minor fixes.  . v2.0.42\nI've now added *Async extensions for Option and Task<Option> which promotes the type to an OptionAsync. \ne.g.\n```c#\n        // Option -> OptionAsync\n    var mc = Some(10).MatchAsync(\n        Some: x => Task.FromResult(x * 10),\n        None: () => 0);\n\n    Assert.True(await mc == 100);\n\n    Option<int> opt = 4;\n    Unit _ = await opt.IfSomeAsync(i => DoWork());\n\n    // Task<Option> -> OptionAsync\n\n    var mc = Task.FromResult(Some(10)).MatchAsync(\n        Some: x => Task.FromResult(x * 10),\n        None: () => 0\n    );\n\n    Assert.True(await mc == 100);\n\n```\n\n\nOption extensions\n\n\nTask<Option> extensions\n\n\n. @feugen24 \nYou're right.  Had a bit of a brain freeze there.  Found a couple of others too, so fixed them as well.\nNew version on nu-get v2.0.44. @melston Hi Mark,  I haven't fully read through all of this yet.  But if you're mixing types then you will have a bad time, Bind explicitly works by binding with other monads of the same type.  So Either<L, R> will not work with Task<Either<L, R>>.  Also if you want to Bind nested monads (Task<Either<L, R>>) you will most probably want to use BindT which is the transformer version of Bind and will dive into the doubly nested type to extract the R value in Task<Either<L, R>>.\nSo if you want to make Either<L, R> work with Task<Either<L, R>> you should lift the Either<L, R> with either.AsTask(), or you must unwrap the Either<L, R> within the Task<Either<L, R>>.\nFinally, what version are you using? . @melston So I have created a test in the unit tests with the following, and it all resolves as you'd like (assuming you're using the v2):\n```c#\n    public Task> Issue207() =>\n        Initialization\n            .BindT(createUserMapping)\n            .BindT(addUser);\nstatic Task<Either<Exception, ADUser>> Initialization =>\n    Right<Exception, ADUser>(ADUser.New(\"test user\")).AsTask();\n\nstatic Either<Exception, UserMapping> createUserMapping(ADUser user) =>\n    Right<Exception, UserMapping>(UserMapping.New(user.ToString() + \" mapped\"));\n\nstatic Task<Either<Exception, int>> addUser(UserMapping user) =>\n    Right<Exception, int>(user.ToString().Length).AsTask();\n\n```\nIt's rather attractive I think :). The reason why this works is because there are two BindT extension methods for every nested monad permutation.  And so for Task<Either<L, R>> theres:\nc#\npublic static Task<Either<L, B>> BindT<L, A, B>(this Task<Either<L, A>> ma, Func<A, Either<L, B>> f) =>\n    Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>\n        .Inst.Bind<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f); \nAnd:\nc#\npublic static Task<Either<L, B>> BindT<L, A, B>(this Task<Either<L, A>> ma, Func<A, Task<Either<L, B>>> f) =>\n    Trans<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>\n        .Inst.Bind<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);\nIt may not be obvious from that, but if you look at the second argument f for each, they're Func<A, Either<L, B>> and Func<A, Task<Either<L, B>>>.  So the first one allows you to work exclusively within the inner monad (Either<L, B>), the second one allows you to return the outer monad (Task<Either<L, B>>).  And so if you want to work in the context of Task<Either<L, B>> then BindT gives you the maximum flexibility.\nBtw, there's also MapT, FoldT, FoldBackT, ExistsT, ForAllT, IterT, FilterT, PlusT, SubtractT, ProductT, DivideT, AppendT, CompareT, EqualsT, ApplyT, SumT, CountT, Traverse, and Sequence.  \nAll of which allow you to work directly with the bound value of nested monads.\nIncidentally, if you were using LINQ to do this, you'd have to explicitly lift the result of createUserMapping with AsTask:\nc#\n        public Task<Either<Exception, int>> Issue207_2() =>\n            from us in Initialization\n            from mu in createUserMapping(us).AsTask()\n            from id in addUser(mu)\n            select id;\nThe reason for this is that, unlike BindT, SelectMany only has a single extension and expects the lifted type of Task<Either<L, R>> at each stage.  . @melston  What version of lang-ext are you running?. @melston  Ok, I can't really support that version.  I would definitely recommend upgrading.  Even though it's beta officially, it's stable (I am mostly updating documentation before I do the release proper, which will be in the next few weeks).  There were some issues with the transformer types (in v1) which have been resolved with v2, so it's your best course of action.\nPlease be aware that there may be some breaking changes if you're heavily using the library.\nhttps://github.com/louthy/language-ext/releases/tag/2.0.26-beta. @melston  Yep, v1 doesn't have the dual BindT implementations.  It's a much more feature rich anyway, so it's worth doing it sooner rather than later.  It looks like you're doing a lot of async work and there's 3 new types explicitly to help there (OptionAsync, TryAsync, and TryOptionAsync).  If I find the time soon I'll also be adding EitherAsync.\nYou could probably still do this on v1 (this is from memory, rather than guaranteed!):\nc#\n    public Task<Either<Exception, int>> Issue207() =>\n        Initialization\n            .BindT(u => createUserMapping(u).AsTask())\n            .BindT(addUser);. @trbngr Not sure why you've posted this twice.  But the answer is the same:\nThe reason it reports a BottomException in those examples is because it's doing a trasnformer bind operation, which is a generalised system for monadic binding on two nested monads (in this case Task<Either<L, R>>).  When the inner monad bind fails (which it will do because of the initial Left state), then so does the outer bind operation.  The outer monad (Task<...>) isn't aware of the Left type being Exception so all it can do is fail with BottomException because the Task is now in a failed state. \nSo essentially you're getting a general failure response from the Task not the Either.. @trbngr You may want to use Try<A> and TryAsync<A> it captures exceptions and removes the need for nesting monads.  You can create methods that return Try<A> and easily make them asynchronous by calling ToAsync() or calling any of the Async variant functions like MatchAsync, MapAsync, etc.\n```c#\n    static Try addUser2(UserMapping user) => () =>\n        user.ToString().Length;\nstatic Try<UserMapping> createUserMapping2(ADUser user) => () =>\n    UserMapping.New(user.ToString() + \" mapped\");\n\npublic TryAsync<int> Issue207_5() =>\n    from us in TryAsync<ADUser>(() => throw new Exception(\"fail\"))\n    from mu in createUserMapping2(us).ToAsync()\n    from id in addUser2(mu).ToAsync()\n    select id;\n\npublic async Task<int> Test2()\n{\n    return await Issue207_5().Match(\n        Succ: value => value,\n        Fail: excep => 0);\n}\n\nYou can use the various conversion functions if you want to use it with `Either` in other places:c#\n    Issue207_5().ToEither();    // Task>\n``. @trbngr No problem.  You can definitely think ofTryas a friendlierEitherandTryAsyncas a friendlierTask>`.  \nThere's also TryOption<A> which is basically: Either<Exception, Option<A>> and TryOptionAsync<A> which is Task<Either<Exception, Option<A>>>\n. Fixed, thanks. @Skoucail You may want to start with a book, I can recommend Functional Programming in C#; I've been a technical proofer on that book and would recommend it highly.  There's a lot of cross-over to what I have built here.\nThe key thing with functional programming in C# is being strict with yourself, as it's easy to fall into the OO habits.  Primarily it's about:\n\nExpression oriented programming - making everything you do an expression, rather than a sequence of statements (you can always tell if you've got an expression because the first thing in a method is return, or you're using the expression-bodied methods that don't have braces and start with =>)\nGet the OO notion of functionality and data being attached out of your mind.  Create immutable types (see my StackOverflow answer here for info); they act like 'record types' or 'data types' in other functional languages.  And then create static classes that work with the data-types.  \nWrite pure methods.  Pure methods are referentially transparent.  They don't refer to any global state, and work solely with the values provided to the method.  Combined with immutable types it allows you to consider the result of a pure method to be exactly like a value, because every time you provide the same inputs you get the same output.\nTry to avoid throwing exceptions.  Exceptions are like a goto, and do not fit the expression oriented mentality.  Instead return Option<A> to indicate success or failure, or Either<L, R> where L is the error value and R is the success value.\nFor the occasions where you're using code that might throw an exception, use Try<A>.  It will catch the exception and allow you to match or map on the result.\nLearn what functors, applicatives, and monads are.  They're scary terms, but so is 'polymorphism' when you first start OO.  Functors are types with a Map function (also known as Select in LINQ).  They allow you to 'stay in context' with some of the core functional types like Option<A>, Either<L, R>, Try<A>, etc.\n\nFor example, let's say you have a function that can return an optional result (so instead of throwing an error, you return None):\nc#\n    Option<string> GetValue(bool hasValue) =>\n        hasValue\n            ? Some(\"Skoucail\")\n            : None;\nOption<A> doesn't allow you to get at the inner value of the type without matching:\nc#\n    string value = GetValue(true).Match(\n        Some: name => $\"Hello, {name}\",\n        None: () => \"Goodbye\"\n    );\nNow doing that all the time you want to work with optional values is pretty annoying.  And this is where functors and monads come in.  So with functors you can stay in the optional context by mapping:\nc#\n    Option<string> value = GetValue(true).Map(name => $\"Hello, {name}\");\nSo instead of jumping back out to the string, you stay in the Option<string> context.  You can maintain this for as long as necessary by doing subsequent calls to Map.  The key thing is that the lambda inside the Map won't be invoked if the Option is in a None state.  So Option is a replacement for if statements, and reduces the cyclomatic complexity of your code.\nMonads are classically a difficult subject for people coming at OO.  But don't worry too much about their name, just know that most of the types in language-ext are monads.  Monads have two requirements: \n\nTo have a constructor function\nTo have a bind function\n\nThe constructor function just makes a new monad of whatever type.  The Some(x) and None functions above construct the Option monad.  Usually in functional programming it's called Return which adds to the confusion, but don't worry about that for now.\nThe Bind function is almost exactly the same as the Map function.  Except where Map takes a Func<A, B> to map an A to a B;  Bind takes a Func<A, M<B>>, where M is the monad type.  So for Option its Func<A, Option<B>>.  So in other words you're mapping an A to a monad of B.  This allows you to chain multiple functions together that all return Option for example:\n```c#\n    Option GetFirstName() => \n        Some(\"Joe\");\nOption<string> MakeFullName(string firstName) => \n    Some($\"{firstName} Bloggs\");\n\nOption<string> name = GetFirstName().Bind(MakeFullName);\n\n``\nSo of course if eitherGetFirstName()orMakeFullName()returnedNonethennamewould beNone`.  \nAgain that starts to get a bit unwieldy, but C# has syntax for monadic types: LINQ:\n```c#\n    Option GetFirstName() => \n        Some(\"Joe\");\nOption<string> GetLastName() => \n    Some(\"Bloggs\");\n\nvar name = from first in GetFirstName()\n           from last in GetLastName()\n           select $\"{first} {last}\";\n\n``\nWhenever you see afrom x in y, you should always think thatyis a monad, and thatxis the value _inside_ the monad.IEnumerable` is a monad as well.\nWhy is this better?  Well, it avoids you writing the same shit over and over:\nc#\n    var name = \"\";\n    var firstName = GetFirstName();\n    if(firstName != null)\n    {\n        var lastName = GetLastName();\n        if(lastName != null)\n        {\n            name = $\"{first} {last}\";\n        }\n    }\nSo Option removes the need to write if statements, so does Either but gives you an alternative value for when it fails (else).  Try avoids the need to write try/catch statements.  TryOption is a combination of returning an optional result and catches exceptions, etc.\nThe collection types in lang-ext are all immutable types, which are much more robust than mutable ones, and are easier to use when writing pure functions.  Lst<A> is a List<A> replacement, Set<A> and HashSet<A> replace the BCL HashSet<A>, Map<A, B> andHashMap<A, B> replace SortedDictionary<A, B> and Dictionary<A, B>; Seq<A> is a better IEnumerable which doesn't suffer from multiple evaluation traps, etc.\nSumming up\nThe best thing to do is start working with expressions more, start using Option more, get friendly with the ternary operator for conditional expressions (a ? \"true\" : \"false\" instead of if(a) ...);  it will take time to all sink in, and may seem bat shit crazy at times, but take it from me as a reformed OO guy, that it will be worth it, and you'll wonder why you ever wrote OO in the first place.  You'll have several 'aha' moments, but it can take a few years to really master it, although there's tons more resource around now compared to when I started it.  Most of the functionality in this library are here to help you to compose expressions, that is the absolute key to all of this: to make your code act like a mathematical formula - which gives you super powers as a programmer when it comes to reasoning about it (and from stopping it code-rotting over time).\nYou may want to have a look at the unit tests for examples, although they're not particularly presented in a style that's useful for tutorials.. @Skoucail Good luck!  I guess one final point, and I know it's kinda obvious, but it's all about functions.  Functions are the unit of currency, whether they're pure static functions or first class functions (Func<...>) that you pass around.  Dependency Injection for example is terrible in OO land, yet in functional land it's just done with Func and is the core idea behind the paradigm.  Even the high-abstraction stuff like monads, applicatives, and functors are all just about function composition.  \n@jeremysmith1 That's great to hear :). @solvingJ No fundamental reason. It just didn't occur to me.  I'm just packing for my vacation, so feel free to submit a pull request and I'll review as soon as I can.\n. @jeremysmith1 Thanks Jeremy!. @NickDarvey  Map (the type) isn't currently supported in the transformer system.  So Map<K, InnerMonad<A>> and OuterMonad<Map<K, A>>.  The reason for this is that it can't support Bind and therefore can't be a monad.  The old system had dummy functions in there for Bind (and SelectMany) which threw exceptions.  The new system uses the Trans type which requires that the inner and outer types are monadic (using the new type-class system, which enforces constraints which the old system didn't).  \nUnfortunately because the transformer system is an all or nothing affair at the moment, I can't selectively pick which functions each type implements (this will be improved), and so Map isn't part of the generated Trans extension methods.  \nBut because they are all just extension methods, so you can add your own trivially:\nc#\n    public static Option<Map<K, B>> MapT<K, A, B>(this Option<Map<K, A>> ma, Func<A, B> f) =>\n        ma.Map(a => a.Map(f));. @kthompson hi Kevin, I see you closed this, sorry for the lack of reply I'm in holiday atm.  What was your resolution? . @kthompson Hi Kevin, sorry for the slow response, been away on holiday.  I am not sure why this won't work, but it seems others have similar problems.  This appears to be a work-around, could you try that?. @taotaobujue There isn't support for that in this library.  Although I will probably add a Free monad at some point; but getting the API right isn't trivial in C#, most implementations I've seen are very cumbersome.  \n. I would probably avoid using the EmailValidator in the generic arguments list and just inject your validation (and normalisation) into the constructor:\n```c#\n    public class Email : NewType\n    {\n        Email(string email) : base(NormaliseEmail(email))\n        {\n            ValidateEmail(email).Match( \n                Some: err => throw new Exception(err.Message), \n                None: unit);\n        }\n    Email(string email, Unit _) : base(NormaliseEmail(email))\n    {\n        // Doesn't validate\n    }\n\n    public static Either<EmailFormatError, Email> TryParse(string input) =>\n        ValidateEmail(input).Match(\n            Some: error => Left<EmailFormatError, Email>(error),\n            None: () => new Email(input, unit));\n\n    static string NormaliseEmail(string email) => ...;\n    static Option<EmailFormatError> ValidateEmail(string email) => ...;\n}\n\n```\n. @orthoxerox Is correct, the behaviour is correct, and if it ever changes for int then the code will continue to work.. New-types are definitely not just for constraints, so yes I would.  New-types give not just range constraints but also type constraints where an int != Priority, or an string != Email, etc.  So it removes a whole class of common errors where 'untyped' integers floating around could end up being assigned to the wrong thing.  . As you thought the new-types are for primitive types. The idea is that they hold a single piece of data, and can be constructed with a constructor that takes a single value.  It's not really possible to take that further and implement a 'record' type which would be a composite (well, it may be possible with some inline IL generation, but it would require a reasonable amount of typing by anyone using it, making it less than easy to consume).\nBy defining EqPerson which derives from Eq<Person> you're creating a class instance of the Eq type-class.  What that means is that you can call the TypeClass.equals function to compare your Person values:\n```c#\n    using static LanguageExt.TypeClass;\nbool areEqual = equals<EqPerson, Person>(personA, personB);\n\n``\nOr use them in any generic function that has a constraint ofEq.  This comes into its own with the other types in this library likeOption,Lstetc.  where there areequalsoverrides that allow you to do structural comparisons ofOptionorLst(for example).  It is a more explicit way of doing equality which causes compile time errors if you haven't got a class-instance for the type you want to compare.  It removes the need for types likeOption,Lst,Map, etc. from having to rely onEqualityComparer.Default` which won't report at compile-time if your type can't be compared.\nIt won't (as you suspected) implement the == or != operators, or Equals, or implement IEquatable, you still need to do that (if you want to use those features); but yes, you can implement them using your EqPerson class-instance.\nc#\n    public bool Equals(Person x, Person y)\n    {\n        if (ReferenceEquals(x, y)) return true; // must i check for null?\n        if (ReferenceEquals(x, null) ^ ReferenceEquals(y, null)) return false;\n        if (x.GetType() != y.GetType()) return false;\n        return x.Id == y.Id && x.Age == y.Age && x.Email == y.Email;\n    }\nYes you should still check for null.  Again there's no magic here, it's just a different approach which uses the idea of type-classes and instances.  You don't need to check the types with GetType(), that is enforced by the compiler.\nYou don't need to use the type-class system to use the standard systems for equality in .NET.  It depends how deep into the type-class idea you want to go.\n. > I was thinking that wherever your code makes use of a Eq it could handle the \"are both null?\" => true, \"is just one true?\" => false situations generically, before getting to my type-specific code, so my code wouldn't need to worry about it. \nThat's not possible, because generic functions that expect values that are constrained by the Eq<A> type-class call it like so:\nc#\n    static bool IsEqualTest<EqA, A>(A x, A y) where EqA : struct, Eq<A> => \n        default(EqA).Equals(x, y);\nThere's no way of enforcing that A is not null in all uses of the Eq<A> instance.  The function equals is purely a convenience function, and its usage can't be guaranteed.\n\nI'm not totally sure about this. I was thinking about the case where one type is a sub-type of the other.\n\nOk, fair enough.  I'm so far away from using inheritance for most things these days that it didn't cross my mind.. Yep, bug.  Fixed in v2.0.61. > Taking this approach to its logical conclusion shouldn't NewType be NewType?\nYes, and at some point I will add those variants too (if you need it soon then I can bring that forward, as a lot of the new-type system has settled down since the v2 release).  As you can probably imagine it ends up being quite a bit of typing to support everything that the new-types, num-types, and float-types can do.  Mostly new-types are simple types with equality and comparison operators 'built in'; but as you point out, types like string can have different strategies for equality.\n\nFinally, it really seems like NewType should be a struct for performance reasons. However if it was struct you could never give it a friendly name since there is no inheritance. Is that why you implement this as a class rather than a struct?\n\nYou can't derive from a struct, so the new-type system wouldn't work at all.  But yes, I'd much prefer it if C# allowed derived structs, or classes with value-type properties.. Yes they're cumbersome to use, it's not an ideal situation at all (and that's why I have raised a proposal for the Roslyn team).  But it's there if you want a more declarative approach.  If you don't want to use it, just put your validation in the constructor and don't supply a PRED argument.. By the way, you can do your first example using Range:\nc#\n    Range<TInt, int, I5, I50>. @Maximusya Yeah sure, I've set up a ko-fi page, for virtual coffee - I'm more of a coffee addict than a beer addict ;)\nThanks for the support!. > I have support you 3$. Sorry because of my incoming, I can't give you too much.\nThank you, that's very welcome :)\n\nOr you can contact some IT publisher, e.g. O'Reilly, Packt Publishing, and etc.\n\nI've already been asked to write a book on functional programming.  I just don't have the free time to be a CTO, develop lang-ext, and write a book (as well as the non-coding related interests I have in my life).  If there were 48 hours in a day I might consider it ;)\n\nthink you can take a while to write some samples for it. I have seen that the samples project in the solution is empty. If there are some pragmatic samples, I think there will be more users of your library, and maybe more patrons.\n\nWhilst I agree that more samples is a good idea, it is often difficult to demonstrate the scope of a project like this.  Mostly because it is all very abstract.  It's a bit like writing samples on how to use int.  This isn't a repo for teaching functional programming.  It's a repo to provide the common tools of functional programming that are found in other functional languages.  I realise that a lot of C# devs haven't touched functional programming before, or are inexperienced, and in those circumstances I'm always happy to help through the issues section or on gitter.  But also I'm not here to explain this stuff.  I provide the toolkit, it's up to you to go and learn functional programming.  Apart from the type-class stuff there's nothing really 'surprising' here in terms of functionality, and the type-class stuff can be pretty much ignored unless you're at an advanced level.\nI think something like the fsharpforfunandprofit tutorials would be quite good in this situation, but it would require a lot of time.  I am always open to contributions on this front (that can added to the wiki).  So if anyone is reading this and wants to get involved in adapting fsharpforfunandprofit-like tutorials, I would be very grateful. . @cjdsellers Hi Chris, thanks for the kind words.  Good luck with your project :). @OlduwanSteve I'll get on that now Steve.  Thanks.. Fix deployed in v2.0.62 :). Pull request merged. Thanks!. I think the F suffix was for Fail, but that's fine.. @vkirienko Depending on the type you can use things like .IfNone(default(T)).  Or you can build some extensions that do the same as before if you're not concerned about getting bad values out:\n```c#\n    public static class LangExtExtensions\n    {\n        public static T Value(this Option option) where T : struct => \n            option.IfNone(default(T));\n    public static T Value<T>(this OptionUnsafe<T> option) where T : struct =>\n        option.IfNoneUnsafe(default(T));\n\n    public static R Value<L, R>(this Either<L, R> either) where R : struct =>\n        either.IfLeft(default(R));\n\n    public static R Value<L, R>(this EitherUnsafe<L, R> either) where R : struct =>\n        either.IfLeftUnsafe(default(R));\n\n    public static T ValueUnsafe<T>(this Option<T> option) =>\n        option.IfNoneUnsafe(default(T));\n\n    public static T ValueUnsafe<T>(this OptionUnsafe<T> option) =>\n        option.IfNoneUnsafe(default(T));\n\n    public static R ValueUnsafe<L, R>(this Either<L, R> either) =>\n        either.IsLeft\n            ? default(R)\n            : either.IfLeft(default(R));\n\n    public static R ValueUnsafe<L, R>(this EitherUnsafe<L, R> either) =>\n        either.IfLeftUnsafe(default(R));\n}\n\nThen you can call:c#\n    Option option;\n    var x = option.Value();\nOption<string> option;\nvar x = option.ValueUnsafe();\n\n```. @gregberns \n\nFirst, thanks for this awesome library. I just started using it on a new project with fantastic results.\n\nGreat to hear :)\n\nI'm looking for a function that's basically identity plus an Action, so it accepts A and an Action and returns an A. This could be used for something like logging.\n\nUnfortunately not.  I've kind of resisted it because it goes against the core concepts of functional programming (where we should avoid side-effects).  \nObviously to provide your own extension method for each type would be relatively easy.  I think for IEnumerable based types you'd want something like this that is lazy and therefore streams the values through rather than Do taking a the outer value:\nc#\n    public static class DoExtensions\n    {\n        public static IEnumerable<A> Do<A>(this IEnumerable<A> self, Action<A> f)\n        {\n            foreach (var item in self)\n            {\n                f(item);\n                yield return item;\n            }\n        }\n    }\nThen you could do:\nc#\n    list.Map(i => DoSomething(i)) \n         .Do(j => Log(j))\n         .Map(k => DoSomethingElse(k))\nOr more succinctly :)\nc#\n    list.Map(DoSomething)\n        .Do(Log)\n        .Map(DoSomethingElse);\nNow you could go all in and create a Writer monad that works with lists:\n```c#\n    public delegate (Lst Seq, W Output) WriterSeq();\npublic static class PreludeExt\n{\n    static readonly Lst<Unit> OneUnit = List(unit);\n\n    public static WriterSeq<MonoidW, W, A> WriterSeq<MonoidW, W, A>(Lst<A> seq)\n        where MonoidW : struct, Monoid<W> => () =>\n        (seq, default(MonoidW).Empty());\n\n    public static WriterSeq<MonoidW, W, Unit> tellSeq<MonoidW, W>(W what)\n        where MonoidW : struct, Monoid<W> => () =>\n        (OneUnit, what);\n}\n\npublic static class WriterSeqExtensions\n{\n    public static WriterSeq<MonoidW, W, B> Map<MonoidW, W, A, B>(\n        this WriterSeq<MonoidW, W, A> self, \n        Func<A, B> map)\n            where MonoidW : struct, Monoid<W> =>\n                Select(self, map);\n\n    public static WriterSeq<MonoidW, W, B> Select<MonoidW, W, A, B>(\n        this WriterSeq<MonoidW, W, A> self, \n        Func<A, B> map) \n            where MonoidW : struct, Monoid<W> => () =>\n    {\n        var (seqA, output) = self();\n        var seqB = List<B>();\n        foreach (var a in seqA)\n        {\n            seqB = seqB.Add(map(a));\n        }\n        return (seqB, output);\n    };\n\n    public static WriterSeq<MonoidW, W, C> SelectMany<MonoidW, W, A, B, C>(\n        this WriterSeq<MonoidW, W, A> self, \n        Func<A, WriterSeq<MonoidW, W, B>> bind,\n        Func<A, B, C> project)\n        where MonoidW : struct, Monoid<W> => () =>\n    {\n        var (seqA, output) = self();\n\n        var seqC = List<C>();\n\n        foreach (var a in seqA)\n        {\n            var mseqB = bind(a);\n            var (seqB, outputB) = mseqB();\n            output = default(MonoidW).Append(output, outputB);\n\n            foreach (var b in seqB)\n            {\n                seqC = seqC.Add(project(a, b));\n            }\n        }\n        return (seqC, output);\n    };\n}\n\nThat allows logging to be captured as part of the monadic expression rather than as a side-effect:c#\nvar list = List(1, 2, 3);\nvar comp =  from num  in WriterSeq, Lst, int>(list)\n            from _    in tellSeq, Lst>(List($\"Number: {num}\"))\n            let  num2 = TimesTwo(num)\n            from __   in tellSeq, Lst>(List($\"Number x 2: {num2}\"))\n            let  pls1 = PlusOne(num2)\n            from ___  in tellSeq, Lst>(List($\"Number x 2 + 1: {pls1}\"))\n            select pls1;\nNow that's not super attractive, so you could create helper functions that cover your common use cases:c#\n        public static WriterSeq, Lst, A> with(Lst list) =>\n            WriterSeq, Lst, A>(list);\n    public static WriterSeq<MLst<string>, Lst<string>, Unit> log(string message) =>\n        tellSeq<MLst<string>, Lst<string>>(List(message));\n\nThen it starts to look a bit more attractive.c#\nvar comp = from num  in with(list)\n           from _    in log($\"Number: {num}\")\n           let  num2 = TimesTwo(num)\n           from __   in log($\"Number x 2: {num2}\")\n           let  pls1 = PlusOne(num2)\n           from ___  in log($\"Number x 2 + 1: {pls1}\")\n           select pls1;\nYou can then just invoke the `comp` delegate:c#\n    var (seq, output) = comp();\nConsole.WriteLine(\"Values\");\nforeach(var item in seq)\n{\n    Console.WriteLine(item);\n}\n\nConsole.WriteLine(\"Log\");\nforeach (var item in output)\n{\n    Console.WriteLine(item);\n}\n\n```\nAnd your results and logging are returned. \nThat may be overkill for what you want.  But I guess it depends how seriously you want to take the pure/referentially transparent approach. . @Orca2040 There's no implicit coercion for nullable types in case the behaviour you're describing is intentional.  Nullable is a struct, so when you return null it's creating a Nullable<T> which isn't null.  And so Option happily wraps it up.\nIt does seem a little strange that you want to maintain the nullable type but remove its one additional feature over the value type it wraps: it's nullability.  So if you want it to not be null then return Option<int> and Option<short> rather than Option<int?> and Option<short?>.\nYou can use the explicit coercion of Optional(x):\n```c#\n        public static Option nullableShort()\n        {\n            short? x = null;\n            return Optional(x);\n        }\n    public static Option<int> nullableInt()\n    {\n        int? x = null;\n        return Optional(x);\n    }\n\nOr use `Some(x)` which will throw a `ValueIsNullException` if the nullable is `null`.. @vrobinson Because `Some` is a `struct` there are a number of ways that it can be created without being initialised:c#\n    var x = new Some();\n    var y = new Some[10];\n    var z = default(Some);\nclass Foo\n{\n    public Some<string> Bar;\n}\n\nAnd because structs don't support co-variance it makes it awkward to use with generics.  So it can often get in the way.  . @gregberns Hi Greg, you do seem to be tying yourself up in knots here.  The first example can be done with `Map`:c#\n    static Either GetVehicleFromVin(string vinString, int stockNumber) =>\n        Vin.Create(vinString).Map(vin => new Vehicle(vin, stockNumber));\nYou could also write:c#\n    static Either GetVehicleFromVin(string vinString, int stockNumber) =>\n        from vin in Vin.Create(vinString)\n        select new Vehicle(vin, stockNumber);\n``\nWhatMapdoes is to only run the lambda provided if theEitheris in Rightstate.  So IfVin.Createreturns anErrorthen thenew Vehicle(...)code won't execute and theError` will propagate.  \nYou could also use MapLeft if you wanted to add some extra context to your error:\nc#\n    static Either<Error, Vehicle> GetVehicleFromVin(string vinString, int stockNumber) =>\n        Vin.Create(vinString)\n           .Map(vin => new Vehicle(vin, stockNumber))\n           .MapLeft(err =>  Error.New($\"{err} for stock-number: {stockNumber}\"));\nMapLeft only runs when the Either is in Left state.\nWith your second example you could make use of Partition which runs a sequence of Eithers and splits them into two sequences of Lefts and Rights:\n```c#\n    public static Either, Unit> Test()\n    {\n        Either ret1 = call1();\n        Either ret2 = call2();\n    var (lefts, rights) = Seq(ret1, ret2).Partition();\n\n    return lefts.IsEmpty\n        ? Right<Seq<Error>, Unit>(unit)\n        : Left<Seq<Error>, Unit>(lefts);\n}\n\n``\nObviously I've set it up to returnSeq, but you could just returnnew Error(lefts)` to wrap up the errors.\n\nGet the latest build from nu-get, as I've just made it work with ValueTuple and Seq (before it just supported Tuple and IEnumerable).\n\nA lot of the point of types like Option and Either are to avoid the mess of if then else, they deal with that for you.  So if you ever find yourself using if(either.IsLeft) or similar, then you're probably doing it wrong.\nThe general rules are:\n If you need to get a concrete value, use Match\nc#\n    int x = either.Match(\n        Right: value => value * 2,\n        Left: error => 0\n    );\n If you want to provide functionality for the 'success' path (i.e. an error ends the computation, but positive results continue it), use Map.\nc#\n   Either<Error, int> nextEither = either.Map(value => value * 2);\n If you need to flip from the success path to the fail path, use Bind.\nc#\n   Either<Error, int> nextEither = either.Bind(\n        value => value == 0 \n            ? Left<Error, int>(Error.New(\"Value can't be zero\"))\n            : Right<Error, int>(value * 2)\n    );\n If you need to work with more than one Either at a time, use LINQ\nA series of Map or Bind calls can be seen as logical AND.  Which can also be represented using LINQ:\nc#\n    from x in call1()\n    from y in call2()\n    select x + y;\n^^^ x+ y only run if call1 AND call2 return Right(int).\nYou can also use the || operator for left coalescing:\nc#\n    Either<Error, int> res = eitherA || eitherB || eitherC;\nThe first Either to be in a Right state is returned.\nGenerally it's best to stay in context rather than trying to extract the values with Match or the approach you were using.. @trbngr Hi Chris, what are you trying to achieve?  Perhaps I can help on a more specific question.\nThe reason it reports a BottomException in those examples is because it's doing a trasnformer bind operation, which is a generalised system for monadic binding on two nested monads (in this case Task<Either<L, R>>).  When the inner monad bind fails (which it will do because of the initial Left state), then so does the outer bind operation.  The outer monad (Task<...>) isn't aware of the Left type being Exception so all it can do is fail with BottomException because the Task is now in a failed state. \nSo essentially you're getting a general failure response from the Task not the Either.. @feugen24 Great idea!  Now to triage... . @feugen24  All issues have now been triaged.  I have also added a link to the issues on the home page and wiki. @JHaugh4  Sorry, that is an old example.  The transformer functions don't need an extra using any more. It should be:\n```c#\n    using LanguageExt;\n    using static LanguageExt.Prelude;\n    using LanguageExt.ClassInstances; // Required for TInt on Sum (see ad-hoc polymorphism)\nvar list = List(Some(1), None, Some(2), None, Some(3));\n\nvar presum = list.SumT<TInt, int>();                                // 6\n\nlist = list.MapT(x => x * 2);\n\nvar postsum = list.SumT<TInt, int>();\n\n``\n However the example  does need an extrausingfor use ofTIntwhich allowsSumT(andSum) to work with anystructtype that implementsNum, which is also a new feature since the original example was posted.. @StefanBertels Added tov2.0.70` on nu-get now.\nThanks for the suggestion :). @StefanBertels Obiviously you can use LINQ to make it slightly prettier:\nc#\n    var value = from section in ini.Find(\"Section\")\n                from varname in section.Find(\"varname\")\n                from result  in parseInt(varname)\n                select result;\nBut yes, I will add the same extensions that the regular Map has.  Might be a few days though, I have quite a lot on at the moment.. @bender2k14 There's overloads for both.  So you can find by keys and get an Option or find by keys with an embedded Some None match.\nThe reason for the embedded match was mostly drying up a real world repetition I saw a lot of:\nc#\n   var x = map.Find(keyA, keyB).Match(Some: x => ..., None: () => ...);\nIt was so common that I decided to create an overload to reduce the cognitive load:\nc#\n   var x = map.Find(keyA, keyB, Some: x => ..., None: () => ...);\nPerhaps calling it FindMap or FindMatch or something like that might have been clearer.. Cognitive load was probably the wrong term.  'Less clutter' is probably more accurate.  There is precedence in the Map type for inline behaviour based on a  key's existence: TryAdd, AddOrUpdate, etc.  So, I think in this case it's a reasonable interface extension.  It isn't something I'd want to litter the code base with though.\n\nI am not that crazy about .Match(some, none)\n\nThere are efficiency benefits to .Match(some, none) over .Map(some).IfNone(none) which in some situations might be important.  It also looks a lot like the match statement of F#.  \nPersonally, I prefer to use Match, IfNone, etc. as little as possible and stay bound in the context of the monad.  It makes composition and propagation much easier.\nThere is also opt.Some(some).None(none) if you want a slightly more elegant fluent interface.\nAlthough this library is clearly opinionated, there are a number of styles it supports to suit preferences of the developer.\n\nFunction based  - match(option, Some: some, None: none)\nFluent - option.Some(some).None(none)\n'Pattern matching' - option.Match(Some: some, None: none)\n\nIt's a policy I think works well, and even if you prefer one style, sometimes the others can be more elegant in certain situations (Function based when used with LINQ for example)\n\nBeing explict (e.g. FindMatch) has advantages:\n\nIn hindsight, I agree.  In reality it becomes a breaking change.  Although I guess I could make the Find extensions Obsolete and just add the newly named functions.\nI'm midway through an enormous refactor for the async work - so I'll leave it for now and come back to it.  Not entirely sure FindMatch is the right name yet, so I'll have a think (open to suggestions).. @StefanBertels Do you fancy having a go at the implementation for this?  I'm pretty time poor at the moment, so a pull request would be lovely - rather than leaving this perpetually open :). @StefanBertels \nYou could partially apply the equals function in static LanguageExt.TypeClass:\nc#\n    var eq = par<string, string, bool>(equals<EqStringOrdinalIgnoreCase, string>, \"abc\");\nThen your Find would be:\nc#\n    ...Find(eq);\nBut remember EqStringOrdinalIgnoreCase.Inst is just a static value, so you can also do:\nc#\n    var eq = EqStringOrdinalIgnoreCase.Inst;\nOr,\nc#\n    var eq = default(EqStringOrdinalIgnoreCase);\nAnd then your Find would be:\nc#\n    ...Find(x => eq.Equals(x, \"abc\"));\n. @hyrmn Thanks Ben!. This won't work.  But I see the issue you're trying to fix, so I will do it.. I think the only workable solution would be to put them into a different type.  But it would be a breaking change, so I'm not massively up for the idea.  I think ultimately the issue is likely to be rare enough to not be worth any change, because it will only fail when you're using the variables in an untyped situation (like in string interpolation).  . @alex-fomin \nc#\nvar some = f1() || f2() || f3();\n. @alex-fomin You can also put in a default at the end of the chain.  For example let's say it was Option<int> you were working with:\nc#\nvar result = f1() || f2() || f3() || 100;\nThe 100 will be implicitly converted to Some(100).. @chadedrupt Hi Chad, this is expected behaviour.\nThe reason it reports a BottomException is because it's doing a transformer bind operation, which is a generalised system for monadic binding on two nested monads (in this case Task<Either<L, R>>).  When the inner monad bind fails (which it will do because of the initial Left state), then so does the outer bind operation.  The outer monad (Task<...>) isn't aware of the Left type on the Either so it can't give you a useful exception, so it fails with BottomException because the Task is now in a failed state. \nSo essentially you're getting a general failure response from the Task not the Either.\nYou should consider Try, TryAsync, TryOptionAsync for these kinds of operations.  This very question was asked yesterday, below is an example from my response:\nYou may want to use Try<A> and TryAsync<A> it captures exceptions and removes the need for nesting monads.  You can create methods that return Try<A> and easily make them asynchronous by calling ToAsync() or calling any of the Async variant functions like MatchAsync, MapAsync, etc.\n```c#\n    static Try addUser2(UserMapping user) => () =>\n        user.ToString().Length;\nstatic Try<UserMapping> createUserMapping2(ADUser user) => () =>\n    UserMapping.New(user.ToString() + \" mapped\");\n\npublic TryAsync<int> Issue207_5() =>\n    from us in TryAsync<ADUser>(() => throw new Exception(\"fail\"))\n    from mu in createUserMapping2(us).ToAsync()\n    from id in addUser2(mu).ToAsync()\n    select id;\n\npublic async Task<int> Test2()\n{\n    return await Issue207_5().Match(\n        Succ: value => value,\n        Fail: excep => 0);\n}\n\nYou can use the various conversion functions if you want to use it with `Either` in other places:c#\n    Issue207_5().ToEither();    // Task>\n```\nYou can definitely think of Try<A> as a friendlier Either<Exception, A> and TryAsync<A> as a friendlier Task<Either<Exception, A>>.  \nThere's also TryOption<A> which is basically: Either<Exception, Option<A>> and TryOptionAsync<A> which is Task<Either<Exception, Option<A>>>\n. > But if my Left case is not an exception type, I'm left with Matching the Either and throwing inside a Try. Which I suppose is not the end of the world, just a bit ugly IMO. Of course I could create an extension method to hide it away.\nYes, if your Left isn't an Exception then Try isn't appropriate.  \n\nThe other option I'm going to play with is Validation.  But if my chain is too long, it just doesn't flow right. And I don't want an Applicative.\n\n(Emphasis mine) Not sure what you mean here?  \n\nLike I said above, wrapping Task to TryAsync feels dirty. I suppose it's just the nature of \"bolting\" FP onto a language that's not pure FP.\n\n(Emphasis mine)  Not really.  FP is fully supported in C# - it has first-class functions, lambdas etc.  There isn't any sense that anything is being bolted on.  What it didn't have (until I started this project) is a comprehensive and consistent 'base class library' for functional programming.  Unfortunately even though this library covers the majority of what is needed, sometimes there are gaps.  So what's missing here is EitherAsync, like OptionAsync, TryAsync.  Because C# has built in language support for async it also needs bespoke implementations to be really useful in monadic programming. It is in my road-map, I am currently super busy though and probably won't get to it for a few weeks at least.\nWhat you could do instead of writing those extension methods is to provide bespoke Select, SelectMany, and Where extensions for the Task<Either<..., ...>> type.  If your Left is always a type called Error for example then I think the C# extension method resolver will prefer your version over a more generic one:\n```c#\n    public static class Exts\n    {\n        public static async Task> Select(this Task> self, Func f) =>\n            (await self).Match(\n                Right: r => Right(f(r)),\n                Left: l => Left(l));\n    public static async Task<Either<Error, C>> SelectMany<A, B, C>(\n        this Task<Either<Error, A>> self,\n        Func<A, Task<Either<Error, B>>> bind,\n        Func<A, B, C> project) =>\n        await (await self).MatchAsync(\n            Right: async a => (await bind(a)).Match(\n                Right: b => Right<Error, C>(project(a, b)),\n                Left: l => Left<Error, C>(l)),\n            Left: l => Left<Error, C>(l));\n\n    public static async Task<Either<Error, A>> Where<A>(this Task<Either<Error, A>> self, Func<A, bool> f) =>\n        (await self).Match(\n            Right: r => f(r)\n                ? r\n                : Either<Error, A>.Bottom,\n            Left: l => l);\n}\n\n```\nI have just typed that into the issue and not tested it, so apologies if it doesn't compile/work.\n. @trbngr @chadedrupt \nThis was bugging me a bit, so I looked into a more permanent solution.  If you get the latest from nu-get (v2.0.88) then the behaviour you expected will work.\nPart of the problem was that the nested monadic bind called the outer monad's Fail function (on its class instance type).  The Fail method is a bit of a hacky solution (it is in Haskell too), but it's needed to make the type-class stuff work with C#'s type system.  The outer monad in this case is Task and its Fail function was BottomException.Default.AsFailedTask(), which is why the operation fails at that point.  \nObviously you were expecting the failed inner value to propagate so the result would be Task(Left(x)).  The Task monad now checks the failure value and if it matches its bound value type then it casts it to a valid result (I have done the same for the other monads too).  This means the failed inner value is maintained within a successful outer value but still does the early out.\nHere's a unit test to demo it:\n```c#\n        public void Issue208()\n        {\n            var r = from a in Left(Error.New(\"error 1\")).AsTask()\n                    from b in Right(1).AsTask()\n                    select a + b;\n        Assert.True(r.Result == Left<Error, int>(Error.New(\"error 1\")));\n\n        var r2 = from a in Option<int>.None.AsTask()\n                 from b in Some(1).AsTask()\n                 select a + b;\n\n        Assert.True(r2.Result == None);\n    }\n\n``\n. Ok, leave it with me I'll put in some more tests.. @chadedrupt @trbngr Unfortunately I had to revert the changes.  It turns out I can't generalise it as I would have hoped.  There may be a few other approaches but I will need some time to investigate.  So you will need to provide thoseSelectandSelectManyoverrides for now.. This issue is fixed inv2.2.17-beta` . @gregberns \nThe hug has worked.  v2.0.91 on nu-get.  Map now has:\n Union - All items from both maps are kept in the result, keys that are in both are merged using the merge function you provide.\n Intersect - Only items that are in both maps are kept in the result, all results are merged used the function you provide\n Except (difference) - Items from the second map are removed from the first which becomes the result\n SymmetricExcept - Only Items that are in one map or the other are kept in the results\nYou can call them fluently or functionally.  The functional versions are below.\n```c#\n[Fact]\npublic void MapUnionTest1()\n{\n    var x = Map((1, 1), (2, 2), (3, 3));\n    var y = Map((1, 1), (2, 2), (3, 3));\nvar z = union(x, y, (k, l, r) => l + r);\n\nAssert.True(z == Map((1, 2), (2, 4), (3, 6)));\n\n}\n[Fact]\npublic void MapUnionTest2()\n{\n    var x = Map((1, 1), (2, 2), (3, 3));\n    var y = Map((4, 4), (5, 5), (6, 6));\nvar z = union(x, y, (k, l, r) => l + r);\n\nAssert.True(z == Map((1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)));\n\n}\n[Fact]\npublic void MapIntesectTest1()\n{\n    var x = Map(        (2, 2), (3, 3));\n    var y = Map((1, 1), (2, 2)        );\nvar z = intersect(x, y, (k, l, r) => l + r);\n\nAssert.True(z == Map((2, 4)));\n\n}\n[Fact]\npublic void MapExceptTest()\n{\n    var x = Map((1, 1), (2, 2), (3, 3));\n    var y = Map((1, 1));\nvar z = except(x, y);\n\nAssert.True(z == Map((2, 2), (3, 3)));\n\n}\n[Fact]\npublic void MapSymmetricExceptTest()\n{\n    var x = Map((1, 1), (2, 2), (3, 3));\n    var y = Map((1, 1),         (3, 3));\nvar z = symmetricExcept(x, y);\n\nAssert.True(z == Map((2, 2)));\n\n}\n```. @gregberns \n\nWith Union, do the types have to match? Looks like the merge signature takes two of the same type and returns that same type.\n\nCurrently they must be the same types yes.  I've already started on a version that supports two types for the values, it needs an additional map function for when there isn't a merge, and two map functions when the result type isn't the same as the two input types.  Just ran out of time this evening to complete it. I figured a first pass may be helpful.\nThe final goal will be to implement a similar system to Haskell's Map merge, which allows for injection of various strategies for missing values and merging.\nhttps://hackage.haskell.org/package/containers-0.5.9.2/docs/Data-Map-Merge-Strict.html. @gregberns v2.0.92 has:\nc#\nMap<K, V> union<K, V>(Map<K, V> left, Map<K, V> right, WhenMatched<K, V, V, V> Merge)\nMap<K, A> union<K, A, B>(Map<K, A> left, Map<K, B> right, WhenMissing<K, B, A> MapRight, WhenMatched<K, A, B, A> Merge)\nMap<K, B> union<K, A, B>(Map<K, A> left, Map<K, B> right, WhenMissing<K, A, B> MapLeft, WhenMatched<K, A, B, B> Merge)\nMap<K, C> union<K, A, B, C>(Map<K, A> left, Map<K, B> right, WhenMissing<K, A, C> MapLeft, WhenMissing<K, B, C> MapRight, WhenMatched<K, A, B, C> Merge)\nAnd intersect has been upgraded to allow different types for the values and return value:\nc#\nMap<K, R> intersect<K, A, B, R>(Map<K, A> left, Map<K, B> right, WhenMatched<K, A, B, R> merge)\nThe other types remain unchanged, because they rely on the value types being the same.  I haven't gone the whole hog like the Haskell version, but I will when I have more time.\n. @gwintering Hi Greg, I dropped support for it because I genuinely thought nobody would use it due to it being generics hell!  \nI'd be up for re-adding it, but I would want to generalise it properly like I have done with the Writer (where W is constrained to be a monoid), and with a more specific version that mimics the original.  I think the last time I tried it it turned my head inside out, so rather than commit something buggy I decided to drop it.\nThis is the old source if you want to build a version for yourself:\n```c#\nusing LanguageExt;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Diagnostics.Contracts;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static LanguageExt.Prelude;\nnamespace LanguageExt\n{\n    /// \n    /// Combines all the behaviours of the Reader, Writer and State monads into a single\n    /// monadic computation.\n    /// \n    /// Reader type\n    /// Writer type\n    /// State type\n    /// Wrapped type\n    /// A tuple (environment, state) that represents the shared immutable\n    /// environment and shared mutable state.\n    /// A value that represents the bound value as well as the shared environment,\n    /// shared state, and shared outputs\n    public delegate RwsResult Rws(Tuple rws);\n/// <summary>\n/// RWS result.\n/// </summary>\npublic struct RwsResult<W, S, T>\n{\n    readonly T value;\n    public readonly IEnumerable<W> Output;\n    public readonly S State;\n    public readonly bool IsBottom;\n\n    internal RwsResult(IEnumerable<W> output, S state, T value, bool isBottom = false)\n    {\n        this.value = value;\n        Output = output;\n        State = state;\n        IsBottom = isBottom;\n    }\n\n    [Pure]\n    public T Value =>\n        IsBottom\n            ? default(T)\n            : value;\n\n    [Pure]\n    public static implicit operator RwsResult<W, S, T>(T value) =>\n       new RwsResult<W, S, T>(new W[0], default(S), value);        // TODO:  Not a good idea\n\n    [Pure]\n    public static implicit operator T(RwsResult<W, S, T> value) =>\n       value.Value;\n\n    public static readonly RwsResult<W, S, T> Bottom =\n        new RwsResult<W, S, T>(new W[0], default(S), default(T), true);\n}\n\n}\npublic static class RwsExtensions\n{\n    internal static Rws Valid(this Rws self) =>\n        self ?? (rs => RwsResult.Bottom);\n[Pure]\npublic static Rws<R, W, S, IEnumerable<T>> AsEnumerable<R, W, S, T>(this Rws<R, W, S, T> self) =>\n    self.Select(x => (new T[1] { x }).AsEnumerable());\n\n[Pure]\npublic static IEnumerable<T> AsEnumerable<R, W, S, T>(this Rws<R, W, S, T> self, R env, S state)\n{\n    var res = self.Valid()(Tuple(env, state));\n    if (!res.IsBottom)\n    {\n        yield return self(Tuple(env, res.State)).Value;\n    }\n}\n\npublic static Rws<R, W, S, Unit> Iter<R, W, S, T>(this Rws<R, W, S, T> self, Action<T> action) =>\n    s => bmap(self.Valid()(s), action);\n\n[Pure]\npublic static Rws<R, W, S, int> Count<R, W, S, T>(this Rws<R, W, S, T> self) =>\n    s => self.Valid()(s).IsBottom\n        ? 0\n        : 1;\n\n[Pure]\npublic static Rws<R, W, S, bool> ForAll<R, W, S, T>(this Rws<R, W, S, T> self, Func<T, bool> pred) =>\n    self.Select(pred);\n\n[Pure]\npublic static Rws<R, W, S, bool> Exists<R, W, S, T>(this Rws<R, W, S, T> self, Func<T, bool> pred) =>\n    self.Select(pred);\n\n[Pure]\npublic static Rws<R, W, S, FState> Fold<R, W, S, T, FState>(this Rws<R, W, S, T> self, FState state, Func<FState, T, FState> folder) =>\n    s => bmap(self.Valid()(s), x => folder(state, x));\n\n[Pure]\npublic static Rws<R, W, S, S> Fold<R, W, S, T>(this Rws<R, W, S, T> self, Func<S, T, S> folder) =>\n    s => bmap(self.Valid()(s), x => folder(s.Item2, x));\n\n[Pure]\npublic static Rws<R, W, S, Ret> Map<R, W, S, T, Ret>(this Rws<R, W, S, T> self, Func<T, Ret> mapper) =>\n    self.Select(mapper);\n\n[Pure]\npublic static Rws<R, W, S, Ret> Bind<R, W, S, T, Ret>(this Rws<R, W, S, T> self, Func<T, Rws<R, W, S, Ret>> binder)\n{\n    if (binder == null) throw new ArgumentNullException(nameof(binder));\n    return state =>\n    {\n        var resT = self.Valid()(state);\n        if (resT.IsBottom)\n        {\n            return new RwsResult<W, S, Ret>(resT.Output, resT.State, default(Ret), true);\n        }\n        return binder(resT.Value).Valid()(Tuple(state.Item1, resT.State));\n    };\n}\n\n[Pure]\n[EditorBrowsable(EditorBrowsableState.Never)]\npublic static Rws<R, W, S, U> Select<R, W, S, T, U>(this Rws<R, W, S, T> self, Func<T, U> map)\n{\n    if (map == null) throw new ArgumentNullException(nameof(map));\n    return state =>\n    {\n        var resT = self.Valid()(state);\n        return resT.IsBottom\n            ? new RwsResult<W, S, U>(resT.Output, resT.State, default(U), true)\n            : new RwsResult<W, S, U>(resT.Output, resT.State, map(resT.Value));\n    };\n}\n\n[Pure]\n[EditorBrowsable(EditorBrowsableState.Never)]\npublic static Rws<R, W, S, V> SelectMany<R, W, S, T, U, V>(\n    this Rws<R, W, S, T> self,\n    Func<T, Rws<R, W, S, U>> bind,\n    Func<T, U, V> project\n    )\n{\n    if (bind == null) throw new ArgumentNullException(nameof(bind));\n    if (project == null) throw new ArgumentNullException(nameof(project));\n\n    return state =>\n    {\n        var resT = self.Valid()(state);\n        if (resT.IsBottom) return new RwsResult<W, S, V>(resT.Output, resT.State, default(V), true);\n        var resU = bind(resT.Value).Valid()(Tuple(state.Item1, resT.State));\n        if (resU.IsBottom) return new RwsResult<W, S, V>(resU.Output, resU.State, default(V), true);\n        var resV = project(resT.Value, resU.Value);\n        return new RwsResult<W, S, V>(resT.Output.Concat(resU.Output), resU.State, resV);\n    };\n}\n\n[Pure]\npublic static Rws<R, W, S, T> Filter<R, W, S, T>(this Rws<R, W, S, T> self, Func<T, bool> pred) =>\n    self.Where(pred);\n\n[Pure]\n[EditorBrowsable(EditorBrowsableState.Never)]\npublic static Rws<R, W, S, T> Where<R, W, S, T>(this Rws<R, W, S, T> self, Func<T, bool> pred) =>\n    state =>\n    {\n        var res = self.Valid()(state);\n        return new RwsResult<W, S, T>(res.Output, res.State, res.Value, !pred(res.Value));\n    };\n\n[Pure]\npublic static Rws<R, W, S, int> Sum<R, W, S>(this Rws<R, W, S, int> self) =>\n    state => bmap(self.Valid()(state), x => x);\n\n[Pure]\nprivate static RwsResult<W, S, Ret> bmap<W, S, T, Ret>(RwsResult<W, S, T> r, Func<T, Ret> f) =>\n    r.IsBottom\n        ? new RwsResult<W, S, Ret>(r.Output, r.State, default(Ret), true)\n        : new RwsResult<W, S, Ret>(r.Output, r.State, f(r.Value), false);\n\n[Pure]\nprivate static RwsResult<W, S, Unit> bmap<W, S, T>(RwsResult<W, S, T> r, Action<T> f)\n{\n    if (r.IsBottom)\n    {\n        return new RwsResult<W, S, Unit>(r.Output, r.State, unit, true);\n    }\n    else\n    {\n        f(r.Value);\n        return new RwsResult<W, S, Unit>(r.Output, r.State, unit, false);\n    }\n}\n\n}\n```\nThen the prelude:\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics.Contracts;\nnamespace LanguageExt\n{\n    public static partial class Prelude\n    {\n        /// \n        /// Reader Writer State monad constructor\n        /// \n        /// Rws monad\n        [Pure]\n        public static Rws Rws(T value) => rws =>\n              new RwsResult(new Out[0], rws.Item2, value);\n    /// <summary>\n    /// RWS monad 'tell'\n    /// Adds an item to the writer's output\n    /// </summary>\n    /// <returns>Rws monad</returns>\n    [Pure]\n    public static Rws<Env, Out, S, Unit> tell<Env, Out, S>(Out value) =>\n        rws => new RwsResult<Out, S, Unit>(new Out[1] { value }, rws.Item2, unit);\n\n    /// <summary>\n    /// RWS monad 'ask'\n    /// Gets the 'environment' so it can be used \n    /// </summary>\n    /// <returns>Rws monad with the environment in as the wrapped value</returns>\n    [Pure]\n    public static Rws<Env, Out, S, Env> ask<Env, Out, S>() =>\n        rws => new RwsResult<Out, S, Env>(new Out[0], rws.Item2, rws.Item1);\n\n    /// <summary>\n    /// RWS monad 'ask'\n    /// Gets the 'environment' and maps it\n    /// </summary>\n    /// <returns>Rws monad with the mapped environment in as the wrapped value</returns>\n    [Pure]\n    public static Rws<Env, Out, S, Ret> ask<Env, Out, S, Ret>(Func<Env, Ret> map) =>\n        rws => new RwsResult<Out, S, Ret>(new Out[0], rws.Item2, map(rws.Item1));\n\n    /// <summary>\n    /// Get the state from monad into its wrapped value (RWS)\n    /// </summary>\n    /// <returns>Rws monad with state in the value</returns>\n    [Pure]\n    public static Rws<Env, Out, S, S> get<Env, Out, S>() =>\n        rws => new RwsResult<Out, S, S>(new Out[0], rws.Item2, rws.Item2);\n\n    /// <summary>\n    /// Set the state (RWS)\n    /// </summary>\n    /// <returns>Rws monad with state set and with a Unit value</returns>\n    [Pure]\n    public static Rws<Env, Out, S, Unit> put<Env,Out,S>(S state) =>\n        _ => new RwsResult<Out, S, Unit>(new Out[0], state, unit);\n}\n\n}\n```\n. >  know what you mean about the generics; in my use I NewType<> away all but the return type.\nInteresting, how does that work out with LINQ and the like?  Are you dereferencing to Value?  I wonder if there's a better aliasing story that could be achieved here, hmm food for thought.\n\nSince you're up for including it, I started defining the essential methods. Please take a look at fee58d0 and let me know if you think the approach will work.\n\nMy brain's a bit frazzled after doing the Record feature this evening, but on the surface it looks good. \n. > I'd be interested in whatever your thoughts are on this.\nMy thoughts are roughly around creating a type-class system similar to Haskell which can resolve the class-instance to use by effectively doing a query on the type-system.  I've started something like this for the Record and NewType equality and ordering.  I could imagine an MType which is a wrapper for a monad value, a bit like a NewType is a wrapper for any value.\n. @vkirienko This looks like a Json.NET bug.  The only way I've managed to make Option serialise with Json.NET is to provide a constructor that takes an IEnumerable<A> and then derive Option<A> from IEnumerable<A>.  That means Json.NET serialises the Option<A> as [value] for Some(value) or [] for None.  \nI have unit tests that shows this working.  So I can only assume that there is something wrong in Json.NET that causes it to fail in this scenario.  \nI have tried removing the ISerializable implementation from Option to see if it was confusing Json.NET, but it doesn't seem to make any difference.  The fact that it appears to be a parsing error would tell me that it's best to raise an issue on the Json.NET repo for investigation.. @vkirienko So I did a bit more digging, and have found your issue.\nThis works:\n```c#\npublic class TopHatTests\n{\n    public class TopHat\n    {\n        public TopHat(int one, int? two)\n        {\n            Id = one;\n            Id2 = Prelude.Optional(two);\n        }\n    public int Id { get; set; }\n    public Option<int> Id2 { get; set; }\n}\n\n[Fact]\npublic void TopHatSerialisationTest()\n{\n    var t1 = new TopHat(1, 1416);\n    var str = JsonConvert.SerializeObject(t1);\n    var t2 = JsonConvert.DeserializeObject<TopHat>(str);\n\n    //Assert.True(t2 == t1);\n}\n\n}\n``\nThe reason it works is because I changed the name of the arguments toTopHattooneandtwo.  Previously they wereidandid2.  Json.NET will look for constructors that have the exact same names as the fields and properties in the type.  So because you haveIdandId2and a constructor that takesidandid2it tried to deserialise the JSON tointandint?.  ButId2's type isn't compatible withid2` (which still seems like a Json.NET bug to me).  \nSo I think it's trying to parse an int?, but the string has [1416] in it.\nYou could implement TopHat like this:\n```c#\n    public class TopHat\n    {\n        public TopHat(int id, Option id2)\n        {\n            Id = id;\n            Id2 = id2;\n        }\n    public int Id { get; set; }\n    public Option<int> Id2 { get; set; }\n}\n\n```\nAnd it would work as expected.\nNOTE: I commented out Assert.True(t2 == t1); because you don't have any equality testing implemented, so it will never work (because C# will just do reference equality, and they're two different references).  If you want structural equality testing then you can derive from the new Record type and provide a default serialisation constructor (The serialisation constructor allows it to play nicely with Json.NET):\n```c#\n    public class TopHat : Record\n    {\n        public TopHat(int id, Option id2)\n        {\n            Id = id;\n            Id2 = id2;\n        }\n    TopHat(SerializationInfo info, StreamingContext context) : base(info, context) {}\n\n    public int Id { get; set; }\n    public Option<int> Id2 { get; set; }\n}\n\n``\nThenAssert.True(t2 == t1)` will work perfectly.  . > LanguageExt to v2.0\nThe serialisation of Option changed from v1 to v2.  With different versions of Json.NET it variously worked or not.  The most robust solution I have found was to serialise it to an IEnumerable as mentioned above.  So previously it would have serialised a value that was compatible with int?, but later versions are not.  I needed to bite the bullet though, because Json.NET has been a massive thorn in my side ... you can probably imagine my horror when I saw the title of this issue! \nI think it's pretty stable now though!. Prelude.toMap(keyValues). I will be adding a feature that will allow you to specify your own Eq<JObject> implementation.  But that's not there yet.  The best short term option you have is to use [OptOutOfEq] on the field/property and then override the Equals yourself:\nc#\n    public override bool Equals(MyClass rhs) =>\n        base.Equals(rhs) && JObject.DeepEquals(this.Property, rhs.Property);\nYou'll need to do a similar thing for Equals(object rhs) and operator== (and the comparison operators if you want ordering).  . @StefanBertels  \nI would only implement what you can, and opt-out of what doesn't make sense in the comparison.\nBy the way, you should take a look at the new release, because you don't need to provide your own Equals overrides now.\nhttps://github.com/louthy/language-ext/releases/tag/v2.1.14. >  is this necessary with .NET Standard 2.0?\nYes, as the lang-ext builds netstandard 1.3, not 2.0, so the features of assembly discovery are not available.\n\nIf I add ClassInstancesAssembly.Register(typeof(EqJObject).GetTypeInfo().Assembly); build fails: Register seems to be defined in netstandard2.0 but not in net462.\n\nYou will need to use a #if condition for your framework.  I will probably allow Register to exist as an empty function so this isn't necessary in the future, but a bit swamped right now, so don't have much time to do a new build. Hi Stefan, I'll try and get a look at this next week.  Very time poor at the moment, sorry.. Bit slow on the fix, but this should work now in v2.2.15-beta. @sharwell Thanks Sam!. @sharwell Thanks for looking into this.  I do have major performance issues with VS 2017, this project is only one of my problems.  My main work project, which unfortunately I can't share, is constantly locking up and has laggy text input.  \nOne of my suspicions was expressions in general, but especially readonly statics.  I have a project where I use an in-house virtual dom system that bakes to readonly statics, i.e.\nc#\npublic readonly static DomMap Header =\n    WithAppointment(\n        SectionHeader(\"Appointment\", \"{AppointmentType}\", \"{prettydate(TimelineDate)}\"),\n        Details(\n            Info(\"Date and time\",\n                If<AppointmentModel>(a => a.ArrivedDateTime.IsSome,\n                    Then(\"{shorttime(Start)} to {shorttime(Finish)} on {shortdate(Start)}, arrived at {shorttime(ArrivedDateTime)} on {shortdate(ArrivedDateTime)}\"),\n                    Else(\"{shorttime(Start)} to {shorttime(Finish)} on {shortdate(Start)}, not arrived\"))),\n            Info(\"Site and location\", \"{Site}: {Location | (location not specified)}\"),\n            Info(\"Attendees\", Attendees),\n            Where<AppointmentModel>(am => HasServices(am, AppointmentServiceState.Provided),\n                Info(\"Provided services\", Services(AppointmentServiceState.Provided))),\n            Where<AppointmentModel>(am => HasServices(am, AppointmentServiceState.Cancelled),\n                Info(\"Cancelled services\", Services(AppointmentServiceState.Cancelled))),\n            Where<AppointmentModel>(am => !String.IsNullOrWhiteSpace(am.Subject ?? \"\"),\n                Info(\"Subject\", \"{Subject}\")),\n            Where<AppointmentModel>(am => !String.IsNullOrWhiteSpace(am.Comments ?? \"\"),\n                Info(\"Admin notes\", \"{Comments}\")),\n            Actions(\n                Action(\"Print\", \"This.PrintAppt({AppointmentId})\"),\n                If<AppointmentModel>(a => a.PersonModelType == PersonModelType.Exact,\n                    Then(Tool.Action(\"Expand\", \"This.ExpandAppt({AppointmentId})\")),\n                    Else(Tool.Action(\"Collapse\", \"This.CollapseAppt({AppointmentId})\"))))\n            ),\n        Divider);\nI use this type of thing to build pre-constructed expressions that take a state object and spit out HTML.\nDomMap is a delegate:\nc#\npublic delegate IEnumerable<DomElement> DomMap(object env);\nI have noticed that if I have a code file open with lots of these types of expressions in (that refer to each other) then it will get to the point of being unusable.  That seems pretty crazy.  As much as possible I try to make everything I do into an expression (for the ideological reasons that this library exists).  Not just static expressions that build when the ctor fires, but in general throughout my code base; could there be a general issue with deep expressions, or nested lambdas? \n\n(part of the 15.3 update release)\n\nWhat's the ETA for 15.3?\n\nThe next area where I believe this project is currently negatively influenced involves documentation comments. While I can make some improvements to this quickly, I believe that certain options regarding comments are limited by the language itself. \n\nI don't really follow what you're suggesting here.  But in terms of project comments, I couldn't find any docgen system that could deal with this project properly (having a lot of the core functionality in the static Prelude class), so I rolled my own that supported markdown and the like (and can deal with angle brackets in between tags properly).  Are you suggesting that the comments themselves are slowing down VS?  \n\nI would encourage you to express support for dotnet/csharplang#401.\n\nSupport in what way?  \nI very much appreciate you looking into this, although I do feel there are just general performance issues and bugginess throughout VS since Roslyn became the driver of all tooling.  I regularly see the refactoring components crashing (yellow bar pops up, I reset it, a few mins later - yellow bar).  . > According to the compiler, you have a hair over 94,000 syntax problems inside of documentation comments\nHmm, that's interesting.  I guess I could modify my doc gen to not just generate documentation, but fix-up the broken comments (although I find the embedding of <cref> etc as particularly ugly for the primary users of the source: the coders.  Is there a quick way of getting the doc error output?\n\nIf you have a reproducer, you can file a bug on github/roslyn. \n\nIt's annoyingly random, with no obvious pattern of failure.  Obviously it isn't random!  I will make sure I push the report button when I see it next.  \n\nSo we've heard. On the basis that your open source project and work project are likely share certain characteristics\n\nSome, but they are pretty different to be fair.  It is very large though: 70 projects, mixture of C# and F#, includes about 100 nu-get packages (internal and external).  It's a 'layered' project with an application core, data-access-tier, business-logic, UI, etc.  (each layer comprising of many projects).  I am currently working on the UI only part of the project and have seen major improvements in build time and general responsiveness by building a small SLN projects with just four projects in (build time down from minutes to 35 seconds) .  So it seems there could be some significant performance improvements if you could just stop checking projects that aren't changing?\n\nIf you have the hard drive space to spare, you can have one \"stable\" copy as your primary environment, and a \"preview\" copy \n\nDownloading now.  4.6 gb over a 3mbit connection, will take a while ;). \n@sharwell \nJust had ExtractMethodCodeRefactoringProvider crash when I was highlighting two lines of code.  I wasn't trying to refactor anything.\nSystem.InvalidOperationException : Unexpected false\n   at Roslyn.Utilities.Contract.ThrowIfFalse(Boolean condition,String message)\n   at Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix.GetVariableStyle(Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)\n   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GetVariableStyle(Dictionary`2 symbolMap,ISymbol symbol,SemanticModel model,ITypeSymbol type,Boolean captured,Boolean dataFlowIn,Boolean dataFlowOut,Boolean alwaysAssigned,Boolean variableDeclared,Boolean readInside,Boolean writtenInside,Boolean readOutside,Boolean writtenOutside,Boolean unsafeAddressTaken)\n   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)\n   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(<Unknown Parameters>)\n   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(<Unknown Parameters>)\n   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](<Unknown Parameters>)\n   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(<Unknown Parameters>)\n   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(<Unknown Parameters>)\n   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(<Unknown Parameters>)\n   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)\nCode looks like this:\n```c#\n                return await stream.MatchAsync(\n                    Right: async value =>\n                    {\n                        var choiceDSL = inner[value % inner.Length];\n                        ChoiceActions.SetChoiceState(id, choiceDSL.Item1).IfFailThrow();\n                        inner.Where(t => t.Item1 != choiceDSL.Item1 && t.Item1.Value > 0)\n                             .Iter(t => TaskStateActions.SaveSkippedTaskAndChildren(t.Item1).IfFailThrow());\n                    return await chooseChoice(value);\n                },\n                Left: async type => type == TaskStateType.Shutdown\n                                        ? await CancelledTask<TaskState>()\n                                        : TaskStateActions.UpdateTaskState(taskState.SetTaskStateType(type)).IfFailThrow());\n\nI highlighted:c#\n                        ChoiceActions.SetChoiceState(id, choiceDSL.Item1).IfFailThrow();\n                        inner.Where(t => t.Item1 != choiceDSL.Item1 && t.Item1.Value > 0)\n```. Let's wait, no point looking for fixes that have already been done.  I'm firing it up now.  . Doesn't seem to like F# (I did pick it from the install list)\n\n1>error MSB4057: The target \"GetTargetFrameworkProperties\" does not exist in the project.\n2>error MSB4020: The value \"\" of the \"Project\" attribute in element  is invalid.\n\n. Not using Ionide, so unlikely.  Just added the F# projects to the solution as normal.  \nI will probably have to pause this testing as I have a big deadline to meet for monday.  I have my main solution open in 15.3, so that should be enough to do some decent testing (it failed on a standalone service project)\nThanks for your help so far :). @sharwell Going to close this down for now.  15.3 seems to be an improvement so far.  I'll report anything else through the normal channels.  Thanks for your help  \ud83d\udc4d . @sharwell Thanks Sam, I'll give this a go.. @NickDarvey Hi Nick, yes if you go three levels deep with the monads you will need to manually lift to the outer monad.  The HKT stuff as you probably know is auto-generated, it generates 26 functions for 17^2 'transformer' types: which is 7514 functions.  I could in theory make it work for 3 levels deep, but then we're at 127,738 functions, and probably a very large DLL (not withstanding the trouble that Visual Studio already has with the HKT files.\nOne thing that strikes me is that you could just use: TryOptionAsync<A> which is the equivalent to Task<Either<Exception, Option<A>>.  If you call ToEither on a TryOptionAsyc<A> then you get a Task<Either<Exception, Option<A>>>.\nSo you could have something to wrap your Error type in an Exception:\nc#\npublic class ErrorException : Exception\n{\n    public readonly Error Error;\n    public ErrorException(Error error) : base(error.Value) =>\n        Error = error;\n}\nThen some conversion extensions to make it easier to jump between your Either<Error, Option<A>> and Task<Either<Error, Option<A>>> and TryOptionAsync<A>:\n```c#\npublic static TryOptionAsync AsTryOptionAsync(this Either> ma) =>\n    ma.Match(\n        Right: r => TryOptionAsync(r),\n        Left:  e => TryOptionAsync(new ErrorException(e)));\npublic static TryOption AsTryOption(this Either> ma) =>\n    ma.Match(\n        Right: r => TryOption(r),\n        Left: e => TryOption(new ErrorException(e)));\npublic static TryOptionAsync AsTryOptionAsync(this Task>> ma) =>\n    ma.Map(either => either.AsTryOption()).ToAsync();\npublic static Error AsError(this Exception ex) =>\n    ex is ErrorException err\n        ? err.Error\n        : Error.New(ex.Message);\n```\n\nI used As... rather than To... to avoid clashing with the existing extensions.\n\nThen you can benefit from the plethora of async functionality attached to TryOptionAsync.  \nWhen you match on the type to extract either the Some, None, or Fail states you can use the AsError() extension to go back to your Error type:\n```c#\nvar m1 = Task.FromResult(Right>(\"Testing\"));\nawait m1.AsTryOptionAsync()\n        .Match(\n            Some: va => Console.WriteLine(va),\n            None: () => Console.WriteLine(\"none\"),\n            Fail: ex => Console.WriteLine(ex.AsError()));\n``\nAn additional benefit to this approach is that you can then nest theTryOptionAsynctoo, so for example:List(tryOptionA, tryOptionB, tryOptionC, tryOptionD), you can thenBindT,MapT,Sequence`, etc.  \n. Fixed in v2.1.18. @gregberns Hi Greg, this is a lifting discussion.  You have incompatible types in your LINQ expression.  LINQ expressions are C#'s equivalent to Haskell's do notation.  The idea is that for the whole expression each from sub-expression must have the same outer type.  So for Option<A> the outer-type is Option<> and the inner type is A.\nIn the first line of your expression you have:\nc#\n    from i in list\nlist is of type List<int>, the base monadic type is IEnumerable<int>.  \nIn your second line you have:\nfrom s in es(i)\nes(i) returns an Either<string, int>, which, although a monad, is not of the same type as IEnumerable<int>.  However Either<string, int> derives from IEnumerable<EitherData<string, int>>.  This is actually to facilitate serialisation/deserialisation with Json.NET;  normally an IEnumerable<> wouldn't be compatible with an Either<>.\nEitherData isn't much use to you here, because it's not a monadic type, it's just a data type.  So you want to find a way of either:\n1) Making every item in the expression have the same outer type, or\n2) Build a sub-expression that allows you to switch context (the context being the outer type).\nThis is the sub-expression approach, it's good because the original expression can easily be seen as having 'two halves': the first half in the IEnumerable<> context, and the second half in the Either<> context.\nc#\n    var r = from i in list\n            select from s in es(i)\n                   from t in et(i)\n                   select s + t;\nIt can be written fluently as:\nc#\n    list.Map(i => es(i).Bind(s => et(i).Map(t => s + t)));\nor,\nc#\n    list.Select(i => es(i).SelectMany(s => et(i), (s, t) => s + t));\n\nIts best to use Bind if you're going to use the fluent style, the version of SelectMany implemented for the various monadic types are a bit bulky for human consumption (I find anyway) and are merely there to facilitate LINQ \n\nThe other approach is Making every item in the expression have the same outer type.  Now that means we need to make the IEnumerable<> and Either<> types match.  So for the list data we want a IEnumerable<Either<string, int>>, and for the es() and et() functions we want them to return the same (or be lifted manually - which is what I'll do).\n```c#\n    var eitherList = list.Map(x => Right(x));\nvar r2 = from i in eitherList\n         from s in List(es(i))\n         from t in List(et(i))\n         select s + t;\n\nThe result of that is you get an `IEnumerable<Either<string, int>>`, which is to be expected, because that's the monadic type for the whole expression.  You can then extract the values:c#\n// Get all right values - IEnumerable\nvar rights = r2.Rights();\n// Get all left values - IEnumerable\nvar lefts = r2.Lefts();\n// Get a tuple of the lefts and the right values (IEnumerable, IEnumerable)\nvar (lefts, rights) = r2.Partition();\n// Flip the type to an Either> - which will return either the \n// first Left or an IEnumerable of Rights.\nvar succ = r2.Sequence();\n. @gregberns Oh, and btw, if you're not actually worried about the `Left` part of the result of `es()` and `et()`, and want the `Either` to be converted to an `IEnumerable<Right>`, then you can wrap them in `Seq(either)`:c#\nIEnumerable list = new List() { 1, 2, 3 };\nFunc> es = (i) => i;\nFunc> et = (i) => i;\nvar r = from i in list\n        from s in Seq(es(i))\n        from t in Seq(et(i))\n        select s + t;   \n``\nThat will result in anIEnumerable.  If any of theEithers are in aLeftstate then theIEnumerable` will be empty.. Hmm, I never intended it to be patronising, it was more a comment on how C# land is mostly populated by OO devs and that there is a definite expectation that libraries follow the BCL style.  \nI'm not against changing the wording, but I wonder if you've read a bit too much into it?  \nI'm open to feedback here, so I'll leave this for others to comment before making a final decision.. Going to close this down.  3 months on and nobody seems too bothered, so I'm going to leave it.  Thanks for the input though.  . > can you explain why the monadic approach here isn't working?\nSeems there was an issue in the bind for MTryOptionAsync, should be fixed in v2.1.23. @heemskerkerik Thanks Erik \ud83d\udc4d . @gregberns Thanks!. @gregberns Unfortunately I can't create types and methods on the fly, they need to exist at the time of compilation; and because each Deconstruct function has a different shape based on the type it's not possible to provide a standard implementation.. On my phone, so can't give a full answer, but just call .Sequence(), it\nwill flip the inner and outer monads.\nOn Sat, 26 Aug 2017 at 00:44, Greg Berns notifications@github.com wrote:\n\nI've been exploring the Validation class and have it working on\nvalidating a single item, but I want to validate each item in a list and\nreturn a single Validate item.\nExample: I have a list of numbers, and I want to validate each of their\nlengths is less than 5.\nFrom my understanding, the Error is actually a Seq which is appendable (a\nmonoid?).\nCan I get a Validate with any errors appended?\nI assume the type of Validation would also need to change from Validation to Validation> during this transition.\nvar list = new List() { \"1234\", \"12\", \"123456\" };\nvar ValidateString = fun((string s) => s.Length < 5 ? Success(s) : Fail(Error.New(\"Too long\")));\n// would like a Validation<Error, List<string>> back, with both sides aggregated.\nIEnumerable> validList = list.Map(t => ValidateString(t));\nIEnumerable> validList = from i in list\n                                                              select ValidateString(i);\npublic class Error : NewType\n    {\n        public Error(string e) : base(e) { }\n    }\nThe real use case is to take a list of emails, validate them, and return\nthe list, if thats of any value.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/259, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk5eZzZqDH41mUPespkJuvxPHXRTgks5sb1xvgaJpZM4PDREb\n.\n. The AsyncAsync naming troubles me.  Let me have a think about this.  \n\nI am in two minds about the Task.Run.  One one hand you wouldn't be making a Func asynchronous unless you wanted it to run asynchronously, so Task.Run makes sense.  On the other hand it could be that in reality its a convenience function for use in LINQ (which is probably what I really added it for - but my memory is letting me down today).\nI'm more of the mind to remove the constructor function altogether, because its effects are unclear.  More thought, I'll get back to you.. @pimier15 \nI'm not sure how much you know about the Writer monad, but its purpose is to collect information along with the result.  That information needs to be told to the writer using tell.  This can propagate through the monadic computation, and at the end you end up with two values: the bound monadic value and the aggregate data collected via tell.  The data can be aggregated because the Writer knows that it's working with a Monoid\nThis is an example using Seq<string> to collect the aggregate data.  The monoid instance used is MSeq<string>, the bound value is int.\n```c#\nvar computation = from x in Writer, Seq, int>(100)\n                  from y in Writer, Seq, int>(200)\n                  from _1 in tell, Seq>(SeqOne(\"Hello\"))\n                  from _2 in tell, Seq>(SeqOne(\"World\"))\n                  from _3 in tell, Seq>(SeqOne($\"the result is {x + y}\"))\n                  select x + y;\nvar result = computation();\nDebug.Assert(result.Value == 300);\nDebug.Assert(result.Output.Count == 3);\nDebug.Assert(String.Join(\" \", result.Output) == \"Hello World the result is 300\");\n``\nIf you [look at theMSeqimplementation](https://github.com/louthy/language-ext/blob/master/LanguageExt.Core/ClassInstances/Monad/MSeq.cs#L17) you will see it implementsAppendandEmptywhich is theMonoidinterface.  As you can seeEmptyis an empty sequence, andAppendis concatenating the sequences.  You can provide your own implementation ofMonoidand pass that to the writer to get your own behaviours fortell`.\nFor example:\n```c#\nvar computation = from _1 in tell(2)\n                  from _2 in tell(4)\n                  from _3 in tell(6)\n                  select unit;\nvar result = computation();\nDebug.Assert(result.Value == unit);\nDebug.Assert(result.Output == 12);\n``\nThis usesTIntas the monoid, whereEmpty()returns0, andAppend()` adds the numbers.  So it sums the results into a total.\nI could create a MProduct monoid, that calculates the product of the values instead of summing:\n```c#\nstruct MProduct : Monoid\n{\n    public int Append(int x, int y) =>\n        x * y;\npublic int Empty() =>\n    1;\n\n}\nThen I would get a different result:c#\nvar computation = from _1 in tell(2)\n                  from _2 in tell(4)\n                  from _3 in tell(6)\n                  select unit;\nvar result = computation();\nDebug.Assert(result.Value == unit);\nDebug.Assert(result.Output == 48);\n```\n. Yes, it works with properties as long as they're field backed properties.\nOn Fri, 1 Sep 2017 at 10:59, Brad Phelan notifications@github.com wrote:\n\nWPF doesn't like binding to fields.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/262, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk1Qymsb3hSUADiEE5E9_0qc_-3rUks5sd9WSgaJpZM4PJ81J\n.\n. @bradphelan The ordering is done first with fields then properties.  This is the function called to enumerate the members, so you could try it on your types to see how it will come out.  \n\n```c#\n        public static IEnumerable GetPublicInstanceFields(params Type[] excludeAttrs)\n        {\n            var excludeAttrsSet = toSet(excludeAttrs.Map(a => a.Name));\n            var publicFields = typeof(A)\n                .GetTypeInfo()\n                .GetAllFields()\n                .Where(f =>\n                {\n                    if (!f.IsPublic || f.IsStatic) return false;\n                    if (toSet(f.CustomAttributes.Map(a => a.AttributeType.Name)).Intersect(excludeAttrsSet).Any()) return false;\n                    return true;\n                });\n        var publicPropNames = typeof(A)\n                                .GetTypeInfo()\n                                .GetAllProperties()\n                                .Where(p => p.CanRead && p.GetMethod.IsPublic)\n                                .Where(p => !toSet(p.CustomAttributes.Map(a => a.AttributeType.Name)).Intersect(excludeAttrsSet).Any())\n                                .ToArray();\n\n        var backingFields = typeof(A)\n                                .GetTypeInfo()\n                                .GetAllFields()\n                                .Where(f => f.IsPrivate &&\n                                            publicPropNames.Exists(p => f.Name.StartsWith($\"<{p.Name}>\")))\n                                .ToArray();\n\n        return Enumerable.Concat(publicFields, backingFields);\n    }\n\n``\nYou could also use[OptOutOfOrd]to remove fields or properties from the ordering comparison .operation.. @bradphelan Thanks for that Brad!  That's very useful, and has been rolled intov2.1.20.  Note, if you're using NETCore then you will need to migrate tonetstandard 2.0asMetadataTokenis not available onnetstandard 1.3, so I had to update the whole project.  It was in the post anyway, asnetstandard 1.3` has gotten in the way a number of times.\nhttps://github.com/louthy/language-ext/releases/tag/2.1.20 . Because C#'s inference of functions is rubbish, you must specify the generic arguments for act if you want this to work:\nc#\nact<long, Unit>(fire);\nBasically C# has two types of functions:\n\nMethod groups\nFirst class functions (Func)\n\nMethod groups are not first class citizens like Func, they're not values.  \nTo show the proof of this, you could define your fire function thus:\nc#\npublic Func<long, Unit> fire = i =>\n{\n    return unit;\n};\nThen this wouldn't cause an error:\nc#\nact(fire);\nIt's something I've complained about before on the Roslyn project.  C# programmers shouldn't have any concept of method groups, as they're artefacts from the compiler.  The compiler should be able to resolve to a single valid method within the method group and use it, but unfortunately that's just a limitation we have right now.. Fixed in v2.1.19 on nu-get now.. The first item isn't lazy, no.  The rest is.  But yes, for memo it seems wrong.  . Didn't mean to close this.  Yes, I will come up with a solution.. @OlduwanSteve @StanJav This is fixed in v2.1.21\nIt required a bit of a refactor, and I did some additional work to make Seq more efficient in terms of memory.  All the unit tests pass, so I don't expect any problems, but it was quite a big change so just be a little wary and let me know if you see any issues. Gah!  Thanks \ud83d\udc4d . Thanks @Maximusya \ud83d\udc4d . @trbngr Hi Chris, it was covered in the release notes:\nhttps://github.com/louthy/language-ext/releases/tag/2.1.20. Surprisingly no, that is not in there yet.  The other monadic types use the || operator to achieve this, but because Try<A> is a delegate we can't do that.  \nSo for example with Option<int> you can do this:\n```c#\n    Option x = None;\n    Option y = Some(123);\nvar z = x || y;\n\n// z == Some(123)\n\nThe functionality already exists in the type-class instance for `Try<A>` called `MTry<A>`:c#\n    default(MTry).Plus(a, b);\nYou can implement your own extension trivially until I get a chance to do an update:c#\n    using LanguageExt;\n    using LanguageExt.ClassInstances;\npublic static class YourTryExtensions\n{\n    public static Try<A> Or<A>(this Try<A> self, Try<A> alt) =>\n        default(MTry<A>).Plus(self, alt);\n}\n\n```\n. On my phone, so apologies for the bad formatting/ errors:\nstatic Try Or(this TryOption self, Try alt) =>\nself.Match(\nSome: x => Try(x),\nNone: () => alt,\nFail: ex => alt);\nOn Fri, 22 Sep 2017 at 14:52, Mathias Birkkj\u00e6r Nielsen \nnotifications@github.com wrote:\n\nAnd then a follow up.\nI found that I actually could type it better with a TryOption.Or(Try)\nTo add a little context.\nThe first call is searching for a contact. That call could fail, hence the\nTry part. But it could also be \"not found\", hence the option part.\nIf it is not found, I will create it, hence the Or(Try) part.\nHow would I update my Extension to that?\n(Sorry, I find this orthodox functional style a bit more difficult than\nother functional libs i've tried...)\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/270#issuecomment-331452795,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkxhviVg7WmQclSUvEeju5IsAYafrks5sk7uZgaJpZM4Pe8Iv\n.\n. @mathiasbn Hi Mathias, a bit late, but this is fixed in v2.2.7-beta\n\nThere is now a choice function in the Prelude for Try, TryOption, TryAsync, TryOptionAsync, and Task.\nFor example:\n```c#\nvar ma = Try(() => throw new Exception());\nvar mb = Try(() => throw new Exception());\nvar mc = Try(() => 123);\nvar res = choice(ma, mb, mc);\nAssert.True(res.IfFail(0) == 123);\n`Plus` is available for chaining _OR_ operations.c#\nvar res = ma.Plus(mb.Plus(mc));\nObviously that's not quite as elegant as the `choice` approach.. @BrainCrumbzc#\n    Option result = queryable.HeadOrNone();\n```\nThere isn't currently an async version I'm afraid.. @BrainCrumbz \nThe full set of IQueryable<A> extensions and functions are here:\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/Extensions/Query.cs. Hi Timothy, which version are you running?  There was an earlier bug with\nInsert that has been fixed.  If it's the latest then I'll take a look as\nsoon as I can.\nOn Fri, 22 Sep 2017 at 16:51, Timothy Trewartha notifications@github.com\nwrote:\n\nPerhaps I'm missing something here but I am trying to update something in\na lst at a specified index. It works for index 0 and 1 but after that\nthings get a little strange. Here is a code snippet:\nLst lint = new Lst();\nlint = lint.Insert(0, 0).Insert(1, 1).Insert(2, 2);\nlint = lint.SetItem(2, 500);\nAfter running this the first item is 500, then 1 then 2 whereas I was\nexpecting 0, 1, 500.\nPlease advise! Also it only gets worse at higher indexes\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/272, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkxcTPhm3vOiWX_3YSCnaGwIQo9Wmks5sk9dngaJpZM4Pg5bq\n.\n. @timminata Ok, the bug I referred to was a while back, so this is new.  I will dig into it.  Although probably earliest will be Monday I'm afraid.. @timminata \n\nI just ran this code and it worked.  Do you have another example that fails?\n```c#\n        Lst lint = new Lst();\n        lint = lint.Insert(0, 0).Insert(1, 1).Insert(2, 2);\n    Debug.Assert(lint[0] == 0);\n    Debug.Assert(lint[1] == 1);\n    Debug.Assert(lint[2] == 2);\n\n    lint = lint.SetItem(2, 500);\n\n    Debug.Assert(lint[0] == 0);\n    Debug.Assert(lint[1] == 1);\n    Debug.Assert(lint[2] == 500);\n\n. @timminata Never mind, I have just seen it's the enumeration not direct access.  Leave it with me.. @timminata  I've found the issue.  It's just mixed up with a few other changes that I need to be a bit careful of.  As a temporary fix, avoid `SetItem`.  You can use this below until I can deploy:c#\n    lint = lint.RemoveAt(2).Insert(2, 500);\n``\n. This is now fixed on v2.1.22.  Sorry for the delay!. @bradphelan Unfortunately it's not as simple as that because it would mean splitting thePreludewhich removes the advantage that this library seeks - which is a simple functional prelude that can be included with oneusing`.  On a personal level I am also not particularly keen on making changes to this library to support other libraries that can't be bothered to update to the latest versions.  So I would suggest posting to the reactive-ui repo asking them when they're going to update.  . Thanks!. @orthoxerox Thanks for sharing, I haven't got an enormous amount of time to dig into it.  But, from a quick scan, I don't see anything relating to higher kinds?  It just seems to be refining the earlier proposal.  Am I missing something?. @orthoxerox From what I can tell (from my very brief look) is that there's still no way to parameterise a higher-kind.  Something like this:\nc#\n    public interface Monad<M<>, A>\n    {\n        M<B> Bind<B>(M<A> ma, Func<A, M<B>> f);\n    }\nAny thoughts on how a concept, instance, and associated type could work in that case?  The member return types for higher-kinded types are the biggest obstacle I find to a really robust solution (obviously the type-inference is problematic too).\nIn lang-ext right now I do this:\nc#\n    public interface Monad<MA, A>\n    {\n        MB Bind<MonadB, MB, B>(MA ma, Func<A, MB> f) where MonadB : struct, Monad<MB, B>;\n    }\n\nIt's more complex than that, but you get the idea.\n\nObviously, the problem with that is that even though the return type is constrained to be a monad, it's not constrained to the instance monad (so Option.Bind could return a Either, for example).\nI'll dig a bit deeper with this next week, maybe there's some cunning tricks that can be done to coerce the types.  \nI know you watch the Rosyln repo carefully, is there now competing approaches with shapes and concepts?  . I think too much has changed since this.  So, if you still feel strongly, please resub. > Is there a special reason why Lst does not implement ISeq?\nIn some ways I regret making ISeq.  The core idea was that Seq would be the 'root' type (which is borne out in the return types for the methods).  Seq can actually wrap Lst:\nc#\nvar xs = List(1,2,3);\nvar sq = Seq(xs);\nBehind the scenes sq is a SeqLst(xs), i.e. it maintains the Lst and gives it all the powers of a Seq.  This is very, very low cost, there's no major conversion going on, just an allocation of SeqLst.  \nThe main reason for doing this (creating SeqLst, SeqList, SeqArray, etc.) was to have a type that acted like IEnumerable but could also understand the underlying structures and make relevant optimisations.\nFor example Count doesn't need to use Head and Tail to loop through each item in the collection, it can make use of the fact that SeqLst already knows what the count of items are.   \nIt also deals with windows into the collections.  i.e  sq.Skip(5).Take(10) will return a new SeqLst(xs, 5, 10) which uses the same Lst as sq.  \nSo, yes the Lst type could implement Seq, but it wouldn't be able to carry those same optimisations as SeqLst;  well, it could, but I think the behaviour would be 'surprising'.\n. @NickDarvey I'll take a look.  btw, you can just use Sequence instead of Traverse(n => n).  Sequence is Traverse with identity.. Fixed in v2.1.25 on nu-get now.. It inherits all the mutable functionality of ICollection, which leaves lots\nof functionality with NotImplementedExceptions.\nThis is widely acknowledged as a mistake by the .NET team when they tried\nto bolt on read-only behaviour to collections.  I don't want to propagate\nit.\nOn Wed, 18 Oct 2017 at 09:41, Brad Phelan notifications@github.com wrote:\n\nIs there something about IReadOnlyDictionary that precludes this?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/280, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkwMXWekzoIZSFZfIIBufFYsPMUH4ks5stbmqgaJpZM4P9Wwb\n.\n. On v2.1.24 on nu-get now.. @bradphelan Thanks Brad, looks good \ud83d\udc4d . @cfiet Your second example doesn't make sense:\n```c#\n        public async Task SyncMethodReturingTaskShouldResultInFail()\n        {\n            var result = await Try(() => Task.FromException(new Exception())).ToAsync().Match(\n                Succ: _ => \n                    Option.None,\n                Fail: ex => \n                    Some(ex)\n            );\n\n        result.IsSome.ShouldBeTrue();\n        result.Some(e => e.ShouldBeOfType<TestException>());\n    }\n\nWhen I run it `ShouldBeTrue()` passes fine.c#\nresult.Some(e => e.ShouldBeOfType());\nThis is not doing anything at all.  It is only partially matching, you need to follow it with `.None(() => ...)` to run.  Or instead do:c#\nresult.IfSome(e => e.ShouldBeOfType());\n``\nThen there's the issue of testing againstTestExceptionwhen your example creates anew Exception()`.  \nI created my own test and everything works as expected:\n```c#\n    public static async Task Issue283()\n    {\n        var result = await Try(() => Task.FromException(new ArgumentException())).ToAsync().Match(\n            Succ: _ => Option.None,\n            Fail: ex => Some(ex)\n        );\n    Debug.Assert(result.IsSome);\n    result.Some(e => Debug.Assert(e is ArgumentException));\n}\n\n``\n. Fixed inv2.1.24on nu-get now.  NOTE:Removewill remove all matches rather than just the first one.. Fixed inv2.1.24` on nu-get now.. @bradphelan \n\ndoesnt that allocate and then deallocate a backing array every time you do\nthat?\n\nNope. MArr<A> is the 'class instance' for the Arr<A> data-type, it doesn't allocate anything, just calls: Enumerable.SequenceEqual(x, y). @bradphelan Added my own fixes for this, so closing.  Thanks for the heads up (Y).. It's default(MArr) not default(Arr) - the Monad/Eq/Ord type-class instance for Arr.\n\nOn 26 Oct 2017, at 20:23, Brad Phelan notifications@github.com wrote:\nno i mean that Arr is a struct but is backed by an array reference which\nneeds to allocate on heap. Therefore default(Arr) will allocate an array\nevery time it is called.\nOn Thu, 26 Oct 2017, 20:52 Paul Louth notifications@github.com wrote:\n\n@bradphelan https://github.com/bradphelan\ndoesnt that allocate and then deallocate a backing array every time you do\nthat?\nNope. MArr is the 'class instance' for the Arr data-type, it\ndoesn't allocate anything, just calls: Enumerable.SequenceEqual(x, y)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/287#issuecomment-339763629,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8pPlqyoNIl5sffOxkGOubkL8q-mCks5swNT_gaJpZM4P-0Dp\n.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n. I'll need a few days to take this in, I'm not massively keen on changing my deployment process at the moment, because it's pretty seamless which means I tend to get things deployed quickly.. Going to close this, as I'm not really looking to change my deployment process right now. Thanks @StefanBertels \ud83d\udc4d . Looks good, thanks!. @LubosBehensky Unfortunately not, this is more of a functional 'prelude' than a middle-ware library.  So it's more of a toolkit for building your own functional systems.  . @GiuseppePiscopo Hi Giuseppe, I haven't quite got time to look at this now, but I suspect it's because you're working with nested monads Task<Option< and Task<Either< and the higher-kinded LINQ provider is considering a failed inner monad of Task<Option< (which would be Task<None>) to also be a failed outer monad, and because a failed Task must have an exception, you get BottomException.  \n\nTake a look at these extensions that I wrote for a similar (probably the same) issue: https://github.com/louthy/language-ext/issues/242#issuecomment-318335885 . @bradphelan Hi Brad, I've been away for a week or so, so I'll take a look at this once my head is back in gear.. @bradphelan Hi Brad, sorry for the delay.  Map<K,V>, Map<OrdK, K, V>, Set<A>, Set<OrdA, A>, Lst<A>, Lst<PredA, A>, Lst<PredList, PredItem, A> now all support IComparable as well as the <, <=, >=, > operators.  So your records should also use those.. @chakming Looks like a cut n paste error.  Fix committed, will roll out tonight hopefully.. Fixed in v2.1.24 on nu-get now.. @sholland1 Yes it was intentional, it's very difficult to generalise the Haskell version of traverse.  When I get some more time I may look into trying to formulate it again (and the Traversable type-class).. @sholland1 btw, you can achieve the same behaviour with x.Map(a => Some(a)).Sequence(); although it's less efficient than bespoke traverse functionality obviously.. Thanks :). The Result type is meant as an intermediate value, so I'm probably not going to make it fully monadic.  If I were to do it I'd probably create a new type called TryStrict or something like that.\nBut you could add the extensions yourself:\n```c#\npublic static class ResultConstruct\n{\n    /// \n    /// Ctor function\n    /// \n    public static Result Result(A value) =>\n        new LanguageExt.Result(value);\n/// <summary>\n/// Ctor function\n/// </summary>\npublic static Result<A> Result<A>(Func<A> f)\n{\n    try\n    {\n        return Result(f());\n    }\n    catch (Exception e)\n    {\n        return new LanguageExt.Result<A>(e);\n    }\n}\n\n}\npublic static class ResultExt\n{\n    public static Result Map(this Result ma, Func f)\n    {\n        try\n        {\n            return ma.IsBottom\n                ? LanguageExt.Result.Bottom\n                : ma.Match(\n                    Succ: v => new Result(f(v)),\n                    Fail: e => new Result(e));\n        }\n        catch(Exception e)\n        {\n            return new Result(e);\n        }\n    }\npublic static Result<B> Bind<A, B>(this Result<A> ma, Func<A, Result<B>> f)\n{\n    try\n    {\n        return ma.IsBottom\n            ? LanguageExt.Result<B>.Bottom\n            : ma.Match(\n                Succ: v => f(v),\n                Fail: e => new Result<B>(e));\n    }\n    catch (Exception e)\n    {\n        return new Result<B>(e);\n    }\n}\n\npublic static Result<B> Select<A, B>(this Result<A> ma, Func<A, B> f) =>\n    ma.Map(f);\n\npublic static Result<C> SelectMany<A, B, C>(this Result<A> ma, Func<A, Result<B>> bind, Func<A, B, C> project) =>\n    ma.Bind(a => bind(a).Map(b => project(a, b)));\n\npublic static Unit Iter<A>(this Result<A> ma, Action<A> f)\n{\n    try\n    {\n        return ma.IsBottom\n            ? unit\n            : ma.Match(a => { f(a); return unit; }, _ => unit);\n    }\n    catch(Exception)\n    {\n        return unit;\n    }\n}\n\npublic static bool Exists<A>(this Result<A> ma, Func<A, bool> f)\n{\n    try\n    {\n        return ma.IsBottom || ma.Match(f, _ => true);\n    }\n    catch(Exception)\n    {\n        return true;\n    }\n}\n\npublic static bool ForAll<A>(this Result<A> ma, Func<A, bool> f)\n{\n    try\n    {\n        return ma.IsBottom\n            ? false\n            : ma.Match(f, _ => false);\n    }\n    catch(Exception)\n    {\n        return false;\n    }\n}\n\npublic static S Fold<S, A>(this Result<A> ma, S state, Func<S, A, S> f)\n{\n    try\n    {\n        return ma.IsBottom\n            ? state\n            : ma.Match(a => f(state, a), _ => state);\n    }\n    catch(Exception)\n    {\n        return state;\n    }\n}\n\npublic static Result<A> Filter<A>(this Result<A> ma, Func<A, bool> f)\n{\n    try\n    {\n        return ma.IsBottom || ma.IsFaulted\n            ? ma\n            : ma.Match(\n                Succ: a => f(a),\n                Fail: _ => false)\n                ? ma\n                : LanguageExt.Result<A>.Bottom;\n    }\n    catch(Exception e)\n    {\n        return new Result<A>(e);\n    }\n}\n\npublic static Result<A> Where<A>(this Result<A> ma, Func<A, bool> f) =>\n    ma.Filter(f);\n\n}\n``\nThen you can include it with:using static ResultConstruct` to get the constructor functions:\nThis will catch exceptions:\nc#\n   var x = Result(() => 123);\nThis is the simpler value ctor:\nc#\n   var x = Result(123);\nAll the LINQ operations and common functions are then available through the extensions.\nAnother option is to provide an extension to Try to force it to evaluate:\nc#\n    public static class TryExt\n    {\n        public static Try<A> Strict<A>(Try<A> f)\n        {\n            var r = f.Try();\n            return () => r;\n        }\n    }\nWhich you can call:\nc#\n   Try<A> x = ....;\n   var y = x.Strict();\nNOTE: That even though Try is lazy, it memoizes the result when evaluating, so even if you Match on it multiple times you'll only evaluate the expression once (which is the case for all of the functions that cause an evaluation).. @3dGrabber Updated the ResultExt type to catch all exceptions.. @BrainCrumbz The ValidateAsync code snippet works for me.  It calls the None branch as expected.  I'd suggest upgrading to the latest version 2.1.25.  Perhaps it was fixed with the previous bi-iter issue.. Yes, this was fixed.  So an upgrade will be required I'm afraid.. Hi Greg, thanks for this, I'll do my best to review this week\nOn Mon, 6 Nov 2017 at 04:46, Greg Wintering notifications@github.com\nwrote:\n\nHi Paul,\nI finally got enough time to finish this up and review it.\nI've now got a much deeper respect for your efforts in writing this\nlibrary; there are quite a lot of API functions for each monad.\nI'm still interested in your MType idea or any other way to hide the type\nparameter noise but that's probably a separate issue.\n244 https://github.com/louthy/language-ext/issues/244\n\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/louthy/language-ext/pull/300\nCommit Summary\n\nReintroduce RWS Monad\n\nFile Changes\n\nA LanguageExt.Core/ClassInstances/Monad/MRWS.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-0 (126)\nA LanguageExt.Core/DataTypes/RWS/RWS.Extensions.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-1 (208)\nA LanguageExt.Core/DataTypes/RWS/RWS.Prelude.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-2 (291)\nA LanguageExt.Core/DataTypes/RWS/RWS.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-3 (10)\nA LanguageExt.Core/DataTypes/RWS/RWSResult.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-4 (28)\nM LanguageExt.Core/DataTypes/State/State.Extensions.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-5 (2)\nM LanguageExt.Core/DataTypes/Writer/Writer.Extensions.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-6 (3)\nM LanguageExt.Core/DataTypes/Writer/Writer.Prelude.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-7 (3)\nA LanguageExt.Core/TypeClasses/MonadRWS/MonadRWS.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-8 (62)\nM LanguageExt.Tests/MonadTests.cs\n   https://github.com/louthy/language-ext/pull/300/files#diff-9 (44)\n\nPatch Links:\n\nhttps://github.com/louthy/language-ext/pull/300.patch\nhttps://github.com/louthy/language-ext/pull/300.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/300, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkzgv6bSYOFAT-9FMlTR4K76CKXrlks5szo8VgaJpZM4QSuyp\n.\n. @gwintering Hi Greg, fabulous stuff!  I'd probably prefer a few more tests and comments, but, to be honest with you, I don't mind too much as I understand how much just writing this stuff can turn your head inside out!  Thanks for the effort \ud83d\udc4d \nI've now got a much deeper respect for your efforts in writing this library; there are quite a lot of API functions for each monad.\n\nYep, I wish it could be simpler, but this the best approach I can think of that is type-safe.\n\nI'm still interested in your MType idea or any other way to hide the type parameter noise but that's probably a separate issue.\n\nI'll need to revisit that.  But I think, when we spoke about it originally, I tried some prototype ideas that didn't really work out.  I'm very time poor at the moment, so I'll have to come back to that later.\nPaul. Well spotted, thanks! . Thanks @OlduwanSteve . There is no support for Record inheritance (which is also the case in\nfunctional languages that have record data types). The best approach is to\nuse composition instead.\nOn Mon, 6 Nov 2017 at 15:46, SirUppyPancakes notifications@github.com\nwrote:\n\nHow does Record handle inheritance (if at all)? Consider:\npublic class Test : Record\n{\n    public int A { get; }\npublic string B { get; }\n\npublic Lst<string> C { get; }\n\npublic Test(int a, string b, Lst<string> c)\n{\n    A = a;\n    B = b;\n    C = c;\n}\n\n}\npublic class TestSub : Test\n{\n    public double D { get; }\npublic TestSub(double d)\n{\n    D = d;\n}\n\n}\nI am already a little nervous from something like this since the signature\nTest.Equals(Test) exists but not TestSub.Equals(TestSub). However, trying\nto get something unexpected to happen doesn't work. Consider:\nvar a = new Test(123, \"abc\", List(\"a\", \"b\", \"c\")) == new Test(123, \"abc\",\nList(\"a\", \"b\", \"c\"));\na is true.\nvar b = new TestSub(123, \"abc\", List(\"a\", \"b\", \"c\"), 123.456) == new\nTestSub(123, \"abc\", List(\"a\", \"b\", \"c\"), 123.456);\nb is true.\nvar c = new TestSub(123, \"abc\", List(\"a\", \"b\", \"c\"), 123.456) == new\nTest(123, \"abc\", List(\"a\", \"b\", \"c\"));\nc is false.\nvar d = new Test(123, \"abc\", List(\"a\", \"b\", \"c\")) == new TestSub(123,\n\"abc\", List(\"a\", \"b\", \"c\"), 123.456);\nd is false.\nDoes this mean that inheriting from Record, and then inheriting again is a\nvalid pattern?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/303, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk7Z-oiXZcGEgWeKOAuKcnm-V-S__ks5szynIgaJpZM4QTcCm\n.\n. Rolled out to v2.1.26. Thanks \ud83d\udc4d . @jmagaram > Forget .net native for a sec. Out of habit, I tried testing it with a class like the following. It does NOT work \n\nSaying something does not work, but without specifying what doesn't work isn't particularly helpful.  However the documentation is pretty clear:\n\nNote that only fields or field backed properties are used in the structural comparisons and hash-code building.\n\nBy providing your own implementations to the properties you are not using field-backed properties (even if you are actually backing them with fields manually).  Field backed properties have special names given by the compiler that the Record system can spot.  \nSo you can either use the second example, or:\n```c#\npublic class PersonC : Record\n{\n    public string FirstName { get; }\n    public int Age { get; }\npublic PersonC(string firstName, int age)\n{\n    FirstName = firstName;\n    Age = age;\n}\n\n}\n``\nWith regards to your .NET Native comment.  It seems the limitation is reflecting on 'private members of the .NET Framework class library'.  I guess the implication is that the meta-data from the core BCL isn't being included in native builds, whereas the meta-data for types within your project and third-party DLLs are.  Since the record system can't be retrospectively applied to a .NET Framework type (you can't makeDateTimeinto aRecord` for example) then this limitation doesn't seem important or relevant.  \nHowever if you want to see the code that gets the list of FieldInfo structures for a Record derived type, take a look here.\n. > I think the docs would be more clear if it said it works with \u201cpublic fields and public auto-implemented properties; private and protected members are ignored.\u201d\nSure, if it's unclear then I'm happy for the documentation to change.  If you want to do a pull request then I'll review.\n\nOne other thing. Fields are almost ALWAYS private. That is why I think clarification is helpful.\n\nIn your world maybe ;)\nRecords are very much meant to behave as record types in other functional languages - which are pure data types where all members are public.  So a type that is just pubic readonly fields is exactly the right behaviour (and was the only supported members on the original version, it has been expanded to work with field backed properties now).. It's by design.  Seq is a better IEnumerable for short sequences . @bradphelan I have added a similar disclaimer that's on the partial-application page to the bottom of the currying page.  \n\nNOTE: When using a method as an argument to par and curry you will need to provide the generic arguments that represent the arguments in the method being partially-applied or curried.  I have omitted them from the examples above for clarity.  No such limitation exists when using Func however.\n\nC# doesn't support inference with method-groups, even if there's a single method in the method group.  It's such a shitty situation.  Anyway, the best approach is to just provide the generic arguments.\nc#\n    var f = curry<int, int, Unit>(PrintTwoParameters);. You talk about 'the problem' without explaining what your problem is.\nPlease be explicit\nOn Tue, 21 Nov 2017 at 16:19, ggmueller notifications@github.com wrote:\n\nHi,\nit seems like there is a problem with Exceptions in a Match, when its\nthrown inside an async Action.\nThe unit test attached reproduces the problem.\nRunning in an application this problem also kills the problem, as it\ncauses an unhandled Exception on the ThreadPool.\nRegards Georg\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/louthy/language-ext/pull/309\nCommit Summary\n\nAdded test for async exception handling\n\nFile Changes\n\nM LanguageExt.Tests/OptionAsyncTests.cs\n   https://github.com/louthy/language-ext/pull/309/files#diff-0 (24)\n\nPatch Links:\n\nhttps://github.com/louthy/language-ext/pull/309.patch\nhttps://github.com/louthy/language-ext/pull/309.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/309, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk_P1W1y7DzyjZKyseN7eq_J2aEiqks5s4vgjgaJpZM4QmGuH\n.\n. This has been dealt with on the async overhaul.. @NickSeagull Your first example should work, and there should be no need to explicitly invoke Try() on result.   I'll re-open, because I'll need to check.. @NickSeagull Everything seems to work as it should.  Without seeing your definition of DeleteFolder I can't really dig much deeper.  But if it's defined like so:\nc#\n    static Try<Unit> DeleteFolder(string x) => \n        throw new DirectoryNotFoundException();\nThen yes, it will throw, because it's not a lambda.  It needs to be defined like this:\nc#\n    static Try<Unit> DeleteFolder(string x) => () =>\n        throw new DirectoryNotFoundException();\nThis is the full implementation I used to test:\n```c#\n    static Try DeleteFolder(string x) => () =>\n        throw new DirectoryNotFoundException();\n\nstatic Try<Unit> AccessDB(string x) => () =>\n    throw new ArgumentOutOfRangeException();\n\nstatic Unit PrintLine(string x)\n{\n    Console.WriteLine(x);\n    return unit;\n}\n\nstatic void Issue310()\n{\n    match(\n      from r in DeleteFolder(\"...\")\n      from s in AccessDB(\"...\")\n      select s,\n      Succ: (Unit _) => PrintLine(\"All correct\"),\n      Fail: (Exception e) => PrintLine(e.ToString()));\n}\n\n```. I'm not at a pc at the moment to check if this is a Lang-ext dependency\nissue or your one. But as a temporary solution have you tried an assembly\nredirect in your app.config/web.config?\nOn Thu, 30 Nov 2017 at 21:03, Charles Taylor notifications@github.com\nwrote:\n\nI'd like to start by saying, that I am very impressed with this library. I\nhope it can make functional programming more ubiquitous in C#.\nI am trying to get the Record functionality to work, but I'm getting the\nfollowing error whenever I run code code against a class which inherits\nRecord functionality:\nSystem.TypeInitializationException : The type initializer for 'LanguageExt.RecordType1' threw an exception.\n  ----> System.TypeInitializationException : The type initializer for 'LanguageExt.ClassInstances.Class1' threw an exception.\n  ----> System.IO.FileNotFoundException : Could not load file or assembly 'System.ValueTuple, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies. The system cannot find the file specified.\n   at LanguageExt.Record1.Equals(RECORDTYPE other)\n   at [MyProjectNameRedacted]:line 22\n--TypeInitializationException\n   at LanguageExt.IL.GetHashCode[A]()\n   at LanguageExt.RecordType1..cctor()\n--FileNotFoundException\n   at LanguageExt.ClassInstances.Class`1..cctor()\nI've double checked and I have the NuGet package System.ValueTuple 4.4.0\ninstalled. Am I doing something wrong? Is it likely I am missing some\ntransitive dependency?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/311, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk-EFBwIvEyIRrN_UbPxp_BsQfk9Pks5s7xgsgaJpZM4QxMq6\n.\n. This is fixed in v2.1.29.  Stupid bug, but there's at least a unit test for it now!. Validation is an applicative as well as a monad.  The applicative behaviour allows for collection of multiple failure values, the monad behaviour can only support one failure (so it behaves the same as Either).  That's because a series of from statements in LINQ requires each one to be evaluated before moving onto the next one.  So:\n\nc#\n var z = from x in FuncThatReturnsX()\n         from y in FuncThatReturnsY()\n         select x + y;\nIf FuncThatReturnsX fails then x can't possibly have a value and so if I allowed the monadic expression to continue then the final select x + y would be using undefined values.\nWith applicatives you can imagine that all the values are being calculated in parallel (they're not, but the point is that each expression isn't dependent on any of the others - whereas clearly the select x+y is dependent on the two from expressions above it).\nIn example you can do this:\nc#\n    var z = (FuncThatReturnsX(), FuncThatReturnsY()).Apply((x, y) => x + y);\nSo in your case you can do this:\n```c#\npublic static void ValidationTests()\n{\n    int num = 0;\nvar validNum = (ValidateNonZero(num), ValidateBiggerOne(num)).Apply((_, n) => n);\n\nvalidNum.Match(\n    Succ: i => WriteLine($\"result: {i.ToString()}\"),\n    Fail: errors => errors.Iter(e => WriteLine($\"error: {e.Message}\")));\n\n}\nstatic Validation ValidateNonZero(int i) =>\n    i == 0 \n        ? Fail(new TestError(\"no zero!\")) \n        : Success(i));\nstatic Validation ValidateBiggerOne(int i) =>\n    i > 1\n        ? Success(i))\n        : Fail(new TestError(\"must be bigger than 1\")) ;\nAlso because `ValidateNonZero` and `ValidateBiggerOne` are not transforming the valid result (it's leaving the integer alone), and they're both of the same type, you can do this:c#\n    from _ in ValidateNonZero(num) | ValidateBiggerOne(num)\n    select num\nOr you could compose them into a reusable operation:c#\n    Validation ValidateNumber(int num) =>\n        ValidateNonZero(num) | ValidateBiggerOne(num);\n``\nThe|` operator will give you all failure values or the first successful value if all terms are successful.\nThere's some pretty good unit tests for this which shows a real-world-ish example.. Hi @NickDarvey , there's always been pairs of monads that Sequence and Traverse wouldn't play nice with because Sequence and Traverse are extension methods implemented using a default implementation from the Trans type.  That default implementation works for almost all pairs of monads, but will always struggle when the inner type is a sequence.  \nI have updated the HKT extension methods for Sequence and Traverse to work with two types: Trans and SeqTrans.   SeqTrans deals with the inner type being an enumerable of some sort (Set, Seq, HashSet, IEnumerable, etc.).  This should resolve your issue.\nIf you want to understand a bit deeper, then it's worth digging into what Traverse and Sequence do for TryAsync<IEnumerable<string>>.  \nIf I break it down and replace the types:\nc#\nvar state = default(MEnumerable<TryAsync<string>>).Return(default(MTryAsync<string>).Zero());\nWhat ^^ this does is create the initial state for the operation.  This is actually where all the problems come from.  It's the default behaviour of MEnumerable.Return(MTryAsync.Zero) which means the outer-monad is always returning a value state, even though the inner monad is returning Zero.  For our pair of types that means we always return a one item enumerable with a TryAsync in a bottom state.\nSo for Seq<Option<A>> it would be: MOption.Return(MSeq.Zero) which makes sense, but for Option<Seq<A>> it doesn't MSeq.Return(MOption.None).\nIf we follow on, we can see this state is used with a MTryAsync.Fold operation.  That Fold operation won't run if the TryAsync is in a failed state (which it is), and so it returns state - which is the enumerable with a TryAsync in a Bottom state.\nc#\ndefault(MTryAsync<IEnumerable<string>>).Fold(GetNumbersPoorly(), state, (outerState, enumerableA) =>\n    Trans<MEnumerable<TryAsync<string>>, IEnumerable<TryAsync<string>>, MTryAsync<string>, TryAsync<string>, string>.Inst.Plus(\n        outerState,\n        default(MEnumerable<string>).Bind<MEnumerable<TryAsync<string>>, IEnumerable<TryAsync<string>>, TryAsync<string>>(\n            enumerableA, \n            a =>\n               default(MEnumerable<TryAsync<string>>).Return(default(MTryAsync<string>).Return(a)))));\nThe way I've fixed it is for all operations where the inner type is an enumerable in instead uses SeqTrans, which if you look at its starting state, it's default(NewOuterMonad).Zero(). By the way, your 'expected' behaviour of:\nSystem.AggregateException: One or more errors occurred. (uhhh) --->\nSystem.InvalidOperationException: uhhh\n\n...isn't what you'll get.  Calling Sequence on a TryAsync<IEnumerable<A>> that's in a failed state will return an empty IEnumerable<TryAsync<A>>.  If you then call Sequence on that again then you'll have a successful TryAsync<IEnumerable<A>> where the inner IEnumerable<A> is empty.\nAnother thing I notice is you're calling new TryAsync all over the place, and writing: new Result(....  You can use the TryAsync function in the prelude or just throw an exception for failure.  For example, your IsNotFour function could be written thus:\nc#\n    static TryAsync<string> IsNotFour(string number) =>\n        number != \"four\" \n            ? TryAsync(number)\n            : TryAsync<string>(() => throw new ArgumentException(\"Nope\"));\n. @bradphelan Get v2.1.32\nYou can either use the IgnoreBase attribute:\n```c#\n[IgnoreBase]\npublic class SubClass2 : BaseClass, IEquatable, IComparable\n{\n    public readonly int Y;\npublic SubClass2(int x, int y) : base(x) =>\n    Y = y;\n\npublic int CompareTo(SubClass2 other) =>\n    RecordType<SubClass2>.Compare(this, other);\n\npublic override bool Equals(object obj) =>\n    RecordType<SubClass2>.Equality(this, obj);\n\npublic bool Equals(SubClass2 other) =>\n    RecordType<SubClass2>.EqualityTyped(this, other);\n\npublic override int GetHashCode() =>\n    RecordType<SubClass2>.Hash(this);\n\n}\nOr, control behaviour on a per-operation basis by using `RecordTypeIgnoreBase` instead of `RecordType`:c#\npublic class SubClass1 : BaseClass, IEquatable, IComparable\n{\n    public readonly int Y;\npublic SubClass1(int x, int y) : base(x) =>\n    Y = y;\n\npublic int CompareTo(SubClass1 other) =>\n    RecordTypeIgnoreBase<SubClass1>.Compare(this, other);\n\npublic override bool Equals(object obj) =>\n    RecordTypeIgnoreBase<SubClass1>.Equality(this, obj);\n\npublic bool Equals(SubClass1 other) =>\n    RecordTypeIgnoreBase<SubClass1>.EqualityTyped(this, other);\n\npublic override int GetHashCode() =>\n    RecordTypeIgnoreBase<SubClass1>.Hash(this);\n\n}\n```. >  I couldnt find those before\nIt didn't exist before, I added it to v2.1.32 ;). Fixed in v2.2.6-beta. You're both right for different reasons.  Yes, the quick fix would be to asyncify the code.  But what I've actually started doing is looking into breaking Monad apart into Monad and MonadAsync.  The attempt to unify the two has lead to a slightly messy interface and compromises like this implementation of Fold for MTask; it should be FoldAsync that returns a Task.\nI have a busy few days coming up, but hopefully I should have something by the end of the week.. @faeriedust @bender2k14 Just a heads up on the progress of this.  The work is being done on the async-refactor branch, it's becoming quite a large refactor that will almost certainly lead to a significant improvement for the async story.  \nHere's the first commit to give you an idea of the scope of the changes: https://github.com/louthy/language-ext/commit/96e83efbbd398575b5b5cab1f763c7b6b1edbe88\nThe unfortunate knock-on effect is with the transformer types (nested monads).  Synchronous and asynchronous monads are not directly compatible with each other now, and so I've split the HKT t4 templates to generate the extension methods for async-async pairs and sync-sync pairs.  \nThe main issue with that is something like Lst<TryAsync<A>> won't get the transformer extension methods.  This will definitely cause problems for users of the library, so I'm just looking into ways to still pair up sync and async types where it makes sense.  It should be a solvable problem, just needs a bit more thinking time.. @bender2k14 @faeriedust The latest release deals with the issue above in that default(MTask<int>).Fold does not exist any more and won't exist for any asynchronous type.  Calling default(MTask<int>).FoldAsync exhibits the behaviour you'd expect.. @bender2k14 Actually that's an oversight.  I started by making all async interfaces have ...Async methods.  But then after hitting some issues where the C# compiler just can't work out the difference between an A and a Task<A> I started using ...Async just for higher-order functions that have a asynchronous Funcs or return a Task<A>.  \nI've been so knee deep in the transformer system that I will probably need to review all the naming before pushing it to beta status.  Initially I wanted to avoid issues with a type implementing both the sync and async interfaces for say Monad or Functor.... the requirements slightly changed as I was going along. \nI think the final policy will be:\n If the method returns a Task then append Async.  That allows for say a synchronous int Sum() and an asynchronous Task<int> SumAsync() for example.\n If the method is a higher-order method and the delegate argument returns a Task then Async is appended.\nPossible policy: \n\nUse a naming convention for delegate arguments, so devs could specify the name of the argument they're providing, if it's unique then it will trump the type system (something like Sync or Async).  i.e. value.Map(Sync: x => x + 1);.  This would help for methods like BiMap where there are four possible variants.  Something like: value.BiMap(LeftSync: x => x + 1, RightAsync: y => y + 2);\n\nThis will be a be consistency issue throughout the code-base I expect (from pre-existing async functionality).  So, it will need some time to iron all of that out.  It's a good time to get this stuff done and out of the way (because of the other breaking changes).\nOn your second point - you could be right, I don't have the code in front of me at the moment (about to hit the hay after looking at a screen for too long).  If they unify then that would certainly be a benefit.. > I would typically think of handing that by lifting one delegate to return a Task<> to match the other delegate and then calling the overload that takes two delegates that returns Task<>.\nThere's an additional allocation cost which would be saved by using named arguments.  Where possible I try to reduce unnecessary allocations - not that this library is particularly light on the allocations front, but I try to minimise them where I can.  \nI think also there's the real-world use-case to consider.  Often with choice types where they're bi-mappable, or bi-foldable, the 'alternative' value is used for the error case (not always, obviously, but mostly).  I suspect that the most common usage is for choice 1 to be asynchronous where choice 2 would be synchronous (perhaps just giving context to an error value for example).  Choice 1 is the 'happy path' where all the heavy lifting is happening.\nThere is also already precedent for using named arguments for Match and the like, so I'm comfortable with using them to aid the selection of the correct overload.\nHowever, having said all of that, I wanted to clear some ideas through my head first, so I'm not just arguing from a preference point-of-view, but from a 'good for the library' point-of-view.\nThink about this situation:\n```c#\n    static async Task AddValue(int x) =>\n        x + await GetValue();\nstatic Error AddContextToError(Error err) =>\n    err.AddSomeContext();\n\n ma = ma.BiMapAsync(RightAsync: AddValue, Left: AddContextToError);\n\n``\nThat has a certain amount of elegance to it because it's not cluttered with lambda grammar.  It also has no additional allocation costs over what theAddValueandAddContextToError` functions use in their implementations.\nIf BiMapAsync only took Task<R> and Task<L> then the Left side would have to be lifted:\nc#\n     ma = ma.BiMapAsync(Right: AddValue, Left: err => AddContextToError(err).AsTask());\nThat instantly becomes much less elegant.  There is also an allocation for the lambda and for the Task.  Finally, there's the cost of constructing a Task - probably negligible, but but if the Left type is a value-type then we're essentially boxing something that doesn't need boxing.  \nI took the thought experiment a bit further to see if I could provide some improvements on the elegance front, by providing some common lifting functions:\n```c#\n    static Func> liftTask(Func f) =>\n        () => f().AsTask();\nstatic Func<A, Task<B>> liftTask<A, B>(Func<A, B> f) =>\n    a => f(a).AsTask();\n\n// ... etc ...\n\n``\nThese would work likefunoractbut instead they would lift the synchronous function so it could be used in the various async methods.  However, it suffers from the exact same problems asfunandact` and that is C#'s terrible handling of method-groups.  The type system refuses to infer the correct method, even when there is only one possible candidate.  \nAnd so, what should be this:\nc#\n    ma = ma.BiMapAsync(AddValue, liftTask(AddContextToError));\nWhich has the elegance.  Instead ends up like this:\nc#\n    ma = ma.BiMapAsync(AddValue, liftTask<Error, Error>(AddContextToError));\nWhich is ugly.  It also suffers from the same allocation problem as providing a lambda.  \nHopefully one day C# will treat methods in method-groups as first-class citizens and provide a decent inference story, but I'm not holding my breath.  In the meantime I feel the named arguments approach is likely to make life easier for devs.\n\nHowever, I don't like the idea that the name of any method that returns a Task should end in Async. For example, I don't think the extension method AsTask that lifts an A to an Task should be called AsTaskAsync.\n\nI think I mostly agree here.  Context is important.  For example, Match in EitherAsync returns a Task<R> but has no delegates that return a Task.  The type EitherAsync by default makes all operations on it asynchronous.  So, it makes sense for Match to not have Async appended.  \nHowever, that general rule falls apart slightly for the ToString and GetHashCode overrides on EitherAsync.  They can't have their names or signatures changed (because they're inherited from Object) and they will force synchronous evaluation.  I have provided ToStringAsync and GetHashCodeAsync, but that's immediately breaks the rules set above.  \nIdeally the rules wouldn't have too many caveats so they can be easily followed and maintained.  I'm working through the interfaces this evening, so I'll try and come up with a concrete set that works for all types.\n. > I like your change from last night\nYeah, it's starting to feel right.  I still need to go through the other async types (TryOptionAsync, TryAsync) and update them as well as the async extensions for Option and TryOption.  This is one of those 'by convention' things that will just need a bit of time and care to refine.\n\nSo this method MapAsync is lies on the interval between Map and Bind.\n\nI know why you say that, but I see the Async variants more as artefacts of C#'s strict evaluation and less of a 'sliding scale of Map and Bind'.  \nIf values were lazy like Haskell then I wouldn't need to litter the code with Task<...> and the implementations of Map and Bind could deal with the asynchronous behaviour transparently.  Unfortunately C# doesn't work that way and so we end up with async polluting the function signatures too.   So, although MapAsync and BindAsync isn't a purist definition of a functor map and monad bind operation, the end result is still a functor map operation and monad bind operation, just with asynchronous behaviour.\n\nLooking at TryOption<> though, I don't see any method that accepts just one argument that is either Func<A, Option<B>> or Func<A, Try<B>>.\n\nI wouldn't expect that though.  They are not the definition of Map or Bind.  TryOption has:\n\nTryOption<B> Map<A, B>(this TryOption<A> self, Func<A, B> f)\nTryOption<B> Bind<A, B>(this TryOption<A> self, Func<A, TryOption<B>> f)\n\nI would expect the dev to lift any Option or Try into a TryOption to use with the standard Bind operation.\nc#\n   var x = TryOption(Some(123));\n   var y = Try(123).ToTryOption();. @abdulkaderjeelani You're looking for the Validation type in language-ext to implement the example.  I won't do all the work for you, but you can take a look at one of the units tests which has a real-world example of using the applicative behaviour of the Validation type. \nMost of the core types in language-ext support applicative behaviour through the apply function.. @bender2k14 What's the justification for this?  Visual Studio injects the type-params there by default (and not on the method).  It would be an enormous job to change this for the whole project.  So for consistency it seems better to leave them where they are, because the type-params are type arguments, not method arguments.  \nI think it's especially true for Functor which is a 'class-instance' - i.e. the type is pretty much part of the method definition too.\n. So sorry, I just realised I was arguing the wrong way around.  Yes, it's wrong that they're attached to the method.  For some reason my quick scan of the changes gave me the impression you were moving the typeparams to the method, not from it to the type.\nThis is almost certainly a legacy of when I was trying various approaches to the type-class system and the generic params were part of the method.  . That is intentional as all types (apart from Task<T>) are owned by lang-ext.  It means users get the functionality hanging off the types without having to have using LanguageExt in their code.  The Task<T> global extensions are arguable - but as Task<T> isn't something one would de-reference too often, I felt providing those extensions and the LINQ operators was a bigger convenience win over the pollution of intellisence.\n\nchange behavior of compiler\n\nWhat do you mean by this?  How does it change the behaviour?\n. @ijsgaus I have pinged Phillip Carter on the F# team - this looks like an F# compiler issue to me.  Although I normally don't like to point fingers at compilers, there's nothing in that code which has any relation to lang-ext from what I can tell.. Thanks, that's great stuff \ud83d\udc4d . Good stuff \ud83d\udc4d . Rejecting this.  The point of the Prelude is to have a single static type that devs can include to get the constructors for all the key types.  This makes discovery harder and will break everybody\u2019s builds. . Apologies, reading on my phone - probably didn\u2019t look properly.  I\u2019ll take a look tomorrow when the \u2018Christmas cheer\u2019 has worn off ;) . I've read it properly now.  Thanks \ud83d\udc4d . Sorry, I thought it was just the name change.  I see you've moved the Check type now.. Purely elegance and sometimes to match naming in F#.  I don't want any of them renamed.  But, new functions should be camelCase where possible (as long as it's the most elegant, but I can make a judgement on commits). The second one is a bug.  There\u2019s not a one size fits all policy, but in this case it\u2019s reasonable for use to return null and so it should be protected against in the finally clause.\nData types in general don\u2019t allow null values unless they have the Unsafe suffix.  . Fine with me \ud83d\udc4d . > Is there a reason that these monad types have some kind of use method while others (such as Option<>) don't?\nMostly because the types you list are all delegates, the idea is you can inline a computation as an expression that you couldn't normally do with use(...) { ... }.  By the time an Option exists the computation has been done (although since that decision was made Option also supports lazy evaluation).\nThere is another issue open about whether Option (and other types) should derive from IDisposable.  I'm truly undecided whether that's actually a good idea or not.  But obviously if it did then use<T, R>(T disposable, Func<T, R> f) would work for Option types.\nOne thing that has crossed my mind is that tooling like ReSharper might complain about values not being disposed properly, so that would need to be considered.  I don't use it, so I'm not sure if it would start throwing out warnings, but from what I've seen of it before, I wouldn't be surprised.. >Int32.TryParse becomes parseInt,\nsometimes the TryParse method is referenced from the class (such as Int32 in the above example) and sometimes it is from the alias keyword (such as in the example \"bool.TryParse becomes parseBool).\nNot sure what you're referring to here, that quote isn't related to the link.  Anyway, they're both aliases: int and bool, it's not using Int32 or Boolean.  So, aliases are the preferred approach.  If you want to add parseSByte, go ahead.  . Thanks \ud83d\udc4d . It's based on common real world usage.. Yep, bit of an oversight there.  Fixed.. > Is there a reason that reflection is used here instead of the factory method pattern?\nGood luck trying to make a virtual static method ;)  You can't have an abstract Create method when you don't have an instance to call it on.. They\u2019re dead, I replaced dropped support for the ImmutableCollections, so\nthat can go\nOn Sun, 31 Dec 2017 at 01:52, bender2k14 notifications@github.com wrote:\n\nIn main documentation for this project at the end of the section about out\nparameters\nhttps://github.com/louthy/language-ext#the-awful-out-parameter, it says\nthat extension methods exists for\n\nIImmutableDictionary.TryGetValue\nIImmutableSet.TryGetValue\n\nthat return Option. However, I can't find these methods anywhere. The\nother two extension named TryGetValue that return Option<> are defined in\nTryOutExt.cs\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/Extensions/TryOutExt.cs\n.\nWould you like these extensions added to match the documentation or change\nthe main documentation to match the code?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/336, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk1jZLyjWNypLhIVgI28HCe4-7TQeks5tFuj2gaJpZM4RPvsr\n.\n. Not really.  FA and FB are just data-types, and you can use any data-type you like as long as FA can be mapped to FB with a Map function that takes a delegate of Func<A, B>.  \n\nIt's not trivial to implement the Map function when FA isn't F<A> and FB isn't F<B> (other than something that just throws an exception).  So, the Map function is pretty much the constraining force here.\nIt's not ideal, but I think it will always be a bit of a rubbish solution without higher-kinds in C#.\n. \ud83d\udc4d . The race is a feature.  They provide something over the other operators.  There is no 'right' way to implement Plus, each type can use its own decision making to combine the result - so the fact they don't match their sync counterparts is irrelevant (and actually a benefit).  There are real benefits to taking the first successful result.\n. @gwintering Hi Greg, I've decided to relent on this one.  I have made the default behaviour of MTryAsync.Plus, MTryOptionAsync.Plus, and MTask.Plus to what you suggested.\nAs well, I have:\n Added MTryFirstAsync, MTryOptionFirstAsync, and MTaskFirst.  It seems sensible to make use of the ad-hoc polymorphic system to give the option to the programmer.  These class-instances use the previous behaviour of racing to the first value.\n Added Plus and PlusFirst extensions to TryAsync, TryOptionAsync, and Task. \n* Added plus and plusFirst to the Prelude for TryAsync, TryOptionAsync, and Task. \nThis is in the v2.2.4-beta release.. @Saikyun The nu-get packages contain DLLs for .NET 4.5.1 - they should work on any .NET 4.6 compatible system too.  Have you tried those?. @sne11ius The library isn't built for Unity.  I am not aware of the restrictions of Unity and therefore won't be spending any time looking into it.  It would make more sense to find answers on Unity forums or to find someone who understands the issues that Unity has in building lang-ext.  If, as implied in the first question, Unity is still only C# 6 compliant then you're right out of luck - as I am not willing to compromise this project to support the legacy language, sorry.  If the binaries (DLLs) are incompatible with Unity projects, that's a Unity issue.\nWhen @mnn askes \"I have no clue if this is a problem with this library or with Unity\" - I can quite easily confirm: it's Unity that's the problem.  This project builds and links when used with the official C# compiler, runtime, and framework.\n. @quabug  Thanks for the update, that's very useful.  I have added a slightly reworded version of your comment to the home page.  . It\u2019s a bug, I\u2019ll take a look when I can.\nOn Mon, 8 Jan 2018 at 17:00, Oliver Hanappi notifications@github.com\nwrote:\n\nI would expect the expression Result.Bottom.IsBottom to return\ntrue, however it returns false. I do not know if this is by design or\nnot, however I think it is pretty unobvious.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/341, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk1tDZAK5B4QCQrbHMhCSgb5E1V-xks5tIkmdgaJpZM4RWqQS\n.\n. If you mean matchAsync rather than MatchAsync, then sure.  But make the change in the async-refactor branch as that's where all the latest changes are.  You'll need to create variants for MatchUnsafeAsync too.\n\nNote that (although I haven't yet done this for Option.MatchAsync) the delegates for Some and None should be called SomeAsync or NoneAsync if the delegate return a Task.. Thanks for the commit, I took a slightly different path.. @faeriedust The reason for the Count function existing is legacy.  The HKT template system previously relied on a consistent set of functions being implemented per-monadic type.  This allowed for the transformer functions to be generated reliably.\nThe requirement for it to exist now isn't as great because of the MonadTrans implementations that do all of the transformer work now.  \nAnyway, I have already updated this function in the async-refactor branch\nI won't be dropping the function as I don't agree that there should be any confusion with Task<IEnumerable<A>> - if you want to count the items in the inner IEnumerable you should call the transformer variant: CountT():\n```c#\npublic static Task CountT< A>(this Task> ma) =>\n    default(TransAsyncSync>, Task>, MEnumerable, IEnumerable, A>).Count(ma);\n```. I don\u2019t know why you\u2019re confused. CountT is the transformer version of\nCount. Task> is a transformer type - so if you want the\ncount of items in the enumerable use CountT.\nOn Mon, 15 Jan 2018 at 23:30, Elijah E Kohrt notifications@github.com\nwrote:\n\nI don't understand how .CountT helps with the above issue.\nIf it's an IEnumerable<>, then I should call .Count(), and it behaves\ncorrectly.\nIf it's a Task>, then .Count() silently returns me a\ngarbage answer. If I notice this, I can call .CountT() sure, but I didn't\nnotice at all, so this clearly wasn't an option.\nIn particular, I had someone writing tests for me, and they didn't notice\nthat it was returning a Task, and just called .Count()\nwithout looking at the types (assuming it was IEnumerable<>), and they even\nhad several tests passing with this mistake before we noticed anything.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/344#issuecomment-357812052,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk3Fw0OwZICn5-tFRp5ubDTBVSYU8ks5tK9-PgaJpZM4Rbh38\n.\n. I don't think thread-safeness is important here.  It will be such a minor issue in the use-case of TryAsync and TryOptionAsync that the occasional double evaluation is acceptable.  The user can obviously use locks if they want to enforce thread-safety - and I'm fine with that.\n\nThanks for the work here @gwintering - could you do a pull request (from the async-refactor branch)?. The code works for me on .NET 4.6.1.  Please make sure you're on the latest build - as I can't see how static field initialization would have any bearing on this issue.  \nPlease comment or re-open if you still have issues.. @StefanBertels  Thanks Stefan \ud83d\udc4d . @alaendle There is no issue with Writer  - you can't use incompatible monads in the same LINQ expression.  That's also the case in Haskell.  It's clear from your Haskell example that the multWithLog function is using the Writer monad all the way through, but to work with the [Int] sequence that's inputted it uses let c = ... which is a non-monadic operation.  The fmap is projecting the sequence of ints into a sequence of Writers which then are flipped using sequence to make a Writer of sequence (this is trick 3 that @gwintering mentioned).\nThis is the code in lang-ext:\n```c#\nstatic Writer, Seq, int> writer(int value, Seq output) => () =>\n    (value, output, false);\nstatic Writer, Seq, Seq> multWithLog(Seq input) =>\n    from _ in writer(0, SeqOne(\"Start\"))\n    let c = input.Map(i => writer(i * 10, SeqOne($\"Number: {i}\")))\n    from r in c.Sequence()\n    select r;\n```\nI think you'll agree it looks pretty close to the Haskell version.\nYou can run it with:\n```c#\npublic static void F()\n{\n    var (value, output, faulted) = multWithLog(Seq(1, 2, 3))();\nDebug.Assert(value == Seq(10, 20, 30));\nDebug.Assert(output == Seq(\"Start\", \"Number: 1\", \"Number: 2\", \"Number: 3\"));\n\n}\nThe one thing that's missing is the `Sequence` implementation for the `Seq<Writer<..>>` pair.  `Sequence` exists for most monad pairs in lang-ext, but it's not yet been done for `Writer`, `Reader`, `State`, or `RWS`.  But you can add the extension yourself and it will work as expected:c#\npublic static class WriterSeqExt\n{\n    public static Writer> Sequence(this Seq> ma) where MonoidW : struct, Monoid => () =>\n        ma.FoldBack((Value: Seq(), Output: default(MonoidW).Empty(), IsBottom: false), (s, w) =>\n        {\n            if (s.IsBottom) return s;\n            var (a, output, bottom) = w();\n            if (bottom) return (Value: Seq(), Output: default(MonoidW).Empty(), IsBottom: true);\n            return (Value: Prelude.Cons(a, s.Value), Output: default(MonoidW).Append(output, s.Output), IsBottom: false);\n        });\n}\n``.SequenceandTraverseadded for sequences ofReader,Writer,State, orRWS` monads:\nhttps://github.com/louthy/language-ext/releases/tag/v2.2.2-beta. @alaendle I have made a couple more improvements to the Writer API to make writing the code in your example a bit easier.\nThis isn't needed any more:\nc#\nstatic Writer<MSeq<string>, Seq<string>, int> writer(int value, Seq<string> output) => () =>\n    (value, output, false);\nThe Writer constructor previously only accepted the bound value (int value) and would use the MonoidW.Empty() as the seed for the writer output.\nNow you can construct any writer like so:\nc#\nWriter<MSeq<string>, Seq<string>, int>(0, Seq1(\"Start\"));\nThat allows for a sequence of strings to be collected for the output and an int as the bound value.  You're not limited to Seq<A> though, you can use any monoid.  Here we'll use a string as the output value:\n```c#\nvar ma = from _1 in Writer(unit, \"\")\n         from _2 in tell(\"Hello\")\n         from _3 in tell(\", \")\n         from _4 in tell(\"World\")\n         select unit;\n// ma().Output == \"Hello, World\";\nAnd here we'll use the `Product<NumA, A>` monoid to find the product of all outputted values:c#\nvar ma = from _1 in Writer, int, Unit>(unit, 1)\n         from _2 in tell, int>(2)\n         from _3 in tell, int>(4)\n         from _4 in tell, int>(10)\n         select unit;\n// ma().Output == 80;\n``\nHowever, because collecting a sequence of values is likely to be the most common usage of Writer, and the overhead of typing the generic arguments is pretty painful, I have added some convenienceWriterconstructors andtell` functions.  \nSo, going back to your example, you can now do this:\nc#\nstatic Writer<MSeq<string>, Seq<string>, Seq<int>> multWithLog(Seq<int> input) =>\n    from _ in Writer(0, Seq1(\"Start\"))\n    let c = input.Map(i => Writer(i * 10, Seq1($\"Number: {i}\")))\n    from r in c.Sequence()\n    select r;\nInstead of:\nc#\nWriter<MSeq<string>, Seq<string>, int>(0, Seq1(\"Start\"))\nWe can now write:\nc#\nWriter(0, Seq1(\"Start\"))\nOr, if you want to start with an empty output:\nc#\nWriter<string, int>(0)\nAnd instead of:\nc#\ntell<MSeq<string>, Seq<string>>(Seq1(\"Another\"))\nWe can now write:\nc#\ntell(\"Another\")\nIn fact this:\nc#\nWriter(0, Seq1(\"Start\"))\nIs equivalent to:\nc#\nfrom x in Writer<string, int>(0)\nfrom _ in tell(\"Start\")\nselect x;\nThis should make the Writer slightly more accessible, and reduce the burden of writing these convenience functions.\n. On my phone, so can\u2019t go in depth, but you can convert a Parser to a\nParser as long as the I is a char. You can call ToParser() to convert.\nOn Fri, 2 Feb 2018 at 00:05, davegi notifications@github.com wrote:\n\nI'm trying to use ItemT.satisfy() as follows but the result generates an\nerror when I try and use it in a LINQ from clause:\nprivate static LanguageExt.Parsec.Parser\nColorParser(string color) => LanguageExt.Parsec.ItemT.satisfy(_ =>\nIsColor(color));\n            this.Parser =\n            from ...\n            from ...\n            from color in ColorParser(colorString) // CS1943\n            from ...\n            from ...\n            select constructor(color);\n\nCS1943 An expression of type 'Parser' is not allowed in a\nsubsequent from clause in a query expression with source type\n'Parser<>'. Type inference failed\nin the call to 'SelectMany'.\nObviously I have a type mismatch between Parser and Parser which makes sense since I'm using ItemT.\nBottom line:\n\nCan I convert a Parser to Parser?\nIs my approach correct but I should be using Item, which doesn't\n   seem to exist?\nIs there another approach that I'm not aware of (functional and\n   lang-ext are very new to me)?\n\nThanks,\ndjg\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/350, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk3BJfSMn90Fbm7Fa2h4keHswBPngks5tQlE8gaJpZM4R2e03\n.\n. @davegi Not really, no.  The Parser<A> essentially is a Parser<char, A> because it parses a stream of char.  So, unless you can map your I input stream to char then there is no type compatible way of using them together.. I'm not sure how write is working.  Normally you wouldn't use from with write and select with write.  Because select isn't monadic, it's merely a map at the end.  So your LINQ expression is more like:\nc#\nwrite(\"First line\").Bind(_ => write(\"Second line\")).Bind(__ => read()).Map(input => write());\nWhich would give you a nested monad.\n\nWithout seeing your implementation I can't really comment on exactly what you need - but it seems like the connection is something that is fixed for the whole LINQ expression (i.e. it's not state that can change, but an 'environment').  You should probably look at the Reader<Env, A> monad for passing through an environment value:\nFirst I'll create a basic Connection type that represents whatever it is you use to connect to your APIs:\n```c#\n    public class Connection : IDisposable\n    {\n        public static Connection Open() => new Connection();\n        public Unit Close() => unit;\n    public void Dispose()\n    {\n    }\n}\n\nThen I add some handy overrides for working with a `Reader` monad that has a `Connection` environment:c#\n    public static class Conn\n    {\n        public static Reader write(string value) =>\n            conn =>\n            {\n                // Do the code for writing\n                return (unit, false);\n            };\n    public static Reader<Connection, string> read() =>\n        conn =>\n        {\n            // Do the code for reading\n            return (\"\", false);\n        };\n\n    public static Option<A> Use<A>(string url, Reader<Connection, A> ma)\n    {\n        var conn = new Connection(); // TODO: Actually connect to your API\n        try\n        {\n            var (a, isFaulted) = ma(conn);\n            return isFaulted\n                ? None\n                : Some(a);\n        }\n        catch(Exception)\n        {\n            return None;  // TODO: You may want to expose this, so return Try<A> \n                          //       instead of Option<A>\n        }\n        finally\n        {\n            conn.Dispose();\n        }\n    }\n\n    public static Reader<Connection, A> Return<A>(A value) =>\n        _ => (value, false);\n}\n\nHere's a little test app based on your original:c#\n    public static class Test\n    {\n        public static void F()\n        {\n            var expr = from _     in Conn.write(\"First line\")\n                       from __    in Conn.write(\"Second line\")\n                       from input in Conn.read()\n                       select input;\n        var result = Conn.Use(\"http://yourapi.com\", expr);\n    }\n}\n\n``\nNotice howreadandwritereturn delegates, the parameter of which isConnection`.  That always allows you to get to your connection.. Could you add it to OptionAsync pls?  \nI haven't finished the API updates for the async improvements yet - so there will be some areas not completed yet.. @gwintering  Good stuff, thanks Greg \ud83d\udc4d . Hi Stefan, if you take a look at the Ord.Prelude.cs.  You'll see various functions for working with Ord.  It doesn't need to be in the interface itself as the behaviour is common to all types, and would add the burden of typing in the same method for every Ord class-instance.  When default interface methods come along then there's definitely an argument for adding more to the interface of the type-classes, but right now I don't think it's wise.\nWe could add min and max relatively easily to the Prelude though:\n```c#\npublic static A min(A x, A y) where OrdA : struct, Ord =>\n    compare(x, y) < 0\n        ? x\n        : y;\npublic static A max(A x, A y) where OrdA : struct, Ord =>\n    compare(x, y) > 0\n        ? x\n        : y;\npublic static A min(A x, A y, A z, params A[] tail) where OrdA : struct, Ord =>\n    fold, A[], A, A>(tail, min(x, min(y, z)), min);\npublic static A max(A x, A y, A z, params A[] tail) where OrdA : struct, Ord =>\n    fold, A[], A, A>(tail, max(x, max(y, z)), max);\n``\nIn fact I've just done it (it's onv2.2.5-beta)\n.CompareTo` is implemented automatically.  Why are you overriding it?. You can override it if you like.  But you\u2019re not getting any functionality for free.  That\u2019s not the problem of the Record type, it\u2019s the problem of the programmer who wants bespoke behaviour over what the Record type provides.\nI am not prohibiting overriding because it may be useful in certain circumstances,  but if you want operators you must implement them.  \n\nOn 8 Feb 2018, at 02:20, bender2k14 notifications@github.com wrote:\nIn defense of @faeriedust, why is CompareTo declared as virtual if you (@louthy) don't expect anyone to override it? Is the presence of this key word a mistake?\n(Equals and GetObjectData are also declared as virtual. Is the presence of this key words a mistake?)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I have added this to the documentation\n\nNOTE: Inheritance is not supported in Record derived types. So, if you derive a type from a type that derives from Record then you won't magically inherit any equality, ordering, hash-code, etc. behaviours. This feature is explicitly here to implement record-like functionality, which - in other functional languages - do not support inheritance. Equality of origin is explicitly checked for also.\n. @bender2k14 Thanks \ud83d\udc4d . Gah!  Thanks \ud83d\udc4d . That's a bug, yes.  Should probably change to:\nc#\nbool includeBase = !(typeof(A).CustomAttributes\n                              .Exists(a => a.AttributeType.Name == \"IgnoreBaseAttribute\"));\n. Declined.  This is changing the intention of the Record type, which is to support equality of origin only.  I'm not going to stop (and can't stop) developers inheriting from types derived from Record, but the equality and ordering operators and methods are not going to support it.  This also brings in performance and memory allocation overheads which is unnecessary when the intention is clear.. Hi Sean, not sure how I can contact you directly.  But if you want to send a CV and covering letter to me directly then that might be easiest? \nMy email is: p.louth@gmail.com \n(That goes for anyone else too)\nI probably won\u2019t be contacting people until mid to late next week.  So if you don\u2019t hear from me immediately, don\u2019t worry :) . Thanks \ud83d\udc4d . I assume because Seq the class and Seq the function clash.  It\u2019s an annoying limitation.  I\u2019d be surprised if it\u2019s related to the partial nature of the class, but I\u2019d be interested in fixing that if it\u2019s the case (as it causes clashes elsewhere too).\n\nOn 9 Feb 2018, at 16:05, bender2k14 notifications@github.com wrote:\nIn what way does it not work?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @SeanFarrow Hmm, not sure I entirely follow.  If I remove LanguageExt.Prelude from in from of LanguageExt.Prelude.random(6) then I would expect it to not compile, because LanguageExt.Prelude is a static class.  \n\nTo be able to remove LanguageExt.Prelude from LanguageExt.Prelude.random you must first add:\nc#\nusing static LanguageExt.Prelude;\nThat does then make accessing the Seq class problematic for the reasons I mentioned in my comment above.  But you can use:\nc#\nvar intSeq = Seq(Enumerable.Range(1, 5));\nTo construct your sequence and then use the fluent API from there.\nIt's not an ideal situation, and one I plan to take up on csharplang at some point.  \nI'm not sure where your intuition for the partial classes idea comes from though?  As partial is a compiler level construct, not something that ends up in the assembly.  So, by the time you get to use LanguageExt.Core.dll the partial nature of the types have been removed.. Going to close this as (bar lobbying the C# team to get their compiler to understand the difference between a function invocation and a static module dereference) there's very little I can do.  . Fixed in v2.1.13. > On a related note, what is the meaning / intention between the classes MTask<> and MTaskFirst<>?\nhttps://github.com/louthy/language-ext/issues/339. It keeps the context of the original exception. Fixed in v2.2.12-beta. This has highlighted another area that needed a refactor, which I've started on in the async branch (that branch should really be seen as 'next major release', perhaps even version 3.0).  Anyway, the 'Unsafe' suffix is always used to indicate that you may get a null value returned.  I have been less aggressive with enforcing it with some types (like Task).  \nIt seems clear to me that Unsafe is similar to Async in that they're variants on core types and should have their own type-class support.  \nSo, I have added OptionalUnsafe, OptionalUnsafeAsync, ChoiceUnsafe, and ChoiceUnsafeAsync (actually the last one still needs adding).  The types which are safe by default (Option, Either, etc.) now have their class-instances (MOption, MEither, etc.) derive from both the safe and unsafe type-classes.  \nBut. the types that are unsafe by default (OptionUnsafe, EitherUnsafe, etc.) now have their class-instances derive only from the unsafe type-classes.\nThe theory here is that you can make a safe value unsafe, but not make an unsafe value safe.\nI have made some types safe by default that weren't before: Task, Try, TryAsync, TryOption, TryOptionAsync.\nIt's still early and will continue along with the provision of the ...Async types when I get time (or if anybody wants to volunteer).\nAnyway, this is all in v2.1.13-beta. Seems reasonable.  I didn't even know of the existence of this, so give me a bit of time to look into it.  I'm super busy atm.. You need to add:\nusing static LanguageExt.Prelude;\n\nIt\u2019s right there in the documentation ;)\n\nOn 11 Feb 2018, at 21:44, MrYossu notifications@github.com wrote:\nHello,\njust started a new C# console app in VS2017, added the LanguageExt.Cire Nuget package, and typed the following line of code inside Main()...\nvar ab = Tuple(\"a\",\"b\");\nThis gave an error on Tuple, as it seems to be trying to use the System.Tuple. I tried typing...\nvar optional = Some(123);\n...but got an error that Some does not exist in the context.\nI have a using for LanguageExt, and have tried various combinations of the namespaces within, but nothing seems to help. Even ReSharper doesn't have any suggestions as to where to find the types.\nWhat am I doing wrong? Thanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I guess you missed it: https://github.com/louthy/language-ext/blob/master/README.md#getting-started. @StanJav This is fixed in v2.1.11\n\nI guess if you're writing pure code it shouldn't really matter, but the 'real world' isn't always as easy, so I agree it needed fixing.. Closing this now.  But just for clarity:\n\nMap is just an alias for Select.  For IEnumerable it will use the standard lazy behaviour of IEnumerable\nThe issues with multiple evaluation of lazy streams with IEnumerable is well documented, hence the Seq type in this library - which is to remove the problems of multiple-evaluations of items in the stream, but is still lazy.  It has a cost though which is that each evaluated value must be stored - so you incur a memory allocation per item (which for infinite lazy streams would obviously blow up your memory usage).. This is braking the lazy nature of IEnumerable.  Seq has the properties you\u2019re after.. @crodriguezvega Hi Carlos, sorry for the slow reply, been hella busy and am only just getting round to a backlog of questions here.\n\nYour first example should work as you expected it to do.  I've been trying to investigate this evening, but it's a weird one.  \nIf you include:\nc#\n    public static class Ext\n    {\n        public static Task<Either<L, C>> SelectMany<L, A, B, C>(\n            this Task<Either<L, A>> ma,\n            Func<A, Task<Either<L, B>>> bind,\n            Func<A, B, C> project) =>\n            ma.BindT(a =>\n                bind(a).BindT(b =>\n                    default(MEither<L, C>).Return(project(a, b))));\n    }\nIn your project it should work.  But bizarrely that code already exists in lang-ext and for some unknown reason the compiler isn't spotting it for use with LINQ.  If I copy it to the source file then it does pick it up.  So, I'll need to do some digging.  It's either an idiotic mistake that I can't quite see right now or a possible compiler issue.\nAs mentioned you can use EitherAsync.  I'm not sure what missing plumbing is being talked about, because you can create them in a number of ways, from values or Tasks.\n```c#\n    public class Issue376\n    {\n        static Task Number(int n) => n.AsTask();\n        static Task Error(string err) => err.AsTask();\n    public static EitherAsync<string, int> Op1() =>\n        Number(1);\n\n    public static EitherAsync<string, int> Op2() =>\n        RightAsync<string, int>(Task.FromResult(2));\n\n    public static EitherAsync<string, int> Op3() =>\n        Error(\"error\");\n\n    public static EitherAsync<string, int> Calculate(int x, int y, int z) =>\n        (x + y + z);\n\n    public static async Task Test()\n    {\n        var res = await (from x in Op1()\n                         from y in Op2()\n                         from z in Op3()\n                         from w in Calculate(x, y, z)\n                         select w)\n                        .IfLeft(0);\n    }\n}\n\nIf you desperately want to use `Task<Either<L, R>>` then you can easily convert one to an `EitherAsync<L, R>` by calling `ToAsync()` on it (you will need the latest version for that)c#\n    public class Issue376_2\n    {\n        public static async Task> Op1()\n        {\n            return await Task.FromResult(1);\n        }\n    public static async Task<Either<string, int>> Op2()\n    {\n        return await Task.FromResult(2);\n    }\n\n    public static async Task<Either<string, int>> Op3()\n    {\n        return await Task.FromResult(\"error\");\n    }\n\n    public static async Task<Either<string, int>> Calculate(int x, int y, int z)\n    {\n        return await Task.FromResult(x + y + z);\n    }\n\n    public static async Task Test()\n    {\n        var res = await (from x in Op1().ToAsync()\n                         from y in Op2().ToAsync()\n                         from z in Op3().ToAsync()\n                         from w in Calculate(x, y, z).ToAsync()\n                         select w)\n                        .IfLeft(0);\n    }\n}\n\n```. Sure, go ahead. Just be careful in TryAsync and TryOptionAsync which does\nneed to check the Faulted state of the Result\nOn Sun, 4 Mar 2018 at 02:26, bender2k14 notifications@github.com wrote:\n\nRecall issue #367 https://github.com/louthy/language-ext/issues/367.\nThe method in question\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/ClassInstances/Monad/MTask.cs#L197\nlooks like\npublic async Task Apply(Func f, Task fa, Task fb)\n{\n    await Task.WhenAll(fa, fb);\n    return !fa.IsFaulted && !fb.IsFaulted\n        ? f(fa.Result, fb.Result)\n        : throw fa.Exception;\n}\nI said that this method might be throwing the wrong exception. Actually, I\nwas wrong.\nThe documentation of Task.WhenAll\nhttps://msdn.microsoft.com/en-us/library/hh160374(v=vs.110).aspx says\nIf any of the supplied tasks completes in a faulted state, the returned\ntask will also complete in a TaskStatus.Faulted state, where its exceptions\nwill contain the aggregation of the set of unwrapped exceptions from each\nof the supplied tasks.\nand the documentation of await\nhttps://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/await\nsays\nIf you await a task-returning async method that causes an exception, the\nawait operator rethrows the exception.\n...\nA single task that is in a faulted state can reflect multiple exceptions.\nFor example, the task might be the result of a call to Task.WhenAll. When\nyou await such a task, the await operation rethrows only one of the\nexceptions. However, you can't predict which of the exceptions is rethrown.\nTherefore, the above method contains unneeded code. It is equivalent to\nthis simpler method\npublic async Task Apply(Func f, Task fa, Task fb)\n{\n    await Task.WhenAll(fa, fb);\n    return f(fa.Result, fb.Result);\n}\nThe case is similar for canceled tasks. The same Task.WhenAll\ndocumentation says\nIf none of the supplied tasks faulted but at least one of them was\ncanceled, the returned task will end in the TaskStatus.Canceled state.\nand the same await documentation says\nIf you await a task-returning async method that's canceled, the await\noperator rethrows an OperationCanceledException.\nHere\nhttps://github.com/louthy/language-ext/blob/async-refactor/LanguageExt.Core/ClassInstances/Monad/MEitherAsync.cs#L33\nis an example in the async-refactor branch that included a call to\nTask.IsCanceled after awaiting the same task (via a call to Task.WhenAll).\nI have not yet identified all locations in Language.Ext that use this kind\nof unneeded code. I volunteer to find all such locations in the\nasync-refactor branch and create a PR that removes the unneeded code.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/377, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk3KltukX4gNX9i0zumf0jFBu7lj0ks5ta1DtgaJpZM4SbK19\n.\n. Just to be clear Result and OptionalResult are types to simplify the return values of various monadic types (instead of using a tuple, for example); they're not really general purpose monadic types like Either, Option, etc. and don't conform to any common notion of what an Either, or Option type may be.\nI needed something with three states: some, none, exception\n\nThat's exactly what TryOption is.  If you want three different types for the states then you probably need Either<A, B, C> which I have created in a project I'm working on now and will add to lang-ext at some point.. I have done a slight refactor of Result and OptionalResult.  I am still considering removing the interface altogether (by making all methods internal) because of the confusion about how to use Try, TryOption, etc.  Although it may just be better to make the ma.Try() extension method internal so you can never see a Result or OptionalResult.  \nThe main reason why I may keep the Result or OptionalResult interface public is because I can see they have some real-world use, and perhaps it will break a lot of code.  The next release will have a fair amount of backwards compatibility breakages (from the async updates), so I'd like to reduce that.\nI'm not sure why I exposed the Try extension method in the first place, it was probably because Try the monad (and related types) didn't originally support memoisation.  They do now and I have added Strict to force evaluation.  \nBoth Result and OptionalResult now consider the Bottom state to be when the State == IsFaulted and Exception == null || Exception is BottomException.  The null exception is never exposed or known about unless you call IsBottom.  \nSo, the types are essentially two-state types of Faulted or Success.  And even if the Exception == null then IsFaulted will still return true.  And any Match or IfFail call will give you a BottomException if the internal Exception is null.  \nIt's arguable whether the IsBottom property is even needed now, but I'm going to keep it for now.\n\nI'm not sure whether OptionalResult should default to Bottom\n\nBecause in the case of OptionalResult the None state represents success - so creating something that represents success implicitly is in my mind a bad idea - that's the kind of thing that leads to bugs propagating.  None in Option represents a failure value.  \nAnyway, with the new version the bottom state doesn't really exist, it's now a Faulted state with a BottomException, and only knowable if you call IsBottom.\n\nYou say: use TryOption. But that's a different thing because TryOption is Func and I'm looking for a return type for my own function that returns exactly something like OptionalResult.\nHow can I replace that by TryOption? \n\nThere are prelude functions for constructing them from values, exceptions, as well as funcs:\n```c#\nTryOption YourFunc() =>\n    TryOption(123);\nTryOption YourFailFunc() =>\n    TryOption(new ArgumentNullException());\nObviously the preferred way would be to do:c#\nTryOption YourFunc() => () =>\n    123;\nTryOption YourFailFunc() => () =>\n    throw new ArgumentNullException();\n```\nBut if you're not actually trying to capture an exception and you want to construct them manually then the first examples are fine.\n\nthat at least guarantees that the inner function is called only once\n\nIf you want to guarantee that the functions are call only once, then use the func constructors:\n```c#\nTryOption YourFunc() => TryOption(() =>\n{\n    // ... this code will never be called twice for the same returned TryOption\n    // You can also use Memo or Strict to force it for methods that haven't been\n    // wrapped with the constructor method.\n    return Some(123);\n});\n```\n. >IMHO you realky should avoid \"None\" as name for bottom default state\nWhat do you mean?  Check the code\nc#\n        internal static readonly OptionalResult<A> None = new OptionalResult<A>(Prelude.None);\n        internal static readonly OptionalResult<A> Bottom = default(OptionalResult<A>);\nNone is a successful result with an Option.None in it, bottom is an uninitialised struct.\n\nUsing Tryoption means: I should pass a func instead of a value\n\nI'm not sure you've read my reply properly.  You can use it with values if you like.  TryOption(123)\n. @NightWatchman Hi Eric, it really is about trying to stick to a common monadic type throughout or lifting/mapping to that common type.  If I were you I'd look at EitherAsync<L, R> and try to use that rather than Task<Either<L, R>>.   If you have an Either and you want it to work with other EitherAsync types then call either.ToAsync() to make it into one.\nThen it's important to understand the difference between Map and Bind (or the async versions MapAsync and BindAsync).  So, head over to the Thinking Functionally section of the Wiki for a discussion on this\nOnce you've groked that then you'll see how to compose these types together.  Take a look at @bender2k14 's example, but replace the Task<Either<>>s with EitherAsync.  Also, take a look at my version using LINQ for the Method.  It's easier to understand than the chain of Bind calls (even though that's what it's doing behind the scenes)\n```c#\ninternal class MyClass\n{\n    internal EitherAsync ProcessReq(string connectionString, MyRequest request) =>\n        from db in DataAccessModule.Connect(connectionString).ToAsync()\n        from ex in RecordExists(db, request.FshApplicationKey)\n        from rs in ex\n            ? UpdateRequest(db, request)\n            : InsertRequest(db, request)\n        select rs;\nprivate EitherAsync<DataAccessException, bool> RecordExists(MyDatabase db, FshApplicationKey fshApplicationKey) => throw new NotImplementedException();\nprivate EitherAsync<DataAccessException, string> UpdateRequest(MyDatabase db, MyRequest request) => throw new NotImplementedException();\nprivate EitherAsync<DataAccessException, string> InsertRequest(MyDatabase db, MyRequest request) => throw new NotImplementedException();\n\n}\ninternal class MyRequest\n{\n    public FshApplicationKey FshApplicationKey { get; }\n}\ninternal class DataAccessModule\n{\n    internal static Either Connect(string connectionString) => throw new NotImplementedException();\n}\ninternal class FshApplicationKey { }\ninternal class MyDatabase { }\ninternal class DataAccessException : Exception { }\nYou can then call it like so:c#\n   var res = MyClass.ProcessReq(conn, req);\nAnd get at the asynchronous result like so:c#\n    var res = await MyClass.ProcessReq(conn, req).IfLeft(ex => ...);\n``\nNestingMatchis nearly always an indication that you're doing the monadic bind yourself rather than letting the monad do it itself (viaBind);  Throwing exceptions in anEithercomputation is also an indication that you're doing it wrong, because theLeftvalue is supposed to carry the _alternative value_ - i.e. the error.. @thehoglet I have fixed up the docs.  Thanks for the heads up.. That's almost certainly an artefact of the defaultFailfunction forMTask.  WithBindTthe outer monad is in control of the bind operation, if the inner monad is in a failed state then it will fail too.  It's propagating the failure exception up the chain.  It's best to see the transformer types as one type rather than two nested ones, but with the rules of the outer monad being law.  The wayTask` deals with failure is an exception, so that's what you see.\nI am super short of time at the moment, so I'll take a look when I can, but there will just be some combinations of types used in the generic transformer system that don't play well with each other (and that means manually unwrapping to inject the behaviour you want).. This issue is fixed in v2.2.17-beta. I'd rather not.  I made that mistake on a previous project.  It's a large maintenance overhead for very little gain and has other issues with construction which make it a bit ugly to use in the wild.\nI thought I'd added Strict() as an extension method for Try, but it seems not, so I'll add that.  I am also probably going to restrict the surface of Result and OptionalResult because it seems to have caused massive confusion - really Result and OptionalResult shouldn't be for direct use, they're temporary types for the extension methods to use.  If you want to get a value out of Try use Match, IfFail, etc.  \nNote also that Try memoises the bound value when computed - so if you're worried that Try evaluates multiple times, it doesn't, it computes once on demand.  A Strict extension would allow you to force evaluation without losing the Try context.  \nIf you want to implement your own Strict method, just add this extension:\nc#\n    public static Try<A> Strict<A>(this Try<A> ma)\n    {\n        var res = ma.Try();\n        return () => res;\n    }. Seq<A> doesn't contain a method called New. Scroll down, you\u2019ll see its use case - even if it isn\u2019t used directly. The intended behaviour is to create a windowing system into the backed list - so that there is no need to create sub-lists when doing operations like Take and Skip - which are big pain points in IEnumerable.  Where do you see the 'advantage of making it slightly faster'?  It's designed for performance already, is there something that you think isn't as fast as it could be, because I can't see much area for improvement when just manipulating integers.  \nRemember SeqList isn't public and New will never be seen by a user (nor will the constructors).  . Thanks for this.  Damn copy and paste!  Fixed now.. @brotherbill I'm using VS Community 2017 too (v15.6.4) with no issues.\nTry switching to the async-refactor branch - that's the active version branch for the next major release.\nRE: Writing unit tests - yes, please, that would be awesome - the more the merrier.  I don't really have time to do any hand-holding, so it's probably best you start on areas that you understand clearly.  There's plenty of areas of the library that could benefit from additional tests (the collection types for example).  . @thehoglet That could well just be legacy from the horror DNX/.NETCore 1 days when everything was in flux and nothing worked.  I won't be able to test this for a few days, but it could well be time to drop it.  Thanks for the heads up.. Certainly looked fishy so I've killed it.  It's probably not quite as efficient (at least memory allocation wise) as sticking it in a List anyway, which is what I've done now.\nAt some point I'm going to come back to all these types to see if I can do something interesting with Span<T>, I think there's some performance mileage there (maybe).\n\nAt present, my feeling is that I could find such a multiple evaluation issue, but I don't know of one yet.\n\nGood luck.  You won't find it ;). The former is the most efficient way for an IList.  If you use an IEnumerable you will need to use Skip and Take which has additional overhead. \nAll imperative functionality in the library is for efficiency reasons - most often to avoid unnecessary allocations.\n\nOn 4 Apr 2018, at 02:30, bender2k14 notifications@github.com wrote:\nIn SeqList<>, many methods are implemented using a for loop, such as Fold<>, Exists, and ForAll.\nLet's consider ForAll as an example.\npublic override bool ForAll(Func f)\n{\n    for (int i = index; i < index + count; i++)\n    {\n        if (!f(list[i])) return false;\n    }\n    return true;\n}\nAnother way to implement this is\npublic override bool ForAll(Func f) =>\n    AsEnumerable().ForAll(f);\nwhich is how SeqTaken does it.\nIs there a reason for the former implementation over the latter?\nI can't think of any. In particular, I think the latter implementation just uses a bunch of static function calls that when inlined would produce the former implementation. To help confirm my understanding, I could run some performance tests.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I was reading from my phone, I assume you were talking about using the LINQ AsEnumerable().  I've now fixed the ones that can be changed.. That's a bug. Fixed . Sure, I doubt Arr will veer too far from the underlying array type.. SeqArr removed. @kdblocher I don't have infinite time and I won't be bullied into pushing code out the door.  This commit has .editorconfig changes in which I have not yet had time read, understand and review.  So, I'll get to it when I have time.. > Should OptionalResult equal Result>\n\nNo, they're different types and therefore will never be equal.. It may share the same name, but it\u2019s not the same.  The Lang-ext type that matches the Result type in that blog is Either<L, R>.  It derives from IEither which is untyped.. The whole thing reeks of bad design to be honest.  The point of this library is to improve life in C# by leveraging the type-system to reduce common classes of errors.  If you want an untyped Either then use IEither (which is what Either<A, B> derives from).  But you'll only be able to Match on object values.  \nYou could add your own extension methods for IEither to cast to the typed values you want, but that is outside the scope of this project.\nYour save function should look like so:\nc#\n    public Either<Error, Unit> Save(Stuff stuff)\n    {\n        try\n        {\n            SaveMethodThatCanThrow(stuff);\n            return unit;\n        }\n        catch(Exception e)\n        {\n            return new Error(e.Message);\n        }\n    }\nOr, even better. use Try which is designed to catch exceptions:\nc#\n    public Try<Unit> Save(Stuff stuff) => () =>\n    {\n        SaveMethodThatCanThrow(stuff);\n        return unit;\n    };\n. @imranypatel This is slightly misleading.  I think if you check result.IsFaulted you'll realise it's false.  And if you check result.Reply then you'll find the values you're expecting.  The Parser is recursive and some types of Parser will capture errors and ignore them, but still pass the error message back.  For example many and many1 both need to stop parsing when their 'inner parser' doesn't succeed any more.  So, you're seeing the error from the spaces parser when it gets to the end of the stream - it can't parse a space any more, so it errors, but the many1 parser still succeeds because nothing additional has been consumed.  \nThere are four states the parser can be in:\n\nConsumed OK\nConsumed Error\nEmpty OK\nEmpty Error\n\nConsumed OK means that the parser succeed without any errors.  Consumed Error means the parser failed, but it did consume some of the input stream before failing.  Empty OK means that the parser succeeded, but there's no result (you can imagine that many which can return zero items would use this).  Empty Error - means the parser failed, but didn't consume anything.\nConsumed Error is a fatal error for the parser, one which can't be recovered from, unless you wrap the parser with attempt(p), which will turn the Consumed Error into an Empty Error (and rewind the stream to the point before it tried to parse the inner parser).  Certain parsers will consider Empty Error to be their cue to end (many and many1 for example).  So, many(attempt(p)) will be the most reliable way to deal with the parsing of a number of items.\nUse this helper extension method to get something a bit easier to consume:\nc#\n        public static Either<string, T> ToEither<T>(this ParserResult<T> result) =>\n            result.IsFaulted\n                ? Left<string, T>(result.Reply.Error.ToString())\n                : Right<string, T>(result.Reply.Result);\nIt converts a ParserResult to an Either.  Left is the error, Right is the result.\nBy the way, it's possible to build that parser to not have anything at all in the Error field, but that was outside the scope of that tutorial.\nIf you're wondering why it propagates at all, it's so certain 'parent' parsers could collect a series of 'child' parser results and munge them together into something a bit more useful.  It makes sense whilst in the midst of a parser expression, but less so when you're calling the parser with a real stream: that's where the result.ToEither() comes in useful.\nI know there's limited documentation on the lang-ext Parsec, but it is an almost 1-to-1 port of the Haskell Parsec library, so it's useful to know when looking for tips.. @imranypatel If you get the latest version (2.2.27-beta), I have updated the ParserResult.ToString() implementation, so it doesn't give misleading results.  You should see: Success(x) where x is the Reply.Result.\nI have also added ToEither() which will convert the ParserResult to an Either<string, T>; ToEither<ERR>(Func<string, ERR> f) which takes a function that will convert the string error to an error-type of your choosing.  \nIf you're using NewType for an Error type:\nc#\n    public class Error : NewType<Error, string>\n    {\n        public Error(string value) : base(value) { }\n    }\nThen you could do this:\nc#\n    var res = parse(parser, \"   4 words are here\").ToEither(Error.New);\nHopefully that should remove any confusion.. @imranypatel  Just to be clear.  The code hasn't changed the example or the outcome - I got the same results as @bender2k14  - it's just the ToString() implementation was misleading.  The results were correct and as stated in the Wiki documentation - IsFaulted was false, and Reply.Result did contain the correct result.\n\nAm curious whether you've have seen my request on gitter on 6th April?\n\nI did see it, I started writing a reply, but got pulled away on something else.  Yes, the Free Monad approach would work well in that situation.  Although if you're just getting into this stuff then you may want to keep it simple and write some basic mapping functions from one type to another.  That's all the outcome will be: a series of operations which describe map computations.  The benefit of the Free Monad approach will be that you can encapsulate the side-effecting code (printing), which will also make it easier to write unit tests.  \nBtw, it's often better to ask those types of more in-depth questions on these Issues pages - it's much easier to give code examples and can serve as future reference for others looking for similar solutions.  So, feel free to open up a new issue and we can discuss it there.  . > But finding bit challening getting access to values inside containers and map further\nIt really depends on what you want to do, if you want to continue working with the results then you can just use LINQ:\n```c#\nvar res1 = // Either>\nvar res2 = from terms in res1  // now terms == Seq\n           let onlyWords = terms.Filter(t => t is Word).Map(t => t as Word)\n           select onlyWords;\n`res2` will now be an `Either<string, Seq<Word>>`.  You could also do it fluently:c#\nvar res2 = res1.Map(terms => terms.Filter(t => t is Word).Map(t => t as Word));\nIf you want to get at the raw `Seq<Term>` then you have to decide what to do if you get an error.  For example, let's say you ignored the error and decided that it represents zero terms:c#\nvar terms = res1.IfLeft(_ => Seq());\nThen `terms` is just a `Seq<Term>` which is either empty or has the parsed terms in it.  I find it's usually best to stay in context (maintain the `Either`) for as long as possible, so if I had something that processed the terms then I would get that to return an `Either` too, and then that makes composition and error handling much easier.  For example, let's say we had a function that parsed the text and then validated the terms:c#\n    Either Validate(string text) =>\n        from terms in parse(parser, text)\n        from result in ValidateTerms(terms)\n        select result;\nEither<string, Unit> ValidateTerms(Seq<Term> terms) =>\n    term is Word word     ? ValidateWordTerm(word)\n  : term is Number number ? ValidateNumberTerm(number)\n  : Left(\"Unknown Term type\");\n\nEither<string, Unit> ValidateWordTerm(Word word) =>\n    word.Length > 1 && word.Length < 8\n        ? Right<string, Unit>(unit)\n        : Left(\"Invalid word\");\n\nEither<string, Unit> ValidateNumberTerm(Number number) =>\n    number > 100\n        ? Right<string, Unit>(unit)\n        : Left(\"Invalid number\");\n\n```\nI think it's often easy if you're coming at the functional programming thing from the OO world to get into the 'must abstract' mindset.  I think it's very much the case that functional programming is more about concrete behaviour with known sets of types.  Clearly you could add inherited methods to Term/Word/Number to do the Validation, and in this instance it may well be better - but then Term, Number, and Word are 'infected' with the decision on how to validate - whereas with my example above it's contextual and the Word and Number types are just pure data.\nUltimately pick a solution that is appropriate for the problem you're trying to solve.  There are real benefits to separating data and functionality (the opposite of what we're told is good in the OO world).  Especially when the data is immutable - that's when the systems become really powerful.  It's easy to move immutable blocks of data around a system, it's easy to move immutable blocks of data between systems.  Then each sub-system can have its own local functionality that deals with those data blocks.\nThe costs that come with this approach is well captured by the Expression Problem, which means it's more difficult to extend a system built in the functional paradigm - for example, if I add a new type that derives from Term then I don't immediately get a validator, or anything like that.  \nThat's the cost of functional - but my personal belief is (so, you can choose to ignore) that the OO world abstracts unnecessarily 99% of the time.  And needs to extend existing types functionality rarely.  It's a myth that we need to build in abstraction layers by default \"just in case\".   And, so the few times that it's needed (in the functional world) it does mean some additional diligence (especially as we haven't got proper discriminated unions and pattern matching with exhaustiveness checking).  \nI can live with that because I believe that functional programs are significantly more robust, easier to test, and are cognitively easier to deal with when applications get to a super large scale.. @flcdrg Hi David, I have no plans for this in the short term, each target adds a large compilation time overhead which I'd rather not incur.  I'd suggest (if it's for a short term problem) that you fork the solution and maintain a net45 build until you're ready to move.  You can call pack.bat in the root to build the nu-get packages.. @flcdrg Hi David, after splitting out the Rx project I decided to downgrade the .NET framework requirement.  It's now at net45 if you haven't already upgraded your projects.. @imranypatel So, if you want to do this, as well as it can be done - and learn the functional thing on the way.  Then (based on what you're asking for) I would do the following (btw, I have implemented this exact setup twice in the past few weeks, so I know it will work, but it's going to be a steep learning curve).\nHere's a working gist of what I'm going to talk you through:\nhttps://gist.github.com/louthy/b3a40c7f5f1bc1a8431c770230800ecb \nFirstly the idea of building a Free monad is exactly how this will work well.  Note however that lang-ext doesn't have generalised free-monad support (one day I'll work out how to generalise it, but it isn't there now).  So, each time you want to use a technique like this you have to do the plumbing yourself.\nNext, to do the expression stuff, then you should use LanguageExt.Parsec - this is what it's built to do.  It can build a mini-DSL language that you can use to make either a simple expression system right up to a fully fledged language.\nThe parser you build with LanguageExt.Parsec should 'compile' to the same Free monad.  The Free monad type will need to have cases to handle expressions.  This will allow your entire process to be one computation that both runs the operations but also runs the expressions.\nOnce you have the Free monad definition you need to define the Interpreter to run it.\nSo, first I'll start off with the Free monad definition.  The first step is to create 'an algebra' for all the operations you want to perform.  What this means is a 'discriminated union' the describes every operation.  C# doesn't support discriminated unions, so we use inheritance.\nBelow is the core type Transform<A> and its 'cases':\n```c#\n    public class Transform\n    {\n        public class Return : Transform\n        {\n            public readonly A Value;\n            public Return(A value) => Value = value;\n        }\n    public class Fail : Transform<A>\n    {\n        public readonly string Value;\n        public Fail(string value) => Value = value;\n    }\n\n    public class AllRows : Transform<A>\n    {\n        public readonly Func<Seq<AccountingRow>, Transform<A>> Next;\n        public AllRows(Func<Seq<AccountingRow>, Transform<A>> next)\n        {\n            Next = next;\n        }\n    }\n\n    public class FilterRows : Transform<A>\n    {\n        public readonly string Value;\n        public readonly Func<Seq<AccountingRow>, Transform<A>> Next;\n        public FilterRows(string value, Func<Seq<AccountingRow>, Transform<A>> next)\n        {\n            Value = value;\n            Next = next;\n        }\n    }\n\n    public class Log : Transform<A>\n    {\n        public readonly string Value;\n        public readonly Func<Unit, Transform<A>> Next;\n        public Log(string value, Func<Unit, Transform<A>> next)\n        {\n            Value = value;\n            Next = next;\n        }\n    }\n\n    public class SetValue : Transform<A>\n    {\n        public readonly string Name;\n        public readonly object Value;\n        public readonly Func<Unit, Transform<A>> Next;\n        public SetValue(string name, object value, Func<Unit, Transform<A>> next)\n        {\n            Name = name;\n            Value = value;\n            Next = next;\n        }\n    }\n\n    public class GetValue : Transform<A>\n    {\n        public readonly string Name;\n        public readonly Func<object, Transform<A>> Next;\n        public GetValue(string name, Func<object, Transform<A>> next)\n        {\n            Name = name;\n            Next = next;\n        }\n    }\n\n    public class Compute : Transform<A>\n    {\n        public readonly ComputeOperation Operation;\n        public readonly Func<Unit, Transform<A>> Next;\n        public readonly SourceType SourceType;\n        public Compute(ComputeOperation operation, SourceType sourceType, Func<Unit, Transform<A>> next)\n        {\n            Operation = operation;\n            SourceType = sourceType;\n            Next = next;\n        }\n    }\n\n    public class Print : Transform<A>\n    {\n        public readonly PrintOperation Operation;\n        public readonly Seq<string> Messages;\n        public readonly Func<Unit, Transform<A>> Next;\n        public Print(PrintOperation operation, Seq<string> messages, Func<Unit, Transform<A>> next)\n        {\n            Operation = operation;\n            Messages = messages;\n            Next = next;\n        }\n    }\n}\n\n``\nNote how most of the classes have aNextfield which is aFunc.  That is how the operations are chained together.  A bit like continuations.  OnlyReturnandFaildon't haveNext`, and that's because they terminate the computation.\nFor the type to become a monad you need to define the standard monad operations:\n```c#\n    public static class TransformLINQ\n    {\n        public static Transform Bind(this Transform ma, Func> f)\n        {\n            switch (ma)\n            {\n                case Transform.Return item: return f(item.Value);\n                case Transform.Fail item: return new Transform.Fail(item.Value);\n                case Transform.Log item: return new Transform.Log(item.Value, n => item.Next(n).Bind(f));\n                case Transform.SetValue item: return new Transform.SetValue(item.Name, item.Value, n => item.Next(n).Bind(f));\n                case Transform.GetValue item: return new Transform.GetValue(item.Name, n => item.Next(n).Bind(f));\n                case Transform.Compute item: return new Transform.Compute(item.Operation, item.SourceType, n => item.Next(n).Bind(f));\n                case Transform.Print item: return new Transform.Print(item.Operation, item.Messages, n => item.Next(n).Bind(f));\n                case Transform.AllRows item: return new Transform.AllRows(n => item.Next(n).Bind(f));\n                case Transform.FilterRows item: return new Transform.FilterRows(item.Value, n => item.Next(n).Bind(f));\n                default: throw new NotImplementedException();\n            }\n        }\n    public static Transform<B> Map<A, B>(this Transform<A> ma, Func<A, B> f) =>\n        ma.Bind(x => Transform.Return(f(x)));\n\n    public static Transform<B> Select<A, B>(this Transform<A> ma, Func<A, B> f) =>\n        ma.Bind(x => Transform.Return(f(x)));\n\n    public static Transform<B> SelectMany<A, B>(this Transform<A> ma, Func<A, Transform<B>> f) =>\n        ma.Bind(f);\n\n    public static Transform<C> SelectMany<A, B, C>(this Transform<A> ma, Func<A, Transform<B>> bind, Func<A, B, C> project) =>\n        ma.Bind(a => bind(a).Map(b => project(a,b)));\n}\n\n``\nNOTE: Every time you add a new case to the type you need to add it to theswitchin theBindfunction.  The important thing here is that each one is basically the same, it's recreating the same case type, but with a newNext` function, and each time you do it it's the same.  So it's quite easy to do.\nWhat this does is allow non-Transform<A> behaviours to be injected without defining new cases.  This enables LINQ operations, etc.\nNow, for convenience we create a static type called Transform which is a factory type for creating new Transform<A> types.  The important thing with these factory functions is we don't need to supply Next, it uses Return as the default Next function.  \n```c#\n    public static class Transform\n    {\n        public static Transform Return(A value) => \n            new Transform.Return(value);\n    public static Transform<A> Fail<A>(string value) => \n        new Transform<A>.Fail(value);\n\n    public static Transform<Unit> Log(string value) =>\n        new Transform<Unit>.Log(value, Return);\n\n    public static Transform<Seq<AccountingRow>> AllRows =\n        new Transform<Seq<AccountingRow>>.AllRows(Return);\n\n    public static Transform<Seq<AccountingRow>> FilterRows(string value) =>\n        new Transform<Seq<AccountingRow>>.FilterRows(value, Return);\n\n    public static Transform<Unit> SetValue(string name, object value) =>\n        new Transform<Unit>.SetValue(name, value, Return);\n\n    public static Transform<object> GetValue(string name) =>\n        new Transform<object>.GetValue(name, Return);\n\n    public static Transform<Unit> Compute(ComputeOperation op)\n    {\n        var sourceType = from expr in Parse(op.SourceType)\n                         from type in op.Operator == \"Expression\"\n                              ? from value in Compiler.Compile<object>(expr)\n                                select new ValueSourceType(value) as SourceType\n                              : from rows in FilterRowsBy(expr)\n                                select new RowsSourceType(rows) as SourceType\n                         select type;\n\n        return from type in sourceType\n               from compute in new Transform<Unit>.Compute(op, type, Return)\n               select compute;\n    }\n\n    static Transform<Seq<AccountingRow>> FilterRowsBy(Scripting.Expr expr) =>\n        expr is Scripting.IdentifierExpr ident\n            ? FilterRows(ident.Value)\n            : Fail<Seq<AccountingRow>>($\"Invalid SourceType: {expr} for non-Expression operation\");\n\n    public static Transform<Unit> Print(PrintOperation op)\n    {\n        var messages = op.Messages\n                         .Map(x => $\"\\\"{x}\\\"\")\n                         .Map(Parse)\n                         .Map(msg => from e in msg\n                                     from r in Compiler.Compile<string>(e)\n                                     select r);\n\n        return from msgs in Sequence(messages)\n               from compute in new Transform<Unit>.Print(op, msgs, Return)\n               select compute;\n    }\n\n    static Transform<Scripting.Expr> Parse(string script) =>\n        Scripting.Parse(script).Match(\n            Right: e => Return(e),\n            Left: er => Fail<Scripting.Expr>(er + \" at \" + script));\n\n    static Transform<Seq<A>> Sequence<A>(Seq<Transform<A>> seq) =>\n        seq.IsEmpty\n            ? Return(Seq<A>())\n            : from x in seq.Head\n              from xs in Sequence(seq.Tail)\n              select Prelude.Cons(x, xs);\n}\n\n``\nNow, some of those functions are more complex than just creating newTransformtypes, and that's because they support scripting (SourceTypeinComputeandMessagesinPrint).  What they do is the parse the text first into aScripting.Expr, then they compile the expression into aTransform`.  That means the scripts are running in the same context as the bulk operations.\nTo achieve this I build a language parser using LanguageExt.Parsec.  It does a lot for free, you've almost got an entire language here.  I won't walk you through all of that, but essentially the Scripting type builds the core parsers, an operator precedence and associativity table, and then calls buildExpressionParser which does the hard work of making a robust expression parser.  So, calling Scripting.Parse(text) will give you a Scripting.Expr which is an abstract syntax tree.  \nYou then pass the expression to the Compiler.Compile function which walks the syntax tree building a single Transform<A>.  \nWhat's nice about this approach is you will get proper contextual errors out of the thing if there are syntax errors, or typos, etc.  And it can work in the same context as the bulk computation.  That means it can access the rows, or whatever.\nSo, now we have a way of manually creating a Transform<A>, we need a way of creating it from the 'schema' JSON.  Now, I'm not going to do the work of loading JSON for you, so take a look at the Data type:\n```c#\n    public static class Data\n    {\n        public static readonly Seq Rows = Seq(\n            new AccountingRow(\"Asset\", \"Account Recievable\", 50000),\n            new AccountingRow(\"Asset\", \"Cash In Hand\", 10000),\n            new AccountingRow(\"Asset\", \"Bank ABC\", 100000),\n            new AccountingRow(\"Expense\", \"Salary\", 30000),\n            new AccountingRow(\"Expense\", \"Office Rent\", 6000),\n            new AccountingRow(\"Expense\", \"Utilities\", 4000));\n    public static readonly Seq<IOperation> OperationsToPerform = Seq(\n       ComputeOperation.New(\"TotalAssets\", \"Sum\", \"Asset\", \"Sum all with type Assets\"),\n       ComputeOperation.New(\"TotalExpenses\", \"Sum\", \"Expense\", \"Sum all with type Assets\"),\n       ComputeOperation.New(\"Balance\", \"Expression\", \"TotalAssets - TotalExpenses\", \"Compute Balance\"),\n       PrintOperation.New(\"Print messages after substituting computed Ids in each message format string\",\n            Seq(\n                \"Total Assets : {TotalAssets}\",\n                \"Total Expenses : {TotalExpenses}\",\n                \"Balance (Total Assets - Total Expenses): {Balance}\")));\n\n    public static Transform<Unit> Load(Seq<IOperation> operations) =>\n        operations.IsEmpty \n            ? Transform.Return(unit)\n            : from head in \n                  operations.Head is ComputeOperation c ? Transform.Compute(c)\n                : operations.Head is PrintOperation p   ? Transform.Print(p)\n                : Transform.Fail<Unit>(\"Invalid operation\")\n              from tail in Load(operations.Tail)\n              select tail;\n}\n\n``\nIt has your original test data in it - but also a simpleLoadfunction that takes a sequence ofIOperationvalues and then compiles it into aTransform.  What's good about this is the calls toTransform.Compute(c)andTransform.Print(p)` will also be compiling the scripts.\nNow, that's the raw type side of it done.  We need to implement an interpreter to run the Transform<A> DSL.\nFirst off we need some state that will be managed by the interpreter as its running:\n```c#\n    public class InterpreterState\n    {\n        public readonly Map Vars;\n        public readonly Seq Rows;\n        public readonly Subject Output;\n    public readonly static InterpreterState Empty = new InterpreterState(default, Seq<AccountingRow>(), new Subject<string>());\n\n    public InterpreterState(Map<string, object> vars, Seq<AccountingRow> rows, Subject<string> output)\n    {\n        Vars = vars;\n        Rows = rows;\n        Output = output;\n    }\n    public InterpreterState SetVar(string name, object value) =>\n        With(Vars: Vars.AddOrUpdate(name, value));\n\n    public Option<object> GetVar(string name) =>\n        Vars.Find(name);\n\n    public InterpreterState With(\n        Map<string, object>? Vars = null,\n        Seq<AccountingRow> Rows = null, \n        Subject<string> Output = null\n        ) =>\n        new InterpreterState(\n            Vars ?? this.Vars,\n            Rows ?? this.Rows,\n            Output ?? this.Output\n            );\n}\n\n```\nIt has three fields: \n\nVars - this will be used to store and load the variables defined during the computation (like TotalAssets, etc.)\nRows - this will get the raw data-set that needs to be processed\nOutput - this is an Rx stream that you can subscribe to to get information out of the system.  You don't have to do it this way, the state could keep a running total of data sets or whatever.\n\nNow the InterpreterState type is defined we need to implement the interpreter itself:\nc#\n    public static class Interpreter\n    {\n        public static Either<string, A> Interpret<A>(Transform<A> ma, InterpreterState state)\n        {\n            switch(ma)\n            {\n                case Transform<A>.Return r: return Right(r.Value);\n                case Transform<A>.Fail f: return Left(f.Value);\n                case Transform<A>.Log m:\n                    state.Output.OnNext(m.Value);\n                    return Interpret(m.Next(unit), state);\n                case Transform<A>.GetValue op:\n                    return state.GetVar(op.Name)\n                         .Match(Some: v  => Interpret(op.Next(v), state),\n                                None: () => Left($\"Unknown value: {op.Name}\"));\n                case Transform<A>.SetValue op:\n                    return Interpret(op.Next(unit), state.SetVar(op.Name, op.Value));\n                case Transform<A>.Compute op:\n                    return Compute(op, state);\n                case Transform<A>.Print op:\n                    return Print(op, state);\n                case Transform<A>.FilterRows op:\n                    return FilterRows(op, state);\n                default:\n                    throw new NotImplementedException(ma.GetType().Name);\n            }\n        }\n    }\nThis is just a big switch statement, note how Return and Fail don't call Interpret like all the others.  Interpret is a recursive function that gets passed the result of the last operation so it can run its current operation.  This walks the Transform<A> DSL - essentially running it.\nThere are three functions called Compute, Print, and FilterRows.  They look like this:\n```c#\n        static Either FilterRows(Transform.FilterRows op, InterpreterState state) =>\n            Interpret(op.Next(state.Rows.Filter(r => r.Type == op.Value)), state);\n    static Either<string, A> Print<A>(Transform<A>.Print op, InterpreterState state)\n    {\n        op.Messages.Iter(state.Output.OnNext);\n        return Interpret(op.Next(unit), state);\n    }\n\n    static Either<string, A> Compute<A>(Transform<A>.Compute op, InterpreterState state) =>\n        op.Operation.Operator == \"Sum\" ? SumCompute<A>(op, state)\n      : op.Operation.Operator == \"Expression\" ? ExprCompute<A>(op, state)\n      : Left($\"Unknown operator: {op.Operation.Operator}\");\n\n    static Either<string, A> ExprCompute<A>(Transform<A>.Compute op, InterpreterState state) =>\n        op.SourceType is ValueSourceType sourceType\n            ? Interpret(op.Next(unit), state.SetVar(op.Operation.Id, sourceType.Value))\n            : Left(\"Invalid source type for Compute\");\n\n    static Either<string, A> SumCompute<A>(Transform<A>.Compute op, InterpreterState state) =>\n        op.SourceType is RowsSourceType sourceType\n            ? Interpret(op.Next(unit), state.SetVar(op.Operation.Id, sourceType.Rows.Map(x => x.Amount).Sum()))\n            : Left(\"Invalid source type for Compute\");\n\n``\nNote howExprComputeandSumComputeboth callSetVarto save the computed result.ExprComputedoesn't actually need to compute anything because it's already been done by the compiledTransformandSumComputedoesn't need to do any filtering because it's already done as part of theFilterRowssetup in theTransform` factory functions.\nAnd, that's it, you can now run it using:\n```c#\n        static void Main(string[] args)\n        {\n            var transform = Data.Load(Data.OperationsToPerform);\n        var state = InterpreterState.Empty.With(Rows: Data.Rows);\n\n        state.Output.Subscribe(Console.WriteLine);\n\n        var result = Interpreter.Interpret(transform, state);\n    }\n\nIt outputs:\nTotal Assets : 160000\nTotal Expenses : 40000\nBalance (Total Assets - Total Expenses): 120000\n``. @imranypatel Because I see this as a useful example for people learning this library I have decided to make it into an example project (and because it's probably hard to follow when everything is in one gist).  It currently resides in theSamplesfolder on [theasync-refactor` branch](https://github.com/louthy/language-ext/tree/async-refactor/Samples/AccountingDSL/AccountingDSL)\nI have taken the idea a bit further than your initial requirements.  It's now possible to avoid the manual building of the operations followed by 'loading' them into the Transform.  Now you can just use the scripts:\nc#\nTotalAssets = sum(filter(\"Asset\", rows));\nTotalExpenses = sum(filter(\"Expense\", rows));\nBalance = TotalAssets - TotalExpenses;\nlog(\"Total Assets : {TotalAssets}\");\nlog(\"Total Expenses : {TotalExpenses}\");\nlog(\"Balance (Total Assets - Total Expenses): {Balance}\");\nThe way I've achieved that is to support function invocation and variable assignment in the scripting system.  The functions sum and filter are provided in a ScriptFunctions class that allows you to extend the set of available operations without much hassle:\n```c#\n    public static class ScriptFunctions\n    {\n        public static Seq filter(string type, Seq rows) =>\n            rows.Filter(r => r.Type == type);\n    public static int sum(Seq<AccountingRow> rows) =>\n        rows.Map(r => r.Amount).Sum();\n\n    public static int count(Seq<AccountingRow> rows) =>\n        rows.Map(r => r.Amount).Count;\n\n    public static int avg(Seq<AccountingRow> rows) =>\n        sum(rows) / count(rows);\n}\n\nBelow is the test method for loading from a script:c#\n        static void Test_Script()\n        {\n            var script = @\" TotalAssets = sum(filter(\"\"Asset\"\", rows));\n                            TotalExpenses = sum(filter(\"\"Expense\"\", rows));\n                            Balance = TotalAssets - TotalExpenses;\n                            log(\"\"Total Assets : {TotalAssets}\"\");\n                            log(\"\"Total Expenses : {TotalExpenses}\"\");\n                            log(\"\"Balance (Total Assets - Total Expenses): {Balance}\"\"); \";\n        var result = from transform in Parse(script).Map(Compile<object>)\n                     let state = InterpreterState.Empty.With(Rows: Data.Rows)\n                     let disp = state.Output.Subscribe(Console.WriteLine)\n                     from _ in Interpret(transform, state)\n                     select unit; \n    }\n\n```\nNote, these functions and scripting extensions are available in the version where you manually build the operations.  Although, you only really need the Print operation now:\nc#\nPrint(\"Print messages after substituting computed Ids in each message format string\",\n    Seq(\n        \"Total Assets : { sum(filter(\"Asset\", rows)) }\",\n        \"Total Expenses : { sum(filter(\"Expense\", rows)) }\",\n        \"Balance (Total Assets - Total Expenses): { sum(filter(\"Asset\", rows)) - sum(filter(\"Expense\", rows)) }\"))\n. Exceptions don't go away with Try and if you're running the debugger then\nit will pause on all exceptions, that's just a sad fact of life, whether or\nnot you're inside a try/catch block or not.  It's annoyed me in the past\ntoo.  This isn't anything to do with lang-ext, you're not running lang-ext\ncode at the point of the exception, you're running your code.  I'd suggest\nposting the issue to the Visual Studio forums if you want something done\nabout it.\nOn Thu, 12 Apr 2018 at 12:40 Stefan Bertels notifications@github.com\nwrote:\n\nMaybe I'm doing something wrong, but I stumbled on this Debugger behaviour:\n            var bla = LanguageExt.Prelude.Try<string>(() => LanguageExt.Prelude.failwith<string>(\"test\"));\n            bla.Match(Succ: Console.WriteLine, Fail: Console.Error.WriteLine);\n\nSeems like default Visual Studio Debug/Exception settings will let the\ndebugger break at failwith because the Exception is \"unhandled in user\ncode\".\nThis only occurs if Debug setting \"Enable Just My Code\" is checked (AFAIK\ndefault) and there is no \"Additional Action\" defined in the specific\nException (see Exception Settings Windows => context menu =>\"Continue when\nunhandled in user code\") -- which AFAIK is default, too.\nDoes this mean: Try will always cause Debugger to stop when exception case\noccurs in Visual Studio default settings?\nAdditional note:\nhttps://docs.microsoft.com/en-us/visualstudio/debugger/managing-exceptions-with-the-debugger\nsays that libs with debugging info (pdb) are regarded \"My Code\" . So if we\nthink about how we could disable this behaviour for LanguageExt.\nAny other ideas / hints?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/401, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk1l3HVN5xS3Ug8afsNfptcYOrhMuks5tnz0QgaJpZM4TRoN_\n.\n. Closing, as there's nothing that I know of that I can do in code to affect Visual Studio.. > It is from this understanding that I thought the compiler would inline the lambda \n\nIt certainly does turn it into a method in an anonymous class , but it still has allocation costs:\n\nFirst class functions and Method Groups are not the same thing in C# (annoyingly).  And so all methods that take a Func or a Action will have to new a delegate before use.\nLambdas that capture free values (arguments that aren't explicitly provided to it) need a class declaration with the free values as member fields.  This obviously needs allocating.\n\nIn much of this library it's not a big deal, there's an expected churn of short-lived objects, that probably don't hurt the GC too much because they're in gen0 and don't ever get promoted to gen1.  But for certain functions (like use) that are supposed to be more like language features, I think it's much better to consider the impact of all allocations and anything that would be surprising to the end user. \nWhere possible it's best to stick to the core grammar of C# (if, else, for, etc.), avoid LINQ, avoid lamdas, avoid heap allocated types.  \nI'm sure you will have noticed that a lot functionality that uses the core data-types (like Option) will refer directly to their internal members rather than using Match to get at the values - it's explicitly for the reason of trying to minimise the overhead of the core functionality so that users of the library get as much for free as possible.  \nIt's not always the case that I have taken the most optimal route.  It's often for one of the following reasons:\n Premature optimisation is often bad - so it may have been an area that I thought would change\n Optimised code isn't always easy to maintain - so I may have thought the optimal version was unclear\n* Large refactors - Sometimes if I'm doing a bulk refactor (like the async refactor) then I'll stick with the safer code but slower code until I get a chance to go back an consider the performance impacts.\nIt's all pragmatism, obviously.  Just don't look at ugly imperative code and think \"that definitely should be more functional\", because it's this library's job to deal with that ugliness :)\n\nBtw, if you're ever unsure, just drop the compiled DLL into ILSpy - you'll see how the inner workings all language features are compiled.. Just as a follow up, take this simple class:\n```c#\n    static class TestClass\n    {\n        public static void TestMethod(int x)\n        {\n            var result = Run(() => StaticFunction(x));\n        }\n\n    public static A Run<A>(Func<A> f) =>\n        f();\n\n    public static int StaticFunction(int a) =>\n        a * a;\n}\n\nAnd this is the IL for `TestMethod`:c#\n.method public hidebysig static \n    void TestMethod (\n        int32 x\n    ) cil managed \n{\n    // Method begins at RVA 0x205a\n    // Code size 30 (0x1e)\n    .maxstack 8\nIL_0000: newobj instance void ConsoleApp5.TestClass/'<>c__DisplayClass0_0'::.ctor()\nIL_0005: dup\nIL_0006: ldarg.0\nIL_0007: stfld int32 ConsoleApp5.TestClass/'<>c__DisplayClass0_0'::x\nIL_000c: ldftn instance int32 ConsoleApp5.TestClass/'<>c__DisplayClass0_0'::'<TestMethod>b__0'()\nIL_0012: newobj instance void class [mscorlib]System.Func`1<int32>::.ctor(object, native int)\nIL_0017: call !!0 ConsoleApp5.TestClass::Run<int32>(class [mscorlib]System.Func`1<!!0>)\nIL_001c: pop\nIL_001d: ret\n\n}\n``\nAtIL_0000it callsnewobjto instantiate the anonymous type<>c__DisplayClass0_0` (which is allocated on the heap).\nIt then duplicates the object on the stack, then gets x (ldarg.0) and stores (stfld) it in the x field of the  <>c__DisplayClass0_0 type (which pops one of the copies of the anonymous class's references off the stack).  \nIt then loads a reference to the <TestMethod>b__0 method on the stack (which is the lambda function).  After that it creates a new delegate (Func) from that reference (which is allocated on the heap).\nFinally it invokes it (call). \nSo, that's two heap allocations.\nThis is the IL for the anonymous lambda class:\n```c#\n.class nested private auto ansi sealed beforefieldinit '<>c__DisplayClass0_0'\n    extends [mscorlib]System.Object\n{\n    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (\n        01 00 00 00\n    )\n    // Fields\n    .field public int32 x\n// Methods\n.method public hidebysig specialname rtspecialname \n    instance void .ctor () cil managed \n{\n    // Method begins at RVA 0x2052\n    // Code size 7 (0x7)\n    .maxstack 8\n\n    IL_0000: ldarg.0\n    IL_0001: call instance void [mscorlib]System.Object::.ctor()\n    IL_0006: ret\n} // end of method '<>c__DisplayClass0_0'::.ctor\n\n.method assembly hidebysig \n    instance int32 '<TestMethod>b__0' () cil managed \n{\n    // Method begins at RVA 0x2086\n    // Code size 12 (0xc)\n    .maxstack 8\n\n    IL_0000: ldarg.0\n    IL_0001: ldfld int32 ConsoleApp5.TestClass/'<>c__DisplayClass0_0'::x\n    IL_0006: call int32 ConsoleApp5.TestClass::StaticFunction(int32)\n    IL_000b: ret\n} // end of method '<>c__DisplayClass0_0'::'<TestMethod>b__0'\n\n}\n``\nYou should hopefully see it's just a regular class, with aint xfield, a constructor, and a method (which is the lambda's inner code.\n. Now, take a look at this example where I don't capture any free values and everything isstatic`:\n```c#\n    static class TestClass\n    {\n        public static void TestMethod(int x)\n        {\n            var result = Run(StaticFunction);\n        }\n    public static A Run<A>(Func<A> f) =>\n        f();\n\n    public static int StaticFunction() =>\n        1;\n}\n\nAnd now the IL for `TestMethod`c#\n.method public hidebysig static \n    void TestMethod (\n        int32 x\n    ) cil managed \n{\n    // Method begins at RVA 0x205a\n    // Code size 19 (0x13)\n    .maxstack 8\nIL_0000: ldnull\nIL_0001: ldftn int32 ConsoleApp5.TestClass::StaticFunction()\nIL_0007: newobj instance void class [mscorlib]System.Func`1<int32>::.ctor(object, native int)\nIL_000c: call !!0 ConsoleApp5.TestClass::Run<int32>(class [mscorlib]System.Func`1<!!0>)\nIL_0011: pop\nIL_0012: ret\n\n}\n``TestMethodstill needs to allocate adelegateon the heap to invoke theStaticFunction`.  \nIt's the same for local functions that do and don't capture free values.  It's a shit state of affairs, why the https://github.com/dotnet/csharplang team didn't re-write them as static functions with additional parameters, I don't know, but that's where we are.  . * Option's implementation is for efficiency reasons - the user never needs to see the underlying complexity.\n MOption is used, because it's part of the public API - it's there for generalist programming of monads (it's also heavily used in the HKT generated code)\n Bind can't be constrained to return the same type because C#'s type system doesn't allow it.  Until C# can do higher kinds we can't constrain the return value.  The system I have created is actually still valid in that it uses Monad.Return and Monad.Fail to construct a valid monad, so although, yes, you can return a different monad type, it's still entirely type safe (and arguably 'a better monad').. Yup will be a copy and paste issue . Leave it for now.  It's a system I will be replacing eventually.  . > Is it possible to directly turn a method group into the appropriate Action and Func type \nOnly if all the types are known.  Welcome to C# - the language that can\u2019t infer the types from a single method in a method-group.\nI\u2019ve complained about this on csharplang before.  Nothing is going to change in this area, which is super annoying . > My understanding is that this shouldn't be possible, given that the memoizer is using a WeakDictionary\nIndeed, I'd be very surprised if that was the case.  This is probably a symptom of a memory leak elsewhere.  There's a unit test which tests the memo feature by going through all 4 billion+ integers and converts them to a memo'd string, it's usually commented out because it takes so long to run; but running it shows the dotnet process to not go over 80mb of usage at any point:\n```c#\n            var mbStart = GC.GetTotalMemory(false) / 1048576L;\n        Func<int, string> fn = x => x.ToString();\n        var m = fn.Memo();\n\n        Range(0, Int32.MaxValue).Iter(i => m(i));\n\n        var mbFinish = GC.GetTotalMemory(false) / 1048576L;\n\n        Assert.True(mbFinish - mbStart < 30);\n\n``\nSo, it might be worth getting a memory profiler on the case to see where the leaks are.. @ntwilson Closing as I've had no follow up..HandleTestMessage` can just be this:\nc#\nstatic Either<string, MessageResult> HandleTestMessage(JObject msg) => \n    from type    in GetTestMessageType(msg)\n    from handler in GetTestHandler(type)\n    select handler(msg);\nIf you really need to stick \"Error: ...\" on the front, then call:\n```c#\nstatic Either HandleTestMessage(JObject msg) => \n    (from type    in GetTestMessageType(msg)\n     from handler in GetTestHandler(type)\n     select handler(msg))\n    .MapLeft(TestMessageResultError);\n. Just to be clear, this is a limitation of C#.  When you use the ternary operator:c#\n   a = b ? c : d;\n``\nIf there isn't a common base type shared bycanddthen C# will claim it can't infer the type of the expression.  Even if the type ofa` is known.  \n\nThe return type for Right<R>(r) is EitherRight<R>\nThe return type for Left<L> is EitherLeft<L>(l).\n\nThey don't share the same base type\nAnd therefore C# can't work out what's going on.  So, you can't do this:\nc#\n    var a = b \n        ? Right<R>(r) \n        : Left<L>(l);\n\nThe return type for Right<L, R>(r) is Either<L, R>\nThe return type for Left<L, R>(l) is Either<L, R>.  \n\nWhich clearly share the same return type (note both L and R are provided for both), and so you can call:\nc#\n    var a = b \n        ? Right<L, R>(r) \n        : Left<L, R>(l);\nNow the Bind function that can be called on EitherLeft<L> or EitherRight<R> is there to provide the other type in the Either \nSo,\n For EitherLeft<L> the Bind operation provides the R type.\n For EitherRight<R> the Bind operation provides the L type.  \nSo, there are 3 ways you can do this.  And the one you chose should probably be based on the resulting attractiveness/readability of the code:\n```c#\n    static Either> GetTestHandler(string type) =>\n        type == \"GET_AUTHORS\"\n            ? Right(HandleGetAuthors)\n            : Left($\"Invalid Message type {type}\").Bind>();\nstatic Either<string, Func<JObject, MessageResult>> GetTestHandler(string type) =>\n    type == \"GET_AUTHORS\"\n        ? Right(HandleGetAuthors).Bind<string>()\n        : Left($\"Invalid Message type {type}\");\n\nstatic Either<string, Func<JObject, MessageResult>> GetTestHandler(string type) =>\n    type == \"GET_AUTHORS\"\n        ? Right<string, Func<JObject, MessageResult>>(HandleGetAuthors)\n        : Left<string, Func<JObject, MessageResult>>($\"Invalid Message type {type}\");\n\n```. > here's the concrete example of what I'd like to accomplish.\nBut there's no Writer used?  Am I missing something?. > I'd like to provide an alternative that will return, in addition to the existing return, a log for this function.\nI just read this fully.  \nSo, it looks from the code that you're trying to follow the free-monad approach.  So, the easiest thing is to use the interpreter state to propagate the logged values, and then return it with the result.  \nI've done a pull request on your repo to demonstrate: https://github.com/trbngr/infusio/pull/5. btw, other approaches I've used is to have a Subject<LogMessage> in the interpreter state.  Then the Log action can call state.Output.OnNext(msg) and external 'stuff' can subscribe to the messages coming through (might be better for the async approach, which is where I've used this before).. You could also just have the Log function push to some mutable state.  Less functional obviously, but in some ways the point of the interpreter is to package up all the messy stuff, so as long as its controlled it doesn't really matter (i.e. you could push logs to a DB, or to a txt file, or whatever). @iSOcH  This is 'fixed' on v3.0.2 you should use named arguments to pick the correct overload:\nvar y = x.TryGetValue(Key: k);. I would suggest talking to the authors of YAXLib. Json.net will use the\nconstructor to build immutable types, maybe YAXLib it doesn\u2019t.\nFor your explicit example above try adding ISerializable to the inherited\ninterfaces\nOn Mon, 14 May 2018 at 22:47, Hong Zhang notifications@github.com wrote:\n\nI declare a new type called SalesType, which is just a string with a\nfixed number of possible values.\nI am using YAXLib for XML serialization.\nFor some reason, the serialized XML always has null for that field.\nHere is the code:\n[Serializable]\n  public class SalesType : NewType\n  {\n      public SalesType(string value) : base(value)\n      {\n          if (!(value.Equals(\"Create\", StringComparison.InvariantCultureIgnoreCase) ||\n              value.Equals(\"Void\", StringComparison.InvariantCultureIgnoreCase)))\n          {\n              throw new ArgumentException(\"SalesType must be either Create or Void\");\n          }\n      }\n  public SalesType(SerializationInfo info, StreamingContext context) : base(info, context)\n  {\n  }\n\n}\nI tried to override the ToString and explicitly returns the value. Didn't\nhelp at all.\nJust want to know if I really have to write a custom serializer.\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/417, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk7SyxeQBPqtvcJH6BJk85Vt1H5bwks5tyft8gaJpZM4T-kcY\n.\n. This is wrong.  The || is there to propagate the errors, && is the same as \u2018from\u2019 which doesn\u2019t . That\u2019s a blatant copy and paste bug, it should be testing if the value is Time.  Fancy doing a pull request? \nOn 17 May 2018, at 10:32, thehoglet notifications@github.com wrote:\nWhat should be the result here:\n    var t1 = 123.Seconds();\n    var t2 = 123.Seconds();\n\n    object o1 = t1;\n    object o2 = t2;\n\n    var b3 = o1.Equals(o2);\n\n?\nI'm getting false. Judging by this code from Time.cs, the intent is to compare the .Value in each instance. If so, the runtime type check (Length?) is in error.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Fix deployed in v3.0.2 (thanks @bender2k14 ). > If desired, I can incorporate my implementations of Force, Pressure and Temperature plus one for Mass (plus unit tests) into language-ext and issue a pull request. Let me know.\n\nYes please\n\n(In implementing a UoM for force, I omitted any mention of mass. I'm guessing the best return for the multiplication operator for the language-ext Accel type, if the LHS/RHS is mass, is a Force instance\n\nI'm not sure I'm following what you're saying here.  The return value for the operators should be based on the operands.  So if you multiply an Accel by a scalar value (a double for example) then you should just get an Accel back, Accel x Accel should be AccelSq, etc.  If you divide an Accel by an Accel then you'd get a non-units value out of it (double).  \nIn all instances it's better to not provide the operator than provide one with a half-arsed solution.  . @bender2k14 \n\nI have put some though into what names to use for these two units of measure. I currently like the name Information and InformationRate. The first sentence from the Wikipedia article for Information theory says\nInformation theory studies the quantification, storage, and communication of information.\nThe size of a file is an example of quantification, the capacity of a directory is an example of storage, and the rate of a data transfer is an example of communication.\n\nI like the purity of what you're suggesting (name-wise), and the idea in general, but do you think names like Information are just a bit too vague sounding for most users?  Is there scope here for coming up with something more descriptive (without too much penalty in terms of the length of the unit name)?. > So, in conclusion, my preference is still for Information and InformationRate.\nYes, with a bit more thought I'm ok with this.  Especially as it will be in the UnitsOfMeasure namespace and is therefore unlikely to cause clashes with users' types.. There's no shortcut really, aside from writing a Roslyn plugin that rewrites the syntax tree of your compilations.\nI use this approach that I outlined on stackoverflow a while back. Thanks \ud83d\udc4d . I agree there should be a single Temperature type, not multiple ones.  Just like there's only one Length and all other units are converted to metres we should probably represent all temperatures in Kelvin.  \nTo deal with the different zero points I'd do this:\n```c#\n        public struct Temperature\n        {\n            enum ScaleType : byte\n            {\n                Kelvin,\n                Celcius,\n                Fahrenheit\n            }\n        readonly ScaleType Scale;\n        readonly double Value;\n\n        Temperature(ScaleType scale, double value)\n        {\n            this.Scale = scale;\n            Value = value;\n        }\n\n        public static Temperature operator*(double x, Temperature k) =>\n            k.Scale == ScaleType.Kelvin     ? new Temperature(ScaleType.Kelvin, x * k.Value)\n          : k.Scale == ScaleType.Celcius    ? new Temperature(ScaleType.Kelvin, ((x * k.Value) + 273.15))\n          : k.Scale == ScaleType.Fahrenheit ? new Temperature(ScaleType.Kelvin, ((x * k.Value) + 459.67) * 5.0 / 9.0)\n          : throw new NotSupportedException();\n\n         ....\n    }\n\n``\nThen only the non-Kunits multipliers likedegCwould ever construct aTemperaturewith aScaleTypethat's notScaleType.Kelvin`, all other constructions would be with the converted values.\nThere's probably an argument for maintaining the ScaleType and maintaining the original units for as long as possible (for example if all calculations are done in Celsius then it may make sense to keep them that way until they're multiplied with another unit type, but that would add a ton of complexity I think).  I suspect just supporting Round(x) would make things ok.\nAlso, could we use the full word Temperature rather than Temp, as Temp would definitely look like shorthand for temporary for most devs I think.\nThe benefit of sticking with Kelvin as the default is that absolute zero is 0 and so default(Temperature) will be absolute zero.. Ok, my calcs were wrong (fixed now), but you get my point ;). > Do you realize that even adding two Temperature instances is troublesome when the zero points could be different? I am unable to tell if you realize that.\nMaybe I'm missing something, it's been a long day, but if they've both been converted to a common unit then what's the issue?  Obviously there's potential rounding issues of double precision floating point values, but are you referring to something else?. Never mind, it's clear now.  Although it's too late for me to think of a solution that isn't ugly.  I'll have a think tomorrow.. I still think the whole thing can be contained within a single Temperature type, but for addition and subtraction we only need to know the delta from the zero point (of the right-hand-side) and the units that the type is in internally.  So for example if you say 1K + 1\u00b0C then one degree is the same in Kelvin and Celsius, so the result can be Temperature(ScaleType.Kelvin, 1+1) for 1K + 1\u00b0F we could do Temperature(ScaleType.Kelvin, 1+(1*5/9)).  \nThe left hand side of the operation should dictate the resulting internal units type.\nAs long as each operator takes into account the units its working with and the operation its performing then I think we can maintain a consistent units system (i.e. we don't have a type per unit, but a type per thing being measured).\nObviously if there was a never ending list of temperature unit types then this wouldn't be a tenable approach.  But there aren't, so I think hiding the messiness for a consistent interface is preferable.. > Now after writing all this, I think I like the second solution better. However, I still don't like the idea of being able to multiply a Temperature by a scalar.\nYes, it makes total sense.  10\u00b0c * 2 should be 20\u00b0c.  Temperature * Temperature doesn't make sense though.  Because then we'd need a TemperatureSq type - which doesn't really have any real world usage.. I think you're massively over thinking this.\nIf I get 10 cm and add 5 cm to it, I would expect to get a result of 15 cm.\nIf I get 10  \u00b0C and add 5  \u00b0C to it, I would expect to get a result of 15  \u00b0C.\nI don't need a new type called CentimetresDelta or CelciusDelta, the operation being performed gives context to the operands.  \nThe zero point is irrelevant when the operation is addition and subtraction.  Because the 'base point' isn't the zero point, it's the left-hand side.  In my examples above, it's 10 cm and 10  \u00b0C.\nThe most important thing when doing delta operations is that the scale of 1 degree is consistent.  So, with  \u00b0C and K the size of 1 degree is the same - so if I add 1 \u00b0C to 1 K then I would expect the result to be 2 K, but with \u00b0F we need to scale the value to be consistent with  \u00b0C and K, and ignore the zero-point altogether.  \nI feel this whole thing is going around in circles, so I have done an implementation and committed it.  I'd appreciate all interested parties to take a look (and check my calculations).  I've done a handful of unit tests, but if anyone wants to add more, then I'd be eternally grateful.\n\nLanguageExt.Core/DataTypes/UnitsOfMeasure/Temperature.cs\nLanguageExt.Tests/UnitsOfMeasureTests.cs. > That is not my suggestion. Sorry for giving you that impression.\n\nNo problem.\nI was just thinking a bit more about it, trying to make sure my point is clear.  And it kinda dawned on my that we're probably discussing edge cases here.  Anybody doing operations on temperatures are likely to always be in the same unit anyway, especially for delta operations - you'd have to be some kind of nihilist to be mixing units in an important calculation.  The only time any of this is likely to impact anyone (in the real world) is when converting for display reasons (I suspect).  \nThe type supports three properties: Kelvin, Celcius, and Fahrenheit to convert between the various units, and I suspect that's the most anybody will ever see of this really.. > So why not eliminate all of those edge cases by using explicitly  different types \nBecause then it's entirely inconsistent with all of the other UoM types.. I have made the addition and subtraction operators use the absolute values now.  If someone is adding 1\u00b0C to 1K then that's something they'll find in testing when nothing works as they expected, having a single type called Temperature is more valuable in my opinion (the only other viable solution in my mind is to change all unit types to be the measurement type rather than the concept it's measuring - which risks breaking a lot of user code).\nAnyway, it's not worth losing sleep over and I'd prefer we concentrated on getting the rest of this pull request into a good state.  . @Richiban It works for me, so make sure you're on the latest version and re-check if possible.\nReally, records should be closed immutable types, that's what the lang-ext record features are designed for.  Your type is very much the opposite: built for inheritance and mega-mutable.  \nPersonally, I would implement your above type like so:\n```c#\n    public class CacheInvalidationMessage : Record\n    {\n        public readonly Guid Id;\n        public readonly string CacheProfileKey;\n        public readonly string CacheItemKey;\n        public readonly Lst InvalidationItems;\n    public CacheInvalidationMessage(\n        Guid id, \n        string cacheProfileKey, \n        string cacheItemKey, \n        Lst<CacheInvalidationItem> invalidationItems)\n    {\n        Id = id;\n        CacheProfileKey = cacheProfileKey;\n        CacheItemKey = cacheItemKey;\n        InvalidationItems = invalidationItems;\n    }\n\n    public CacheInvalidationMessage AddInvalidationItem(CacheInvalidationItem item) =>\n        With(InvalidationItems: InvalidationItems.Add(item));\n\n    public CacheInvalidationMessage With(\n        Guid? Id = null, \n        string CacheProfileKey = null, \n        string CacheItemKey = null, \n        Lst<CacheInvalidationItem>? InvalidationItems = null) =>\n            new CacheInvalidationMessage (\n                Id                ?? this.Id, \n                CacheProfileKey   ?? this.CacheProfileKey, \n                CacheItemKey      ?? this.CacheItemKey, \n                InvalidationItems ?? this.InvalidationItems);\n}\n\n```\nI note it's a message type and that's probably why you're compromising it by making it mutable and not having a single constructor that forces everything to be set.  I know sometimes it can seem difficult to get immutable types working with serialisation, but if you're using Json.NET then it will work as-is; if you're using other serialisation providers then you may need to do this:\n```c#\n    [Serializable]\n    public class CacheInvalidationMessage : Record, ISerializable\n    {\n        public readonly Guid Id;\n        public readonly string CacheProfileKey;\n        public readonly string CacheItemKey;\n        public readonly Lst InvalidationItems;\n    public CacheInvalidationMessage(\n        Guid id, \n        string cacheProfileKey, \n        string cacheItemKey, \n        Lst<CacheInvalidationItem> invalidationItems)\n    {\n        Id = id;\n        CacheProfileKey = cacheProfileKey;\n        CacheItemKey = cacheItemKey;\n        InvalidationItems = invalidationItems;\n    }\n\n    public CacheInvalidationMessage(SerializationInfo info, StreamingContext ctx)\n        : base(info, ctx) { }\n\n    public CacheInvalidationMessage AddInvalidationItem(CacheInvalidationItem item) =>\n        With(InvalidationItems: InvalidationItems.Add(item));\n\n    public CacheInvalidationMessage With(\n        Guid? Id = null, \n        string CacheProfileKey = null, \n        string CacheItemKey = null, \n        Lst<CacheInvalidationItem>? InvalidationItems = null) =>\n            new CacheInvalidationMessage (\n                Id                ?? this.Id, \n                CacheProfileKey   ?? this.CacheProfileKey, \n                CacheItemKey      ?? this.CacheItemKey, \n                InvalidationItems ?? this.InvalidationItems);\n}\n\n``\nI'd also question the usage ofvirtualfor theId, again it's not really in the spirit of a record-type.  I was surprised it worked for me to be honest, but it appears to still use the backing field forId, but note, any overridden implementation ofIdwon't be respected byRecordType.ToString(x), and so if you are thinking of doing inheritance for these types (rather than composition) then I'd pass theidup the constructor hierarchy (base(id, ...)` . > I know, I know...\nYeah, I figured you would based on your previous comments here.  \ud83d\udc4d \n\nI'm guessing that my version of LanguageExt is out of date.\n\nCool, shout if you're still getting issues.  You will still fall foul of the inheritance on Id though, so beware on that one with types derived from CacheInvalidationMessage. Thanks \ud83d\udc4d . Sorry, I thought I\u2019d deployed it already.  I\u2019m away for a couple of days.  I\u2019ll try and sort it this weekend . The right hand side is being treated as a relative value, not an absolute one.  This is intentional.. ToEitherAsync already exists from Option<A>, the other extensions (because it's not only MapAsync requires a fair amount of typing), so I'd stick with ToEitherAsync for now.. > Would it be possible to change the way LanguageExt specifies it's dependencies to use a minimum allowable version\nDoes anyone know how to do this in the new csproj reference spec?  I was able to do it when project.json was a thing, but googling this is remarkably difficult.. @SeanFarrow Hi Sean, I've decided to relent and create a LanguageExt.Rx package, so unless you specifically need the Rx features then you can just update to the latest LanguageExt.Core and the Rx dependency will be removed.\nI did use the wildcard system to require version * for Rx which in theory should allow it to work with any version of Rx (as I'm only using the real core functionality), but it seems that has clamped it to >= v4 in nu-get, which is a touch frustrating!\n. @SeanFarrow It contains the extension methods that work with IObservable.  I tried another approach to versioning, using ranges:\nc#\n<PackageReference Include=\"System.Reactive\" Version=\"4.0.0\" allowedVersions=\"[2,10]\" />\nThat should allow version 2.0.0 to 10.0.0, but doesn't seem to change anything on nuget.  I opened up the package in the Nuget Package Explorer.exe and it doesn't seem to respect the range.  So, not 100% sure of the best approach.  \nI haven't got time to check at the moment, but maybe just setting Version=\"3.*\" would allow all versions above 3.0.0 (including 4.0.0) to be used.  Needs some testing.\n. I managed to convince nu-get to use a range using :\n<PackageReference Include=\"System.Reactive\" Version=\"[3.0.0,5.0]\" />. Sorry for the delay in deploying, I thought I'd already merged this.  On nuget now 3.0.16.  Thanks again.. Thanks :). Sorry for the delay in deploying, I thought I'd already merged this.  On nuget now 3.0.16.  Thanks again.. I thought I'd found all Task.Runs in the async refactor, seems not.  Anyway, this is fixed now and deployed.. Yep, it\u2019s probably a copy and paste bug\nOn Wed, 13 Jun 2018 at 22:23, Tyson Williams notifications@github.com\nwrote:\n\nThe parser combinator called count\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Parsec/Parsers/Prim.cs#L512\nhas an unused type parameter.\nParser count(int n, Parser p)\nShould this unused type parameter be removed?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/435, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkwqOV_0K_70CLowI8j3pNSPf7BObks5t8YLGgaJpZM4Um9Q-\n.\n. I think it\u2019s dotnet pack that\u2019s the problem, before that we had docs, I\nkeep meaning to look into it but very short of time atm\n\nWeirdly VS has started stepping into the source for me now when debugging -\nI think it was the latest update, which is super annoying\nOn Wed, 13 Jun 2018 at 22:29, Tyson Williams notifications@github.com\nwrote:\n\nWhen I use the \"Go To Definition (F12)\" feature in Visual Studio on a type\nor method in Language Ext, I am taken to file that does not have any\ndocumentation. It only has the signatures. See this image.\n[image: screenshot 2018-06-13 16 25 30]\nhttps://user-images.githubusercontent.com/34664007/41379120-c5707d68-6f26-11e8-87b3-27117e1c40a2.png\nDo other people experience this as well or is my development environment\nnot configured correctly?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/436, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk04HZnk5pHuCwpbJX1DTXy-hQVq5ks5t8YRNgaJpZM4Um91B\n.\n. @bender2k14  After incrementing the version numbers using inc.bat I run pack.bat to build the project:\nc#\ndotnet restore\ndotnet pack LanguageExt.Core -c Release -o ../../artifacts/bin\ndotnet pack LanguageExt.FSharp -c Release -o ../../artifacts/bin\ndotnet pack LanguageExt.Parsec -c Release -o ../../artifacts/bin\ndotnet pack LanguageExt.Rx -c Release -o ../../artifacts/bin\nAnd then run a little console app I wrote to push to nu-get.\n\nIt has a function in it for invoking the nuget.exe\n```c#\n        static void Nuget(params string[] parms)\n        {\n            var process = new Process {\n                StartInfo = new ProcessStartInfo {\n                    FileName = \"nuget.exe\",\n                    Arguments = String.Join(\" \", parms.Select(p => p.Contains(' ') ? $\"\\\"{p}\\\"\" : p)),\n                    UseShellExecute = false,\n                    RedirectStandardOutput = true,\n                    RedirectStandardError = true,\n                    CreateNoWindow = true\n                }\n            };\n        process.Start();\n        while (!process.StandardOutput.EndOfStream)\n        {\n            Console.WriteLine(process.StandardOutput.ReadLine());\n        }\n        while (!process.StandardError.EndOfStream)\n        {\n            Console.WriteLine(process.StandardError.ReadLine());\n        }\n    }\n\n``\nWhich is called like so, for eachnupkg`:\nc#\n    Nuget(\"push\", file, apiKey, \"-src\", \"nuget.org\");\nFor a while dotnet pack was terrible and refused to work with various aspects of the project files, but I did before all the .NETCore debacle have a source documentation build, but like I say I'm not really time wealthy at the moment, so this has slipped off the radar.. This is fixed in v3.0.23 thanks @rantri . Agreed, the A B C route is my preferred approach now. It just feels more\nelegant than T, dunno why.\nWill check the pull request when I get back to my pc\nOn Wed, 13 Jun 2018 at 23:09, Tyson Williams notifications@github.com\nwrote:\n\nWhen a function has multiple type parameters, I have seen two styles for\nnaming them in Language Ext. One to name them like T1, T2, T3 and the\nother is to name them like A, B, C. I have come to really prefer the\nlatter.\nThis PR changes form the first style to the second style for the functions\nin one file. It also changes the parameter names (that were a and b) to\navoid confusion with this new type parameter names.\n\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/louthy/language-ext/pull/437\nCommit Summary\n\nremove unused usings\nchanged parameter names to better distingish them from the new type\n   parameter names to coming next\nreplaced type parameters like T1, T2, and T3 with type parameters\n   like A, B, and C\n\nFile Changes\n\nM LanguageExt.Core/Compose.cs\n   https://github.com/louthy/language-ext/pull/437/files#diff-0 (52)\n\nPatch Links:\n\nhttps://github.com/louthy/language-ext/pull/437.patch\nhttps://github.com/louthy/language-ext/pull/437.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/437, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kkzxd_h2Jt_TW-LKq07zsjQGZqslTks5t8Y2lgaJpZM4UnA7z\n.\n. > Changing those to their Success cases get's us farther along.\n\nIt can't be changed to a Success state without a SUCCESS value.  So, it must be a fail state with the zero value for the failure type.  Ideally we need a ValidationAsync like EitherAsync to capture the special case.  \n. Well spotted, thanks! . @michael-wolfenden That would require a whole new version of NewType that supported Validation, because any changes here would break lots of users' code.  I don't think it's a trivial job, so I'll need to leave it on the nice-to-have list for now.\nAs a stop-gap I have added NewTry(A value) and NewOption(A value) to NewType, NumType, and FloatType - that return Try<NEWTYPE> and Option<NEWTYPE> respectively.  The will both capture exceptions.\nIt's not quite the solution you're looking for, but it's a bit closer.\n. Nice, thanks!. I won't be renaming it, it'll break lots of users' existing code.  What I do is this\nc#\nusing G = System.Collections.Generic;\nThen I can reference the BCL HashSet as G.HashSet\nObviously you could do it the other way around if you have lots of usage of the Generic types:\nc#\nusing L = LanguageExt;\nThen you can reference the Language-Ext HashSet as L.HashSet\n. @mattfurness  Hi Matt, it was a conscious decision to do this, because:\n\nReally there's only one way to compose Tasks, which is the way that the async keyword does it: continue on success, bail out on fail/cancel.  So replicating that in Select and SelectMany made sense.\nIt also made sense that it should be a feature of Task already and not something to explicitly opt in to.  i.e. Task should be a Task monad, it just made sense.\n\nI can see the issue though, mostly when I've done this in the past (putting the extensions in the global namespace) it has been to extend types that belong to lang-ext, so I can totally see your point that it can cause clashes with other implementations.\nObviously moving it to the LanguageExt namespace is what needs to happen.  Although also obviously it sounds like that will still preclude you from using the LanguageExt namespace along with your other extensions, but at least you'll have the choice.  \nOut of interest what are you doing in your version of Select for Task?  Is it the same mapping functionality?  . Yep, understood.  If you fancy doing a pull request that I can just deploy when I get back in front of my machine (may be Sunday or Monday) that\u2019d be great.\nPaul\n\nOn 28 Jun 2018, at 09:01, Ben Tefay notifications@github.com wrote:\nI can provide a bit more detail (I work with @mattfurness).\nWe have an extension method:\nnamespace Company { \n    public static class Extensions {\n        public static Task> Select(this Task> task, Func func);\n    }\n}\nWhen it comes to extension method overload resolution, if the target method is ambiguous (as it is in this case between Language Ext's Select method and ours), the method in the shallower namespace wins. Because the global namespace is shallower than our Company namespace, the Language Exts' Select method wins. If we put our extension method into the global namespace, the compiler can no longer disambiguate the methods and raises an error: The call is ambiguous between the following methods.\nLong story short, by putting public static async Task Select(this Task self, Func map) in the global namespace, it becomes impossible for consumers of Language Ext to write a Select extension method on a Task of something more specific.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. This is now deployed.  Thanks for the pull request \ud83d\udc4d . Thanks @mattfurness . ToValidation and ToEither extensions now allow an optional mapping function.  It is still better to build bespoke extension methods for your projects, as it's likely to be repeated effort, but these new conversion methods will help.\n\nhttps://github.com/louthy/language-ext/releases/tag/v3.0.19. @StefanBertels Looks like TInt, TLong, and TShort make the same mistakes.  Do you want to fix those too?. Thanks @StefanBertels \ud83d\udc4d . > My understanding of Monadic composition is that it does not produce effects as a result of the composition\nThat's not strictly true.  It all depends on whether the type is lazy or strict.  All the Option, Either, Seq, etc. monads are strict and invoke immediately too.  In this case the type is a lazy type and therefore it probably should be changed.. No we\u2019re not.  They\u2019re all pure.  The computations only stop being pure if they perform operations that interact with the outside world.  There\u2019s no obligation for Try to be lazy or strict, it\u2019s merely a side-effect of Try being implemented as a delegate: that makes it lazy.  But it could just have easily been implemented strictly.  \nThe moment of execution of the computation has nothing to do with its  referential transparency . > OptionAsyncTests.Issue206()\n\nMemoTests.MemoTest3()\n\nYes, there are a few time-critical tests which often fail when running all tests.  I usually run them by hand after doing a full run.  Don't worry too much about those. \nThe pull request is accepted, thanks.\n. Thanks Simon \ud83d\udc4d . > and somehow mucking up the memoization\nThere's no memoization here because the Try<object> is generated every time the enumerable is evaluated.\nThe partition function looks like this:\nc#\npublic static (IEnumerable<A> Lefts, IEnumerable<B> Rights) partition<CHOICE, CH, A, B>(IEnumerable<CH> ma)\n    where CHOICE : struct, Choice<CH, A, B> =>\n    (lefts<CHOICE, CH, A, B>(ma), rights<CHOICE, CH, A, B>(ma));\nWhich as you can see will run the enumerable twice.  I could probably update it to:\nc#\npublic static (IEnumerable<A> Lefts, IEnumerable<B> Rights) partition<CHOICE, CH, A, B>(IEnumerable<CH> ma)\n    where CHOICE : struct, Choice<CH, A, B>\n{\n   var sa = Seq(ma);\n   return (lefts<CHOICE, CH, A, B>(sa), rights<CHOICE, CH, A, B>(sa));\n}\nBut that could give unexpected results for large streams (memory usage). \nYour second example doesn't call partition and so it gives the expected number of attempts.\nReally, this is expected behviour from Enumerable, if your code was pure then it would be correct.  And so, I'm slightly unwilling to put in any fix here.\nThere is a Seq version of partition, so if you did this (below) I would expect a consistent result:\n```c#\n    var objFactory = new ObjFactory();\n    Try Create(int i) => () => objFactory.Create(i);\nvar attempts = Enumerable.Range(0, 3).Map(Create);\nvar (failures, successes) = partition(Seq(attempts));\n\nvar objs = successes.ToArr();\nvar exceptions = failures.ToArr();\n\nConsole.WriteLine($\"NCalls = {objFactory.NCalls}\");\n\n``. @lucasteles Hi Lucas, we already have this as theCond` type.  I think continuations are of limited use to be honest, and I don't think it gets much usage.  I would much prefer to try and formulate a general case Free monad which would be the ultimate mechanism for chaining computations.. > By the way, i liked the Idea off using the \u2019>\u2019 e \u2019>=\u2019 operators for simulate fsharp \u2019|>\u2019\nI've considered it a number of times, but I'm not 100% sure it's a good idea.  I think it can look quite elegant if you know what it is, but to an outsider who's looking at your code (and is a C# programmer) they will probably be a bit confused.\nI tend to use || and | for mplus but that's about the extent of it (relying on LINQ instead for bind). I\u2019ll take a look today . @xlecoustillier \n\nIs there a reason why there is no Succ() and Fail() fluent methods available for Validation type\n\nYep, sometimes I'm lazy ;)  I have added the fluent versions and they'll be in the next release.\n. Released in v2.0.30. > My concern is that it allows developers to circumvent all of the goodness that Option provides.\nIn your example it would throw a Sequence contains no elements exception.  That is a general risk with the LINQ API.\nThe reason for supporting this is:\n1. To make the type work with Json.NET --- yes, annoying, but Json.NET kept breaking with this type so I made it support the enumerable serialiser that seems to never break.\n2. It's relatively natural to think of an Option as a collection of zero or one items.\n3. Because of the above concept it means you can easily use Option in LINQ expressions with other enumerable types without converting them manually.\nI would prefer it to not be an IEnumerable and instead have manual conversion to IEnumerable, but unfortunately reason 1 is such a biggy in .NET-land that I need to maintain it.  The amount of times that I made Option work with Json.NET, only for a bug to be raised a month later that it doesn't deserialise, was ridiculous.. I guess a final point is this: even if it weren't an IEnumerable you'd still be able to do this:\nc#\n   var x = option.AsEnumerable().First();\nAt some point you just need better policies in place internally to stop devs doing stupid shit.  . Your preference is not my preference or many other\u2019s preferences. Most\npeople want serialisation to \u2018just work\u2019 - especially with the most popular\nmethod of serialisation in the .net world.\nOn Wed, 1 Aug 2018 at 16:21, Tyson Williams notifications@github.com\nwrote:\n\nWhy do you care so much about serialization for Option<>?\nIf I serialize and deserialize with Option<>, then I am allowing my\napplication the possibility of crashing at runtime when the implementation\nof Option<> changes. I only want my application to depend on the public\nAPI of Language.Ext. That way the compiler can tell me if something has\nchanged.\nAny time data needs to cross a boundary like serialization, I prefer to\nuse Data Transfer Objects (DTOs) designed specifically for the job of being\nserialized from and being deserialized to. Then this runtime crash will\nonly occur if we modify our DTOs.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/456#issuecomment-409612906,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk-OjCd0PD07tLJH9xpON438plJg9ks5uMcdcgaJpZM4Vo9Tl\n.\n. I was away from my machine, this is a more considered response:\n\n@bender2k14 I think you have a tendency toward absolutism, which in software development is rarely useful.  \nYour premise is this: You can't rely on serialisation of 3rd party types, so you must build your own, because it might change in the future.\nI always come at problems from the point-of-view of a working programmer and what their needs are.\nSo, let's list some needs for serialisation:\n\nStoring settings in a file\nStoring a representation of an object in a database\nSending a message from one service to another\nStoring a representation of an object in a cache (say Redis)\n\nThen let's also look at the premise of lang-ext:\n\"To provide a functional-programming 'Base class library'\"\nThe idea of a 'base-class library' is to be as static as possible.  No breaking changes.  Now, obviously that's not entirely true, but that it is a goal of this library to become more and more fixed over time.  Things like the format of serialised types should never change.\nStoring settings in a file\nOk, so the options are:\nI call:\nc#\n    File.WriteAllText(file, JsonConvert.SerializeObject(settings));\nOr, I build my own serialiser.  Or, I copy the settings to a new type that doesn't have things like Option in and serialise that.  \nThen I load them with:\nc#\n    var settings = JsonConvert.DeserializeObject<Settings>(File.ReadAllText(file));\nOr, I write my own deserializer, which then sets up the Settings type.\nThe problems I see with the first approach are the same as what you state.  If the underlying serialiser changes, then you can't load your settings.  The problems I see with the second approach is that, with each setting you add, you have to remember to update your serialiser and deserialiser.  It also uses more memory and is probably slower (although for this use-case that probably doesn't matter).\nWhat's the mitigation strategy for the first issue?  Write a settings file migrator to migrate old to new.  Probably involves loading up the file with:\nc#\n    /// Note: it's the untyped variant\n    JsonConvert.DeserializeObject(File.ReadAllText(file));\nThen manually fixing up the bad data and re-saving.  \nI'd argue that isn't so bad if your settings file has a version number in it, or gains one after migration.  The alternative of building your own serialiser and maintaining a mirror structure is full of potential error vectors: copy n paste problems, missing item problems, dealing with null, etc.\nStoring a representation of an object in a database\nThis is pretty much the same problem as above, but I suspect that the reason the object is in a database in the first place is that there are multiple services using it.  This is where decisions need to be made:\n\nYou can either take all services down, migrate the data, and bring them back up\nOr, you can abstract the serialisation as you advocate\n\nAgain, this will depend on the project.  Neither options are perfect.  You will still get the silent bugs with the second option, but the first has downtime implications, or on-screen user error implications with non-migrated data.\nThis is where the performance implications start to rear their head.  You incur costs by copying data to intermediate types, or by writing your own poorly considered serialiser.\nSending a message from one service to another\nOk, so this will depend on whether the message is ephemeral and/or important.  Most service architectures should be designed to survive any message being lost, so if a message fails to deserialise then it seems reasonable to fire it off to dead-letters.  \nSo, why would you ever want to erase the important type information of something being optional? (by migrating to an intermediate 'DTO' type without the Option, Either, etc. in it)\nWell, in some systems it may not be possible to update every service in the distributed architecture and therefore an Option being serialised and deserialised in different ways isn't going to help anybody.  That would be a reason to go the route you advocate.\nThe flip side of the argument is that Option serialisation and deserialisation never changes.  And if it did, then you could plan the migration of your architecture.  The reason I say this is: what do you want to spend your day on?\n\nWriting DTO objects that almost exactly replicate existing objects and manually writing error prone serialisers\nOr, none of the above, but once every few years you need to update all your services in one go?\n\nI'd take the second option, but again it would entirely depend on the application.\nStoring a representation of an object in a cache (say Redis)\nCaches can be flushed.  In some ways this problem is the same as the messaging one.  If the cache needs to be shared between services then the representation must match, so all serialisers must work the same.  But on the whole this is an example where just serialising an Option would make sense.\nSimilar list of points:\n You could update everything\n You could abstract away the problem by forcing yourself to write error prone manually written serialisers\n* You could set up a second cache for the newly updates services - so old and new run side by side\nThe last item is new, but is an option to reduce the need to write endless boilerplate.\nDTO\nEven the idea of DTO objects makes me cringe slightly, DTO is another example of a coping strategy for the problems of OO, which are:\n\nThe attachment of functionality to classes - which often constrains the type to live in the application its in\nThe use of hidden state - which means only the type itself knows how to construct itself and how it got to its current state.  Making it fundamentally un-serialisable.\n\nPersonally I write types to be like simple record types:\n- Immutable\n- No externally dependent functionality \n- No hidden state - other than that which can be re-calculated easily (like a hash code for example)\nThat means I can often create a shared 'schema' project of common record-types and then just move them around between services without having to break them down into DTO objects.  The only time I'll build, what you'd call, a DTO is to limit the amount of data moving around, so I may write another record-type that contains a subset of the fields of the larger one.\nI will also build message-types for use with echo-process that use Option, because I don't want to be doing null checks at the other end.  \nConclusion\nSo, it's clear that in many circumstances it's valid (and cheaper in man-hours) to use the off-the-shelf serialisation.  There are trade-offs with both approaches.  But because one of the approaches requires language-ext's types to be serialisable: they are, and they will continue to be.  \n. > Your section on DTOs makes me think that we have of different understandings of what a DTO is\nWe don't.  I just see them as mostly unnecessary when using record-like types everywhere.  But the reason they exist in the first place is because of the problems with the OO way of doing things which makes most hidden stateful, mutable, external-dependency-carrying types unusable for data-transfer... either between application layers or between application domains.\nRegardless of terminology, there is still the trade-offs that devs make between building their own serialisation primitives and just not doing it.  If you want to build DTOs great, and I understand your reasons.  I personally believe that it's unnecessary overkill nearly all of the time.  \nThe moment one person doesn't want to build their own serialisation abstraction then this library should allow them to get their job done.  There is no right or wrong here, only trade-offs, that's why it just isn't as black and white about whether we should support serialisation or not.  If you want it, it's there; if you're concerned I might change what the output of a type's serialisation might look like then build your own.\nIn the large projects I work on daily we very rarely need to build bespoke serialisation code - possibly because we just don't use any of the Microsoft mandated tech like EF, WPF, etc.  None of that is even on our radar.  We do however need to move messages around our system using echo-process, which is how our services talk to each other and how the client browser can talk to/from the server.  I have an absolute motivation for the serialisation of the core language-ext types, like Option, to stay the same, because all of our services and subsystems use serialised messages to talk to each other.  But I also would find it a minor annoyance if it were to change, the migration strategy is relatively trivial.  Not zero work, but less work than the ongoing maintenance of shadow DTO types and bespoke serialisers.\nSo, essentially my message is: it must be supported, but you don't have to use it. . I guess the idea you express that Either is for a value or an error is the main thing that needs dispelling.  It isn't really true, it's a type that can represent two values, it just happens to have monadic bind behaviour that shortcuts the computation when in a Left state -- which is very useful for errors, yes, but it's not essential.  \nSo, when it comes to being declarative, Either is more about saying:\n\n\"I have either one a value of this type, or a value of that type\"\n\nIt isn't opinionated in its name - only its bind function.\nWhereas clearly by virtue of its name Validation is opinionated.  It has one role to perform: validation - and is built for those reasons.  \nAs you've noted the types are very similar, but when it comes to being declarative they're different.\nThe natural next argument from then would be: \"Why isn't there an Error<Err, A> type if you love being so declarative?\".  There probably should be, but it's arguably overkill here.  \nIn terms of performance, there's a very slight performance benefit to using Either, because its alternative value is just a value, whereas in Validation<F, S> it's a Seq<F> and that comes with more overheads than dealing with just a single value reference.  We're talking negligible differences here, but perhaps in a tight loop the differences would start to show.\nObviously with Validation<MonoidF, F, S> it depends which monoid you use to collect the failure results as to the potential performance hit, but on the whole it will have the same performance profile as Validation<F, S>\n. What version are you running? I know I fixed an issue in this area\nrecently.\nOn Wed, 8 Aug 2018 at 16:08, OlduwanSteve notifications@github.com wrote:\n\nIn the following code:\n        var a = toSet<OrdStringOrdinalIgnoreCase, string>(new[] { \"a\" });\n        var b = toSet<OrdStringOrdinalIgnoreCase, string>(new[] { \"A\" });\n        var c = a.Except(b);\n\nI would expect c to be empty but it's not. If both sets are the same case\nit works, suggesting perhaps that OrdA is not being used in this method.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/458, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk-NPaYwZXdT4cW_SR0tY6vyKOtq3ks5uOv7WgaJpZM4V0Hs7\n.\n. Fixed in 3.0.21 on nuget now. It doesn't have the same bug, that was caused by the call to IEnumerable.Contains rather than SetInternal.Contains.  But it can be optimised like I did for Except to not generate a new set.. > no \"ToLst()\" (equivalent of ToImmutableList()) extension method for IEnumerable, this means:\n\nenumerable.Freeze()\nNot the best named method ever, but I never foresaw implementing all the collection types I have ;)\n\nneed to explicitly repeat T for new: new Lst(enumerable) as ctor params can't be deduced\n\nUse the static prelude:\n```c#\n    using static LanguageExt.Prelude;\nvar list = List(enumerable);\n\n```\n\nfor some reason Lst is not implicitly cast to IEnumerable\n\nIt is:  https://github.com/louthy/language-ext/blob/master/LanguageExt.Core/DataTypes/List/Lst.cs#L19\nBut you have to realise that Lst<A> is a struct, not a class and because of that the A can't be covariant or contravariant.  That means if you want to cast a Lst<SubType> to IEnumerable<BaseType>, you can't.  It's a limitation, and if you use a lot of inheritance, you'll probably hit this issue a lot with lang-ext.\nI very rarely see this issue as I avoid inheritance and unnecessary abstraction.\n\nThere is no Lst.Replace(old, new), what should be used instead?\n\nc#\n    Lst<B> Replace<A, B>(this Lst<A> ma, A oldv, B newv) =>\n        ma.Map(a => EqualityComparer<A>.Default.Equals(a, oldv)\n            ? newv\n            : a);\n\nSide question: does ToString() use exact same fields that Equals and GetHashCode uses (so can be used for debugging which fields are used and which are not)?\n\nYes.\n\nlast but definitely not least: just addinf LanguageExt.Core to my project increased build time from 13 to 22 sec, any idea why? Can I reduce it back in any way?\n\nI've never profiled build times, but that seems slightly surprising.  I suspect it's because of the HKT generated functions.  Not much I can do for you there (bar removing the feature).. No, they're explicitly built for public record-types, rather than the OO hidden state approach.\nThis is the code for building the equality method for the record types.  You can see on line 573 how it gets the public fields.  You could roll your own that worked with private fields if you want to build something similar.. If you just need serialisation, then by deriving from Record<TestRecord>, ISerializable and implementing the default serialisation constructor:\nc#\nprotected TestRecord(SerializationInfo info, StreamingContext context) =>\n    base(info, context);\nShould give you serialisation support for 'free'.. Yep, the source check should be removed and should just throw an ArgumentNullException as the first line.. I have a fix for this ready, just not currently at the computer it's on, so don't worry about doing a PR. Thanks!. Cheers Tom. Trying to replicate sum types as you have is fine.  In my opinion it's the best way without any direct language support.  Writing code to do this (like your example with Match and lambdas) is a bad idea.  It's far too limited compared to the existing language support and also has a runtime overhead that's entirely unnecessary here.\nOne thing you could look to change is how you do the matching.  Instead of using switch which has no return value, use the ternary operator:\nSo, this:\n```c#\n      public static string renderValue(Value letter)\n      {\n        switch (letter)\n        {\n          case Letter l when l.Value == Letters.O: return \"O\";\n          case Letter l when l.Value == Letters.X: return \"X\";\n          case Unspecified _: return \" \";\n        }\n    throw new ArgumentOutOfRangeException();\n  }\n\nWould become:c#\n      public static string renderValue(Value letter) =>\n          letter is Letter l && l.Value == Letters.O ? \"O\"\n        : letter is Letter l && l.Value == Letters.X ? \"X\"\n        : letter is Unspecified _                    ? \" \" \n        : throw new ArgumentOutOfRangeException();\n``\nIt has the benefits of being more terse and so closer to F# and it's an expression, which is whatmatch` is in F#.. > Why do you think this approach is limited?\nBecause:\n it's just case matching, it doesn't add additional logic.  So you can't refine your match (like the renderValue which matches on Letter then matches on the letter value).\n So, without above you can't match twice on the same type\n You must provide all cases\n   - If you look at how you match in F# and the like, it's not always the case that you provide logic for all cases, you sometimes want to fall-through to otherwise.\n You can't provide a default. \n You spend most of your life writing boilerplate\n You will add bugs to your boilerplate as you lose to will to live writing it\n* There are 2n memory allocations per use, where n is the number of cases.\nObviously, I think this approach has some merit, because it's how matching works in Option, Either, etc. in lang-ext.  But they're very simple types.  I think when you start expanding the scope of the type then you lose a lot by taking this approach.\n. parseMove can be done more functionally like this:\nc# \nstatic Option<Position> parseMove(string str) =>\n    from s in Optional(str)\n    let t = s.Split(' ')\n    where t.Length == 2\n    from r in parseOneThroughThree(t[0])\n    from c in parseOneThroughThree(t[1])\n    select Position(c, r);. @slimshader You may want to look at the issues that have been labelled as examples / documentation\nAlso, there's some useful stuff in the wiki on Thinking Functionally\nIn terms of an IO monad, you'll probably find it's a bit of a waste of time for C#, but for certain situations where you want to define an algebra of possible IO operations and be able to abstract away from the underlying implementation you can use a Free Monad.  The IO monad in Haskell is essentially a more specialised Free Monad.  This was discussed here and there are two example projects in the Samples folder called AccountingDSL and BankingAppSample that introduce the concept.  \nNote: This isn't a feature of lang-ext yet, as a properly generalised Free Monad or even an IO monad is very difficult to achieve without higher-kinds.  I am working on it though.. Thanks! . Not totally against the idea, but it would add an extra dependency which might be undesirable.  Open to opinions. . Yup, less concerned about .NET Framework, more concerned with .NET Core\ndependencies. I\u2019ve not checked if it\u2019s available by-default or requires\nanother nuget include\nOn Fri, 7 Sep 2018 at 17:33, Sean Farrow notifications@github.com wrote:\n\nIt only adds system.net, which is part of the BCL.\nIf things like this are undesirable in the core, have you considered a\ncontrib project where things like this could live?\nFrom: Paul Louth notifications@github.com\nSent: 07 September 2018 17:17\nTo: louthy/language-ext language-ext@noreply.github.com\nCc: Sean Farrow sean.farrow@seanfarrow.co.uk; Author \nauthor@noreply.github.com\nSubject: Re: [louthy/language-ext] Add the capability to parse an IP\naddress to the Prelude.Parse module (#469)\nNot totally against the idea, but it would add an extra dependency which\nmight be undesirable. Open to opinions.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub<\nhttps://github.com/louthy/language-ext/issues/469#issuecomment-419490704>,\nor mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/ABY1fsU6N38YGPazR4gfe9DejGzoajANks5uYpwEgaJpZM4WYSn0>.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/469#issuecomment-419495336,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk9lY49P1ZWVFPbaXcSnuXR0KOWf_ks5uYp_PgaJpZM4WYSn0\n.\n. Great, thanks for checking.  Unless anybody else has any major concerns then I'm happy to accept a pull-request for this.. This is now deployed.. Scratch that, wrong issue!. Ha, ok, yes, this is released!. Thanks!\n. I don't believe in adding support for this, as it's possible to do this now (with @Richiban 's approach, and as already discussed here) .  The OneOf approach isn't one that interests me, because it comes with a lot of baggage (plenty of typing of generics).  \n\nThe code-gen approach is fine, but again not really in the bailiwick of this library. . > Do you think this is something that is possible? Supporting this idiom with a SumType base class or similar, that will generate the IL necessary for each child class, instead of the base (as Record does)\nThat's certainly possible.  A bit short of time to dig into it though.. It was meant to be tongue-in-cheek, I'll change it.. Often the source-code can help ;)\n```c#\nnamespace LanguageExt\n{\n    public delegate (A Value, bool IsFaulted) Reader(Env env);\n}\nnamespace LanguageExt\n{\n    public delegate (A Value, S State, bool IsFaulted) State(S state);\n}\n```\nAnd there are a number of examples in the unit tests. Thanks!. > Is this ambiguity something that we care about or should do something about?\nIt's tough.  They're not really false positives to be honest, because the  Option<A> supports the + operator, and so the bind that belongs to Task<A> will produce a valid result just like the bind that works with Task<Option<A>>.  The whole expression is valid for all bind extensions, which is obviously why we have that ambiguity.  \nIt's a shame that changing var three = ... to Option<int> three = ... doesn't change the inference system.  Because that's the key difference between the two possible expressions that the compiler is confused by.\nMy instinct would be to remove the Task<M<A>> bind, but that would probably be a breaking change for a number of people.  It would need some thought, which at 2am I'm probably not best to do!\nI'm sure there's another issue that brought up a similar problem with Task bind.  Struggling to find it though.. I guess the best advice here is to use OptionAsync, EitherAsync, etc.  those types obviously always behave well.  \n(Which is perhaps a good reason to drop the transformed Task<M<A>> bind operations).. @michael-wolfenden I haven't managed to find a way to generalise the Free monad, yet.  So, any solution would be a bit of a hack I'm sure.  Usually, if I use the free monad technique to create a bespoke monadic type that abstracts intent from effect (like the BankingFree example) then I am doing it because I want to put something in a box... that is, I want it to exist is a sub-system and have an algebra that describes the subsystem (the types).  \nI am yet to fully explore the idea of composition, because first of all I'd like to find an approach to generalise the Free monad itself (which I suspect would allow composition to fall out of it naturally).\nI'm afraid when I look at Scala my brain just starts shutting down because I can never get over the use of [ and ] for generic parameter delimiters.  And so, it's not entirely clear what your example demonstrates.\nI have attempted to create nested 'free' monads which allow for layered systems (like a Free UI, Free Business, and Free Data Access, ... with limited success).\nIt's something I will return to at some point, I suspect it would need something similar to the records IL generation to make everything work.  . @michael-wolfenden Yep, I thought that might be the case, but wasn't too sure.  Having them side-by-side like that in a single LINQ expression would be tough to achieve - because you'd need a way of combining the interpreters and that's messy.  \nWhat I was alluding to would be the ability to lift one free-monad into another and then have an adapter in the outer interpreter that would kick off the inner-interpreter.\nSomething like:\nc#\n    from uid in UI.ask(\"What's your user ID?\")\n    from pwd in UI.ask(\"Password, please.\")\n    from sid in UI.Auth(\n        from user in Authentication.Login(uid, pwd)\n        // ... continue working in the Auth layer ...\n        select user.SessionToken)\n    from // ... continue working in the UI layer\n    from rgt in UI.Auth(\n        from r in Authentication.HasRight(sid, Rights.ViewDemographic)\n        from e in Authentication.HasRight(sid, Rights.CanEmail)\n        select (HasDemo: r, CanEmail: e))\n    where rgt.HasDemo && rgt.CanEmail\n    select ...\nI didn't get massively far with this due to the limitation that any Free monad type must have a single generic argument only (which can't be used for arguments).  This limitation comes about because of the pattern-matching in the bind functions and the interpreter.  It meant that UI.Auth(...) would have to be a UI<Auth<object>> or something similarly non-typesafe.  \nSo, I kinda stopped until I could find a cunning way to get around the type-system.  However this did spark a bit of interest again, so I had yet another go at it (I must have had a dozen attempts so far!), and I have built a prototype that uses reflection to build the bind function automatically.  That's the first step to making this work, but to make it efficient and useful it would have to build the IL needed for matching, dispatching, and binding without reflection.  I suspect there are also a ton of edge cases - and so don't hold your breath waiting for this, but progress is being made.\n. Didn't mean to close this.  Anyway, I have added the suggested entry in the csproj and deployed the nuget packages (v3.0.23).  I haven't tried adding them to a test project yet, but I guess we'll get to find out if this helps soon :). Fixed, thanks @rantri . Looks good, thanks @StefanBertels . They're different functions, not sure why you think they're the same?\nc#\n    find(map, 1);\nIs equivalent to:\nc#\n   map.Find(1);\nThe equivalence is pretty much guaranteed\nI think there's a typo in your example, because I think what you've actually stumbled on is IEnumerable.Find(Func<A, bool> predicate). \nMap is both a tree and an IEnumerable<(K, V)>, and so you're iterating through every item in the map if you use the predicate variant of Find.\nThat's not to say that there is always parity between the static functions and the instance methods.  But, in this case there is.  \n. It seems there\u2019s a bug in the per hour calculations (a divide by 3600 instead of multiply).  Use the per second calculations until I get to it.. Fixed in v3.0.28. Because I don\u2019t have infinite time. Feel free to create a pull request.\n. Deployed in 3.1.6-beta.  Thanks for contributing @MrYossu . Thanks Tom, I\u2019ll review on Monday . @colethecoder  Looks good, thanks.  In London for a few days, so will roll out early next week.. That's not quite the same thing.  Altough, I can see the potential for confusion if you're forced to provide L.  However the vast majority of the time the programmer should never need to provide generic arguments here as they're easily inferred by the compiler.. > but can you expand a little bit on why it's not the same thing \nSure... mostly because it's just an extension method on Try<A> and not an Either constructor.  So, I didn't feel strongly that it must follow the Either generic parameter ordering.  \nI usually (although not religiously) put the primary subject generic parameter first in the list of generics and try to get the naming of the generics to flow from left-to-right (A..Z for exampe), because the subject of the method is usually the first argument to the method (or this).  Then the generics in the arguments will often flow left-to-right nicely too (again, not always, but mostly).\nSo, if I had an extension method for Option<A> of \n``c#\n    Map(this Option<A> ma, Func<A, B> f)\n```` \nI would use the order`.  \nIf you look at SelectMany for Try<A> it's:\nc#\n    SelectMany<A, B, C>(this Try<A> ma, Func<A, Try<B>>, Func<A, B, C> project)\nIt just usually works out/looks/feels better to have subsequent generic arguments after the subject generic argument.  \nI think you have a valid argument here in that, probably, the ordering is wrong in this case.  But, I can't imagine a situation where you'd ever have to explicitly type it, because the type-system can always infer it... A will always be known because it's the this of the extension method, and L can always be inferred from the return type of the provided Func.  And, so, I don't feel a great urge to change it.  Mostly because that could be a breaking change for someone for very little gain.\nAlthough, the argument against my breaking-change claim is that: if what I say above is true about the type-inference then probably nobody has even typed in the generic arguments for that method and therefore changing it wouldn't break anybody's code.\nUltimately this is one of those things that I think probably isn't worth worrying about, other than to pander to programmer OCD.  If you want to do a pull-request for it, I'd proabably accept it, but I'm not going to lose too much sleep over it in the meantime ;). > It's fixed by changing var iter = seq.GetEnumerator(); to using(var iter = seq.GetEnumerator()) in SeqEnumerable2.cs\n@faeriedust That won't fix it unfortunately as it will dispose the enumerator after consuming only the head item.  It needs to dispose after the last item has been consumed.  I have done a fix and it's deployed in version 3.0.27. This is your change (wrapping var iter = seq.GetEnumerator() in using(...)):\nc#\nusing (var iter = seq.GetEnumerator())\n{\n    if (iter.MoveNext())\n    {\n        cached = new SeqEnumerable<A>(iter.Current, iter);\n    }\n    else\n    {\n        cached = Empty;\n    }\n}\nThe code within the using { ... } will return after iterating the first value (the head).  And will pass iter (which is disposed immediately) to SeqEnumerable.  It can never work, SeqEnumerable will have a reference to a disposed enumerator.  Your tests weren't good enough to prove that the enumerator wasn't not-disposed until the lazy sequence was done with.\n\nI don't think it shouldn't matter if I read the last item or not.\n\nI think you're fundamentally misunderstanding the purpose of Seq.  It' a lazy sequence.  Just because you've only taken one item so far, doesn't mean you won't take more.  The internal iter enumerator needs to exist forever or until the end of the sequence is reached, it is how the the laziness is implemented. \nIf you need a sequence to dispose earlier then I'd suggest forcing the items into a Lst or a List.  I'm not sure you're ever going to get the behaviour you want.\n. That won't fix it, it will dispose after the first item.  I have a fix for it that I'll commit.. Indeed, that looks wrong.  I\u2019ll check . This is fixed in v3.0.29, along with a general performance improvement for .NET Framework users. If we ever get CompileToMethod in .NETStandard then that improvement can be brought over.. I agree with all of @IDisposable 's comments here.. > How about I use mton and ston? Not quite as short, but no conflict then.\nDon't use anything that isn't already a commonly used shorthand/acronym.  There's no requirement for a shorthand if a unit like km doesn't exist in the real world.  I'd actually be fine with ton for imperial and tonne for metric, but am open to other opinions.  I haven't fully studied the world variants.. @MrYossu You need to merge the changes in the lang-ext repo into your repo, fix the merge requests, commit, and do a new merge request to the lang-ext repo from yours.. Maybe some of the other regular contributors here could help you.  I rarely have this problem because I work directly in the repo, and so I'd probably end up giving you bad advice:\nCC: @IDisposable @bender2k14 @StefanBertels . Thanks for helping out @bender2k14\n@MrYossu I will try and review over the weekend . @MrYossu It seems Github had a major outage last night and there's a chance something got messed up on the way.  The MR is still claiming conflicts (even though I saw it reporting none last night).  Could you double check and then I'll push it through once done.  Thanks.. @MrYossu Looks like Github was still restoring, it committed on its own.. headOrInvalid and headOrLeft are the two functions below headOrNone that will need updating too.\n. @faeriedust I have done this and deployed in v3.0.30. Yes, good point.  It would need some rewording here and there.. It's a mutable field, so you can just set it directly:\nc#\n   TryConfig.ErrorLoger = (Exception ex) =>\n    {\n        // Your error handler here\n    };\nWhenever Try, TryAsync, TryOption, or TryOptionAsync catch an Exception they call this method.\nIn hindsight it probably would have been better as an observable or an event.. I'd do something like this:\n```c#\nusing LanguageExt;\nusing static LanguageExt.Prelude;\nusing System;\nnamespace ConsoleApp11\n{\n    public static class Telemetry\n    {\n        public static readonly Action Client = (Exception ex) =>\n        {\n            Console.WriteLine(ex.Message);\n        };\n    }\npublic static class TryExtensions\n{\n    public static Try<A> LogFailures<A>(this Try<A> ma) =>\n        ma.Match(\n            Succ: x => Try(x),\n            Fail: ex =>\n            {\n                Telemetry.Client(ex);\n                return Try<A>(ex);\n            });\n}\n\nclass Program\n{\n    static readonly Func<string> GetStringFromFirstExternalSource = () => throw new Exception();\n    static readonly Func<string> GetStringFromSecondExternalSource = () => null;\n    static readonly Func<string> GetStringFromSourceThatDoesntThrowExceptions = () => LanguageExt.Some.Create<string>(\"foo\");\n\n    static string GetStringOrDefault() =>\n       GetString().IfNone(GetStringFromSourceThatDoesntThrowExceptions());\n\n    static Option<string> GetString() =>\n        Get(Seq(GetStringFromFirstExternalSource, GetStringFromSecondExternalSource));\n\n    static Option<A> Get<A>(Seq<Func<A>> delegates) =>\n        delegates.FoldWhile(\n            Option<A>.None,\n            (state, fun) => Try(fun).LogFailures().ToOption(),\n            (state) => state.IsNone);\n}\n\n}\n```\nPersonally I wouldn't bother so much with the Some<A> type, mostly because now that I always use Option for optional values, when I see a reference type that isn't an Option then I know it should never be null.  This does require a certain amount of team discipline obviously.\nYou'll notice I created an extension method for Try<A> for logging, this is only required if you don't use the built in error-logger in TryConfig, and instead you want to make a decision on a case-by-case basis whether you want to log or not.\nI have split the GetString method up into a more general Get and then less general GetString, and GetStringOrDefault method.  This makes each function much simpler and easier to reason about.\nOne thing I'd warn against is the path you appear to be going down of creating lots of 'global' fields.  That's going to get you in to trouble quite quickly.  Consider either passing external IO functions through to the functions, or trying to move IO to the edges, or build your own monadic types to capture IO operations.  \nPure functions are your best friend, and that's where you'll get the most wins from taking a functional approach.. > Can you explain what you mean by \"global\" fields\nEssentially lots of public static fields or properties.  It will create a messy set of dependencies that will be hard to reason about and maintain.  For example if I have a function prototype like this:\nc#\n   int Divide(int x, int y);\nIt should do nothing other than divide two numbers.  If behind the scenes it fires off calls to various global services then it hides what's really going on, that approach over time makes code brittle and hard to deal with.\nNow imagine this:\nc#\n   int Divide(int x, int y, Func<Exception, Unit> telemetry);\nIt's obvious to all users of your code that it may do something more than add two numbers together.\nThe problem with that approach is that there are still possible side-effects happening during the function.  Which may have performance implications, race condition implications, or just extra argument to every function implications.\nSo, we could change Divide to not do any telemetry at all, and just return the result or the error:\nc#\n   Either<Exception, int> Divide(int x, int y);\nNow, that talks to me.  The function should have no external dependencies other than the arguments being passed, but the result could be either an Exception or an int.  Obviously the exception could come from divide-by-zero, and so now you can imagine what the function might look like:\nc#\n    Either<Exception, int> Divide(int x, int y) => \n        Try(() => x / y).ToEither();\nWe now have a declarative and pure function.\nSo, what happens with the Exception, when does it get logged?\nLet's imagine we had a small API that was declarative and pure like the Divide function:\n```c#\npublic class Error : NewType\n{\n    public Error(string value) : base(value) { }\n    public static Error FromEx(Exception e) => new Error(e.Message);\n}\nEither Div(int x, int y) =>\n    Try(() => x / y).ToEither(Error.FromEx);\nEither FromString(string value) =>\n    parseInt(value).ToEither(Error.New(\"String can't be parsed into an integer\"));\nEither Div(string left, string right) =>\n    from l in FromString(left)\n    from r in FromString(right)\n    from n in Div(l, r)\n    select n;\nEither Add(string left, string right) =>\n    from l in FromString(left)\n    from r in FromString(right)\n    select l + r;\nEither Sub(string left, string right) =>\n    from l in FromString(left)\n    from r in FromString(right)\n    select l - r;\nEither Mul(string left, string right) =>\n    from l in FromString(left)\n    from r in FromString(right)\n    select l * r;\nEither Foo() =>\n    from x in Div(\"48\", \"2\")\n    from y in Add(\"10\", \"12\")\n    from z in Sub(\"5\", \"3\")\n    select x + y + z;\n``\nNotice how theErrortype propagates, and functionFoowhich is using other possible error throwing functions is relatively more complex.  You can maintain this right up to the 'edges' of your application.  i.e. away from your pure code.  That means if something goes wrong, the expression backs out and then youMatch` on failure and call your telemetry providers there.  No need for injection.\nThat works well if you never recover from failure.  In your example you try to return a default value if the others fail (I'd argue this isn't always great practice, it can make much more sense to propagate the error, but it really does depend on the use-case).  But if you do need call IO functionality mid-way through an expression then there are a number of routes to achieve this.  \nReader monad\nThis is a built in type in lang-ext that allows you to pass an environment to your computations.  It isn't always the easiest thing to use, but it is effective in that you can gain access to telemetry without having to explicitly pass an extra argument:\nFirst, you create a type to pass in as the telemetry:\n```c#\npublic class World\n{\n    public readonly Func SendTelemetry;\npublic World(Func<string, Unit> sendTelemetry)\n{\n    SendTelemetry = sendTelemetry;\n}\n\n}\nThen we'll add a couple of extension methods that work with `Reader<World, A>`.  Writing bespoke extensions for your environment type tends to make it easier to work with.  These will convert between `Try<A>`, `Option<A>` to `Reader<World, A>`:c#\n        public static Reader ToReader(this Try ma) => env =>\n            ma.Match(\n                Succ: x => (x, false),\n                Fail: ex =>\n                {\n                    env.SendTelemetry(ex.ToString());\n                    return (default(A), true);\n                });\n    public static Reader<World, A> ToReader<A>(this Option<A> ma, string message) => env =>\n        ma.Match(\n            Some: x  => (x, false),\n            None: () =>\n            {\n                env.SendTelemetry(message);\n                return (default(A), true);\n            });\n\n``\nNotice theTry` variant will send the telemetry if there's an exception caught.\nIf the returning of (x, false) and (default(A), true) looks wierd.  Take a look at the declaration of Reader:\nc#\nnamespace LanguageExt\n{\n    public delegate (A Value, bool IsFaulted) Reader<Env, A>(Env env);\n}\nIt's just a delegate that takes an Env and returns (A, bool) the bool indicates whether it's faulted or not.\nBefore we use the Reader in anger, we can add a helper function to send random telemetry whenever we want:\nc#\npublic static Reader<World, Unit> SendTelemetry(string message) =>\n    from world in ask<World>()\n    let _ = world.SendTelemetry(message)\n    select _;\nNotice how the function only takes a string, but somehow returns a Reader<World, Unit>.  That's because of the ask<World>() call.  Which goes and gets the environment for you and puts it in world.  We can then invoke the injected Func to deliver the message.\nNow we can use for real:\n```c#\nstatic Reader Div(int x, int y) =>\n    Try(() => x / y).ToReader();\nstatic Reader FromString(string value) =>\n    parseInt(value).ToReader(\"String can't be parsed into an integer\");\nstatic Reader Div(string left, string right) =>\n    from l in FromString(left)\n    from r in FromString(right)\n    from n in Div(l, r)\n    from _ in SendTelemetry($\"Result of {left} / {right} = {n}\")\n    select n;\nstatic Reader Add(string left, string right) =>\n    from l in FromString(left)\n    from r in FromString(right)\n    from _ in SendTelemetry($\"Result of {left} + {right} = {l + r}\")\n    select l + r;\nstatic Reader Sub(string left, string right) =>\n    from l in FromString(left)\n    from r in FromString(right)\n    from _ in SendTelemetry($\"Result of {left} - {right} = {l - r}\")\n    select l - r;\nstatic Reader Mul(string left, string right) =>\n    from l in FromString(left)\n    from r in FromString(right)\n    from _ in SendTelemetry($\"Result of {left} - {right} = {l * r}\")\n    select l * r;\n``\nNotice the calls toSendTelemetry`.  \nWriter monad\nObviously that still calls the telemetry during the computation.  So, another approach is to use a Writer<Exception, A> monad to collect telemetry and then dump it all in one go when you're done.  Instead of using ask to get the environment, you call tell(exception) to log your output.  \nRoll your own\nAnother approach is to build your own monadic type.  That might be a bit out of your reach at the moment if you're just getting started, but once you know how to write a Bind function the rest is trivial.\nFor example if we create a lightweight Maybe monad (which works like the Option monad):\n```c#\n    public class Maybe\n    {\n        public static Maybe Just(A value) => new Just(value);\n        public readonly static Maybe Nothing = new Nothing();\n    }\npublic class Just<A> : Maybe<A>\n{\n    public readonly A Value;\n    public Just(A value)\n    {\n        Value = value;\n    }\n}\n\npublic class Nothing<A> : Maybe<A>\n{\n    public Nothing()\n    {\n    }\n}\n\nThe `Bind` function would look like this:c#\n    public static class MaybeExtensions\n    {\n        public static Maybe Bind(this Maybe ma, Func> f) =>\n            ma is Just just\n                ? f(just.Value)\n                : Maybe.Nothing;\n    }\n``\nIt encapsulates the rules of the monad (i.e. don't run anything else if we get aNothing`).  \nOnce the Bind is written, the extensions to make it work with LINQ is almost cut n paste:\n```c#\n        public static Maybe Select(this Maybe ma, Func f) =>\n            ma.Bind(x => Maybe.Just(f(x)));\n    public static Maybe<B> SelectMany<A, B>(this Maybe<A> ma, Func<A, Maybe<B>> f) =>\n        ma.Bind(f);\n\n    public static Maybe<C> SelectMany<A, B, C>(this Maybe<A> ma, Func<A, Maybe<B>> bind, Func<A, B, C> project) =>\n        ma.Bind(a => bind(a).Select(b => project(a, b)));\n\n``\nJust changeMaybe` to the name of your monad and it will work for anything.\nThe point of this is that you can relatively easily roll your own monadic types, which carry injected functionality and are less cumbersome than Reader or Writer; and easily allow you to change what you do with IO or any external dependencies.\nFree monad\nAnd the final, most pure method, is the Free monad approach.  This creates true separation between the pure and IO code.  I've written about this in depth before and there are two samples in the Samples folders that use this approach.  \nIt is very powerful, but requires a reasonable amount of typing, however it's a reeeeally powerful technique.\n. @michael-wolfenden Thanks for this, looks good, we should update the other validation type: Validation<MonoidFail, FAIL, SUCCESS> they're both part of the same story and should have API parity where appropriate.\n. Thanks @michael-wolfenden \ud83d\udc4d . Deployed in v3.0.30. I'm ok with both of those changes if you want to do a pull req?. Deployed in v3.0.30. Thanks @ChadBH \ud83d\udc4d . This is a good idea.  But, I think they're more like functor maps (because they return Either rather than a concrete value), maybe this instead:\n```c#\n    Either MapBottom(Func Bottom);\n    Either MapBottom(Func Bottom);\n    Either BindBottom(Func> Bottom);\nEither<L, R> MapBottom(L Bottom);\nEither<L, R> MapBottom(R Bottom);\nEither<L, R> BindBottom(Either<L, R> Bottom);\n\n``\nThat's then more consistent withMapLeftandBindLeft`.\nAlso, there's EitherUnsafe<L, R>, and EitherAsync<L, R> too.  It's good to keep consistency across the types :)\n. btw, if you're using Bottom because of where clauses in your Either expressions, then you can do something like this for more useful filtering and contextual alternative values:\nc#\n    var res = from x in eitherA\n              from r in x > 5\n                  ? Right<string, int>(x * 2)\n                  : Left<string, int>(\"Number is less than 5\")\n              select r;\n. Thanks @michael-wolfenden \ud83d\udc4d . > there are ramifications to strong naming\nWhat are they?  And how much pain does it involve for this project and the users of it?\n\nI'm happy to do the work, but the change would be a breaking change.\n\nWhat's involved?  Is there an ongoing cost?  . > Anyone able to help me out here? Sorry if this is a dumb question, but as I said, I'm fairly new to FP, so am still a bit vague about how it works.\nOne thing I'd suggest is trying to stick to a few golden rules:\n\nAll functions should return a value (even if it's unit)\nTry to reduce side-effects as much as possible and write pure functions\nThis means:\nOnly depending on the arguments passed to a function\nThe only output of a function should be it's return type\n\n\nWrite declaratively\n\nComposition is the name of the game.  By writing composable functions that have no side-effects you make it easier to create higher level abstractions.  The example you gave above may be using types from this function library, but you're doing it in a very imperative way.  \nSo, this:\nc#\nTry(() => GetAnswer(PrimaryTravelTypeQuestionID))\n    .Match(\n        s => ticket.FseTravelType = s,\n        e => Log.Error(e));\nHas:\n External dependencies (Log.Error(e))\n Causes side-effects\n   *  Log.Error(e) affects the world\n   * GetAnswer(PrimaryTravelTypeQuestionID) presumably is talking to a database or something like that?  Either way, it can't get an answer from an ID without relying on some global state.\nNow, it's obviously not always possible to not cause side-effects, especailly using C# as a language.  But we can improve the situation by:\n\nMoving IO to the edges.  This means do your IO first and last, and have pure code in-between.  This at least silos the dangerous stuff, and makes it easier for us to build higher abstractions.\nUsing monadic types to abstract away from the messy details\n\nGetAnswer is a good example of something we can improve with a bit of cunning:\nImagine this:\n```c#\n    static string log = \"\";\n    static Map answers;\nstring GetAnswer(int id)\n{\n    var answer = answers[id];\n    log = log + $\"Got answer {id}\";\n    return answer;\n}\n\n```\n When we write it like this, it becomes really clear what the external dependencies are.  So, how do we improve the situation?  Well, we want the function to only depend on it's arguments, not some global state:\nc#\n    (string answer, string log)  GetAnswer(int id, Map<int, string> answers, string log)\n    {\n        var answer = answers[id];\n        log = log + $\"Got answer {id}\";\n        return (answer, log);\n    }\nSo, now we're passing in all the possible answers, and returning the chosen answer and the updated log.\nBut, we still have some problems (apart from lots of argument typing).  And it's this:\nc#\n    log = log + $\"Got answer {id}\";\nWhy should this function know anything about how to log?  the + operation is the mechanics of logging, we shouldn't know about it.  And, wow many functions are we going to have to write this in?  What happens when we change our minds?  Could this function die if a log file gets full?  Are there any performance impacts to this?\nAll of these things makes the manually written log code bad.  \nSo, let's change it slightly:\nc#\n    (string answer, string log)  GetAnswer(int id, Map<int, string> answers)\n    {\n        var answer = answers[id];\n        return (answer,  $\"Got answer {id}\");\n    }\nOK!  That's more like it, we don't have a dependency on an external log, we're not manually concatenating to a log, and we have very precise performance characteristics.\nBut let's have add some other functions:\n```c#\n    (string text, string log)  GetQuestion(int id, Map questions)\n    {\n        return (questions[id],  $\"Got question {id}\");\n    }\n(string text, string log)  AskPerson(int id, Map<int, string> person, string question)\n{\n    return ($\"Hello {person[id]}, {question}\",  $\"Asked person {id}\");\n}\n\n```\nThe problem is now we have lots of separate log values a poor composition story:\nc#\n    var (question, log1) = GetQuestion(1, questions);\n    var (answer, log2) = GetAnswer(1, answers);\nA composed solution would look like this:\nc#\n    var (text, logN) = AskPerson(42, people, GetQuestion(1, questions));\nBut clearly we're not there, as the return type from GetQuestion gets in the way and we still have no way to join the log together that doesn't involve the code doing it manually.\nEnter function composition:\n```c#\nstatic Func Compose(Func f, Func g) => \n    a =>\n    {\n        var (valueA, logA) = f(a);\n        var (valueB, logB) = g(valueA);\n    return (valueB, logA + logB);\n};\n\n``\nThis may look a bit crazy at first, but it takes two arguments, both functions.  One fromA -> (B, string)the other toB -> (C, string)`.\nNotice how it concatenates the logA and logB for us?\nIf we slightly rewrite our original functions, we can inject the global state also:\n```c#\nstatic Func GetQuestion(Map questions) => \n    id => \n        (questions[id], $\"Got question {id}\");\nstatic Func> AskPerson(Map people) => \n    id => \n        text => ($\"Hello {people[id]}, {text}\", $\"Asked person {id}\");\nNow if I call:c#\n    var getQuestion = GetQuestion(questionsDb);\n    var askPerson = AskPerson(peopleDb);\n``\nThegetQuestionis function that takes anintand returns a(string, string).  It's captured thequestionsDb.  AndaskPersonis a function that takes anintand returns astring -> (string, string)`.  \nThat means we can all askPerson with a person ID to get a string -> (string, string).  If we Compose those functions we get:\nc#\nvar questioner = Compose(getQuestion, askPerson(1));\nThis gives us a Func that calls GetQuestion and AskPerson and also logs everything without us having to know how the log works.\nThis is a full example of it:\n```c#\nMap questionsDb = Map(\n    (1, \"What's the meaning of life?\"), \n    (2, \"Is there anybody out there?\"));\nMap peopleDb = Map(\n    (1, \"Mr Yossu\"),\n    (2, \"Louthy\"));\nvar getQuestion = GetQuestion(questionsDb);\nvar askPerson = AskPerson(peopleDb);\nvar questioner = Compose(getQuestion, askPerson(1));\n// (\"Hello Mr Yossu, What's the meaning of life?\", \"Got question 1\\nAsked person 1\")\nvar result1 = questioner(1);\n// (\"Hello Mr Yossu, Is there anybody out there?\", \"Got question 2\\nAsked person 1\")\nvar result2 = questioner(2);\n```\nAnother aspect to this is that the string concatenation is actually monodial.  \nWhat does monoidal mean?  A monoid has two properties:\n\nIt has a unit value.  Often called Empty\nIt must have an associative binary operator.  It is usually called Append.\n\nNow, language-ext supports monoids (although C# fights us).  And it already has one for string called TString, other monoids are MSeq, MLst, MSet, and so we can do some more cunning stuff.  Let's update our Compose function:\n```c#\nstatic Func Compose(Func f, Func g)\n    where MonoidW : struct, Monoid =>\n        a =>\n        {\n            var (valueA, logA) = f(a);\n            var (valueB, logB) = g(valueA);\n        return (valueB, default(MonoidW).Append(logA, logB));\n    };\n}\n\n``\nNotice how the resultingLogis now of typeW, and there's another generic argument calledMonoidW, which is constrained to bestruct, Monoid`.  \nThe String.Join has also gone, and is now replaced with:\nc#\n    default(MonoidW).Append(logA, logB);\nSo, now we can inject any logging mechanism we like into the composed behaviour:\nc#\nvar questioner = Compose<MSeq<string>, Seq<string>, int, string, string>(\n    getQuestion, \n    askPerson(1)\n    );\nThis will log using Seq<string>.\nNow, all this may seem like a lot of work to create some logging abstractions.  But what we've actually created here is a monad.\nThe Writer monad to be exact.  Which already exists in language-ext.  And what you use the Writer monad you get all this stuff for free.\nThe general idea of performing 'hidden' operations (like the log append) between functions is what monads are all about.  So, if you're looking to learn how to do the functional thing well, then it's worth understanding everything above.\nSo, with the Writer monad you get this:\n```c#\nstatic Writer, Seq, string> GetQuestion(int id, Map questions) =>\n    from q in Return(questions[id])\n    from _ in Log($\"Got question {id}\")\n    select q;\nstatic Writer, Seq, string> AskPerson(int id, Map people, string text) =>\n    from p in Return(people[id])\n    from _ in Log($\"Gog question {id}\")\n    select $\"Hello {p}, {text}\";\nI used a couple of helper functions:c#\nstatic Writer, Seq, A> ReturnW(A value) =>\n    Writer, Seq, A>(value);\nstatic Writer, Seq, Unit> LogW(string message) =>\n    tell, Seq>(Seq1(message));\n``Writeris the constructor andtell` is the function that logs to the monoid.\nAnd now the composed version looks like this:\nc#\nvar question = from q in GetQuestion(1, questionsDb)\n               from t in AskPerson(2, peopleDb, q)\n               select t;\nPersonally I love the way that LINQ (which is the C# support for monads) can make everything so declarative.  \nBut now we have a new problem.  And that is that questionsDb and peopleDb are directly involved again.  And that is because there is no state being inputted to the composed functions.\nIf you remember our original functions how they returned a value and a log (some state), but they dropped the incoming state other that the arguments.  Well the State monad deals with that for us...\nFirst, let's create a type that encapsulates the world as it is before we call any of our code.  Imagine taking a snapshot of the state of your program.  In reality you only need to capture the things that your code will need, but it's a useful idea to keep in mind:\n```c#\nclass World\n{\n    public readonly Map Questions;\n    public readonly Map People;\n    public readonly Seq Output;\npublic World(Map<int, string> questions, Map<int, string> people, Seq<string> output)\n{\n    Questions = questions;\n    People = people;\n    Output = output;\n}\n\npublic string GetQuestion(int id) =>\n    Questions[id];\n\npublic string GetPerson(int id) =>\n    People[id];\n\npublic World Log(string text) =>\n    new World(Questions, People, Output.Add(text));\n\n}\n``\nSo, this represents all the _stuff_ that is usauall being called directly by things likeLog.Errororticket.FseTravelType = GetAnswer(PrimaryTravelTypeQuestionID)`\nWe can now create some reusable functions that work with our World type:\n```c#\nstatic State Log(string log) =>\n    from s in get()\n    from _ in put(s.Log(log))\n    select unit;\nstatic State GetQuestion(int id) =>\n    from s in get()\n    from _ in Log($\"Got question {id}\")\n    select s.GetQuestion(id);\nstatic State AskPerson(int id, string text) =>\n    from s in get()\n    let p = s.GetPerson(id)\n    from _ in Log($\"Got question {id}\")\n    select $\"Hello {p}, {text}\";\n```\nSo, now when I use those functions:\nc#\nvar question = from q in GetQuestion(2)\n               from t in AskPerson(1, q)\n               select t;\nYou'll notice I am not providing questionsDb or peopleDb.  It is done like so:\n```c#\nvar world = new World(questionsDb, peopleDb, Seq());\nvar (text, world2, _) = question(world);\n```\nObviously the more you build out of these monads, the less you have to run these invocations to get the results.  You compose bigger and bigger chunks into higher levels of abstraction.  With all operations being pure.\nComposition is the essence of functional programming in my humble opinion.  To successfully compose smaller functions into bigger ones, we must be able to trust what's inside those smaller functions.  Otherwise you have non-deterministic and frankly unknowable code.  We can get away with this when our applications are small, but not when they grow to multi-million line behemoths.  \nAll of the examples in this comment are here. > Functional Programming in C# by Enrico Buonanno\nI\u2019m one of the technical proofers for that book, so I\u2019d recommend it highly :)  Enrico did a great job. . @MrYossu Update to the latest beta release (you'll need to tick the _ show pre-release_s check in nuget (your Mass changes are in there too).\n. default(EitherAsync) should be the bottom state, so I don't think relying on calling a different constructor is the best plan here.  Probably a different approach is required.. Putting ToArray after the Cons stops the issue.. @StefanBertels Thanks!. Thanks @StefanBertels . Good stuff, cheers Tom . Thanks @bender2k14  \ud83d\udc4d . @andyigreg I have talked about this before with Free Monads and you can see the working in the AccountingDSL sample and the BankingApp sample.\nThat is the ultimate in total separation as you're creating a DSL to describe the behaviour and then building an interpreter to do the messy stuff.\nIt isn't particularly easy to build that stuff in C# though.  The alternative is to build a domain specific monad.  If you spend any time using Haskell then you'll see the use of bespoke monads for a lot of stuff.  Monads are built to provide structure and to hide all the messy real world stuff.\nFor example, I'm working on a new language for an internal project which has a tokeniser, parser, type-inference, and code-gen.  Each stage has its own monad (well, it will do when I'm finished).\n\nParser monad (using the one built into LanguageExt.Parsec)\nCompiler monad (which carries state and is the 'master' monad for all the others)\nInfer monad which does the type-inference, but also keeps tabs on constraints and named generic arguments\nCodeGen monad which deals with generating the compiled result\n\nEach one does a specific job and hides the complexity.  But also manages stuff like IO and carrying of state through the process.  The result is that I have functions like this:\n```c#\nstatic Compiler compileProject(Seq paths) =>\n    from 1 in parseFiles(paths)\n    from _2 in parseIncludedFiles\n    from _3 in rename\n    from _4 in envInit\n    from _5 in typeCheck\n    from _6 in codeGen\n    select unit;\n```\nObviously each step is doing a significant amount of work, but what's happening here is that the source files are being loaded from disk, tokenised and parsed, and then any included files are parsed, a renamer runs, then the core types environment is initialised before running the type-checker, and then the code-generator runs.  The monad is managing IO, state, error handling, etc.  And the end result is pure, declarative, and abstracted so you can _see the important stuff.  It's pretty damn readable for something so complex.\nWhen you think of monads you should think of them as having two distinct concepts:\n\nThe bound value - this is the actual value held inside the monad.  So the int in Option<int>\nThe container - this is the monad itself, the rules that make Option different from Parser, or Lst different from CodeGen.\n\nIf we take a look at a regular function:\nc#\n    a -> b\nThe arrow represents a function (or morphism) from type a to b.  Then we can compose it with a function b -> c:\nc#\n    a -> b -> c\nWhich gives us a function:\nc#\n    a -> c\nThis can be thought of as:\n```c#\n    B f(A a);\n    C g(B b);\nC h(A a) => g(f(a));\n\n```\nNow that's all great and everything.  But we might want to do some logging, or pass through some external state (which means adding lots of additional state arguments to our functions), or do some IO.  None of which plays well particularly nicely with our lovely simple function composition.\nThis is where monads come in.  They can be seen as an embellishment to the composed operation on the bound values.  The rules of the monad and the implementation of the Bind function for monads is what allow monads to compose.  \nBut, and importantly: because the monad container part of it should be seen as separate from the bound value operations, the container bit can do work which is considered impure, without the bound value operation losing its purity.\nNow that might sound a bit too convenient a get-out of jail free card, and in some ways it is.  But really, it doesn't matter.  What you want to do is bury your IO in the monad and then get over it.  A Haskell programmer doesn't think of the getChar function as pure, they don't think they will only ever get the same Char back every time they call it.  They absolutely think of it as a getting a value from the world each time.  \nWe can do that, but we have to take into account the consequences of that:\n If getChar could return a different value each time, then how can we test it?\n How are we going to handle IO errors?\n* Will we get race conditions?\nThere are 3 lang-ext built in monads that you can use for inspiration here.  \n\nReader which takes an environment (think of it as a snapshot of the world)\nWriter which as well as the bound value builds a log of values\nState which manages a state value along with the bound value\n\nThey are all pure (in every sense), but you can expand on them to add some IO.\nSo, let's start with the Reader.  As that's a good way to get information into the operation:\nc#\n    public delegate A Reader<Env, A>(Env env);\nSo, that defines the reader as a delegate.  It takes an Env and returns an A.  To make it a monad we need to define Return and Bind.\n```c#\npublic static class Reader\n{\n    public static Reader Return(A value) => \n        _ => value;\npublic static Reader<Env, B> Bind<Env, A, B>(this Reader<Env, A> ma, Func<A, Reader<Env, B>> f) =>\n    env =>\n        f(ma(env))(env);\n\n}\nOnce you have defined the `Bind` and `Return` functions you can very easily make it work with LINQ:c#\npublic static class Reader\n{\n    public static Reader Select(this Reader ma, Func f) =>\n        ma.Bind(a => Return(f(a)));\npublic static Reader<Env, C> SelectMany<Env, A, B, C>(\n    this Reader<Env, A> ma,\n    Func<A, Reader<Env, B>> bind,\n    Func<A, B, C> project) =>\n        ma.Bind(a => bind(a).Select(b => project(a, b)));\n\n}\n``\nId you look carefullySelectandSelectManyare derived fromReturnandBindand so you can almost copy n paste that wherever you need it, just change the names fromReader` to your bespoke monad type.\nSo, all the magic is in Bind, you can see it runs the Reader by passing an Env through the delegate.  At no point does the Env value change, it's just a static piece of environment that's passed through.\nLet's take a look at a concrete example.\n```c#\n    public static class Test\n    {\n        public static Unit AddLineNumbers(string fileName)\n        {\n            var lines = File.ReadAllLines(fileName);\n            var nlines = AddLineNumbers(lines);\n            File.WriteAllLines(fileName, nlines);\n            return unit;\n        }\n    static string[] AddLineNumbers(string[] lines) =>\n        lines.Zip(Naturals)\n             .Select(pair => $\"{pair.Item2}: {pair.Item1}\")\n             .ToArray();\n\n    static IEnumerable<int> Naturals =>\n        Enumerable.Range(1, Int32.MaxValue);\n}\n\n```\n\nI realise this is just an example of IO at the edges, but it doesn't really matter for this example.\n\nWe want to try and make that pure, so that the IO is abstracted.  \nSo, let's create an environment for the Reader:\n```c#\npublic class World\n{\n    public readonly Func ReadAllLines;\n    public readonly Func WriteAllLines;\npublic World(Func<string, string[]> readAllLines, Func<string, string[], Unit> writeAllLines)\n{\n    ReadAllLines = readAllLines;\n    WriteAllLines = writeAllLines;\n}\n\n}\n```\nNotice how it captures the two IO functions in the original.  \nThe monad needs to be able to get at its environment, so let's add that:\nc#\npublic static class Reader\n{\n    public static Reader<Env, Env> Ask<Env>() => \n        env => env;\n}\nThis is so simple, it takes the environment that was in the structure of the monad and makes it into the bound value.  \nSo, now we can add a couple of bespoke functions for ReadAllLines and WriteAllLines:\n```c#\npublic static class Reader\n{\n    public static Reader ReadAllLines(string fileName) =>\n        from env in Ask()\n        select env.ReadAllLines(fileName);\npublic static Reader<World, Unit> WriteAllLines(string fileName, string[] lines) =>\n    from env in Ask<World>()\n    select env.WriteAllLines(fileName, lines);\n\n}\nSo, now rewrite the `Test` class:c#\npublic static class Test\n{\n    public static Reader AddLineNumbers(string fileName) =>\n        from lines in Reader.ReadAllLines(fileName)\n        from _     in Reader.WriteAllLines(fileName, AddLineNumbers(lines))\n        select _;\nstatic string[] AddLineNumbers(string[] lines) =>\n    lines.Zip(Naturals)\n            .Select(pair => $\"{pair.Item2}: {pair.Item1}\")\n            .ToArray();\n\nstatic IEnumerable<int> Naturals =>\n    Enumerable.Range(1, Int32.MaxValue);\n\n}\n```\nAnd now that will call the injected functions without you having to pass them through explicitly.  The reader is called like so:\n```c#\nvar world = new World(\n    File.ReadAllLines,\n    fun(File.WriteAllLines));\nvar result = Test.AddLineNumbers(\"c:\\temp\\test1.txt\")(world);\n```\n\nThe use of fun is to deal with the fact that File.WriteAllLines returns a void.  This makes it return a Unit.\n\nState\nBut what about if we want to abstract away from files?  And we want to specify a context of some sort to read from?  That requires us being able to set some state as well as just read some.  So, we'll need to update the monad delegate:\nc#\npublic delegate (S, A) State<S, A>(S state);\nIt looks similar, but instead of returning an A it returns an (S, A).  \nLet's also update our World to hold a string container value:\n```c#\npublic class World\n{\n    public readonly Func ReadAllLines;\n    public readonly Func WriteAllLines;\n    public readonly string Container;\npublic World(Func<string, string[]> readAllLines, Func<string, string[], Unit> writeAllLines, string container)\n{\n    ReadAllLines = readAllLines;\n    WriteAllLines = writeAllLines;\n    Container = container;\n}\n\npublic World SetContainer(string container) =>\n    With(Container: container);\n\npublic World With(\n    Func<string, string[]> ReadAllLines = null,\n    Func<string, string[], Unit> WriteAllLines = null,\n    string Container = null) =>\n    new World(\n        ReadAllLines ?? this.ReadAllLines,\n        WriteAllLines ?? this.WriteAllLines,\n        Container ?? this.Container);\n\n}\nAnd create a new monad to work with the new `State` delegate:c#\npublic static class State\n{\n    public static State Return(A value) =>\n        state => (state, value);\npublic static State<S, B> Bind<S, A, B>(this State<S, A> ma, Func<A, State<S, B>> f) =>\n    state =>\n    {\n        var (sa, a) = ma(state);\n        return f(a)(sa);\n    };\n\n}\n``\nNotice how theReturnnow returns a pair ofstateandvalue; andBindnow extracts the state and bound value from callingmaand passed the updatedsastate value onto the result of calling the bind functionf`.  This propagates the state value throughout the computation.\nThen we copy n paste in our boilerplate LINQ stuff:\n```c#\npublic static State Select(this State ma, Func f) =>\n    ma.Bind(a => Return(f(a)));\npublic static State SelectMany(\n    this State ma,\n    Func> bind,\n    Func project) =>\n        ma.Bind(a => bind(a).Select(b => project(a, b)));\nInstead of `Ask` we will have `Get` as well as a new function called `Put` that will put any state value back into the monad _structure_:c#\npublic static class State\n{\n    public static State Get() =>\n        state => (state, state);\npublic static State<S, Unit> Put<S>(S state) =>\n    _ => (state, unit);\n\n}\nNow we'll add some functions to make it easier to get and set the `World` and the container:c#\npublic static State World =>\n    Get();\npublic static State Container =>\n    from w in World\n    select w.Container;\npublic static State SetContainer(string container) =>\n    from w in World\n    from _ in Put(w.SetContainer(container))\n    select _;\nThen let's update `ReadAllLines` and `WriteAllLines` to be _file unaware_.c#\npublic static State ReadAllLines =>\n    from w in World\n    from c in Container\n    select w.ReadAllLines(c);\npublic static State WriteAllLines(string[] lines) =>\n    from w in World\n    from c in Container\n    select w.WriteAllLines(c, lines);\nNow the `AddLineNumbers` function can look like this:c#\npublic static State AddLineNumbers =>\n    from lines in State.ReadAllLines\n    from _     in State.WriteAllLines(DoAddLineNumbers(lines))\n    select _;\n```\nAnd so all the messiness of files and the outside world is now encapsulated within the monad itself.\nYou can call this computation with this:\n```c#\nvar world = new World(\n    File.ReadAllLines,\n    fun(File.WriteAllLines),\n    \"\");\nvar comp = from _1 in State.SetContainer(\"c:\\temp\\test1.txt\")\n            from _2 in Test2.AddLineNumbers\n            select unit;\nvar result = comp(world);\n```\nBut equally you can call it with mocked IO and container details.  And so that allows you to build something that does apparently interleaved IO without having to go crazy by building a Free Monad.  \nError handling\nBut, we can take it further.  What about error reporting?  It will be difficult to make this work with Option, etc.  (well, not difficult, just slightly awkward).  And we also might have IO exceptions.  So, let's deal with that.\nFirst, let's create an Error type:\nc#\npublic class Error : NewType<Error, string>\n{\n    public Error(string value) : base(value)\n    {\n    }\n}\nNext, let's update the delegate.\nc#\npublic delegate Either<Error, (S, A)> State<S, A>(S state);\nAnd so now it returns either an Error or a (S, A) pair.  We could have used Try here, but I just wanted to show some bespoke error behaviour to really highlight the idea that you are building a bespoke monad for your own domain.\nSo, we'll need to update Bind to understand this new return type:\nc#\npublic static State<S, B> Bind<S, A, B>(this State<S, A> ma, Func<A, State<S, B>> f) =>\n    state =>\n    {\n        try\n        {\n            return ma(state).Bind(pairA => f(pairA.Item2)(pairA.Item1));\n        }\n        catch(Exception e)\n        {\n            return Error.New(e.Message);\n        }\n    };\nNotice how it catches the exceptions, this will be built into every call of the computation, bar one, the initial invocation.  So, let's have a Run function to capture that:\nc#\npublic static Either<Error, (S, A)> Run<S, A>(this State<S, A> ma, S state)\n{\n    try\n    {\n        return ma(state);\n    }\n    catch (Exception e)\n    {\n        return Left(Error.New(e.Message));\n    }\n}\nYou could make this a Match function so you don't can call ma.Match(state, ...)instead ofma.Run(state).Match(...)`\nShort-cutting\nIf we also add an Quit function, we can use that to short-cut our whole computation:\nc#\npublic static State<World, A> Quit<A>(string message) => _ =>\n    Left(Error.New(message));\nThen we can update our Read and Write functions:\n```c#\npublic static State ReadAllLines =>\n    from w in World\n    from c in Container\n    from r in c == \"\"\n        ? State.Quit(\"Container not set\")\n        : State.ReturnW(w.ReadAllLines(c))\n    select r;\npublic static State WriteAllLines(string[] lines) =>\n    from w in World\n    from c in Container\n    from r in c == \"\"\n        ? State.Quit(\"Container not set\")\n        : State.ReturnW(w.WriteAllLines(c, lines))\n    select r;\n```\n\nI also added ReturnW which is the same as Return with the W set to World.\n\nLogging\nBut why stop there?  We could do some logging too.  Let's add a log to the World:\n```c#\npublic class World\n{\n    public readonly Func ReadAllLines;\n    public readonly Func WriteAllLines;\n    public readonly string Container;\n    public readonly Seq Output;\npublic World(Func<string, string[]> readAllLines, Func<string, string[], Unit> writeAllLines, string container, Seq<string> output)\n{\n    ReadAllLines = readAllLines;\n    WriteAllLines = writeAllLines;\n    Container = container;\n    Output = output;\n}\n\npublic World Log(string message) =>\n    With(Output: Output.Add(message));\n\npublic World SetContainer(string container) =>\n    With(Container: container);\n\npublic World With(\n    Func<string, string[]> ReadAllLines = null,\n    Func<string, string[], Unit> WriteAllLines = null,\n    string Container = null,\n    Seq<string> Output = null) =>\n    new World(\n        ReadAllLines ?? this.ReadAllLines,\n        WriteAllLines ?? this.WriteAllLines,\n        Container ?? this.Container,\n        Output ?? this.Output);\n\n}\nAdd a `Log` function to `State`:c#\npublic static State Log(string message) =>\n    from w in World\n    from _ in Put(w.Log(message))\n    select _;\nAnd then update the `ReadAllLines` and `WriteAllLines` functions:c#\npublic static State ReadAllLines =>\n    from w in World\n    from c in Container\n    from r in c == \"\"\n        ? State.Quit(\"Container not set\")\n        : State.ReturnW(w.ReadAllLines(c))\n    from _ in Log($\"Read {r.Length} lines from container: {c}\")\n    select r;\npublic static State WriteAllLines(string[] lines) =>\n    from w in World\n    from c in Container\n    from r in c == \"\"\n        ? State.Quit(\"Container not set\")\n        : State.ReturnW(w.WriteAllLines(c, lines))\n    from _ in Log($\"Wrote {lines.Length} lines to container: {c}\")\n    select r;\n```\nConclusion\nAnd so that's it really, that's how to carry state, abstract away from IO, implement telemetry, but also write pure functions.  If the fact that IO is still really happening mid-flight bothers you, then the best option is to preload, because even the Free Monad approach requires mid-flight IO.. I think the main points are:\n\nFunctions and higher order functions are our building blocks\nThey should be pure\nFunctions should take data-types: product and sum-types as immutable values - i.e. records, tuples, and unions - as arguments, and they should also return immutable data-types.  \nJust to make this point clear.  Functionality shouldn't be connected to data.\nAlthough this seems unnecessarily strict, so I think if you're going to use methods on data-types, they should only depend on data from within the type (that essentially makes them like a pure function that takes an argument of a data-type).  \nPure functions compose better than all other mechansims of composition - this is where functional programmers win. \nFunctors, monads, foldables, and monoids are the core tools in our composition toolbox.  They capture complexity, allow us to build abstractions, and smooth over our primary job of function composition.  You can imagine that the code buried inside the Bind function of a monad or the Map function of a functor to be analogous to code buried in a base-class of an inheritance heirarchy.  They're all there to reduce the amount of repeated effort and to capture common functionality,  but where objects don't compose: functions, functors, and monads do.\n\nIt's restrictive compared to all the sillyness you can do with C#.  But it protects us from stupid mistakes and in the long run makes it easier for us to trust the code we've written, making it easier to write more complex applications.. @andyigreg It's in the beta release.  You'll need to check the box for pre-releases on nu-get.. This is now fully released. The bug is caused by this.  I don't have any time at the moment to look at the extent of the fallout if I change it to Some(x), so I'll just leave this here as a reminder for when I do.. Thanks!. Note that raise and failwith were really there to help with embedding exceptions into expressions; which isn't needed any more with the advent of expression based exceptions in C#, and so I tend to just throw them now - mostly because the stack-trace is slightly better.  Obviously YMMV, but I thought I'd just put in my thoughts.. @ceddlyburge Use the Do function in the latest release.  It's the same as Iter on all of the monadic and collection types, except it returns the original structure, allowing for fluent side-effects.\nUse at your own peril ;). Awesome.  Great work @colethecoder - I know this was a beast to track down, so very much appreciated \ud83d\udc4d . Seems reasonable\nOn Fri, 16 Nov 2018 at 20:42, Elijah E Kohrt notifications@github.com\nwrote:\n\nIn a earlier fix for #488\nhttps://github.com/louthy/language-ext/issues/488 , we changed the\nimplementation of Query.headOrNone from list.ToSeq().HeadOrNone() to\nlist.AsEnumerable().HeadOrNone().\nHowever this still isn't ideal behavior as the constructed query now is\nasking for all of the items instead of just the required single item.\nTherefore, I propose we change it to\nlist.Take(1).AsEnumerable().HeadOrNone() (and fix similar cases)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/523, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk__bh2tcbjDamr9SY8rk7zI5iRYcks5uvyMegaJpZM4Ym7vR\n.\n. Looks good, thanks!. Thanks!. Thanks!. @StefanBertels I am mega busy at the moment, I don't suppose you've narrowed down the change/diff that caused the problem?. This has the original lambda.Compile() restored (thanks @StefanBertels ) - and is now deploy in https://github.com/louthy/language-ext/releases/tag/v3.1.15. Thanks!. Fixed in 3.1.14. I usually do:\n\nvar x = p1 ? t1\n      : p2 ? t2\n      : el;\n\nWriting this on my phone, so hopefully it comes out ok!. The Pure attribute was requested by someone using Resharper, I think it gives useful warnings if you don't consume the result of a pure method.  In terms of whether the parse functions are pure or not.  Yeah, I see your point, but for all intents and purposes they're pure, it's pretty unlikely that global formatting will be changed mid-operation.  But I agree it doesn't totally fall into pure territory.  \nIf you want to remove the Pure attribute and add <remarks> for the lack of purity then I'd be happy to accept.. I'm going to be slowly getting back to lang-ext over the next month, I'm still super busy, but I'm starting to get a bit more free time.  \nThanks to all those who have been answering questions and submitting pull requests.  It's very much appreciated \ud83d\udc4d \n. @asgarddesigns If you want to investigate the code change that might be causing you problems, then I usually put the version number in the commit log.  It's not always quite in sync, but should be close enough:\nhttps://github.com/louthy/language-ext/commits/master. I assume this is because the HKT T4 templates generates a ton of extension methods, and that might be pushing some limit.  It's potentially possible to split lang-ext into Core and HKT, but obviously if you want the transformer extension methods then the problem will continue.  . I'm honestly not sure, the attribute is part of the metadata in the assembly, so it shouldn't be stripped.  And I believe all Bind methods have the Pure attribute.  So, I'm not sure if there's another deeper reason for the errors.. Do you see other attributes like NonRecord, NonEq, etc. that are used for Record exclusion?  If so, I'd suggest that something is trying to be 'smart' by hiding the Pure attribute.  . A cursory glance and this looks excellent, but I don\u2019t have a huge amount of time to review right now.  Do you have an urgency in getting this released? . Looks great, thanks!. Even though I have a fundamental mistrust of regex, I'll allow, thanks. Thanks!. Thanks!. > However, achieving that idempotent behavior is tricky. I have seen many bugs related to it. Because of that, I have been leary of replacing IEnumerable<> with Seq<> in my code.\nI use it heavily.  Including in a language compiler where it gets really nailed.  I'd say your concerns are unfounded now we've ironed out the edge cases.. Just to answer the original point, the benefits of Seq are:\n\nAt most once evaluation of the lazy sequence\nHas performance characteristics that are similar to List<T> in .NET for Cons (prepending) and Add (appending)\nContiguous memory allocation, which means high performance iteration of the sequence of items, especially if the lazy sequence has been evaluated once.\n\nDown-side:\n\nThe at-most-once-evaluation requires caching of the evaluated values, which means infinite sequences are not possible\nThe above also means that there's a memory cost to evaluating a sequence whereas a lazy IEnumerable sequence may never be stored\n\nIt's my go-to structure in lang-ext now, I prefer it over Lst<A> for all list like operations other than where mid-sequence inserts/removals are required.. Disagree.  TryAsync<A> is essentially Either<Task<Exception>, Task<A>>.  Just the left must always be an Exception.  The two sides are still mappable, but the resulting type of the left-hand-side must always be the same, even if the value has been mapped.  So, it will stay as BiMap.. The HKT functions (with the T suffix) are auto-generated, so this might have something causing the eagerness.  . I don't know why, but this keeps hurting my brain.  The Action is essentially implicitly cast to a Func<...,Unit>.  It feels like surprising behaviour (even though I understand your reasoning for doing it).  I can't help think that it should either have a source of this Func<T2, Unit> or result of Action<T1>.\nI'm open to suggestions.  I think providing multiple source variants could help.\n. Ah yes, good point.  I think the least surprising route is the best one here, so yeah let's go for Actions rather than Funcs.\n. a => keySelector(a).GetHashCode()  no null test, use: a => keySelector(a)?.GetHashCode() ?? 0. Renamed this to hashCode please, getHashCode feels nasty.. getHashCode -> hashCode. Is this needed?  Que<T> is already an IEnumerable, and therefore the Distinct extension method for IEnumerable will do the same job.  If it is needed, then it should be this Que<T> as the first argument.. Is this needed?  Stck<T> is already an IEnumerable, and therefore the Distinct extension method for IEnumerable will do the same job.  If it is needed, then it should be this Stck<T> as the first argument.. Is Return the best name for the constructor function here?  Return is known for being a monad constructor function, so I think this could be confusing, and will probably clash with the new monad type-class.  Perhaps Recurse because, regardless of its parameter, it's returning a Recursive<A>? \n. Please remove Some<A>, it isn't used throughout language-ext due to its limitations.  Please just check the val for null and throw. Check func for null. Remove use of Some<A>, it adds a (admittedly small) unnecessary overhead to the execution.. Please place the body of the member expression on a new line:\nc#\n    public static implicit operator Recursive<A>(A val) => \n        new Recursive<A>(val);. Remove this.  It's available in Option to support MatchUntyped, this behaviour isn't needed here.. Can we rename this Rec<A>?\n. In general the comments for Return and Recurse are either missing or very light.  They're constructor functions, and therefore should have some more info about their purpose (like the Recursive<A> type).  . I open to suggestions, I just think that Return isn't really the right name here.  I think whatever it is should be a single word, so no RecReturn, RecurseReturn type ugliness.  We should also avoid anything too generic like Result.  Thoughts?. @IDisposable I quite like Yield. Also Yield is a verb rather than noun, so for a constructor name it's not ideal.  And with that in mind Recurse is a bad choice also.  We need something like Some, None, Left, Right, something that gives an indication of the state of the Recursive once constructed.\nThe only things that come to mind are 'termination' synonyms: Final, End, Last, Done, etc.. @IDisposable \n\nTechnically, Yield is also a noun\n\nThat's a good point... I think I'm back on-board with Yield! (I'm so fickle). Could you remove the leading underscores from the names?  It doesn't fit with any of the existing code base and it's a style I disagree quite strongly with.  Thanks.. This is OK.. This is OK.. Leave these as Head and Tail because it's exactly what's happening.\n. You should look at the implementation, it passes the Tail, not the Head + Tail to the Tail delegate; that's why Tail is the best name here.  As I stated before, the names aren't really important for list matching.  But in this case it should be Tail because it is literally receiving list.Tail as its argument.  \nThis isn't some obscure use case, it allows the user to work with a complete tail rather than a deconstructed one, which under certain circumstances will be more memory efficient than the variant above that does deconstruct.  That's why I added the variant, to help both potential use-cases.. Should probably just call default(MArr<A>).Equals(this, obj);. Could GetAccessors ever return an empty array?  Would it be better to call: \n!p.GetAccessors(true).HeadOrNone().Map(x => x.IsStatic).IfNone(true)\nBecause then if GetAccessors ever did return an empty array then the property would be filtered out.. The problem with the new implementation is it traverses the tree twice.  I think we can do better than this.  Leave it with me.. This commit is all great, but could you do me a favour and remove the empty-line every other line:\nSo this:\n```c#\nobject value = null;\nvar actual = NullCheck(value);\nAssert.Equal(ExpectedWhenNull, actual);\nBecomes:c#\nobject value = null;\nvar actual = NullCheck(value);\nAssert.Equal(ExpectedWhenNull, actual);\nJust as a general rule I like to keep related blobs of code together, only spacing when there's a natural 'pause' in what's happening - the message to the programmer being \"We've done that, now we're doing this\".  I think because the setup/test/assert are one-liners here, there's no real \"we're doing the setup bit, now we're moving to the testing bit, ...\". This should stay as `default(T)`, it's more efficient than accessing the `DefaultT` field.  . I think we've gained some local changes that probably shouldn't have been committed?  . Missing `return`. It's probably worth making sure your code compiles before committing ;). This incurs an additional allocation over the original (for the lambda).  Can we go back to how it was please.  Mostly I would prefer the pretty code, but this is a function that most people wouldn't expect to have a resource cost.. This incurs an additional allocation over the original (for the lambda).  Can we go back to how it was please.  Mostly I would prefer the pretty code, but this is a function that most people wouldn't expect to have a resource cost.. There appears to be some inconsistent indentation here.  Why aren't they lined up any more?. Your tab size is 2 spaces, this project uses 4, could you change that please.. Please remove all `#region`s . Please format expression methods like so:c#\npublic bool Equals(Mass other) => \n    Kilograms.Equals(other.Kilograms);\n.c#\npublic override bool Equals(object obj) =>\n    obj is Mass m && Equals(m);\n. Please move the `=>` arrow to the line above:c#\n    public static Mass Grams(this int self) => \n        new Mass(self / 1000.0);\n``._sizeinList` is always updated after the allocation if its internal array and any set operation.  So, even though it could be out of sync with the backing store, it will only ever report that the collection is smaller than it thinks.  So, the worst that could happen (I believe) is that we attempt to stream another item.   But there shouldn't be any synchronisation issues.\nThere's a unit test that pretty aggressively tests the lazy loading whilst multiple threads are trying to iterate it:\nhttps://github.com/louthy/language-ext/blob/c412a962fac7110845b80d0f80a467cc929637ff/LanguageExt.Tests/Seq.Module.Tests.cs#L182. I guess there's one of two trade-offs needs to be picked here:\n\nThe lazy stream blocks if you try to jump ahead \nThe general performance if lazy streams is reduced from the cost of the lock acquire per iteration\n\nGoing to have a think on this one.  And probably do some perf tests to see where we stand.  I'm erring towards your solution, because the type will act more like a regular immutable type.. Sorry, I don't follow?  I'm looking at it now, and I can see that last if should be moved inside the else above it.  But other than that not really sure.  The ugliness of the function is obviously to try and return as quickly as possible without doing unnecessary work.. I guess you could say that.  More precisely Strict forces evaluation.  . I have made the change you suggested.. Namespace should be:\nc#\nnamespace LanguageExt.UnitsOfMeasure;. This will be unnecessary once you update the namespace in Mass.cs. ",
    "ButchersBoy": "Looks awesome, your write up is really good, will have a play with this over the next few weeks.\n. Hi, just throwing in my tuppence worth, but as a WPF developer, that TypeConverter is pure ugly.  That's part of what view-models are for, to massage stuff in and out of a view.  Why bind directly to the Option<>, when you can wrap/convert it in some kind of proxy for view-time? For example, I never bind a TextBox.Text to an int.  Id' bind it to a string, and manage validation & conversion in the view-model without having to jump through horrible hoops.\n. Hi @Silv3rcircl3 ...no, I don't really have a better idea, other than these comments:  \nIf it's a readonly (OneTime) binding, yeah, expose the Option<>.  If it's not, simplify it through a property, for various reasons:\n- The TypeConverter is complicated, and therefore brittle, and therefore likely to break\n- The TypeConverter won't be performant.  I spend most of my time working on systems with large UI grids and high throughput of data.  This kind of thing would likely cripple performance.\nOn my current system we have our own similar Option<>, but whether its Option<>, or another domain object I normally try and follow the process:\nConstruct VM/Unpack domain object > user edits VM/proxies > user submit > pack into Domain object, leave VM\nThis also, roughly translates into\nImmutable Object > Mutable Object > Immutable Object\nThe longer your data is immutable (e.g sitting in a Option<>), the less brittle your code will be.  UI aspects are notoriously brittle.  So on exit/save/when appropriate, at that point push into domain/Option<>/immutable object as the data leaves the VM.\nThis is just my opinion, but I've written many successful UI screens in this manner.\n. Reading your use case, I still stand by what I have said.  5 fields or 150, your users opens the app, edits it then closes the screen, and potentially the app.\nTwo things stood out for me from what you have described:\n- Your model/domain layer is mutable.  I always strive to have an immutable domain object.  If it needs to change, you replace it.  Which is the same with Option<>.  Even if the backing store (whatever that may be) only updates on application exit, it is good practice.  Exiting the application is the same as closing a window.  By coding this way you will leave the flexibility to open/close records which ever way the app works.\n- 150 fields.  OK, so your big issue is repetition.  You have been trying to avoid that by binding to directly Option<>.  I would be aiming to avoid it by normalising sets of those fields.  Possibly into one more more collections.  Those collections may contain name/value pairs and be grouped by type or by validation requirement or by something meaningful to the user.  I would then generate a proxy VM, which would receive the Option<> on construction and re-generate an Option<> on demand, either save or shutdown/close.  Then, the magic of WPF DataTemplates/ItemsControl will repeat the UI.  Thus you will only have one get/set on your proxy.  There may be a few flavours of proxy, but certainly not a property per backing store field.\nHope that helps!\n. @vintem have you seen this? https://github.com/dsplaisted/strongnamer\n. ",
    "brandf": "Ok, that's more or less what I thought.  \nRegarding further feedback, as you said AsEnumerableOne is the direct type conversion into the IEnumerable monad, so consider renaming this AsEnumerable.  What you're currently calling AsEnumerable is actually a type conversion + repeating that value forever, so consider renaming this one to have the additional suffix: AsEnumerableRepeated, if not removing it entirely.\nI don't do enough functional programming to have a sense for how often the lazy stream switch situation comes up, but it sounds like something I've seen done with IObservable (System.Reactive.Linq).  There is already a conversion from IEnumerable to IObservable (AsObservable), and there is already a Repeat method which makes it infinite, so the convenience seems minimal vs. just composing two existing functions.\nWeighing the convenience vs. how frequent this situation comes up vs. the added confusion of having two conversions into the IEnumerable monad, etc seems warranted.\n. ",
    "asgerhallas": "I must admit, I don't see that ctor anywhere: \nhttp://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx) ?\n. @louthy @laynor ooh... I didn't see those brackets were curly, sorry :)\n. ",
    "Therzok": "Thanks, it makes more sense now.\n. Better use default(string)\n. Good catch!\n. ",
    "jonpryor": "A suggestion for an improvement:\npublic static Func<T, R> memo<T, R>(Func<T, R> func, Func<R, bool> keep = null)\n{\n    keep = keep ?? v => true;\n    var cache = new ConcurrentDictionary<T, R>();\n    var syncMap = new ConcurrentDictionary<T, object>();\n    return inp =>\n    {\n        R res;\n        if (!cache.TryGetValue(inp, out res))\n        {\n            res = func (inp);\n            if (!keep (res))\n                return res;\n            var sync = syncMap.GetOrAdd(inp, new object());\n            lock (sync)\n            {\n                res = cache.GetOrAdd(inp, res);\n            }\n            syncMap.TryRemove(inp, out sync);\n        }\n        return res;\n    };\n}\n. > I don't currently see how your example can do anything other than stop the growth of the cache?\nIndeed; my proposal is not a very good solution.\n\nTo do a large caching system properly you'd want to know about the age of objects, possible size, etc, so that you could defer the decision about what stays in the cache to a 'cache manager function'.\n\nExactly.\n\nIt's memoization, not a cache,\n\nIt's trite, and (more importantly) meaningless. People don't read documentation, will come across this method, use it, and suffer.\n...and if people do read documentation, your documentation states that values are cached, so stating \"it's not a cache\" is immediately contradicted by documentation.\nIn fact, this \"memorization is a memory leak\" outlook isn't exactly \"far fetched\":\nScala:\n\nProblem is, all computers commercially available today only support a finite amount of memory, so memoization of such data structures is very capable of making your program throw an OutOfMemoryError.\n\nJavaScript (in the comments):\n\nA memoiser is then a great generic way to build a cache.\nThe danger however, is to have this cache growing with every cycle of actions in the app. Then the memoiser ends up being a huge memory leak\n\nReact:\n\nMemory leaks due to heavy memoization\n\nClojure\n\nThere are (unfortunately) a few places in Closure Library where unexpected memoization might cause a memory leak.\n\nThe unfortunate truth of the matter is that memoization is a feature very easy to misuse, and when it's misused the results are subtle: increased memory use, a corresponding decrease in system responsiveness, out of memory conditions, and possible crashes.\nFurthermore, because of the nature of usage, the actual container of the cache is hidden behind a captured variable, inaccessible to everything but the debugger.\nIn terms of API usage, I believe it would be better to just drop the entire idea of memoization. If you need a local cache of values in a LINQ statement, it's not difficult to create one, in the current scope. Even better, the existence of said cache would be immediately evident, instead of buried behind a delegate.\n\nSo if it causes too much confusion I'd rather remove it altogether than try to accommodate complex caching mechanisms.\n\nThis would probably be best, frankly.\n. ",
    "johtela": "Hi Paul,\nThanks for the reply. I understand your position perfectly. If you are not aiming at building a comprehensive functional library, but only tackling the specific problems you mentioned, merging the libraries is not a good idea.\nHowever, I bit disagree about the point you made about the practicality of the \"fundamentalist\" approach in general C# programming. Retrofitting immutable data structures and monads into a legacy OO project does not maybe make much sense. But in a greenfield project the situation is different. Many people have been exposed to a functional programming lately through F#, Haskell, Scala, Clojure, etc. and they see that C# actually has many functional concepts found in these languages. They would like to program C# in a functional way as well.\nThe problem is that it is not idiomatic to program C# in a functional way. Many APIs of .the NET are hopelessly imperative making it quite painful to incorporate them in functional code. Tuple and Lazy types are good examples; they implement the basic concepts but with a clumsy syntax, and are used little in other places of the .NET framework. Instead of returning tuples, methods in .NET 4.5 still use the hideous out parameter convention. See the TryGetValue() method in the IImmutableDictionary interface, for example.\nThis is one of the reasons, I am not too happy with the System.Collection.Immutable library. It does a semi-decent job implementing the purely functional data structures, but the abstractions and APIs are quite lacking. IEnumerable too, although prevalent and very useful, is still very much an imperative abstraction. My ideal framework for C# would contain not only the data structures but also the abstractions and idioms for writing them. Clojure does a very good job in the JVM world defining a bunch functional abstractions and hiding the imperative Jave framework.\nI guess my ultimate goal would be to write a library that would be the jQuery of C#. That is, a library that would change the way people write C#. JavaScript programming is nowadays very much synonymous to programming with jQuery. The library has effectively patched a slightly flawed imperative language into something that looks and feels much nicer.\nLanguage-ext in many ways does exactly that as well: it makes C# code look and feel a bit more elegant and cleaner. If .NET framework was perfect already, so many people would not be writing these kind of libraries as you and I do :-)\nI also disagree about parser combinators not being practical. I have used them in couple of real projects and to me they are much easier to use than writing a custom top-down parser, or using a Yacc style parser generator. Since parser combinators support only LL(1) grammars with no backtracking, they are very fast too. This is also their only weakness; converting a complex grammar into LL(1) is not always straightforward.\nI admit that it is easy to go overboard with Linq expressions and sometimes you can write clearer code with plain old statements. But the composabilty of monadic expressions and the fact that you can really build your code like lego blocks make it very hard not to overuse them. You could call this the Haskell syndrome :-)\nKeep up the good work!\nRegards,\nTommi\n. Let me try to sum up what I mean by not being happy about the abstractions. First let's take the IEnumerable interface. The good thing about it is that the interface is supported by practically all traversable structures. That fact makes Linq as useful as it is. This is great, and this is the reason why I also support IEnumerable in my collections.\nThe abstraction actually consists of two interfaces: IEnumerable and IEnumerator. The latter is a stateful pointer or finger to your data structure, and the former is a dispenser for these pointers. This means that you cannot pass IEnumerators outside your loop structure, because that would most probably mess up your traversal. You can only pass IEnumerables, which will create new enumerators at request.\nThe downside of this implementation is that IEnumerable is not always the most efficient way to traverse a collection. It can be even less efficient when manipulating a collection with Linq operations like Select, Where, SelectMany, etc. These are implemented in Linq by creating a promise or lazy computation, which when evaluated will apply the computation and traverse the underlying collection.\nAssume for examle, that you would like to skip first 100 items in a collection and pass the tail to a function that will use it repeatedly. You can certainly do this by passing coll.Skip(100) to the function. But every time the function loops through the collection, the loop will also step through the first 100 items.\nYou can fix this by copying the collection to an intermediate data structruce (with ToArray(), for example) before passing it to the function, but sometimes you don't know what the function you call does, so there is no way to guess what kind of performance issues there might be.\nFunctional collections like list and tree are based on a recursive data structure. They rely on structural sharing to allow efficient implementations. Better abstraction for these kind of collections is something like Seq interface in clojure. That contains the canonical list operations: head, tail, and cons. In Flop library this abstraction is implemented by two interfaces, IStream and IStreamBuilder. The first one is a read-only interface that has the getters for head (First) and tail (Rest), and the second one is the interface used to construct new streams.\nYou can define a lot of operations using these interfaces, and there is no need to wrap any computations to implement this inteface. The guideline is that all the operations should have (amortized) O(1) implementations. If this is not possible, a data structure should not implement this interface.\nThis brings me to the next important abstraction: the IReducible interface. It abstracts the fold/reduce/aggregate operation that is found in practically all functional languages. It is basically the dual opposite of IEnumerable. You can do everything with IReducible that you can do with IEnumerable, and even more. You can traverse a collection front-to-back (ReduceLeft()) or back-to-front (ReduceRight()). But instead of being lazy like IEnumerable, IReducible is very strict. It always evaluates the whole collection. Instead of being pull-based, it takes a delegate as parameter to which values are pushed.\nIt is actually much efficient to traverse tree structures with IReducible than with IEnumerable. You don't need to maintain any intermedate data structure (stack or queue) to remember where you are in the tree. The implementation of the function is trivial for immutable data structures, and it is usually the most efficient way to traverse them. I think the latest innovation of Clojure you mentioned, namely transducers, are actually based on the idea of using reduce as the abstraction to manipulate data structures and with network data streams using the same exact implementation. I cannot say that I fully understand the concept, but that is my impression anyway.\nThe rest of the immutable interfaces found in System.Collections.Immutable like IImmutableList, IImmutableSet, and IImmutableDictionary are just slightly modified versions of their mutable counterparts. There are not suited at all to build higher level operations and abstractions on top of them. I see very little practical use with those.\nI should have probably explained all this in the documentation of Flop, but as I said, I am too lazy to write documentation when I can write code instead. Although in a functional setting laziness is a virtue :-) I will try to explain in the documentation why I think these abstractions are important and how to use them in real, practical code. I would also like to incorporate parallellism to these concepts. If you can make the assumption that the code manipulating the collections is side-effect free, you can automatically parallellize some of the operations making them even faster.\nHope this rambling explains my points a bit. Regarding parser combinators, I was thinking of writing an exmple parser that would parse JSON data. I know I would be reinventing the wheel there, but that would be a good example to show how concisely you can build a parser.\nRegards,\nTommi\n. ",
    "kasajian": "Thank you for the explanation.\nAnd I agree with you that that's the purpose of the Lazy class, for momization.  I was just saying that if put aside as to how the value get inside of Lazy or Option, they are similar in that:\n1.  The are a container of a value.\n2.  They work with both value types and objects.\n3.  They may or may not contain a value.\n4.  You can query it to determine if has a value.\nLazy doesn't create inner Value until you attempt to access it via the Value property.   If you use the version of Lazy where you provide an initialization function, then you can simply access the Value property to force it to contain a value when one exists.\nTo illustrate, take a look a simple usage of it as an alternative to TryGetValue for Dictionary:\nhttp://programmers.stackexchange.com/questions/159096/return-magic-value-throw-exception-or-return-false-on-failure/264516#264516\n(my alias is zumalifeguard)\nI can't disagree with you if your position is that using Lazy in this way is hackish and you may not want to rely on it for your framework.   I was just curious if that, in fact, your stance.\n. Thank you.   You're right.   When you have Option in your library, it's ideal.   I was suggesting that without such library, if one wishes to return a value from a method that may be an object, null or no-value, then Lazy can be as an internal implementation that mimics Option.   The client only sees a version of Lazy with a value or without a value.   They don't use it to perform deferred instantiation.   Anyway, I think I got the answer to my question.   Thanks for your time.\n. Yeah, no worries.   If I were you, I'd probably see if others agree or not, especially if no one else agrees.\nI think it's perfectly fine as an internet open-source project.   But if this thing is to become more mainstreamed, and sponsored by the .NET Foundation, my thinking is that it might need to get modified. \nGood work, otherwise.. ",
    "samirahmed": "Yes I considered that will help :) i just uninstalled-package that... perhaps time to re-install.\nHowever if there is ever a future vote on this... my vote is still +1 for .Value native support :)\n. To be fair, its not just WPF that needs this ...  in MVC and WEBApi TypeConvertors are used to bind incoming requests.  Without a typeconvertor it would mean I can't use Optionals at the Request object binding layer (which is imperative since I would have to validate incoming requests and at times allow for optionally null)\n. ",
    "tejacques": "I think we're on the same page, but I just wanted to clarify my suggestion was more for removing Some(value) so that users can't possibly get it wrong.\nI think the implicit cast works quite nicely, the only real reason to add an explicit constructor/creation function is to be able to have consistent use of var and remove the type annotation.\nIE:\ncsharp\nOption<string> = \"Hello world\";\nvs\ncsharp\nvar = option(\"Hello world\");\n. That's a totally fair thought process. There's always going to be a tradeoff unless C# / .NET gets a non null reference type (which seems unlikely at this point), and the \"if it's going to be wrong, blow up quickly\" approach does make it easier to find the root of the cause.\nClosing this & thanks for the discussion!\n. No problem -- I like the way you handled everything, I think that makes it work out nicely. Closing this issue now.\n. +1\n. ",
    "tomaszpolanski": "Thanks for the clarification Paul, keep up the great work!\nCheers,\nTomasz\n. thanks for the response.\nFor now I've only tried to use the NuGet package and they still glitchy overall in Win10 and VS 2015.\nI will investigate this issue a bit more and also try using sources instead to pinpoint the issue.\nWill get back to you after I investigate it.\n. Hi @louthy, I did not have time before to try it out again. Today I will do it and give you feedback.\n. I've investigated the issue more closely.\nIt seems that nuget is not the issue. \nThe issue is that the library is not Portable, so no wonder that it cannot be used inside Universal application/library.\n@louthy, is there a reason why your library is not Portable?\nCheers,\nTomasz\n. Great, thanks for the response!\nT\n. ",
    "marcpiechura": "Hi @louthy,\nthat explains the lack of binding support :)\nHonastly, that's also for me the first time I must write a TypeConverter, usually I would write a ValueConverter and set this for a specific binding/value, for example to bind a bool value to the visual state of a control. \nAlso the converter I wrote yesterday was more like a workout in the morning, so it's not really perfect and only tested with Option<String> and Option<TestClass>.\nHoppfully I can answer your questions correctly, I have only the knowledge of google from yesterday about the TypeConverter and I doesn't have deep knowledge about the binding system from WPF, I \"only\" know how to use it ;)\n1. After I read your anwser, I thought over this and I think that can't happen. Because the converter is coupled to a specific type, in this case IOptionalValue and should only used for this type. \n2. ConverTo is for the VM -> GUI way and I think the control properties can handle null, if not I would only expect something like a \"BindingError\" which only shows up in the debug console from visual studio. Another example  would be if you bind a textbox to a integer value and then type \"ab\" into the textfeld, this case is handled by the binding itself and doesn't throw any exceltion which could crash the app.\n3. Doesn't know if I understand your question correctly and I'm not sure if some gui property updates the vm with null, but if so, None would make sense in my mind. For example if you bind a DatePicker to Nullable<DateTime>, the control would set the vm property to null if no date is selected, which should be None in option case ?! If I remember me correctly, this case bound to DateTime would set the vm property to default(DateTime).\n4. I tried this method at the beginning, unfortunately the value must implement the IConvert(or something like this) interface.\nI also have to say, that I read about your framework at the weekend and started a \"could it be work for me\" hour yesterday, so  I'm really new to option, some ... ;)\nSince you personally have no benefit from implementing binding support for WPF (as you said more a web guy) and you would have to learn the hole WPF stuff, I would suggest that I install VS 2015 in a VM and try it by my self. If I have question, I would ask again and if the converter is working, I would write a demo application and submit a pull request.\nOf course I have no doubt if you want to do it by yourself ;-)\n. HI,\nworks great, with some modifications ;)\nIn ConvertFrom\n: methods(value.GetType())?.Invoke(\n                                null,\n                                new[] { simpleTypeConverter.ConvertFrom(context, culture, value) }\n                                );\nyou use value.GetType but it must be simpleType.\nvalue == null\n                ? None\n                : value.GetType() == simpleType\n                    ? methods(value.GetType())?.Invoke(null, new[] { value })\n                    : value is string && String.IsNullOrEmpty(value as string)\n                        ? None\n                        : simpleTypeConverter == null\n                            ? base.ConvertFrom(context, culture, value)\n                            : methods(simpleType)?.Invoke(\n                                null,\n                                new[] { simpleTypeConverter.ConvertFrom(context, culture, value) }\n                                );\nAnd Prelude contains Optional<T>(T) and Optional<T>(Nullable<T>), so this one\noptional = (from info in typeof(Prelude).GetMethods()\n                        where info.Name == \"Optional\"\n                        select info)\n                       .Single();\nthrowns an Exception and Single must changed to First.\noptional = (from info in typeof(Prelude).GetMethods()\n                        where info.Name == \"Optional\"\n                        select info)\n                       .First();\nAnother problem is binding a ListBox to Option<List<string>>, because Option implements IEnumerable the binding isn't calling the TypeConverter but calls directly IEnumerator IEnumerable.GetEnumerator() from Option.\nWith this method it works, but I'm not sure if this would break something else or if this was the idea behind implementing IEnumerable at all. \nIEnumerator IEnumerable.GetEnumerator() =>      \n            (value is IEnumerable) \n            ? (value as IEnumerable).GetEnumerator() \n            : AsEnumerable().GetEnumerator();\nOne last thing, do you know that the static using has changed?\nusing LanguageExt.Prelude;\ndoesn't work any more, must changed to\nusing static LanguageExt.Prelude;\nJust asking because in the readme and sources the old way is still used and I had to change it everywhere befor I could compile the source code ;)\n. Sorry, I skip that you have also implemented it for Some. \nCould you explain me when some should be used for member declaration(of course only in the scope of a view model)?\nFor me it sounds like the only reason would be to be sure that the value can't be null, like int but for all types.\nNormally I would handle this with Nullable and some validation which checks that HasValue is true or a ValueConverter which throws an Exception like \"xyz is required and must be a number\", because the default behavior in WPF when you bind a textbox to int looks like this: \nOn start text is set to default int value\n\nif you type in some number it converts successfully \n\nand when you clear the textbox you get an error message \"The value \"\" could not be converted\"\n\nand the same for inputs which aren't a number\n\nand this error message in the Output window from VS\nSystem.Windows.Data Error: 7 : ConvertBack cannot convert value '1a' (type 'String'). BindingExpression:Path=OptionalString; DataItem='MainWindowViewModel' (HashCode=46256406); target element is 'TextBox' (Name='textBox'); target property is 'Text' (type 'String') FormatException:'System.FormatException: Die Eingabezeichenfolge hat das falsche Format.\n   bei System.Number.StringToNumber(String str, NumberStyles options, NumberBuffer& number, NumberFormatInfo info, Boolean parseDecimal)\n   bei System.Number.ParseInt32(String s, NumberStyles style, NumberFormatInfo info)\n   bei System.String.System.IConvertible.ToInt32(IFormatProvider provider)\n   bei System.Convert.ChangeType(Object value, Type conversionType, IFormatProvider provider)\n   bei MS.Internal.Data.SystemConvertConverter.ConvertBack(Object o, Type type, Object parameter, CultureInfo culture)\n   bei System.Windows.Data.BindingExpression.ConvertBackHelper(IValueConverter converter, Object value, Type sourceType, Object parameter, CultureInfo culture)'\nSo for some this would mean every value that comes from the UI which is null or can't be converted to T would show such a \"meaningful\" error message like \"Can't be null\" or \"Cant' be converted\"... \nAnd are you returning None if string is empty?\nGot this error message when clearing the textbox bind to Some<int>\n\"LanguageExt.OptionNone\" could not converted to \"LanguageExt.Some`1[System.Int32]\"\nSo the some converter should not check for empt string, but rather let the simpletypeconverter handle this case, because it should work for some<string> but not for some<int>.\nAnd last but not least, this happens only for value types but with some this would also happen for reference types...\nWith all this in mind, I would never bind to Some, but rather use Option and some validation logic to handle these cases... \n. Hi @ButchersBoy \nas I said I also would not bind a Textbox to an int ;-)\nBut without the TypeProvider a conversion from every Option<T> to T would be required, if you use Option in you model. \nIn your example you would create a facade over you model, which makes sense of course, but what about use cases where you do not need any validation or conversion?\nYou would end up with useless getter and setter in the viewmodel wich are converting the option from the model, in these cases I would just bind directly to the model properties. \nOr do you have a better idea how to solve these cases?\n. I agree to all your opinions and you have probably more experience then I do.\nSo maybe you could give me then an advice, because the projects I'm working on aren't from these nature, were a user clicks a button, \"fills out five fields\" and clicks submit. \nIt's more like a reporting tool, so the user opens a \"document\", in my case a patient, then has to fill out ~150 fields, some with validation, some without and then closes the program. \nOf course, in some cases there are some \"submit\" dialogs and I handle these as you discriped.\nBut in general, I \"just\" have to expose many fields as long as the programm is running, \nSo, how would you handle these cases? Would you sill use a \"proxy\" for all properties?\nCurrently I bind 90% directly to the model(which is exposed through the vm) and the other 10%, are fields where I need conversion or validation, so I bind them to the VM. \nI know, that's not as it should be, but is the effort worth the outcome?\nFurthermore a subset of ~50 fields need to be displayed in a live report, for printing...\nSo these would be your read only case, but without the TypeConvert, I would need to expose these fields via proxy again. \nSo, hopfully you understeand why I would like to bind directly to my model properties without exposing them again through the vm.\nHaving said that, I would of course change my opinions and use the vm as proxy instead of the TypeConverter. \nSo I would be thankful for your advice!\n. Sounds good. \nI already read about immutable models and replacing instead of updating in context of F# and event sourcing and I found it quite usefull but never get my head around how to apply it for my use case ;-)\nI definitly give it a try!\nSo, many thanks for your adivce!\n@louthy I think you can close this, I will try @ButchersBoy approach, sorry for coming up with this ;)\n. Works now!\nShould I create a demo application for you?\n. Apologies for the late response but I was ill the last month.\nI just want to ask if you still need the demo project, I could create one tomorrow ;-)\nregards\n. @louthy unfortunately I haven't used the actor pattern before, but it sounds great and I have used the process part exactly for what you describe, I think. I used a spawn to loop through a directory, parse every json file content and then used a tell for notify other subscribers. The interpreter part sounds a bit like a mediator I used for the ports and adapter pattern. There I have send a request message to the mediator, which used a container to resolve the handler for this request, wraps the execution with pre and post actions(logging for example) and then executes the handler with the message and returns the result to the caller. \nAnyway, I also haven't actually the time to learn more about the actor pattern or the process part of you library, that's also the reason I hoped you may have some documentation ready ;-)\nBut as far as I have finished the current project, I will come back to this and hopefully can learn this stuff and maybe can contribute something back, because I used the other parts with great success in the current project :+1: \nthanks.\n. ",
    "donners77": "Fantastic!\nThanks.\n. Hi.\nI think I've tried what you suggested...\npublic void SomeCastTes3()\n    {\n        var some = new Some<List<string>>(new List<string>() { \"a\", \"b\", \"c\" });\n        Foo(some.Value);\n    }\nBut it doesn't seem to be acceptable to the compiler...\n\n. I think I may have found a solution...\npublic static Some<T> ToSome<T>(this T value) { return Create(value); }\nThen to fix the error in the previous screenshot I can do filterMut.Value.ToSome<IFilter<T>>() in c# 5, which is not too messy.\n. The implicit type conversion also seems to fail at times when no unwrapping is required, e.g...\n\nToImmutable() returns an IFilterIm<T> but the compiler complains about implicitly converting this to a Some<IFilterIm<T>>\nI wonder if this is some implicit casting limitation related to Generics?\nHowever, using the static ToSome() method I proposed above without any type annotation makes it acceptable to the compiler.\n. Hi. Wondering if you have any further thoughts on this?\n. Hi. I don't mind. Happy to just implement it for myself. Happy for it to be in the namespace you suggested if you think other people will need it.\n. ",
    "KodrAus": "Looks good, I hadn't seen that on the readme. So you're supporting currying by supplying an explicit function for each possible number of arguments, up to a total of 7?\nThe approach I'd tried to take was to support currying of functions up to any length (at least to the max supported arguments of Tuple<>, which is 16?), but yours is much easier on the eyes.\n. I pretty well agree that 7 arguments should be heaps in most circumstances, I'm just thinking out loud about the different approaches, I was basing mine off what I've seen of compiled FSharp. \nI had actually just assumed Tuple took 16 because of Func's 15+1 generic args.\n. That's really nice, I'll have to have a play with it and see what I come out with\n. ",
    "ricardopieper": "So the process part of LanguageExt is something like Akka.net?\nIn fact I will need an actor system very soon. I will not do any complex work, just some simple things but I'll give it a try. \nAbout the method signature MatchAsync, I like it because it looks Microsoft-y. Their APIs are all SomethingAsync, so the name fits well.\n. I wish I could honor all this text and make some deep/insightful comment, but unfortunately I can't. But it does look like good documentation :smile:\n. I'm doing some tests using the Process library. \nI'm using LanguageExt because I'm a little more familiar with functional programming and I want the functional goods in my code.\nBut the rest of my team (just only one other guy) probably isn't familiar with it. So I'm introducing Options and Eithers and functional programming in general in an easy to digest way.\nWhile the Process library seems to work fine (and the Fold approach is very cool), I think i'll stick to the class-based Akka approach because it's more familiar to the rest of the team. Also, it's more mature, it certainly counts.\n. So IProcess looks like TypedActor in Akka. Interesting.\nI updated my fork, but changed the new span method to this:\npublic static ProcessId spawn<P,T>(ProcessName name)\n        where P : IProcess<T>, new() //added new() constraint\n    {\n        return spawn<IProcess<T>, T>(name, () => {\n              var p = (IProcess<T>) new P(); //no reflection (I think)\n              p.Setup(); //added Setup to the interface as well\n              return p;\n          },\n          (process, msg) => {\n              process.OnMessage(msg);\n              return process;\n          });\n    }\n. I also created this:\npublic static ProcessId spawn<P, T>(ProcessName name, P processInstance)\n        where P : IProcess<T>\n    {\n        return spawn<IProcess<T>, T>(name, () => processInstance,\n          (process, msg) =>\n          {\n              process.OnMessage(msg);\n              return process;\n          });\n    }\nFor reasons that I don't know yet.\nEdit: Probably for starting state. I could do this in the Setup function, but I thought that it could be useful.\n. Hmm, I understand. I didn't consider that.\n. ",
    "mpartipilo": "This is quite similar to Sprache.\n\nOn 19 Mar 2016, at 02:45, Paul Louth notifications@github.com wrote:\n@ricardopieper - A first pass at a parser combinators library is now in git (not on nuget yet)\nhttps://github.com/louthy/language-ext/tree/master/LanguageExt.Parsec\nI'm going to be using this in the Process library for configuration scripts. If you're interested in examples, here's the parser:\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Process/ActorConfig.cs#L176\nAnd a unit test that uses it:\nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Tests/ParsecTests.cs#L446\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. \n",
    "gordonwatts": "I might also suggest that as you add more and more to this library you split it from being monolithic...\n. I have been watching this conversation for a while now. I agree it would be great to upgrade the way C# handles monads. The C# team seems pretty serious about taking ideas from the community - their GitHub is full of proposals and what looks like serious conversation after they are made. The road into the language, of course, is a bit longer. So I'd encourage us all to propose ideas. In some other work I've been doing I have been stuck in monad hell (as I call it - having to write \"var newvalue = from x in monad1 from y in monand2 x + y;\" over and over again, obscuring the simple \"+\" operator which is what is important), and I can't help but wonder if one couldn't write something much simpler that using the pre-existing LINQ infrastructure but hides all the \"from x in monad1\" code. The issues you've been discussing above would probably require a little more, but I'd urge you not to shy away from putting together a proposal.\n. Ok, I think I'm getting it... but it looks very ugly.\nvar r = (await jk)\n            .Right(j => j.lastBuild == null ? Left<Exception, JenkinsJob>(new ArgumentException(\"No build completed\")) : Right<Exception, JenkinsJob>(j))\n            .Left(e => Left<Exception, JenkinsJob>(e))\n            .Map(j => j.lastBuild.number);\nwhere \"jk\" is the result from _server.FetchJSON<>\nPerhaps there is a way to clean that up? It isn't very readable as it stands. :-)\n. Ah, thanks. The Bind rule of thumb is exactly the sort of thing I'm interested in. Also, the breakdown and refactoring is a huge help as well.\n. ",
    "Jagged": "Are you open to PR's to help with the code documentation?  If so, I suggest we co-coordinate efforts by raising issues for each class or related group of classes.  Obviously your README file is a great source to pull from, beats starting from scratch!\n. I'll start on docs for Fold and Reduce next, etc, it's about time I actually got my head around these!\n. Paul, thank you for that detailed description and background, the scary thing is I think I understood it!  Nicely explained!\nFold is for combining values into another value (think cake mixture and adding extra ingredients).\nReduce is for reducing down to a single value (think boiling down to a concentrate).\nThat's assuming I got it correctly? (and if the lame lay-person examples make sense!)\n. They're both for aggregating a value. It's only the start condition that's different.\nYep, I get that.  It would be interesting to find the roots of the naming of those two methods, to see what inspired them to be called fold and reduce ..  =)\nDarnit, I'm finding it easier and easier to read those!  I recently took a look at some F# code and it made me realise how much C# has already started the transition with Linq and similar, getting people used to piping results from function to function to function.  OK, the syntax is different, but the flow is much the same now.  Lots of small reusable functions.\nI can't help but notice a huge amount of repetition when I searched for Fold (etc).  I wonder if there's a way to get the compiler to help us here.  T4 templates?    Marking classes as IFoldable etc and using extensions?  \nWhen looking at some of the Fold comments I found two distinct styles: (1) what it does, and (2) how it does it, in quite a bit of detail.  The latter doesn't work that well with intellisense.\nPerhaps we could move the How under remarks and put the What under summary?  \nWhat would you like to do there?\n. cata-what-ism ???? lol!  I'd never remember how to write that!\nI like where bind is going there, and the use of LINQ.  There are some imperative bits in the code that are screaming out to be made functional, eg TryOption.Subtract.  I'd love to see what milage bind might offer, if for no reason to see how functional coding could be used in a situation like that.\nedit: Based on what you said earlier, would the following be equivalent?\n``` C#\n    public static TryOption Append(this TryOption lhs, TryOption rhs) => () =>\n    {\n        // imperative\n        var lhsRes = lhs.Try();\n        if (lhsRes.IsFaulted || lhsRes.Value.IsNone) return lhsRes;\n        var rhsRes = rhs.Try();\n        if (rhsRes.IsFaulted || rhsRes.Value.IsNone) return rhsRes;\n        return TypeDesc.Append(lhsRes.Value, rhsRes.Value, TypeDesc.Default);\n    // or bind\n    return bind(lhs, l => bind(rhs, r => TypeDesc.Append(l, r, TypeDesc<T>.Default)))\n\n    // or LINQ (is there a cleaner way without Invoke?)\n    return (from l in lhs\n                from r in rhs\n                select TypeDesc.Append(l, r, TypeDesc<T>.Default)).Invoke();\n\n};\n```\nedit2: I had a closer look at Bind for TryOption, it definitely looks like it'll do it.  Trying to follow the LINQ version thru the code is a little harder!\n. Hi Paul, thanks for your feedback.  I'll go thru things and amend to\nprotect against threads, I suspected you might pull me up on that!  The new\n?. operator is quite useful here!\n- Will\n. I think I've completed all you've asked, though with a little artistic license. =)  I noticed that ActorInboxLocal wasn't Cancelling the tokenSource, so added that.\n. Ah so \"pid.Head() == RootProcess.Id\" is asking if the process is local / on this machine??\n. Glad I mentioned it then!  I felt silly not being able to fix it myself, but the code in this area is rather opaque, and screaming out for documentation!  Or better still, make the code self-documenting thru use of explaining variables, perhaps renaming some routines, and breaking some of the larger ones down into manageable bits.\nI'm more than happy to roll up my sleeves and helping with that, but I guess I'm wary of stepping on your toes!  You might find some routines unrecognisable when I'm done!  =P  (but hopefully clearer!!)\nI've noticed that quite a bit of code still deals with \"raw\" reference types that can be null, having to continually check all over the place.  I'd like to see how we might be able to make use of Some{T} etc.\nUltimately, I'm keen to help out, and see it an opportunity to get familiar with the functional side of things in depth.  \n-Will\n. > My slight concern based on your comments is that it would just be a 'style war'\n\nBut if you can just bear my concerns in mind that will make the whole process much smoother\n\nThanks for taking my comments so graciously, I have to remind myself that you don't know me from a bar of soap.  Sometimes my enthusiasm can get away with me, and other times I can come across quite blunt (oops, sorry!).  It's simply because I give a damn, and hoping I'm more than a help than a hinderance! =)  \nPlease keep the feedback coming, it's appreciated! \n\nSome is less useful that it should be unfortunately.\n\nI had a quick look at it last night and was, um, surprised - I didn't know it could hold nulls and be treated as None.\nUpdate: It's been hardened, see PR.  I hope that means we can now use Some wherever we're expecting a non-null argument, and allow us to remove the null checks everywhere.  \nHardening code and checking for logic faults is somewhat of a specialty of mine, so if you're happy for me to proceed I'll start tidying up the null checks.  It will be a breaking change as the function parameters and/or return values will changed from naked Ts to SomeTs.  \nThoughts?\n. Re uninitialised\nYes I'm aware that Some could be uninitialised in that edge case (shame we can't stop it! ...yet C#7 maybe ...).  I was trying to take a pragmatic solution to it so Some could be used to protect against nulls in most cases, detecting as soon as possible that nulls/uninitialised values existed (hence the checks put into all properties).   But if you're going to drop it then it doesn't matter.\nRe it's unwise to do unnecessary allocations\nLittle confused there, structs don't do allocations.\nRe breaking changes\nI suspected that might be the case, hence why I queried it.  But there was a chance that the library wasn't set in stone yet, and changes could be made to harden it.  Worth asking anyway =)\n. It suggests a bunch of things, and then I selectively pick thru them so I don't mess up the style of your coding.  For instance you often use ternary expressions where a simpler binary expression could do, but I get that you've written it that way for readability, so left them alone.    ... for now ... =P\nBut there's many things it can do, and if you like what it's offering then you can, with a couple of clicks, change one, some or all occurrences.\nIt's rather powerful!  But be cautious, I have seen it generate incorrect code that still compiled.  That's rare though.  I manually review the commits just in case.  Still much faster than by hand!\nps It's free!  And doesn't seem to affect VS speed very noticeably unlike some popular commercial tools that do similar.\n. The changes to IsSome, IsNone and MatchUntyped were supporting hardening Some as much as possible, to fail fast if nulls or initialised snuck in.  \nHowever I understand the changes aren't what you're wanting for Some, so I'll drop them and rethink my approach.  Cheers\n. > Also, why does MatchUntyped allow nulls?\n\nBecause it's intrinsically unsafe. So as with MatchUnsafe the constraints\nare lifted.\n\nJust out of curiosity why do you consider it intrinsically unsafe?\nBy checking for nulls we'd make it safe, unless there's another angle\nyou're coming from?\n\nAlso ToString and GetHashCode are redundantly checking for nulls when\nSome, which should be impossible for OptionT\nAs with Some if you have an uninitialised Option then it could contain a\nnull.\n\nYep the value would be null when uninitialised, but IsSome will also be\nfalse.\nIf a null ever got into the value when IsSome was true it would be a bug.\nChecking for \"value != null\" just hides any potential bug.\nps. I also have some related changes to always call the appropriate\nCheckNullNone/SomeReturnValue routine (can't quite remember the name,\nplease excuse if wrong), instead of using the one that requires passing in\n\"None\" or \"Some\" continually.  Will drop a PR later.\npps.  Something is nagging me that there's at least one other Match routine\nthat has snuck thru without checks, will include in the PR if I find it.\nCheers!\n. Cheers, thanks for clarifying things!   I was responding to the email GH sends out, however it didn't show your amendments.  Sorry for rehashing something you'd already explained!\n- Will\n. Changed per feedback, though called Default \"Bottom\" instead for clarity, which removed need for Bottom() function.  Shame we can't use SomeT, even for internal methods, it made things very easy to add null protection.\n. And FYI, structs do not allocate memory from the heap, however their members might.  There are many articles on the web regarding this topic.  What this means is that whenever you pass a variable containing a struct, it copies the whole struct.  That's why MS has recommendations to keep struct size small.  Great for SomeT, OptionT, EitherT etc.\nThe assembly below shows that \"new\" is faster than \"static EitherT Default\" as the new only needs to zero the memory for the struct, whereas using Default needs to copy the Default values to the new struct.   You'll note that there's no memory allocation.\nvar x = new Either<string, int>();\n00007FFEC8AF4A1C 33 C0                xor         eax,eax  \n00007FFEC8AF4A1E 48 8D 55 28          lea         rdx,[rbp+28h]  \n00007FFEC8AF4A22 66 0F 57 C0          xorpd       xmm0,xmm0  \n00007FFEC8AF4A26 F3 0F 7F 02          movdqu      xmmword ptr [rdx],xmm0\nvar x = Either<string, int>.Bottom;\n00007FFEC8AE496C 48 B8 28 89 78 AA E5 00 00 00 mov         rax,0E5AA788928h  \n00007FFEC8AE4976 48 8B 00             mov         rax,qword ptr [rax]  \n00007FFEC8AE4979 48 83 C0 08          add         rax,8  \n00007FFEC8AE497D F3 0F 6F 00          movdqu      xmm0,xmmword ptr [rax]  \n00007FFEC8AE4981 F3 0F 7F 45 28       movdqu      xmmword ptr [rbp+28h],xmm0\nIn short, struct is great as it doesn't have the overheads of heap allocation, only takes up as much memory as the fields, can't be null, and perfect for immutables.  However it doesn't have a default ctor (yet - c#7 maybe), and as it always copies the struct everywhere it is inefficient for larger structs.  I think 16 bytes was MS' upper suggested limit.  Oh and doesn't support all the class semantics.  Still, it has it's uses!\n. Thanks for responding.  \nI'm sorry, it was NEVER meant to be taken as arguing.  I'd backed off re SomeT as the commits show, and then in good faith reworked the code and also helped finish off the Productable to Multiplicable rename.  I hope you can see it's the actions of someone who is trying to help.  Of course I'll question, and sometimes accidentally go in the wrong direction, and that's where I look forward to your constructive feedback.\nHowever \"Please stop arguing with me\" isn't constructive, it's making it personal.  I was just trying to understand what you were saying vs what the compiler does - there is definitely a disconnect.  But I'm humble enough to know I can't know everything, and I'm getting ready to eat my hat!\nI will have a good read.  Thanks for the links.\nEdit: I have read those previously, and again just now.  They don't contradict my understanding, nor the x86 code I supplied -- struct types are stack allocated unless they're part of another class.  They are not heap allocated by themselves.  Yes it's an implementation detail, but it's still a fact for today's compilers.\nHmm, I wonder if a struct with only an Int would look exactly the same as an Int by itself when initialised. (am tempted to test that just out of personal interest)\nLet's agree to disagree.  =)\n. Good spotting, have corrected and made use of nameof, much nicer!\nThanks for explaining where you're coming from, though you raised more points that you cleared!  (\"oh no\" I hear you say =P  .. though I can imagine other words lol )\nwithout a doubt do more allocations \nIf a closure was going to capture a variable then it was already going to have to allocate space via an anonymous object to hold it.  True?\nWrapping the value in a struct (eg SomeT/OptionT) wouldn't change the number of allocations, as they're just an inline wrapper for the contained value.  Also true?\nSo, um, where's the extra allocation?\nOr maybe I'm just having an extra thick day?\n(I'm the kind of person who can't help but ask when something appears not to add up, especially if others are making decisions based on potentially questionable info - it's what I do for a job, as I'm sure you do too.  But hey, I could be wrong!  But I've found it never hurts to question and explore things.  Well, almost never. =) )\nps I'm about to submit a PR to nuke SomeT from high orbit so I'm not tempted to use it in future... =)\n. No probs.  This wasn't about SomeT, I'd dropped it ages ago.  I was just wanting to understand where the extra allocations came from for structs in general.\nCheers =)\n. Sweet, I suspected it could have roots from other functional languages =)\n. Any thoughts before I close this?\n. If you're interested, I could put NullGuard just into OptionT and UnsafeOptionT, and see what you think from there?\n. The opt-in approach would let us get used to it before we risk turning it on across the lot.\nOr we rely on the unit tests and hit the big red button...\nI'll check and get back to you re project-wide opt-out.\n. Yes, I hear you there.  Just read their outstanding issues and am concerned that maybe it isn't ready for Roslyn yet, which we depend on.  Probably shelve it for now methinks, sorry to waste your time there!\n(I'll keep an eye on it, it wouldn't surprise me if a patch comes sometime in the coming weeks)\n. Evening! \nRe \"if left/right\" , done. =)\nRe \"isnull\" for ref types, done.  My bad, I had used IDE search and replace and it picked up more than I'd intended.  The only reason to do any of this was to help finish off the work you'd started with the generics.  Hopefully things make more sense now with my latest commits.\n- Will\n. Have searched in every way I can think of to clean up the rest of the docs as mentioned.  I hope I got it all.  I had only just started cleaning up the Fold documentation before I got side-tracked, it's still very inconsistent.  I'll have another go when this PR is out of the way.\n. Morning!  Is there anything I've missed holding up this PR?\n. ",
    "Profpatsch": "So everything that returns a Func<T> is also a Try<T>? Can I treat them as such? Or do I still somehow have to convert them? (Haskell guy, not much experience with C#\u2019s type system.)\nI\u2019ve got a function that should only catch two types of exception, is it possible to achieve that, too? As I read in the code, Try basically does a catch (Exception e); how would I narrow that down?\n. I wonder why there is no implicit conversion from Func<(),T> to Try<T>; or is there?\n. You are right, that\u2019s how list expressions work in Haskell. https://www.haskell.org/onlinereport/exps.html#sect3.11\n. Does it perform, though? It builds a new Lst for each element and then joins them back together. I\u2019m sure ghc can optimize this, but can C#?\nUpdate: Ah, @louthy, didn\u2019t see your answer. Yes, imperatively updating the list is going to perform better.\n. That\u2019s wonderful, thanks!\nIf you wanted to take it further you\u2019d introduce Bifunctors as in https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html, that would generalize the mapping over two arguments and reduce redundant functions a bit (if it\u2019s possible with the type system). Of course\u2014as Edward Kmett constantly demonstrates\u2014this game can be played ad infintum.\n. Haha, that\u2019s super great!\n\nif you've come from a Haskell background why didn't you go straight to F# rather than C#?\n\nI\u2019m fixing bugs and improving a small C# codebase and originally just wanted a Maybe and an Either type because I loathe the null- and exception-passing style. Maybe it escalated a little \u2026\n. Ah, I see. I can only describe myself as \u201caspiring Haskeller\u201d, since I\u2019m still missing a lot of coding experience.\nBut understanding the concepts goes a long way, too, as I noticed (currently working in Scala for my bachelor\u2019s, and C# for work and using the stuff everywhere).\n. Oh, I found another guide for Try in Scala: http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html\nHow compatible is that with this Try type?\n. > Use LINQ for this:\nThere is a monadic notation in Scala, too, something like:\nscala\nfor {\n  a <- monadicValue1\n  b <- mval2\n} yield { a + b }\nThen there\u2019s LINQ and do-notation in Haskell. I still like Haskell\u2019s version the most, though.\n. > It's certainly not quite as pretty, but required for safe clean-up.\nI know this as with pattern from Python. I use http://jsuereth.com/scala-arm/ for my current Scala project, that does the same. In Haskell normally these things are wrapped in a custom Monad in my experience, but probably a similar pattern exists.\n. I think the with pattern is absolutely fine.\n. > Map and Bind are lazy for lists\nNormally I would expect \u201ctrue\u201c laziness to evaluate each thunk only once and then use the cached result for each consecutive call; of course it shouldn\u2019t matter when there is referential transparency, but side-effects kind of destroy that. hm.\nSo .ToList() forces the LINQ thunk to be evaluated?\n. Thanks!\n. This seems like a sensible addition, however:\nThe default behavior is still pretty unintuitive, in that it introduces bugs that are very hard to hunt down when one doesn\u2019t know about this pitfall.\nI wonder if it would be possible to enable this memoization by default?\nIf it is not, I\u2019m at a loss. It should be very well documented at least, but since this concerns pretty much every function in this library, it would fit into an FAQ best probably.\n. > My concern would be that it could break existing code and it goes against what most people understand re: IEnumerable\nIn that case always go with the Principle of Least Surprise\n\nI think it's quite widely understood (because LINQ is used for SQL query providers mostly) that calling .ToList() or .ToArray() causes evaluation;\n\nThen it\u2019s probably that I\u2019m not well-versed enough in C# (I mostly do Haskell and C# only for a client project).\n. ",
    "fazouane-marouane": "You can create a Try<T> from any Func<T> using LanguageExt.Prelude.Try.\nExample:\ncsharp\nusing LanguageExt;\n//...\nvar x = 0;\nvar f =Try(() => 1 / x);\nf.Match(\n    Succ: v => Console.WriteLine(\"Value: \"+v),\n    Fail: e => Console.WriteLine(\"Bang! \" + e)\n);\n//...\n(irrelevant to the issue: @louthy Thanks for your awesome work! I've just discovered LanguageExt an hour ago. This project implements all the most needed/helpful paradigms seen in other systems & languages. Thanks for bringing in this into C#.)\n. Hi,\nSo I just happen to pass by this awesome project and saw your issue.\nIt's actually quite simple to solve. You can first transform your IEnumerable<Either<L,R>> into a IEnumerable<IEnumerable<L>> then join the bits to get a single IEnumerable<L>\nHere are two possible working implementations\n``` csharp\n    public static class EitherExtensions\n    {\n    private static IEnumerable<L> Lefts<L, R>(this IEnumerable<Either<L, R>> eis)\n    {\n        return eis\n            .Map(ei => ei.Match(Left: l => List(l), Right: r => LanguageExt.List.empty<L>())) // map Left l to [l] and Right _ to []\n            .Fold(LanguageExt.List.empty<L>(), (acc, l) => acc.AddRange(l)); // join them\n    }\n\n    private static IEnumerable<L> Lefts2<L, R>(this IEnumerable<Either<L, R>> eis)\n    {\n        return eis\n            .Map(ei => ei.Match(Left: l => Enumerable.Repeat(l,1), Right: r => Enumerable.Empty<L>())) // map Left l to [l] and Right _ to []\n            .Aggregate((acc, l) => acc.Concat(l)); // join them\n    }\n}\n\n```\n. ",
    "feugen24": "Agreed,\nI think that in the end using Action with Match(Some:, None:) and option.Some().None() should look the same:\n```\n        Action actionint = v => v = v * 2;\n        Action action = () => { };\n    Option<int> optional1 = Prelude.Some(123);\n    optional1\n       .Some(actionint)\n       .None(action);\n\n    optional1.Match(\n        Some: actionint,\n        None: action\n        );\n\n```\n. I asked because i saw dapper already ported, but i'll actually try it on rc2 since i don't think i'll have the time until then.\nGood resource:\nhttp://docs.asp.net/en/latest/dnx/projects.html\nAlso it might help to have vs2015 update 1, not sure but tooling might be improved.\nhttp://blogs.msdn.com/b/webdev/archive/2015/11/18/announcing-asp-net-5-release-candidate-1.aspx\nAs for the process I assume you need to create a new project, add dependencies, copy files and build.\nAnd transition should probably be done after the dependencies themselves are migrated(i just thought of this)\nhttps://github.com/Reactive-Extensions/Rx.NET/issues/148\nhttps://github.com/Reactive-Extensions/Rx.NET/pull/151\n. I did something like:\npublic static class OptExtensions\n    {\n        public static async Task IfSomeAsync<T>(this Option<T> opt, Func<T, Task> some)\n        {\n            await opt\n                .Some(some)\n                .None(Task.CompletedTask);\n        }\n    }\n//and called it like:\n await opt.IfSomeAsync(async x => await DoWork());\nDoes this look ok?\nAlso, are the following equivalent?\nawait opt.MatchAsync(async i => await DoWorkInt(), () => Task.FromResult(0));\n//and\n await opt\n                .Some(async i => await DoWorkInt())\n                .None(() => Task.FromResult(0));\nI'm assuming if some is executed, opt internal state will return Some ' Task' result from None() call.. Not sure what to say about OptionAsync, typically developers are used with .CallThisAsync() like most .net libraries, so .IfSomeAsync looks better than .ToAsync().IfSome(). Also I thinks OptionAsync implementation has some issues.\nI wrote some tests:\n```\nConsole.WriteLine(\"OptionAsync\");\n            OptionAsync optAsync = Some(4).ToAsync();\n            var tskOptionAsync =  optAsync.IfSome(async (i) => \n            {\n                var x = DoWork();\n                Tasks.Add(x);//Tasks is a static list of tasks.\n                Console.WriteLine($\"Inner id {x.Id}\");\n                await x;\n            });\n            Console.WriteLine($\"Outer id {tskOptionAsync.Id}\");\n            Tasks.Add(tskOptionAsync);\n            await tskOptionAsync;\n        WriteTaskStatuses();\n\n        Console.WriteLine();\n        Console.WriteLine(\"Option.IfSomeAsync\");\n\n        Tasks.Clear();\n        Option<int> opt = 4;\n\n        var tskIfSomeAsync = opt.IfSomeAsync(async (i) =>\n        {\n            var x = DoWork();\n            Tasks.Add(x);\n            Console.WriteLine($\"Inner id {x.Id}\");\n            await x;\n        });\n        Console.WriteLine($\"Outer id {tskIfSomeAsync.Id}\");\n        Tasks.Add(tskIfSomeAsync);\n        await tskIfSomeAsync;\n        WriteTaskStatuses();\n\n```\nand the output:\n```\nOptionAsync\nOuter id 2\nInner id 7\nTasks:2 is RanToCompletion\nTasks:7 is WaitingForActivation\nOption.IfSomeAsync\nInner id 12\nOuter id 16\nTasks:12 is RanToCompletion\nTasks:16 is RanToCompletion\n. :)..i missed that. It works but it looks like the implementation has issues:\n// Func f\nTask.Run(() => { f(a); return unit; })\n```\nHere it looks like instead of 'await'-ing for the task you allocate/block a threadpool thread that waits, actually bypassing the utility of async.\nSee here\n. Thanks for the changes, I will use latest once it's out of beta.. @louthy It looks great. Also maybe it would help if the link would sort by 'thumbs up' by default, and you could be explicit in the docs that people can vote on these documentation issues, something like \"Remember to vote on helpful items\". ",
    "la-yumba": "Hi Paul,\nyes, I agree with your comments... this first commit was mostly to get some\ninitial feedback and see if you were interested!\nI can make the last 2 changes you requested right away, but the first 2\nwill be piece-meal...\nmaybe you could create a branch on your repo for this work, that we can\nboth contribute to, and then merge to your master branch when you think\nit's ready?\n. Hi Paul,\nI'm in the process of writing a book on FP in C#; the first couple of\nchapters are already available on MEAP.\nI'd like to send you a complimentary copy (for this, I would need your\nemail) and would welcome your involvement in the review process, if you can\nspare some time.\nPlease email me enrico.buonanno gmail\nBest,\nEnrico Buonanno\nemail: enrico.buonanno@gmail.com\nskype ID: enrico.buonanno\nTel: +34 632 333 865\nOn Tue, Dec 8, 2015 at 12:23 AM, Paul Louth notifications@github.com\nwrote:\n\nMerged #71 https://github.com/louthy/language-ext/pull/71.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/pull/71#event-485038710.\n. \n",
    "orthoxerox": "To quote Eric:\n\nIn particular, the storage locations of instances of reference types are always treated as though they are long-lived, even if they are provably short-lived. Therefore they always go on the heap.\n\nOf course, he mentions that this is generally an irrelevant implementation detail, since even local instances of value types go on the heap when they are closed over or are in an iterator block.\nThe most important distinction is their semantics. Current tuples have value type semantics despite being implemented as classes: they are immutable, so copying by value or by reference is semantically indistinguishable, and they compare their contents when testing for equality.\nI guess the difference will only add up when you will aggressively use lots of short-lived tuples. Perhaps it might be wise to wait for that ValueTuple type.\n. It looks like it's based on Claudio Russo's and Matt Windsor's concepts, awesome stuff. Have you managed to make query expressions work with generic monads?\n. int.GetHashCode() returns itself.. Associated types will allow compile-time type-safe emulation of HKTs and therefore concepts like monoids and monads, if I'm reading the proposal right.. I think it's the same approach. The document says they still haven't finalized the names. After all, that's one of the hardest problems in computer science. \ud83d\ude2c . ",
    "ghost": "Thanks for the quick response.\nI got the latest but had to download visual studio 2015 community (and run in virtual box) to compile the project as vs2013 nor xamarin studio (under mac mono) will compile the solution successfully.\nI tested RedisPublishSample and RedisStateSample and they both worked (windows / mac mono) as exoected. I could see numbers being printed out in console / terminal.\nI suggest adding a test so that in future this particular scenario is covered.\nI however didn't understand what you meant by \"That means the demo project doesn't do what it says any more unfortunately; because if the process is local and you subscribe to it locally, then the messages you receive won't have come from Redis.\" I haven't really delved into the source yet maybe I don't have the full picture.\nMaybe it would be a good idea to document and explain what each of the ProcessFlags values mean and what the expected behaviour would be. But I personally don't like enum being used as a switch in this way. It's not natural. But sorry I don't have any good ideas.\n. Thanks for your reply. It's much more clear now for me. And yes I meant \"flags\", not switch, sorry.\nI noticed another issue, it's possibly very similar to above mentioned but it's on the receiving end.\nIf I run RedisPublishSample and then I manually publish via redis-cli like so (\"PUBLISH\" \"/redis-test/user/redis-pubsub-random-test-pubsub\" \"521\") in terminal the subscriber didn't respond (i.e. nothing was printed out).\nIt's the same if I \"publish\" via below c# code, which is equivalent to the PUBLISH command above.\nvar pid = new ProcessId(\"/redis-test/user/redis-pubsub-random-test\");\npid.Tell(DateTime.Now.Millisecond);\nI also tried below, both on a separate AppDomain without success. Am I doing something wrong?\nIn the main app I register a public name using pid.Register<int>(); (pid is the \"redis-pubsub-random-test\" process) then in another app I do\nvar pid = Process.find(new ProcessName(\"redis-pubsub-random-test\"));\nProcess.tell(a, DateTime.Now.Millisecond);\n. Ok, maybe I had the wrong assumption. I was hoping or expecting that if Ispawn<Random, int>(\"redis-pubsub-random-test\" multiple processed with the same process name _on different AppDomain_, they could \"talk to each other\" but after sometime I realised the spawned processes on different AppDomain actual has different guid, hence they won't \"talk to each other\" via redis.\nI guess I was hoping to be able to have a setup like this:\nAppDomain 1\nvad pid = \"abc\";\npid.Subscribe(Console.WriteLine);\nAppDomain 2\nvad pid = \"abc\";\npid.Subscribe(Console.WriteLine);\nif I \"publish\" from redis, I should see one write line in each console (AppDomain), and if I publish from either AppDomain 1 or AppDomain 2, I should see again, one write line in each console. So it's like a distributed actors sharing the same Inbox. I guess this is the correct way to put it. Maybe I'm mixed up between event / message driven with actor models. :)\nMaybe above is not what Process does.\nI haven't tested the latest version as I don't have access to windows until tomorrow.\n. Thanks for your response.\n\nThe example you give above isn't valid, and I'm not even sure what it is you're trying to do? I'd advise you to stop manually publishing in Redis and use the system as designed. I can't support your ad-hoc direct access to Redis.\n\nI was trying to test. And no you don't need to support this scenario.\nI see, you are using var hello = Process.Top[\"redis-test-app-dom-1\"][\"user\"][\"hello\"];. And I was using Process.find(\"hello\") or Process.find(\"redis-pubsub-random-test\") in AppDomain 2 to find the ProcessId from AppDomain 1. But in order to find Process from AppDomain 1, in AppDomain 2 I must know the name used in AppDomain 1. So there's no way to do something like this in AppDomain 2 var hello = Process.Top[\"user\"][\"hello\"];.\nBy the way, where's Process.Top?\n. AppDomain 1\n```\n    class MainClass\n    {\n        const string ID = \"Node A\";\n    public static void Main(string[] args)\n    {\n        RedisCluster.register();\n        Cluster.connect(\"redis\", \"redis-test-1\", \"localhost\", \"0\");\n\n        var pid = Process.spawn<string>(\"hello\", msg => Process.publish(msg));\n        pid.Register<string>(\"hello-registered\", ProcessFlags.PersistAll);\n        pid.Subscribe<string>(Console.WriteLine);\n\n        while (true)\n        {\n            pid.Tell(string.Format(\"{0} - {1}\", ID, DateTime.Now.Millisecond));\n            Console.Read();\n        }\n    }\n}\n\n```\nAppDomain 2\n```\n    class MainClass\n    {\n        const string ID = \"Node B\";\n    public static void Main(string[] args)\n    {\n        RedisCluster.register();\n        Cluster.connect(\"redis\", \"redis-test-2\", \"localhost\", \"0\");\n\n        var pid = Process.find(\"hello-registered\");\n\n        while (true)\n        {\n            Process.tell(pid, string.Format(\"{0} - {1}\", ID, DateTime.Now.Millisecond));\n            Console.WriteLine(\"{0} told\", ID);\n            Console.Read();\n        }\n    }\n\n}\n\n```\nI think it's working now. AppDomain 2 can \"talk\" to actor in AppDomain 1 via Redis.\nAnd if actor in AppDomain 1 is not reacting, messages are persisted in Redis and will be processed when actor resumes.\nThanks!!!\n. This question is unrelated to SonarLint rules. I'm not sure about the adoption of this package, but I think it would be increased if it built on top of already existing immutable enumerations, and added missing functionality through extension methods. \n. ",
    "IDisposable": ":shipit: \n. 100% this. \n. Would love to see some unit-test coverage for these.\n. More used to seeing number and dimension... http://www.mne.psu.edu/cimbala/Learning/General/units.htm. Why are some Add and some Append for these?. The same problem occurs with Kelvin, of course, because Kelvin is just an offset version of Celsius. I get the relative idea, but it's still wrong. \nBy not removing the scale (+/-32 in the case of Fahrenheit to/from Celsius), you are scaling (* or / by 1.8) too big (or small) a number... let's try an identity test...\n\nWhat's 10C+ 10C? Everyone can agree with 10 + 10 = 20C, right?\nWhat's 10C in F? Everyone can agree with (10 * 1.8) + 32 = 50F\nSo what's 10C + 50F? Current code says it's 10 + (50 * 5.0 / 9.0) = 10 + 27.778 = 37.778C which is obvious not what would be expected.\nWith submitted patch it would be 10 + ((50 - 32) * 5.0 / 9.0) = 10 + 10 = 20C, which matches the expectation of 10C + 10C above.. Perfect, thanks for noting that... I was code reviewing from my phone and\ndidn't dive deep enough, sorry.\n\nOn Mon, Oct 8, 2018 at 12:31 PM Avrohom Yisroel Silver (Mr Yossu) \nnotifications@github.com wrote:\n\nI agree with all of @IDisposable https://github.com/IDisposable 's\ncomments here.\nSo do I, I just haven't had time to do the changes yet!\nMy only comment would be that I can't use st as a shorthand for short\ntons, as I already used that for stones. How about I use mton and ston? Not\nquite as short, but no conflict then.\nThanks\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/492#issuecomment-427917496,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AA1WS4qTPRiqSJYcQda96ZSIc3aq9emdks5ui4v1gaJpZM4XHCsu\n.\n\n\n-- \nMarc Brooks\nhttp://about.me/IDisposable\nhttp://twitter.com/IDisposable\n. The error you are seeing is due to the fact that SINCE you forked, you've\nfallen behind the branch that you are basing the PR on... so you need to\nfirst get caught up and then reapply your changes and then do another PR or\npush to the same branch as before... I suggest reading through this post\nfor some information.\nSimple: https://gist.github.com/CristinaSolana/1885435\nSlightly more detail:\nhttps://garygregory.wordpress.com/2016/11/10/how-to-catch-up-my-git-fork-to-master/\nReally detailed: https://www.xanthir.com/b4hf0\nOn Wed, Oct 17, 2018 at 8:14 AM Avrohom Yisroel Silver (Mr Yossu) \nnotifications@github.com wrote:\n\n@bender2k14 https://github.com/bender2k14 Tyson, I'm looking at GitHub\nwhen I made that comment. I assumed I would have to use GitHub to pull the\nlatest code form the master into my repo, then pull the code into Visual\nStudio from my repo and go from there. However, I can't work out how to get\nthe latest changes from the master repo into mine.\nSorry if I wasn't clear. Thanks again for any help.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/492#issuecomment-430623021,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AA1WS_vjj5LsvT0kCgHl8pLlx4vANJPTks5uly0ugaJpZM4XHCsu\n.\n\n\n-- \nMarc Brooks\nhttp://about.me/IDisposable\nhttp://twitter.com/IDisposable\n. shouldn't this be return rhsRes; \n. shouldn't this be return rhsRes;\n. Perhaps a throw would be more reasonable? Seems arbitrary. Maybe even returning a None state?\n. Perhaps a throw would be more reasonable? Seems arbitrary.  Maybe even returning a None state?\n. return rhsRes;\n. return rhsRes;\n. return rhsRes;\n. return rhsRes;\n. We shouldn't check in commented-out code... if it's dead, that's what GIT is for...\n. Could we be more consistent with Where here? Seems that a and func are really source and predicate like line 16.\n. If we don't know how to do this now, record the hoped-for interface elsewhere, but commented-out code is bad.\n. Yield is one choice, but might confer the wrong idea. Perhaps Produce?. Technically, Yield is also a noun (says the guy doing tons of analysis on corn yields). For a less dangerous noun, perhaps Outcome, Issue, Product or Harvest (okay, maybe a bit corny). This is inconsistent with the AbsTemp implementation, we should be doing lhs.Kelvin > rhs.Kelvin to make sure any precision loss is identical. Same with the other operator methods mixing ScaleTemp and AbsTemp . Use .Kelvin. Use .Kelvin. Use .Kelvin. If Value is the number of Kilograms (as indicated by the ToString body and the fact that Kilograms is a pass-through of Value), the number of grams should be Value * 1000 instead? (e.g. there are 1000 grams in a kilogram).. Likewise, since Value is the number of Kilograms, the number of metric tonnes should be Value / 1000 instead? (e.g. there are 1000 kilograms in a metric tonne).\nPossibly should call this MetricTonnes?. Should probably be 0.000984207 for better accuracy. Also should call this ImperialTons as that is the correct name for UK tonnage.. Should probably be 0.00110231 for better accuracy. Also should call this ShortTons as that's the correct name for a US tonnage.. Safer when dealing with int values to always make the constant 1000.0 to not lose values on integer overflow that a double could have inexactly represented. . alias for mt? e.g. metric tonne?. alias st and shortTon?. alias it and imperialTon?. Is this safe if we're mid-growing? Will the list.Count be partially updated before we're finished and thus this could return uninitialized array element?  In other words, do we need to wrap in a lock(list)?. Do we want to move the lock(list) down here so we unlock between each iteration of .Add in case the incoming iterator is really long and you've asked for a really high index?. Since this is common with the earlier code in the get, maybe we should check and grow, then fall through?. Comment:\nSo is Strict the name of the early memoization? . Is it possible for ReferenceEquals(this.seq, rhs.seq) to be true (e.g. could we ever have two different Seq<> that have the same inner seq)?  If so, would that be worth inserting between lines 812 and 813?\n. Why is this ternary here? Are we just using this to make sure that exceptions or side-effect that might be happen deep in Enumerable.SequenceEqual get a chance?. ",
    "IanYates": "My understanding is that SignalR won't be a part of the original ASP.Net v5 release.  I watch the SignalR v2.x repository on GitHub and, for the first time in what feels like a few months, there's finally some activity there from MS folk.  So I guess they're getting back to regular ASP.Net maintenance and will then do SignalR v3 after the ASP.Net v5 release.  It has its own repo but, IIRC, it's empty.\n. It's listed as \"future\" here https://github.com/aspnet/Home/wiki/Roadmap#future-work - Q3 calendar year 2016.  So I guess ~10 months away if all goes well.\n. ",
    "plouh": "How about ifdeffng out the Rx dependencies from UWP/.NetCore build for now?  As far as I know, they are not very crucial part of the library compared to the overall usefulness, so until Rx people has gotten their libraries compiling, those could be removed.\nIt's only a couple of MatchAsync end delay -functions that we can easily live without, given that we wouldn't have Rx observables in .NetCore anyway.\n. ",
    "BrainCrumbz": "@louthy is that because Rx have been ported somehow to CoreCLR? I was also checking Rx.NET issue 148 and could not figure out that.\nThanks\n. Sure\n. ... I guess you meant Brain, if that was my team first name :smile: \n. Doh! Thanks for pointing to the right bits. \nWould you consider a doc PR mentioning this somewhere in readme?\nEDIT Although, an async addition returning Task<Option<>> would not be bad.... Not sure wether it's the same issue or what, so just posting here another test we did. We turned code gist to use async/await:\n```c#\nstatic async Task ValidateAsync()\n{\n    Option textOpt = await Task.Run(() => (Option)None);\nUnit doAction = textOpt.BiIter(\n    None: () =>\n        Console.WriteLine(\"Do Action None\"),\n    Some: text =>\n        Console.WriteLine($\"Do Action Some: '{text ?? \"<null>\"}'\"));\n\nreturn doAction;\n\n}\n```\nWith such code we incur into a ValueIsNoneException with following stacktrace:\nat LanguageExt.OptionData`1.get_Value()\nat LanguageExt.Option`1.get_Value()\nat LanguageExt.ClassInstances.MOption`1.BiFold[S](Option`1 ma, S state, Func`3 fa, Func`3 fb)\nat LanguageExt.TypeClass.biFold[FOLD,F,A,B,S](F foldable, S state, Func`3 fa, Func`3 fb)\nat LanguageExt.TypeClass.biIter[FOLD,F,A,B](F foldable, Action`1 fa, Action`1 fb)\nat LanguageExt.Option`1.BiIter(Action`1 Some, Action None)\nat LangExtOptBiIterFail.Program.<ValidateAsync>d__2.MoveNext() in [...]\\Program.cs:line 30\nThere's a similar repro project here for such scenario as well.\nWe can create a separate issue if needed. Thanks. Thanks for feedback. At the moment we're on .NET Core 1.1.4, no netstandard 2.0, thus we're stuck at language-ext 2.1.18.\nTrying to trace back commits related to package versions, this seems to be the closest comparison. Skimming through changes, there are some cases where an IsNone was turned into an IsSome, in particular those within MOption.cs BiFold and BiFoldBack. So it might as well be that there was a fix. But as said, right now we're not switching framework version.\nPlease, feel free to close this issue if you think it's solved.\nCheers!. ",
    "masaeedu": "@louthy Haven't dug into the codebase, but what are you using SignalR for?\n. @louthy Given that the actor system stuff is in a different project, couldn't LanguageExt.Core and the associated nuget package be transitioned to .NET Core now?\n. @louthy @IDisposable Yeah, working on it. There wasn't any unit tests for the existing Compose/BackCompose extension methods nor the Prelude.compose static overloads; I'll add coverage for the Compose and BackCompose extension methods, but you probably want to use codegen for methods with lots of overloads like Prelude.compose.\n. @louthy Done. The CI output looks kind of weird, it's spewing lots of HTML, but I ran the tests locally and they compile & pass.\n. @louthy ping\n. @louthy I opened an issue in #164, but fair enough. Usually if there are conflicts you can ask the person making the PR to rebase once you've merged in whatever you're prioritizing.\n. @louthy Btw, one of the reasons for making this change is so all files aren't listed in a csproj/fsproj file, causing merge headaches. This allows project structure changes and code changes to be made orthogonally. Unless you're moving/adding new projects or modifying dependencies, merging in this series of changes should not cause conflicts. Is the branch you're working on https://github.com/louthy/language-ext/tree/type-classes?\n. @louthy Assuming you're talking about the type-classes branch, I've gone over all the changes with a mergetool and they're perfectly mergeable. I don't think you're quite grokking what the change is doing. Nearly all of your changes in the csproj files are modifying the list of files to be compiled. This list no longer needs to exist; you can just delete the csproj file and continue working. The project.json format does not need to maintain a list of all files in the project.\nIf you don't want to think about this right now, would you instead be willing to take a mergeable PR to the type-classes branch?\n. > Just a quick glance at your changes and they appear to be very dangerous, deleting all the csproj files, which is insane \nThe project.json format was intended as a replacement for csproj, so I don't know where you're getting that deleting csproj is \"insane\". Having both project.json and csproj is redundant, and it leads to configuration drift (this has already started happening with your dependencies). After applying the changes I made to master, the solution compiles in both Visual Studio and from the command line, and all unit tests not requiring a redis instance pass against netcoreapp1.0 and net4.5 targets. You're welcome to clone https://github.com/masaeedu/language-ext/tree/netcoreunittests to see for yourself.\nDon't really know what else to tell you here, maybe google the docs on project.json. A few months from now you could be stuck consolidating your project.json and csproj files and migrating to the new msbuild format by hand, which is going to be a pain in the ass.\n\n(The non-Core sln exists because compiling the .NET Core solution is so slow)\n\nYes, this is a problem lots of people have complained about. They're tracking it in dotnet/cli#2515, but this is only going to improve after they switch back to msbuild in 2017.\n\nThis is something I really don't want to be thinking about at the moment. My brain is not in this space as I've got a 1000 plates spinning with the new version.\n\nHey, its your library, do as you will.\n. > So you knew about it, and decided to cripple my build process anyway? Thanks\nJesus. On my laptop, it takes ~50 seconds to build LanguageExt.Core (which is the bottleneck) for a single target using dotnet build. It takes ~30 seconds to build it using msbuild. This doesn't seem to me like an earth-shattering performance regression, but YMMV. Typical build times for the projects I work on are 20-30 seconds, so in general I have used project.json wherever possible.\nBut you caught me. My real intention was to \"insanely\" \"cripple\" your build process, as I twirled my moustache and cackled maniacally.\n. I'm fine with having an Action return value, I was just trying to be in line with the library's goal of eliminating void. Note that we can't have it both ways; two overloads can't differ only in return type. Keeping that in mind, should we go ahead and change:\npublic static Func<T1, Unit> Compose<T1, T2>(this Action<T2> b, Func<T1, T2> a)\nto:\npublic static Action<T1> Compose<T1, T2>(this Action<T2> b, Func<T1, T2> a)\n?\n. Also, you don't need a separate overload for an argument of type this Func<T2, Unit>, that's already covered by the existing single argument function composition overloads.\n. ",
    "DamianReeves": "Any reason why .NET core support targets netframework1.6 instead of 1.3 for example?\n. Thanks for the quick turnaround on this.\n. I see what you mean. Great stuff. Thanks for the awesome library.\n. ",
    "blairconrad": "Thank  you!\nAnd I'm not sure what that weird \"f\" comment is above. I think I mashed the keyboard when saving the change\u2026\nSorry.\n. ",
    "aloisdg": "you are welcome :)\n. ",
    "ncthbrt": "Thanks Paul. Good to hear about its depreciation.\nOn 20 Mar 2016 17:36, \"Paul Louth\" notifications@github.com wrote:\n\n@ncthbrt https://github.com/ncthbrt - Hi Nick, I had actually removed\nthe Serialization attribute when updating the project to support DNX. It\nseems the Serialization attribute is on its way out, and isn't supported in\nDNX. I guess most serialisation is done with Json.NET or similar these days.\nAnyway, I've now restored it for non-DNX builds. Please grab the latest\nversion from nu-get: 1.7.29\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/issues/80#issuecomment-198950893\n. Sorry to hear about your issues. \nI've personally been having trouble with visual studio, I've been lately using VSCode's C# extension, because it feels somewhat more stable, but all in all, it hasn't been a smooth ride. :confused: \n. Awesome. Thank you.\nOn 23 Jul 2016 22:16, \"Paul Louth\" notifications@github.com wrote:\n@ncthbrt https://github.com/ncthbrt Hi Nick, version 1.9.0 is now\ndeployed to nu-get with full .NET Core support (and referencing\nSystem.Reactive 3.0.0)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/110#issuecomment-234737914,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AISSWTVmJwr1X158byquJR1KnYuz1h6Jks5qYnacgaJpZM4JPJmi\n.\n. Note: Failing build appears unrelated to additions on this branch. I Will make the requested changes in the next few days. Got bogged down in some work as well. Hey. Sorry it is taking such a while. Still planning to make the changes. Just got some pretty crushing deadlines at work at the moment. Would really like this in. Trampolining would enable recursive actors systems in C#. . Note: build failure appears independent of this pull request. This is amazing :)\nFunnily enough. The class was originally called ConditionalContinuation. \nYour implementation does indeed seem more composable. \nThanks for the detailed breakdown of the changes. I belive this line might be the culprit: Lst.cs, line#658: index - node.Left.Count - 1\nI haven't looked at the underlying implementation in detail however, but I'm guessing this might actually be \ncs\nindex - (node.Left.Count - 1)\n. Thanks for the fix\n\nOn Wed, Feb 8, 2017 at 4:19 AM, Paul Louth notifications@github.com wrote:\n\nClosed #180 https://github.com/louthy/language-ext/issues/180.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/180#event-953161007, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AISSWfjkDddb8KU1NK2X61T0Q-sMOnn7ks5raSYrgaJpZM4LORe_\n.\n. Which version are you working off: v1.9.x or v2?. Will do. I wanted to make it clear that this is the base of the recursion. But I'm happy to change it if you feel it is more consistent. I quite like Yield, but it might be confused with the yield keyword.. \n",
    "cocogorilla": "I slightly modified the tests and had trouble getting them to work.  I\nthought for certain the second version would work... yet it did not appear\nto.\n```\n    [Fact]\n    public void UrlTest()\n    {\n        var results = new List();\n        var lines = getURLContent(\"http://www.google.com\").IterT(\n            (x) => results.Add(x));\n        Assert.NotEmpty(results);\n    }\n[Fact]\npublic async void UrlTestAsync()\n{\n    var results = new List<string>();\n    var lines = await getURLContent(\"http://www.google.com\");\n    lines.Iter(\n        (x) => results.Add(x));\n    Assert.NotEmpty(results);\n}\n\n```\nbtw, awesome work, way above and beyond what I anticipated, and in short\norder as well.\nThanks,\n-Ethan Nelson\nOn Thu, Mar 31, 2016 at 8:34 AM Paul Louth notifications@github.com wrote:\n\n@cocogorilla https://github.com/cocogorilla I have added Task\nextension methods to LanguageExt.Core that turn it into a monad. And have\nadded the standard set of functions that work with the higher-kinded type\nsystem, so you get to work with Option> and Task> as\nthough they were a single value.\nHere's a simple example with Task and Task>. Note that\nAction3() returns an Option, so it then needs to be unwrapped in the\nselect. The result of the computation is Task>.\n```\n    public void TaskLINQTest2()\n    {\n        var computation = from x in Action1(0)\n                          from y in Action2(x)\n                          from opt in Action3(y)\n                          select from z in opt\n                                 select x + y + z;\n    Assert.True(computation.Result == 10);\n}\n\npublic async Task<int> Action1(int x)\n{\n    await Task.Delay(100);\n    return x + 1;\n}\n\npublic async Task<int> Action2(int x)\n{\n    await Task.Delay(200);\n    return x + 2;\n}\n\npublic async Task<Option<int>> Action3(int x)\n{\n    await Task.Delay(300);\n    return x + 3;\n}\n\n```\nYou mentioned the TryMonadTests, unfortunately that code didn't work, and\nhas been fixed for both Try and Task. This is the example with\nTask:\n```\n    public Task> getURLContent(string url) =>\n        from u in parseUri(url)\n        from conn in openConnection(u)\n        from result in use(\n            getInputStream(conn),\n            stream => use(getSource(stream), getLines)\n            )\n        select result;\n[Fact]\npublic void UrlTest()\n{\n    getURLContent(\"http://www.google.com\").IterT(x => Console.WriteLine(x));\n}\n\n```\nNotice how getURLContent returns Task>, but I'm able\nto iterate the wrapped list.\nYou need to include LanguageExt.Trans if you want to use the transformer\nfunctions (the functions that work on wrapped monads and are appended with\nthe T).\nThe available Task functions are:\nTask extension Task> transformer M> transformer\nSelect n/a n/a\nSelectMany n/a n/a\nWhere n/a n/a\nMap MapT MapT\nFilter FilterT FilterT\nBind BindT BindT\nFold FoldT FoldT\nIter IterT IterT\nSum SumT SumT\nCount CountT CountT\nExists ExistsT ExistsT\nForAll ForAllT ForAllT\nPrelude Task> transformer M> transformer\nmap mapT mapT\nfilter filterT filterT\nbind bindT bindT\nfold foldT foldT\niter iterT iterT\nsum sumT sumT\ncount countT countT\nexists existsT existsT\nforall forallT forallT\nThe latest is on nu-get now (1.7.37)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/issues/81#issuecomment-203988688\n. Thanks. Post fact, I did sort of figure that out with a little\ntroubleshooting. Thanks again.\nOn Fri, Apr 1, 2016 at 6:10 AM Paul Louth notifications@github.com wrote:\n@cocogorilla https://github.com/cocogorilla Hi Ethan, just to follow up\non this (I was replying from my phone last night, so couldn't give much\ninfo). The example in the unit tests file was primarily a demo from a\nprevious conversation comparing Scala Try to lang-ext Try (see here)[#33\nhttps://github.com/louthy/language-ext/issues/33]\nFor a fully working example, that works better in .NET world you could try\nthis. It fully disposes the WebClient after use and also demos MapT, SumT\nand IterT.\n```\n    Task parseUri(string uri) =>\n        new Uri(uri).AsTask();\nTask<WebClient> getClient() =>\n    Task.FromResult(new WebClient());\n\nTask<string> getContent(Uri uri, WebClient client) =>\n    client.DownloadStringTaskAsync(uri);\n\nTask<Lst<string>> getLines(string text) =>\n    Task.FromResult(text.Split('\\n').Freeze());\n\nTask<Lst<string>> getURLContent(string uri) =>\n    from address in parseUri(uri)\n    from result  in use(\n        getClient(),\n        client => from content in getContent(address, client)\n                  from lines   in getLines(content)\n                  select lines)\n    select result;\n\npublic void UrlTest()\n{\n    // Iterates all lines of content\n    getURLContent(\"http://www.google.com\").IterT(x => Console.WriteLine(x));\n\n    // Counts the number of lines\n    int numberOfLines = getURLContent(\"http://www.google.com\").CountT();\n\n    // Maps the lines to line-lengths, then sums them\n    int totalSize = getURLContent(\"http://www.google.com\")\n                        .MapT(x => x.Length)\n                        .SumT();\n}\n\n```\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/issues/81#issuecomment-204392034\n. \n",
    "dhalsim": "Hi @louthy,\nThanks for the response. Sorry for the delay :)\nAFAI understand there is no way to dynamically create a partial function because of .NET's type system. So I think there is no point to reverse map's signature because I have to apply partial by myself so I can use lpar as you said.\nSo I'm closing the issue.\nCheers,\n. ",
    "melston": "Thanks.  After playing with it for some time I finally got an intellisense\nrecommendation to try that and it worked.\nPart of the docs (even the readme) should have something about what to use\nto access these elements, I think.\nNice package, though.  It makes for some very robust C#.\nMark\nOn Sun, May 1, 2016 at 6:19 PM, Paul Louth notifications@github.com wrote:\n\nusing LanguageExt.Trans;\nShould do it.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/louthy/language-ext/issues/87#issuecomment-216089293\n. There must be something different in what I am trying than what you are showing here because I tried BindT and got lots of complaints from the compiler.  I will have to check it out again.\n. I'm using 1.9.7.\n\n. Ah.  Ok.  I just tried what you suggested and got the same kinds of errors I got before on the second BindT.  Specifically, it complains about the type arguments for method TaskTMonadT.BindT....  When I try fixing these type argument (by explicitly specifying them) I then get other errors.\nSo, upgrading to the latest beta should fix this?\n. OK.  That was easy.  Upgraded, built, and now no errors doing what I thought was the right thing all along (using BindT, which I could never get to work right).. Thanks.  I was getting errors on the second BindT so I abandoned that approach. :)  It works now, thanks.. ",
    "LukeJanPracuj": "Thanks, but\nWhat if the object on which we call the Match func can be changed by several threads\n. ",
    "Hinidu": "Oh, it's sad, didn't know about that (or forgot)...\nIn that case what about Lst<T>, Set<T>, etc? They are classes. And it looks like we can create the list of mammals adding a cat to the list of dogs :smile_cat: \n. Thank you for detailed explanation! It's really hard to grasp all these caveats of covariance and contravariance in C# :disappointed: \nI've encountered it the cases like this:\nc#\npublic static Either<Error, TValue> GetEither<TKey, TValue>(\n    this IDictionary<TKey, TValue> dictionary, TKey key)\n{\n    return dictionary.TryGetValue(key)\n        .ToEither(() => (Error)new KeyNotExistError<TKey, TValue>(key));\n}\nPerhaps sometimes I'll try to define algebraic data types in F# if it will be more suitable for such tasks than inheritance.\n. @louthy Thank you for suggestions :+1: \n. Great! I can wait of course! A week would be much faster than I could hope to find time to learn and implement it myself :-)\nThank you in advance!\n. Hello! I've just thought that immutable HashSet would be useful too. The only small problem that System.Collections.Generic already has a class with the same name...\n. Hi @louthy! Sorry for the late response.\nI didn't think about such implementation - it is quite straightforward :+1: I think algorithm in unordered containers for Haskell is more fancy.\nSadly I can't update Language.Ext to the version with HashMap in our project because new version depends on Rx 3.0 and Rx 3.0 requires at least NuGet 2.12 but NuGet 2.12 is not released yet for Visual Studio 2012 which we still use in our company... I hope this problem will be solved soon: perhaps we will switch to NuGet CLI instead of VS extension or we will get new version of VS :smile:\n. The biggest problem in your approach is that variable of type IOption<T> can contain null and compiler will not help you to find this bug. Option<T> is a struct because we want to be \"nullsafe\".\n. @MiloszKrajewski I don't aggree that adding IOption<T> doesn't hurt. It increases cognitive dissonance for the new users. And \"nullsafe\"-way should be the default because it is the main mission of the hole Option thing. But nothing will save the programmer that doesn't know about such intricate details from using IOption<T> unconsciously.\nBut of course it is just my opinion and I'm just the regular user of this library.\n. c#\npublic interface IOption<out T> {\n    bool IsSome { get; }\n    T Value { get; }\n    R Match<R>(Func<T, R> some, Func<R> none);\n}\nAnother problem with this design is the Value property which is not null-safe and become public but its usage should be discouraged in preference to Match, Map, IfNone, etc.\n. ",
    "andrevdm": "@louthy that is fantastic. That is pretty much all I was thinking of. Sure there is a lot more you could add but I think that covers the 80% and definitely gives the type safety I was after. If you don't add to lang-ext I'll probably steal that code and start from there.\nI think single type param is perfect, having more does not really make sense. Also agree that functions would almost always take the exact type, no need for matching then\nThanks for taking the time to look at this\n. very, very nice! Thanks so much. I'm adding it to my project right now :)\n. I like that the language-ext documentation is focused, I don't think that extending it to cover C# features would be useful. A link to e.g. https://msdn.microsoft.com/en-us/library/1t3y8s4s.aspx would be more than sufficient IMO.\n. ",
    "danielcweber": "If you find the addition generally useful, I'll give it a try. Is the list of types you gave exhaustive ?\n. Work great! Makes for some beautiful code. Thanks a lot. If I can contribute to this otherwise, please get back to me.\n. ",
    "bradphelan": "Hi thanks for the advice. In the end I've decided not to use Either for error handling. We have developed a library called Exceptional which specifically encapsulates exceptions, as well as the combinators catching any exceptions thrown within themselves. The library also wraps IObservable and IExceptional as IObservableExceptional so that errors do not terminate the subscription. We still use your library for other things. It's very very nice. Thanks.\n. Love the idea of this extension. However I think \"Union\" is the wrong name for the type. It is a \"discriminated union\" not a \"union\". However that is a sucky long type name. Possibly better is\nOneOf<Cat,Dog,Pencil>\nrather than\nUnion<Cat,Dog,Pencil>\nIn fact   https://github.com/mcintyre321/OneOf  \n. But how about the ordering. Is it garunteed that auto backed properties\nfields are defined in the same order as the properties? If not this could\ncause some confusion for IComparable and properties.\nOn Fri, 1 Sep 2017, 12:01 Paul Louth notifications@github.com wrote:\n\nYes, it works with properties as long as they're field backed properties.\nOn Fri, 1 Sep 2017 at 10:59, Brad Phelan notifications@github.com wrote:\n\nWPF doesn't like binding to fields.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/262, or mute the thread\n<\nhttps://github.com/notifications/unsubscribe-auth/AB5kk1Qymsb3hSUADiEE5E9_0qc_-3rUks5sd9WSgaJpZM4PJ81J\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/262#issuecomment-326542098,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8g81hMee1wRFjiJnDAbzxpPmsralks5sd9XwgaJpZM4PJ81J\n.\n. If you look at the doc for GetFields  you will see\nThe GetFields method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.\n\nThough your code doesn't explicity use GetFields but rather DeclaredFields I assume the same caveat with regards to ordering applies. \nThere seems to be some discussion and maybe a solution on getting a stable order here\nhttps://stackoverflow.com/questions/8067493/if-getfields-doesnt-guarantee-order-how-does-layoutkind-sequential-work. Glad to be of help. The project is great :)\nOn Wed, 6 Sep 2017, 11:53 Paul Louth notifications@github.com wrote:\n\n@bradphelan https://github.com/bradphelan Thanks for that Brad! That's\nvery useful, and has been rolled into v2.1.20. Note, if you're using\nNETCore then you will need to migrate to netstandard 2.0 as MetadataToken\nis not available on netstandard 1.3, so I had to update the whole\nproject. It was in the post anyway, as netstandard 1.3 has gotten in the\nway a number of times.\nhttps://github.com/louthy/language-ext/releases/tag/2.1.20\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/262#issuecomment-327435111,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8l_ODT8iOfw0NkNnACTNZk61FoQFks5sfmutgaJpZM4PJ81J\n.\n. there is an update in 'alpha' so its not critical. C# 8 extension\neverywhere feature should make it possible to fake open modules. but we\nwill have to wait.\n\nOn Thu, 28 Sep 2017, 14:07 Paul Louth notifications@github.com wrote:\n\n@bradphelan https://github.com/bradphelan Unfortunately it's not as\nsimple as that because it would mean splitting the Prelude which removes\nthe advantage that this library seeks - which is a simple functional\nprelude that can be included with one using. On a personal level I am\nalso not particularly keen on making changes to this library to support\nother libraries that can't be bothered to update to the latest versions. So\nI would suggest posting to the reactive-ui repo asking them when they're\ngoing to update.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/273#issuecomment-332816208,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8qR4DjQGjsYo3qozlr29ibyoN2z7ks5sm4vmgaJpZM4PikIi\n.\n. yeah you are totally right. i keep forgetting about the total mess the\ncollections api interfaces are.\n\nim converting over all my system.collections.immutable code to lang ext\ntypes now. its much cleaner.\nOn Wed, 18 Oct 2017, 12:38 Paul Louth notifications@github.com wrote:\n\nIt inherits all the mutable functionality of ICollection, which leaves lots\nof functionality with NotImplementedExceptions.\nThis is widely acknowledged as a mistake by the .NET team when they tried\nto bolt on read-only behaviour to collections. I don't want to propagate\nit.\nOn Wed, 18 Oct 2017 at 09:41, Brad Phelan notifications@github.com\nwrote:\n\nIs there something about IReadOnlyDictionary that precludes this?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/280, or mute the thread\n<\nhttps://github.com/notifications/unsubscribe-auth/AB5kkwMXWekzoIZSFZfIIBufFYsPMUH4ks5stbmqgaJpZM4P9Wwb\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/280#issuecomment-337546455,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8sT0obMjVaoL3QeWwvfNQZ7ksjdCks5stdU8gaJpZM4P9Wwb\n.\n. MS also screwed up the immutable collections API in that they dont\nimplement equality. I remember some half baked reason they gave for it. So\nin the end two immutable list with identical contents use reference\nequality and thus are considered not equal.\n\nSo they dont work with your magic Record base class.\nthus i swap to your collections which do implement equality.\ngreat work. thanks\nOn Wed, 18 Oct 2017, 12:38 Paul Louth notifications@github.com wrote:\n\nIt inherits all the mutable functionality of ICollection, which leaves lots\nof functionality with NotImplementedExceptions.\nThis is widely acknowledged as a mistake by the .NET team when they tried\nto bolt on read-only behaviour to collections. I don't want to propagate\nit.\nOn Wed, 18 Oct 2017 at 09:41, Brad Phelan notifications@github.com\nwrote:\n\nIs there something about IReadOnlyDictionary that precludes this?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/280, or mute the thread\n<\nhttps://github.com/notifications/unsubscribe-auth/AB5kkwMXWekzoIZSFZfIIBufFYsPMUH4ks5stbmqgaJpZM4P9Wwb\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/280#issuecomment-337546455,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8sT0obMjVaoL3QeWwvfNQZ7ksjdCks5stdU8gaJpZM4P9Wwb\n.\n. If I change the static property to a static field\n\npublic static Foo Default;\n\nthen the two tests pass. I'll try and fix it. I've found the problem in the code. tracking https://github.com/bradphelan/language-ext/tree/static-props-fail. If this could be merged  quickly I would appreciate it as it's blocking my integration work and there is no easy work around.. I've done a bit more refactoring and now there is\n    /// <summary>\n    /// Remove an item from the list\n    /// </summary>\n    [Pure]\n    public Lst<A> Remove(A value, IEqualityComparer<A> equalityComparer = null) => \n        Wrap( Value.Remove( value, equalityComparer ) );\n\n    /// <summary>\n    /// Remove an item from the list\n    /// </summary>\n    [Pure]\n    public Lst<A> Remove(A value, IComparer<A> equalityComparer) =>\n        Wrap(Value.Remove(value, equalityComparer));\n\nOne with and IEqualityComparer and one with an IComparer. Is the second one needed? I don't really understand the use for it.. Here's the problem Array.Equals\n\n. doesnt that allocate and then deallocate a backing array every time you do\nthat?\nOn Thu, 19 Oct 2017, 17:36 Paul Louth notifications@github.com wrote:\n\n@louthy commented on this pull request.\nIn LanguageExt.Core/DataTypes/Arr/Arr.cs\nhttps://github.com/louthy/language-ext/pull/287#discussion_r145738503:\n\n@@ -449,6 +449,22 @@ public Arr Map(Func map)\n         public override bool Equals(object obj) =>\n             obj is Arr && Equals((Arr)obj);\n\n\n[Pure]\npublic bool Equals(Arr obj) =>\nSafeEquals(Value, obj.Value);\n\nShould probably just call default(MArr).Equals(this, obj);\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/287#pullrequestreview-70582934,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8sqjvvRgQUzS6phtzJNbqJ0AfgD6ks5st2x1gaJpZM4P-0Dp\n.\n. no i mean that Arr is a struct but is backed by an array reference which\nneeds to allocate on heap. Therefore default(Arr) will allocate an array\nevery time it is called.\n\nOn Thu, 26 Oct 2017, 20:52 Paul Louth notifications@github.com wrote:\n\n@bradphelan https://github.com/bradphelan\ndoesnt that allocate and then deallocate a backing array every time you do\nthat?\nNope. MArr is the 'class instance' for the Arr data-type, it\ndoesn't allocate anything, just calls: Enumerable.SequenceEqual(x, y)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/287#issuecomment-339763629,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8pPlqyoNIl5sffOxkGOubkL8q-mCks5swNT_gaJpZM4P-0Dp\n.\n. my bad! thanks for the clarification\n\nOn Sun, 29 Oct 2017, 13:20 Paul Louth notifications@github.com wrote:\n\nIt's default(MArr) not default(Arr) - the Monad/Eq/Ord type-class instance\nfor Arr.\n\nOn 26 Oct 2017, at 20:23, Brad Phelan notifications@github.com wrote:\nno i mean that Arr is a struct but is backed by an array reference\nwhich\nneeds to allocate on heap. Therefore default(Arr) will allocate an\narray\nevery time it is called.\nOn Thu, 26 Oct 2017, 20:52 Paul Louth notifications@github.com wrote:\n\n@bradphelan https://github.com/bradphelan\ndoesnt that allocate and then deallocate a backing array every time\nyou do\nthat?\nNope. MArr is the 'class instance' for the Arr data-type, it\ndoesn't allocate anything, just calls: Enumerable.SequenceEqual(x, y)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\n<\nhttps://github.com/louthy/language-ext/pull/287#issuecomment-339763629>,\nor mute the thread\n<\nhttps://github.com/notifications/unsubscribe-auth/AABE8pPlqyoNIl5sffOxkGOubkL8q-mCks5swNT_gaJpZM4P-0Dp\n.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/287#issuecomment-340258280,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8mMLg-F_7WUZOw6ZNSaT7wjCqQmJks5sxG1zgaJpZM4P-0Dp\n.\n. This would hopefully make it more seamless as you don't have to rely on AssemblyInfo.cs patching to set the version number, rather you can just just use msbuild and pass the version property in. That I'm using gitversion to generate the version number is just an extra feature. You could just as easily have the version number in a text file and set as an environment variable and pass that to msbuild. However gitversion makes it so that you can't forget to bump the (CI) version number on every checkin.. I tried\n\n```\n    public class ContainerOrderingTests\n    {\n        public class WithSet : Record\n        {\n            public WithSet(int i, Set s)\n            {\n                I = i;\n                S = s;\n            }\n        public int I { get; }\n        public Set<OrdInt,int> S { get; }\n    }\n\n    [Fact]\n    public void SetOrderingWorks()\n    {\n        var a = new WithSet(0, Prelude.Set<OrdInt,int>(0,1,2));\n        var b = new WithSet(0, Prelude.Set<OrdInt,int>(0,1,2));\n        Assert.Equal(0,a.CompareTo( b )) ;\n    }\n}\n\n```\nbut I think that is really just the same as the first example. Progress. I now have\n    /// <summary>\n    /// The pattern we are trying to match here is\n    /// <![CDATA[M<N<T>>]]>\n    /// which for examples models <![CDATA[Ord<Set<T>>]]>\n    /// The generated type needs to match <![CDATA[MN<MT,T>]]> \n    /// or for our concrete example <![CDATA[OrdSet<OrdInt,Int32>]]>\n    /// </summary>\n    /// <returns></returns>\n    public static Option<Type> GetOrderableContainerOrd()\n    {\n\n        Option<TypeInfo> ArityOneGeneric(TypeInfo baseInfo)\n        {\n            return baseInfo.GenericTypeArguments == null || baseInfo.GenericTypeArguments.Length != 1\n                ? (Option<TypeInfo>) None\n                : baseInfo.GenericTypeArguments[0].GetTypeInfo();\n        }\n\n        string RemoveGenerics(string name) => FirstCharToUpper(OrdNameMaps(name.Split( '`' ).Head()));\n\n        var mType = typeof(A).GetTypeInfo();\n\n\n        return\n            from nType in ArityOneGeneric( mType )\n            from tType in ArityOneGeneric( nType )\n            let mnTypeName = RemoveGenerics( mType.Name ) + RemoveGenerics( nType.Name ) + \"`2\"\n            let mtTypeName = RemoveGenerics( mType.Name ) + RemoveGenerics( tType.Name )\n            let tTypeName = RemoveGenerics( tType.Name )\n            from mnType in ClassInstancesAssembly.Structs.Where( t => t.Name == mnTypeName ).HeadOrNone()\n            from ntType in ClassInstancesAssembly.Structs.Where( t => t.Name == mtTypeName ).HeadOrNone()\n            select mnType.MakeGenericType( ntType, tType );\n\n    }\n\n    static string OrdNameMaps(string typename)\n    {\n        switch (typename)\n        {\n            case \"Int32\": return \"Int\";\n            case \"Int64\": return \"Long\";\n            default: return typename;\n        }\n    }\n\n\n    public static string FirstCharToUpper(string input)\n    {\n        switch (input)\n        {\n            case null: throw new ArgumentNullException(nameof(input));\n            case \"\": throw new ArgumentException($\"{nameof(input)} cannot be empty\", nameof(input));\n            default: return input.First().ToString().ToUpper() + input.Substring(1);\n        }\n    }\n\nwhich can resolve the test\n    [Fact]\n    public void GetOrderableContainerOrderWorks()\n    {\n        var type = Class<Ord<Set<int>>>.GetOrderableContainerOrd();\n        Assert.True( type.IsSome );\n\n    }\n\n. Super :)\nOn Tue, 14 Nov 2017, 16:32 Paul Louth notifications@github.com wrote:\n\n@bradphelan https://github.com/bradphelan Hi Brad, sorry for the delay.\nMap, Map, Set, Set, Lst, Lst, Lst now all support IComparable as well as the <, <=, >=, >\noperators\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/293#issuecomment-344295849,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8gMYcBt5c1B5KXjJ34w44brdHH8Yks5s2bJygaJpZM4QD4ND\n.\n. I've noticed a problem with the libraries. We have for example Set<A> and Set<OA,A> but we only have OrdSet<OA,A> which is defined as \n\n/// <summary>\n/// Equality and ordering\n/// </summary>\npublic struct OrdSet<ORD, A> : Ord<Set<A>>\n    where ORD : struct, Ord<A>\n{\n\nbut not \n/// <summary>\n/// Equality and ordering\n/// </summary>\npublic struct OrdSet<ORD, A> : Ord<Set<ORD,A>>\n    where ORD : struct, Ord<A>\n{\n\nwhich seems like there is a missing part of the puzzle somewhere.\nThis means that Ord lookup for\npublic class Foo : Record<Foo>{\n    public Set<OrdInt,int> S{get;}\n}\n\ncannot be done.. Super. Thanks. I couldnt find those before.\nOn Wed, 13 Dec 2017, 18:01 Paul Louth notifications@github.com wrote:\n\n@bradphelan https://github.com/bradphelan Get v2.1.32\nYou can either use the IgnoreBase attribute:\n[IgnoreBase]public class SubClass2 : BaseClass, IEquatable, IComparable\n{\n    public readonly int Y;\npublic SubClass2(int x, int y) : base(x) =>\n    Y = y;\n\npublic int CompareTo(SubClass2 other) =>\n    RecordType<SubClass2>.Compare(this, other);\n\npublic override bool Equals(object obj) =>\n    RecordType<SubClass2>.Equality(this, obj);\n\npublic bool Equals(SubClass2 other) =>\n    RecordType<SubClass2>.EqualityTyped(this, other);\n\npublic override int GetHashCode() =>\n    RecordType<SubClass2>.Hash(this);\n\n}\nOr, control behaviour on a per-operation basis by using\nRecordTypeIgnoreBase instead:\npublic class SubClass1 : BaseClass, IEquatable, IComparable\n{\n    public readonly int Y;\npublic SubClass1(int x, int y) : base(x) =>\n    Y = y;\n\npublic int CompareTo(SubClass1 other) =>\n    RecordTypeIgnoreBase<SubClass1>.Compare(this, other);\n\npublic override bool Equals(object obj) =>\n    RecordTypeIgnoreBase<SubClass1>.Equality(this, obj);\n\npublic bool Equals(SubClass1 other) =>\n    RecordTypeIgnoreBase<SubClass1>.EqualityTyped(this, other);\n\npublic override int GetHashCode() =>\n    RecordTypeIgnoreBase<SubClass1>.Hash(this);\n\n}\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/315#issuecomment-351454621,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8mSUCL4wTlTi1AH7_NmvL4p1acwyks5tAALJgaJpZM4RAX3K\n.\n. oh \ud83d\ude03  Well double thanks then.\n\nOn Wed, 13 Dec 2017, 19:37 Paul Louth notifications@github.com wrote:\n\nI couldnt find those before\nIt didn't exist before, I added it to v2.1.32 ;)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/315#issuecomment-351482197,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AABE8o6hwTvibITttmHWm_jYiphJtIULks5tABlegaJpZM4RAX3K\n.\n. It can return zero\n\n\nhttps://msdn.microsoft.com/en-us/library/ff3b842x(v=vs.110).aspx\nwill fix.. Actually.. When you pass true to GetAccessors then the array will always have two elements\nhttps://msdn.microsoft.com/en-us/library/afadtey7(v=vs.110).aspx\n\nAn array whose elements reflect the get and set accessors of the property reflected by the current instance. If nonPublic is true, this array contains public and non-public get and set accessors. If nonPublic is false, this array contains only public get and set accessors. If no accessors with the specified visibility are found, this method returns an array with zero (0) elements.\n\nStill just to be safe I'll fix the code. ",
    "thitemple": "I haven't. Gonna try it. Thanks\n. That solved it. Thanks.\n. For me it's the same thing. I can use it, but everything is rebuild every time. \n. ",
    "jbarbosa": "I tried using LanguageExt with StrongNamer, but there's one major downside - StrongNamer forces the solution to be rebuilt from scratch every single time, effectively ditching \"incremental building\".\nIn a fairly large project, build times go from a couple of seconds to >1 minute. This makes the test-fail-code loop completely unbearable. Writing tests is no longer practical, and my team decided not to use this lib for this reason.\nI beg you to reconsider signing this library.\nIMHO, the biggest challenge in signing an OSS library is keeping the key out of the git repository, so that only the author has access to it. But, if I'm only signing the lib to make it work with other signed projects, I find there's no value in keeping the key out of the repository. I've done this successfully in other OSS projects.\nSo, in my experience, if you simply add a key to the project and to the repository, it shouldn't have any impact on builds and deployments.\nI'm sure there are plenty of people out there who would benefit from this.\nThanks.\n. Thank you for reopening this.\nIs there a need for a weak version? Can the strong version not be used in all situations where a weak version is used?\n. ",
    "khtan": "Sorry, the above is not an issue but I just had a question. Thanks,\n. Thanks. In case you are interested, a comment on the Iter like // also known as ForEach \nwould help beginners like me find the function more quickly. Great work!\n. Belated thanks. Just got confused which functions are standard functional HOF ( Map, Reduce etc ) and which are Microsoft's Linq, like GroupBy. \n. ",
    "ceywj": "ForEach will be trasformed fo \"foreach (x in y )\" by the VS IDE all the time ,I think call it Iter is a good idea. public static B use(A disposable, System.Func f)\n    where A : System.IDisposable\n    LanguageExt.Prelude \u7684\u6210\u5458\n\u6458\u8981:\nFunctional implementation of the using(...) { } pattern. ",
    "jcoder58": "@louthy:  I agree with you about the Akka design, which is why I'm looking at Process.  What they've done is very impressive, but I want to move to a more functional style, without having to jump to F#.   F# is a great language, but the C# tooling still wins for me.\nProcess and Core seem to be what I'm looking for, so as long as you're aware of the performance issue and have plans to improve it, I'll continue to look at it.  \n. @louthy ,\nThanks for the response.   Your version works for me.  And it makes it clear what I was doing wrong.\nIf I understand this, you're using LINQ expressions similar to the way do/<- syntax works in Haskell, or as a limited form of F#'s computational expressions?\n. @louthy  the best-form C# parser looks like a good starting point for me.  I need to parse C++ headers that use doxygen comments, so there is quite a bit overlap with the C# syntax.  The biggest change will be adding the C++ preprocessor directives and c++ method inline declarations.\n. User Error :(.\n. ",
    "solvingj": "Thats separation of the nuget packages really is the key, so that works. I guess the only other factor is for those wanting to fork and contribute have to get the whole project, but it's so small and well divided that I guess it doesn't matter.  I really hope to see the functional pieces get noticed and picked up by other projects, which will draw other contributors and thus increase the chances of survival and it's ability to adapt with related changes (C# 7 etc). \nThanks again for your contribution and effort. \n. Agreed.  I didn't even know that was a c# feature... thank you :)\n. I just realized that I made a bit of an error in the title of this request.  I was meaning to request a functional parseJson method to go along with the others.  Sure, it would be good if Json.Net to implement TryParse but I would still prefer the parseJson in the context of this library. \nDoes that make a bit more sense :). Your suggestion of just using Try is perfect.  No need for the helper method.   I completely understand about the dependency.  \nYour assumption about unknown schema is correct. \nThanks again on the hard work you're doing for the library. I read something about your efforts on Json.Net and know it must be hard. Someday i hope to contribute. \n. This information seems to deserve it's own wiki page.  As you said, it's been a recurring issue, and Json.Net, .NET Core are not likely to \"stop moving\" any time soon.  In any case, those types of articles are helpful \"warnings\" to people who are new to using language-on-language frameworks about the nuances surrounding compatibility with third party.  My first language was Groovy which is written on top of Java, and there were nuances there as well.  Highlighting the known stumbling blocks is a good courtesy if you have the time. I think you do a good job. . Wow, awesome... link is bad but the PR looks nice. . Indeed, logging is an extremely common need, so I'm curious how other projects using this library achieve logging if there's no simple and built-in: \nA -> Action<A> -> A\n. ",
    "OlduwanSteve": "Sorry I realised I didn't need the second interface so I can't now repro the error. I think it was this one:\nreturn Left<string, object>(\"Message-type (\"+message.GetType().FullName+\") doesn't match inbox declared type: \" + String.Join(\", \", inboxDeclaredType.Map(x => x.FullName)));\nAnd from that I assumed it wasn't the intended behaviour. It may just have been that the old metadata was registered in redis and hadn't been updated yet. I'll close this for now and reopen if it comes up again.\n. On further investigation, you can override the compiler-supplied nullable comparison operators. I think a good course of action would be to implement them as 'expected' but mark them obsolete to discourage use and highlight problems during refactoring. I'll make a patch in case you agree.\n. The example above does deal with nullable options, because the compiler helpfully converts Option to Option? before it performs the comparison.\nThe problem with refactoring isn't really a question of effort. If you replace a nullable with an option (quite a likely thing to do) then there is no good way of finding all the places where comparison to null is happening, but anywhere it is happening the logic will break.\n. As I understand it, the point of Option<T> is to be a 'better' Nullable<T>. You wouldn't ever use Option<T>? because it's a tautology. In addition to that, you're actively discouraging the use of null throughout the library. Bearing those things in mind, it's not clear to me what's getting broken by the proposed change.\nThe main advantage I see to the proposal is simply that doing this:\n\nfind all usages of the variable and validate it.\n\n...is hard and unreliable. Thanks to type inference and anonymous types, it's very easy for the type of a variable to be passed on to other variables. Tracing all of that manually is likely to fail at some point.  If the compiler does it for you then it's much more reliable.\n. I think I can justify the pull request better. If you look here it describes how, for types which overload the equality operator, the compiler automatically implements a 'lifted' equality operator with nullable arguments.\nIn the current lang-ext, when I call this :\nvar arguablyShouldBeTrue = opt == null;\nThe compiler is calling the auto-generated method:\npublic static bool operator ==(Option<T>? lhs, Option<T>? rhs)\nwhere lhs is never null (because it's lifted a struct). In order to change this default behaviour I had to override that method so the default implementation isn't created (or the compiler prefers mine... not sure which).\nThe point is whenever you compare Option<T> with null, that's the overload that will get called. So my pull request is only dealing with Nullable<Option<T>> because that's how you overload comparison between a struct and null.\nYou're right about the 'With' use-case, but actually this only breaks if you use the conditional operator. With my changes you get an 'obsolete' warning and VS underlines it with a green squiggle:\n\nIf you use the coalescing operator then it works perfectly, and is a bit neater:\n\nFWIW, by compiling our code base against my fork of lang-ext, I've already found some minor bugs that slipped through the refactoring net.\n. Nuget package 3.0.20. Thanks, it looks like IsProperSubsetOf might have a similar problem - you're making a distinct set of 'other' using Set<A>.. ",
    "wallymathieu": "There is a way to work with immutable collections. You can add extensions with \"NotImplemented\" as implementation and create a copy update expression. I've done it in the library With :\nManipulation_of_enumerable.cs#L76\nconst string newValue = \"const\";\n        var ret = myClass.With(m => m.Preferences.Add(newValue));\n        Assert.Equal(newValue, ret.Preferences.Last());\nHere the property Preferences does not have an Add method (it's an extension method only for the use in expressions).\n. I merely wanted to sneak in a suggestion on how to extend the syntax when working with immutable types. So, yes, it's unrelated.\n. Exactly. In order to simplify creation of record types in c#.\n. Yes, well, the easiest and prettiest way would be to actually use f# ;) \n. ",
    "OzieGamma": "Hum Ok, makes sense !\nI use my own class templates (I dont have any imports by default :P) so I dont have that problem !\n. Ok, Ill write a small analyzer whenever I have time this week ! \n. I am writing T4 generation to do the job. That would be specialisation at compile time. Solving the code size problem at least for types defined in the lib.\nThe problem I see with your \"type classes\" is that the return types are of type Monad which is not very interesting ...\nOption.map the returns Monad. Type accuracy is lost ! So it might be there for convenience if users define their own but doesnt replace the original type ...\n. ",
    "dcastro": "Thank you, I hadn't noticed the Prelude.\nI'm not using the one that compiles because, in my actual code, I'm being passed an instance of the interface (X) and not an instance of the concrete type (Y).\n. Another use case where this happened to me was this:\ncsharp\nEither<Exception, IEnumerable<T>> F()\n{\n    return Enumerable.Empty<T>();\n}\nThe workaround was to return new List<T>() instead, which performs needless allocations.\n. Perfect!\nThank you for the explanation, I wasn't aware of this limitation.\n. ",
    "johannesegger": "The R# documentation says you can create external annotations and distribute them through NuGet packages, so you could completely separate the library from the R# annotations if you wanted to.\n. OK, you're right. It's R# that is wrong. Thanks for the detailed explanation. I understand your point of view.\n. Wow, thanks for the fast response. Making it nullable seems like the best option for me at the moment.. Ahh that's great, I didn't know that there was any support for Nullable. Thanks.. ",
    "architrent": "I see.  Very helpful response.  Thanks.  We'll go with the config file approach, then.\nThe in-code process configuration you show for \"my-service\" is how I am currently handling spinning up the processes.  That all worked fine.  It was just getting Redis into the picture so the processes didn't have to be local that was holding me up.\nYou mention that with the config file approach, the processes are also registered.  That's great, since that's what we want.  I was doing that in code, also, and shutting them down on app shutdown.  You don't mention it, but, using the config file approach, do I still need to do that or is the framework going to handle shutdown for me?\nI have some other questions about the best way of solving certain problems using language-ext.  Do you have a preferred medium for discussing those?  They don't belong here, since they aren't issues.\n. I see.  Thanks.  I'll post other questions in gitter, and close this issue.  (Sorry for the delay.  Life intervened.)\n. ",
    "Maximusya": "End-user may use whatever she likes, but for the sake of documenting Unsafe and null are read like \"null is unsafe\" not \"default value is unsafe\". And btw internal methods have null in their names all over the place (CheckNullReturn, isnull etc)\n. Related: https://github.com/louthy/language-ext/issues/91\n. Any option for a one-time payment? Maybe it would not be too helpful - just a way to make virtual beer a real beer). The stuff you are mentioning is in the Introduction section. The Introduction to a Functional language extension IS EXPECTED to contain OOP vs FS points!\nThe project has the personal touch and style everywhere. I - as a traditional seasoned C# OO programmer - like it very much to use and READ advices and overall thoughts of a sane person. That things do not deserve small section ghetto :). ",
    "monkeyhell": "Interesting.  I had hitherto assumed that ImmutableSortedDictionary<K,V> had a type constraint to ensure its key type was IComparable, but as you say, it doesn't.  I think perhaps the reason I've never made the same mistake with the Microsoft immutable collections is that the name of the type includes the word 'sorted', so it forces you to think about your key type.\n. Got it.  I'll just have to get into the mindset that maps are sorted by default, and unsorted only if you explicitly say so.  Looks like the same is true for Set vs HSet.\nThis library looks really useful.  I've been frustrated by the amount of boilerplate when using the Microsoft immutable collections, and as a result it's been quite a hard sell when trying to convince others to use them.  Using this library instead makes everything much easier on the eye.  Thanks!\n. Re the implementation of HMap and HSet, that's interesting because I would have assumed that a hashmap/hashset would be backed by a hashtable, and would therefore have O(1) lookup, but in this case it's actually O(log(n)).  Good to know.\nRe v2, sounds good, I'll keep an eye out for it!\n. @louthy Just tried again from scratch; same error:\n\nRestoring packages for 'LanguageExt.Parsec'.\nRestoring packages for 'E:\\code\\github\\language-ext\\LanguageExt.Parsec\\project.json'\nTODO: Read and use lock file\nUsing source https://api.nuget.org/v3/index.json\nRestoring packages for .NETFramework,Version=v4.5\nRestoring packages for .NETFramework,Version=v4.6\nError occurred while restoring NuGet packages: Circular dependency references not supported. Package 'LanguageExt.Parsec'.\n. @louthy Installed VS2015 Update 3 overnight.  Notably, the NuGet Package Manager component was upgraded from 3.0.0 to 3.4.4.  It builds fine now.  Thanks!\n. \n",
    "spyder94": "I was wrong about using the JsonConvert.DefaultSettings to register custom converters.  Apparently the code where i was doing the registration wasn't getting called.  Adding this in our application entry point corrects the problem.\nNewtonsoft.Json.JsonConvert.DefaultSettings = () => new Newtonsoft.Json.JsonSerializerSettings\n            {\n                Converters = new List<Newtonsoft.Json.JsonConverter> { new ClaimConverter() }\n            };\n. ",
    "Richiban": "As an example: \n``` csharp\n    var input = List(\n        Some(1),\n        Some(2),\n        Some(3),\n        None,\n        Some(4),\n        None,\n        Some(5));\nvar actual = input.Choose(x => x);\n\n```\nactual should be equivalent to {1, 2, 3, 4, 5} but instead it simply returns the original sequence of {        Some(1), Some(2), Some(3), None, Some(4), None, Some(5)}\n. Sweet, thanks\n. Thank you Paul,\nI thought it was worth a discussion (although it probably wasn't\nappropriate to go straight to pull request) but you're right, there's no\nreal reason for this to be here.\nI did notice your use of the Pure attribute, but I'm not sure it's going to\nwork for me since I'm worried about a lot more than just pure functions.\nE.g. a database query is far from pure but I still want a compiler warning\nif I ignore the result. It's also incredibly useful for task-async methods,\nwhere failing to await the result of a task can be disastrous in a subtle\nway.\nI think I need an attribute such as DoNotIgnoreReturnValue (such as\n@warn_unused_result in Swift v2), but I would much prefer that it happened\nby default (as in Swift 3 where they reversed the behaviour with\n@discardableResult).\nThanks for your input!\nOn 11 October 2016 at 22:56, Paul Louth notifications@github.com wrote:\n\nWhilst I think it's a novel idea to have a write-only _ field, I'm not\nsure the solution to the problem you're trying to solve belongs in this\nlibrary. There would also be holes in this solution with locals named _\n(which I often use in LINQ and in lambdas).\nAlso have you considered that the [Pure] annotation from the Microsoft\nContracts library is a good place to start with code-analysis? I have\nannotated everything that's pure (and should therefore return a value) in\nthis code-base, as has Microsoft with the BCL.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/151#issuecomment-253058797,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAoyj-Z2mlhfymsFCO1XoFCfhE0ZatYPks5qzAYegaJpZM4KQJhH\n.\n\n\n\nRichard Gibson -\n. Sure, no problem!\n. Wouldn't it be possible to have a method on the RecordType base class with this signature:\n\n```csharp\npublic abstract class RecordType\n{\n    ...\npublic T With<TProp>(Expression<Func<T, TProp>> propSelector, TProp newValue)\n{\n    // Some of Louthy's magic here?\n}\n\n}\n```\nUsage would then look like this:\n```csharp\nvar r = new MyRecord(value : \"Hello world\");\nvar r2 = x.With(x => x.Value, \"Goodbye, cruel world!\");\n```\nIt's similar to how mocking frameworks such as Moq work:\n```csharp\nvar m = new Mock();\nm.Setup(x => x.Foo()).Returns(\"My new value\");\nm.Object.Foo(); // Returns \"My new value\"\n```\nIt's definitely possible with reflection which I hope means that, Louthy, you could sprinkle some of your IL-generation magic to make it perform much better.\nThe main problem that I see with this is that there are a lot of cases that would have to result in an exception. For example, there's nothing to force the user from passing in a lambda that actually references a property on the object. Also, you might have some trouble matching property names to constructor argument names.\n. @trbngr Fody might be a good choice, since it can not only verify at compile-time that the call written by the user is correct but could also rewrite the call to With into a direct call to the constructor:\n```csharp\npublic class MyRecord : RecordType\n{\n    public MyRecord(int x, int y, int z) => (X, Y, Z) = (x, y, z);\npublic int X { get; }\npublic int Y { get; }\npublic int Z { get; }\n\n}\n```\nGiven the type definition above the following:\n```csharp\nvar record = new MyRecord(4, 5, 6);\nvar record2 = record.With(r => r.X, 10);\n```\nwould be rewritten to:\n```csharp\nvar record = new MyRecord(4, 5, 6);\nvar record2 = new MyRecord(10, record.Y, record.Z);\n```. @louthy \n\nReally, records should be closed immutable types, [...]\nPersonally, I would implement your above type like so\n\nI know, I know... I'm abusing the RecordType feature somewhat (okay, a lot) and just using it to dump instances of arbitrary types to a log. My type is not actually a Record at all!\nI'm working in a legacy system here and don't want to change too much. I'm guessing that my version of LanguageExt is out of date.\nThanks for your help!. Are you looking for Either<L, R>? It only supports two arguments but you can always nest them.. @slimshader Unfortunately I don't think there's anything LanguageExt can do for you there, since implementing proper DUs would require compiler support. Perhaps there is something it could do to help reduce the boilerplate, as it does with records.\nCurrently, if I want to implement a DU in C# I do something like this:\nfsharp\ntype FavouriteColour =\n    | Red\n    | Green\n    | Blue\n    | Other of string\n```csharp\npublic abstract class FavouriteColour\n{\n    private FavouriteColour() {}\npublic static readonly FavouriteColour Red = new FavouriteColour();\npublic static readonly FavouriteColour Green = new FavouriteColour();\npublic static readonly FavouriteColour Blue = new FavouriteColour();\n\npublic sealed class Other : FavouriteColour\n{\n    public Other(string value) => Value = value;\n\n    public string Value { get; }\n}\n\n}\n```\nThe interesting parts are: \n The private constructor of the base type that \"closes\" the type (i.e. stops any external type from inheriting it)\n Data-less cases of the union don't need to be classes themselves; they're singleton values so they can just be static readonly fields or properties\n* Cases that contain data should be a class\nThere is an argument for making even data-less cases a class so that they can be used with C# 7's basic pattern matching, something like this:\n```csharp\nswitch(colourChoice)\n{\n    case FavouriteColour.Red r => Console.WriteLine(\"You chose red!\"); break;\n    case FavouriteColour.Blue b => Console.WriteLine(\"You chose red!\"); break;\n    case FavouriteColour.Green g => Console.WriteLine(\"You chose red!\"); break;\ncase FavouriteColour.Other o => Console.WriteLine(\"You chose another colour: {o.Value}. Nice!\"); break;\n\ndefault: break;\n\n}\n```\nUnfortunately C#'s compiler has no concept of closed type hierarchies so it can't check the switch statement for completeness and you must therefore add a default case every time, but still it's a step in the right direction.\n\nObviously this contains no equality or parsing code, feel free to add those. I don't know off the top of my head whether the base type could inherit from Record<T> to get those working.. @slimshader Absolutely, especially since I've just discovered that inheriting from Record<T>:\n```csharp\npublic class FavouriteColour : Record\n{\n    private FavouriteColour() { }\npublic static readonly FavouriteColour Red = new FavouriteColour();\npublic static readonly FavouriteColour Green = new FavouriteColour();\npublic static readonly FavouriteColour Blue = new FavouriteColour();\n\npublic sealed class Other : FavouriteColour\n{\n    public Other(string value) => Value = value;\n\n    public string Value { get; }\n}\n\n}\n```\n...doesn't work. Equality is incorrect and ToString is not generated.\n@louthy Do you think this is something that is possible? Supporting this idiom with a SumType base class or similar, that will generate the IL necessary for each child class, instead of the base (as Record<T> does)?. ",
    "sdedalus": "I've removed the inheritance problem in my last check-in.  As it is now static checking will throw a compile time error if you have the types out of order or fail to match all cases so the refactoring burden is limited and the chance of a runtime error is minimised.  I'll read over the link you provided It looks like it has a solution for tagging the contained type which is nice.  I was working on a wrapper class with proxied operators to manage that aspect of it.\n. IDisposable Louthy seems not very keen on this entire approach so that checkin was intended to capture the final state of my work in case someone finds it useful.   I'm studying the preferred approach now.\n. Go ahead and close this. I have some ideas that need a bit of fleshing out\nbefore they are ready and honestly I'm having fun putting the type system\nthrough it's paces so I'll keep working on it regardless.  If and when I\nget this to a state where it seems like it could benefit the project I'll\nrun it by you on the issue board assuming that it hasn't been closed also.\nOn Tue, Oct 18, 2016, 12:29 PM Paul Louth notifications@github.com wrote:\n\n@sdedalus https://github.com/sdedalus How do you want to manage this\ngoing forward? Should I close this and you do a new pull request when\nyou're ready, and we can discuss on the Issue that's open? Or keep this\npull request open, and you'll update it as you go?\nI think it's worth coming back quickly when you have ideas on a potential\napproach. I don't want you wasting time going off in a random direction if\nit's not something I think will work for the library.\nElegance is the key to a feature like this working. At the moment it's\npossible for users to do this:\n```\npublic abstract class Shape { }\npublic class Square : Shape\n{\n    public readonly Position TopLeft;\n    public readonly double Width;\n}\npublic class Triangle : Shape\n{\n    public readonly Position Vertex1;\n    public readonly Position Vertex2;\n    public readonly Position Vertex3;\n}\npublic class Circle : Shape\n{\n    public readonly Position Position;\n    public readonly double Radius;\n}\nvar res = x is Square    ? DrawSquare(x as Square)\n        : x is Triangle  ? DrawTriangle(x as Triangle)\n        : x is Circle    ? DrawCircle(x as Circle)\n        : DefaultBehaviour(x);\n```\nObviously this isn't such a great example (it's one where inheritance\nactually works better); but as an example of how to do sum-type like\nbehaviour for C# it's quite elegant. It has the initial hit of having to\nbuild the types, but that's a once only hit, whereas as the initial\nproposed solution inflicted the declaration on the programmer every time\nthey used it.\nIt also forces a form of completeness checking, because it's a sequence of\nternary operators and therefore you must always have a catch-all case.\nAnd finally it allows for predicate like behaviour:\nvar res = x is Square && (x as Square).Width > 50 ? DrawBigSquare(x as Square)\n        : x is Square                             ? DrawSmallSquare(x as Square)\n        : x is Triangle                           ? DrawTriangle(x as Triangle)\n        : x is Circle                             ? DrawCircle(x as Circle)\n        : DefaultBehaviour(x);\nObviously it doesn't allow for ad-hoc types like Union,\nbut I'd argue that you don't get ad-hoc types in F# (or similar functional\nfirst languages). The original Union proposal was closer to an Either\nthan a sum-type.\nFor example in F# you'd be writing this:\n```\ntype Thing =\n  | Integer of int\n  | String  of string\n  | Boolean of bool\nlet x = Integer 123\nlet y = String \"Hello\"\nlet z = Boolean true\nmatch x with\n | Integer a -> UseInteger a\n | String  a -> UseString a\n | Boolean a -> UseBoolean a\n```\nWhich is the equivalent of:\n```\npublic abstract class Thing { }\npublic class Integer : Thing\n{\n    public readonly int Value;\n    public Integer(int value) { Value = value; }\n}\npublic class String : Thing\n{\n    public readonly string Value;\n    public String(string value) { Value = value; }\n}\npublic class Boolean: Thing\n{\n    public readonly bool Value;\n    public Boolean(int value) { Value = value; }\n}\nvar x = new Integer(123);\nvar y = new String(\"Hello\");\nvar z = new Boolean(true);\nvar res = x is Integer  ? UseInteger(x as Integer)\n        : x is String   ? UseString(x as String)\n        : x is Boolean  ? UseBoolean(x as Boolean)\n        : UnknownValue(x);\n```\nWith pattern-matching about to land in C# a lot of this is moot. The key\ndifficulty is creating the sum-type in the first place. That's where the\ninterface approach looks quite nice. Because the above could be declared\nlike so:\npublic interface Thing\n{\n    public Thing Integer(int x);\n    public Thing String(string x);\n    public Thing Boolean(bool x);\n}\nThere is some messiness to the solution on codeplex though:\nvar x = DataType.New<Thing>();\nThis generates an object of type Thing. It would be the equivalent of null\nbecause it's not until calling one of the methods that you get a concrete\nvalue:\nvar x = DataType.New<Thing>().Integer(123);\nvar y = DataType.New<Thing>().String(\"Hello\");\nvar z = DataType.New<Thing>().Boolean(true);\nWhich is a little unsatisfactory, as this library - if anything - is about\ncorrectness and reducing the possibilities of coder fuck-ups.\nThe matching story on the codeplex version is quite ugly compared to the\nexamples I gave above using the ternary operators.\nHowever it does unpack the data, which is quite nice. That would be good\nfor the Shape example:\n```\npublic interface Shape\n{\n    Shape Square(Position topLeft, double width);\n    Shape Triangle(Position vertex1, Position vertex2, Position vertex3);\n    Shape Circle(Position position, double radius);\n}\n// Assuming we had a Prelude function called datatype that does the same as DataType.New\nvar x = datatype().Square(pos, width);\nvar y = datatype().Triangle(p1, p2, p3);\nvar z = datatype().Circle(pos, radius);\nvar area = x.Match()\n    .With( => .Square,   (Position , double width) =>              AreaOfSquare(width))\n    .With( => .Triangle, (Position p1, Position p2, Position p3) => AreaOfTriangle(p1,p2,p3))\n    .With( => .Circle,   (Position , double radius) =>             AreaOfCircle(radius))\n    .Return();\n```\nIt's still hella-ugly compared to the ternary approach, and that's without\nany predicate functionality!\nHaving spent the past 20 minutes writing this out (and trying to think of\nbetter solutions), I'm definitely erring more towards the position that\nthis is a pointless exercise. It saves effort on generating the initial\ntype, but the cognitive load is heavy and the existing tools for matching\n(the ternary operator) is still more powerful and attractive to look at\n(IMHO). It is also much more efficient.\nThe main issue with the ternary approach is having to manually downcast\nthe type, that will be handled with C# 7 pattern-matching which is due very\nsoon. So I think it's going to be a tough sell unless you can find some\nmagic way to de-ugly all this, support predicates, have completeness\nchecking, and be efficient.\nYour call, but I think it'll be tough!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/pull/154#issuecomment-254580006,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABk1Ci0YsjFcNCoODtU5boYqAiEl9Ij_ks5q1QHugaJpZM4KSPhE\n.\n. Would a syntax like the following meet the criteria mentioned above?\n\n```\nUnion x = 100;\nstring value = x.Match()\n    .Where(v => v)   // This only matches a string type and returns that string\n    .Where(c => c == 100, v => \"Keeping It 100.\") // when the value is 100 this returns.\n    .Where(v => \"Tea?\") // if the previous value isn't a match this.\n    .Else(() => \"Nothing\"); // if nothing else matches this.\nAssert.Equal(\"Keeping It 100.\", value); \n```\nThis enforces that all possible states are covered.  When you provide a matching condition the interface won't provide a way to match the next type or retrieve the output value until you provide a default for that type and the final value is not retrievable unless you provide a default handler if nothing else matches. \nthe following is also possible:\n```\nvar x = new Union>>(\n    new Union>(\n        new Union(\"Test\")));\nstring value = x.Match()\n    .With(v => \"Not This\")\n    .With(v => v\n.       Match()\n        .With(b => \"Not This\")\n            .With(c => c.Match()\n            .With(d => d) // this is the match\n            .Else(() => \"Not This\"))\n        .Else(() => \"Not This\"))\n    .Else(() => \"Not This\");\nAssert.Equal(\"Test\", value);\n\n```\n. I built the start of the example you're describing for a talk I gave a few\nmonths ago.  I didn't use language-ext but it shouldn't be a problem to\nport the code to use those primitives.\nhttps://github.com/sdedalus/FPTalk1\nOn Sun, Mar 10, 2019 at 8:19 AM Ehouarn Perret notifications@github.com\nwrote:\n\nActually, I have some plans to achieve something similar with a relatively\nsimple kata project following DDD.\nI drafted the requirements for a full-stack application below (bigger than\na todo api tho):\nWrite (little) program that shows how you handle the full stack from\nfront-end to back-end.\n\nA user should be able to enter a new flight which has a departure\n   airport and a destination airport.\nThis new flight should be persisted into the system so that it can\n   be retrieved later on.\nBusiness logic should be able to calculate the distance between the\n   two aiports their GPS positions and to calculate the fuel needed for this\n   flight, given the aircraft fuel consumption per distance / flight time +\n   takeoff effort.\nThe program should be able to list the different flights which are\n   loaded from a persistence medium, technology for this can be chosen freely.\nIt should also be possible to edit a flight and persist these\n   changes.\n\nA report page should be included that shows a summary of all entered data,\nincluding calculated data.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/556#issuecomment-471300155,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABk1CtIJTiOiGln8oKRrL1W56Yp5F7kdks5vVQZ1gaJpZM4bJCEk\n.\n. I'll clean that up.  I've adapted this from a personal project that was more or less just to see if I could so I'm actually really happy to fix any issues you spot.   I'll fix that naming issue and I've got some more unit tests to add as well.  this will be in my next check-in. \n. Having written some more tests I realise there is one thing i'm not happy with in my implementation.  Because I implemented it using inheritance for example:\nFor a three type Union\n// public class Union :  Union\n\nThe following is valid\n```\nUnion x = new ItemType3();\nAssert.Equal(\"value3\", x.Match()\n    (item => item.Value)\n    (item => item.Value));\n```\nI think a valid assumption would be that the proceeding would cause a build error since only two of the three items are evaluated.  \nI think my only option for getting the static checking right is to remove inheritance from the equation and directly implement the constructors and value backing fields.  possibly just use a Tuple,Option,Option> etc... for the backing values.\n. ",
    "stefc": "Windows 7 with dotnet core \ndotnet --versions give me the following\n```\nVersion 1.0.0-preview2-003121\nOS Name : Windows\nOS Version: 6.1.7601\nRID: win7-x64\n```\nLanguageExt.Core / .Process package is 1.9.3\nThe same exception I got under a mac \n```\nmacmini:actormodel stefan$ dotnet --info\n.NET Command Line Tools (1.0.0-preview2-003121)\nProduct Information:\n Version:            1.0.0-preview2-003121\n Commit SHA-1 hash:  1e9d529bc5\nRuntime Environment:\n OS Name:     Mac OS X\n OS Version:  10.12\n OS Platform: Darwin\n RID:         osx.10.12-x64\n```\n. Work very good now with netcore ! Thx for the fix. \n. Thanks for your large answer. I think I'll try the first pattern you mentioned (publish, observe). As a future enhancement of your framework I would suggest to make passing additional message context easier (i.g. correlationId). Perhaps it can be a Monad ;) \nThe enhancement of ask in an async way I would not like, because it break's the actor-model. As you mentioned ask is blocking and that is what I not wanted if I use an Actor Model, so there must be another solution for this problem. This also belongs to the sync ask method!\nPerhaps you can mark the ask method with a warning at compile-time (deprecated or something similar) ;) \n. ",
    "MiloszKrajewski": "@Hinidu You are right, but adding IOption<T> (interface) to library won't hurt. You can still use Option<T> (struct) in your signatures if you like.\n. @louthy As I understand your concerns about tri-state value but I have to say say that 'Match' function does not mess with covariance, as both (see below) versions of Match compile just fine:\n``` csharp\npublic interface IOption {\n    bool IsSome { get; }\n    T Value { get; }\n    R Match(Func some, Func none);\n}\npublic static class OptionExtender {\n    public static R Match(this IOption option, Func some, Func none) {\n        return option.IsSome ? some(option.Value) : none();\n    }\n}\n```\nPersonally, I think potential option.Fix() (not the best name, I know) method could help with tri-state problem:\ncsharp\npublic static class OptionExtender {\n    public static IOption<T> Fix<T>(this IOption<T> option) {\n        return option != null ? option : Option.None<T>();\n    }\n}\n. @Hinidu You are absolutely right, It's not null-safe and should be discouraged. Don't use it. Yet, it is there in other imperative-tinted languages for purely pragmatic reasons: java, fsharp, scala\n. ",
    "bbarvish": "Paul,\nI am certainly on the c# side of the world right now, looking to get my \nfeet wet with f#.  I certainly do quite  a bit of interface-based \ndevelopment and your comment struck me as curious.\nCan you recommend a resource (book, web, paper, etc...) that help to \nbetter frame what a well structured f# program looks like so we c# \npeople, who are f# newbies can being to reason about world without \ninterfaces.\nThanks\nboris\nOn 10/17/2016 2:53 PM, Paul Louth wrote:\n\n@MiloszKrajewski https://github.com/MiloszKrajewski As mentioned \nabove it's due to the types being structs to protect against |null|. \nIf you're programming in a more functional style you'd be using \ninterfaces less anyway. Working with data-types that are just like \nproduct types in functional languages (immutable and with no methods \nattached), and static 'module like' classes I see this issue very \nrarely. I do understand it's a pain point however.\nIntroduction of |IOption| won't work for this library, it has its \nown problems, as @Hinidu https://github.com/Hinidu says it turns \nyour bi-state value into a tri-state value (because |null| is \navailable), which kills the entire reason for the |Option| type. It \nalso causes unnecessary boxing. And finally, even a minimal \nimplementation of |IOption| can't be covariant or contravariant, \nbecause at the very least you'd want a |Match| function, which has \nboth input and output arguments:\npublic  B Match<B>(Func<A, B> Some, Func<B> None) => ...\nSo the best course of action is to map using |option.Map(x => x as A)|.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub \nhttps://github.com/louthy/language-ext/issues/161#issuecomment-254314394, \nor mute the thread \nhttps://github.com/notifications/unsubscribe-auth/ADTHxfhNnDtvBm6mdkx1TCsr9Y4AZgsXks5q09ImgaJpZM4KYZnD.\n. \n",
    "gordey4doronin": "Oops, sorry, I see now. Thanks for the answer.\nSo closing the issue?\nUnless you don't want to extract the reactive methods part to LanguageExt.Core.Reactive for example.\nHowever, maybe it is over-engineering and it is more obvious just to install one redundant dependency for consumers of the library (like me).\nP.S. Some preface. I was searching for monads for C# and found your csharp-monad project. Then I discovered this language-ext project, and it looks more complete and useful. So I decided to take monads from here rather than csharp-monads.\n. ",
    "mario-d-s": "Hey @louthy, Language-Ext looks like a great library that I'd like to use, but having to pull in System.Reactive to use LanguageExt.Core is really sad \ud83d\ude1e \nWould you please reconsider externalizing the Reactive support to another package? I'd be happy to help out if you still agree this should happen.. ",
    "jrouaix": "ok @louthy I have tested your 2nd options, working but, if I add a node to the server cluster, I end up having actors spawning and processing the message in both of the nodes.\n\nAlso, I cannot trust the KillAllInGeneratedSpace method to cleanup actors registration because we cannot be sure the node application will nicefully quit or catastrophicaly crash (or just a machine could be disconnected). This is why we should have a process, in charge of cleaning registrations, and a keep alive system from nodes.\nFor example, let's says I want an actor for each house of the world.\n- I want to be able to add nodes in my cluster, and have a elastic resource management (and i'll of course need to provide more nodes for Redis too)\n- When I call the Actor-house42, I don't care on witch node it's spawn.\n- I need an at least once delivery system for messages to this actor\n- if the node on witch the actor is dies, the state of this actor and the message queue, are saved.\n- And so the Actor-house42 should spawn on another node and continue its job.\nDo you think we can achieve that with your library ?\nnotes : I won't use process states to keep my system records as we can't rely on perfect Redis consistancy, I'll use an EventStore to store events, and then load them back to aggregate objects.\nThank you for your answers, I need more time to go deeper in use with your library. I'll post here some more questions about this same topic when they comes if it's ok for you.\n. ",
    "NickDarvey": "Thanks for the response Paul! Exceeept... I'm having trouble picking the signature (and it can't be inferred).\ns is the current state and x is the next, right?\nC#\nstatic Option<Unit> Evalulate(Option<Unit>[] xs) =>\n            fold<Unit, Option<Unit>>(xs, Some(unit), (s, x) => from _ in s\n                                                               from b in x\n                                                               select b);\ntells me that s doesn't implement the query pattern. \nAs an aside, how do you know which style to pick where? I jump between query syntax, fluent and your Prelude class and it never seems as neat as your samples and tests.\n. Perfect, thank you.\nAnd for the good advice too.\n. @louthy Cheers Paul, but that didn't work out. It's still serializing as an array and failing to deserialize back into a Set.\nIn the meantime, converting it to a list does the trick! \n(I'm not sure if supporting DataContractSerialization is within the scope of this project so I'll close this issue.)\n. That is beautiful! (Thank you both.)\nHow long till it makes it's way into the NuGet package?. Okay, I had a brief look into this and struggled to bend to my contractual whim.\nWould you be adverse to exposing Map's readonly value as a private settable like you do with MapItem's key and value?\nAnd also, how the heck does JSON.Net figure get your Map structure out into an array? Does it automagically use the enumerator?\n(As an aside, might it be better if Map serialized as a dictionary rather than an array? Would that be semantically better?). Unfortunately Data Contract doesn't do constructors, but it does private settables.\nThis looks like a headache, I think I might leave this one. (To anyone searching, we ended up including private surrogates in our DCs so that it serialized happily but we exposed it through lang-ext.)\nRE: dictionary vs array, the only time it's important might be where you're integrating with an external API that expects a dictionary and you want to work in the happy land of Map. Though, it's no cost to consume it as an IReadOnlyDictionary at that point, so /shrug.\n. I haven't created anything yet (other than something we slapped together for work) but I'll have a shot this weekend at a decent implementation and let you know how I go.\nWhere is the Try<Task<A>> extension btw?. >So that's what I've done, and is available as v2.0.19-alpha on nuget now.\nBloody hell you are fast. This is fantastic!. Ahah! That makes sense, thank you for explaining it.. Whoa, this is great @louthy. Is this how you use Writer for logging?. You are my favourite. Thank you so much, that's a fantastic solution!. Is there another way I can create a TryOptionAsync when I already have a function that is task-returning (Func<Task<Option<string>>>)?. Closing because there is this a ToAsync :: Try<Task<T>> -> TryAsync<T> here.\nSpotted by @trbngr in #283.. Ah, so I cloned the repo and added a reference to the project from my sample project.\nThis is the line that's throwing. And this is the call stack:\n```\n\nLanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync..cctor.AnonymousMethod__51_0() Line 18    C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Try(LanguageExt.TryAsync self) Line 886 C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync.Plus.AnonymousMethod__0() Line 80 C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Try(LanguageExt.TryAsync self) Line 886 C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync.Bind.AnonymousMethod__0(LanguageExt.Unit ) Line 25   C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync.IdAsync.AnonymousMethod__0() Line 55  C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Try(LanguageExt.TryAsync self) Line 886 C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync.Bind.AnonymousMethod__0(LanguageExt.Unit ) Line 25   C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync>.IdAsync.AnonymousMethod__0() Line 55  C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Try>(LanguageExt.TryAsync> self) Line 886 C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync>.Apply.AnonymousMethod__0() Line 393   C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Try>(LanguageExt.TryAsync> self) Line 886 C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync>.Apply.AnonymousMethod__0() Line 392   C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Try>(LanguageExt.TryAsync> self) Line 886 C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync>.Apply.AnonymousMethod__0() Line 392   C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Try>(LanguageExt.TryAsync> self) Line 886 C#  Symbols loaded.\n    LanguageExt.Core.dll!LanguageExt.ClassInstances.MTryAsync>.Apply.AnonymousMethod__0() Line 392   C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Try>(LanguageExt.TryAsync> self) Line 886 C#  Symbols loaded.\n    LanguageExt.Core.dll!TryAsyncExtensions.Match>(LanguageExt.TryAsync> self, System.Action> Succ, System.Action Fail) Line 319 C#  Symbols loaded.\n    ConsoleApp13.dll!PlzHalpPaul.Program.Compute(LanguageExt.TryAsync> numbers) Line 22  C#  Symbols loaded.\n    ConsoleApp13.dll!PlzHalpPaul.Program.Main(string[] args) Line 13    C#  Symbols loaded.\n```\n\nI'll keep poking around!. Thank you for the detailed explanation and the addition of SeqTrans!\n\n\n...isn't what you'll get. Calling Sequence on a TryAsync> that's in a failed state will return an empty IEnumerable>. If you then call Sequence on that again then you'll have a successful TryAsync> where the inner IEnumerable is empty.\n\nAh, damn. Yes, that makes sense. I think I'll change my approach then!\n. >however I was expecting the\ncalls to the lambda to only occur during construction, regardless of\nwhether it's created eagerly or lazily\nI think the main thing with laziness is there is no construction. That LINQ isn't constructing anything except for an expression of the computation you'd like to run.\n(Which is great because you can do things like Enumerable.Range(0, inf).)\nThis is less about having immutable data structure but having an immutable computation (LINQ query). Right now, your computation mutates every time it's executed.\nYou need to make sure you don't introduce any side effects into the computation if you want the same result every time it's executed. Otherwise, execute the mutable computation once with the results going into a list (or into one of the System.Collections.Immutable data structures if that's important).\n. Ohh, ok. Interesting! Thanks for explaining.\nI'm pretty sure Seq works like that, if it helps.. ",
    "StanJav": "\nHow quickly do you need it?\n\n@louthy This year please.. Hi @louthy , could you please build a new version of lang-ext? . Do you plan to fix it? . You can write also this: \nvar val = from c in d.c\n          from b in c.b\n          from a in b.a\n          select v in a.value\n          select v;\nAt least it looks a bit better.\n. Ah... yes, thanks @bender2k14  . I will close this one. . Done.. Done.. Done.. Copy & paste  issue. Done also for the existing Distinct and Exists.. Copy & paste  issue. Done also for the existing Exists.. ",
    "shmutalov": "Ping. ",
    "Micha-kun": "i fixed the code with more \"monadish\" style.. It's already separated? It's good news to hear! :) I think my confusion comes from NuGet package description of LanguageExt.Core:\nThis library uses and abuses the features of C# 6 to provide a functional 'Base class library', that, if you squint, can look like extensions to the language itself. It also includes an 'Erlang like' process system (actors) that can optionally persist messages and state to Redis (note you can use it without Redis for in-app messaging). The process system additionally supports Rx streams of messages and state allowing for a complete system of reactive events and message dispatch.\nIs that ok?. ",
    "leandromoh": "@louthy  no problem. thanks for the explanation. sorry, the PR was submitted for the wrong branch. so i canceled it and i will re-create it for the right branch.. ",
    "jonschoning": "I see. Thanks..\nThis is a side node, but looking at\npublic static MB apply<MONADAB, MONADA, MONADB, MAB, MA, MB, A, B>(MAB x, MA y)\n            where MONADAB : struct, Monad<MAB, Func<A, B>>\n            where MONADA  : struct, Monad<MA, A>\n            where MONADB  : struct, Monad<MB, B> =>\n            default(MONADAB).Bind<MONADB, MB, B>(x, a =>\n            default(MONADA ).Bind<MONADB, MB, B>(y, b =>\n            default(MONADB ).Return(a(b))));\nI see that using apply implies a Monad constraint.  This may work for those Applicatives which are also Monads, but it reverses the dependency.  Applicative should not require Monad; sometimes you cannot make something a Monad, but you can make something an Applicative (i.e. there are more Applicatives than Monads).  For example, AccValidation has a nice Applicative Instance but it cannot be made a Monad in any way that makes sense \nhttp://hackage.haskell.org/package/validation-0.5.4/docs/Data-Validation.html#t:AccValidation\n. Ah, ok!. ",
    "StefanBertels": "1.9.x\nCode snippet is taken from master branch.. Thanks for very fast answer and for this fantastic library.\nYes, I already switched to Set for key types like int. There are some HashSets left with case-insensitive string keys (e.g. filenames).. Thank you for fast bug fixing!. Hi Paul,\nok. I understand your motivation and agree that LanguageExt supplies the better Collection types. I'm just not sure whether this namespace conflict will help people converting. You now have to refactor your classes if you need/want co-existence. Just a note -- it's not a problem for me.\nI wondered because the list type is named Lstand only the Prelude has a List factory (which does not conflict with new List() of Collections.Generic) -- whereas the hash set now uses HashSetas type name.\nDo you plan to change Lstto List, too?\nAnother thought on this: Methods like Add or Contains tend to have the same signature for G.HashSet and your HashSet-- but different behaviour. If you change an existing code-base by just changing the using directive, a line like:\nmyHashSet.Add(...);\ndoes not work as (originally) intended with your immutable HashSet(return value unused). Different type names would avoid \"auto-converting\" methods that use HashSet in signature (without fully qualified namespace). \nIf I think about this more, it might even be safer to not solve conflict by using G = ... but to fully qualify all usages until Collections.Generic is no longer used in class.\nAnyway: \nI agree that type names like HSet, Lst etc. are ugly. So this is just a comment -- I don't have a better idea and can work with either way.\nThank you again for your great lib.. related to #118 . I don't see a general difference between List, Stack, Queue and HashSet here. \nI saw you added it later (see #111) but I don't see a difference in principal.\nCurrent naming feels a bit arbitrary. I don't blame you. Naming is hard -- and this special problem is very hard. I suggest to strategically decide which way to go. Currently a (breaking) change in v2 won't hurt that much.\nI really hope you will get more users, so a breaking change will hurt much more later.\nThere is probably more work to be done when switching existing code completely away from Collections.Generic than with something like changing Lst to List.\nIf you feel bad about using List maybe this is a reason to avoid naming collision (follow the ugly path).\nOr do you think HashSet is much less important and conflicts there are (much) more acceptable?\nThe ugly path would introduce the next ugly question: Should it be var list = Lst(1,2,3) // Prelude?\nThere seems to be no technical problem, mixing Lst struct with List method works ok. But feels a bit strange (until one sees the reason).\nI think there is a high value with collision-free usage. Will be easier for users to introduce your lib step by step in practise.\nHmm. \nI'm ready for change and use the nice names everywhere -- removing System.Collections.Generic.\nSide node \"Array\": \nThere is some other collision with System.Array. I just found an old method of mine with Array.ConvertAll and Array.FindIndex in my code. The compiler complains that Array is a method as found in Prelude (\"Cannot choose method from method group\"). The message gave no hint that there is a System.Array class...  Maybe those static methods won't be used that often -- I personally would writer \"better\" code today.. This is really great! Thank you for this good designed and fast solution.\n. Just a note: maybe having a custom ContractResolver might help with Json.NET (http://www.newtonsoft.com/json/help/html/ContractResolver.htm). I think this could result in a helper lib making e.g. NumTypes compatible with Json.NET (and maybe have Map as dictionary, too).\nSolution would be without Json.NET attributes, but you would have to set this special JsonSerializer / JsonSerializerSettings in the application code. Perhaps generic NumType etc. need some common interface for detecting it (xy is NumType). Don't know if this is enough (and boxing/unboxing can be done using [Serializable]).. Note: Does not work out in practise by simple combining packages (not that I really expected it working...)\n\nAn unhandled exception of type 'System.TypeLoadException' occurred in LanguageExt.Process.dll\nAdditional information: Could not load type 'LanguageExt.EnumerableExtensions' from assembly 'LanguageExt.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null'.\n. Thank you for fixing this very fast!. I thought about StreamReader. Compare\nhttp://stackoverflow.com/questions/1065168/does-disposing-streamreader-close-the-stream\nBTW: StreamReader has an optional constructor parameter to disable it (bool leaveopen).\n\nWhy not see Option as owner of T here (in the same way StreamReader does with its Stream)?\nIs this just another point of view or is this (ownership) itself a bad idea for Option (and similar types)?\nI mean: Dipose (or using) on an Option itself does not have any use case because Option itself does not have any resources. So one obviously would like to Dipose the contained value (if Some).\nAnyway: I'm fine with your decision, to not change this. Maybe there are other use cases against it.. Just some note:\nIDisposable on a struct has its issues...\nAnd this article by Eric Lippert shows that it works some way.\nI'm not sure but as far as I can see making Option IDisposable should be ok because you have to call Dispose() by intent (directly or by using). So nothing bad happens for normal use cases. And a simple using construct should work as intended.\nBut if we see Option as a container (a list of at most one element) making Option IDisposable seems questionable. (But maybe disposing a container should just mean dispose all elements.)\nAnyway: IIRC the reason for this feature request / question was that your echo lib diposes state objects if they are IDisposable and if you had Option<T> as state object with T being IDisposable you probably need some solution (or not use Option there).. I opened this issue and I wasn't sure whether it is really a good idea. But after todays comments I think @louthy wrote some good reasons why Option can be IDisposable. ACK, so far. Comments by @bender2k14 didn't show me a good reason against this. \nBut maybe I'm missing a point -- and I'm still interested whether there could be real practical problems with this and I'm open for any theoretical discussion how things should be.\nI have to say that I avoid dependency injection and try to solve this by writing side-effect free code (static pure functions) where possible. But currently I don't see the point where Option.Dispose() would really harm.\nIt might be a good idea for you (and others) to have some IDisposable \"graph\" and \"ownership\" pattern, but how is this exactly related to Option.Dispose()?\nYes, everyone having a ref can call Dispose() and this might be a problem in some scenarios.  But if you want to enforce this you might have to add some wrapper (something like decorator reversed / adapter) and have the outside object NOT implement IDisposable while giving some special access to the inner IDisposable object (e.g. to your parent object). If you just wrap some IDisposable with Some(...) everyone having a ref to this Option can dispose the inner object anyway...\nAnd there are other patterns to Dispose correctly, see for example: https://msdn.microsoft.com/en-us/library/system.reactive.disposables\nI really have use cases for at least an disposable Option. It's not only making using/use work again with Option allowing for cleaner code but about every code that creates Options with contained Disposables (e.g. echo library actor setup function).\n(Just for the record: I don't think IDisposable and all those finalizer things are good design, but it's the way it is in C#/.NET). https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/dispose-pattern says:\n\nimplement the Basic Dispose Pattern on types containing instances of disposable types. IMO the point is:\n\nDoes Option contain the inner object or does it just refer to it. It depends.\nMaking Option IDisposable will allow outside code to dispose it in case it contains inner object. You don't have to call Dispose if you don't want to.\nBesides the fact that use/using code will be possible, I see two more advantages:\nIf you have some factory it's straight forward that the factory returns an IDisposable (or compatible) if someone should call Dispose later. Having Option non-IDisposable will hide this fact for optional return values. This is a problem for generic code. Look at echo actor setup (example): echo calls factory (setup) and therefore owns the returned object. If your setup returns Option you have a problem.\nAnother (minor) point is that Option itself could throw errors if you call some method after Dispose().\nI don't see a practical problem with IDisposable for those cases where your inner object isn't IDisposable or should not be Disposed.. Why should a user write code like your ToAsyncUsing?\nThis isn't limited to Option. If you decorate some Stream ref or do other transformation on any IDisposable obj you won't dispose it in that operation, either.. Static analysis cannot be perfect, I think proof for this is similar to that of Halt problem. Just to add some theory pence here ;-) It's not impossible to limit analyzer so it only warns about relevant missing Dispose calls (i.e. Disposing container might not be necessary if inner object is disposed in some other way). But I admit this might be a workaround...\nYes, IDisposable has it's problems, in practise, too. Think about a StreamWriter that (by default) owns a MemoryStream. Disposing MemoryStream is not necessary (no unmanaged ressource). If StreamWriter does not own Stream, why do we need to Dispose it? (Yes, Flush, but: Autoflush) Might be a bad example but in C# we probably will end in similar situations because of abstract types. \nAnyway: I see demand for Option.Dispose() just because Option should be usable like a container that really \"owns\" the value AND generic code that does rely on is IDisposable shouldn't break.\nAnyway: I value your arguments because I think this library shouldn't go into some \"wrong\" direction. I'm sure Paul takes all issues into account to make this library as useful as possible.\nEveryone have a good start into 2018!\n. @bender2k14\nI don't think you need state or side-effects for Halt Problem... ;-)\nIMO: Immutability is not a problem. The problem is we have copies of references to the same object. Which reference is \"master\"? There is no such ownership flag in C#. Would be great if we had something like this because then compiler could call Dispose automatically if scope of \"master\" reference ends.\n@faeriedust \nWe don't know whether an arbitrary Option is owner of inner disposable or not. Depends on context.\nThe issue here is: If Option is owner of some Disposable, then Option itself should be IDisposable.\nThere is some practical value because if Option is not IDisposable, you cannot use it in code like echo actor (return type of setupFn = state). And of course using/use in combination with such Option.\nI don't see a problem with @faeriedust example because it depends on users code whether Dispose on Option will be called. You only call Dispose() on Options that are owner.\n\nOption<> here is pretty clearly not the owner of the inner service\n\ngets wrong if you add this line of code:\nvar x = _MyMethod(Some(new OuterService { InnerService = CreateSomeDisposable() }));\nAdmittedly the drawback of IDisposable Option is that we will create objects of type Option where we won't call Dispose() because this option is not or is no more owner of the inner object of type T.\n. Yes, my one line call to _MyMethod is bad style -- was just an example for something where the reference to some IDisposable is passed/wrapped. Yes, there are workarounds for e.g. echo actor. I already have some workaround. Thank you for trying to find solutions for me, but this point is more about a generic solution in LanguageExt.\nI don't think this is an actor issue or an issue with my very special use case. I personally use Option as replacement for refs that can be null (None), so I would need more workarounds when making more heavy use of LanguageExt. How about using/use (see Pauls writing above)?\nIMO there is no mutability or security issue: Option does not ensure that the inner object is immutable.\nOption does not disable possibility to dispose inner object. Having Option.Dispose() won't change something here. I'm interested in examples showing I missed a point.\nI still see the drawback for analyzers / about principle to dispose every IDisposable somewhere.\nBut why do you think a ResourceOption (or better DisposableOption) is something bad?\nThe point to put this directly into Option is just a question whether this is more practical. Probably it would be better to have different types (Option and DisposableOption) and ideally being able to shift between them / shifting the \"master\" flag of refs between them.. The issue is about the request to have Option IDisposable. It was clear from beginning and written multiple times here that this will make things better in some way and worse in others. @louthy pointed at some positive effects. We discuss and bring arguments together. IMO: This issue is not an easy one to decide.\nI'm really open to arguments, but we should discuss whether they hold or not. Those arguments about principle / analyzers hold, but Paul already mentioned that there is no real concept (or at least a broken one) for IDisposable at all. Lifetime management has to be done by developer and there are different methods to manage ownership.\nSide note: If you compare C# 8 (?) solution for nullable references: LanguageExt provides a very nice way to deal with null (hey, Option again) and we hopefully benefit by new default that refs shouldn't be null at all (or have to be explicity marked). Compare this to how this is solved in C# by static analysis that will be imperfect (missing warning) and even produce false positives. I like ReSharper and all those analyzer help, but I don't see it as a primary tool. It's similar with testing: Good design might reduce need for testing.\nI feel that you want to just stop this request / do not respect positive outputs. But IMO some arguments are wrong (like mutability) and others depend on coding style / design. Regarding dependency injection: This is some solution to a specific problem in OOP. But we can change design to avoid this. I don't suggest to drop DI (maybe you should think about it ;-)). Anyway I currently cannot see a specific problem there. If you give some example to show problems with disposable Option we could evaluate pros and cons.\nProbably @louthy has a good overview whether this change (or some DisposableOption) would in summary be an improvement for his library and code using it. I'm grateful for this library and have a lot of confidence in his wise design decisions.\nIMHO there is still a lot of value with disposable Option because we could make code easier to write and to read with using/use and reduce overhead we already put into our C# code by using the library.\nIt will be interesting to read what Paul says about DisposableOption. Would this integrate into LanguageExt or cause even more overloading problems?. I hope you accept that I respond on your general points about DI for now -- as long as there is no special issue with IDisposable here. If there is, please just add example here. I'm not interested in breaking code of people using DI. (And yes, thanks for the links, I already tinker with functional solutions for dependency problems like Free Monads...)\nLet's go back to this specific issue. I really hope nobody is annoyed by this lengthy discussion but at least we address this from different perspectives and we learn more than just what Option should be.\nTo address your argument \n\nImplement IDisposable only if you are using unmanaged resources directly\n\nregarding\n\nIDisposable specification\n\nI think IDisposable is used (and can be used) for managed resources, too. If you have unmanaged ressources, you probably need Dispose(bool disposing). \nResharper's way to build Dispose pattern is this one: https://www.jetbrains.com/help/resharper/Code_Generation_Dispose_Pattern.html\n(Seems this pattern does not implement Dispose(bool disposing) for unmanaged-only case...)\nAnyway my use case here is something that might be constrained (exclusive lock on file, opening exclusive tcp port, making sure only one instance is running ...) but I don't have to deal with low level objects (GC related unmanaged code like win32 calls).  Compare e.g. Reactive Extensions (Observable subscriptions). \nSummary: IDisposable is a solution for lifetime management for anything that explicitly needs to be disposed.\nTo get back to specific issue about Option<T> is IDisposable being a good or bad idea: Do you really need to call Dispose() on any disposable object?\nhttps://stackoverflow.com/questions/13459447/do-i-need-to-consider-disposing-of-any-ienumerablet-i-use \n(This is related to https://github.com/louthy/echo-process/issues/27 a little bit).\nRegarding static analysis. Every line creates some IDisposable object:\nvar bla1 = new[] {12, 23, 34}.Select(identity);\n            var bla2 = new MemoryStream();\n            var bla3 = bla2.GetBuffer().Select(i => (int) i).GetEnumerator();\n            var bla4 = new FileStream(@\"c:\\tmp.tst\", FileMode.Open);\nResharper only warns about bla3. Only bla1 has to be casted to IDisposable to call Dispose().\nhttps://stackoverflow.com/questions/101664/can-resharper-be-set-to-warn-if-idisposable-not-handled-correctly\nI really would regret this change request (Option implementing IDisposable) if it practically would result in inspection warnings that are active by default in Visual Studio and/or ReSharper. (Yes I care about other analyzers, too, but that's more about appreciation of values.) And I'm sure even though LanguageExt \"misuses\" some C# features for the good, Paul wouldn't like that, either.\n. > Using IDisposable.Dispose to free managed resources is just an optimization\nI disagree. Objects might be \"active\" (pushing messages) and you need to stop/unsubscribe (e.g. observables).\n\nI slightly misunderstood the linked SO question. Just because a type could be cast to IDisposable doesn't mean that it should be. Ideally casting is never needed. If some piece of code doesn't know at compile time that some object's type implements IDisposable, then this is a strong indication that this piece of code should not be responsible for managements of this object's lifetime.\n\nDoesn't that contradict what you suggested in https://github.com/louthy/echo-process/issues/27?\nIMO this is an appreciation\u00a0of\u00a0values (as this Option.Dispose() request): Is it better to have the ref your in your code IDisposable or not when it (or something it contains...) might have to be disposed.\n@louthy uses the is IDisposable check for state in echo -- probably because this is the only way making this work without limiting state ref type to implement IDisposable.\nStream is similar to some Observable subscription: Maybe there is a need to Dispose (FileStream), maybe GC is enough. You don't know in general by the ref type you use in your code.\nFor Option: I really think it is clear that you don't have to call Dispose on this (or use using) just if you create or copy some option (passing the inner value around). It's IMO quite obvious that Dispose() always targets the inner value. If your inner object is IDisposable you have to care of it's lifetime and Option.Dispose() is just a proxy call.\nIt's nice if some technical inspection could verify correctness, so I agree to your \"preferred world\" in some way. But it's nicer if code is easy to read and e.g. making Option available for using would help there. And finally it's unclear what analyzers can do today or in future and IDisposable concept is unsatisfactory in some ways we cannot fix. I currently don't see that we would make that worse in reality.\n@louthy: Just a thought -- would it make things better (or worse) to allow use to be called on types that are not constrained to be IDisposable and check for is IDisposable on runtime? Might be some mitigation...\n@bender2k14 Regarding your last question: it does not compile for the same reason\nOption<int> myOption = 5;\n            OptionAsync<int> myOptionAsync = myOption;\ndoes not compile. I don't see your point. Despite casting error: no line in your code disposes the disposable, regardless of the change this issue requests. So there might be leak but luckily your CompositeDisposable is empty .... ;-) \nWhat do you think should be the state here?\n. Ah, just found something:\n```\nusing static LanguageExt.TypeClass;\ncompare(a, b);\n```\n. @louthy Do you think you could/would reopen this feature request?\nI think it's quite useful to have som case-insensitive string type: \npublic class MyType : NewType<MyType, EqStringOrdinalIgnoreCase, string, StrLen<I1, I400>>\n{\n        public MyType (string value) : base(value)\n        {\n        }\n}\nor\npublic class MyType : NewType<MyType, EqStringOrdinalIgnoreCase, string>\n{\n        public MyType (string value) : base(value)\n        {\n        }\n}\nI just stumbled upon a typical comparison bug so having this feature would be great.\nI looked at source and found some EqNewType with similar type definition. But as far as I understand it's a struct with some helpers for equality check -- NewType<...,string,...> is effectively using default EqString (including assembly type search). Creating some custom EqString class  is no option for me, I don't want to change all string comparisons or something like that.\nMy current workaround is adding this to MyType:\n```\n        public override bool Equals(MyType other) => this == other;\n    public static bool operator ==(MyType a, MyType b) =>  ReferenceEquals(a, b) || (!ReferenceEquals(a, null) && !ReferenceEquals(b, null) && EqStringOrdinalIgnoreCase.Inst.Equals(a.Value, b.Value));\n\n    public static bool operator !=(MyType a, MyType b) => !(a == b);\n\n```. my 2 pennies:\nBeing explict (e.g. FindMatch) has advantages:\n\nIt's easier to understand. Semantics defined by function name, not by signature.\nimproves type inference\nmakes learning functional programming easier because you can see that your using a composition (short cut) function. \n. Hi Paul,\n\nI did some small experiments, current state can be seen here: https://github.com/StefanBertels/language-ext/commit/2974a7a5ff0d5c55d29080ed2bac298427f58dbf\nThere are multiple ways we can go and I'm not happy with any of them. Maybe I'm missing something.\nTwo side notes:\n- I'd (still) favor having another name for Find function with built-in match (see discussion above).\n- Maybe even multi level find could get another name, making multi-level access more visible.\nBoth things are just a matter of taste.\nNow for the real thing:\nIt's probably easy to create multi level Find for each existing type itself, meaning we would have Multi-Level find for nested Maps with ORD on every level. But then we would have many types that would not get some nested Find function just because they don't have same properties. This does not only apply to Map and Map but also to HashMap and HashMap.\nWould be quite useful to have multi level find for any combination of them.\nMaybe one solution is to create some code generator producing every combination up to level n (e.g. n=5). I didn't write tt files before but I don't like this solution. But should work.\nAnother solution I tried is to have some new interface Searchable (Findable / TypeWithFind) that could enable any type with some Find method for multi level find. I fiddled with this in my experiment commit.\nNice thing is, we only need to implement one extension function per supported level.\n(Really) bad thing is that type inference doesn't work which makes it quite ugly (useless) in practise.\nI fiddled a bit with making some covariant interface (see code), but probably I don't understand enough how things work here -- seems this doesn't help here.\nAnother thing that came to my mind is that it might be an acceptable solution to have some fluent interface for multi level find (again see code snippet in commit). But I didn't get something working here yet. My goal was to add some ThenFind function for every Option> (and HashMap<...>) that would allow: multimap.Find(key1).ThenFind(key2).ThenFind(key3)\n(Unsure whether ThenFind should be named Find, probably not because it combines Bind+Find.)\nAny ideas for some solution that is usable in practise? Or should I try to create some code generator?\n. Thank you.. I really appreciate this libary and Pauls effort, so please treat my comment just as feedback / some opinion. And by listening to it, discussing it, or just answering it in some way (closing is valid) more things get clear (like design decisions).\nThat said: From my point of view I would suggest to move it to a different class (namespace). This is a breaking change but I guess measures collection is not used that widely AND this will break on compile time AND it can be easily fixed by adding one line using static LanguageExt.Measures.\n@jeremysmith1 is right with \"add unit tests\" helps, but he is even more right with \"stuff happens\". Anyway, I think LanguageExt helps reducing bugs because many things get explicit and are typed and move problems from run time to compile time -- which is a very big benefit. This reduces the need to (unit) test which is a good thing. HashSet is a great example making Equality more safe, of course Option and all the other great types help, too. And measures and newtype derived custom data types are even more examples.\nThe issue is really not about types but more about scope (which name is valid, priority) and in theory there is nothing wrong with the current library design. But this is a practical issue that might cause bugs. The using static feature makes this more relevant (Extension functions do something similar). But adding lower case items to the scope (by using static) makes this significant worse because lower case names are widely used for local variables and parameters and are sometimes not constrained (type/signature) resulting in no compiler but a runtime error.\nBesides string interpolation the issue may arise when using var or dynamic or when using generics. I agree that avoiding dynamic is a good idea (I only use it e.g. for late binding old COM objects) and var and generics use might result in subsequent compile time errors. I'm not aware of other relevant problem fields here. But this is some potential cause of bugs that maybe just can be avoided.\nAnother thought: There are other parts of LanguageExt that need separate using lines, this is from the code file I just opened:\nusing LanguageExt;\nusing LanguageExt.ClassInstances;\nusing LanguageExt.TypeClasses;\nusing static LanguageExt.TypeClass;\nusing static LanguageExt.Prelude;`\nMight be more convenient to reduce this prologue to one or two lines but seeing this issue I would tend to be more explict and include more using lines if this reduces naming collisions and bugs like this one.\nLast thought: The problem for me just arised because of moving code around. day was defined in the source scope (I think it was a parameter) but not in the target. There might be another common source for this kind of error: if you don't write your code in a linear way but let it evolve -- e.g. writing code using a local variable before defining it. Might be a personal style thing, I think it's more about using the right or left part of the brain or being more intuitive or sensing.\nThanks for listening, I'm happy with any outcome.. Nice, will completely solve my use case.\nDo you think this should / could be added for comparison, too?\nThis would be not as easy for JObject because there is no comparer equivalent to JObject.DeepEquals AFAIK. (And I personally don't need comparison.) Just for completeness...\n. I'm not getting the desired result with EqJObject : Eq<JObject> in my project targetting netstandard2.0.\nSeems equality operator does not use EqJObject.Equals.\nI read about ClassInstancesAssembly.Register in https://github.com/louthy/language-ext/releases/tag/v2.1.14 -- is this necessary with .NET Standard 2.0?\nMy project file\n```\n\n\nnetstandard2.0;net462\nwin10-x64;win-x64;win\nMyProject\n\n\n\n\n\n\n\n\n``\nI want to usenetstandard2.0. I addednet462so that test runners can run my xunit test (included in project). At leastdotnet xunit` and NCrunch work now (by running tests for net462).\nBut the test fails.\nIf I add ClassInstancesAssembly.Register(typeof(EqJObject).GetTypeInfo().Assembly); build fails: Register seems to be defined in netstandard2.0 but not in net462.. Ok, it will compile with\n```\nif COREFX\n        ClassInstancesAssembly.Register(typeof(EqJObject).GetTypeInfo().Assembly);\n\nendif\n``\nBut that does not help because test is running onnet462`..\n. Note: I removed target netstandard2.0 and for now just go with net461 in one project. \nBut EqJObject (your suggested solution for 2.1.14+) does not work (for me):\n```\npublic struct EqJObject : Eq // without namespace\n{\n    public bool Equals(JObject x, JObject y) =>\n        JObject.DeepEquals(x, y);\npublic int GetHashCode(JObject x) =>\n    x.GetHashCode();\n\n}\n```\nMy test:\n```\n        public class MyClass2 : Record\n        {\n            public JObject Json { get; set; }\n        }\n    [Fact]\n    private void TestEqual()\n    {\n        Assert.Equal(new MyClass2\n        {\n            Json = new JObject(),\n        }, new MyClass2\n        {\n            Json = new JObject(),\n        });\n    }\n\n```\nThis test is fails. What's going wrong?\nI use LanguageExt.Core 2.1.21 and Xunit 2.2.0.\nSide node: \nAssert.Equal(new JObject(), new JObject());  // success because Xunit has some permissive logic, trying to compare by using IDictionary, IEnumerable interfaces etc.\n            Assert.True(new JObject() == new JObject()); // fails\n            Assert.True(new JObject().Equals(new JObject())); // fails\n. Hmm. Just pasted my code above into a small console app (net462) with LanguageExt 2.2.27-beta and my test still fails. Looks like methods GetHashCode and Equals of EqJObject don't get called when running my test.. Thank you for explanation, very helpful!. After thinking a bit more I would suggest this general rule:\nMatch should just do list size pattern matching.\nParameters hould have names like empty, oneOrMore resp. empty, one, twoOrMore.\noneOrMore and twoOrMore should always get the full list (every parameter gets it).\nMaybe it's ok to allow variant Func<T, Seq<T>, TResult> oneOrMore but I find it more clean to do deconstruction afterwards. It's not clear whether Func<T, Seq<T>, TResult> is more appropriate for oneOrMore (head and maybeEmptyTail) or twoOrMore (head and tailWithAtLeastOne). If you really think deconstruction should be done in 'Match' I suggest to make parameter name very explicit here or even better name this special 'Match' function different (MatchAndDecons).\nBTW: Is there a separate Decons function that turns Func<Seq<T>,TResult> into Func<T, Seq<T>, TResult> (resulting in an error if seq is empty)?\nRegarding twoOrMore there might be even a DeDecons function turning Func<Seq<T>,TResult> into Func<T, T, Seq<T>, TResult> (resulting in an error if seq contains 0 or 1 elements).. I will now close this issue because\n- this isn't a bug and\n- I became accustomed to it\n- I'm sensitized for different variants\n- I try to avoid the IMHO potentially misleading variant where the third parameter is xs => ... (missing head) and use only the signature with (x,xs) => ...\nI still would favor if the IMHO potentially misleading variant would be more clearly marked (obsolete, editorbrowsable(never)...) but doesnt' really bug me anymore.. Still a question (just for understanding how things could/should be):\nShouldn't this\nvar r = list.Match(\n    ()      => ...,\n    x       => ...,\n    (x, xs) => ... );\nbetter be like this\nvar r = list.Match(\n    ()      => ...,\n    x       => ...,\n    (x1, x2, xs) => ... );\nbecause the more case always has at least two elements and xs as a type (list/sequence) in general could be empty. (Of course that means you would need x1.Cons(x2.Cons(xs)) to get back the whole sequence).. Ah, an important note: My patch changes behaviour of HashSet! By default duplicates will just be ignored now. I just replicated behaviour of Set. Maybe you want to raise errors for duplicates by default?\nAnyway: I would expect same behaviour for HashSet and Set.. Some more thoughts on general design regarding HashSet/Set and duplicates. (Note: I think HashSet and Set should behave same way. Maybe this is related to HashMap, too.)\nThere are some options to create a Set like:\n- Map\n- Bind\n- IEnumerable constructor\nShould Map, Bind and constructor use Add() or TryAdd()?\nI personally like the more strict way to use Add because this will uncover errors instead of silently dropping elements. AFAIK you use this in Bind and Map.\nConstruction Set using an IEnumerable is similar. We could be strict here, too. But this would in fact result in uncovering errors or forcing the caller to use Distinct() before. The latter isn't possible if IEnumerable constructor is used by some other libraries for deserialization (json). So you would force to have the input to be distinct. This would mean: use Add everywhere (would change Set constructor behaviour).\nBut you could see it the other way, too: If data type is something like Set then it's likely that the caller would want to implicitely Distinct here -- if he doesn't want the operation to validate input. I think validating input wouldn't be best style here and I guess there are many use cases where it would be a nice shortcut to just call Map/Bind/constructor with implicit Distinct functionality. You might see this as something similar as GroupBy. Example: you map (a set of) vcard entries to a Set of city names by giving _ => _.City as mapper function.  Just a thought.\nIf Map/Bind are strict and constructor is not (current behaviour for Set) comments should make this clear and other functions should be checked for consistency (toSet(...), Set(1,2,3,1)).\nJust some thoughts. What do you think? Anyway we should add some test cases to make sure behaviour is consistent and doesn't accidentally change later. Let me know if I should write some.. Thanks for giving details!. https://github.com/louthy/language-ext/blob/master/LanguageExt.Core/TypeClasses/Ord/Ord.cs. If someone is interested: read about upcoming C# feature here: https://github.com/dotnet/csharplang/blob/master/proposals/default-interface-methods.md. Thanks. I agree. Just one point: I suggest returning first element on equality always. (stable order). I know of this technical reason, especially having non-null default for struct.\nBut why is Bottom used in a conceptional way? There are structs with a natural bottom state (Option etc can be OptionNone etc.). Why not make default(OptionResult) := OptionResult.None and drop all bottom/IsValid code?\nOk, types without natural None state need to be checked for invalid (default) state. But why not fail fast (throw exceptions) when calling them? Currently seems like the bottom state is handled different, resulting in Match(...) to proceed but e.g. run something on an invalid state. Why not let Match throw exception fast? \nIs there a reason to pass invalid values around? \n. Ok, thanks for clarifying.  I'm a bit sceptic whether making every default struct invalid is very practical. \nWill this really apply for every struct? What about container types like List, what about Option? AFAIK those types currently (master) have some decent default like empty or None.\nA had a look at async-refactor branch. Currently it doesn't look like this change already happend everywhere. If I read this correctly then default for Option types is still mapping to None.\nAnother point: \ncode of Result has this line\npublic static readonly Result<A> None = default(Result<A>);\nShould this be renamed to Bottom to clearly separate invalid states from regular None states?\nCan you or Paul say something about this issue regarding roadmap (really for every struct?) and maybe about compatibility? Normally I don't try to use default for this but I remember I used it somewhere... probably for some default method parameter for some Option like this:\nMyMethod(...params ..., Option<string> optionalText = default). Just had a short look at async-refactor: I see changes, better code, might fix some bottom case. What is conceptionally different to master?\n@louthy: I think  public static readonly Result<A> None = default(Result<A>); should be removed or changed. default is Bottom (identically declared below). None should be Option.None (=> success state). IMHO.\nI'm not sure whether OptionalResult should default to Bottom (i.e. \"have\" bottom). Why not default to Option.None here (success with None value)? Of course one could argue in different ways. Maybe OptionalResult is conceptionally more like Option> (this means Option.None is natural default) or more like Result> (current implementation => Bottom). If this is indifferent, why not favor the case where we can throw away invalid states in as many structs as possible (favor natural defaults when they do not harm)?\nAnother question: I understand (and guessed from code anyway) that OptionalResult should not be data types I create in my own code as I do with Option.\nYou say: use TryOption. But that's a different thing because TryOption is Func and I'm looking for a return type for my own function that returns exactly something like OptionalResult.\nHow can I replace that by TryOption? I could create a TryOption in my function and directly invoke it to create an OptionalResult typed return value. This still means I'm using OptionalResult in my code and just avoid that I call wrong constructors of OptionalResult itself.\nThis probably is not what you wanted to say by \"use TryOption\". Could you clarify?\nThe nearest thing I could imagine is: I could use memo in combination with TryOption to define somthing that at least guarantees that the inner function is called only once.  But I would prefer classic way and just pass values around...\nEither comes to mind, of course. But Result and OptionalResult are more exact fits here because I just want to make explicit that Exceptions are catched and then returned in clean way -- ideally compatible with all your great LanguageExt things...\n(Same for Try / Result, of course.)\n. OptionalResult: I'm totally ok with this, won't use it anymore. (IMHO you realky should avoid \"None\" as name for bottom default state).\nUsing Tryoption means: I should pass a func instead of a value. It will work but my use case was a little different: I didn't need the comfort on construction (exception catching) but the expressiveness if the return value (value or exception).\nI will use Either (or Validation) in those use cases. Makes a little more noise for Validation but that can be reduced by my own match extension if necessary.\nFor breaking compatibility: Don't know about other users but I think you still can break minor functionality like this if it helps others.\nOf course it is nice to deprecate things first and wait before removing interfaces. But if compiler will throw errors I'm fine with it.. @louthy Sorry, I really didn't check the latest code. None is indeed well defined and have OptionalResult conceptionally behave like Result is fine (i.e. default = bottom).\nRegarding TryOption: I checked out TryOption(123). I probably missed the point that I can directly use TryOption as type and e.g. directly call Match on it. And I missed the point that I can construct a TryOption by giving it some value or none or even some exception value.\nSo I'm perfectly happy with construction.\nI used OptionalResult because I have a value (some/none/exception) and just wanted to pass this -- conceptionally equal to Option without that third exception state.\nSo my interface would not return something that might get evaluated lazy / has to be invoked. Looks like constructing by value just creates a function to return the value and passing a function always (?) will make use of memo to avoid duplicate evaluation.\nIt was just the interface return value itself (TryOption) that caused some confusion to me because I assumed that this is just a exception-catching function decorator (with multiple function evaluation).\nBut I understand that conceptionally it is just a data type including lazy evalution.\nAlso I just noticed that Option itself has similar mode when constructing it by giving a function. But the signatures differ: Option takes Func and TryOption takes Func. And Option does not need to be invoked. (Is there a deeper reason for these differences?)\nFinally: thanks for explanation, really helped me understand this better.\n. That's not entirely correct. The following old-school version is not affected:\ntry\n{\n    var x = LanguageExt.Prelude.failwith<string>(\"test\");\n    Console.WriteLine(x);\n}\ncatch (Exception ex)\n{\n    Console.Error.WriteLine(ex);\n}\nIt doesn't help to add some outer try-catch around my original code above.\nThe issue occurs if the exception occurs in or passes my code and gets catched in external code (like Try).\nYes, this is not an issue of LanguageExt. But LanguageExt suffers from this behaviour.\nSome special CLR exceptions are by default excluded from this behaviour (see VS Exception Settings).\nI will post this to Visual Studio team because I think there is a need to disable this behaviour for someting like Try. From my point of view it doesn't make sense to force every developer to change their VS preferences just to not be annoyed.\nSeems like one reason for this crazy default is that e.g. ASP.NET applications would catch errors in framework and just give HTTP Status 500 -- making debugging bad. \nSeems like a debug build of external libs is seen as  \"My code\". Seems like this means (pdb and) disabled optimization :-/\nOne reason why I added this issue is to maybe find a better workaround and at least document this behaviour. We stumbled upon this because I had \"Just My code\" disabled (everything working) and a work mate with a clean VS installation reported that Try is not working as expected.\n. Hi @bender2k14,\nMight be that you have \"Just My Code\" disabled because I don't see this extra column in your screenshot:\n\nThis picture shows my actual settings (everything works fine) but these are not defaults (click \"Restore Defaults\").\nCan you check your settings in VS: Tools => Options => Debugging => General:\n\n. No, I don't thin that. \nThere are two settings. \n\n\n\"Enable Just My Code\" is a general setting which let's the debugger make a difference between \"my\" code (source code + debug-libraries) and (optimized) libaries. \n\n\nThe difference depends on Exception settings, especially on \"Continue When Unhandled\" option that is disabled by default for most Exceptions, including \"Exception\".\n\n\nTherefore the behaviour is correct and Visual Studio documentation matches this.  I just verified it with a third machine, so everything fits together here.\nBut I think it is not a good default or at least VS default settings are bad when using Try. At least if you want to debug your code and expect that your debugger only stops when your compiled program would crash (= completely unhandled exception).\nI wonder how you can have a different behaviour with default settings on your machine. I'm interested in the difference as it might help to find a workaround (other than setting every developer machine to IMO reasonable non-default settings).\nI just verified that my debugger stops if I put code into a XUnit test and run that in Debug mode (xunit visualstudio runner). Here's my complete project:\n```\n\n\nExe\nnet462\n\n\n\n\n\n\n\n```\nProgram.cs\n```\nusing System;\nnamespace ConsoleApp2\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var x = LanguageExt.Prelude.Try(() => LanguageExt.Prelude.failwith(\"test\"));\n            x.Match(Succ: Console.WriteLine, Fail: Console.Error.WriteLine);\n        }\n    }\n}\n```\nTest.cs\n```\nusing Xunit;\nnamespace ConsoleApp2\n{\n    public class Test\n    {\n        [Fact]\n        void PassOrBreak()\n        {\n            var x = LanguageExt.Prelude.Try(() => LanguageExt.Prelude.failwith(\"test\"));\n            var result = x.Match(Succ: _ => 1, Fail: _ => -1);\n            Assert.Equal(-1, result);\n        }\n    }\n}\n```\nIf this does not stop in debug mode on your machine, could you attach your debug settings (Tools => Options => Debug => General)?\n. It's difficult to build a good real-world test because the dead-lock might not occur. I might try to build a synthetic one just to show the difference...\nThis is a conceptional problem. I think using ConfigureAwait(false) will in summary be better, because:\n\n\nLanguageExt is most useful in business code and library code, perhaps more than in GUI code (very poor argument, I know  ;-)).\n\n\nDead-lock problems are very ugly in general and hard to isolate in task context. Depends on how tasks are assigned to contexts. IMHO this is nothing you should have to care about in general.\n\n\nUsing ConfigureAwait(false) might result in local issues (as @bender2k14  mentioned: exceptions will help). You can find (local) workarounds there. If you use other libraries with async features, you have to care about context things, too (i.e. be sure about library internals or better don't rely on them). \n_\nIn mixed code (sync calling async) the status quo will result in issues (dead-locks) that occur somewhere but have to be handled more generally, which means: change your calling code to be async. \nI did this for my use case (replacing OptionAsync with Task ...) and it resulted in a really ugly code mix. If someone tries to make this code nice (again) he will produce code with the dead-lock issue again without knowing -- the dead-lock probably will not occur in tests-cases and perhaps will arise in production a lot later. \nIn my situation a completely unrelated piece of code made the difference (dead-lock yes or no). This other code wasn't async at all but used a library which at least caused a different context behaviour of the task scheduler (maybe internally using Tasks). Even after reproducing the dead-lock it took some time to build a fix for this.\n\n\nFor the GUI part: I'm not sure what a real-world example using LanguageExt async types would look like that causes an exception. @bender2k14: Do you have something in mind? \n. Here is a GUI example that shows the problem with ConfigureAwait(false) in UI context and a potential solution.\n```\n        // This example requires a simple Windows Forms application with a button \"copy\" and a textbox \"txtOutput\"\n    /// <summary>\n    /// Helper function to make sure the passed async function gets our synchronisation context\n    /// </summary>\n    /// <typeparam name=\"T\"></typeparam>\n    /// <typeparam name=\"TResult\"></typeparam>\n    /// <param name=\"someAsyncFunction\"></param>\n    /// <returns></returns>\n    Func<T, Task<TResult>> WithCurrentContext<T, TResult>(Func<T, Task<TResult>> someAsyncFunction)\n    {\n        var scheduler = TaskScheduler.FromCurrentSynchronizationContext();\n        return x => Task.Factory.StartNew(\n            () => someAsyncFunction(x),\n            CancellationToken.None,\n            TaskCreationOptions.None,\n            scheduler).Unwrap();\n    }\n\n    /// <summary>\n    /// some library function using ConfigureAwait(false) when awaiting a passed async function\n    /// </summary>\n    /// <typeparam name=\"T\"></typeparam>\n    /// <typeparam name=\"TResult\"></typeparam>\n    /// <param name=\"input\"></param>\n    /// <param name=\"mapper\"></param>\n    /// <returns></returns>\n    async Task<TResult> Apply<T, TResult>(T input, Func<T, Task<TResult>> mapper)\n    {\n        await Task.Delay(1).ConfigureAwait(false);\n        return await mapper(input).ConfigureAwait(false);\n    }\n\n    async Task<bool> ShowText(string text)\n    {\n        await Task.Delay(1000);\n        txtOutput.Text = text;\n        return true;\n    }\n\n    private async void copy_Click(object sender, EventArgs e)\n    {\n        txtOutput.Text = \"processing...\";\n\n        // will work\n        await Apply($\"{DateTime.Now}\", WithCurrentContext<string, bool>(ShowText));\n\n        // will throw error:\n        await Apply($\"{DateTime.Now}\", ShowText);\n    }\n\n```\n\ncopy_Click is the async method attached to the event handler\nShowText is some user function doing a side effect to GUI element (context sensitive function)\nApply is a place holder for any library function (could be BindAsync or any other higher-order async LanguageExt function) using ConfigureAwait(false)\nfinally WithCurrentContext is an example how this can be fixed locally without changing code structure\n\n. Hi, \nI changed to BindBottom and will add a commit soon with async support.\nI struggle currently with MapBottom because I tried to first build a static function in Choice.Prelude.cs:\n```\n/// \n        /// Returns the input if in Left or Right state\n        /// Returns the result of bottom function if in Bottom state as Left value\n        /// \n        /// Function to generate a Left value if in the Bottom state\n        /// Returns an either value\n        [Pure]\n        public static Either mapBottom(CH ma, Func bottom)\n            where CHOICE : struct, Choice =>\n            default(CHOICE).Match(ma,\n                Left: Left,\n                Right: Right,\n                Bottom: bottom.Compose(Left));\n    /// <summary>\n    /// Returns the input if in Left or Right state\n    /// Returns Left(bottom) if in Bottom state\n    /// </summary>\n    /// <param name=\"bottom\">value to return as Left value if in Bottom state</param>\n    /// <returns>Returns an either value</returns>\n    [Pure]\n    public static Either<A, B> mapBottom<CHOICE, CH, A, B>(CH ma, A bottom)\n        where CHOICE : struct, Choice<CH, A, B> =>\n        default(CHOICE).Match(ma,\n            Left: Left<A, B>,\n            Right: Right<A, B>,\n            Bottom: () => Left<A, B>(bottom));\n\n    /// <summary>\n    /// Returns the input if in Left or Right state\n    /// Returns the result of bottom function if in Bottom state as Right value\n    /// </summary>\n    /// <param name=\"bottom\">Function to generate a Right value if in the Bottom state</param>\n    /// <returns>Returns an either value</returns>\n    [Pure]\n    public static Either<A, B> mapBottom<CHOICE, CH, A, B>(CH ma, Func<B> bottom)\n        where CHOICE : struct, Choice<CH, A, B> =>\n        default(CHOICE).Match(ma,\n            Left: Left<A, B>,\n            Right: Right<A, B>,\n            Bottom: bottom.Compose(Right<A, B>));\n\n    /// <summary>\n    /// Returns the input if in Left or Right state\n    /// Returns Right(bottom) if in Bottom state\n    /// </summary>\n    /// <param name=\"bottom\">value to return as Left value if in Bottom state</param>\n    /// <returns>Returns an either value</returns>\n    [Pure]\n    public static Either<A, B> mapBottom<CHOICE, CH, A, B>(CH ma, B bottom)\n        where CHOICE : struct, Choice<CH, A, B> =>\n        default(CHOICE).Match(ma,\n            Left: Left<A, B>,\n            Right: Right<A, B>,\n            Bottom: () => Right<A, B>(bottom));\n\n```\nThe problem is that I have to change the return type to CH here to make it generic (using Choice). This means I need to create a Left. I got this solution for the Right path:\n[Pure]\n        public static CH mapBottom<CHOICE, MONAD, CH, A, B>(CH ma, Func<B> bottom)\n            where CHOICE : struct, Choice<CH, A, B>\n            where MONAD : struct, Monad<CH, B> =>\n            default(CHOICE).IsBottom(ma) ? default(MONAD).Return(bottom()) : ma;\nIs there any typeclass support for creating left? (Otherwise this variant will have to be non-generic, i.e. without using Choice).. I think there are three ways to go:\n(1) just merge the commits until now -- getting only BindBottom and dropping MapBottom.\n(2) implement MapBottom just for Either/EitherAsync (non-generic / without Choice)\n(3) create an interface like 'IReturn' as the return part of the monad definition which could be implemented by Either as IReturn<L>. We could even replace the return part of the monad by IReturn<A> so Option would implement it once and Either would implement it twice (for L and R). Seems like there might already be an interface in LanguageExt that might had this target: Liftable. It's currently unused..\nWhen going way (3) we should do this in a separate issue. I'm glad to help with a PR. This option obviously is the most work and doesn't pay off just for MapBottom. But maybe Liftable is a useful concept in other parts, as well.. default(EitherAsync) is now bottom state.\nNote: I changed constructor so null argument will throw an exception instead of silently falling back to bottom. IMHO this makes it more clean and one should never pass null to the constructor to get some EitherAsync in bottom state.\nIf you think the previous behaviour is better (because there might be legitimate ways to indirectly have null value here with bottom \"meaning\") we can change that back, of course. My thought here was just \"another null check is fine\".. Another link: https://stackoverflow.com/questions/41588195/how-to-prevent-an-action-parameter-from-being-an-async-lambda \nMy commit https://github.com/louthy/language-ext/pull/512/commits/6648f2e65e061577e37a9da035466da5e213259c fixes the issue by adding a (probably missing) variant IfSome(Func<A, Task>) which gets called by the current test code.\nThe async lambda produces an anonymous function returning Task and this can be awaited. Func<A, Task> variant gets called on this type.\nThere is still the problem that it will break if the async lambda gets casted to a simple Action somewhere. Probably there are three options:\n(1) It's not a bug in the library => user error => don't care (besides implementing Func variants)\n(2) remove any Action<A> variants to reduce the problem as far as possible\n(2b) mark Action variants at least as [Obsolete]\n(3) check the action for async on runtime and handle this some way. This is a code smell, for sure. And throwing an exception isn't correct as this just might be some fire-and-forget-action by intent. I'm not sure whether there is a hack to await something like this.\n. Added some comment fixes.\nWhen going way (1) there probably every method accepting Action should have a companion with Func<Task>. I'm not sure whether this helps making the library better as many methods already are defined with a different name (like MatchAsync). \nSee https://github.com/louthy/language-ext/blob/267f1c69002a58df64655f777cd8b6fee57f5e7c/LanguageExt.Core/TypeClasses/OptionalAsync/OptionalAsync.cs#L47-L73\nThere is a Match function defined without this companion.\n(It's such a mess that C# allows async void / passing async functions to Action.). (1b): implement all those companion functions (with Func<Task> instead of Action) and mark all of them obsolete and give a hint to use MatchAsync instead of Match (and IfSomeAsync instead of IfSome etc).. Maybe related: https://stackoverflow.com/questions/35903724/compiletomethod-cannot-compile-constant-some-value-because-it-is-a-non-trivial. I stripped down my project to only a few lines. Test throws runtime error here. If I downgrade to LanguageExt 3.0.28 everything works fine (and test green).\nI can even remove my custom Equals method (#247) and it still fails.\nmy.csproj\n```\n\n\nnet462\n\n\n\n\n\n\n\n```\nSomeStaticClass.cs\n```\nusing LanguageExt;\nusing LanguageExt.ClassInstances;\nusing Xunit;\npublic static class SomeStaticClass\n{\n    [Fact]\n    static void TestMyRecord()\n    {\n        var key1 = new MyRecord(\"a\");\n        var key2 = new MyRecord(\"A\");\n        var key3 = new MyRecord(\"b\");\n        Assert.Equal(key1, key2);\n        Assert.NotEqual(key3, key2);\n        Assert.Equal(0, key1.CompareTo(key2));\n        Assert.Equal(key1.GetHashCode(), key2.GetHashCode());\n    }\n}\ninternal class MyRecord : Record\n{\n    public MyRecord(string text)\n    {\n        Text = text;\n    }\n[OptOutOfEq, OptOutOfHashCode, OptOutOfOrd] \npublic string Text { get; }\n\npublic override bool Equals(MyRecord rhs) =>\n    base.Equals(rhs) && EqStringOrdinalIgnoreCase.Inst.Equals(rhs.Text, Text);\n\n}\n``\n. I just could reproduce it in LanguageExt.Tests! If you modifyLanguageExt.Tests.csprojthis way, some tests fail:net462`. @louthy: Happy new year!\nI looked into this but I could not find out why exactly this fails / how to fix the optimized code.\nAfter reverting the change 2f1e06 (see PR #531) tests are green again.\n.  I was just confused because I would intuitively expect \nMatch(Func<B>, Func<A, B>, Func<Seq<A>, B>)\nto give me:\n0 elems (= all)\n1 elem (= all)\n2 or more elems (= all = head included)\nthis would scale for any number of args and last arg would always be \"seq with at least n elems\" while args before are \"tuple\" of 0, 1, ... n-1.\nParameter name Tail is ok (but who looks on arg names to see behaviour, signature should be hint enough) -- IMHO this function could be left out. Having the last arg Func<A, Seq<A>, B> can be used instead and has clear meaning. Fits exactly what you wrote in the beginning of your answer.\n. Yes I looked at implementation.\nI'm not sure what kind of memory overhead you see. If the function with this signature would be this:\n/// <summary>\n        /// Match empty sequence, or one item sequence, or tail of multi-item sequence\n        /// </summary>\n        /// <typeparam name=\"B\">Return value type</typeparam>\n        /// <param name=\"Empty\">Match for an empty list</param>\n        /// <param name=\"HeadOnly\">Match for list with only 1 element</param>\n        /// <param name=\"More\">Matches list with at least 2 elements</param>\n        /// <returns>Result of match function invoked</returns>\n        public virtual B Match<B>(\n            Func<B> Empty,\n            Func<A, B> HeadOnly,\n            Func<Seq<A>, B> More) =>\n            IsEmpty\n                ? Empty()\n                : this.Tail.IsEmpty\n                    ? HeadOnly(this.Head)\n                    : More(this);\nThis would match on list size without dropping head or another element in any case as every other Match variant does (yes, this is just one point of view).\nIf the caller is only interested in Tail he could just call Tail like this:\nvar resultAsString = Seq(1, 2, 3).Match(\n    () => \"empty\", \n    one => $\"only: {one}\", \n    more=> more.Tail.Apply(xs => \"tail: \" + string.Join(\",\", xs)));\nI don't see why it matters in regard of memory or performance.\nAnyway this is all just my humble opinion. My primary goal is to understand design decision to avoid bugs due to misunderstanding and this was something I stumbled on.\nYou probably don't want to change semantics for this function signature for compatibility reasons, anyway. That's why \"drop it\" came to my mind. \nI'm happy with current state with cleaned up parameter names.. ",
    "emiguelt": "Thanks a lot @louthy! \nI'm a c# and functional programming learning.. ",
    "bender2k14": "I don't think Option<T> should implement IDisposable.\nMy reasoning for why mostly comes from Mark Seemann, an expert in dependency injection and author of Dependency Injection in .NET.  In particular, I think that Mark would also be against Option<T> implementing IDisposable.  I will attempt to justify this as I think Mark would.  To read some of Mark's own words on this topics, see this blog post.\nI begin with a quote from that blog post.\n\nthe object that composes the object graph is the only object with enough knowledge to dispose of any disposable objects within the object graph that it created\n\nIn our case, we are considering the object graph that conceptually is just two objects: the Option<T> and its T within.  The Option<T> class did not create the T; it was given the T.  So it should not be responsible for its disposal.  The object that instantiated the disposable T should be the one to dispose it.  Ideally, this would happen in the composition root, possibly with the help of a DI container.\nThe difference with StreamReader and its child Stream object is that it might be the StreamReader object that instantiated the Stream object.  In that case, it is the only object that knows about the need to dispose the Stream object, so it must implement IDisposable \"in that case\".  This case would happen when calling the constructor StreamReader(string path) that\n\nInitializes a new instance of the StreamReader class for the specified file name.\n\nWhere it gets weird is that StreamReader has other constructors, such as StreamReader(Stream stream), that accept a Stream object.  Some other object instantiated this Stream object, so it should be the one that is responsible for disposable as well.  My guess is that, given this API for StreamReader, the decision was made to both simplify the logic and \"help out the user\" by disposing the Steam object even when it was provided in a constructor.\nSo I don't think the example of StreamReader and its Stream object is a good example to be considering for this issue.  It could very well be that the designers of StreamReader now regret the two vastly different ways of instantiating the class and would do things differently if given another chance.. > Ultimately, it's the developer that decides when to dispose, either through calling Dispose or wrapping the instantiation with a using. In my opinion, the 'owner' is the programmer, not some mystical object graph.\n\n...\nIf we agree that nobody really owns the items and it's the programmer that ultimately makes the decision. Surely we can give the programmer the most efficient disposable mechanism going - so they don't have to repeat the same code over and over?\n\nSure, the programmer can pick any design they want, including a bad one.\n\n\u201cI have the right to do anything,\u201d you say\u2014but not everything is beneficial. \u201cI have the right to do anything\u201d\u2014but not everything is constructive. ~1 Corinthians 10:23 NIV\n\nThis is what I like so much about functional programming.  It's proponents claim it is a more beneficial and constructive way to write programs.  I am very convinced by these claims, which is why I am so eager to learn more about functional programming.\n\nI prefer to approach these kinds of questions from a pragmatic point-of-view...\n\nI want to consider a pragmatic approach while also considering a theoretical one.  I think to myself, \"how would the design look in a perfect world?\"...or at least as perfect as I can imagine it to be.  Then I consider the gap between theory and practice and consciously choose a point on the interval between them.  I feel like this gives be a better appreciation for compromises that I am making, both from a pragmatic perspective as well as from a theoretical one.\nIn theory, I want code written within small scopes so that I can look at each piece of code (along with its entire scope), see the whole thing on my screen, assume that all dependencies are correct, and immediately be convinced of the correctness of this piece of code.  I think of this as the manual code-review equivalent of a automated unit tests.\nIn the case we are discussing, I want to be immediately convinced that any object that is disposable is disposed.  It must be disposed at the right time.  Too early will causes an ObjectDisposedException to be thrown.  Too late we hinder performance by withholding resources from others that needs them, or worse, deadlock by never releasing the resource.  Furthermore, some objects throw an exception if Dispose is called a second time.  So we need find a unique space and the right time in which to call Dispose on each disposable.\nTo that end, consider that some disposable object is instantiated, and consider the set of objects that have the ability to call Dispose on it (either directly because the object has (or even had at one point) a reference to it or indirectly by calling some function that would eventually cause this invocation).  We must pick one (the space requirement) to be the one to call Dispose.  Even in such an abstract setting where it seems that we know almost nothing about the code, there is a natural choice that always works: the object that instantiated the disposable object.\nFor example, this code adheres to this theoretical ideal.\npublic T Execute<T>(Func<SomeDisposableClass, T> f) {\n    var dependencies = this.GetDependencies();\n   using (var someDisposableClass = new SomeDisposableClass(dependencies)) {\n      return f(someDisposableClass);\n   }\n}\nI see two downsides to this code.\n1. It is not functional.\n2. We would be repeating code by copy-pasting so that one can reuse it for SomeOtherDisposableClass.\nSo think of the theoretical ideal as the above code after these abstractions to be more functional and not duplicate code when \"repeated\".\nIn contrast, I imagine that you would implement Dispose on Option<> with something like (obj as IDisposable)?.Dispose().  This is not convincing me of correctness at all.  How do I know  that it wasn't disposed too early?  How do I know that it couldn't have been disposed of sooner?  How do I know that this is the first time that this method was called on this object?  How do I know that some other object won't call this method on this object later?\nI imagine the counter argument to go like this.\n\nBut the user of Option<> has an instance with identifier opt and has called opt.Dispose().  So from the perspective of Option<>, we know that it is the right time because we get to assume it is the case because the user has declared it to be.\n\nMy rebuttal is that this user should just call something like opt.IfSome(t => t.Dispose()) instead.  In particular, they are more likely to \"know\" if t implements IDisposable, thus not needing to cast.  By applying this argument recursively, we terminate at the base case in which the method calling Dispose is the same one that instantiated it.\n\nBe aware, the whole dependency injection framework thing is something that starts me twitching like Chief Inspector Dreyfus from the Pink Panther.\n...\nPlease let's not turn this into a dependency injection discussion ;)\n\nI too want to keep this discussion on topic :) As such, notice that my argument has nothing to do with dependency injection.  I am very interested know why you feel that way, but we can save that conversation for another time.. Now the hard part is picking the point between the pragmatic and the theoretical.\nFor the pragmatic side, I will say that in the programs that I write at work, I strive to achieve code like in my example, and I think the programs are better for it.  When I joined my current project at work, one issue with the program was that it would max out CPU and memory slowly over the course of 24 hours.  My advice to the client was that we should ignore this problem for now in the hopes that it is disappear as I continued to add new features and fix smaller bugs while simultaneously cleaning the code in the vicinity of those changes.\nMy hypothesis for the this issue is that the program was not disposing disposables, which caused all the memory to be allocated, which caused frequent garbage collections from the runtime to a desperate attempt to free more memory, which caused the maxed out CPU utilization.\nThe latest report is that this issue no longer exists (or, at least, is significantly better).  I attribute this improvement to places in the code where I guarded access to IDisposable`s like in my example code in my previous comment.  This leads me to believe that my theoretical code is also practical.. > I have to say that I avoid dependency injection and try to solve this by writing side-effect free code (static pure functions) where possible.\nI am interested to discuss dependency injection with you as well, but I will also refrain from doing so now.  The issue at hand is rather orthogonal to dependency injection.  My acknowledgment of Mark as the source for my argument has had quite the opposite effect compared to what I had intended, and I think it might have presented somewhat of a straw man argument in both of your eyes because of it.\nFrom a theoretical (or maybe hypothetical) perspective, let's consider the slippery slope argument.   If Option<> should implement IDisposable, then why not have every type implement IDisposable?. What about this argument?\nThe documentation of IDisposable says that Option<> (in its current form) should not implement this interface.\n\nImplement\u00a0IDisposable\u00a0only if you are using unmanaged resources directly. If your app simply uses an object that implements\u00a0IDisposable, don't provide an\u00a0IDisposable implementation.\n\nMy arguments before were trying to explain \"why\" this requirement from the interface itself exists.. @StefanBertels, your quote ends just as an explanation of it beings.  Here is how it continues.\n\nIf a type is responsible for the lifetime of other disposable objects, developers need a way to dispose of them, too.\n\nThe essence of our entire thread here is to decide, for each disposable object, who is responsible for its disposable.  We have yet to come to an agreement about this.\nThe responsibility of Option<T> is to represent the concept of the existence or absence of an instance of T that it was provided. To also take on the responsibility of lifetime management of this provided instance is a violation of the single responsibility principle.\nIt cannot be the case that every class with a reference to the same instance of a disposable object are all responsible for its disposable.  There must be exactly one class with that responsibility.  Otherwise, it is impossible to avoid early disposal, late disposal (including never being disposed), or double disposal.\nSo \"containing\" in your quote doesn't mean \"has an reference\".  Conceptually it means \"instantiated\". \n Practically though, \"instantiated\" is too strict.  A factory that only creates instances of a disposable type is not responsible for disposing it.  How could it be?  If it did, then the entire class is a big no-op.  Instead of the factory being responsible for disposable then, the responsibility of disposable falls to the class utilizing the factory.\nSo an alternative to my previous example\npublic T Execute<T>(Func<SomeDisposableClass, T> f) {\n    var dependencies = this.GetDependencies();\n   using (var someDisposableClass = new SomeDisposableClass(dependencies)) {\n      return f(someDisposableClass);\n   }\n}\nis\npublic T Execute<T>(Func<SomeDisposableClass, T> f) {\n   using (var someDisposableClass = SomeDisposableClassFactory.Create()) {\n      return f(someDisposableClass);\n   }\n}\nThe authors of this documentation are trying to account of cases like this.  As programmers, we know very well how much the requirement to properly handle edge cases increases the complexity of the code.  Writing prose is no different.. > Does Option contain the inner object or does it just refer to it. It depends.\nExcept the interface is called IDisposable, not IMaybeIDisposable.  A class is supposed to implement IDisposable if it does have something that it alone is responsible for disposing.\n\nMaking Option [implement] IDisposable will allow outside code to dispose it in case it contains inner object.\n\nTwo responses to this.  First, Option<> already allows outside code to dispose.  For example, opt.IfSome(t => { t.Dispose(); return unit; }).  Second, whether or not Option<> \"contains\" (according to the previously quoted documentation) is a decision to be made by its creators, not by its users.\n\nYou don't have to call Dispose if you don't want to.\n\nNo, this is the entire problem.  The contract of a class that implements IDisposable requires from its users that Dispose is called at the proper time and in the proper way.  The users of Option<> are going to trust this contract and be inclined to write code like this\npublic static OptionAsync<T> ToAsyncUsing<T>(this Option<T> opt) {\n    using(opt) {\n        return opt.ToAsync();\n    } \n}\nbecause they believe this is what is required of them in order to properly use Option<T> for any type T and instance thereof.  If the desires of a user are in conflict with the behavior of a class as specified by its contract, then the user needs to find a different class satisfy their desire.\nEven if it were ok to implement IDisposable in such a way that sometimes it is a no-op, how is the user supposed to know when this is the case?  How are they supposed to know when   You and I know when it would be a no-op but that is only because you and I are aware of the proposed implementation.  It is unreasonable to expect users to inspect the implementation.  Of course one could attempt to explain this in documentation.  However, it is my understanding that closely aligned with functional programming is the desire to use strong types; that the semantics of a program are dictated by its (strong) types instead of the documentation of (weaker) types.\n\nLook at echo actor setup (example): echo calls factory (setup) and therefore owns the returned object. If your setup returns Option you have a problem.\n\nI think I found the line of code that are referring to.  I opened this echo-process issue to document this.\n\nIf you have some factory it's straight forward that the factory returns an IDisposable (or compatible) if someone should call Dispose later. Having Option non-IDisposable will hide this fact for optional return values. This is a problem for generic code.\n\nThe shortest response that I can give to that is this.  I think Actor specifically (and thus echo-process generally) is not managing object lifetimes properly.  Furthermore, I think making Option<> implement IDisposable is the wrong solution to this problem.  If your type of your state was instead IEnumerable<T> where T : IDisposable, would you request that Microsoft have IEnumerable implement IDisposable?  I wouldn't think so.\nI have more to say about Actor.  I will make a post at the echo-process issue shortly.\n\nI don't see a practical problem with IDisposable for those cases where your inner object isn't IDisposable or should not be Disposed.\n\nThe problem is that the intent it communicates to the user.  The user will think that they have to write code like ToAsyncUsing above.. > Why should a user write code like your ToAsyncUsing ?\nBecause the contract of Option<>, should it implement 'IDisposable`, states that each instance should be disposed.\n\nThis isn't limited to Option. If you decorate some Stream ref or do other transformation on any IDisposable obj you won't dispose it in that operation, either.\n\nI don't know what you mean. Can you be more specific?. From issue #328 \n\nOne thing that has crossed my mind is that tooling like ReSharper might complain about values not being disposed properly, so that would need to be considered. I don't use it, so I'm not sure if it would start throwing out warnings, but from what I've seen of it before, I wouldn't be surprised.\n\nI don't know about ReSharper, but I have considered writing my own static analysis tool that attempts to identify undisposed disposables.  I hear that Roslyn makes this type of static analysis rather easy.. > Static analysis cannot be perfect, I think proof for this is similar to that of Halt problem. Just to add some theory pence here ;-)\nYou are probably thinking of Rice's Theorem.\n\nIt's not impossible to limit analyzer so it only warns about relevant missing Dispose calls (i.e. Disposing container might not be necessary if inner object is disposed in some other way). But I admit this might be a workaround...\n\nMy approach would be to err on true positives and provide some level of warning in all other cases.  The idea is that warnings are always useful because they identify locations in the code that are too complicated for automated static analysis.  The point is that we should avoid writing programs like those conceived of by Turning in order to show the impossibility of the halting problem.\nMy understanding of functional programming is that it is fundamentally about avoiding side effects. \n Theoreticians like Turning and Rice can exploit this feature of a language to show that bad things can happen when state is modified.  That is why pure static functions are so wonderful.  They lend so well to static analysis, whether manual or automated.\nBoth of you are more knowable about functional programming than myself.  It has taken a long time to reach my current understanding of monads.  I was confused for a rather long time.\nOne of my overall impressions about monads is that they go to great lengths to formalize and isolate side effects.  I have almost exclusively used the option, list, promise, and whatever the monad name for C#'s Func<A> would be.  I hear that some monads help to control modification of state are the reader, writer, and state monads.  But even so the monads themselves do not have side effects.\nIf Option<> were to implement IDisposable, in what sense would Option<> still adhere to this core design principle of monads that is the avoidance of state mutation?  My current understanding of Option<> is that it can be viewed as an immutable data structure.  Is this benefit lost if Option<> were to implement IDisposable?\n\nAnyway: I value your arguments because I think this library shouldn't go into some \"wrong\" direction. I'm sure Paul takes all issues into account to make this library as useful as possible.\nEveryone have a good start into 2018!\n\nThanks Stefan, I appreciate that.  I do want the best for language-ext.  It has helped us greatly improve our code at work.  This has motivated me to improved my ability to do functional programming.  Getting involved with language-ext seems like an excellent way to do that.  It is very helpful to process my programming thoughts here by sharing them with you and @louthy in these issues.  The least I can do in return is to contribute improvements via pull requests.\nHappy new year everyone :). > IMO: Immutability is not a problem. The problem is we have copies of references to the same object. Which reference is \"master\"? There is no such ownership flag in C#. Would be great if we had something like this because then compiler could call Dispose automatically if scope of \"master\" reference ends.\nI guess the part that I fundamentally don't understand is why you want to solve your specific mutability problem by changing a core functional data type to make it mutable as well.  Sure, the way in which this non-pure behavior is achieved is through a copy of a shared reference, but this fact is just an implementation detail of the desired non-pure specification.\n\nThere is some practical value because if Option is not IDisposable, you cannot use it in code like echo actor (return type of setupFn = state)\n\nWhat do you think about using a class like this as your state?\npublic class StefanOptionWrapper<T> : IDisposable {\n  public Option<T> Value { get; }\n  public StefanOptionWrapper(Option<T> value) => Value = value;\n  public void Dispose() => Value .IfSome(x => x.Dispose());\n}. > But why do you think a ResourceOption (or better DisposableOption) is something bad?\nOur main point is not that DisposableOption<> is a bad idea.  Our main point is that changing Option<> by having it implement IDisposable is a bad idea.  The title that you picked for this issue makes us think that you want to change Option<> by having it implement IDisposable.\nCan you clarify this for us @StefanBertels?  Would you like to see Option<> changed by having it implement IDisposable or would you like to see a new data type added to language-ext called (say) DisposableOption<> that works exactly like the existing Option<> data type except it also implements IDisposable?\nI would not be against adding this new data type.. > The issue is about the request to have Option IDisposable. It was clear from beginning...\nOk, good.  Thanks for clarifying.  That is what I thought, but your previous comment made me think that you instead just wanted to add an additional data type with the desired behavior.\n\nI feel that you want to just stop this request / do not respect positive outputs.\n\nChanging Option<> to implement IDisposable is probably the smallest change (aka diff size) to fix the problem you had in your use of echo-process.  That weighs in favor of making this change.  But such small changes also directly correlate with being a hack.\nThis change wouldn't affect just you and your code; it would affect everyone that uses Option<>, including me and our client's projects.  You believe that your actor project will benefit from this change, and I believe that our client's projects would suffer for it.  For example, Microsoft's documentations warns that this would be a breaking change.\n\nWarning\nIt is a breaking change to add the\u00a0IDisposable\u00a0interface to an existing class. Because pre-existing consumers of your type cannot call\u00a0Dispose, you cannot be certain that unmanaged resources held by your type will be released.\n\nI can imagine a counter-argument being that this won't break any pre-existing code because not calling Dispose in those cases is the correct thing to do.  There are two issues with this.  First, this shows that the proposed use of IDisoposable it incorrect because it would not match this specification.  Second, it could break pre-existing code because what used to be a no-op (obj as IDisposable)?.Dispose() no longer is and the correctness could depend on that fact.\nI do respect the positive outputs while also thinking that they do not out weight the negative outputs in this case.  It is for that reason that I oppose this change.\n\nthere is no real concept (or at least a broken one) for IDisposable at all\n\nJust because a window is broken doesn't mean it is ok to break the one next to it.  It is not wise to throw the baby out with the bath water.  Of course the IDisposable interface is not ideal and the concept of ownership is unclear.  Nevertheless, we still have a responsibility to our clients, our companies, and the .Net community at large to do the best we can with the IDisposable interface.\n\nLifetime management has to be done by developer and there are different methods to manage ownership.\n\nThere are multiple ways to do anything in life.  Some ways are better, some ways are worse, and the usefulness of some ways depends on the situation.  In general, the comparison of ways will only be a partial order, not a total one, so some ways are best in some situations but terrible in others.  Just because the proposed change would benefit you doesn't mean it would benefit everyone.\nI have tried to explain my approach to lifetime management above.  Here is some more insight into my understanding that I can share on that topic.  It has only been within the last year that I have realized how useful it is, in all aspects of life, to delay decisions.  In the past, my personality lead me to try and solve a problem as soon as it arised.  I now have a better appreciation for the fact that by delaying a decision, I will often have more information about the problem, which allows me to make a better decision.  This delay is not procrastination, which is waiting too long.  Instead you should delay (as others have said) \"until the last responsible moment\".\nThe connection is that I want to delay choices about lifetime until the last responsible moment.  I think we can always responsibly delay the choice to dispose the instance given to the constructor of Option<> to somewhere outside of Option<>.  Conceptually, instead of actor.Dispose() also disposing your IObservable<> subscription, it would be more like actor.Dispose(); actorState.Map(x => x.Dispose());.\nRobert Martin discusses the benefit that delaying decisions has on your architecture.  Here is a blog post that nicely summarizes what I have heard Robert say on the subject.  And two exellent quotes from that post are\n\ngood architecture is less about the decisions you make and more about the decisions you defer making\n\nand\n\nThe purpose of a good architecture is to defer decisions, delay decisions. The job of an architect is not to make decisions, the job of an architect is to build a structure that allows decisions to be delayed as long as possible.\n\nI can imagine a counter-argument to this being that the proposed change allows for the delay of disposing the value inside the Option<> instance because the choice to call Dispose on the Option<> instance can be delayed.  The problem though is that this doesn't obey the specification of the IDisposable interface.  The intent of this interface is that any instance of a class that implements this interface should have Dispose called on that instance as soon as it is no longer needed, not when some object given in its constructor is no longer needed.\n\nIf you give some example to show problems with disposable Option we could evaluate pros and cons.\n\nIs the following specific enough?\nBecause of this, if the proposed change were accepted, I think the following will inevitably happen.  Some developer will create a class that uses an unmanaged resource, and they will have their class implement IDisposable because they were told that this is the proper way to free an unmanaged resource.  Locally speaking, this developer is correct to do so.  Then they will wrap an instance of their class with language-ext's Option<> because they were told that this is the proper way to model the possibility that their reference doesn't exist.  Locally speaking, this developer is correct to do so.  Then they will notice that Option<> implements IDisposable and recall that they were told that each disposable instance should be disposed of as soon as possible.  And, again, locally speaking, this developer is correct to do so.  But now they will have a bug in their code when later they attempt to use their disposable instance and a DisposedObjectException is thrown.\nMy favorite part about strongly typed languages and functional programming is how it forces the developer to do the right thing.  For example, if you want extract the value from Option<int>, you can't just call .Value like you can with C#'s int?.  Instead you have to call something like Match or IfNone, which forces the developer to consider the possibility that the value doesn't exist.\nMy opposition to this change is an attempt to protect this developer.  I want the data types in language-ext to force them to do the right thing.  The problem with the proposed change is that it doesn't force the developer to do the right thing.  It does the opposite by giving them more ways in which to do the wrong thing.\n\nBut IMO some arguments are wrong (like mutability)\n\nYou probably know better than me.  Is there any example of a monad with a non-pure method?  I have only learned about and understand a few monads so far, and all of them only have pure methods.\n\nRegarding dependency injection: This is some solution to a specific problem in OOP. But we can change design to avoid this. I don't suggest to drop DI (maybe you should think about it ;-)).\n\nI think we have different understandings of DI.\nI would say that Paul is using DI in language-ext when he passes a type parameter T into a method, constrains T to be a struct and to implement some interface with method Foo, calls default(T) to obtain an instance of T, and then calls Foo on that instance.\nThe implementation of this method \"depends\" on some method Foo and Paul \"injects\" that dependency into the method via a type parameter.  Here of one example where Paul does this.  One doesn't have to get so fancy to do DI in FP though.  A more traditional approach is to just pass in a delegate as a parameter, which is what I did in my recent refactor to the parseT family of methods.  Now of all the parseT functions that I touched, only this one includes branching.  The others only exist to provide an unambiguous function name for each type.\nMaybe you equate DI with the use of a DI container (such Simple Injector)?  I would agree with you then; it is my current understand that existing DI containers are rather specific to OOP.  Even in OOP though, you don't have to use a DI container to do the same injection of dependencies.  Instead you can use pure DI.\nAnother place I like to go to learn more about functional programming the site F# for fun and profit by Scott Wlaschin.  He has a nice blog post about what he thinks DI looks like in FP.\n\nIMHO there is still a lot of value with disposable Option\n\nAgain, I am not primarily against having a disposable Option.  I am primarily against not having a non-disposable Option<>; I am against changing the existing non-disposable Option<> and making it a disposable one.. > I think IDisposable is used (and can be used) for managed resources, too.\nYes, this seems common to me, even to the point that Visual Studio now includes a snippet similar to ReSharper's.\nUsing IDisposable.Dispose to free managed resources is just an optimization.  As such, I don't have a problem with it in general.  I do remind people though not to prematurely optimize.\n\nSummary: IDisposable is a solution for lifetime management for anything that explicitly needs to be disposed.\n\nI agree, but I don't see how this follows from your discussion about the dispose pattern.\n\nTo get back to specific issue about Option is IDisposable being a good or bad idea: Do you really need to call Dispose() on any disposable object?\n\n~In practice, no, but I would prefer to live in a world where the answer was yes.~\nI slightly misunderstood the linked SO question.  Just because a type could be cast to IDisposable doesn't mean that it should be.  Ideally casting is never needed.  If some piece of code doesn't know at compile time that some object's type implements IDisposable, then this is a strong indication that this piece of code should not be responsible for managements of this object's lifetime.\nMy original response (which now follows) addresses a slightly different question, which is\n\nDo you really need to call Dispose() on any ~disposable~ object whose type at compile type is known to implement IDisposable?\n\nIn practice, no, but I would prefer to live in a world where the answer was yes.  That world is easier to understand.  Instead, I think we live in this more complicated world because IDisposable is misused, including by Microsoft by having Stream implement it even though this class doesn't use any unmanaged resources.  I don't think I am the first one to say that Microsoft has done something wrong. ;)\nSo, in practice, no, but I try to make the answer \"yes\" for applications in which I am involved.  I believe that this makes it easier to write correct code.\n@StefanBertels, what do you think about this code?  Do you think it should compile?  If not, why not?  If so, what do you think should be the state of the object referenced by the variable myOptionAsyncDisposable?\nOption<IDisposable> myOptionDisposable = new System.Reactive.Disposables.CompositeDisposable();\nOptionAsync<IDisposable> myOptionAsyncDisposable = myOptionDisposable;. > I disagree. Objects might be \"active\" (pushing messages) and you need to stop/unsubscribe (e.g. observables).\nI don't understand.  An observable subscription is not a managed resource.  That is why it implements IDisposable.\n\nDoesn't that contradict what you suggested in louthy/echo-process#27?\n\nI don't think so.  Did you have something specific in mind?\n\nIMO this is an appreciation of values (as this Option.Dispose() request): Is it better to have the ref your in your code IDisposable or not when it (or something it contains...) might have to be disposed.\n\nI am having a hard time understanding what you are saying here.  Could you rephrase it?\n\n..ref your in your code IDisposable...\n...ref type to implement IDisposable...\n...ref type you use in your code...\n\nBy \"ref [type]\", you mean compile-time type, right?\n\nRegarding your last question: it does not compile for the same reason...does not compile.\n\nI didn't ask you if it compiles.  I know it doesn't compile.  I asked you if you think it should compile.  I asked you for your opinion.  I want to know what you think.  I am trying to better understand your perspective.\n\nWhat do you think should be the state here?\n\nI already know if I want that code to compile (and if not, why, and if so, what the state is).  I will tell you, but I don't want to bias you my telling you what I think first.. The existing Find methods (that are extensions on nested Maps and take in all the keys at once) return an Option<> of the innermost key.  However, they are defined using a method with signature R Find<R>(K key, Func<V, R> Some, Func<R> None).  I was surprised to see this.  I was expecting to see them defined by a method like Option<V> Find(K key).\nWhy do these methods exist that combine the essential logic of Find with the logic of Option<>.Match?\nIt seems like there is an enormous amount of Option<>.Match-like code duplicated in order to implement these methods.  I prefer calling methods with fewer argurments, so I would prefer to call a Find(key) followed by Match(some, none) instead of Find(key, some, none).  It also makes it awakard to try and define (say)\nOption<D> Find<A, B, C, D>(this Map<A, Map<B, Map<C, D>>> self, A aKey, B bKey, C cKey)\nin terms of\nOption<C> Find<A, B, C>(this Map<A, Map<B, C>> self, A outerKey, B innerKey)\nwhich is how I was expecting the existing Find (Map extension methods) would be defined.. It is interesting to hear which one has a smaller cognitive load for you.  It goes the other way around for me.  In fact, I am not that crazy about .Match(some, none) either.  I prefer .Map(some).IfNone(none) instead.. > it will only fail when you're using the variables in an untyped situation (like in string interpolation)\nI think there is a bug in the debugger version of Visual Studio's IntelliSense feature that is related to this issue being discussed here.  I am using version 15.7.1 of Visual Studio Enterprise 2017.\nIf I hover over the declaration of the variable min while in the process of editing code, then IntelliSense says that its type is int.  This is the expected behavior.\n\nBut if I hover over that same declaration while debugging, then IntelliSense says that its type is the unit of measurement Time with 60 s as its ToString.\n\n. That makes sense to me. # Reducing to Match\nWe can simply the problem slightly by defining Fold<> in terms of Match<>.\n[Pure]\npublic Func<Unit, S> Fold<S>(Task<A> ma, S state, Func<S, A, S> f) => _ =>\n    default(MTask<A>).Match(ma, a => f(state, a), () => state);\nThis version of Fold seems bug free to me while Match<> has the same issues as the current version of Fold.  Maybe both of these methods behave as intended, and I should be using FoldAsync instead.\nConsidering FoldAsync\nI can imagine a potential reply saying to use FoldAsync instead of Fold.  It is true that the test passes when using FoldAsync.  However, I created the above test while trying to simplify this one.\n```\n[Fact]\npublic void SequenceOnTaskSeq_InAsyncContexAndWithSingletonSeq_Terminates() =>\n  AsyncContext.Run(() => SequenceOnTaskSeq_WithSingletonSeq_Terminates());\nprivate static void SequenceOnTaskSeq_WithSingletonSeq_Terminates() {\n  var source = 0\n    .AsTask()\n    .Apply(SeqOne)\n    .Sequence();\nsource.Sequence();\n// execution terminates by reaching here\n}\n````\nThis test eventually calls Fold in a manner similar to the test that I originally gave.  I don't see any method like SequenceAsync that would eventually call FoldAsync instead of Fold.  Maybe this is the real bug?...That the code in this test should eventually call FoldAsync instead of Fold?\nTask Status Canceled\nOn a related note, this test passes by throwing a TaskCanceledException.  Is that the expected behavior?\n```\n[Fact]\npublic async Task MTaskFoldAsync_CancelledTask_ThrowTaskCanceledException() {\n  var cts = new CancellationTokenSource();\n  cts.Cancel();\n  var intTask = Task.Run(() => 0, cts.Token);\nvar f = default(MTask)\n    .FoldAsync(intTask, 0, (x, y) => 0);\nawait Assert.ThrowsAsync(() => f(Unit.Default));\n}\n``. I see that you have removed all the calls to properties ofTask<>, such asResultandIsFaulted`.  That is an extremely good improvement just by itself.\nI have two questions about he new design.\nFirst Question\nOn the interface FunctorAsync<FA, FB, A, B>, there are two methods with signatures\n1. FB MapAsync(FA ma, Func<A, B> f) and\n2. FB MapAsync(FA ma, Func<A, Task<B>> f).\nCan you explain the reasoning for calling them both MapAsync?  In your alpha release notes, you say\n\nTo reduce the problems of method resolution a large number of methods have been renamed to have Async suffixes...\n\nIs this reasoning used on these method names as well?  Instead of calling them both MapAsync, I was wondering if there would be any problems calling them both Map or calling them Map and MapAsync respectively.    Do you know if either of these other choices allows for method resolution problems?\nSecond Question\nIf there is no technical limitation to calling the first method above just Map, then the possibility exists to having the interface FunctorAsync<FA, FB, A, B> extend the interface Functor<FA, FB, A, B>.\nWould this inheritance be good or bad?. > If the method returns a Task then append Async. That allows for say a synchronous int Sum() and an asynchronous Task<into> SumAsync() for example.\nThe example is good. Specifically, if there are two methods that do the same thing except one returns A and the other returns Task<A>, then appending Async is good.\nHowever, I don't like the idea that the name of any method that returns a Task should end in Async. For example, I don't think the extension method AsTask that lifts an A to an Task<A> should be called AsTaskAsync.\nI like the idea of appending Async only if there is also a synchronous variant.  This idea may well have exceptions though.\n\nThis would help for methods like BiMap where there are four possible variants.\n\nI would typically think of handing that by lifting one delegate to return a Task<> to match the other delegate and then calling the overload that takes two delegates that returns Task<>.  Or await when able before calling a synchronous function.  Do we have to be worried about the performance tradeoff from a additional method call like that?\n\nIf they unify then that would certainly be a benefit.\n\nThe only difference is the name of the method (Map vs MapAsync). My current understanding is that they should be unified.. I like your change from last night (hash d3c2ccb).  Specifically,\n- the Map-like method the accepts a Func<A, B>  is called Map\n- the Map-like method the accepts a Func<A, Task<B>>  is called MapAsync.\nI think it is consistent with the monad design pattern to call the methods as you have because the method name varies with the argument types but not with the monad type.\nRecall, for a monad M<T>, that\n- the method that accepts a Func<A, B> is called Map and\n- the method that accepts a Func<A, M<B>> is called Bind.\nSo this method MapAsync is lies on the interval between Map and Bind.  I suppose any combined monad would face a similar naming issue.  Looking at TryOption<> though, I don't see any method that accepts just one argument that is either Func<A, Option<B>> or Func<A, Try<B>>.. > I know why you say that, but I see the Async variants more as artefacts of C#'s strict evaluation and less of a 'sliding scale of Map and Bind'.\n\nIf values were lazy like Haskell then I wouldn't need to litter the code with Task<...> and the implementations of Map and Bind could deal with the asynchronous behaviour transparently. Unfortunately C# doesn't work that way and so we end up with async polluting the function signatures too. So, although MapAsync and BindAsync isn't a purist definition of a functor map and monad bind operation, the end result is still a functor map operation and monad bind operation, just with asynchronous behaviour.\n\nThis makes a lot of sense to me.  In particular, synchronous computation is a special case of asynchronous computation.  This is clear from C#.  Asynchronous computation can easily call synchronous computation but there is no completely correct way for synchronous computation to call asynchronous computation.\n\nHowever, that general rule falls apart slightly for the ToString and GetHashCode overrides on EitherAsync. They can't have their names or signatures changed (because they're inherited from Object) and they will force synchronous evaluation. I have provided ToStringAsync and GetHashCodeAsync, but that's immediately breaks the rules set above.\n\nI think this exception to the rule is acceptable.  Another method with this problem is IEnumerable<T>.GetEnumerator, which, in your design, is on every monad.\n\nI see that you have removed all the calls to properties of Task<>, such as Result and IsFaulted. That is an extremely good improvement just by itself.\n\nI said that 4 days ago, presumably in reference to state of your branch at commit 39b7400.  Somehow I made a mistake.  There are still many calls to Result and IsFaulted in the current commit.\nDo you intend to remove them?\nI don't see how your asynchronous monad types can correctly implement synchronous methods like ToString, Equals, GetHashCode, and GetEnumerator.. > I said that 4 days ago, presumably in reference to state of your branch at commit 39b7400. Somehow I made a mistake. There are still many calls to Result and IsFaulted in the current commit.\n\nDo you intend to remove them?\n\nI just reviewed the current version (which is commit 966d9bfecaeb84668338564c3a841ea0cd611ace) of your async-refactor branch.  I think you (@louthy)  have fixed (almost) all the possible deadlocks that could happen by calling Task.Result.  The only methods in production code (I didn't check tests or sample code) that could deadlock are EitherAsync.ToString and EitherAsync.GetHashCode because they both call Task.Result on the Task returned from their async counterparts.  I think you did that intentionally, and I think it is reasonable to do so.\nGood work!. Oops.  Didn't mean to do that.. Previously in this issue we were discussing the naming of methods like Map and Bind depending on whether or not their argument types include Task<>.\n@louthy, I really like the idea you shared in your v3.0 release notes.  There, when talking about this naming, you gave this example.\nMatch(SomeAsync, None)\nMatch(Some, NoneAsync)\nMatch(SomeAsync, NoneAsync)\nsaid that sometimes the method would keep its normal name (in this case, Match) and one can explicitly disambiguate among the overloads by explicitly naming the arguments.\nI just wanted to say that I think this is a great idea.  This approach should allow the name to be simple (i.e. just Match instead of something like MatchAsync) in most cases without any problems (i.e. the compiler will select the indented overload).  Then in the rare cases where things are ambiguous to the compiler, we have a simple way to clarify the ambiguity (by explicitly naming one or more arguments).  Furthermore, we don't have to come with an exponential number (relative to the number of parameters) of different method names in order to avoid ambiguous situations for the compiler.\nP.S.\nSince the original purpose of this issue was a bug that is now fixed, I think this issue can now be close.\nGreat work @louthy! :). I was just trying to change something that I thought was wrong.  I don't know what Visual Studio injection you are talking about.\nIf (hypothetically) in Visual Studio, you refactor-rename these generic type parameters with the documentation as is, then the documentation will not be updated to match.  If instead the documentation moved to where I put it, then the documentation will also be changed to match.\nI thought I was making things more consistent.  Of the four generic interfaces in the TypeClasses namespace that I have looked at, the majority documented each generic type parameter defined on type on the defining type (as I my change does with Functor.cs).\n\nAll generic type parameters defined on types in these files are documented on its defining type\nApplicative.cs\nMonad.cs\nMonoid.cs\nAll generic type parameters defined on types in these files are documented on a method\nFunctor.cs (but my change makes this files consistent with those in the previous group)\nAll generic type parameters defined on types in these files are missing documentation\nSemigroup.cs\n\nAs both my first pull request to your project and also first pull request on this type of change, I wanted to just modify one small file to get feedback from you first before spending time making similar changes in many files.\nIt may very well be an enormous job to make this type a change for the entire project.  That doesn't bother me though.  I enjoy making types of improvements.  I have been reading the documentation to gain a better understanding of the vocabulary from functional programming.  Doing this with your library is rather ideal because C# is my best language.  Furthermore, I am interested in aspects of quality assurance, and might use some tool to identify possible changes like this one and ideally even ones that can make the change for me.. I must be missing something.  How would this break anyone's build?  I moved a method from one partial implantation of the Prelude type to a different partial implementation of the Prelude type.  I don't see any problem with that.  The Option<> type has three different names for constructors: None, Some, and Optional.  What this PR does is move the None constructor to the same file where the Some and Optional constructors are located.. Ok, that makes sense.  Thanks for the explanation.  Reverted the type name change.. May I ask why this was closed?. Found another bug in the family of use methods.  This one is in the extension method in TryExtensions with signature Try<U> Use<T, U>(this Try<T> self, Func<T, U> select).  The code self().Value should be assigned to t.\npublic static Try<U> Use<T, U>(this Try<T> self, Func<T, U> select)\n    where T : IDisposable => () =>\n    {\n        var t = default(T);\n        try\n        {\n            return select(self().Value);\n        }\n        finally\n        {\n            t?.Dispose();\n        }\n    };\nI would like to repurpose this issue (#328) to address these bugs within the family of use methods.\nIs that ok with you @louthy or would you prefer if I create separate issues?. There are use and tryuse methods in Prelude_Use.cs as well as some Use extension methods.  For these methods, either the IDisposable is directly passed in or it is indirectly passed in via one of these monad types:\n1. Func<>\n2. Task<>\n3. Try<>\n4. TryOption<>\n5. TryAsync<>\n6. TryOptionAsync<>\nIs there a reason that these monad types have some kind of use method while others (such as Option<>) don't?. I still don't see what is special about those monad types.  My thought would be to have a single function something like this\npublic static Func<A, B> disposing<A, B>(Func<A, B> f)\n    where A : IDisposable => disposable =>\n    {\n        try\n        {\n            return f(disposable);\n        }\n        finally\n        {\n            disposable.Dispose();\n        }\n    };\nand use it something like this\npublic static Func<A, B> Method<A, B>(AnyMonad<A> ma, Func<A, B> f)\n    where A : IDisposable => disposable =>\n    ma.Map(disposing(f)));. Some of the use family of method have the type constraint where T : class, IDisposable while other just have the type constraint where T : IDisposable.\nDo you have a preference about the inclusion or exclusion of the class type constraint on these methods?. I will take the silence as a \"no\".  I decided to remove the class type constraints.. Ah, that was a markdown typo.  Only the first line was meat to be quoted.  I fixed it now.\nVery explicitly, I would like to change the awful out parameter documentation by changing\n\nInt32.TryParse becomes parseInt\nInt64.TryParse becomes parseLong\nInt16.TryParse becomes parseShort\nChar.TryParse becomes parseChar\nByte.TryParse becomes parseByte\nUInt64.TryParse becomes parseULong\nUInt32.TryParse becomes parseUInt\nUInt16.TryParse becomes parseUShort\n\nto\n\nint.TryParse becomes parseInt\nlong.TryParse becomes parseLong\nshort.TryParse becomes parseShort\nchar.TryParse becomes parseChar\nbyte.TryParse becomes parseByte\nulong.TryParse becomes parseULong\nuint.TryParse becomes parseUInt\nushort.TryParse becomes parseUShort. I just made a pull request to fix the issues identified here.  I would reopen this issue if I could, but I don't seem to have that ability.  Doesn't really matter though.  It can stay closed.. This definitely looks like something that should be changed.\n\nThe async monads are getting quite the overhaul right now in the branch async-refactor stemming from an issue raised in #317.  Not sure if it would be better to fix the issue you found before or after this branch is merged into master.. I think the difference is the existence or absence of order.  @gwintering wants a monadic data type that represents the first task from an ordered collection that successfully completed while @louthy wants the same thing but for an unordered collection.\nBefore we try to solve the impossible problem of naming, I have a different question.  Are both of these monadic data types useful?\n. I don't think you have to do anything special. Just have the exe and DLLs in the same arrangement that you would in Windows and then run the exe with mono.. Why is the DLL in a folder called Assets? Did you add language-ext as a dependency via NuGet? Are you compiling in Windows or somewhere else?. I have been using it with Mono without any problems..  > Unity uses Mono which seems to be the only multiplatform solution for .NET platform.\nThere is also .Net Core.. Welcome, and no worries about not using this code.  I am interested to see how you fixed it.  Have you pushed your fix somewhere?. I see.  It is included in commit c9bae2d41d0de614100d7cf1480625774a8bfd0a.. More important is that this method needs to return Task<int>.  I could write a test similar to those in issue #317 that causes this code to deadlock.  I expect that this will be fixed in the branch async-refactor.\nAfter that change, the compiler will once again assist you flipping between async and sync code.\nEven so, I in favor of having a consistent set of methods across monads.. Can you provide links to these implementations?. Thanks.  Your change seems good.\nIs this code supposed to be thread safe?. I don't understand.  Why did you merge  pull request #1 into this branch?. Can you link to the Ord interface?. In defense of @faeriedust, why is CompareTo declared as virtual if you (@louthy) don't expect anyone to override it?  Is the presence of this key word a mistake?\n(Equals and GetObjectData are also declared as virtual.  Is the presence of these key words a mistake?). In your PR, what x is null?. > Also I don't understand what the performance hit you mentioned is.\nYou replaced a static call with a virtual call.  Virtual methods involve a layer of indirection that static ones don't.  Therefore, you code is slightly slower.. sigh Sorry about all those closed PRs.  I was having some difficulties this morning.  Everything should be good now.. In what way does it not work?. Here is that same code in the async-refactor branch.\nOn a related note, what is the meaning / intention between the classes MTask<> and MTaskFirst<>?. > Fixed in v2.1.13\nI think you meant v2.2.13-beta, but you didn't increment the version in that commit either.  I don't see a version beyond v2.2.12-beta yet.. The existence of InnerException is confusing me.  Can you explain what its purpose is?. Actually, most of this is dead code.  I used to know this and was just recently reminded of how this works.\nThe documentation for Task.WhenAll says\n\nIf any of the supplied tasks completes in a faulted state, the returned task will also complete in a TaskStatus.Faulted state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.\n\nFurthermore, when awaiting a failed Task, an exception is thrown.  Therefore, most of the method is just dead code.  It can be simplified to just\npublic async Task<A> Apply(Func<A, A, A> f, Task<A> fa, Task<A> fb) \n{\n    await Task.WhenAll(fa, fb);\n    return f(fa.Result, fb.Result);\n}. No hurry.  Take your time.\nI only recently heard about this myself.  Support for Visual Studio used to come by way of an extension but as of Visual Studio 2017 (specifically version 15.0), the support is built in.. Not sure if it is a bug, but that behavior is because of this line.\nThe example code uses an internal data structure that is a tree.  The current behavior (that follows from the order of the arguments in the method call on the linked line) is a pre-order traversal of this tree data structure.  @StanJav was expecting an in-order traversal, which can be achieved by swapping the third and fourth arguments.\nI can create a PR to make this change.. > btw - I think there may be issues with your Task extension methods - I've\nseen both Map and Bind block (not every time). In particular you don't\nseem to be using Task.Unwrap in the latter case. When I get an hour I'll\nsee if I can come up with a minimal failing test and a PR\nThis is a known issue (#317) and has been fixed in the branch async-refactor.  The most recent prerelease (v2.2.2-beta) includes these fixes.. > Like yourself I have a massive bias in favour of immutablity, so I would\nchange your extension method IEnumerable.Map to return a Lst, rather\nthan IEnumerable - which as we see can change each time it's iterated\nover.\nThis seems backwards to me.  Your test fails because the local variable n is not mutated.  Your desired behavior is that the local variable n is mutated.\n\nIf I really want the current behavior I'd just call Select.\n\nI think the point of this Map is retain the efficient lazy behavior of Select while changing from database jargon to functional programming jargon.. > Is the EitherAsync<,> type meant to be used together with async...await and from...select syntaxes? Is it supposed to be a Task-like type?\nIt is.  Now that I try your code myself, it seems that EitherAsync<,> is missing some plumping required to make the async...await and from...select syntaxes work.  This is something that I don't fully understand yet.  I tried to add the methods that I thought were necessary, but it still didn't work.. > I'm not sure what missing plumbing is being talked about\nI was referring to this SelectMany method that you @louthy included in your comment.  Because I couldn't get the from...select LINQ syntax working for this type, I assumed that LanguageExt was missing the needed method and that I didn't understand this feature of C# well enough yet to figure out what method was missing.\n\nBut bizarrely that code already exists in lang-ext and for some unknown reason the compiler isn't spotting it for use with LINQ. If I copy it to the source file then it does pick it up. So, I'll need to do some digging. It's either an idiotic mistake that I can't quite see right now or a possible compiler issue.\n\nI am very interested now to see what the fix is.  If this problem doesn't get solved right away, then I will try my hand at it.. > Is this expected behavior? I have tested this on version 2.2.18-beta.\nCan you share the code that is giving you this error?. EitherAsync<,> has these four implicit operators:\npublic static implicit operator EitherAsync<L, R>(Task<L> value);\npublic static implicit operator EitherAsync<L, R>(L value);\npublic static implicit operator EitherAsync<L, R>(Task<R> value);\npublic static implicit operator EitherAsync<L, R>(R value);\nso you can just write\npublic static EitherAsync<string, int> Op1() =>\n  Task.FromResult(1);\nor even just\npublic static EitherAsync<string, int> Op2() =>\n  1;. Can you give a better example?\nHere is my attempt to guess at what you are trying to achieve.\n```\npublic static EitherAsync Op1() => unit\n  .Apply(QueryDatabase)\n  .Map(ReturnsEitherStringOrInt)\n  .ToAsync();\npublic static Task QueryDatabase(Unit _) =>\n  true.AsTask();\npublic static Either ReturnsEitherStringOrInt(bool b) {\n  if (b) {\n    return 42;\n  } else {\n    return \"Fail\";\n  }\n}\n``. I think usingasync/await` usually means that you are not doing things functionally.\nIdeally you can avoid using null.  I would recommend having the return type of _userRepository.GetAsync be OptionAsync<User>.  Then you could write\npublic static EitherAsync<string, User> GetUserAsync(int id) =>\n  _GetUserBool(id).ToEither(\"Could not find user\");\nprivate static OptionAsync<User> _GetUserBool(int id) =>\n  new User();\npublic class User { }\nOtherwise, you can first turn the type of the return value into OptionAsync<User> then do as above, like\npublic static EitherAsync<string, User> GetUserAsync(int id) =>\n  _GetUserBool(id).Map(Some).ToAsync().ToEither(\"Could not find user\");\nprivate static Task<User> _GetUserBool(int id) =>\n  new User().AsTask();\npublic class User { }. I definitely noticed that LanguageExt.Result<>.IsFaulted could be confused with System.Threading.Tasks.Task.IsFaulted.\nFor TryAsync and TryOptionAsync, I will maintain the intent, which is to return a Result<> containing the exception instead of throwing the exception.  For the remaining cases, my plan is to maintain the behavior.  Certainly let me know if you would like any of these intents to replace the current behavior.. > is this intended?\nNo.  The bug you linked to (#341) is definitely related.  In that case, the expected behavior is that the instance is in the bottom state, but it is in the faulted state.  In your case, the expected behavior is that the instance is in the faulted state, but it is in the bottom state.  Depending on your perspective, you can either view this as two separate bugs or one bug in which two cases have each other's behavior.\n\nWhat's the reason for having those invalid states (mostly named Bottom)?\n\nC# presents the following trade off in type safety.  A variable with a struct for its type cannot be null, but a struct can always be created via its (possibly implicit) default constructor.  In contrast, a class can only be created via an explicitly defined constructor (unless there are no explicitly defined constructors, in which case an implicit default constructor exists), but a variable with a class for its type can be null.\nBased on this, LanguageExt has the following intended behavior with its struct types.  If a struct is created via it default constructor, that struct is put into its bottom state.  Then any interaction with a struct instance in its type's bottom state causes a BottomException to be thrown.\n\nAnd are Result and OptionalResult available for arbitrary use\n\nYep.  They are public types, so you can use them however you'd like.. Oh, first, I meant to say that \"both\" of these bugs are fixed in the current version of the async-refactor branch.\n\nBut why is Bottom used in a conceptional way? There are structs with a natural bottom state (Option etc can be OptionNone etc.). Why not make default(OptionResult) := OptionResult.None and drop all bottom/IsValid code?\n\nWe want the type system to tell us that our code is correct.  Sometimes we make a mistake by calling the default constructor of struct when we didn't mean to....and the type system isn't able to tell us that we are wrong.  Therefore, to compensate for this weakness of the C# type system, the approach of LanguageExt with its sturcuts is that the default state is considered an invalid state.  The situation would be more complicated (and thus more bugs) if the default state of some structs were valid and other were invalid.\n\nOk, types without natural None state need to be checked for invalid (default) state. But why not fail fast (throw exceptions) when calling them?\n\nDo you mean why not explicitly define the default constructor to throw an exception?  I think that is a good question and don't know the answer to that.\n\nCurrently seems like the bottom state is handled different, resulting in Match(...) to proceed but e.g. run something on an invalid state. Why not let Match throw exception fast?\nIs there a reason to pass invalid values around?\n\nThe current behavior in the master branch (aka the current released version of LanguageExt) is incorrect.  The intended behavior is that interacting with a struct in its bottom state throws an exception.\n. > I'm a bit sceptic whether making every default struct invalid is very practical.\n\nWill this really apply for every struct?\n\nTo be clear, I haven't seen @louthy explicitly say anywhere that...\n\nthe approach of LanguageExt with its structs is that the default state is considered an invalid state\n\n...that is my current understand that I have gained by reading the code.  It seems like a fine design choice to me.\n\nWhat about container types like List\n\nLanguage.Ext.List is a class, not a struct, so this discussion doesn't apply to it.  Did you mean to say Language.Lst<>?  If so, then...\n\nwhat about Option? AFAIK those types currently (master) have some decent default like empty or None.\n\nYes, you are correct, so these structs are inconsistent with my previous statement.\n\nA had a look at async-refactor branch. Currently it doesn't look like this change already happend everywhere. If I read this correctly then default for Option types is still mapping to None.\n\nThis issue was specifically for OptionalResult<>, so I think that is the only thing @louthy fixed in the async-refactor branch.\n\nAnother point:\ncode of Result has this line\npublic static readonly Result None = default(Result);\nShould this be renamed to Bottom to clearly separate invalid states from regular None states?\n\nI think the same changes to OptionalResult<> should be made to Result<>.  For that line, the assigned expression should be change as it was in OptionalResult<> to match the meaning of the identifier. . What is the return type of DataAccessModule.Connect?  Looks like it could be Either<DataAccessException, MyDatabase> where MyDatabase is the type of the variable db.. Your two occurrences of Left: ex => throw ex are unexpected.  I don't think you meant to do that.  It seems your intended return type for this code is Task<Either<DataAccessException, string>>.  In which case, you can just return these two instances of DataAccessException instead of throwing them.\nI think the method you are looking for is BindAsync.  Here is my attempt to use that method to simplify your code.  I stubbed everything out so that the following code complies.  Please let me know if I got any of the specifications incorrect.\n```\ninternal class MyClass\n{\n    internal Task> Method(\n        string connectionString,\n        MyRequest request\n    ) => DataAccessModule\n        .Connect(connectionString)\n        .BindAsync(db =>\n            RecordExists(db, request.FshApplicationKey)\n                .BindAsync(isExistingRec => isExistingRec\n                    ? UpdateRequest(db, request)\n                    : InsertRequest(db, request)));\nprivate Task<Either<DataAccessException, bool>> RecordExists(MyDatabase db, FshApplicationKey fshApplicationKey) => throw new NotImplementedException();\nprivate Task<Either<DataAccessException, string>> UpdateRequest(MyDatabase db, MyRequest request) => throw new NotImplementedException();\nprivate Task<Either<DataAccessException, string>> InsertRequest(MyDatabase db, MyRequest request) => throw new NotImplementedException();\n\n}\ninternal class MyRequest\n{\n    public FshApplicationKey FshApplicationKey { get; }\n}\ninternal class DataAccessModule\n{\n    internal static Either Connect(string connectionString) => throw new NotImplementedException();\n}\ninternal class FshApplicationKey { }\ninternal class MyDatabase { }\ninternal class DataAccessException : Exception { }\n``. > but replace theTask>s withEitherAsync`\nEitherAsync<,> is in the pre-released version of LanguageExt but not in the released version.. That Inst property is defined here.  From that instance, you can call the instance (i.e. non-static) method Compare.\nHowever, the line in question doesn't compile for me either.  The issue that I am experiencing is that the arguments to Compare should be of type int[] but are instead of type Arr<int>.\nThe two possible fixes that I see are to either replace both occurrences of Array(1, 2) with new int[] { 1, 2 } to get\nint x = OrdArray<TInt, int>.Inst.Compare(new int[] { 1, 2 }, new int[] { 1, 2 }); // 0\nor replace OrdArray with OrdArr to get\nint x = OrdArr<TInt, int>.Inst.Compare(Array(1, 2), Array(1, 2)); // 0\nWhat do you say @louthy?  Would you like one of those changes or possibly another?. No worries about opening an issue.  If you were confused, then there must be others that were confused as well.  In fact, you did help us to find something that was incorrect, so thanks for that :) . > It's best to see the transformer types as one type rather than two nested ones...\nIndeed.  In fact, the workaround we found before creating this failing test was to call .ToOptionAsync() to transform Task<Option<T>> to OptionAsync<T> (in both places) and then replace BindT with Bind.\nThis could be the fix...to use OptionAsync.  Some possibilities of achieving this include\n\ncompletely remove BindT and force the user to call .ToOptionAsync() themselves or\nchange the return type of BindT to OptionAsync and call .ToOptionAsync() internally.\n\n\nI am super short of time at the moment...\n\nSo no worries about not quickly coming up with a fix since a nice workaround exists.. Oh, I meant SeqList<>.  Sorry for the confusion.  I added a link to the code (which I should have done initially).. Yes, I see and believe I understand all four places in LanguageExt that it is called.  From those four uses, I created my bulleted list above to describe what I believe is the actual behavior.  However, my question was about the intended behavior.  I will assume by your comment that the actual behavior and intended behavior coincide.\nI will contribute a PR shortly to clarify its use, which will have the additional advantage of making it slightly faster as well.. The constructor has this ternary operator, and I think it can be removed.\nThe only time we expect count == -1 to be true is when this constructor is called from the New method in my original post.  There might be bugs in this class that put it into an invalid state from which it is possible to get -1 passed in for count in one of the other three calls.  Otherwise, an invariant of SeqList<> is that count > 0.\nOne of the bugs could be the behavior of Skip when the parameter is a negative value.  The documentation for the IEnumerable<> extension method Skip<> says\n\nIf count is less than or equal to zero, all elements of source are yielded.\n\nOh, I didn't notice that SeqList<> is internal.  So after first investigating some bugs, we should be able to simplify this code while also improving the performance (ever so slightly ;) ).. Can you elaborate on the desired output of ISeq<>.Skip and ISeq<>.Take?  Do you want them to be the same as Enumerable.Skip<> and Enumerable.Take<>?\nSpecifically for Skip, if the parameter count is less than 0, should the same sequence be returned?\nSpecifically for Take, if the parameter count is less than or equal to 0, should an empty sequence be returned?\nI ask because the behavior of SeqList<> differs in those two cases.\nI would like SeqList<> to have the class invariant\n\n1 <= count  (i.e. nonempty)\n0 <= index < list.Count  (i.e. index is a valid index into list)\nindex + count <= list.Count  (i.e. represents a valid subsequence of list)\n\nbut the behavior of Skip allows each of index and count to be any negative value.\nThe alternate behavior for Take doesn't break my desired class invariant, but I still think its semantics are wrong. If you Take zero items, then you should have zero items, not all of them.  This behavior seems especially egregious when you see that TakeWhile is defined in terms of Take, so passing in _ => false to TakeWhile returns the entire sequence.\nI recommend requiring the output of Take and Skip to match the output form their corresponding counterparts on the Enumerable class.  However, if they differ on negative values the way that SeqList<>.Take currently does (i.e by not violating my desired class invariant), then this seems like a reasonable choice to me as well.. Oh boy.  The classes SeqArr<>, SeqArray<>, and SeqLst<>, being what appears to be copy/pasted code, have the same issues as SeqList<>.  I want to make further improvements to SeqList<> (in a yet-to-be-created GitHub issue).  Then I will remove the duplicated logic among these classes.. Hello @brotherbill.  I can try to help you out.\nLet's start with your problem building the code.  Can you share more about what specifically isn't working for you?\nBTW, you can read the Wikipedia article on Semigroup to start learning more about what that is.. Try installing the .NET Core SDK 2.1.101 from here:\nhttps://www.microsoft.com/net/download/windows/build  . I am willing to provide you some guidance @brotherbill.  Just now sure right now how to fix the problem with your development environment :(. For reference\n\n...so I've killed it.\n\nhappened in this commit.\n. Your response makes me think that you think AsEnumerable() on SeqList<> is defined by enumerating the entire underlying IList<>.  That is not how it is implemented.  Instead, it is implemented as\npublic override IEnumerable<A> AsEnumerable()\n{\n    for (int i = index; i < index + count; i++)\n    {\n        yield return list[i];\n    }\n}\nAm I correct in my suspicion that you had a different idea in your mind for the definition of AsEnumerable?. Sure, you replaced the for loops with foreach loops.  But why not go further and implement them like\npublic override bool ForAll(Func<A, bool> f) =>\n    AsEnumerable().ForAll(f);\n?\nIs there something that I am missing?. For reference, this commit.. Specifically replying to the question in your title, what do you mean by equal?. Yes, I think they are semantically equivalent.  I think both types exist on purpose.  In particular, OptionalResult<> is easier to use than Option<Result<>>.\nSomething you can do is use this (custom) extension method to convert an Option<Result<A>> into an OptionalResult<A>.\npublic static OptionalResult<A> ToOptionalResult<A>(this Option<Result<A>> mma) =>\n    mma.Match(\n        ma => ma.Match(\n            a => new OptionalResult<A>(Some(a)),\n            e => new OptionalResult<A>(e)),\n        () => new OptionalResult<A>(None));\nHowever, it wasn't @louthy's intent that Result<> and OptionalResult<> be used so extensively outside of LanguageExt, so it would be best to limit your dependence on them.. > Is there a way for a method to return a Result or something that would replace a void return in a command?\nYou can replace\nDoWork(); // returns void\nwith\nfun(DoWork)(); // returns Unit\nwhere Language.Prelude.fun can be used like above if you include using static Language.Prelude at the top of your source file.\nThen you can use Either<L, R> with the \"success\" type being Unit.. Could you post the necessary usings as well?. I did not encounter your problem.  Everything seemed to work for me.  Specifically, I used the same package versions, same target version, and the following unit test passed.\n```\nusing System;\nusing LanguageExt.Parsec;\nusing Xunit;\nusing static System.Console;\nusing static LanguageExt.Parsec.Char;\nusing static LanguageExt.Parsec.Prim;\nusing static LanguageExt.Prelude;\nnamespace Tests {\n  public class TestClass {\n    [Fact]\n    public void OptionalNumericAppend() {\n      var spaces = either(\n             eof,\n             many1(satisfy(System.Char.IsWhiteSpace)).Map(_ => unit)\n         );\n  Parser<A> token<A>(Parser<A> parserA) =>\n      from res in parserA\n      from spc in spaces\n      select res;\n\n  var word = from w in token(asString(many1(letter)))\n             select new Word(w) as Term;\n\n  var number = from d in token(asString(many1(digit)))\n               select new Number(Int32.Parse(d)) as Term;\n\n  var term = either(word, number);\n\n  var parser = from sp in spaces\n               from ws in many1(term)\n               select ws;\n\n  var result = parse(parser, \"   4 words are here\");\n  WriteLine(result.ToString());\n}\n\n}\nabstract class Term { }\nclass Word : Term {\n    public readonly string Value;\n    public Word(string value) => Value = value;\n  }\nclass Number : Term {\n    public readonly int Value;\n    public Number(int value) => Value = value;\n  }\n}\n``. Would there be an issue with replacing the current target ofnet451withnet45`?. > To compute desired output from source data, following declaration/specfication in json format might be a reasonable start\nIn what sense is this \"reasonable\"?\nIt appears to me that you are trying to define your own programming language. There is a level of complexity at which defining your own programming language is reasonable, but I don't think you have reached it.. > I find it quite reasonable to define simple domain specific language (DSL) to address recurring usecases.\n\nUsecase in question is one I come across often in business apps.\n\nSure, but I don't think any recurring aspect of this use case is apparent from the example that you have provided.\n\nI've handled this earlier in non-FP style. \n\nWhat would your non-FP style solution look like?\n\nI want keep it to simple computations/expressions (sum/avg/count of lists, add, sub, mul, etc.) only\n\nAbsolutely.\n\n...not to the level where complexity/structure of whole programming language needs to be addressed.\n\nNot sure what you mean here.  Maybe you are you referring to Turing completeness.. > Seems like default Visual Studio Debug/Exception settings will let the debugger break at failwith because the Exception is \"unhandled in user code\".\nThis is not how it behaves for me.  Specifically, consider this test.\n```\nusing Xunit;\nusing Xunit.Abstractions;\nusing static LanguageExt.Prelude;\nnamespace LanguageExtTests\n{\n    public class TestClass\n    {\n        private ITestOutputHelper _testOutputHelper;\n    public TestClass(ITestOutputHelper testOutputHelper) =>\n        _testOutputHelper = testOutputHelper;\n\n    [Fact]\n    public void OptionalNumericAppend()\n    {\n        var x = Try(() => failwith<string>(\"test\"));\n        x.Match(Succ: _testOutputHelper.WriteLine, Fail: e => _testOutputHelper.WriteLine(e.Message));\n    }\n\n}\n\n}\n```\nOf course the test passes (and outputs \"test\"), but that is not the issue.  The issue is the following.\nIf the test is run in debug mode, does Visual Studio break (because an exception is thrown)?\nHere is how this behaves for me.  When I run the test in debug mode with the default exception settings...\n\n...then Visual Studio does not break anywhere, as I expect.  If I change the exception settings to break on all \"Common Language Runtime Exceptions\"...\n\n...then Visual Studio breaks inside failwith when it throws, also as I expect.\n\nthe debugger break at failwith\n\nI am unaware of any way to cause Visual Studio to break at failwith (instead of inside it) because of the thrown exception.\n. You previous comment makes me think that you think that\n\n\"Tools => Options => Debugging => General => Enable Just My Code\" and\n\"Exception Settings => Common Language Runtime Exceptions => right-click menu => Continue When Unhandled In User Code\"\n\nare the same setting.  For me, they are not the same setting.  In particular, if (1) is unchecked, then (2) doesn't exist (\"Continue When Unhandled In User Code\" is not longer in the right-click menu).\nAlso for me, the behavior is the same for all three possible settings of these two checkboxes.  Namely, Visual Studio does not break when that test is run in debug mode.. I still have the same behavior running your test (i.e. never breaks when running in debug mode) using both my \"current\" debug settings (see requested screenshot below) as well as the default Visual Studio settings called \"General\".\n\n. I agree with everything you said.  I think my problem is in correctly understanding the costs.\nFrom previous conversations with you, I know you like to reduce unnecessary allocations (i.e. object creations), such as lifting to a Task<> (in order to minimize the number of cases to implement).  On the other hand, the impression that I have acquired from reading your code is that you have no qualms with making many method calls.  My understanding for that position is that the compiler will typically inline these calls.\nIt is from this understanding that I thought the compiler would inline the lambda in computation.Map(d => use(d, map)) instead of making an allocation for it.  It was not my intention to increase the number of allocations.\nIs there a flaw in my understanding of this?  Is it perhaps the case that the compiler will never inline a lambda expression?. Thank you very  much for that detailed reply!  It was very informative :). I believe that I addressed all your comments @louthy in the commit with message removed delegate allocations.. Oh, about MOption<>.Bind, I also meant to say this.\nMy current understanding of the concept of monads is that Bind is a method that \"flattens\" a particular monad.  For example, if ma is of type Option<int> and f returns maps int to Option<bool>, then we should call Bind so that the return type is Option<bool> instead of calling Map where the return type would be Option<Option<bool>>.\nBase on that understanding, this MOption<>.Bind (from the interface method Monad<,>) seems overly general because it permits binding in the case that the two monads involved are different.  For example, one can write this\nOption<int> ma = None;\nEither<string, int> either = 1;\nvar mb = MOption<int>.Inst.Bind<MEither<string, int>, Either<string, int>, int>(ma, _ => either);\nThis type of binding for the option type is not exposed from Option<> itself.\n. How will you be replacing it?. > Only if all the types are known.\nAll the input types, right?\nBecause I just realized that fun(new StringReader(\"\").ReadLine) complies and correctly returns Func<string> while fun(DoWork) (with a method void DoWork()) also complies and correctly returns Action<Unit> (which means the method group was correctly converted to be of type Action).\nI think I understand this (limitation of C# ;) ) now.. @imranypatel, can you provide sample code that is self contained (i.e. compiles as is)?. This doesn't compile either.. > Explicit casting would be the solution but couldn't figure out one\n@louthy said how to do this in some recent release notes.  The relavent part is\n\nyou can consider Bind to simply be a cast operation for the R value that doesn't exist.\n\nSo you make the expression body style work like this\nstatic Either<string, int> GetTestHandlerExp(bool b) =>\n    b\n    ? 1\n    : Left(\"Fail\").Bind<int>();. > Not my code.\n\nYes it does. Put it in a class.\n\nOh, sorry @trbngr.  I thought that was @imranypatel replying to me.\nEven so, it doesn't compile even after you put it in a class.  You are still missing some usings.. Oh, figured it out :D.  Closing this PR instead.. Definitely!. @louthy I already created PR #420 to fix this :). > \"Length\" is present as an artefact in some of the other units implementations also. Beware!\nYep, I fixed the same issue in the other units of measure as well.. > do you think names like Information are just a bit too vague sounding for most users? Is there scope here for coming up with something more descriptive (without too much penalty in terms of the length of the unit name)?\nI am definitely open to considering alternatives.  I do think it sounds rather unusual at first, but anything else that I have considered sounds even more strange to me.\nI looked around today for more examples of how people measure these quantities.  I only found more evidence that Information is the correct name.  On Wikipedia for example, in addition to articles called Unit of length and Unit of time is an article called Units of information.  It lists the units that I would expect to see such as \"bit\", \"byte\", the powers of 10 like \"kilobit\" or \"kilobyte\", and the powers of 2 like \"kibibit\" or \"kilibyte.\nIf we accept Information, there is still some uncertainly regarding InformationRate.  In the context of measurements, \"rate\" means (in the most general sense) a ratio of two measurements.  In my experience, such rates almost always have a measurement of time in the denominator.  Examples include growth rate (where the numerator might be a currency, the size of population, or the size of a single object measured in length, area, or volume).  One counterexample to this pattern is exchange rate, which is a ratio of two different currencies.\nHowever, we should also consider what types of measurements one by want to divide into information.  The only such example from the Wikipedia article for Information theory is information over time.  I know of one other example though.  Some parts of physics consider the density of information, which would be information over volume.  If someone had a need to model this programmatically though, I would think that InformationDensity would be fine name.\nSo, in conclusion, my preference is still for Information and InformationRate.. > The main problem that I see with this is that there are a lot of cases that would have to result in an exception.\nI think this is a fundamental problem.  It is preferable to write code that won't fail at runtime.. Why do you have types AbsTemp and ScaleTemp instead of just one type called Temperature?. Oh, I understand now.  Thanks for your explanation.\nThe fundamental issue is that Kelvin and Celsius have different zero points.\n\nThe oneHundredCelsius instance has \"forgotten\" that it is a Celsius value, but the programmer has not.\n\nThen I think we should have separate types as you have done.  Instead of calling them AbsTemp and ScaleTemp though, I recommend calling them Kelvin and Celsius.. > Then only the non-K units multipliers like degC would ever construct a Temperature with a ScaleType that's not ScaleType.Kelvin, all other constructions would be with the converted values.\nDo you realize that even adding two Temperature instances is troublesome when the zero points could be different?  I am unable to tell if you realize that.. > Obviously there's potential rounding issues of double precision floating point values\nSure.  I am not (yet) considering any edge cases like that though.\n\nI agree there should be a single Temperature type, not multiple ones.\n\nHere is how I see the problem with with a single temperature type that \"knows\" what scale type it is and allows two such types to be added together.\nThe type signatures\npublic static Temperature operator +(Temperature lhs, Temperature rhs)\nand\npublic Temperature Add(Temperature rhs)\n(and the fact that Temperature is a struct with a valid default state) ensure that each of these functions form a magma.  I believe it is also true these algebraic structures form a quasigroup.  However, I don't see any way to implement these functions so that their corresponding algebraic strictures have an identity element or are associative.  Maybe there are such implementations though, and I am just failing to see them.\nOne solution is to have multiple temperature types with explicit and/or implicit conversions between them.\nAnother solution that is used here (as @thehoglet previously linked to) is to forbid the addition of two instances of type Temperature.  Instead, we introduce an additional type that represents a change in temperature.  This is also how the C# standard libraries handle absolute points in time.  The type DateTime represents a point in time, and you cannot add two DateTimes together, but you can add a DateTime and a TimeSpan together and get another DateTime.\nNow after writing all this, I think I like the second solution better.  However, I still don't like the idea of being able to multiply a Temperature by a scalar.  Is there really a need for this?  It seems to make about as much sense to multiply a DateTime by a scalar, which DateTime does not support.. > > However, I still don't like the idea of being able to multiply a Temperature by a scalar.\n\nYes, it makes total sense. 10\u00b0c * 2 should be 20\u00b0c.\n\nThe way I am thinking of modeling temperature is as a one-dimensional vector space.  An single temperature measurement is a point and a temperature delta is vector.  In a vector space, there is not usually a multiplication operator that combines a point and a scalar and returns another point.  That is why I said that I don't like the idea of being able to multiply a temperature by a scalar.  What you are suggesting is equivalent to mapping each point to the vector from the origin to that point, multiplying that vector by the scalar, and then mapping back to the point at the head of that vector.  The ambiguity with this is that the origin is not uniquely defined.\nSince temperature is a measure of average kinetic energy, I think the most natural way to define multiplication of a temperature and a scalar is to map from the temperature to its corresponding amount of average kinetic energy, multiply this by the given scalar, then from the resulting amount of average kinetic back to its corresponding temperature.  I think this is equivalent to the previous vector space point multiplication by a scalar if we remove the ambiguity there by always internally representing the temperature in Kelvin.. > I don't need a new type called CentimetresDelta or CelciusDelta, the operation being performed gives context to the operands.\nThat is not my suggestion.  Sorry for giving you that impression.. > And it kinda dawned on my that we're probably discussing edge cases here. Anybody doing operations on temperatures are likely to always be in the same unit anyway, especially for delta operations - you'd have to be some kind of nihilist to be mixing units in an important calculation. The only time any of this is likely to impact anyone (in the real world) is when converting for display reasons (I suspect).\nI completely agree.  So why not eliminate all of those edge cases by using explicitly different types with explicit conversions between them?  This code could still be abstracted so that we don't have any repeated code.. I think that is because all the other UoM types implemented in Language Ext have a unique zero point.. I think the intended use of RecordType<> is to have your class extend it like\n\npublic class CacheInvalidationMessage : RecordType { /*omitting class members*/ }\n\nand then you can just call the instance method ToString like\n\nnew CacheInvalidationMessage().ToString(). Very nice.  Can you also add a test that covers this case?. Yea, you can add the test to EitherAsyncTests.  It is funny actually that the file is currently empty.. > If it's going to be a while, what's the workaround to using .ToAsync()?\n\nIn the meantime, you can just implement your own extension method called BugFreeToAsync with the same implementation as the yet-to-be released code.. Yea, I see what you mean @NightWatchman.  I couldn't figure out how to use the same implementation either.  Sorry for misleading you.\nHere is a workaround for you though.\npublic static EitherAsync<L, R> BugFreeToAsync<L, R>(this Task<Either<L, R>> mma) => mma\n  .Map(ma => ma.ToAsync())\n  .Apply(mmma => default(MEitherAsync<L, R>).RunAsync(_ => mmma));\nTo be sure, you can check as I have that it passes these tests.\n```\n[Fact]\npublic async Task TaskEitherBugFreeToAsync_Left_IsLeft()\n{\n    var actual = await Left(0)\n        .Bind()\n        .AsTask()\n        .BugFreeToAsync()\n        .IsLeft;\n    Assert.True(actual);\n}\n[Fact]\npublic async Task TaskEitherBugFreeToAsync_Right_IsRight()\n{\n    var actual = await Right(0)\n        .Bind()\n        .AsTask()\n        .BugFreeToAsync()\n        .IsRight;\n    Assert.True(actual);\n}\n```\n. > The right hand side is being treated as a relative value, not an absolute one. This is intentional.\nSo why not convey this difference via the types involved?  This is one of our fellow contributors being confused by this design.  How many more users of this library will have the same confusion?. It seems more natural to me to combine the ToEither and ToAsync calls.  What do you think of that @nojaf? . Is this what you want?. My understanding is that the relevant part of your initial example is\nargs.HeadOrNone()\n       .ToEither(\"Nothing was inputted\")\n       .ToAsync() // this bugs me!!!\n       .MapAsync(AnswerOfTheUniverse)\nand that your primary concern is finding a nearly identical solution that avoids having to call .ToAsycn().  The solution I proposed would change your code to look like\nargs.HeadOrNone()\n       .ToEitherAsync(\"Nothing was inputted\")\n       .MapAsync(AnswerOfTheUniverse)\nYou can still pass your mapping function into MapAsync.\nTo this solution, you said\n\nNo, I still want to pass a mapping function.\n\nI don't think I understand.  What don't you like about my suggestion?\n. My preference is to combine function calls like ToEither and ToAsync because they map between types of monads that have the same inner type(s) while function calls like Map and Bind map between the same monad but with a different inner type (or types).. Another solution discussed in #163 (but which lacked favor) is to remove the dependency on System.Reactive.Linq.. Can you provide the link to the code where this happens?. Is your build and deployment processes available? If so, then one of us might be able to fix that for you. . Indeed.  Here is a slightly shorter MWE.\n```\n[Fact]\npublic async Task ValidationTaskSequence_Success_IsSuccessful()\n{\n    Task> validation =\n        Success>(1.AsTask())\n        .Sequence();\nvar result = await validation;\n\nAssert.True(result.IsSuccess);\n\n}\n``. InValidation, what isError?  Is that a type you defined, a type in Language Ext, or something else?. > When theTrydelegate is wrapping a network call, the currentBind` implementation will result in an interaction with the outside world. So is it correct to state in that given scenario its not Pure any more?\nSo what are the next steps here?\nMy understanding of purity is that in proving that some method is pure, you get to assume that its inputs are pure.\nFor example, consider this method\n[Pure]\npublic Option<A> Apply(Func<A, A, A> f, Option<A> fa, Option<A> fb) =>\n    from a in fa\n    from b in fb\n    select f(a, b);\nIt has the Pure attribute on it.  Of course f could make a network call, which is impure.  But if we assume that f is pure and that the process of converting fa and fb into a and b are respectively pure, then Apply is definitely pure.\nWhat I am more familiar with is proving correctness.  When method A depends on method B and you want to prove that method A is correct, then you get to assume that method B is correct.\n. > My issue is not about how any function in C# can technically be impure hence bind is impure.\nI not sure I made my point clearly enough.  I will try and say it another way.  I am saying that Bind is pure even if it is possible to pass an impure delegate into it.  Or said another way.  In absolute terms, Bind is pure.  But relatively speaking, maybe one can say \"This particular call to Bind is impure because the delegate passed to it is impure\".  Not exactly sure about this wording though.  This is how I think and speak about it, but maybe that is not how others think and speak about it.\n\nIn the case of composing Try\u2019s, given Try is a lazy construct, does the composition warrant strict evaluation?\n\nNo, you are correct; it does not. Recall that @louthy said\n\nIn this case the type is a lazy type and therefore it probably should be changed.\n\nin agreement with you on that point.\n. So how would you like this fixed @louthy?\nI don't see how to do this with the existing methods and their implementations.\nI think I could do it if the method\npublic Try<A> Run(Func<Unit, Try<A>> ma) =>\n    ma(unit);\nwere lazy instead of also being eager.. Sure, but you didn't change the second Bind you referenced to be lazy. That is what I don't know how to do with the currently available methods.. That method is trying to implement Bind \"from\" the Try monad \"to\" any other monad.  So what your issue has made me think is that methods like this have to be implemented lazily in case the target monad is lazy.. Yes, I think you are correct. Would you like to make a pull request to fix this?. It does.  Good work.  Can you also add a test for each method that exercises the desired behavior?. Why do you care so much about serialization for Option<>?\nIf I serialize and deserialize with Option<>, then I am allowing my application the possibility of crashing at runtime when the implementation of Option<> changes.  I only want my application to depend on the public API of Language.Ext.  That way the compiler can tell me if something has changed.\nAny time data needs to cross a boundary like serialization, I prefer to use Data Transfer Objects (DTOs) designed specifically for the job of being serialized from and being deserialized to.  Then this runtime crash will only occur if we modify our DTOs.\n. And I get the impression that most programmers prefer object oriented programming over functional programming.  Normally you prefer compile errors over runtime errors.  The purpose of my question is to get a better understanding of when you choose to forgo compile errors and permit runtime errors.. Thank you very much for this thorough response.  I very much appreciate the time and effort you put into these discussions.\nYour section on DTOs makes me think that we have of different understandings of what a DTO is.  To me, a DTO is syntactically a POCO  (i.e. no inheritance, no functionality...just public properties for members) and semantically its reason for existing is to quickly move data from one place to another.  As such, its lifetime is very short.\nWe might also have different ideas about about what (de)serialization is.  Is every lifting or lowering of a type considered deserialization or serialization (respectively)?  For example, is TimeSpan ts = TimeSpan.FromMinutes(1.0) deserializing a double into a TimeSpan?  Is double d = ts.TotalMinutes serializing a TimeSpan into a double?  I would say no.  I think of serialization as converting to a type like string or byte[] (and deserialization as the reverse).\nI could ask several followup questions to your post, but I would like to first share three examples of \"needs for serialisation\" that I am familiar with to hep ensure that we both talking about the same problem and solutions.  My intention with these examples is to convey my experience and understanding of these technologies and show how they have helped to form my opinions about DTOs.  I am is not trying to inform you in some general sense about technologies that exist or what they can do.\nData Context in WPF\nIn WPF, the UI is written in a declarative markup language called XMAL.  Data is supplied to this UI by referring to properties, by name, on a class known as its data context.  If such a UI refers to a nonexistent property, then this mistake is typically found by debugging the application in Visual Studio, loading that particular view, and observing in the log a data binding error.\nTo avoid these runtime errors, I prefer for the data context types to be DTOs.  Then I can refacor within C# except for these DTOs and know that I haven't broken anything.  The best factoring example is the renaming a property.  With this approach, the UI should change if and only if I change something in these DTOs.\nClient-Sever Communication\nData, after being serialized, is sent from the server to the client.  When the client is written in JavaScript, the behavior is similar to the previous case.  Data is accessed in the UI by property name.  Mistakes are found by running the server, loading a page in a browser like Chrome, and observing in the console that the attempted reading of a nonexistent property.\nI avoid these runtime erros in the same way using DTOs.  Again, the UI should change if and only if I change something in these DTOs.\nInstead of JavaScript, one can use TypeScript and then use TypeWriter to generate TypeScript types to match the C# types.  This doesn't remove the need for the DTOs though because I still can't use  Option<> as the type of a property on one of these DTOs.  (As least, I think this won't work because I don't think TypeWriter knows what type to use in TypeScript for Option<>.)\nDatabase with Entity Framework\nNearly all of my experience interacting with a database has been through Entity Framework (EF).  The enities are the primary source of information used to create the model of the database used by EF (such as which column are nullable, which column is the primary key, what constraints...such as maximum string length...exist, what addition behaviors should occur when a record is deleted or updated, etc.).  It is possible to specify all this configuration using the fluent interface, but that involves lots of extra work, the work is error-prone, and those errors are runtime errors.\nA nice way to ensure that this configuration is correct is to generate the entities (and any additional configuration) based on the database.  (As far as I know, this is only possible if the database is Microsoft's SQL Server.)  These autogenerated types might specify some of the configuration via property attributes.  This information is specific to this SQL Server data storage solution, so my business models will be different types.  These entities then are just DTOs for the purpose of getting data from the database and into my business models (or vice versa).\nI don't want to modify these autogenerated entities by adding an Option<> type, nor do I want to deal with the problem of configuring EF to properly map data within an Option<> type to and from a database.\nConclusion\nIn the sense of (de)serialization that I defined above, none of my examples include custom serialization code.  Admittedly though, they would typically include some liftings when mapping from the (short-lived) DTOs to the final (strong) type.\nI always want to use \"off-the-shelf serialisation\" in the sense that I do want to use a standard serializer like Newtonsoft.Json.JsonConvert with the simplest calls like SerializeObject(Object) and DeserializeObject(Object).  I do not want to make calls like SerializeObject(String, JsonSerializerSettings) or DeserializeObject(String, JsonSerializerSettings).  Instead, I would prefer to change the type being serialized.  I think this is easier for developers to read and understand.. > ...semantics of Record structural equality, docs say it only considers fields or field backed properties...\n\nI also noticed that auto-properties ARE considered in comparison\n\nAuto properties are indeed field-backed properties. . Oh, I think the intended semantics are as follows.  If the runtime type of source is Task<T>, then something semantically equivalent to this instance is returned with the stronger type.  Otherwise, the runtime type matches the compile-time type of Task but we still return an instance of Task<T> that completes when source completes and then returns default<T>.\nUnfortunately, neither case has this behavior.  The middle line is essentially dead code (as described above) and the last line, if reached, throws an excretion (as described here).\nIf you would like @louthy , I can make a PR that modifies this method to achieve the behavior I described above.. What about the case when source is not null?  I also think that behavior is incorrect (see #463).. I described what I think is the full intended behavior here.. > I had issues with implementing F# discriminated unions (went with \"safe enum C# idiom but not fully) especially in the context of equality.\nI am curious about this part. Can you provide a link to an example of this in your code?. I am having difficultly following your example.  Can you share a link to a specific location in the code that you are asking us to review that where you\n\nwent with \"safe enum C# idiom but not fully\n\n?. Ah, I looked at your C# code.  Here is the end of a specific example.  You have to include this \"dead code\" because (quoting from here)\n\nThe compiler does not emit a warning in those cases where a default case has been written but will never execute. This is consistent with current switch statement behavior where all possible cases have been listed.\n\nAlthough you don't have a default case, what you do is equivalent in this case.\nThere is a \"safer\" way to implement an #F discriminated union in C#, which is to use the visitor pattern.  Then you won't need dead code like that linked above.  Furthermore, the code would not compile if you added more cases (like converting from 3-by-3 tic-tac-toe to 5-by-5).. > I am asking for a review for all of it ;)\nAnd every journey occurs one step at a time ;). What about the visitor pattern is contrary to style of functional programming?. Don't be confused by Microsoft's Pattern Matching article that you linked to above.  It is not equivalent to the FP concept of pattern matching.  Instead, that article is about the idiomatic way to do \"C# pattern matching\".  In contrast, Language Ext\n\nuses and abuses the features of C# to provide a functional-programming 'Base class library', that, if you squint, can look like extensions to the language itself. The desire here is to make programming in C# much more reliable...\n\nAn opportunity exists in your C# code to make it more consistent with the spirit of this library: more reliable by being less idiomatic and more faithfully mapping sum types.. > Which approach do you think is better?\nIt depends.  Towards the beginning of an application's life, I think it is better to use the more flexible but less save approach that you first used (possibly with @louthy's syntax).  As an application matures (which also means that it is changing less), I think it becomes increasingly better to use the less flexible but more safe visitor pattern approach.  If you only ever want to pick one and never change, then I would typically go with the former.. You can probably use Language Ext to remove every if from your code, and it will be better for it.. For example,\npublic static Option<Board> makeMove(Board board, Move move)\n{\n  if (select(board, move.At) is Unspecified)\n    return Some(placePieceIfCan(move.Place.Value, board, move.At));\n  return None;\n}\ncould be written with a ternary as\npublic static Option<Board> makeMove(Board board, Move move) =>\n  select(board, move.At) is Unspecified\n    ? Some(placePieceIfCan(move.Place.Value, board, move.At));\n    : None;\nthough this change doesn't depend on Language Ext.  @louthy already suggested how to remove this if using Language Ext.  The remaining ifs in select and set can also be replaced with ternaries to help rid the code of noise as @louthy showed here.. I didn't check if it is released, but you accepted PR #470 that resolves this issue.. > I'm not entirely sure what it means nor the point but I don't want to spend time on it.\nI am not sure that I understand. If you don't want to spend time on this, then why did you create this issue? Are you saying that you will not reply to any questions asked of you on this issue?. Hello @rantri. That is great that you think you know the fix. This issue also bothers me. I opened issue #436 about it some time ago, but I haven't put enough time into it to find the solution. I hope your solution works!. For reference, here is a link to the Map section.\n\nI'm just trying the sample under the Map section on the main page, and am getting a compiler error.. When you say\nI look at my fork, I see a message telling me it's out of date. I click the button to create a pull request...\n\nWhere are you? What program are you using? Are you in a web browser looking at GitHub or something else?. > Please can someone help me here. I'm not sure how to resolve the conflicts using GitHub. I did the changes in Visual Studio, which didn't give me any warnings about conflicts. It now shows me as not having any pending changes. What do I do?\nYou don't resolve the conflicts in GitHub. You should resolve them in Visual Studio.\nMerge master into your branch. There will be conflicts. Then fix those conflicts in Visual Studio.\nDoes that make sense? . I do not. Sorry.\nSince you don't want to use the command line (and neither do I), I recommend that you try using SourceTree.\nhttps://www.sourcetreeapp.com/ . Merging conflicts is definitely a skill, so this is a great opportunity for you to practice it :). > According to\u00a0this page, there's supposed to be a \"Merge Pull Request\" button somewhere that does it, but I can't see it.\nYou are contributing the pull request. You create the pull request. @louthy is the only one that has the ability to merge a pull request.\n\nPlease can someone explain to me exactly how I get the latest code from the master into my fork? Please spell it out like I'm a really stupid dumb idiot who hasn't a clue about anything, because that's how I feel about it right at the moment!\n\nI will do this in a couple hours once I am on my laptop instead of my phone. . \nJust above where I am writing this comment, it says\n\nThis branch has no conflicts with the base branch\nOnly those with write access to this repository can merge pull requests.\n\nThat means that you @MrYossu resolved the conflicts.  Good job :)  Nothing more is required of you.  @louthy has write access to this repository (and I think he is the only one).  So as I said before, the ball is now in his court to accept your contribution by merging your pull request.. > When I created my fork, and did my first merge from the master, I created a pull request on my own repo, which pulled the changes in. I can't do that now though, because when I click the button to create one, it takes me to this page. I don't see any way of pulling the changes from the master to my fork.\n\nI really can't believe this is so difficult. I work with SVN on a daily basis, and it's a doddle compared to this.\nPlease can someone explain to me exactly how I get the latest code from the master into my fork? Please spell it out like I'm a really stupid dumb idiot who hasn't a clue about anything, because that's how I feel about it right at the moment!\n\nI will try to explain the work flow from first principles.\nI think a primary source of confusion for you is that you think that there are just two relevant copies of the code.  In fact, there are three:\n1. @louthy's GitHub copy of Language Ext,\n2. your (forked) GitHub copy of Language Ext, and\n3. your (forked) local copy of Langugage Ext on your local computer.\n\nHere is a screenshot of my SourceTree that shows the three views of the three copies of the code that are relevant to me:\n1. @louthy's GitHub copy of Language Ext is REMOTES => origin,\n2. my (forked) GitHub copy of Language Ext is REMOTES => fork, and\n3. my (forked) local copy of Language Ext is BRANCHES.\nI called my (forked) GitHub copy of Language Ext fork because it is the only fork of Language Ext that I care about.\nI don't care about REMOTES => fork => master, but I have left it there so that git and SourceTree don't complain about being unable to find some expected branch.\nCurrently, my local (forked) copy of Language Ext only has one branch in it, namely master-origin.\n\nThis branch is tracking REMOTES => origin => master.  By default, the name of this local branch would have been master instead of master-origin.  I picked this alternate name to clearly indicate which remote branch it is tracking.\nSuppose that I want to contribute some change to Language Ext.  Here is how I would do that.\n1. Pull the latest (14 new commits) from REMOTES => origin => master into BRANCHES => master-origin\n2. Create a new branch at that commit\n3. Commit changes to that branch\n4. Push that branch to REMOTES => fork\n5. Create a pull request in @louthy's GitHub copy of Language Ext by either\n - waiting for GitHub to see the branch pushed to my fork and offer me the button in the first screenshot below or\n - \"manually\" creating a pull request by explicitly selecting which branch that I want merged in (see the second screenshot below)\nFirst screenshot \"below\":\n\nSecond screenshot \"below\":\n\nDoes this answer some of your questions @MrYossu?  Is there anything that is still unclear to you? . > ...at least I understand this a lot better.\n\nSo I got the idea of the three database correct, although it was good to see that I'd got it right!\n\nGreat.  There is still some room for improved understanding there.  In confusing times like this, it is helpful that we speak precisely.  So below I will share some places where I think the clarity of your wording in your previous comment could be improved.  I am not trying to be nit picky.\nMost importantly, let me begin with a comment about forks.  You agree that you are in control of two forks (of Language Ext): one on GitHub and one on your local machine.  So when you refer to one of these forks, you should say if it is your GitHub fork or your local fork.  \n\nI got the idea of the three database correct\n\nthree ~database~ repositories\n\nI created a fork, which was my copy of Paul's master. This lives in GitHub. I then pulled this into VS, which is my local copy.\n\nYes, essentially correct.  However, you didn't really pull anything into Visual Studio.  You created a second fork of Language Ext on your local machine.  You could have done using the command line, Source Tree, Visual Studio, or many other programs.  Then, after this fork is created, you opened the solution file contained in that fork with Visual Studio.\n\nIn the meantime, the master was updated with new commits which I don't have.\n\nWhich you don't have in either your GitHub fork or your local fork.\n\nSo, it seems to me that I need to get those new commits from the master...\n\n...from the master branch in @louthy's GitHub copy...\n\n...into my forked repo, from where I can pull them down to VS and make the changes.\n\nWhat you mean here is \"into my forked repo on GitHub, from where I can pull them down to my local fork and make the changes\".\nYou could do that, but it is not necessary.\n\nI haven't updated the master branch in my GitHub fork since about December 2017.\n\nI'm not trying to push my changes into the master repo\n\n...into @louthy's GitHub copy of Language Ext.\n\nWhere i got stuck (and still am) is that I couldn't see how to get the new commits from the master repo into my fork.\n\n...from @louthy's GitHub copy of Language Ext into my local fork.\n\nI assumed (again, correct me if I'm wrong here) that I would have to do that from the GitHub web site, as my local copy in indeed VS knows nothing about the master. It only knows that it's working against a repo, namely my fork.\n\nFalse.  You have write access to both of your forks and you have read access from all three copies.  You can read from @louthy's GitHub directionly into either of your forks with (again) many different programs, including the command line, Source Tree, and Visual Studio.  If you want to do this from Visual Studio, use the Team Explorer feature.\nI don't get the impression that you understood my step-by-step instructions from my previous comment for how I would contribute a change to Language Ext.  In my first step, I read from @louthy's GitHub copy of Language Ext directly to my local fork (not from my GitHub fork).\nIn the broadest possible terms, the simplest work flow for contributing a change to a repo on GitHub that you have already forked on GitHub is\n1. Pull the latest changes from the \"master\" repo (as you called it before) directly into your local fork.\n2. Make an commit changes in your local fork.\n3. Push your changes to your GitHub fork.\n4. Use GitHub to create a pull request (from your GitHub fork into the \"master\" repo).\n\nEnter SourceTree, which apparently will allow me to do this. Problem is, irrespective of which copy of the code I select, my SourceTree only shows commits that were made to the master before I took my fork. It doesn't show any since, so I can't get the new commits.\nEven if I click on REMOTES -> origin (which you said should show me the master copy), I see my most recent commit to my fork as the latest...\n\nYou need to add @louthy's GitHub copy of Language Ext as a remote.  Go to Repository => Add Remote... and make it look like mine (see below).\n\n. You are welcome @MrYossu.  I enjoy helping others. :). Yep! Under the title of this PR, it now says \"Merged\".  Thanks :). Create a new pull request.  It gets confusing to review the same branch more than once.\nYou are welcome :). Yep.  Welcome.. You can create a failing test like I did in #317. I have put a lot of thought into this. I don't think it is so obvious when to use ConfigureAwait(false). I used to follow the advice from articles like the one to which you linked. In particular, I have had some PRs included into Language Ext that used ConfigureAwait(false). However, I am not so sure now.\nSuppose you write a failing test and then contribute a PR on which your test passes. Then I think that I can write a test that passes on master but fails on your commit. More specifically, my test would include context-sensitive code that I would have executed in the correct context on master but in the wrong context on your commit.\nAs it says in the article to which you linked, my test would fail because an exception would be thrown.  In contrast, your test would fail (at least in principle) because a deadlock occurred.\nTo be clear, I would prefer to debug \"my\" thrown exception than \"your\" deadlock. So I do agree with your request to add more calls to ConfigureAwait(false).. Suppose Language Ext always calls ConfigureAwait(false) after awaiting a task.  Then executing\n```\npublic void async OnButtonClick(...) => await GetUnitAsync()\n  .Bind(_SomeContextSenstiveMethod);\npublic static async Task GetUnitAsync() {\n  Task.Delay(1);\n  return unit;\n}\n``\nwill throw the exception in_SomeContextSenstiveMethod` because it is not executed in the correct context.\nThis Bind calls SelectMany, which is defined as\npublic async static Task<U> SelectMany<T, U>(\n    this Task<T> self,\n    Func<T, Task<U>> bind\n    ) =>\n    await bind(await self);\nHowever, I am assuming that this method is implemented as\npublic async static Task<U> SelectMany<T, U>(\n    this Task<T> self,\n    Func<T, Task<U>> bind\n    ) =>\n    await bind(await self.ConfigureAwait(false)).ConfigureAwait(false);\nAfter the the first await, we are no longer in the same context because (1) that task actually executes asynchronously and (2) we called ConfigureAwait(false).  So we execute bind in the wrong context (namely the context of the background threadpool), and it throws the exception about the wrong thread trying to change the UI.\nI believe the correct bug fix is to modify the implementation of OnButtonClick to not use Language Ext, such as\npublic void async OnButtonClick(...) =>\n  await _SomeContextSenstiveMethod(await GetUnitAsync());\nThe difference is that the task returned from the call to GetUnitAsync is awaited without also calling .ConfigureAwait(false).  In fact, it is a special case of Bind/SelectMany in which the two arguments have been hard coded.. I think Appl is short for Applicative, not Apply.. > 1. Strong naming is a breaking change\n\n...\n\nA new major version 4.0.0 will need to be published\n\n\nI don't think @louthy (strictly) follows semantic versioning.. After adding using static LanguageExt.Prelude; to the top of your file, I think you want\nTry(() => GetAnswer(PrimaryTravelTypeQuestionID))\n    .Match(\n        s => ticket.FseTravelType = s,\n        e => Log.Error(e));. > As it happens, I've been reading Functional Programming in C# by Enrico Buonanno (on my third time through), and he explains a lot of the same things you're saying, which is good. I'm reading the book over and over again, trying to get it all clear.\nWow, this looks like a great book.  I just bought it.  I am very excited to read it.\nThanks for mentioning it! :). > hash code will be different for equal items\nThat is unacceptable.. What logic is so special that it gets decorated with the adjective \"business\"?  I sometimes use the phrase \"business logic\" (correctly I think), but I don't know a good definition for it.. > ...any logic that encodes business rules.\nI don't know a good definition for \"business rule\" either.. > This means I end up with more of a sandwich structure: impure-pure-impure-pure-impure which just feels wrong.\nBy definition, a pure function cannot have compile-time dependencies on any impure function.  So by this \"sandwich structure\", you must mean that the code being executed at runtime alternates between pure and impure, right?. Here is how I would present this bug.\nMy expectation is that this test would pass...\n[Fact] // fails\npublic void OptionMap_ToNull_ThrowsValueIsNullException()\n{\n    var option = Some(new object());\n    Assert.Throws<ValueIsNullException>(() => option.Map(_ => (object)null));\n}\n...because then the behavior would be consistent with other monads like Either<,>:\n[Fact] // passes\npublic void EitherMap_ToNull_ThrowsValueIsNullException()\n{\n    var either = Right(new object()).Bind<Unit>();\n    Assert.ThrowsAny<Exception>(() => either.Map(_ => (object)null));\n}\nInstead, I expect this test to fail, but it passes:\n``\n[Fact] // passes\npublic void OptionMap_ToNull_ExpectItToFailByThrowingValueIsNullException()\n{\n    var option = Some(new object())\n        .Map(_ => (object)null);\n    Assert.Equal(None, option);\n}. Maybe changing [ReturnofOption<>`](https://github.com/louthy/language-ext/blob/master/LanguageExt.Core/ClassInstances/Monad/MOption.cs#L198) is correct.\nAt least the behavior for Map of FOption should be changed, either directly or indirectly.  I achieved this in PR #518 by directly changing that function.. There is a prelude method called raise that throws a given exception. Here is an example of it being used:\nhttps://github.com/louthy/language-ext/blob/c412a962fac7110845b80d0f80a467cc929637ff/LanguageExt.Tests/TryAsyncTEsts.cs#317 . @louthy gave an answer to this on Stack Overflow once.\nhttps://stackoverflow.com/questions/38575646/general-purpose-immutable-classes-in-c-sharp/38596298#38596298. I don't think this is a good idea.\n\nAt the moment I have to write code like this\n\n\"have to\" is a strong phrase.  There is very little that you have to do.\nHere is a fluent workaround using the existing API.\n```\npublic void Method() =>\n    new ApplicationRunner()\n        .Bind(CheckAlreadyRunning)\n        .Map(Initialize);\n        .Bind(CheckPermissions);\n        .Match(Run, ShowErrorMessage);\nprivate T Initialize(T t) {\n    // do initializing work\n    return t;\n}\n```\n. There is already a method called IfRight with input type Action<> (that returns Unit), so you can't add public Either<L, R> IfRight(Action<R> right) like you are requesting without removing that method.. Task is the asynchronous equivalent ofvoid.  Neither are consistent with functional style..\nIn my local project, I have created an extension method that lifts Task to Task<Unit>.  I prefer adding this one method than adding overloads everywhere for Task.. First, some small comments.\nSince 1 / n return int when n is an int, the type of f is more specifically Func<int, int>.\nYou can eta reduce nums.Select(n => f(n)) to simply nums.Select(f). Also, Select is probably not the best name for this behavior.  Microsoft picked it because of its similarity to the concept with the same name in SQL.  In functional programming, this behavior is known as Map.  Language Ext contains a function called Map that just calls this Select.  That way, you can write nums.Map(f).\nNow to answer your question, here is the first thing that comes to mind for me.\nIEnumerable<Either<Exception, double>> result = Range(0, 10)\n    .Map(n => Try(() => 1.0 / n))\n    .Map(t => t.ToEither());\n//Requirement 1\nIEnumerable<double> r1 = result.Rights();\n//Requirement 2\nIEnumerable<Exception> r2 = result.Lefts();\n\n...I find playing around like this helps me understand what's going on.\n\nYou are right, and you should continue to do so.. Oh, I think I understand what you are saying.  Let me try and repeat it back to you.\nLst<NonEmpty, A> is (practically speaking) a \"stronger\" type than List<A>.  As such, it would be ok to implicitly \"cast down\" from the stronger type Lst<NonEmpty, A> to the weaker type List<A> but \"casting up\" from the weaker type List<A> to the stronger type Lst<NonEmpty, A> should only happen explicitly.\nHowever, your code demonstrates that the current behavior of Language Ext is to implicitly (attempt to) cast up in this case (and then throw this ArgumentOutOfRangeException when that cast fails).\nDid I get that right?. Oh, I just realized that this issue is also blocking me from upgrading Language Ext.  When I tried to upgrade some months back, many of my tests failed, but I never had the chance to debug why.\nWe are targeting .Net 4.6.1, and I just confirmed that my tests pass using version 3.0.28 but fail with version 3.0.31 by throwing an exception when trying to access some property backing fields of a Record<> type.. Looks perfect.  Thanks! :). I don't see the value using the Pure attribute, so I am indifferent about removing it.. So 3.0.31 works for you and 3.1.13, 3.1.14 and 3.1.10 don't work for you.\nWhat is the first/oldest version after 3.0.31 that doesn't work for you?. Here are the commits that defined those two versions:\n\n3.0.31\n3.1.10. You could try creating your own NuGet packages for commits between those two commits and seeing if your build passes.  If you do that, I recommend trying those two commits first and confirming that you are able to reproduce the current behavior.. I don't even see PureAttribute on Option<>.Bind<> when using reflection within the Language Ext solution.. > I think it shouldn't be the case as the method in question is annotated with [Pure], so I assume that the problem happens because the assembly I get with NuGet strips the attribute, since it is defined with conditional symbol CONTRACTS_FULL.\nSo, my question is, what is the recommended way to use Language-Ext in a project and makes it recognize [Pure] attributes that the library contains?\n\n\n\n\nI don't even see PureAttribute on Option<>.Bind<> when using reflection within the Language Ext solution.\n\nOk.  I figured out what is going on.\nAs @mysticfall pointed out, PureAttribute is defined with the attribute Conditional(\"CONTRACTS_FULL\").  Language Ext doesn't have the symbol CONTRACTS_FULL defined and @louthy doesn't define it (temporarily) during the build that creates the NuGet package, so this attribute gets ignored.\n@louthy, here is how to include PureAttribute in the assembly.\nVia Visual Studio:\n\nWhich corresponds to this source file change:\n\n. Yes, there are several overloads called use.  . I am not sure what docs you are expecting to find or if such docs exists.\nHere are tests of all the use methods.  That should help you figure out what you would like to know.. If the UI is a web browser, then the HTTP communication channel forces Command Query Separation (with commands like PUT, POST, and DELETE and queries like GET).\nIf the UI is desktop application written with WPF, then as you have experienced, one way to send data to and receive data from the UI is by creating bindings with properties on view models.\nRecall that properties in C# are just syntactic sugar for getter and setter methods.  These methods can be implemented in any way you like.  In particular, you can implement the getters the same way you would implement HTTP requests like GET, and you can implement the setters the same way you would implement HTTP commands like PUT, POST, and DELETE.\nTherefore, there is nothing fundamentally different about MVVM from the perspective of FP.. I think I wasn't clear enough.  I will try to be more specific (and conversational).\nFirst, MVVM is one of those things for which it is difficult for two people to have the same understanding.  For our discussion here, I will try to avoid this complication by referring to your understanding of MVVM.\nConsider an application with a client and server that communicate with either other over HTTP.  For such an application, is it possible to create using your understanding of MVVM?. My opinion of MVVM, MVC, and MVP is that they are essentially the same from the perspective of design.  All three separate the logic and data about the same.  I think of them as only differing in implementations details that are orthogonal to design.\nIn a WPF application, new data can be passed to the UI by putting that data in a some property and raising the INotifyPropertyChanged event for that property.\nIn a client/server application communicating over HTTP, new data can be passed to the UI by putting that data in some property, serializing the instance with that property, and providing the serialization to an open web socket.\nI think of both of these as achieving the same design goal with different implementation details.\nSimilarly, in a WPF application, new data can be received from the UI when the setter of a bound property is called.\nIn a client/server application communicating over HTTP, new data can be received from the UI when a method for a specific route is called.\nAgain, I think of both of these as achieving the same design goal with different implementation details.. > For example, one of my windows has a view model property for an entity that represents a medical imaging system (a complex object graph). This is bound to the DataContext for the view, and the XAML then binds to properties on that entity, and child properties, grandchild properties etc.\nThe DataContext for the view?...like, you only have one of each?  When I have created GUIs with WPF, I have always created many nested views that each have nested view models assigned to their DataContext property.  I don't see how this matters though for the purposes of our conversation.\n\nAre you suggesting I create 150 view model properties, and bind each of these controls to its own?\n\nI don't think so. I don't see why you think am suggesting that or why this would be necessary for what I am suggesting.. In the simplest case, RevisionNotes is an auto property and looks like\npublic string RevisionNotes { get; set; }\nbut it doesn't have to be an auto property.  You can make it into a non-auto property.  In which case, that get combined with with raising INPC for RevisionNotes is like sending data to a web client using a web socket, and that set is like the client posting data to some route on the server and some method on a controller being invoked.. You created this issue because you have a specific questions about the relationship between FP and MVVM.  If I understand all of these UI-related design patterns, then I have given a reduction from MVVM to MVC.  I think a similar reduction is possible from MVC to MVVM.\nI don't see what is so special about MVVM in your question.  It seems to me that you are actually asking \"Can you do FP in an application with with a UI?\".\nIs there a type of UI (or UI-related design pattern) for which you know how to \"do\" FP \"in\" that type of UI?. > It seems to me that you are actually asking \"Can you do FP in an application with with a UI?\"\nTo be clear, I think this is a really good question.  I recall another issue discussing this (essentially about how to properly mix pure and impure code), but I can't find it now.. > Maybe this is the wrong way to think about it, but I'm wondering if the relationship between the UI and the first layer of non-UI code could be one of those boundaries (like database access) where impure coding becomes pragmatic. My impression is that unless you're using a database like Event Store, then you're stuck with impure mutable state at that end.\nI think Event Store is a very interesting idea.  I would love to try it but haven't done so yet.\nAs a \"recovering\" object-oriented programmer, I am still trying to retrain my mind and shake off my old habits.  That said, my currently understanding of all this is that mutation must eventually happen in order for some useful work to occur.  When the user requests (at least conceptually) that some piece of persistent state should change (such as setting a different username for themself), then we must write impure code (even when using Event Store).  I think one of the main ideas of functional programming is to break that code into two parts, the pure part and the impure part while also maximizing the size of the pure part.\n\nAs you've probably guessed by now, I'm a rank amateur with FP. I'm totally smitten with it, and have gone over to a very FP-way of coding on a micro scale, ie individual methods, but am struggling to see how to put it all together in a full end-to-end application.\n\nI am also on that road that \"ends\" at the ideal functionally designed application.  However, I do get the impression that I could be further down this road than you and able to offer some suggestions.\n\n\nYou can make it into a non-auto property. In which case, that get combined with with raising INPC...\n\n...I usually work with entities created by Entity Framework, in which case I don't write any of the getter/setter code, it's generated by the framework. Am I right in thinking that this is not going to fit with what you're suggesting?\n\nI think this is a bad idea.  The purpose of the entities in Entity Framework is to transfer data in and out of the  datastore \"behind\" Entity Framework.  If you reuse those classes to also transfer data in and out of your WPF UI, then you will have to deal with competing concerns.\nInstead, I recommend having Entity Framework entities that change for reasons solely to do with Entity Framework reasons, and I recommend having view models (that you set as the DataContext in WPF) that change for solely WPF reasons.  In addition to those two groupings of data types, I also recommend model types that only change for modeling reasons.  The business logic should only depend on these model types and not on Entity Framework's entities nor on WPF's view models.  I think of this as independent and somewhat more important that FP vs OOP (i.e. whether using FP or OOP, I would want my concerns separated like that).\nGiven those separations, I think the next thing to focus on is model design.  Here are two articles I found and read recently that think do a good job at this.\nThen I would focus on extracting the pure code into (often static) methods.\nI think it would be easier to learn FP if I were able to start working on a brand new application at my job.  I assume that you are like me and am doing the best you can to learn FP with the existing application in front of you.  For me, I often feel handcuffed having to debug race conditions day after day.  I would have rather spent that time trying to write new functional code and feeling the different pinpoints firsthand.\nSo, because I am limited by the application in front of me (the design of which is mostly contrary to FP principles), I don't currently feel the need or pressure to figure out...\n\nhow to put it all together in a full end-to-end application\n\nMaybe you are in a similar position and am also able to make progress on your understanding of FP without also knowing how it all comes together in a full application.\n\nI'm the sort of (slightly OCD) person who likes to understand what I'm doing, rather than copy someone else's code blindly.\n\nI am the same way, and I think we are better for it :). > Does that sound reasonable?\nIt does.\nOne caution is to make sure you are aware of the difference between compile-time dependencies and runtime dependencies.  For example, the business models should not have a compile-time dependency on the Entity Framework entities.  However, you can imagine the flow data types when saving as something like \"view model -> business model -> EF entities\".  That is still not a runtime dependency, but it is similar to one.\n\nTo a large extent, it sounds very much like the approach Scott Wlaschin laid out in Domain Modeling Made Functional (an excellent book that I strongly recommend to anyone wanting to learn FP, even if you don't intend using F#).\n\nFor a long time, I have wanted to read a book about domain-driven design.  This looks perfect!  I just bought it :)\n\nHow do you fancy whiping up an end-to-end sample?\n\nI would love to., but I don't foresee it happening any time soon.  The main issue is lack of time.  The other issue is the difficulty in deciding on a good example.  It needs to be complicated enough to show the \"general case\" but not so complicated that the complexity distracts from the teaching.. Are you able to share a simpler example with complete code?  I am having a hard time getting your code to compile (let alone reproduce the problem you are having).  For example, you didn't post the implementation of Finding.. I think I understand your problem.  First, I will share my suggestion and then explain why you were having trouble.\nSuggestion\nIn the Option<> case, I recommend this code:\nvar groupings = cells\n    .Somes()\n    .GroupBy(c => (c.TimePeriod, c.Periodicity))\n    .Map(g => new QueryGrouping(\n        g.Key.Item1,\n        g.Key.Item2,\n        g));\nThen in the Validation<,> case, I recommend reducing to the Option<> case with this code:\nvar groupings = cells\n    .Map(val => val.ToOption())\n    .Somes()\n    .GroupBy(c => (c.TimePeriod, c.Periodicity))\n    .Map(g => new QueryGrouping(\n        g.Key.Item1,\n        g.Key.Item2,\n        g));\nExplanation\n\nI would expect the Select definition for Validation to only return the good state since this is monadic flow.\n\nThat is true, but the code in your example is not calling Validation<,>.Select; it is calling IEnumerator<ValidationData<,>>.GetEnumerator, which is defined on IEnumerable<ValidationData<,>>.\nEach LINQ syntax query can only \"unwrap\" a single monad (or, more generally, functor).  In both of your examples, the single functor in question is IEnumerable<>.  Both Option<> and Validation<,> implement IEnumerable<T> for some type T.  For Option<A>, we have T = A.  For Validation<F, S>, we have T = ValidationData<F, S>.  Enumerating over an Option<A> will yield an A it if has one and nothing otherwise.  Enumerating over Validation<F, S> will yield exactly one ValidationData<F, S> in the appropriate state and containing the corresponding data.\n\nI presume I have to explicitly call Success on c because it has two states?\n\nSort of, but the Success property could contain garbage data if the ValidationData<,> instance is in the other state.\nBy looking at your code, I think you are trying to filter out the instances of Option<> and Validation<,> that are not in the \"good\" state and then mapping the remaining CellData instances to  QueryGrouping instances.  (In particular for your Option<> case, you start with cells of type IEnumerable<Option<CellData>> and end with groupings of type IEnumerable<QueryGrouping>.)  That is exactly what my suggestions do.. > @bender2k14 Thank you! That worked!\nYou're welcome.  Glad to help :)\n\nIs there a reason there is not something similar to Somes for Validation like Successes?\n\nNo reason that I know of.  I think this sounds like a good feature request to me.. IEnumerable<Seq<string>> errors = cells\n  .Map(v => v.Match(_ => None, Some))\n  .Somes();. > Here is an example of one of the validation methods above.\nCan you make that example complete by providing the definitions of CompanyIDValidator and CompanyId?\n\nThe problem is I just end up with an IEnumerable of strings that lose all of the original data.\n\nThe goal is to keep the data in stronger, more specific types as long as possible.  Only \"project\" back down to weaker types like string as the last possible moment.\n\nWhat's a good way to maintain the input state to the function so I can report those back in their matching columns?\n\nFor starters, you can create and use a parameter object containing the inputs to the function.  In OOP, this refactoring step goes by the name \"introduce parameter object\".  (I know that I am being a bit vague here.  I wanted to include a link, but every potential source that I considered was tained with additional OOP-specific information.)\n\nI would like to generate the Finding class below that accumulates errors in their appropriate fields instead of a list of strings.\n\nWhy?. > I plan on making public static functions to create my CompanyIds and making the ctor private so that only something that passes my validation criteria can be a CompanyId.\nYes, yes, yes!  I really like this style and was going to suggest it.  Enrico Buonanno calls this the smart constructor pattern in his book Functional Programming in C#.\n\nSomething like this?\n\nYep.  And if you have it extend LanguageExt.Record<RawData>, then you can call ToString() to get a single string with all of this data in it.\n\npublic static implicit operator BaseStringSynonym(string s) => new BaseStringSynonym(s);\n\nI am very happy with Enrico's book and heartily recommend it to all C# programmers.  However, I don't always agree with him.  One place I disagree is with his preference for implicit operators from a weak type like string to a stronger type ConnectingString (see Listing 7.5 on page 161 of his book).  Instead, I recommend having a smart constructor on ConnectingString that maps a string to (say) Validation<string, ConnectionString>.\nSo in your case, I recommend removing your implicit operator from string to BaseStringSynonym.  I think such an operator has even fewer advantages when you upcast to a base type like that.\n\nI see your point and perhaps I need a base class for my findings and have a ValidFinding and InvalidFinding, where the ValidFinding has CompanyId, Mnemonic, TimePeriod, and Periodicity types in it and InvalidFinding has plain strings.\nA simpler Idea than a custom monoid, would be to have my error type for validation be Finding, so I get IEnumerable and then fold the results in the end into a merged Finding. I would just need to pass all inputs into each validation function, perhaps using an object like you suggest and then checking the respective fields of that object in each validator.\n\nFirst, I don't see why ValidFinding and InvalidFinding finding would share a custom base type.\nOtherwise, it seems reasonable to me that you create a function from RawData to Validation`.\nWhat do you think?. > So you're suggesting, instead of implicit operators, just make ConnectionString a POCO with an internal string and a ToString() method and a smart constructor?\nNot quite.  I only disagree with the implicit operator from the weaker type like string to a stronger type like ConnectionString.  I agree with the implicit operator in the other direction from a strong type like ConnectionString to a weaker type like string.  I prefer to use the ToString() method only for debugging.\nSo starting from ConnectionString in Listing 7.5, I would\n1. remove the implicit operator from string to ConnecitonString,\n2. add inheritance from Record<ConnectionString>,\n3. add a smart constructor, and\n4. make the constructor private.\nI would still have a single property of type string that stores the connection string.  The implicit operator from ConnectionString to string would return this string.  Over time, I would increase the expressiveness by exposing the individual key-value pairs in the same spirit as SqlConnectionStringBuilder.  But of course, my type would differ in that I would keep it immutable and use a With method (as discussed by Enrico in section 9.3.2) to return new instances when a change is requested.\n\nMaybe you're right a bout the base type, but the output columns need to line up with the csv headers unless I decide to separate the failures, which might make sense, but like I said, I was curious how difficult doing something easy in an OO procedural way would be in FP.\n\nCould you give a couple each of valid and invalid examples of RawData instances and what kind of CSV output you want for them?. > Here are two examples I'd like to try to output, the first being closer to the ideal\nI think you might have the order of those two links confused because later you say...\n\n...for the first example, if it failed add it to a list of failures associated with that row, or in the later case I'd just update the fields destructively adding \"Invalid Inputs\" in the final column.\n\n...and I agree with that impression that I got here, which is that it is preferable to add the error messages to the list of failures than to modify the (string output of the) invalid values.\nI coded up something that adds the error messages to the list of failures.  I looked though all the code that you provided.  I think much of it was unrelated to the essential problem that you are (currently) asking about in this issue (as I understand it).\nTo try to keep things simple, I code up everything from scratch except for RawData and Finding types, which are essentially the same.\n\nTo check whether I should query the database I'd either check where the list of errors was empty or in the second case if the invalid field was empty.\n\nI don't recommend this.  The decision to query or not should be made using an strong \"internal\" type not based on the string value of some output data.  (By \"internal\" type, I mean a type not used to get data from or send data to the world outside of the program).  Notice how my code \"decides\" to query the database when the Validation<,> instance is in the success state (via the Map method).  You don't want the logic to decide if the database get queried to depend on the format of data displayed to the user.\nSo (finally), what do you think of this?\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing LanguageExt;\nusing static LanguageExt.Prelude;\nnamespace MyNamespace {\npublic static class Program {\npublic static Seq<RawData> ExampleRawData => Seq(\n  new RawData(\"Data_1\", \"$B$2\", \"ABC129638\",        \"BHCK#$%^3210\", \"3Q2017\",    \"QTR\",     \"4334630\", \"2/6/2019 14:20\"),\n  new RawData(\"Data_1\", \"$B$2\", \"LMN00117622\",      \"BHCK9210\",     \"1233Q2017\", \"QTR\",      \"219083\", \"2/6/2019 14:20\"),\n  new RawData(\"Data_1\", \"$B$2\", \"XYZ0001!@#$17665\", \"BHCK3210\",     \"3Q2017\",    \"QT!@#$R\",  \"100644\", \"2/6/2019 14:20\"),\n  new RawData(\"Data_1\", \"$B$2\", \"ABC129638\",        \"BHCK9210\",     \"3Q2017\",    \"QTR\",     \"4334630\", \"2/6/2019 14:20\")\n);\n\npublic static void Main() {\n  var findings = ExampleRawData\n    .Map(ToFinding)\n    .ToList();\n}\n\nprivate static Finding ToFinding(RawData rawData) => rawData\n  .Apply(Validate)\n  .Map(_ => DatabaseQuery(rawData))\n  .Match(\n    t => Finding.Empty.With(\n      dbValue: t.Value.ToString(),\n      dbLastUpdate: t.DbLastUpdateTime.ToString(\"M/d/yyyy HH:mm\"),\n      validation: \"Ok\"),\n    errors => Finding.Empty.With(\n      validation: errors.Delimit(\"; \")))\n  .With(\n    sheet: rawData.Sheet,\n    range: rawData.Range,\n    companyId: rawData.CompanyId,\n    mnemonic: rawData.Mnemonic,\n    timePeriod: rawData.TimePeriod,\n    periodicity: rawData.Periodicity,\n    cacheValue: rawData.CachedValue,\n    cacheLastUpdateTime: rawData.CacheLastUpdateTime\n  );\n\nprivate static Validation<string, Unit> Validate(RawData rawData) =>\n  (rawData.Sheet.Apply(Sheet.New),\n   rawData.Range.Apply(Range.New),\n   rawData.CompanyId.Apply(CompanyID.New),\n   rawData.Mnemonic.Apply(Mnemonic.New),\n   rawData.TimePeriod.Apply(TimePeriod.New),\n   rawData.Periodicity.Apply(Periodicity.New),\n   rawData.CachedValue.Apply(IntValue.New),\n   rawData.CacheLastUpdateTime.Apply(LastUpdateTime.New))\n  .Apply((a, b, c, d, e, f, g, h) => unit);\n\nprivate static (int Value, DateTime DbLastUpdateTime) DatabaseQuery(RawData rawData) =>\n  (4334630, new DateTime(2019, 2, 6, 14, 20, 0));\n\npublic static string Delimit(this IEnumerable<string> values, string delimiter) =>\n  string.Join(delimiter, values);\n\n}\npublic class RawData {\n    public string Sheet { get; }\n    public string Range { get; }\n    public string CompanyId { get; }\n    public string Mnemonic { get; }\n    public string TimePeriod { get; }\n    public string Periodicity { get; }\n    public string CachedValue { get; }\n    public string CacheLastUpdateTime { get; }\npublic RawData(\n  string sheet,\n  string range,\n  string companyId,\n  string mnemonic,\n  string timePeriod,\n  string periodicity,\n  string cacheValue,\n  string cacheLastUpdate\n) {\n  this.Sheet = sheet;\n  this.Range = range;\n  this.CompanyId = companyId;\n  this.Mnemonic = mnemonic;\n  this.TimePeriod = timePeriod;\n  this.Periodicity = periodicity;\n  this.CachedValue = cacheValue;\n  this.CacheLastUpdateTime = cacheLastUpdate;\n}\n\n}\npublic sealed class Sheet : Record {\n    public string Value { get; }\n    private Sheet(string value) => Value = value;\n    public static Validation New(string value) => new Sheet(value);\n    public static implicit operator string(Sheet self) => self.Value;\n  }\npublic sealed class Range : Record {\n    public string Value { get; }\n    private Range(string value) => Value = value;\n    public static Validation New(string value) => new Range(value);\n    public static implicit operator string(Range self) => self.Value;\n  }\npublic sealed class CompanyID : Record {\n    public string Value { get; }\n    private CompanyID(string value) => Value = value;\n    public static Validation New(string value) => Some(value)\n      .Filter(IsValid)\n      .ToValidation($\"Invalid CompanyID {value}\")\n      .Map(v => new CompanyID(v));\n    private static bool IsValid(string value) => !value.Contains(\"@\");\n    public static implicit operator string(CompanyID self) => self.Value;\n  }\npublic sealed class Mnemonic : Record {\n    public string Value { get; }\n    private Mnemonic(string value) => Value = value;\n    public static Validation New(string value) => Some(value)\n      .Filter(IsValid)\n      .ToValidation($\"Invalid Mnemonic {value}\")\n      .Map(v => new Mnemonic(v));\n    private static bool IsValid(string value) => !value.Contains(\"#\");\n    public static implicit operator string(Mnemonic self) => self.Value;\n  }\npublic sealed class TimePeriod : Record {\n    public string Value { get; }\n    private TimePeriod(string value) => Value = value;\n    public static Validation New(string value) => Some(value)\n      .Filter(IsValid)\n      .ToValidation($\"Invalid TimePeriod {value}\")\n      .Map(v => new TimePeriod(v));\n    private static bool IsValid(string value) => !value.Contains(\"123\");\n    public static implicit operator string(TimePeriod self) => self.Value;\n  }\npublic sealed class Periodicity : Record {\n    public string Value { get; }\n    private Periodicity(string value) => Value = value;\n    public static Validation New(string value) => Some(value)\n      .Filter(IsValid)\n      .ToValidation($\"Invalid Periodicity {value}\")\n      .Map(v => new Periodicity(v));\n    private static bool IsValid(string value) => !value.Contains(\"$\");\n    public static implicit operator string(Periodicity self) => self.Value;\n  }\npublic sealed class IntValue : Record {\n    public int Value { get; }\n    private IntValue(int value) => Value = value;\n    public static Validation New(string value) => value\n      .Apply(parseInt)\n      .ToValidation($\"Invalid IntValue {value}\")\n      .Map(iv => new IntValue(iv));\n    public static implicit operator int(IntValue self) => self.Value;\n  }\npublic sealed class LastUpdateTime : Record {\n    public DateTime Value { get; }\n    private LastUpdateTime(DateTime value) => Value = value;\n    public static Validation New(string value) => value\n      .Apply(parseDateTime)\n      .ToValidation($\"Invalid LastUpdateTime {value}\")\n      .Map(dt => new LastUpdateTime(dt));\n    public static implicit operator DateTime(LastUpdateTime self) => self.Value;\n  }\npublic class Finding {\n    public static Finding Empty = new Finding(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\");\npublic string Sheet { get; }\npublic string Range { get; }\npublic string CompanyId { get; }\npublic string Mnemonic { get; }\npublic string TimePeriod { get; }\npublic string Periodicity { get; }\npublic string CacheValue { get; }\npublic string CacheLastUpdateTime { get; }\npublic string DbValue { get; }\npublic string DbLastUpdate { get; }\npublic string Validation { get; }\n\npublic Finding(\n  string sheet,\n  string range,\n  string companyId,\n  string mnemonic,\n  string timePeriod,\n  string periodicity,\n  string cacheValue,\n  string cacheLastUpdateTime,\n  string dbValue,\n  string dbLastUpdate,\n  string validation\n) {\n  this.Sheet = sheet;\n  this.Range = range;\n  this.CompanyId = companyId;\n  this.Mnemonic = mnemonic;\n  this.TimePeriod = timePeriod;\n  this.Periodicity = periodicity;\n  this.CacheValue = cacheValue;\n  this.CacheLastUpdateTime = cacheLastUpdateTime;\n  this.DbValue = dbValue;\n  this.DbLastUpdate = dbLastUpdate;\n  this.Validation = validation;\n}\n\npublic Finding With(\n  string sheet = null,\n  string range = null,\n  string companyId = null,\n  string mnemonic = null,\n  string timePeriod = null,\n  string periodicity = null,\n  string cacheValue = null,\n  string cacheLastUpdateTime = null,\n  string dbValue = null,\n  string dbLastUpdate = null,\n  string validation = null\n) => new Finding(\n  sheet: sheet ?? this.Sheet,\n  range: range ?? this.Range,\n  companyId: companyId ?? this.CompanyId,\n  mnemonic: mnemonic ?? this.Mnemonic,\n  timePeriod: timePeriod ?? this.TimePeriod,\n  periodicity: periodicity ?? this.Periodicity,\n  cacheValue: cacheValue ?? this.CacheValue,\n  cacheLastUpdateTime: cacheLastUpdateTime ?? this.CacheLastUpdateTime,\n  dbValue: dbValue ?? this.DbValue,\n  dbLastUpdate: dbLastUpdate ?? this.DbLastUpdate,\n  validation: validation ?? this.Validation\n);\n\n}\n}\n```\n. > Wow this is really cool and thanks for taking the time to code this up!\nYou're welcome.  Helping others like this is my favorite part of programming :)\n\n...if I'm understanding the explanation you gave me earlier in this thread, that using the monadic flow over a Validation won't work because it has as it's projected select value ValidationData.\n\nBy \"monadic flow\", I think you are referring to LINQ query syntax.  This is called do notation in Haskell, computation expressions in F#, and for comprehensions in Scala.\nI could discuss C#'s LINQ query syntax more, but I think you are \"asking the wrong question\".  The grouping doesn't have anything to do with the validation, so don't try to group when Validation<,> is involved.\n\nThe one problem with your solution is that my query needs a \"group by\" to optimize it's use with the stored procedure...\n\nSo how about grouping as soon as possible?  In my code, that would look like this.\npublic static void Main() {\n  var findings = ExampleRawData\n    .GroupBy(rd => new Tuple<string, string>(rd.TimePeriod, rd.Periodicity))\n    .Bind(g => g.Map(ToFinding))\n    .ToList();\n}\nOf course, as written, my code is still querying the database one at a time.  Can you adjust from here to get the performance that you want?. I agree that the grouping and the database query should be syntactically near each other.  However, I see no reason why these two things should be located near each other in time during the execution of the program.\nTo be clear, my code doesn't have the grouping and database query syntactically next to each other.  Maybe I could modify my example to do that though.\nCan you give me a better understanding of what you want the call to your database query to look like?  What should the signature be?. This is a duplicate of #530 . > My expectation was that the IfNone API would match the IfSome API.\nI have also been surprised by this inconsistency.\n\nTo achieve the same thing I'm using the unsafe signature and returning null explicitly.\n\nYou don't have to return null though.  You can return Unit, which is one of the ways in FP to indicate that a function has a side effect.. Oh, I see.  Then your approach wouldn't work with a value type.\nIn general, I think ma.Match(Some, () => { DoImpureThings(); return None; }) would work.  I am just trying to think of a way to avoid using null.. How about ma.Match(_ => unit, () => { DoImpureThings(); return unit; }) ?. > It's just needs it to transparently pass to the other two methods it calls. This is the problem that the reader monad attempts to solve.\nI really like this comment.\nI have noticed that an expression with (say) two dependencies can either be the entire body of a function that requires both dependencies or part of the curried version of that function, which effectively moves a type from being part of the input to being part of the output.\nFor example, C Function(A a, B b) curries to Func<B, C> CurriedFunction(A a) and the type B has \"moved\" from the being part o the input  (A and B) to being part of the output (Func<B, C>).\nSince you have to \"see\" B either on the right as part of the input or on the left as part of the output, I don't see an advantage one way or the other from a syntactic perspective.\nWhat does seem different those is a separation of \"what to do\" and \"when to do it\" regarding B.\nIf your signature is C Function(A a, B b), then when it finishes executing, A and B have (presumably) been used and C has been computed.  In particular, any side effects involved with accessing B have occurred.\nOn the other had, if your signature is Func<B, C> CurriedFunction(A a), then when it finishes executing, how to use B has been specified, but B hasn't been used yet, so any side effects involved with accessing B have not occurred.\nThis seems like the real advantage to me.\nThe example I gave above comparing a function and its curried form is how I first became aware of this situation.  However, a curried function is certainly just a special case of separating \"what to do\" and \"when to do it\".  My impression is that the \"purpose\" of the reader monad could be to preciously express the separation \"what to do\" and \"when to do it\" in the case of reading (as opposed to the case of writing, which is handled by the writer monad).. > Add an example on how to use the ValidationContext and ValidationUnitContext.\nCan you add links to those?. > It would nice to also show an example where a validation is invoked only if a previous validation passed\nUse monadic bind to achieve that behavior.  Such an example already exists.  See this line in the validation tests to which you linked.. After adding these usings...\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Reflection;\nusing LanguageExt;\nusing static LanguageExt.Prelude;\n...I still can't get your code to compile.  What are those to calls to Dump()?. > > It would nice to also show an example where a validation is invoked only if a previous validation passed\n\nUse monadic bind to achieve that behavior. Such an example already exists. See this line in the validation tests to which you linked.\n\nIn fact, you did this here\n\npublic static Validation<Error, string> Validators(string str) => NonEmpty(str).Bind(x => StartsWithLetterDigit(str));. Your code contains two validation examples.  I have finished going through the first one, the one that starts with\nValidateList(new List<string> {\"\", \"1\", \"\", \"a\", \"200\"})\n\nI think there is a key idea that you are missing.  The purpose of validation is to guard the creation of strong types.\nIn the validation tests in Language Ext to which you linked, there is a type called CreditCard.  Its constructor accepts any two strings and any two ints.  However, having a CreditCard instance is not the same as having an instance of Tuple<string, string, int, int>.  The difference is that the only call to the constructor of CreditCard went through many validation steps.\nThe type safety of CreditCard is very good.  It could be improved a bit using the smart constructor pattern.  You can read more about this idea in Functional Programming in C# by Enrico Buonanno.  He first mentions the idea in section 3.4.5 and then elaborates on it in section 8.5.1 in the context of validation.\nAlternatively, see below how the types I created have private constructors and factory methods involving validation.\n```\nusing System.Collections.Generic;\nusing LanguageExt;\nusing static LanguageExt.Prelude;\npublic class Example {\n  public static void Main() {\n    var strings = new List { \"\", \"1\", \"\", \"a\", \"200\" };\n    var validatedStrings = strings\n      .Map(Validate)\n      .Map(v => v.Match(s => s.Value, errors => string.Join(\", \", errors))) // just to more easily see what is inside the Validation<,> instances\n      .ToSeq();\n  }\npublic static Validation Validate(string s) => s\n    .Apply(NonnullString.New)\n    .Bind(NonemptyString.New)\n    .Bind(AlphaStartingString.New);\npublic sealed class NonnullString : Record {\n    public string Value { get; }\n    private NonnullString(string value) => Value = value;\n    public static Validation New(string value) => Optional(value)\n      .Map(s => new NonnullString(s))\n      .ToValidation(Error.New(\"Nonnull string is required\"));\n    public static implicit operator string(NonnullString self) => self.Value;\n  }\npublic sealed class NonemptyString : Record {\n    public string Value { get; }\n    private NonemptyString(string value) => Value = value;\n    public static Validation New(NonnullString nonnull) => Some(nonnull)\n      .Filter(s => !string.IsNullOrEmpty(s))\n      .Map(s => new NonemptyString(s))\n      .ToValidation(Error.New(\"Nonempty string is required\"));\n    public static implicit operator string(NonemptyString self) => self.Value;\n  }\npublic sealed class AlphaStartingString : Record {\n    public string Value { get; }\n    private AlphaStartingString(string value) => Value = value;\n    public static Validation New(NonemptyString nonempty) => Some(nonempty)\n      .Filter(s => s.Value[0].Apply(char.IsLetter))\n      .Map(s => new AlphaStartingString(s))\n      .ToValidation(Error.New($\"{nonempty.Value} doesn't start with a letter\"));\n    public static implicit operator string(AlphaStartingString self) => self.Value;\n  }\npublic class Error : NewType {\n    public Error(string e) : base(e) { }\n  }\n}\n```. > > Add an example on how to use the ValidationContext and ValidationUnitContext.\n\nCan you add links to those?\n\nI found ValidationContext and ValidationUnitContext.\nThe purpose of ValidationContext (respectively ValidationUnitContext) is just to pass the two arguments to Match (respectively Match) one at a time.\nFor example, instead of\npublic static void Main() {\n  var strings = new List<string> { \"\", \"1\", \"\", \"a\", \"200\" };\n  var validatedStrings = strings\n    .Map(Validate)\n    .Map(v => v\n      .Match(s => s.Value, errors => string.Join(\", \", errors))) // just to more easily see what is inside the validation instances\n    .ToSeq();\n}\nyou can write\npublic static void Main() {\n  var strings = new List<string> { \"\", \"1\", \"\", \"a\", \"200\" };\n  var validatedStrings = strings\n    .Map(Validate)\n    .Map(v => v\n      .Succ(s => s.Value)\n      .Fail(errors => string.Join(\", \", errors))) // just to more easily see what is inside the validation instances\n    .ToSeq();\n}. For your second validation example, the one that starts with\nValidatorsParent(parent)\ndo you think you can improve it based on my review of your first example?. I think another intended benefit of Seq<> is that its lazy variant is idempotent, i.e. enumerating it twice is equivalent to enumerating it once.  This is not the case for IEnumerable<>.  Only once have I ever intentionally used this behavior of IEnumerable<>.  Every other time it either caused a bug or decreased performance.\nHowever, achieving that idempotent behavior is tricky.  I have seen many bugs related to it.  Because of that, I have been leary of replacing IEnumerable<> with Seq<> in my code.. > ...you have:\n\ncs\nclass Dead : Record<Idle>, ArmyState\nwhich I think should be:\ncs\nclass Dead : Record<Dead>, ArmyState\n\nThat is such an interesting typo.  I was thinking that it should be a compile error because Record<T> has the type constraint T : Record<T>.  The intention is that T is the type that is extending Record<T>.  But as this example shows, the constraint is weaker than the intention because\nclass Idle : Record<Idle>, ArmyState { ... }\nclass Dead : Record<Idle>, ArmyState { ... }\ntogether satisfy both constraints.. > Adjusting that I then get:\n\ncs\nvar mapEq = m1 == m2;               // No Exception, true\nvar eq = a1 == a2;                  // No Exception, false\nvar lstEq = \n    m1.Freeze() == m2.Freeze();     // No Exception, false\nSo map equality is a bit weird but the rest seems to be as you would expect.\nEdit: Map is only comparing keys which I assume is because the value type doesn't have to be equatable\n\nYea, I suppose it could go either way.  I created PR #561 that adds equality checking for the values.  I am interested to see what @louthy wants as the intended behavior.. These hash codes are colliding because the members are being XORed together.\n@louthy, can we change the implementation of Record<>.GetHashCode() to follow Josh Bloch's \n recommendation in Effective Java (3rd Edition, Item 11, Always override hashCode when you override equals)?  This would change the delegate in Fold to (effectively) (state, field) => 31 * state + field.. This situation is ambiguous because the test were all passing, then I added this line, and all the previous tests continued to pass.  If the behavior in master is the intended behavior, then then after rejecting this PR, I would like to create a new PR that adds a test that asserts that two maps with equal key sets but disequal value sets should be considered equal.. I think of Fold as being behavior specific to the case of having (potentially) multiple instances of a single thing (i.e. IEnumberable<> or Seq<>).\nInstead, the first thought that comes to my mind would be to rename this TryAsync.BiMap to TryAsync.Match.  That seems consistent to me with the Match method for Either<L, R>, which is\npublic Ret Match<Ret>(Func<R, Ret> Right, Func<L, Ret> Left, Func<Ret> Bottom = null). Here is my attempt to simplify your tests.  This tests fails but the expectation is that it should pass.\n[Fact]\npublic void IEnumerableOptionBindT_NotEnumerabled_NotEvaluated()\n{\n    var evaluted = false;\n    var list = Seq1(unit)\n        .AsEnumerable()\n        .Select(_ =>\n        {\n            evaluted = true;\n            return unit;\n        })\n        .Select(Some)\n        .BindT(Some);\n    Assert.False(evaluted);\n}. Sure thing.. Oh, sorry sheepish grin. I didn't change this method.  I think we are seeing changes that entered my branch when I merged in master in order to resolve the conflicts.  In this method, the green lines are what master looks like now.. To address your actual question, the formatting is now partially specified by the .editorconfig file.  When auto formatting, sometimes extra white space is allowed to stay.  Other times, extra white space is removed.\nOld line 531 begins the method's expression body.  This is a case where extra white space is allowed to stay.  If you move old line 531 to end of line old line 530 and hit \"Enter\", you will see that Visual Studio would prefer to indent old line 531 exactly as far as old line 530.\nIn contrast, towards the end of old line 531 and the beginnings of old lines 532 and 533, extra white space was not allowed to stay because the context is now arguments to a method call.  This is one case in which extra white space is not allowed to say.. I can line them up if you like.. If you want, you can simplify this second part to Assert.True(await eitherAsync.IsLeft);. ",
    "faeriedust": "using(var x = Some(disposableThing))\n    {\n      ...\n    }\nThis doesn't make sense at all to me. Why turn disposableThing into an Option<> type when it clearly is never None here? This seems to be arbitrarily/randomly throwing away information for no reason.  I can't think of hardly any possible use case to say: var x = Some(...);\nAlso, I think in general the creator of an object should be responsible for disposing it, unless it's a factory method. So I guess the main issue here is the case where you're using factory methods that return an Option<>.. I'm looking at the code:\nstatic Option<Stream> OpenStream(StreamDesc desc) =>  ...;\nstatic Unit Test(StreamDesc desc)\n{\n    var stream = OpenStream(desc);\n    try\n    {\n        return UseStream(stream);\n    }\n    finally\n    {\n        stream.Iter(s => s.Dispose());\n    }\n}\nMy first reaction is for UseStream to not take an Option cause wth is UseStream(None) supposed to do..\nstatic Option<Stream> OpenStream(StreamDesc desc) =>  ...;\nstatic Unit Test(StreamDesc desc)\n{\n    var stream = OpenStream(desc);\n    try\n    {\n        return stream.Map(UseStream).IfNone(unit);\n    }\n    finally\n    {\n        stream.Iter(s => s.Dispose());\n    }\n}\nThe syntax is still ugly, so we want to use the use method, right?\n```\nstatic Option OpenStream(StreamDesc desc) =>  ...;\nstatic Unit Test(StreamDesc desc) =>\n    OpenStream(desc).Map(stream => use(stream, UseStream)).IfNone(unit);\n```\nOr something similar?  Just a thought. I dislike that I need to do the first refactor to do this, though certainly in this case it appears to make sense.\nOne could also consider adding an overload of use that takes an Option<> and behaves appropriately? It wouldn't even have to be in LanguageExt. It seems simple enough to add a method like this in the client application's code if they really need such a thing.\nAnother argument against it is, along the lines of the slippery slope that @bender2k14 mentioned, I don't want to write code to dispose all of my Option<>s, only the ones that wrap IDisposables, so it seems to make a lot more sense to me to handle this in a method that only takes Option<IDisposable> than on the Option<> itself.. So should all of the monads implement IDisposable? (I still think they should not, for already mentioned reasons.)\nIf you want a disposable Option type, simply wrap the existing one. All problems can be solved by adding a layer of abstraction after all. :)\nAlso what if the inner object is owned by someone else? Then how can we say that the Option<> owns it as well?. ```\npublic class OuterService : IDisposable {\n  public InnerService Inner {get; set;}\n  public void Dispose() => this.Inner.Dispose();\n}\npublic Option _MyMethod(Option outer) =>\n  outer.Map(x => x.Inner);\n``Option<>here is pretty clearly not the owner of the inner service...OuterService` is. I don't think I would call it a bug so much as just bad practice to call that overload of Fold.  You're asynchronously getting values in a synchronous method, so a deadlock seems pretty natural to occur there, unless I'm missing something.\nThe fact that calling Sequence twice on a Seq<Task<int>> deadlocks does seem like a bug however.\nI went ahead and made a repo that demonstrates this issue:\nhttps://github.com/faeriedust/languageExtTests\n. Yeah, I tried to fix the bug in the repo and immediately ran into many issues...\nI think breaking Monad into Monad and MonadAsync does seem likely the much better approach.\nI'm looking forward to this. :). > However, that general rule falls apart slightly for the ToString and GetHashCode overrides on EitherAsync. They can't have their names or signatures changed (because they're inherited from Object) and they will force synchronous evaluation. I have provided ToStringAsync and GetHashCodeAsync, but that's immediately breaks the rules set above.\nWhy do you have to evaluate for these methods?\nJust use Object.ToString() and Object.GetHashcode(), no?. I disagree that it is reasonable.\nTask.ToString() is not the same as Task.Result, nor should it be. The same applies to async types in this library, they should not be the same thing, imo.\nSuppose my task is going to take 10 minutes, why should I wait for 10 minutes, or even deadlock my program, just to see the text in the debugger or similar?\nIf it's asynchronous, it's specifically because I chose to delay evaluation, so don't evaluate it for me, unless I need the value, which .ToString() semantically does not require in other CLR types, such as Task. I'm in favor of having consistent set of methods across the monads this library provides as well. but Task<> was not provided by this library, so I think, no?  So I think some care in not actively interfering with people's current usage of Tasks would be pretty desirable.\nI do like the monad-specific extension methods off of task (e.g. Map, Bind, etc), but I guess I seriously question the readability of code if they use a .Count() method to check if a task is faulted or cancelled, particularly if it happens to be a Task<IEnumerable<>>.\nAs an alternative, simply namespacing these extension methods, so that I can opt-in to use them would go a long ways, imo. \nE.g. perhaps all of the Task extension methods could go into a \"LanguageExt.Tasks\" namespace, or some such? Then it can pull all the shenanigans it wants, and I'm not forced to deal with it to get the benefit of the rest of the library, XD\nI just found this annoying because I think it's very nice to be able to install this library into a codebase, use it for a bare minimum of things, and then gradually increase that usage as I go.  It makes it more difficult if it's actively obfuscating and interfering with my coding process that's unrelated to this library atm.\nMaking the return type Task<int> would certainly help, but I think it will likely still be pretty annoying.   (I'm happy to wait and see though). So yeah, I guess my new proposal is to namespace the Task<> extension methods, or perhaps even split them to their own project maybe?. I don't understand how .CountT helps with the above issue.\nIf I have an IEnumerable<> and not a Task<IEnumerable<>>, then I should call .Count(), and it behaves correctly.\nIf I instead have a Task<IEnumerable<>>, then .Count() silently returns me a garbage answer without compiler error or warning. If I notice this, I can call .CountT() sure, but I didn't notice at all, so this clearly wasn't an option.\nIn particular, I had someone writing tests for me, and they didn't notice that it was returning a Task<IEnumerable>, and just called .Count() without looking at the types (assuming it was simply IEnumerable<>), and they even had several tests passing with this mistake before we noticed anything.\nRefactoring synchronous code to async is also a fairly big thing in the project I'm working on, so I can easily see this causing me further headaches as well.. Ah, I see you changed the return type to Task<int> in that branch, so that should make things much easier hopefully, thanks! :). I was overriding it because I thought the point was to get comparison operators for free, lol.  Once I discovered that wasn't the case, I used my own stuff instead.\nCan we at least make it more clear via documentation what the implementations for the operators are doing then, if not calling .CompareTo?\nThere was little to no documentation for them, so I stared at the code for like 10 min before giving up, lol.\nIs there a reason they can't call the .CompareTo method? It's easy enough to do.\nIsn't calling .CompareTo normally the expected thing to do for those operators?\ne.g. Change it to\npublic static bool operator <=(Record<RECORDTYPE> x, Record<RECORDTYPE> y) =>\n      x.CompareTo((RECORDTYPE) y) <= 0;\ninstead of\npublic static bool operator <=(Record<RECORDTYPE> x, Record<RECORDTYPE> y) => RecordType<RECORDTYPE>.Compare((RECORDTYPE)x, (RECORDTYPE)y) <= 0;\nThis would be more consistent with CompareTo being virtual.. I was drunkenly is the short answer.\nI see there are some tests for that case as well, I just had to run them.\nThis tests seems backwards compared to what I would expect, but I guess I can match it for now.\n```\nTestClass x = new TestClass(1, \"Hello\", Guid.Empty);\nTestClass y = null;\nTestClass z = null;\nAssert.True(x > y);\nAssert.True(x >= y);\nAssert.True(y < x);\nAssert.True(y <= x);\nAssert.True(y == z);\nAssert.True(z == y);\n```\nNormally if one side is null, the comparison goes to false, not true, in C# anyways. (See section on operators.)\nhttps://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/using-nullable-types\nI will update my PR to preserve the true behavior for now since it seems this would cause an inconsistency with the default implementation of .CompareTo, but just pointing this out.. I updated my PR to match the original behavior for null orderings.. They seem odd to me.\nShould we consider changing the default implementation to CompareTo (and the operators) to match the MSDN convention for null comparisons, e.g. false?. My issue had nothing to do with inheriting from a Record derived type.\nI simply derived from Record and overrode the virtual .CompareTo method.\nMy PR preserved the exact same existing functionality, except made it more intuitive what will happen if you override the CompareTo method.\nAlso I don't understand what the performance hit you mentioned is.. It's fixed by changing var iter = seq.GetEnumerator(); to using(var iter = seq.GetEnumerator()) in SeqEnumerable2.cs\n. @louthy Woops! I didn't run your tests for some reason. >_< Apologies!\nYour fix doesn't address my issue though. \nI don't think it shouldn't matter if I read the last item or not. It's extremely common to not read the last element of an IEnumerable, particularly if there isn't one.  If I dispose the IEnumerator from the Seq, it means I am done reading and therefore I would expect the resources to be released, e.g. the enumerator from the original IEnumerable to be disposed, no?\nI can adjust the tests I have above to include nonempty sets and they will fail even with your fix.\n```\n//Passes\n[Fact]\npublic void NormalEnumerableBehavior()\n{\n    //ARRANGE\n    var enumerator = Substitute.For>();\n    var enumerable = Substitute.For>();\n    enumerable.GetEnumerator().Returns(enumerator);\n    enumerator.MoveNext().Returns(true);\n//ACT\nenumerable.Apply(Enumerable.FirstOrDefault);\n\n//ASSERT\nenumerable.Received().GetEnumerator();\nenumerator.Received().Dispose();\n\n}\n//Fails\n[Fact]\npublic void SeqBehavior()\n{\n    //ARRANGE\n    var enumerator = Substitute.For>();\n    var enumerable = Substitute.For>();\n    enumerable.GetEnumerator().Returns(enumerator);\n    enumerator.MoveNext().Returns(true);\n//ACT\nenumerable.ToSeq().Apply(Enumerable.FirstOrDefault);\n\n//ASSERT\nenumerable.Received().GetEnumerator();\n//fails here because it wasn't disposed\nenumerator.Received().Dispose();\n\n}\n```\nIn particular, I expect this test to pass:\n```\n//Fails\n[Fact]\npublic void SeqDisposesEnumerator()\n{\n    //ARRANGE\n    var enumerator = Substitute.For>();\n    var enumerable = Substitute.For>();\n    enumerable.GetEnumerator().Returns(enumerator);\n    enumerator.MoveNext().Returns(true);\n//ACT\nenumerable.ToSeq().GetEnumerator().Dispose();\n\n//ASSERT\nenumerable.Received().GetEnumerator();\n//fails here because it wasn't disposed\nenumerator.Received().Dispose();\n\n}\n``\n. @louthy Yeah, after running your tests, I figured out the problem as you described. And yes, after thinking about this a bit, I agree the behavior I want does seem a bit contradictory with the purpose ofSeq` as coded.\nI guess back to the original case that prompted me to create this issue though - It still seems like I should be able to expect .HeadOrNone() to dispose the enumerator, which it currently does not, since it calls Seq internally.\n```\n[Fact]\npublic void HeadOrNoneDisposesEnumerator()\n{\n    //ARRANGE\n    var enumerator = Substitute.For>();\n    var enumerable = Substitute.For>();\n    enumerable.GetEnumerator().Returns(enumerator);\n    enumerator.MoveNext().Returns(true);\n//ACT\nenumerable.HeadOrNone();\n\n//ASSERT\nenumerable.Received().GetEnumerator();\n//fails here because it wasn't disposed\nenumerator.Received().Dispose();\n\n}\n```. UPDATE: My bad! The test in my previous post actually passes. >_<\nIn order to make it fail, we have to use the IQueryable version of .HeadOrNone(), which I still think should pass this test.\n```[Fact]\npublic void HeadOrNoneDisposesEnumerator()\n{\n    //ARRANGE\n    var enumerator = Substitute.For>();\n    var enumerable = Substitute.For>();\n    enumerable.GetEnumerator().Returns(enumerator);\n    enumerator.MoveNext().Returns(true);\n//ACT\nenumerable.AsQueryable().HeadOrNone();\n\n//ASSERT\nenumerable.Received().GetEnumerator();\n//fails here because it wasn't disposed\nenumerator.Received().Dispose();\n\n}\n``. Fixes #488  . Those two are harder to fix since they call methods that are baked intoSeq`, but I can take a shot at moving them off of it?. Fixes #523 . ",
    "kdblocher": "@louthy, I strongly advise against this course of action. It \"feels\" dirty, both from FP and OOP perspectives. We've had some internal discussion at our company about this issue (full disclosure: @faeriedust and @bender2k14 work for me), and we are all flat out against it. We would never use such a kluge. A class should NEVER dispose objects passed to it via the constructor.\nBut don't take it from me, take it from another expert quite knowledgeable about the subject: https://github.com/louthy/language-ext/issues/205#issuecomment-289091607\nIf I haven't convinced you yet that you were correct the first time, please consider that this is a violation of referential transparency (aka SRP), immutability, and DIP. Holy hell, I could treat these unholy beasts as IDisposables and let others dispose them, opening up a whole host of runtime errors. As professional functional programmers, aren't we in the business of using the type system to catch as many errors as possible, because runtime errors don't exist?\nLastly, because C# doesn't allow us non-nullable nor immutable references yet, we should be using Option<> anywhere we want to enforce them (or at least the first). If it's disposable as well, anywhere we construct an Option internally, we've constructed a resource, and best practice says we should call .Dispose() on it. I can't wait to tell everyone who is still learning higher-order programming (aka \"cuz monads\") to ignore the IDisposable warnings in VS that will be going off everywhere because of this.. Now, to actually solve the problem: @StefanBertels, I would suggest writing a ResourceOption monad, adding some nice extension methods off of Option<> to get one for free, and using a latch to prevent multiple calls to Dispose inside a la a State or I/O monad. Such a beast should probably go into the Actor library and not this one, since it sounds like that's the use case you want it for.. @louthy why the reticence in hotfixing your current release? these are common adjustments that have caused quite a few hard-to-notice production issues in our code (other than using post-compilation or analyzers, it is difficult to code around runtime bugs like this). It seems to me that operations on temperatures should behave just like DateTime and TimeSpan behaves; that is, the Temperature carries the original information about the units (like a point on a line), and additions should be of a different type, such as TemperatureOffset, which behaves like a vector. \nYou could also consider implicit cast of raw numeric values in a binary operation to be a TemperatureOffset that inherit the units of the Temperature or TemperatureOffset of the left operand.\nThus, with t:Temperature, o:TemperatureOffset:, n:R\nt op o -> t\no op o -> o\nt op n -> t\no op n -> o\nThe following propositions should hold (where UT is an abbreviation for TemperatureUnitType or similar)\nnew Temperature(10, UT.C) + new TemperatureOffset(10, UT.C) == new Temperature(20, UT.C)\nnew Temperature(10, UT.C) + new TemperatureOffset(18, UT.F) == new Temperature(20, UT.C)\nnew Temperature(0, UT.C) + 10 == new Temperature(50, UT.F)\nnew Temperature(273.15, UT.K) + new TemperatureOffset(10, UT.C) == new Temperature(10, UT.C). Interesting discussion, thanks @louthy and @bender2k14!\n@dgreene1 - For what it's worth, with language-ext, I've taken to simply not including the System.Linq namespace anywhere I don't want anything \"extra\" such as serialization support, and by convention use the functional-style naming for domain functionality and use the LINQ-style naming for anything that is \"special\" (such as EF queries, serialization, interop between null/void/OOP style). It's not a perfect solution, but it's a good convention-based approach to quickly look at the code and see what the context of data transformation is going on.\nLike @louthy said, I do think it's reasonable to strike a balance between purity and practicality. Thanks for your efforts - certainly I don't think @bender2k14 would be so passionate about his contributions here if he didn't think your library is already awesome, because he's that kind of guy ;). Workaround is to use MatchAsync, some variant of Map, or IfNone chaining.. ",
    "trbngr": "It seems that Left cases aren't working properly.\n```\n    public Task<Either<Exception, int>> Issue207_3() =>\n        from us in Left<Exception, ADUser>(new Exception(\"fail\")).AsTask()\n        from mu in createUserMapping(us).AsTask()\n        from id in addUser(mu)\n        select id;\n\n    public Task<Either<Exception, int>> Issue207_4() =>\n        Left<Exception, ADUser>(new Exception(\"fail\")).AsTask()\n            .BindT(createUserMapping)\n            .BindT(addUser);\n\n``\nboth throwLanguageExt.BottomException : Value is in a bottom state and therefore not valid.  This can happen when the value was filtered and the predicate returned false and there was no valid state the value could be in.  If you are going to use the type in a filter you should check if the IsBottom flag is set before use.  This can also happen if the struct wasn't initialised properly and then used.\n`. Sorry. I moved this comment to the correct issue. \nI'm trying to acheive a fail-fast scenario, where the first Left will short-circuit the program.\nSo Issue207_3() should return a Task<Left<Exception>> and not throw.\nJust imagine that the first Left call was a function that returns Either<Exception, ADUser>. I figured as much after racking my brain a bit. ;)\nThanks for your help.......and awesome library. It's making C# fun again.. I accept this ;)\nBut if my Left case is not an exception type, I'm left with Matching the Either and throwing inside a Try. Which I suppose is not the end of the world, just a bit ugly IMO. Of course I could create an extension method to hide it away.\nex: \ne.Match(\n  Right: Try,\n  Left: e => Try<T>(() => throw new Exception(...))\n)\nThe other option I'm going to play with is Validation<L,R>. But if my chain is too long, it just doesn't flow right. And I don't want an Applicative.\nI know I'm being overly pedantic here, but I like clean code ;)\n. I've created a gist with the solution that works for me. It also illustrates a real-world use-case for me.\nLike I said above, wrapping Task<Either> to TryAsync feels dirty.  I suppose it's just the nature of \"bolting\" FP onto a language that's not pure FP. \nI hope this helps someone out. And if there's a nicer way of doing this, I'm all ears.. You know.... With the extension methods in place, this isn't so bad.. You're the best! \ud83d\ude0d. Thank you!!!!. Running 2.0.88 against my gist\n```\nCore.Tests.ExternalOptionsAndEithersTests.what_i_desire\nMicrosoft.CSharp.RuntimeBinder.RuntimeBinderInternalCompilerException : An unexpected exception occurred while binding a dynamic operation\n   at Microsoft.CSharp.RuntimeBinder.RuntimeBinder.Bind(DynamicMetaObjectBinder payload, IEnumerable1 parameters, DynamicMetaObject[] args, DynamicMetaObject& deferredBinding)\n   at Microsoft.CSharp.RuntimeBinder.BinderHelper.Bind(DynamicMetaObjectBinder action, RuntimeBinder binder, IEnumerable1 args, IEnumerable1 arginfos, DynamicMetaObject onBindingError)\n   at Microsoft.CSharp.RuntimeBinder.CSharpConvertBinder.FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion)\n   at System.Dynamic.DynamicMetaObject.BindConvert(ConvertBinder binder)\n   at System.Dynamic.ConvertBinder.Bind(DynamicMetaObject target, DynamicMetaObject[] args)\n   at System.Dynamic.DynamicMetaObjectBinder.Bind(Object[] args, ReadOnlyCollection1 parameters, LabelTarget returnLabel)\n   at System.Runtime.CompilerServices.CallSiteBinder.BindCoreT\n   at LanguageExt.ClassInstances.MEither2.Bind[MONADB,MB,B](Either2 ma, Func2 f)\n   at LanguageExt.Trans5.<>c__DisplayClass4_05.<Bind>b__0(InnerType inner)\n   at LanguageExt.ClassInstances.MTask1.<>c__DisplayClass3_03.<Bind>b__1(Task1 task)\n   at System.Threading.Tasks.ContinuationResultTaskFromResultTask2.InnerInvoke()\n   at System.Threading.Tasks.Task.Execute()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at TaskExtensions.<SelectMany>d__53.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at TaskExtensions.d__53.MoveNext()\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at System.Runtime.CompilerServices.TaskAwaiter1.GetResult()\n   at Core.Tests.ExternalOptionsAndEithersTests.d__0.MoveNext() in /Users/chris/code/linktargeting/dotnet/test/Core.Tests/AsyncEitherTests.cs:line 30\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n--- End of stack trace from previous location where exception was thrown ---\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n``. Here's the extension methods for anyone looking. Everything worked butSelectManywas namedSelect`.\n```csharp\n        // ReSharper disable ConvertClosureToMethodGroup\n    public static async Task<Either<TError, B>> Select<TError, A, B>(this Task<Either<TError, A>> self, Func<A, B> f)\n        where TError : NewType<TError, string> =>\n        (await self).Match(\n            Right: r => Right<TError, B>(f(r)),\n            Left: l => Left<TError, B>(l));\n\n    public static async Task<Either<TError, C>> SelectMany<TError, A, B, C>(\n        this Task<Either<TError, A>> self,\n        Func<A, Task<Either<TError, B>>> bind,\n        Func<A, B, C> project\n    ) where TError : NewType<TError, string> =>\n        await (await self).MatchAsync(\n            Right: async a => (await bind(a)).Match(\n                Right: b => Right<TError, C>(project(a, b)),\n                Left: l => Left<TError, C>(l)),\n            Left: l => Left<TError, C>(l));\n\n    public static async Task<Either<TError, A>> Where<TError, A>(this Task<Either<TError, A>> self, Func<A, bool> f)\n        where TError : NewType<TError, string> =>\n        (await self).Match(\n            Right: r => f(r)\n                ? r\n                : Either<TError, A>.Bottom,\n            Left: l => l);\n\n    // ReSharper restore ConvertClosureToMethodGroup\n\n```\nCheers!. Sean,\nThis should work for you:\ncsharp\n        public async Task<IActionResult> GetGendersAsync() =>\n            Try(await _repository.GetAllGendersAsync()).Match(\n                Succ: Ok,\n                Fail: e => (IActionResult) StatusCode(500)\n            );. Hey Sean,\nI decided to dive on in ;) Here's a repo for you\nhttps://github.com/trbngr/langext-issue255\n@louthy can you explain why the monadic approach here isn't working? It's throwing TaskCancelledExceptions  for the tests no_gender_found_returns_not_found and default_guid_returns_not_found.\nCheers,\nChris. I would just use match.\ncsharp\nvalidation.Match(\n    Succ: identity,\n    Fail: errors => errors.Map(x => x.Value)\n);. Makes sense. Thanks.. I asked about this the other day. This is the explanation.\nhttps://github.com/louthy/language-ext/releases/tag/2.1.20. You summoned me.\nI thought I'd give this a shot and to my surprise, there was no obvious answer. It took some digging into the source.\nI then saw this\nWhich led me to write a test\nTLDR: use the .ToAsync() extension off of Try<Task<A>> to turn it into a TryAsync<A>.\nEnjoy ;). That sounds like a dream for me. Wanna sponsor a guy from Arizona? ;). excellent writeup. I've been working on generating a free dsl from a swagger document and this helps.. All that matters for Either to compose is the left side. You're already lining up your types correctly. Just take advantage of monadic syntax. \ncsharp\nvar result = map(\n    from type in GetTestMessageType(msg)\n    from handler in GetTestHandler(type)\n    select handler,\n    handle => handle(msg)\n).MapLeft(TestMessageResultError);\nand \ncsharp\nvar result2 = match(\n    from type in GetTestMessageType(msg)\n    from handler in GetTestHandler(type)\n    select handler,\n    Left: er => Left<string, MessageResult>(TestMessageResultError(er)),\n    Right: handle => handle(msg)\n);\nand\ncsharp\nvar result3 =\n    GetTestMessageType(msg).Bind(GetTestHandler)\n        .Map(handle => handle(msg))\n        .MapLeft(TestMessageResultError);\nare all equivalent. \nEDIT: I had left off the final MapLeft.. @imranypatel Without a concrete example, I'd stick to the same patterns as above (in whatever style you prefer).\nie.\n```csharp\nclass MessageResult\n{\n}\nstatic Either GetTestMessageType(JObject msg) => Right(\"GET_AUTHORS\");\nstatic Either> GetTestHandler(string key) => Left(\"\");\nstatic string TestMessageResultError(string err) => $\"Error:{err}\";\nstatic Either HandleTestMessage(JObject msg) => match(\n    from type in GetTestMessageType(msg)\n    from handler in GetTestHandler(type)\n    select handler,\n    Left: er => Left(TestMessageResultError(er)),\n    Right: handle => handle(msg)\n);\nstatic void CallsHandleTestMessage() => match(\n    HandleTestMessage(JObject.Parse(@\"{\"\"name\"\": \"\"chris\"\"}\")),\n    Left: error => Log(error).AsTask(),\n    Right: SaveToDb\n);\nstatic Unit Log(string error) => unit;\nstatic Task SaveToDb(MessageResult result) => unit.AsTask();\n``. 1. Not my code.\n2. Yes it does. Put it in a class.. No you\u2019re not. I can\u2019t seem to work out how to mix writer into that. . Thank you! I'll dive in a bit later. Personally, I would opt forEither` in this case.\nYou can achieve what you're after with something like this:\n```csharp\npublic async Task Process()\n{\n    var inputs = Enumerable.Range(0, 40);\nvar failed = await inputs.ChunkBy(10).Fold(\n    state: List<int>().AsTask(),\n    folder: (lst, chunk) =>\n        from failures in lst\n        from results in ProcessChunk(chunk)\n        let fs = results.Partition().Lefts\n        select failures.AddRange(fs)\n);\n\n}\n```\nPS. Don't forget to import the Prelude.. I keep thinking of a way to make this possible at compile-time. \nNow that Rider supports Roslyn analyzers, it wouldn't be a VS-only hack. So that's a good solution.\nI wonder if it would be possible with Fody?. I would prefer the syntax that @louthy uses. Maybe I'll try to implement it tonight.. OK. Here's the beginning of this effort.\nhttps://github.com/trbngr/LanguageExt.Fody\nI still need to emit the IL - which is the hard part ;)\nIL Reference here.. OK. After thinking this through, I'm not sure the Fody way is very beneficial at all. We won't get dev-time With methods. Only after compilation. I'm not sure I'll follow through with this one.\nWhen I get some downtime, I will probably opt for a simple Roslyn Analyzer and/or Rider plugin that will be able to generate the With at dev-time.\nUntil the C# team decides to give us real Records, this is probably the best we'll get.. Trying to debug this....\nIt appears that the Zero() defined for MValidation<MonoidFail, FAIL, SUCCESS> and MValidation<FAIL, SUCCESS> should not be Validation<MonoidFail, FAIL, SUCCESS>.Fail(default(MonoidFail).Empty()); and Validation<FAIL, SUCCESS>.Fail(Seq<FAIL>.Empty), respectively. \nChanging those to their Success cases get's us farther along. But now we're stuck with the default value of, in this case, Validation<string, Task<int>>, which is Success<string, int>(0) and since Sequence is Traverse(OuterType, identity), that's what we get.\nIn other words, I'm not sure where to go from here and, unfortunately, don't have the time to dig further.\nThis is also work-around-able with Match instead of Sequence, so I'm happy enough \ud83e\udd2a\n. There are multiple way to get what you want. The two easiest that come to mind are:\nnote: Make sure you have the Prelude in scope. ieusing static LanguageExt.Prelude;\nI'm assuming Error is class Error : NewType<Error, string>\n```csharp\n            var validationFromTry = X().Match(\n                Succ: Success,\n                Fail: e => Error.New(e.Message)\n            );\n        var validationFromEither = X()\n            .ToEither()\n            .MapLeft(e => Error.New(e.Message))\n            .ToValidation();\n\n```. I agree. There should be. And it Should be a very easy PR ;). ",
    "jeremysmith1": "I would like to second the functional c# programming book suggestion. I started reading it without any functional experience and felt very comfortable afterwards. The extensions the book uses is almost identical to this project. . Ran into some issues with Enum, but I think my solution will work. Set up a pull request here https://github.com/louthy/language-ext/pull/211\n. One thing I have seen using this library is use cases that happen like this current issue that is open:\nhttps://github.com/louthy/language-ext/issues/229\nBecause you can have nullable objects in C#, you are not completely protected from null in the use of Some. In other languages, such as Erlang, where null is not really a thing. \nI would think to work with this library and using functional concepts, you would want to avoid nullable types. But I do not see a way of guarding against its use. Similar how you can make objects in Fsharp, but that would be working against the language. . What would a better naming convention be? I am sure someone here would have a good idea. I was looking around for some ideas.\nUppercase would make it more obvious as a dev that you are using something special. (KILOMETER DATE FT) Pretty sure people are against this style. It would be similar to Erlang Macro naming http://erlang.org/documentation/doc-5.2/doc/extensions/macros.html\nOne could argue that unit testing would have stopped this. Let's be honest though, stuff happens.\nI would be okay with going through and making the changes if desired.. I took a go at it. Adding a null check prevents the problem.\nPR: https://github.com/louthy/language-ext/pull/347\n. Not sure how I did that to be honest. Fixing.. ",
    "Skoucail": "Will take a look at the book for sure.\nAnd thx for the short summary.\nMaybe in a few years i will be able to call myself a reformed OO guy too!. ",
    "manfredk": "Again, praise to the book by Enrico Buonanno, which really is an eye-opener and by far the best book for ambitious C# developers trying to adopt functional principles. @louthy Kudos to you and all people working as proofers and editors on Enricos book - the released book shows substantial improvements in quality over the MEAP versions (which already were worth the money).\nRegarding monads, there's this great article by Eric Lippert here, which really helped me to wrap my brains around the concept. On top of that Enrico does a great job in explaining the intricacies of functors and such.\n. ",
    "kthompson": "I had accidentally closed this issue when making a comment. I have not been able to resolve the issue.. I will look into that.. ",
    "jmagaram": "ok I think that works. Interesting. If you defined custom types for every real-world concept and banished int, string, bool, programs in C# would look quite different than all the example code you see.. > Yes you should still check for null.\nI was thinking that wherever your code makes use of a Eq it could handle the \"are both null?\" => true, \"is just one true?\" => false situations generically, before getting to my type-specific code, so my code wouldn't need to worry about it. But I agree that if I'm using a Eq \"manually\", then it is safer if it handles all the situations.\n\nYou don't need to check the types with GetType(), that is enforced by the compiler.\n\nI'm not totally sure about this. I was thinking about the case where one type is a sub-type of the other.. same with Either <= and >=\nI must be not understanding something. > You can't derive from a struct\nThere might be a way of using a Roslyn script during build to simulate this. It could take a struct, plug in a specific T and U, and output a partial struct file.. I didn't realize I can test this myself by turning on .net native compilation. I'll try it.. Forget .net native for a sec. Out of habit, I tried testing it with a class like the following. It does NOT work because the fields are defined as private. The documentation should be updated to indicate that the fields must be public for this to work. \npublic class PersonA : Record<PersonA>\n{\n    private readonly string _firstName;\n    private readonly int _age;\n\n    public Person(string firstName,int age)\n    {\n        _firstName = firstName;\n        _age = age;\n    }\n\n    public string FirstName => _firstName;\n\n    public int Age => _age;\n}\n\nThis works...\npublic class PersonB : Record<PersonB>\n{\n    public readonly string FirstName;\n    public readonly int Age;\n\n    public PersonB(string firstName, int age)\n    {\n        FirstName = firstName;\n        Age = age;\n    }\n}\n\n. I can't test .NET Native right now. VS eats all available memory when trying to compile a COMPLETELY EMPTY UWP app project that includes LanguageExt.Core. I've submitted a bug to VS. I still wonder though if your Record class will work on .NET Native.\nhttps://developercommunity.visualstudio.com/content/problem/152935/build-fails-with-net-native-out-of-memory.html. Sorry I wasn\u2019t clear. When I said it didn\u2019t work I meant the code asserted that two records were the same when they weren\u2019t, presumably because it couldn\u2019t see those manual private  fields that I used to back the properties. I still think the docs could be a bit clearer since \u201cfield backed properties\u201d sounds a lot like what I wrote that didn\u2019t work. I\u2019ve read about \u201cauto implemented properties\u201d - maybe that is what you meant. I just looked at your code.\nI think the docs would be more clear if it said it works with \u201cpublic fields and public auto-implemented properties; private and protected members are ignored.\u201d\nIt is curious to me that the visual studio fails net native compilation on a totally empty project with language-ext as the only nuget package. Not your fault but i do wonder why.\nThat Record class is a clever piece of code. Super useful. I try to use immutable everywhere and the lack of support for this in C# (yet) is quite frustrating.\n\nFrom: Paul Louth notifications@github.com\nSent: Tuesday, November 21, 2017 9:49:15 AM\nTo: louthy/language-ext\nCc: Justin Magaram; Mention\nSubject: Re: [louthy/language-ext] Record types and .net native (#306)\n@jmagaramhttps://github.com/jmagaram > Forget .net native for a sec. Out of habit, I tried testing it with a class like the following. It does NOT work\nSaying something does not work, but without specifying what doesn't work isn't particularly helpful. However the documentation is pretty clear:\nNote that only fields or field backed properties are used in the structural comparisons and hash-code building.\nBy providing your own implementations to the properties you are not using field-backed properties (even if you are actually backing them with fields manually). Field backed properties have special names given by the compiler that the Record system can spot.\nSo you can either use the second example, or:\npublic class PersonC : Record\n{\n    public string FirstName { get; }\n    public int Age { get; }\npublic PersonC(string firstName, int age)\n{\n    FirstName = firstName;\n    Age = age;\n}\n\n}\nWith regards to your .NET Native comment. It seems the limitation is reflecting on 'private members of the .NET Framework class library'. I guess the implication is that the meta-data from the core BCL isn't being included in native builds, whereas the meta-data for types within your project and third-party DLLs are. Since the record system can't be retrospectively applied to a .NET Framework type (you can't make DateTime into a Record for example) then this limitation doesn't seem important or relevant.\nHowever if you want to see the code that gets the list of FieldInfo structures for a Record derived type, take a look herehttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/Utility/Reflect.cs#L11.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/louthy/language-ext/issues/306#issuecomment-346106198, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ANecS6FrtAVy2GwxIAUZVOlb3fJvzaF-ks5s4w0bgaJpZM4Qjex5.\n. One other thing. Fields are almost ALWAYS private. That is why I think clarification is helpful.\n\nFrom: Justin Magaram\nSent: Tuesday, November 21, 2017 10:28:04 AM\nTo: louthy/language-ext; louthy/language-ext\nCc: Mention\nSubject: Re: [louthy/language-ext] Record types and .net native (#306)\nSorry I wasn\u2019t clear. When I said it didn\u2019t work I meant the code asserted that two records were the same when they weren\u2019t, presumably because it couldn\u2019t see those manual private  fields that I used to back the properties. I still think the docs could be a bit clearer since \u201cfield backed properties\u201d sounds a lot like what I wrote that didn\u2019t work. I\u2019ve read about \u201cauto implemented properties\u201d - maybe that is what you meant. I just looked at your code.\nI think the docs would be more clear if it said it works with \u201cpublic fields and public auto-implemented properties; private and protected members are ignored.\u201d\nIt is curious to me that the visual studio fails net native compilation on a totally empty project with language-ext as the only nuget package. Not your fault but i do wonder why.\nThat Record class is a clever piece of code. Super useful. I try to use immutable everywhere and the lack of support for this in C# (yet) is quite frustrating.\n\nFrom: Paul Louth notifications@github.com\nSent: Tuesday, November 21, 2017 9:49:15 AM\nTo: louthy/language-ext\nCc: Justin Magaram; Mention\nSubject: Re: [louthy/language-ext] Record types and .net native (#306)\n@jmagaramhttps://github.com/jmagaram > Forget .net native for a sec. Out of habit, I tried testing it with a class like the following. It does NOT work\nSaying something does not work, but without specifying what doesn't work isn't particularly helpful. However the documentation is pretty clear:\nNote that only fields or field backed properties are used in the structural comparisons and hash-code building.\nBy providing your own implementations to the properties you are not using field-backed properties (even if you are actually backing them with fields manually). Field backed properties have special names given by the compiler that the Record system can spot.\nSo you can either use the second example, or:\npublic class PersonC : Record\n{\n    public string FirstName { get; }\n    public int Age { get; }\npublic PersonC(string firstName, int age)\n{\n    FirstName = firstName;\n    Age = age;\n}\n\n}\nWith regards to your .NET Native comment. It seems the limitation is reflecting on 'private members of the .NET Framework class library'. I guess the implication is that the meta-data from the core BCL isn't being included in native builds, whereas the meta-data for types within your project and third-party DLLs are. Since the record system can't be retrospectively applied to a .NET Framework type (you can't make DateTime into a Record for example) then this limitation doesn't seem important or relevant.\nHowever if you want to see the code that gets the list of FieldInfo structures for a Record derived type, take a look herehttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/Utility/Reflect.cs#L11.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/louthy/language-ext/issues/306#issuecomment-346106198, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ANecS6FrtAVy2GwxIAUZVOlb3fJvzaF-ks5s4w0bgaJpZM4Qjex5.\n. ",
    "longqinsi": "I have support you 3$. Sorry because of my incoming, I can't give you too much.. Maybe I will give you more sponsor, but a regular patreon like www.patreon.com is too heavy for me. I can't give a promise to give how much money at some time. But maybe sometime later when I come here again I will sponsor another virtual coffee.\nAnyhow, the language-ext you created and are maintaining is great. Keep on.. BTW, there have been several books about functional programming in c# in the market. I think you can contact them to see if anyone of them wants to write a book for your framework.. Or you can contact some IT publisher, e.g. O'Reilly, Packt Publishing, and etc.. BTW, instead of adding more functions to language-ext, I think you can take a while to write some samples for it. I have seen that the samples project in the solution is empty. If there are some pragmatic samples, I think there will be more users of your library, and maybe more patrons.\nAnother thing, you can consider become an author in pluralsight.com by teaching how to use language-ext. It will take you a large amount of time, but it will also lower the threhold for people to master language-ext. And the lessons in pluralsight are for no extra fee for subsribers of pluralsight, unlike udemy.com where every lesson has its own price. This means that if you publish a lesson on pluragsight, every subsriber can immediately access it without any obstacle. And then the lesson can become an advertisement of language-ext.\nOf course, if you like, you can publish lesson to udemy.com.\nMaybe you can publish some introduction or tutorial video of language-ext on Youtube, Channel9, and so on.\nIn general, I think the most important thing for language-ext at present, is not to make it better, but to make it known to more people and easier to be used by others.. Ok, I'm sorry that I didn't think of your circumstances as a CTO who have been very busy.\nI'm still studying functional programming and your framework. I will keep a key on your language-ext. It's great!\nBTW, fsharpforfunandprofit is indeed a great tutorial site. I get in touch with FP via it and studied a lot about F# there.\nI'm planning to study Haskell. Maybe someday I will ask you some questions about Haskell :-) . ",
    "cjdsellers": "Hi Louthy,\nI'm currently writing a trading platform I hope to go open source with. I've been finding good use for more and more functional approaches within the code base, I was just saying to a mate a few days ago that it would be great if there was even more support for functional concepts in C#. I was starting to do some some more research and then stumbled upon your library! I'm extremely impressed in its scope, and honestly it's probably far more than what I need (although I appreciate the wide vision you have for language-ext). If I find any financial success through my use of, or inspiration from language-ext, I'll be sure to pay credit where credit (and pay) are indeed due.\nCheers,\nChris . ",
    "abdulkaderjeelani": "Hi Louthy,\nHats off for writing a wonderful library, Its just great!\nIt would be greater if you could provide some pointers on using interpreters pattern, for i/o operation, \nbest approach to do database operations.\nThanks\n. Great! Thanks,\nOne more struggle is in schema modeling (Value Objects and Entities) with Language -ext record type,\nIn the sample, banking schema the if PersonName is a value object, and Account is an entity. Can they both be treated as RecordTypes? where getting structural equality of Value Object is extremely wonderful, What do do in case of entity, Can I model my entities without record types?. ",
    "gregberns": "@louthy thats awesome. I'm not sure I'm totally ready for monads yet, I'll definitely need to study that one a bit. The Do extension will do just fine for now. I was definitely thinking of implementing with a list, just figured I'd keep the question simple.\nThanks again for the great library, I've been working on understanding functional for 2-3 years now and this really helps me start exploring the next level of FP when I'm in C#. Thanks!!. @louthy Thats awesome, thanks for the fantastic feedback. I got a ton cleaned up based on your recommendations. Thanks again for a great project, its so helpful when trying to integrate FP into everyday work without having to switch languages.. Dang Paul, not sure how you do it...\nWith Union, do the types have to match?  Looks like the merge signature takes two of the same type and returns that same type.\n//Map class\npublic Map<K, V> Union(Map<K, V> other, Func<K, V, V, V> merge);\nCan you take two different types into merge and return a third? Is this valid for union??\n```\n//Map class\npublic Map Union(Map other, Func merge);\n//or 'union' (this could be slightly off)\npublic Map union(Map first, Map other, Func merge);\n```\nLike with map (the function), you go from a -> b. With union can we a -> b -> c?\nThe case I was looking at I think can be summed up like this:\n```\nvar x = Map\nvar y = Map\n//with output of\nMap z = union(x, y, (k, j, l) => new M( j, l))\n//Or a more concrete implementation/example\nvar names = Map\nvar ages = Map\nMap z =  union(names, ages, (k, name, age) => new Person(name, age)\n```\nI'm not sure if this is even valid for Union? Not familiar enough with the real definition of union.. Yea I was looking at the code and it looked like the types had to match up, and like the Haskell doc talks about the signature will have to change to handle the missing cases.\nIn any case, I can get by without. Thanks for the help.. That worked like a charm. Just had to implement IComparable on my keys. That really helped simplify the code as well. Thanks for the help.. Of course!. > the sub-expression must have the same outer type\nAh! That makes so much more sense now. Using the sub-expression (#1) is what I was looking for, that really makes it quite easy to understand. I never really liked the comprehension syntax with lists, but with monads its brilliant. Especially in this case the fluent syntax gets pretty nasty.\nThe 'Seq' suggestion is interesting. In this problem I'm battling with what to do with the Eithers. I want to log them (and I keep flipping on where to do that: right after the failure or after the list of items is processed) but I'm not sure if the failure needs to be exposed out of that area of the code. The es and et are actually network calls that return Either<Error, Unit>.\nAs always, thanks for the help.. I figured. Thanks Paul. Thanks Paul. We've discussed that before, now I remember.\nHere's the resulting code change. Map over the strings to generate a IEnumerable<Validation<Error, string>>, then use Sequence to 'flip' the enumerable in and the validation out.\n```csharp\nvar list = new List() { \"1234\", \"12\", \"123456\" };\nvar ValidateString = fun((string s) => s.Length < 5 ? Success(s) : Fail(Error.New(\"Too long\")));\nValidation> validation = \n                list.Map(t => ValidateString(t))\n                    .Sequence();\n```. I'm going to dig a little further into Validation.\nOnce we have a Validation object we can operate on the Sucess with Map. But how do we operate on the errors? More specifically, how can we Fold/Aggregate the errors into a single error to return to the user?\nSince I'm familiar with Either, I can call ToEither(), and then use MapLeft, but its a little ugly. Any better options?\n```csharp\nValidation> validation2 = Error.New(\"\");\nvalidation\n                .ToEither()\n                .MapLeft(es =>\n                    es.Aggregate(\"Validation Errors: \", (a, b) => a + \", \" + b.Value)\n                        .Apply(err => Error.New(err)));\n```\nThanks. Not sure why I didn't think of that obvious option. Thanks Chris. ",
    "adrianjord": "In a new project I'm working on we are using EntityFramework with a database first implementation and they chose to keep Nullable types as the database is quite old. When I came across this with Nullable, I wasn't sure if this was the intended usage. Thank you for clarifying, my usage was just odd and didn't realize I shouldn't be returning Nullable. ",
    "JHaugh4": "Awesome! Thank you for the quick response I look forward to using this.. ",
    "chadedrupt": "Great, thanks for the explanation, I'll take a closer look at the Try family.. ",
    "gwintering": "@louthy  Thanks for the quick response.  I know what you mean about the generics; in my use I NewType<> away all but the return type.\nSince you're up for including it, I started defining the essential methods.  Please take a look at fee58d06a25e1cd6abaa95d5b40d25f75f06bda0 and let me know if you think the approach will work.. >  how does that work out with LINQ and the like? Are you dereferencing to Value?\nI treat it like a proxy, or any other encapsulated primitive.  So yes I'm derefernciing to Value, but only in the reimplementation of Select, SelectMany, Map, and Bind, which enables LINQ.  There's also implicit conversion to and from Rws<> to allow interop with any of the functional style Prelude.\n\nI wonder if there's a better aliasing story that could be achieved here\n\nI'd be interested in whatever your thoughts are on this.. >The race is a feature.\nYes, there are uses for racing.  But racing semantics hidden deep in a library are highly unexpected.  Most of the time we work very hard to prevent races because it's a particularly nasty form of non-determinism.\nYou seem committed to keeping racing as a feature, so as a compromise we could limit this change to Trys while allowing Tasks to race.  Accordingly, the rest of this comment does not apply to MTask.\n\nThere is no 'right' way to implement Plus, each type can use its own decision making to combine the result\n\nOf course the implementation is going to vary by type, but there are some laws that most types try to support so they behave intuitively.  Racing left and right supports none of those laws, which leads to very unintuitive behavior.  Trys are all about handling errors, so it makes the most sense for them to support Left Catch.\n\nthe fact they don't match their sync counterparts is irrelevant\n\nThe inconsistency is highly relevant.  Their names suggest they are related, and names are the first order documentation of a library.\n\nThere are real benefits to taking the first successful result.\n\nI'm sure there are, but we should consider the overall purpose of Trys, which is functional error handling.\nThere's a very nice symmetry to representing all your fault prone operations in the various Trys, which allows you to compose them to defer error handling till you have the context to do it properly.  Intuitively, you'd select the Try to use based on whether the operation might not produce a value (Option) and whether the process is inherently asynchronous (Async).  But if you follow that intuition, you get this extra racing behavior in the asynchronous case that hampers the monad's use in error handling.\nIt's be great if all the Trys hand similar semantics so you could uniformly write processes that mean \"Try this, but if that fails try this other thing\", irrespective of whether you were working with synchronous or asynchronous operations.  But now the asynchronous Trys have a performance optimization that prevents this consistent form.. Thanks Paul!  Good call on the separate type to support racing.  That's where I was hoping we could move the behavior to.. Here ya go: 3e268ceb450ecb06eb589966d68cab3ebb103105. Good question.  No, it's not thread safe in the sense that multiple threads could be racing to provide the memoized value, just like the current function.  The difference here is that the memoized value is just a Task, which can be produced quickly upon initiation of the underlying process, and not a Result, which wouldn't be available until the underlying process completes.  So there's a chance multiple Tasks are created and all but one of them is thrown away.  And if the Trys produce a side effect that side effect could be caused multiple times.  But that chance is drastically reduced with this implementation because we can produce the memoized value quickly.\nWe could use Lazy to lock out other threads while one of them is providing the memoized value.  I actually think there's a strong case for that in the non async Trys.  But here it might be overkill because a Task itself is not a slow or expensive value to create.\nWe could provide both options with Memo and MemoUnsafe methods, but that would raise the issue of which one to use throughout the library, which frequently memoizes as part of other methods.. When writing the from comprehensions, you have to decide which monadic type you're going to Bind/SelectMany over.  In you're first example, that's IEnumerable (you can always tell by looking at the return value of the expression).\nSo your first example is really just binding an IEnumberable with an IEnumberable; Option has an implicit conversion to IEnumberable, which is why it's not obvious.\nIn your second example, you're trying to operate on the value inside two different monads.  Unfortunately, this isn't possible with the from comprehensions, though I would love it if it were possible.  Instead, you should use the Monad Transformer family of functions.  In this case MapT fits the bill:\nvar x = Some(List(1, 2)).MapT(i => i * 2);\n\nThere's also other cool things you can do with transformers, like use Sequence to swap the monads.. In your example, what are the types of x and i?  If they are not Writer, then the call to SelectMany implicit in the from comprehension will not work.  And I don't think we can just write another overload to SelectMany because then the compiler doesn't know which one to pick.\nBut you shouldn't have to add all the code in #228.\nWhen working with the monads in this library, there's generally three tricks you can use for from comprehensions when mixing and matching other expressions:\n\nLift non Writer expression into a Writer and put if after in\nPut the non Writer expression into a let expression instead of from ... in\nTransform a Writer that's nested inside another monad so the Writer is on the outside, and use that expression after in\n\nSo you should be able to do something like this:\nfrom _ in tell<TString, string>(\"Starting . ..\")\nfrom l in Writer<TString,string,Lst<int>>(List(1,2)) //Trick #1\nlet l2 = from i in l select i + 1 //Trick #2\nlet ops = //More #1, but will be converted to #3 below\n    from i in l\n    select tell<TString, string>($\"i was {i}\")\nfrom __ in ops.Sequence()  //Trick #3\nfrom ___ in tell<TString, string>(\"Done\")\nselect l2\n\nRight now you can use the first two tricks.  However, the third trick won't work because Writer doesn't have the full complement of transforms like Sequence.  I think it should be possible for Writer to have all the transforms, but maybe @louthy  can weigh in on that idea.. Whoops, sorry about that.  Fixed.. Wow, thanks for the speedy fix Paul!. No there's no hurry at all.  For my own purposes I've created a subclass of the existing NewType that accepts an Ord<> and uses it in overrides.  But I wanted to contribute something a little more idiomatic into the library.. As I looked at this again I realized that we could use ORD in place of EQ and also deprecate the other variants of EqNewType and OrdNewType.. ",
    "vkirienko": "Thanks a lot, Paul! That's very interesting. I did not know about this Json.NET behavior. I'll try your suggestion tomorrow in the original project.\nStrange thing that it was working until recently I upgraded LanguageExt to v2.0 and Json.NET to v10.0. Something has changed there. I'll try tomorrow to rollback libraries one by one to narrow down when/where this break occurred.\nAs for Assert you are absolutely correct. My original TopHat class has equality methods implemented so I just forgot to correct Assert in stripped down example.. ",
    "sharwell": "\nbut in general throughout my code base; could there be a general issue with deep expressions, or nested lambdas?\n\nYes, this is one of the primary things fixed by dotnet/roslyn#19258. However, that fix only applies to one specific analyzer in one specific case (that happens to occur frequently). There's always a possibility that other analyzers are running slow for your use cases. There are a boatload of issues related to this (tracking down specific problems for specific users so 1) they can disable slow analyzers before they cause big problems and 2) we can fix them). Here are a couple of issues:\n\ndotnet/roslyn#7474\ndotnet/roslyn#3751\n\n\nWhat's the ETA for 15.3?\n\nIt's outside my pay grade to say anything on this specifically. However, I've been using 15.3 Preview side-by-side with my normal installation of Visual Studio 2017 (15.2), and the side-by-side experience has been quite good. If you have the hard drive space to spare, you can have one \"stable\" copy as your primary environment, and a \"preview\" copy (which should update to each preview as it's made available) to give early feedback on the direction we're headed.\n\nSupport in what way?\n\nA comment saying your project would benefit from the additional expressiveness would be fine.\n\nAre you suggesting that the comments themselves are slowing down VS?\n\nI can't prove this case yet. My guess is a gut feeling based on two observations:\n\nError cases tend to be slower for compilers than \"normal\" or \"expected\" cases\nAccording to the compiler, you have a hair over 94,000 syntax problems inside of documentation comments\n\n\nI regularly see the refactoring components crashing (yellow bar pops up, I reset it, a few mins later - yellow bar).\n\nMy immediate team is directly responsible for making sure these issues get resolved. We fixed a bunch of these for 15.3, but I know more are out there. If you have a reproducer, you can file a bug on github/roslyn. Otherwise, sending feedback with Report a Problem (top right of the IDE) is the best way to get us information so this can be fixed.\n\nMy main work project, which unfortunately I can't share, is constantly locking up and has laggy text input.\n\nSo we've heard. On the basis that your open source project and work project are likely share certain characteristics, I started here while people try to figure out how best to tackle the investigation related to your closed source projects.. > Hmm, that's interesting. I guess I could modify my doc gen to not just generate documentation, but fix-up the broken comments\n\u26a0\ufe0f I must reiterate that I have not conclusively demonstrated even to myself that this is the source of a true problem. That means even if it changes, there is no guarantee of measurable/observable improvements. I'll submit a couple easy wins as pull requests and you can see if you like them.\n\nIs there a quick way of getting the doc error output?\n\nAdd the following to your project, below where you currently set FileVersion:\nxml\n<GenerateDocumentationFile>True</GenerateDocumentationFile>\n<NoWarn>$(NoWarn),1573,1591,1712</NoWarn>\n\n... includes about 100 nu-get packages ... So it seems there could be some significant performance improvements if you could just stop checking projects that aren't changing?\n\nThere is a heavy current emphasis on both of these. The bulk of the improvements are likely to come in 15.5. During 15.3 we took care of some immediate performance concerns in Roslyn and the project system (the latter being driven by Dave Kean). Testing against the 15.3 previews revealed the next primary benefits will come from work on NuGet and the handling of much smarter incremental builds.. > Just had ExtractMethodCodeRefactoringProvider crash when I was highlighting two lines of code.\nWe fixed several cases of this in 15.3. They fell into a couple main \"buckets\" of causes; I can look them up if you're interested or you can wait and see if it goes away in 15.3.. Any chance it's caused by Microsoft/visualfsharp#2819?. I'm not the expert on F#. I linked other people on the team to your comment but they might be doing other things on Saturday. \ud83d\ude04 If there was a way to reproduce it in an open source project, that might help me track it down. \n. :memo: I didn't see a way to define an extension method for use in T4, so I went \"sneaky\" instead.. ",
    "SeanFarrow": "Hi Chris,\nThat worked a treat, so much so that I'm going to pass you some more code that is slightly more complicated.\nI'm currently returning an Option help as I throw exceptions, or does it not really make a difference?\nI'm now looking to port the following code as suctsinkly as possible:\npublic async Task GetGenderByIDAsync(Guid id)\n{\nif (id == default(Guid))\n            {\n                return (IActionResult)BadRequest();\n            }\n        try\n        {\n            var gender =ifNone(await _repository.GetGenderByIDAsync(id), () =>new Gender { Id =default(Guid), Name =String.Empty});\n\n            if (gender.Id == default(Guid) && !gender.Name.Any())\n            {\n                //No gender with the passed in Id was found.\n                return NotFound();\n            }\n\n            return Ok(\"test\");\n        }\n        catch (Exception ex)\n        {\n            return StatusCode((int)HttpStatusCode.InternalServerError);\n        }\n    }\n\nAny help appreciated as I'm new to the library, but can really see it's uses.\nCheers\nSean.\n. Hi Paul,\nI'm very interested in working with you and am immediately available.\nCould you contact me privately to discuss as I'm visually impaired and the stack overflow application process isn't as accessible as I'd like.\nCheers\nSean.. Hi,\nIn order to reproduce this, add the following program class to any type of console app with the LanguageExt core package, then remove the fully qualified LangaugeExt.Prelude from the random function.\nnamespace TestApp2\n{\n    using LanguageExt;\n    using System.Linq;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        //Create a sequence of integers. I've use Enamerable.Range here as I can't use anything from the static Prelude namespace as that causes the issue.\n        var intSeq = Seq.createRange(Enumerable.Range(1, 5));\n        //Randomly generate a value within the previously created range. Note that I fully qualify the random function here, to reproduce the problem, remove the LanguageExt.Prelude part of the qualifier and add the using static LanguageExt.Prelude back to the top of the file.\n        int number = LanguageExt.Prelude.random(6);\n    }\n}\n\n}\nI'm sure making the Seq module partial would fix this. Not only that but the HashSet and HashMap modules ae both partial, so should this be a standard pattern?\nCheers\nSean.\n. @louthy\nYou are definitely  right this isn\u2019t ideal. The only reason I was looking at the partial class idea and tried it locally, was due to the fact that all other modules are partial and that seemed to be usable when using LanguageExt.Static.Prelude.\nFrom: Paul Louth [mailto:notifications@github.com]\nSent: 12 February 2018 15:05\nTo: louthy/language-ext language-ext@noreply.github.com\nCc: Sean Farrow sean.farrow@seanfarrow.co.uk; Mention mention@noreply.github.com\nSubject: Re: [louthy/language-ext] Unable to use the Seq module when using static LanguageExt.Prelude in a code file (#366)\n@SeanFarrowhttps://github.com/seanfarrow Hmm, not sure I entirely follow. If I remove LanguageExt.Prelude from in from of LanguageExt.Prelude.random(6) then I would expect it to not compile, because LanguageExt.Prelude is a static class.\nTo be able to remove LanguageExt.Prelude from LanguageExt.Prelude.random you must first add:\nusing static LanguageExt.Prelude;\nThat does then make accessing the Seq class problematic for the reasons I mentioned in my comment above. But you can use:\nvar intSeq = Seq(Enumerable.Range(1, 5));\nTo construct your sequence and then use the fluent API from there.\nIt's not an ideal situation, and one I plan to take up on csharplang at some point.\nI'm not sure where your intuition for the partial classes idea comes from though? As partial is a compiler level construct, not something that ends up in the assembly. So, by the time you get to use LanguageExt.Core.dll the partial nature of the types have been removed.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/louthy/language-ext/issues/366#issuecomment-364949279, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ABY1fpz_lCD7xloQR405RRfAAPhsHjarks5tUFMXgaJpZM4SAHmz.\n. @louthy\nI\u2019ll have a look at this on Wednesday and submit a Pr.\nFrom: Paul Louth notifications@github.com\nSent: 04 June 2018 17:02\nTo: louthy/language-ext language-ext@noreply.github.com\nCc: Sean Farrow sean.farrow@seanfarrow.co.uk; Author author@noreply.github.com\nSubject: Re: [louthy/language-ext] Issue with the way NuGet package versions are specified (#431)\nWould it be possible to change the way LanguageExt specifies it's dependencies to use a minimum allowable version\nDoes anyone know how to do this in the new csproj reference spec? I was able to do it when project.json was a thing, but googling this is remarkably difficult.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/louthy/language-ext/issues/431#issuecomment-394408348, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ABY1ftpiHRWHAE7xr90rhwZjtkgZGKVIks5t5VnlgaJpZM4UYHms.\n. @louthy,\nWhat does the LanguageExt.RX package contain?\nDo you want me to look at the version issue for that package?\nFrom: Paul Louth notifications@github.com\nSent: 04 June 2018 19:24\nTo: louthy/language-ext language-ext@noreply.github.com\nCc: Sean Farrow sean.farrow@seanfarrow.co.uk; Mention mention@noreply.github.com\nSubject: Re: [louthy/language-ext] Issue with the way NuGet package versions are specified (#431)\n@SeanFarrowhttps://github.com/SeanFarrow Hi Sean, I've decided to relent and create a LanguageExt.Rx package, so unless you specifically need the Rx features then you can just update to the latest LanguageExt.Core and the Rx dependency will be removed.\nI did use the wildcard system to require version * for Rx which in theory should allow it to work with any version of Rx (as I'm only using the real core functionality), but it seems that has clamped it to >= v4 in nu-get, which is a touch frustrating!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/louthy/language-ext/issues/431#issuecomment-394451545, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ABY1fvTqHEooNnym44EJpchCH2s8bMSOks5t5XtbgaJpZM4UYHms.\n. It only adds system.net, which is part of the BCL.\nIf things like this are undesirable in the core, have you considered a contrib project where things like this could live?\nFrom: Paul Louth notifications@github.com\nSent: 07 September 2018 17:17\nTo: louthy/language-ext language-ext@noreply.github.com\nCc: Sean Farrow sean.farrow@seanfarrow.co.uk; Author author@noreply.github.com\nSubject: Re: [louthy/language-ext] Add the capability to parse an IP address to the Prelude.Parse module (#469)\nNot totally against the idea, but it would add an extra dependency which might be undesirable. Open to opinions.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/louthy/language-ext/issues/469#issuecomment-419490704, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ABY1fsU6N38YGPazR4gfe9DejGzoajANks5uYpwEgaJpZM4WYSn0.\n. System.net is available by default in .net standard 2.0.\nFrom: Paul Louth notifications@github.com\nSent: 08 September 2018 09:44\nTo: louthy/language-ext language-ext@noreply.github.com\nCc: Sean Farrow sean.farrow@seanfarrow.co.uk; Author author@noreply.github.com\nSubject: Re: [louthy/language-ext] Add the capability to parse an IP address to the Prelude.Parse module (#469)\nYup, less concerned about .NET Framework, more concerned with .NET Core\ndependencies. I\u2019ve not checked if it\u2019s available by-default or requires\nanother nuget include\nOn Fri, 7 Sep 2018 at 17:33, Sean Farrow notifications@github.com wrote:\n\nIt only adds system.net, which is part of the BCL.\nIf things like this are undesirable in the core, have you considered a\ncontrib project where things like this could live?\nFrom: Paul Louth notifications@github.com\nSent: 07 September 2018 17:17\nTo: louthy/language-ext language-ext@noreply.github.com\nCc: Sean Farrow sean.farrow@seanfarrow.co.uk; Author \nauthor@noreply.github.com\nSubject: Re: [louthy/language-ext] Add the capability to parse an IP\naddress to the Prelude.Parse module (#469)\nNot totally against the idea, but it would add an extra dependency which\nmight be undesirable. Open to opinions.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub<\nhttps://github.com/louthy/language-ext/issues/469#issuecomment-419490704>,\nor mute the thread<\nhttps://github.com/notifications/unsubscribe-auth/ABY1fsU6N38YGPazR4gfe9DejGzoajANks5uYpwEgaJpZM4WYSn0>.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/469#issuecomment-419495336,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AB5kk9lY49P1ZWVFPbaXcSnuXR0KOWf_ks5uYp_PgaJpZM4WYSn0\n.\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/louthy/language-ext/issues/469#issuecomment-419624255, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ABY1fqm6LsctgU3V3neALAI9_YzssPjuks5uY4NTgaJpZM4WYSn0.\n. ",
    "cfiet": "Hi @NickDarvey, @louthy \nI still feel that those constructors would be very useful, especially if implemented with ToAsync calls.\nI think ToAsync is not the clearest way of doing that, hence this issue as well as #283 . Constructors on Prelude were the first place I looked and to be honest, I did create Try<Task<T>> as an attempt of solving my issue, but missed the ToAsync until it was pointed out to me.\nI had an idea of implementing Try*Task methods to keep existing Try*Asyncs intact, but since they are already implemented here, I think it would be worth refining those.. Hi,\nThank you for your quick answer, your solution seems to be working in almost every case. I did find case where it fails, see the second test case in this file. I think this is due to a bug/missing specialised definition for ToAsync for untyped tasks. I'm working on adding the missing declaration.\nThe whole thing left me with a question of what is the purpose of TryAsync type? All it does is it runs computation via Task.Run, but does not really seem to lift/unlift the task correctly, so it can't be used with async methods and Tasks. Any insight here?. ",
    "alastairs": "Thanks @GiuseppePiscopo for doing the necessary detective work, I've just run into this same issue myself. I can use 2.1.18 as a workaround for now.. ",
    "GiuseppePiscopo": "Let's hope is a temp workaround and not a stable thing. I just gave a rough look at the commit so I could not really tell if there was a specific requirement to switch over netstandard 2. Ouch. Thanks for pointing to that, I did not find those info in my initial search.\nWell, I guess this can be closed now.. Generated exception, the one wrapped in an AggregateException due to .Wait(),  is reported on repro project page. Here it is for simplicity:\nType: \n\nLanguageExt.BottomException\n\nMessage: \n\nValue is in a bottom state and therefore not valid.  This can happen when the value was filtered and the predicate returned false and there was no valid state the value could be in.  If you are going to use the type in a filter you should check if the IsBottom flag is set before use.  This can also happen if the struct wasn't initialised properly and then used.\n\nStacktrace: \n\nat System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\n   at TaskExtensions.d__5`3.MoveNext()\n\n. Hi there, thanks again for support. Yes, it seems to me as well that is the same issue. The extensions you wrote fit well on repro project. I'm still struggling applying that on real life project, as left type is an interface and Where implementation complains about Only assignment, call, increment, decrement, and new object expressions can be used as a statement:\n\nAny idea?\nApart from this, one downside is that I guess I have other cases like that in code, and so one should go hunting them down and add appropriate extension methods on a type-by-type basis. I don't completely agree with @trbngr nice gist, as you're forced to create exceptions just for the sake of it, and at a first thought I don't feel great about that.\n\nYou can definitely think of Try<A> as a friendlier Either<Exception, A> and TryAsync<A> as a friendlier Task<Either<Exception, A>>.\nThere's also TryOption<A> which is basically: Either<Exception, Option<A>> and TryOptionAsync<A> which is Task<Either<Exception, Option<A>>>.\n\nSadly there seems to be nothing similar to Task<Either<SomeType, A>> where left-side is not Exception, and I'm not yet really familiar with Try/Option/TryOptionAsync anyway.\nFor future readers, I've successfully applied the workaround (LINQ extensions methods specific to the left-type) onto repro project. It's in fix/left-type-extensions branch.\nAgain, thanks for support.. Re. compile time error, nevermind: it was enough to replace ? r with ? Right<IAuthValidationTag, A>(r) and l => l with l => Left<IAuthValidationTag, A>(l).. ",
    "mathiasbn": "Thank you for quick reply. I can live with that extension. I feared that I missed something, I'm not used to frameworks so Haskell'ish near.. And then a follow up.\nI found that I actually could type it better with a TryOption.Or(Try)\nTo add a little context. \nThe first call is searching for a contact. That call could fail, hence the Try part. But it could also be \"not found\", hence the option part.\nIf it is not found, I will create it, hence the Or(Try) part.\nHow would I update my Extension to that? \n(Sorry, I find this orthodox functional style a bit more difficult than other functional libs i've tried...). ",
    "timminata": "Hi Paul, thanks for the quick response. This is on the latest stable version from nuget (LanguageExt.Core 2.1.21). Haven't tried building from source or anything like that as of yet. In the example it should have been Lst obviously. I have also tried with other data types with the same result, however.. Yeah that example doesn't work for me, fails on Debug.Assert(lint[0] == 0). Thanks for taking a look. Cool, I will use that in the interim. Thanks.. Unfortunately also having problems with that solution. This code fails:\n```\n           Lst lint = new Lst();\n           lint = lint.Insert(0, 0).Insert(1, 1).Insert(2, 2).Insert(3,3);\n        Debug.Assert(lint[0] == 0);\n        Debug.Assert(lint[1] == 1);\n        Debug.Assert(lint[2] == 2);\n        Debug.Assert(lint[3] == 3);\n\n        lint = lint.RemoveAt(2).Insert(2, 500);\n\n        Debug.Assert(lint[0] == 0);\n        Debug.Assert(lint[1] == 1);\n        Debug.Assert(lint[2] == 500);\n        Debug.Assert(lint[3] == 3);\n\n```\nReally strange. Thanks!. ",
    "LubosBehensky": "Ok, I will try the implementation described in the book. Thanks.. Thank you for the explanation.\nLubo. ",
    "chakming": "read the following source code, Is this expected behaviour? if so this seems a feature request \nhttps://github.com/louthy/language-ext/blob/master/LanguageExt.Core/DataTypes/Try/Try.Extensions.cs#L213-L215. ",
    "sholland1": "Ok, thanks.. ",
    "3dGrabber": "Just realized that the r3 example would have the wrong signature for Bind. Should probably have another name?. Whoa, thanks a lot for the detailed response!\nThis will be handy.\n\nThe Result type is meant as an intermediate value, so I'm probably not going to make it fully monadic.\n\nOk, got it, so it is a design decision.\nI thought maybe MResult<T> would somehow subtly break the monad laws.... ",
    "mrgchr": "Thank you for your merging and developing nice project.. Thank you.. Excuse me for cutting in. I'm also interested in this case.\nIn my env, following test case fails:\n```cs\n[Fact]\npublic async void HandlesException()\n{\n    var i = Some(1);\nawait Assert.ThrowsAsync<DivideByZeroException>(async () =>\n    await i.ToAsync().Match(async n =>\n        {\n            await Task.Delay(10);\n            var zero = 0;\n            var result = n / zero;\n        },\n        () => { }));\n\n}\n```\nBut, following code passes:\n```cs\n[Fact]\npublic async void HandlesException()\n{\n    var i = Some(1);\nawait Assert.ThrowsAsync<DivideByZeroException>(async () =>\n    await i.ToAsync().Match(async n =>\n        {\n            await Task.Delay(10);\n            var zero = 0;\n            var result = n / zero;\n            return result;\n        },\n        () =>\n        {\n            return 0;\n        }));\n\n}\n```\nSo, following code is almost same as the original test case and pass successfully:\n```cs\n[Fact]\npublic async void HandlesException()\n{\n    var i = Some(1);\nawait Assert.ThrowsAsync<DivideByZeroException>(async () =>\n    await i.ToAsync().Match(async n =>\n        {\n            await Task.Delay(10);\n            var zero = 0;\n            var result = n / zero;\n            return Unit.Default;\n        },\n        () =>\n        {\n            return Unit.Default;\n        }));\n\n}\n```\nI have noticed that original test case is uging Match(Action<A> Some, Action None in OptionAsync.cs.\nIn my personal opinion, I guess following new overload methods might solve this type of case for example:\n```cs\n        public Task Match(Func Some, Func None) =>\n            MOptionAsync.Inst.MatchAsync(this, Some, None);\n    public Task<Unit> Match(Func<A, Task> Some, Action None) =>\n        MOptionAsync<A>.Inst.MatchAsync(this, Some, None);\n\n    public Task<Unit> Match(Action<A> Some, Func<Task> None) => ...\n\ncs\n        public async Task MatchAsync(OptionAsync opt, Func Some, Func None)\n        {\n            if (Some == null) throw new ArgumentNullException(nameof(Some));\n            if (None == null) throw new ArgumentNullException(nameof(None));\n            if (await opt.IsSome) await Some(await opt.Value); else await None();\n            return Unit.Default;\n        }\n    public async Task<Unit> MatchAsync(OptionAsync<A> opt, Func<A, Task> Some, Action None)\n    {\n        if (Some == null) throw new ArgumentNullException(nameof(Some));\n        if (None == null) throw new ArgumentNullException(nameof(None));\n        if (await opt.IsSome) await Some(await opt.Value); else None();\n        return Unit.Default;\n    }\n\n```\nAgain, sorry for cutting in. I hope this post is helpful.. ",
    "SirUppyPancakes": "Makes sense, thanks.\nLove the library so far!. As a side note, I imagine it is a lot of work writing unit tests for a library this large, and even harder to get good coverage of every function/utility. Since this is a functional library, might I suggest considering something along the lines of QuickCheck? (there is a .NET port available too: https://github.com/fscheck/FsCheck)\nAdmittedly, I haven't had a chance to try it out it myself (I've been meaning to), but the tedious nature of writing unit tests often causes me to give up on writing them altogether, This seems to make the process less painful.. ",
    "ggmueller": "In this case, the exception is not resolved to a Faulted Task, but instead kills the ThreadPool.\nThus code outside of the Match cannot handle the exception.\nThis is the test attached:\n```csharp\n         [Fact]\n        public async void HandlesException ()\n        {\n            Option i = 1;\n        await Assert.ThrowsAsync<MyException>(async () => await i.ToAsync().Match (\n                async n =>\n                {\n                    await DoWork();\n                    throw new MyException (n.ToString());\n                },\n                () => { }));\n    }\n\n```. I will test that in the new year. New release looks good though. \nThanks for your great support. Its a real pleasure working with language-ext.. ",
    "NickSeagull": "Nevermind, just solved it by myself:\n```cs\n            var result =\n                from r in DeleteOutputFolder(\"...\")\n                from s in AccessDB(\"...\")\n                select r;\n        result.Try().Match(\n            Succ: (Unit _) => PrintLine(\"All correct\"),\n            Fail: ShowException\n        );\n\n``. Oh, understood, the problem was thatDeleteFolder` wasn't defined like a lambda \ud83d\ude04 .\nClosing this, thanks!. ",
    "CharlesTaylor7": "There was an existing redirect in our app.config, deleting it made it work. Thank you.. ",
    "lucascebertin": "Great, thanks!. ",
    "ijsgaus": "Sample on FSharp - without LanguageExt - code compiles. After reference - no. And error difficult to determine. I try make analog CSharp sample.\n. You are right, changing namespaces not help.. ",
    "Saikyun": "I have not! The thing is I'm sitting on OSX so I'm not sure about how to\nimport DLLs, but I'll google around a bit and get back when I've figured\nout how Unity/Mono deals with DLLs outside Windows.\nDen 6 jan. 2018 4:24 em skrev \"Paul Louth\" notifications@github.com:\n\n@Saikyun https://github.com/saikyun The nu-get packages contain DLLs\nfor .NET 4.5.1 - they should work on any .NET 4.6 compatible system too.\nHave you tried those?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/340#issuecomment-355753795,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACXPZ8YS8DedsPh2sgPjwkGC-E1bsAc0ks5tH5AegaJpZM4RVUuq\n.\n. I'm getting the following error, and I'm not finding anything that helps when I'm googling:\n\nerror CS0009: Metadata file '.../Assets/LanguageExt.Core.dll' does not contain valid metadata\nCompilation failed: 1 error(s), 0 warnings\nAny ideas...? :)\n  . Oh, it's how Unity does it. :) You just pull DLLs into the Unity project.\n2018-01-07 15:18 GMT+01:00 bender2k14 notifications@github.com:\n\nWhy is the DLL in a folder called Assets? Did you add language-ext as a\ndependency via NuGet? Are you compiling in Windows or somewhere else?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/340#issuecomment-355825763,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACXPZ98devNT7IcYjcFY8d1QJh9HgaKjks5tINIjgaJpZM4RVUuq\n.\n. Currently I'm using OSX, and it's Unity that does the compiling, using Mono.\n\n2018-01-07 15:19 GMT+01:00 Jona Ekenberg saikyun@gmail.com:\n\nOh, it's how Unity does it. :) You just pull DLLs into the Unity project.\n2018-01-07 15:18 GMT+01:00 bender2k14 notifications@github.com:\n\nWhy is the DLL in a folder called Assets? Did you add language-ext as a\ndependency via NuGet? Are you compiling in Windows or somewhere else?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/340#issuecomment-355825763,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACXPZ98devNT7IcYjcFY8d1QJh9HgaKjks5tINIjgaJpZM4RVUuq\n.\n\n\n. Unity does run a modified version of Mono though, so it's not that simple\neither. :/\n\nDen m\u00e5n 28 maj 2018 20:28monnef notifications@github.com skrev:\n\nI am not willing to compromise this project to support the legacy\nlanguage, sorry.\nI completely understand. But to be clear - it is not legacy, Unity uses\nMono which seems to be the only multiplatform solution for .NET platform.\nSo this is not that much about Unity, but rather about multiplaform\nsupport. Or I might be wrong (don't know much about .NET world) and\nofficial build tools do support Linux, Mac, PS4, Switch and other platforms\nUnity can run on?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/340#issuecomment-392583181,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACXPZ3quEGJX9_Zg1ODYIcjeyzGjCNQ3ks5t3EHegaJpZM4RVUuq\n.\n. \n",
    "mnn": "I have similar issue. I have manually downloaded binaries from nuget and moved them to the asset folder (only the dll). I am getting:\nAssets/OptionTest.cs(4,7): error CS0246: The type or namespace name `LanguageExt' could not be found. Are you missing an assembly reference?\nI have tried both dlls, both behave exactly the same way. I have added a reference in IDE (using Rider) and in IDE it looks fine. I have no clue if this is a problem with this library or with Unity (I don't have much experience with .NET ecosystem, going back to C# world after several years working in JS/TS/Scala). I am trying it on Kubuntu 16.04. Is this library Mono compatible?. After switching player configuration to use newer Mono (it says \".NET 4.x equivalent\"), I am getting same error as @Saikyun :disappointed:.\nerror CS0009: Metadata file `/mnt/xxx/unity/test03/test03-lang-ext/Assets/LanguageExt.Core.dll' does not contain valid metadata\nI'll try posting this issue to some Unity forum, since it works with Mono, the issue seems to be on the Unity side. Thank you for your assistance.. > I am not willing to compromise this project to support the legacy language, sorry.\nI completely understand. But to be clear - it is not legacy, Unity uses Mono which seems to be the only multiplatform solution for .NET platform. So this is not that much about Unity, but rather about multiplaform support. Or I might be wrong (don't know much about .NET world) and official build tools do support Linux, Mac, PS4, Switch and other platforms Unity can run on?. > Unity does run a modified version of Mono though, so it's not that simple either. :/ \nI saw people were able to get this library running when it was written in older C#. Is there anything suggesting that it won't run with Unity's Mono if/when C# version is supported by both? \n\nThere is also .Net Core.\n\nIt doesn't seem that it supports (or at least officially) everything Unity runs on. From https://github.com/dotnet/core/blob/master/release-notes/2.1/2.1-supported-os.md I would say that all consoles and even Android devices are unsupported by .NET core.. ",
    "sne11ius": "Just got bitten by this D:\nSince I'm neither a Unity nor a C# expert I am stuck here.... ",
    "quabug": "This library seems compatible on the latest unity 2018.2 with incremental compiler (which enable c# 7).\nSo I guess this library will work well once unity has officially support c# 7 on upcoming 2018.3.\nIn the meanwhile, you can install incremental compiler instead. But I just use limited function of this library without any test on il2cpp or mobile, so at your own risk.. ",
    "alaendle": "Thanks for your quick reply and the hint for monad transformers. While this definitely will work for the Option scenario, it's not a solution for the writer monad - or I'm not aware how I could make use of it.\nBasically I want to use the writer monad for logging like suggested in https://github.com/louthy/language-ext/issues/228. But this seems to be quite hard for real world scenarios; so what I want to write would look like.\n    var y = from i in x\n            from _ in tell<TString, string>(\"global\")\n            from ii in i\n            from __ in tell<TString, string>(\"local\" + ii)\n            select ii * 2;\n\nSo if I understand correctly monad transformation wouldn't allow me to do the \"inner-loging\" since the Writer will be faded out. Also a transformation to method chains - needed to use something like MapT (if available for the Writer) - would give a somehow ugly syntax since all the intermediate objects/states of the writer would get visible. So I still believe a LINQ compliant solution would be desirable - also I'm not sure if it is possible and worth the effort.. Unfortunately I haven't real experience in functional programming, so to not get to much confused about syntax I tried to translate the example to haskell:\n```\nmain :: IO ()\nmain = do\n  print $ runWriter $ multWithLog [1, 2]\nmultWithLog :: [Int] -> Writer [String] [Int]\nmultWithLog input = do\n  _ <- writer(0, [\"Start\"])\n  let c = fmap (\\i -> writer (i*10, [\"Number: \" ++ show i])) input\n  sequence c\n``\nPrints:([10,20],[\"Start\",\"Number: 1\",\"Number: 2\"])`\nFor sure real world is more complicated - I try to use the writer monad to replace the use of direct log statements so I need to carry log-level, exception objects, etc. around - but basically this what I've tried; and yes, you are absolutely right, I'm really missing a Sequence here. So MANY thanks for your detailed description of the problem - even if it might have been obvious for experienced functional programmers, it really helped me to get a better understanding!\nSo maybe we should close this issue and create a new one stating that Writer should support the full complement of transformations?. Great! I just tested 2.2.9-beta and it really seems to support my scenario well.  And again many thanks for the very detailed answers to @louthy and @gwintering. Even if I annoyed you with some beginner-level questions, I hope at least the added Sequence/Traverse methods and the syntactic sugar for writer was the result of our discussion and worth the effort. . ",
    "davegi": "Thanks Paul. I should have mentioned that I found this method but it doesn't seem to apply in my case since I is not a char...or am I missing some functional / lang-ext (magical incantation;-) way of gluing these pieces together?. ",
    "jaccarmac": "Thanks, this is exactly what I was looking for. Using delegates as monads wasn't clicking for me for whatever reason, but now that I see it applied to my specific use-case it's much more clear.. ",
    "MrYossu": "Ah, I was working my way down the main project page, trying the examples there. Didn't mention anything about usings there, so didn't know about this one :)\nThanks for the reply.. OK, you got me there :). Duh, forgot the static LanguageExt.Map namespace! Knew it would be something simple.\nThanks very much.. Hee hee, great answer!\nLike all your other users, I'm extremely grateful for all the time you've put into this amazing library. I'll have a look at opening a pull request (never done that before, but I'm sure it doesn't need a PhD!).\nThanks. Hmm, just been reading the guidelines. Pull requests are for clever people who know how to fix things. Not sure I'm in that category! I'm good at asking stupid questions, but I don't think I'd know how to do this.\nCan I make a feature request instead? That way you get to do all the hard work! Seriously, I'll have a look at your code and see if I can figure it out, but don't hold your breath. If you (or anyone else) knows how to do this, it's more likely to get done.\nThanks again.. > I agree with all of @IDisposable 's comments here.\nSo do I, I just haven't had time to do the changes yet!\nMy only comment would be that I can't use st as a shorthand for short tons, as I already used that for stones. How about I use mton and ston? Not quite as short, but no conflict then.\nThanks. OK, I did the modifications. \nPlease review and let me know of any comments.\nThanks for the feedback. This is my first time contributing to someone else's OSS, so I'm still finding my feet.. I like that reply!\nWhat happens now?. Help!\nI just did the changes as request, and committed them. It now shows that I have a conflict, which looks like I didn't have the latest code before making my changes.\nPlease can someone help me here. I'm not sure how to resolve the conflicts using GitHub. I did the changes in Visual Studio, which didn't give me any warnings about conflicts. It now shows me as not having any pending changes. What do I do?\nThanks. @louthy Sorry for being dumb, but this is the first time I'm working with github in a collaborative project, and having trouble finding my away around (I'm used to SVN).\nIf I look at my fork, I see a message telling me it's out of date. I click the button to create a pull request (which is how I think I'm supposed to get the latest), and get a message \"Can\u2019t automatically merge. Don\u2019t worry, you can still create the pull request\"\nAt this point, I lost it. What do I do now? I don't see any way to carry on with creating the pull request, and I don't see any way to merge the code bases.\nApologies again, please can you help me out here. Thanks. @bender2k14 Tyson, I'm looking at GitHub when I made that comment. I assumed I would have to use GitHub to pull the latest code form the master into my repo, then pull the code into Visual Studio from my repo and go from there. However, I can't work out how to get the latest changes from the master repo into mine.\nSorry if I wasn't clear. Thanks again for any help.. > You don't resolve the conflicts in GitHub. You should resolve them in Visual Studio.\nSorry, my bad explanation, I meant merging in GitHub and then resolving conflicts in VS.\n\nMerge master into your branch. There will be conflicts. Then fix those conflicts in Visual Studio.\nThis is where I was stuck. I can't see how to do the merge. It tells me I can merge, even though there are conflicts, but I don't see how to do the merge. I'd rather do it via the web site if I can, as I've never used the git command line, and am even less confident using that than I am with the site!\n\nAny idea how I merge from the site? The links that @IDisposable gave are all command line ones.\nThanks again.\n. @bender2k14 Thanks for the link, that looks better.\nIf all else fails, I guess I'll just revert my changes, merge (which should be possible once there aren't any conflicts) and then redo my changes. It's only one file, so not a huge problem.\nShame it's all so complicated!\nThanks again. Hee hee, I've done plenty merges before, my problem was getting the conflicting code into Visual Studio.\nOn 18/10/2018 17:35, Tyson Williams wrote:\nMerging conflicts is definitely a skill, so this is a great opportunity for you to practice it :)\n. Ho hum, I'm still struggling here.\nI manually copied the file in question from the master repo (taking a copy of my modest changes beforehand of course) overwrote my own copy and committed it. GitHub now says that there aren't any conflicts, and that I can merge.\nHowever, I still can't see how I'm supposed to merge. According to this page, there's supposed to be a \"Merge Pull Request\" button somewhere that does it, but I can't see it.\nWhen I created my fork, and did my first merge from the master, I created a pull request on my own repo, which pulled the changes in. I can't do that now though, because when I click the button to create one, it takes me to this page. I don't see any way of pulling the changes from the master to my fork.\nI really can't believe this is so difficult. I work with SVN on a daily basis, and it's a doddle compared to this.\nPlease can someone explain to me exactly how I get the latest code from the master into my fork? Please spell it out like I'm a really stupid dumb idiot who hasn't a clue about anything, because that's how I feel about it right at the moment!\nThanks. @bender2k14 Thanks very much for the excellent explanation. Although I'm still a bit stuck (see below), at least I understand this a lot better.\nSo I got the idea of the three database correct, although it was good to see that I'd got it right! However, I think maybe I didn't explain my question clearly enough.\nIf I understand it correctly (which I may not, feel free to correct me), I created a fork, which was my copy of Paul's master. This lives in GitHub. I then pulled this into VS, which is my local copy. I made changes to my local copy, and then pushed those to my fork (on GitHub). In the meantime, the master was updated with new commits which I don't have. So, it seems to me that I need to get those new commits from the master into my forked repo, from where I can pull them down to VS and make the changes. That's where I'm getting stuck. I'm not trying to push my changes into the master repo, I know I can't do that, and even if I could, Paul still has some changes he wants me to make before my changes can be accepted.\nWhere i got stuck (and still am) is that I couldn't see how to get the new commits from the master repo into my fork. I assumed (again, correct me if I'm wrong here) that I would have to do that from the GitHub web site, as my local copy in indeed VS knows nothing about the master. It only knows that it's working against a repo, namely my fork.\nHowever, despite the docs claiming that I should be able to pull the new commits into my fork, I couldn't do it, as I didn't see the same on the screen as what is shown there.\nEnter SourceTree, which apparently will allow me to do this. Problem is, irrespective of which copy of the code I select, my SourceTree only shows commits that were made to the master before I took my fork. It doesn't show any since, so I can't get the new commits.\nEven if I click on REMOTES -> origin (which you said should show me the master copy), I see my most recent commit to my fork as the latest...\n\nAs you can see, it shows commits to my fork, which I wouldn't expect to see when I have the master copy selected (as none of my changes have been copied to the master yet), and other than the commits I made on my fork, it doesn't show any commits to at all since v3.0.29 on 3rd Oct, despite the fact that there have been about 14 commits to the master since then.\nSo, what am I missing here? To repeat, I'm not trying to commit anything to the master, I know I can't do that. I'm also not trying to create a new pull request, I have one open already (this one). All I want to do is get the latest code changes from the master into my fork (ie the copy in GitHub), so I can pull them into VS, and make the changes Paul requested.\nSorry this was so long, but I'm trying to clarify where I'm getting stuck, as your (otherwise excellent and extremely helpful) post concentrated more on creating a pull request, which is not what I'm trying to do.\nThanks again. @bender2k14 Wow, I'm really grateful for the amount of time and effort you've put in to helping me out!\nI'm also impressed at how well you understood my ramblings! Your clarifications of my comments were spot on, which is good, as it means I did understand what you meant, I was just using the wrong (or imprecise) terminology.\nAnyway, the step I was missing was adding @louthy's GitHub copy of Language Ext as a remote. Once I did that, was able to get my local fork up to date, and am now in a position to finish the code changes that Paul requested.\nThanks again.. @louthy Thanks to Tyson's amazing help, I managed to get your latest code into my local fork and add my unit tests back in. I removed these manually to avoid the conflict. Unfortunately, your change requests for these have gone, so they'll need reviewing again. The indentation is now correct (4 spaces instead of 2), but I can't remember what other changes (if any) you wanted.\nPlease review again and let me know if I need to change anything.\nThanks again to all who helped me get this far!. @louthy It all looks OK to me, so if you're happy with it, please push it through.\nThanks again. So are we all done then? Can I pat myself on the back as having contributed to an OSS library? First time I've done that, but hopefully not the last:). @bender2k14 Ooh-err, how exciting!\nWhat happens if I want to add more code under this pull request? For example, it occurred to me that having added a UoM for Mass, it would be useful to add one for Force (which is how I spotted the lack of Mass in the first place). As that's really just an extension of this, do I just make the changes on my local fork, push them to my GitHub fork and wait for them to be reviewed here, or do I open a new pull request?\nThanks again for all the help.. @bender2k14 OK, understood. Presumably would I use the same code base I have here for the new pull request?\nThanks. @louthy Wow, another amazing reply! I wish you would turn these replies into articles, there is sooo much useful info in here, and it just gets lost when the issue is closed.\nAnyway, I'm working my way through this, trying to understand it all, but am struggling to understand what the Reader monad is used for. You created a Div function that takes two strings, and attempts to divide their int values. Please can you explain a) how you would use such a function, as I can't see what you do with the Reader<World, int> that is returned, and b) what the Reader adds here that you didn't have with the code you showed earlier.\nThanks again for another great article. @bender2k14 That's absolutely brilliant, thanks a lot. I'll get there in the end :+1: . @louthy I can't believe you put so much effort into typing that answer! That's amazing. I'm going to print it out and read it more carefully.\nAs it happens, I've been reading Functional Programming in C# by Enrico Buonanno (on my third time through), and he explains a lot of the same things you're saying, which is good. I'm reading the book over and over again, trying to get it all clear. Your library helps a lot, as you have production-ready code which I can use in my experiments.\nAs for your specific comments, as it happens, GetQuestion is a pure function, I just simplified it for this post. The real function takes all the data it needs in its arguments (five of them) and is pure in every sense of the word. It still isn't functional, in the sense that it doesn't use Try or Option (not sure which is better yet), but I'm working on that.\nThe other problem is that I'm working on a very large code base (over ten years old with a lot of devs on it), that was developed in a very strict OO/imperative style, so I can't switch to FP. I'm trying to use any FP concepts that are beneficial, but this sin't going to be real FP code, much as I would like it to be! I had a hard time persuading the CTO to let me introduce a mild variation of Either, even after I demonstrated clearly how it had very little impact on the code base, but provided huge benefits over the way we currently handle exceptions. I have to tread a careful path here!\nThanks again for all the help. I'm sure I'll have lots more questions, but if I keep getting answers like this, I can see me going a long way! Maybe I'll collect all your answers and publish them as a book in your name :). > @louthy I just want to say how impressed and grateful I am that you put so much time and effort into answering questions and providing insight into a lot of this stuff.\nI think that's the understatement of the year!. > > As it happens, I've been reading Functional Programming in C# by Enrico Buonanno (on my third time through), and he explains a lot of the same things you're saying, which is good. I'm reading the book over and over again, trying to get it all clear.\n\nWow, this looks like a great book. I just bought it. I am very excited to read it.\nThanks for mentioning it! :)\n\nIt's really excellent. I've read quite a few FP books, and watched endless hours of video, and nothing comes close to being as clear as this book. He even manages to explain monads in a way that makes you realise that there's nothing complex about them at all. Every other \"explanation\" I've seen or read makes such a dog's breakfast of the whole thing that you wonder why anyone would bother!\nI'm on my third way through it, and will probably read it again and again. I strongly recommend doing the exercises (something I'm normally too lazy to do), as it made a big difference.. > > Functional Programming in C# by Enrico Buonanno\n\nI\u2019m am a technical proofer for that book, so I\u2019d recommend it highly :) Enrico did a great job.\n\nYeah, I saw he mentioned you in the beginning. His library is obviously closely modelled on yours, which is one reason why it's good, because I can use his book, but experiment with a library I would use in production.\nThe one thing I'd really like to see is a full end-to-end solution. Although his  examples were better than most, they were still generally small workflows. I'd like to see how you'd apply FP to a full solution, from front end right down to the database. Be useful to see at what points you need to drop out of FP (if any), and where everything sits, compared to the imperative style, where you'd likely have a client, service, business logic layer and repository.\nI know this would be a lot of work, but it would be hugely useful to people like me.\nHint hint :). @louthy Just been looking at the sample code you added, and I get a compiler error on line 110...\nSeq<string>' does not contain a definition for 'Add' and no accessible extension method 'Add' accepting a first argument of type 'Seq<string>' could be found (are you missing a using directive or an assembly reference?)\nAny ideas? Thanks again.. @louthy Thanks for that, I can see it now :). @louthy Paul, I read (and re-read) your post last night, and most of it makes sense to me, it's basically what EB says in his book. I got a bit lost with the monoids, but I probably just need to re-read it some more.\nHowever, it occurred to me that it was largely based on my simplified (and perhaps misleading) sample code. If you don't mind, if I show you what my code is really doing, then maybe you can show me how to improve it.\nThe situation is like this. I have to download information from a 3rd party API. The information comes in the form of an object graph, containing questions and answers, where each question may have multiple answers. In theory, all the expected questions should be in the object graph, and each question should have all the expected answers, and all data should be in the correct format. However, as I'm working with a 3rd party API, and not a great one at that, I need to code defensively.\nOnce I have the data, I need to update a ticket object (POCO, pulled from a database) with the information.\nThe imperative version of the code (without much in the way of error checking on the incoming data) looked like this..\nc#\n    ticket.FseTravelTime = GetDecimalAnswer(TravelTimeQuestionID, TravelTime_TotalTravelTime_AnswerID, codes, responses);\n    ticket.FseArrivalTime = GetDateTimeAnswer(ArrivalDepartureTimeQuestionID, ArrivalDepartureTime_ArrivalTime_AnswerID, codes, responses);\n...where the methods use the question ID, answer ID, a set of codes (pulled from our database) and the responses from the 3rd party API. The helper methods you see there look like this...\nc#\n    public static DateTime GetDateTimeAnswer(string questionID, string answerID, List<FormDotComCode> codes, WSQuestionResponseForm[] responses) =>\n          DateTime.ParseExact(GetTextAnswer(questionID, answerID, codes, responses), \"M/dd/yyyy h:mm tt\", CultureInfo.InvariantCulture);\nThese all depend on the GetTextAnswer() method, which looks up the answer in the object graph, and returns the data if it finds it, or specific message if not. This needs improving by converting it to return an Option<string>, but I know how to do that.\nMy main requirement at this point is to go through all the questions (of which there are quite a few) pulling in the data and updating the ticket object as I go along, but collecting any errors as I go along, so I can report that the end. In general, errors getting the answers will not be a fatal error.\nMy first attempt at this, which is where this issue started was to try something like this...\nc#\n    Try(() => GetDecimalAnswer(TravelTimeQuestionID, TravelTime_TotalTravelTime_AnswerID, codes, responses))\n      .Match(s => ticket.FseTravelTime = s.IfNone(0), e => errors += $\"Travel time: {e.Message}. \");\nAs you can see, this version uses Option for the data, and substitutes an appropriate default value is the data were missing. In the case of an error, it appends the exception message to the errors string variable.\nSo, to go back to your points, as far as I can see, my helper methods (GetDecimalAnswer() etc) are all pure, as they are only dependent on their parameters. I don't think I have any side-effects (other than modifying the ticket object, but I don't see how I can avoid that), other than the fact that I'm modifying the errors variable. I guess I could pass that in as a parameter, which would avoid that side-effect.\nDon't know if my waffle has confused you! If this makes any sense, please could you tell me if I'm using a reasonable FP approach here, and if not, how the code can be improved.\nThanks again for all your help.\n. @louthy \nTwo things...\n1) Any chance you could read the waffle I posted on 24 Oct 2018 and comment?\n2)~~I've just been re-reading your excellent reply from 23 Oct 2018, and am slowly getting my head around the concepts. (rest snipped)~~ Some more playing with the code sorted out my other question :)\nThanks again to @louthy and @bender2k14 for all the help. I definitely have a much better idea of how this stuff works now. Still a long way, and many more questions to go though!\n. @louthy I am constantly amazed at how much time and effort you put into answering people's questions. I'm struggling with the same issues as @andyigreg and this has been really helpful. I'm still a long way off understanding this properly, but each of these posts gets me closer.\nAny chance you could pull the code above into a complete sample? Would make it easier to play with.\nThanks again for all your efforts.. @louthy Fully agree with @TonyHernandezAtMS and politely repeat my request that you make a full sample of this so we can see how it all fits together. Would be really useful.\nThanks again for your amazing efforts at educating us!. @louthy Just been trying out the code here, and I get a compiler error on the following...\npublic static class Reader {\n  public static Reader<Env, Env> Ask<Env>() =>\n    env => env;\n}\n\nThe env at the end of the line is underlined in red, and I get a compiler error Cannot implicitly convert type 'Env' to '(Env Value, bool IsFaulted)'.\nWhat did I do wrong? Thanks. @bender2k14 That's brilliant, thanks so much for the reply.\nOnly question is that I don't get anything in the Lefts, and the Rights include \"infinity\" for the divide-by-zero cases. I thought the idea of Try was that it would produce a left (if you know what I mean) in the case of an exception.\nAny ideas? I slightly modified your code to throw more exceptions...\nIEnumerable<Either<Exception, double>> result = Range(0, 10)\n    .Map(n => Try(() => 1.0 / (n % 3)))\n    .Map(t => t.ToEither());\nIEnumerable<double> r1 = result.Rights().Dump();\nIEnumerable<Exception> r2 = result.Lefts().Dump();\n\nIf you run this in LinqPad (where I do all of my playing), you'll see what I mean.\nThanks again.. Hmm, if I change the second line to the following...\n.Map(n => Try(() => n % 3 == 0 ? throw new ArgumentException(\"Jim\") : 1.0 / (n % 3)))\n\n...then I get the expected result. It looks like Try is swallowing the exception. Does that makes sense?\nThanks again. @colethecoder Thanks, that's excellent!. @bender2k14 Thanks for the reply. I assumed there would be, but I can't see them mentioned anywhere. I looked in the list on the main project page, but couldn't see anything.\nWhere can I find docs on these functions?\nThanks again.. @bender2k14 I was hoping for something like you see on the project's main page, where there are links to things like Try(). There's not much there in the way of documentation, but at least you can see that the function exists.\nBear in mind that I'm not familiar with all the features of the package, it's very hard finding out what's in there and what it all does.\nThanks anyway, at least now I know use exists, I can play with it.. @bender2k14 Sorry, forgot to specify that I was talking about MVVM in WPF, but your comments about a web browser were worth me forgetting!\nAs to your main point, that's an interesting way of looking at it. So instead of a simple INPC property, my setter would create a new object from the old one, instead of mutating the old one?\nThe only problem I can see here is that this would require coding up every single property individually in the view model. The way I currently work is that if I had (say) a Product property on the view model, then I could bind a textbox to the product's Name property as so...\n<TextBox Text=\"{Binding Product.Name, Mode=TwoWay}\" />\nThis way, I have one Product property, and can bind as many controls to its fields as I like. By contrast, if I understand you correctly, you are suggesting I set up a separate view model property for every field on the Product, which could quickly get out of hand.\nOr did I miss something? Thanks for the reply.. @bender2k14 Sorry for my assumption that you would know what I meant by MVVM!\nI must come clean and say I've never contemplated MVVM over HTTP, so I can't really answer your question.\nMy main experience with MVVM has been in WPF desktop applications, although I've also used it in client-side Javascript code on web pages (using KendoUI in my case, but there are other frameworks that do similar things). In both cases, your view is as dumb as possible, and contains bindings to properties on the view model. The view model is UI-independent, so can be tested easily.\nHowever, the bit I'm struggling with is that (in my experience and understanding at least), the power of MVVM comes form the fact that the binding handles the conversation between the view and view model. You set up the bindings, and the framework does all the updating. That's fine in a mutable world, but if you want to go  immutable, it seems you'd need to bind to a separate view model property for every UI element. I can see that this would get out of hand very quickly. I have some views that have hundreds of UI controls, most of which are bound to fields on one view model property.\nDon't know if all of that waffle helps or makes things worse! Thanks for your reply. Any comments on what I wrote?. @bender2k14 I understand and agree with your comments, but am still not clear how you would do the binding in a WPF MVVM scenario. As I pointed out before, the way you propose it, it sounds like I would need a separate view model INPC property for every piece of data that was to be bound on the view.\nFor example, one of my windows has a view model property for an entity that represents a medical imaging system (a complex object graph). This is bound to the DataContext for the view, and the XAML then binds to properties on that entity, and child properties, grandchild properties etc.\nI just counted up, and there are 150 controls bound to properties in the object graph for that entity, however, I only have the one view model property for the top-level entity. Are you suggesting I create 150 view model properties, and bind each of these controls to its own?\nThanks again.. @bender2k14 I was using one view with one view model as an example, but as you say, the principle is the same.\n\nSimilarly, in a WPF application, new data can be received from the UI when the setter of a bound property is called.\n\nPlease can you explain what you meant by this, as I've obviously misunderstood. In my experience, data binding is done like this...\n<TextBox Text=\"{Binding RevisionNotes}\" />\n\n...where RevisionNotes is an INPC property on the current DataContext. When the user modifies the text in the textbox, the text is sent to the view model and set on the RevisionNotes property. I don't do anything, the text is automatically sent.\nSorry if I'm missing something obvious, but I really don't see what you mean. Maybe you could provide a small code sample to illustrate.\nThanks again. > You can make it into a non-auto property. In which case, that get combined with with raising INPC...\nYes, it occurred to me (too late last night) that this could be one place where we were talking at cross purposes. I usually work with entities created by Entity Framework, in which case I don't write any of the getter/setter code, it's generated by the framework. Am I right in thinking that this is not going to fit with what you're suggesting? As I said, some of our entities are object graphs with hundreds of properties, I would need to think carefully before going down the route of writing the entity code by hand.\n\nI don't see what is so special about MVVM in your question. It seems to me that you are actually asking \"Can you do FP in an application with with a UI?\".\n\nHmm, now you mention it, I think you're right. I was thinking of MVVM for two reasons, one because that's where I spend most of my day, and two because it has the two-way automatic binding (which I've never used in MVP or MVC). However, I guess the same applies to any UI.\n\nIs there a type of UI (or UI-related design pattern) for which you know how to \"do\" FP \"in\" that type of UI?\n\nNope. As you've probably guessed by now, I'm a rank amateur with FP. I'm totally smitten with it, and have gone over to a very FP-way of coding on a micro scale, ie individual methods, but am struggling to see how to put it all together in a full end-to-end application.\nMaybe this is the wrong way to think about it, but I'm wondering if the relationship between the UI and the first layer of non-UI code could be one of those boundaries (like database access) where impure coding becomes pragmatic. My impression is that unless you're using a database like Event Store, then you're stuck with impure mutable state at that end. Maybe I should treat the data coming from the UI in the same way, and have code that validates the data and converts the mutable object graph that's bound to the view to an immutable on that the rest of the code (pure FP) would use.\nDoes that make sense, or am I just taking the easy way out!\nThanks for all your patience. I am getting there, it's just a slow business, as FP is a totally different mindset from imperative programming, and I'm the sort of (slightly OCD) person who likes to understand what I'm doing, rather than copy someone else's code blindly.\nThanks again.. @bender2k14 Thanks for the reply, lots to think about there.\n\nI think one of the main ideas of functional programming is to break that code into two parts, the pure part and the impure part while also maximizing the size of the pure part.\n\nYes, which is why I was suggesting that maybe the UI/view model boundary is one of those. Looks like you agree, judging by what you said later (see below).\n\nHowever, I do get the impression that I could be further down this road than you and able to offer some suggestions.\n\nCould be? I would say that's a certainty! I appreciate the suggestions.\n\nI think this is a bad idea.\n\nYup, but it's the way I (and most people I know) currently work. I think this is part of the OO/imperative mindset.\nI'm thinking of a multi-tiered setup, where you have a repository that talks to a database via EF, a business logic layer above the repository, then a service layer, and then the WPF project which contains the view models and views. That's my most common scenario, and with that in mind, it sounds like you are suggesting something along the following lines...\n\nRepository - Gets objects from the database using EF-generated classes\nData conversion layer (quite possibly not a separate layer, but something like AutoMapper) - Converts those objects into immutable data objects suitable for FP-style coding\nBusiness logic layer and Service layer - Same as before, but using the immutable objects\nWPF project...\nView models, receive the immutable objects from the service layer, convert them into mutable versions and bind them to the UI\nUI - as before\n\nThe same scenario would work in reverse when saving data. The view model would convert the mutable object into an immutable one, send it down to the service, where it would work its way down to the part that converted it to an Ef-compatible object which would get passed to EF for persisting.\nDoes that sound reasonable? To a large extent, it sounds very much like the approach  Scott Wlaschin laid out in Domain Modeling Made Functional (an excellent book that I strongly recommend to anyone wanting to learn FP, even if you don't intend using F#).\n\nI think it would be easier to learn FP if I were able to start working on a brand new application at my job. I assume that you are like me and am doing the best you can to learn FP with the existing application in front of you. For me, I often feel handcuffed having to debug race conditions day after day. I would have rather spent that time trying to write new functional code and feeling the different pinpoints firsthand.\n\nGot it in one! However, existing projects pay the wages, whereas these investigative ones are purely for my own learning. I would need to be a lot more confident of my own capabilities and understand of FP before I would risk trying it on a new project. Not that I start many new projects, 90% of what I do is on one major, well matured, very OO/imperative based project.\nThanks again for all the replies. It's all becoming clearer. What I would really like to see is a full end-to-end project that used WPF (why main UI framework) in a proper FP style. Doesn't have to be a major project, but big enough to show how it woudl be done. The problem I have is that most samples, including the ones in Enrico Buonanno's Functional Programming in C#, Scott Wlaschin's book (mentioned before) and the language-ext samples is that they don't show the full story. Most samples are very small isolated parts of the picture, and even the bigger ones seem to miss out the crucial bits, like the UI/view model interface that prompted this question..\nThere's a challenge for you! How do you fancy whiping up an end-to-end sample? Would be a huge benefit to people like me. I'm sure I'm not the only one keen to embrace FP but struggling.\nThanks again. I printed those linked articles out, and am reading them carefully. Some good stuff there!. @bender2k14 OK, so if I'm on the right lines, maybe I'll see if I can start something. I'm still not sure about the view model, but I guess that's something that I can refine as I go along. I could be doing it wrong, but I often have quite a bit of logic in the view models, usually in response to the user changing data or clicking buttons, and I either have to do that with the mutable objects, and only convert before sending them out of the view model, or I have to do a significant amount of converting backwards and forwards in the view model. Either way sounds like I'm not doing it right.\nThanks again for all the help. Enjoy the book,it really is very good.. @michael-wolfenden Wow, that's brilliant! Much clearer.\nFew questions if you don't mind...\n1) What does the ask() function actually do? I've looked at the signature and the code, but can't work it out.\n2) The Match() function takes two parameters, the first is an Action on the result, which I understand, but the second looks like it gets called if something went wrong. What would go wrong? Obviously an exception would trigger this being called, but anything else? UPDATE: It looks like Match() is returning a Try, in which case this will only be called if there is an exception. Is that correct?\n3) Following on from the previous question (and so might be answered by the answer to that), the second parameter passed to Match() doesn't contain any information about what went wrong, so seems a bit useless. It looks like you can't actually get at the exception details. Again, this question may just be be me not understanding its use.\n4) ~~Finally (for now!), I tried a variation of your idea, where the repository returned an Option<T> instead of an object. See the code below. When I run this passing a valid ID, I get an Option<Ferret> as expected, when I pass a negative ID I get Fail printed out, but if I pass in a positive number that is not in the repository, such as 10, I get what looks like an empty collection. Why is that? I naively thought that if I passed back a None from the repository method, it would either show me None or call the second Action passed to Match(). I'm not actually sure what is happening here.~~ UPDATE: With some more playing around, I realised that I was actually getting None back, it was just that LinqPad's default way of displaying a None is as if it is an empty collection (which in a way it is). So, this question can be ignored.\nThanks again for the great reply. I hope you don't mind me asking more. You might be new to this, but you've obviously got a much better understanding than I have!\nHere is the code I used. If you use LinqPad, add the package and namespaces, set to C# Program and paste this lot in...\nvoid Main() {\n  GetFerretByIDRunAndMatch(-1);\n  GetFerretByIDRunAndMatch(1);\n  GetFerretByIDRunAndMatch(10);\n}\n\npublic class Ferret {\n  public Ferret(int id, string name) {\n    ID = id;\n    Name = name;\n  }\n\n  public int ID { get; }\n  public string Name { get; }\n}\n\npublic class FerretRepository {\n  private List<Ferret> _ferrets = new List<Ferret> {\n    new Ferret(1, \"Freddy\"),\n    new Ferret(2, \"Ferdina\"),\n    new Ferret(3, \"Frogface\"),\n  };\n\n  public Option<Ferret> GetFerretByID(int id) =>\n    id < 0 ? throw new ArgumentException($\"{id} is not a valid value for a ferret ID\") : _ferrets.FirstOrDefault(f => f.ID == id);\n  public Option<Ferret> GetFerretByName(string name) =>\n    _ferrets.FirstOrDefault(f => f.Name == name);\n}\n\npublic Unit GetFerretByIDRunAndMatch(int id) =>\n  GetFerretByID(id)\n    // Creating a new repository for simplicity\n    .Run(new FerretRepository())\n    .Match(x => Console.WriteLine(x),\n           () => Console.WriteLine(\"Exception\")\n    );\n\npublic Reader<FerretRepository, Option<Ferret>> GetFerretByID(int id) =>\n  from env in ask<FerretRepository>()\n  select env.GetFerretByID(id);\n\npublic Reader<FerretRepository, Option<Ferret>> GetFerretByName(string name) =>\n  from env in ask<FerretRepository>()\n  select env.GetFerretByName(name);\n. @michael-wolfenden You posted your reply just as I was updating question 4!\n\nThanks for the explanation of ask. I'm going to need to read it a bit more, but at first skim, it definitely looks like it clarifies it.\nAs for Match, as I said in my update, it looks like it's returning a Try, meaning that the Fail lambda is only called if there is an exception. You can just use the normal Try.Match function, whose overloads include at least one version where the exception is passed in as a parameter.\nWhat I can't work out is when the None function would be called. I modified my function to look like this...\npublic Unit GetFerretByIDRunAndMatchOld(int id) =>\n    GetFerretByID(id)\n        // Creating a new repository for simplicity\n        .Run(new FerretRepository())\n        .Match(\n            Some: x => Console.WriteLine(x),\n            None: () => Console.WriteLine(\"None\"),\n            Fail: ex => Console.WriteLine($\"Exception: {ex.Message}\")\n        );\n\n...but the None lambda was never called, even if the ferret wasn't found. I'm not sure how Try could ever be None as I thought it was either (no pun intended) the target value or the exception.\nHopefully @louthy will help us out.\nThanks again. I'll read your explanation a few more times and see if I get it.. @michael-wolfenden Actually, going right back to the beginning, I still have a basic question.\nIn your original explanation of why Reader would be used, you said \"It offers a form of dependency injection\"\nLooking at it again, I'm not sure what we have gained. Consider my GetFerretByIDRunAndMatch() function, modified to take a repository as a parameter (as I presume newing one up inside the function is exactly what we don't want to do!)...\npublic Unit GetFerretByIDRunAndMatch(FerretRepository ferretRepository, int id) =>\n    GetFerretByID(id)\n        .Run(ferretRepository)\n        .Match(\n            Some: f => Console.WriteLine(f),\n            None: () => {},\n            Fail: ex => Console.WriteLine($\"Exception: {ex.Message}\")\n        );\n\nCompare that to the way I would have written it without Reader...\npublic Unit GetFerretByIDWithoutReader(FerretRepository ferretRepository, int id) =>\n  ferretRepository.GetFerretByID(id)\n    .Match(\n      Some: f => Console.WriteLine(f),\n      None: () => Console.WriteLine(\"None\")\n    );\n\nIf you ask me, the second version is a lot clearer.\nSo what did I miss? What did we gain by using the Reader?\nThanks again.. @michael-wolfenden \nHmm, not sure I see how it helps. You still have to pass the repository around somehow. In both of the cases I showed above, it was passed in as a parameter. How does using the Reader make any difference?\nSorry if I missed something here. Thanks again.. @michael-wolfenden \nAh, I think the light is beginning to dawn! I think I confused myself when I played around with your code, as I named the two functions in FerretRepository with the same names as the two functions outside. I think also having them all in the one LinqPad file made me forget that they would normally be in separate classes.\nLooking at this code...\nUserRepository userRepository = new UserRepository();\nGetUserAandBoss()\n    .Run(userRepository)\n    .Match(x => Console.WriteLine(x),\n                 () => Console.WriteLine(\"Fail\")\n    );\n\nThis could be called from (say) a view model, which being the top-level in the hierarchy is responsible for creating the dependencies (the user repository in this case). GetUserAandBoss() could be in a business logic class, and doesn't need to be given a repository, as it will get the one created in the view model when we call Run.\nClever isn't it? Thanks again for the help, if I am correct in my summary above, then I think I have it now. \nOne (possibly) last question. What if I want to pass in more than one dependency? Let's say my business logic class needs two (or more) different repositories. How do I do that?. @michael-wolfenden \nThanks for that. I have seen @louthy do that, but didn't realise what he was doing until now.\nI just had a play, and came up with something that sort of simulates a view / view model / business logic / repository hierarchy, to make sure I got the overall picture correct.\nPlease can you have a look at the following code and see if it looks right. Any comments welcome. This is a complete sample, which you can paste into LinqPad and run...\nvoid Main() {\n  // Imagine this is a view, which creates a view model (possibly from a DI container).\n  MyViewModel mvm = new MyViewModel();\n  // Commands bound to controls on the view might call view model methods as follows...\n  mvm.RunGetFerretByID(1);\n  mvm.RunGetFerretByID(10);\n  mvm.RunGetFerretByID(-1);\n}\n\npublic class MyViewModel {\n  // This would probably be injected, not newed up\n  private FerretRepository _ferretRepository = new FerretRepository();\n\n  public void RunGetFerretByID(int id) {\n    MyBusinessLogic.GetFerretByID(id)\n      .Run(_ferretRepository)\n      .Match(\n        Some: x => Console.WriteLine(x),\n        None: () => Console.WriteLine(\"None\"),\n        Fail: ex => Console.WriteLine($\"Exception: {ex.Message}\")\n      );\n  }\n}\n\npublic static class MyBusinessLogic {\n  // Yes, in this case the business logic class isn't doing anything useful,\n  // but in a real scenario it might do more\n  public static Reader<FerretRepository, Option<Ferret>> GetFerretByID(int id) =>\n    from ferretRepo in ask<FerretRepository>()\n    select ferretRepo.GetFerretByID(id);\n}\n\npublic class FerretRepository {\n  private List<Ferret> _ferrets = new List<Ferret> {\n    new Ferret(1, \"Freddy\"),\n    new Ferret(2, \"Ferdina\"),\n    new Ferret(3, \"Frogface\"),\n  };\n\n  public Option<Ferret> GetFerretByID(int id) =>\n    id < 0 \n      ? throw new ArgumentException($\"{id} is not a valid value for a ferret ID\") \n      : _ferrets.FirstOrDefault(f => f.ID == id);\n}\n\npublic class Ferret {\n  public Ferret(int id, string name) {\n    ID = id;\n    Name = name;\n  }\n\n  public int ID { get; }\n  public string Name { get; }\n}\n\nThanks again.. ",
    "cage433": "Hi\nI can see that you're being consistent with Enumerable.Select, although\nI'm not certain that's a good thing.\nEnumerable.Range(0, 5) is fixed, no matter how often I compare it with\nList(0, 1, 2, 3, 4) it will be identical. Given that it came as a surprise\nthat the result of mapping over this range wasn't also constant. Clearly\nyour suggestion would work, but I'm not keen on having to remember to add a\nToList each time I map over an enumerable.\nLike yourself I have a massive bias in favour of immutablity, so I would\nchange your extension method IEnumerable.Map to return a Lst, rather\nthan IEnumerable - which as we see can change each time it's iterated\nover. If I really want the current behaviour I'd just call Select.\nBut that's just me - you've written a cracking library, so no hard feelings\nif you disagree with this very new to C# coder.\nbtw - I think there may be issues with your Task extension methods - I've\nseen both Map and Bind block (not every time). In particular you don't\nseem to be using Task.Unwrap in the latter case. When I get an hour I'll\nsee if I can come up with a minimal failing test and a PR\ncheers,\nAlex\nOn 23 February 2018 at 15:36, bender2k14 notifications@github.com wrote:\n\nAnother way to make this test pass is to change\nvar actual = Enumerable.Range(0, 5).Map(_ => NextValue());\nto\nvar actual = Enumerable.Range(0, 5).Map(_ => NextValue()).ToList();\nDo you prefer the solution in your PR more than what I have suggested? If\nso, why?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/374#issuecomment-368043109,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AADreUZAxZ2n-OPPPdB8kLv23HiJKbjYks5tXtrtgaJpZM4SPkVo\n.\n. The local variable is mutated - as I expect, however I was expecting the\ncalls to the lambda to only occur during construction, regardless of\nwhether it's created eagerly or lazily. I did however expect the resulting\nEnumerable to be immutable. Clearly that's not the case for Select,\nhowever I was expecting that to be the result for Map.\n\nInstead Enumerable.Range(0, 3).Map(_ => NextInt()) creates an Enumerable of\nfixed length 3, whose content changes every time you iterate over it.\nIt's this last fact which was surprising - at least to me. I get your point\nabout laziness, so my PR is clearly no good. However lazy evaluation\ndoesn't necessarily have to occur at the cost of immutablilty.\nIt's perhaps because I come from a Scala background, where it is a common\nidiom to use a local mutable variable when constructing an immutable\ncollection.\nSo using our example\n```\nvar foo =  Enumerable.Range(0, 3).Map(_ => NextInt())\nforeach (v in foo)\n   Console.WriteLine(v);\n\n1\n2\n3\nforeach (v in foo)\n   Console.WriteLine(v);\n4\n5\n6\n```\n\nUsing a similar idiom in scala returns a lazily evaluated, yet still\nimmutable collection\n```\nval foo = Stream.fill(3)(NextInt)\nval bar = Stream.fill(3)(NextInt)\nfoo.zip(bar).foreach(println)\n\n(1, 2)\n(3, 4)\n(5, 6)\n\nfoo.foreach(println)\n\n1\n3\n5\n\n```\ncheers,\nA\nOn 23 February 2018 at 16:36, bender2k14 notifications@github.com wrote:\n\nLike yourself I have a massive bias in favour of immutablity, so I would\nchange your extension method IEnumerable.Map to return a Lst, rather\nthan IEnumerable - which as we see can change each time it's iterated\nover.\nThis seems backwards to me. Your test fails because the local variable n\nis not mutated. Your desired behavior is that the local variable n is\nmutated.\nIf I really want the current behavior I'd just call Select.\nI think the point of this Map is retain the efficient lazy behavior of\nSelect while changing from database jargon to functional programming\njargon.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/374#issuecomment-368062565,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AADreS6n1sEa_64mCoiqk3eoZsq7jfEnks5tXukHgaJpZM4SPkVo\n.\n. I think the main thing with laziness is there is no construction.\n\nThat isn't exactly correct. It's perfectly possible for lazy data\nstructures to be immutable, constructed bit by bit whenever a new value in\nthat structure is called for. Haskell does this, and from the Scala Stream\nexample I showed you earlier you can see that does the same. Of course any\nsuch immutable structure needs to keep around the results of previous\ncalculations.\nIncidentally the more typical use of streams in Scala is exactly the same\nas the Enumerable.Range(0, inf) you mention - again laziness does not imply\nmutability. So here's an example of an infinite, lazily evaluated stream\nvar foo: Stream[Int] = NextInt() #:: foo.map(_ => NextInt())\nprintln(foo.take(4).mkString(\",\"))\n\n1, 2, 3, 4\nprintln(foo.take(4).mkString(\",\"))\n1, 2, 3, 4\n\nWhat you are describing is not the definition of laziness - it's just one\nparticular implementation. I was just surprised to see this choice in a\nlibrary a large part of whose focus is on immutability. I understand\nexactly what is going on, and I'm not claiming it's incorrect - I was just\nsurprised. However as I mentioned earlier maybe that's due to my background\nin other languages where laziness is treated differently.\ncheers,\nA\nOn 23 February 2018 at 23:39, Nick Darvey notifications@github.com wrote:\n\nhowever I was expecting the\ncalls to the lambda to only occur during construction, regardless of\nwhether it's created eagerly or lazily\nI think the main thing with laziness is there is no construction. That\nLINQ isn't constructing anything except for an expression of the\ncomputation you'd like to run.\n(Which is great because you can do things like Enumerable.Range(0, inf).)\nThis is less about having immutable data structure but having an immutable\ncomputation (LINQ query). Right now, your computation mutates every time\nit's executed.\nYou need to make sure you don't introduce any side effects into the\ncomputation if you want the same result every time it's executed.\nOtherwise, do the mutable computation once with the results going put into\na list (or into one of the System.Collections.Immutable data structures if\nthat's important).\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/louthy/language-ext/issues/374#issuecomment-368170865,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AADreY7MyZrsU2ALp-ldxW3fPBzNsQZLks5tX0xJgaJpZM4SPkVo\n.\n. Thanks - I've limited experience with C#. I'll close the associated issue. \n",
    "crodriguezvega": "\nIt is.\n\nThanks. Knowing that the intention is to make the type task-compatible is good enough for me for now.. @louthy Thanks for the answer, Paul, and sorry for this late reply. \nI tried using EitherAsync<L, R> as the return type of my functions, but then I could not get the code to compile if I wanted to use await inside the implementation of the method. I am getting the error \nThe return type of an async method must be void, Task, Task<T>, ValueTask<T> or another tasklike type. Is this expected behavior? I have tested this on version 2.2.18-beta.\nSo I fall back to using Task<Either<L, R>> as the return type and call ToAsync() on the functions that I want to chain using from...select syntax. This works fine with async...await functions.\nAmazing library, by the way.. @bender2k14 I am just trying to write some code like this:\npublic static async EitherAsync<string, int> Op1()\n{\n    return await Task.FromResult(1);\n}\n\nBut the compiler complains with The return type of an async method must be void, Task, Task<T>, ValueTask<T> or another tasklike type.. The statement await Task.FromResult(1) was just an example; it's not literally what I am trying to achieve in my case. :-)\nInside of method Op1 I would like to be able to await other asynchronous calls, like to a database or an http request. The results of those calls determine whether Op1 returns the L or the R values.. @bender2k14 In my case I am trying to do something like the following:\npublic async EitherAsync<string, User> GetUserAsync(int id)\n{\n   var user = await _userRepository.GetAsync(id);\n   return (user == null) ? \"Could not find user\" : user;\n}\n\nwhere _userRepository is a class member object to access a database.\nThere is for sure a better FP way of writing this code (similar to your example in the previous comment), but I am just curious to know if it is possible to await an asynchronous call inside a method that returns EitherAsync<L, R>.. @bender2k14 Thanks for the examples. I understand then that the EitherAsync<L, R> type is best used when the method does not await the task, but just returns it and somewhere higher up in the call stack it is awaited.\nIf you reply to the Stack Overflow question with a summary of what we discussed here, then I will happily accept it as answer.. ",
    "NightWatchman": "Hey thanks! That looks like what I need. I'll have to research BindAsync and see how it works.\nI thought I had gotten closer by trying this, but I had trouble because UpdateRequest and InsertRequest return a Task<Either<DataAccessException, String>> so it wouldn't return from that Map call because that call wanted a Task<string>, not a Task<Either<DataAccessException, String>>. I was also unsure of when to use Map and when to use MapAsync.\nC#\nreturn await DataAccessModule.Connect(connectionString).MapAsync(db =>\n        {\n          return RecordExists(db, request.FshApplicationKey).Map(exists =>\n          {\n            var result = exists\n                ? UpdateRequest(db, request)\n                : InsertRequest(db, request);\n            // return result; // What I wanted to do,\n            return \"\"; // Returning a string as an experiment got the code to compile.\n          });\n        }).ConfigureAwait(false);\n. @louthy Thanks for chiming in! My own research into bind vs map has enlightened me as to why I needed bind and not map in the previous construct and things are going pretty well for me. I hadn't thought about using EitherAsync so I'll probably start doing that. Your LINQ example is quite neat, and indeed easier to understand. I appreciate y'all taking the time to maintain this project and also to engage with it's users. I'm going to go ahead and close this \"issue\" since my understanding of these constructs is much more complete now.. Ah, good to know. Thanks!. Is this fix going to be packaged and released soon? If it's going to be a while, what's the workaround to using .ToAsync()?. Thanks for the info. I gave that a shot a little while ago, but I think I ran into an issue with the EitherData constructor being protected and inaccessible from my code. I need to revisit this to verify that was the issue or if it was something else, but it wasn't working for me because of something like that.\n. ",
    "thehoglet": "Ah! Thank you. I see where I went wrong now. I wasn't using the OrdArray in the library; I had copied and pasted the definition of OrdArray in the readme. \nAnd yes, changing the line in question to use OrdArr instead of OrdArray allows compilation. I should have looked more closely at the library source before launching into an issue.\n. I get the same error messages as @brotherbill when I try to build the source, as is, in Visual Studio. My VS is 2017 Enterprise 15.6.6 on Windows 10.\nWhen I run dotnet --info from a command prompt, the product version reported is 2.1.104.\nIf I replace the version specified in global.json with 2.1.104, and restart VS, language-ext builds without error. Also, simply deleting this file fixes the problem.\nI am new to Core, but my gut tells me this is unnecessary problem. Can someone explain in a sentence why it is necessary to enforce a particular version for this lib? I can't help wondering if there's some mechanism/policy, maybe similar to assembly version redirects, that fixes this on a particular system.\n. @louthy Thank you for this library. It's impressive.. \"Length\" is present as an artefact in some of the other units implementations also. Beware!\nAny idea if units of measure is going to be further developed? Is the system just an experiment? This morning, I implemented Force, Pressure, and Temperature for a project I'm working on. I included only the conversions I needed, though. It worked nicely and Units of Measure improved the API I'm working on. But, the experience informed me that implementing this for the entire universe of SI+conversions is a big job!\n. If desired, I can incorporate my implementations of Force, Pressure and Temperature plus one for Mass (plus unit tests) into language-ext and issue a pull request. Let me know.\n(In implementing a UoM for force, I omitted any mention of mass. I'm guessing the best return for the multiplication operator for the language-ext Accel type, if the LHS/RHS is mass, is a Force instance. Also, there seems to be a proposal to alter the SI definition of kelvin that will introduce a dependency on mass. One way or another the lib appears to need the mass SI base unit implemented.)\n. @bender2k14 Why ScaleTemp in addition to AbsTemp? A single Temperature type is desirable to me, but what is the correct behaviour here:\n```\nTemperature oneHundredCelsius = 100degC;\nTemperature oneHundredCelsiusinK = 373.15K;\nPrint(oneHundredCelsius == oneHundredCelsiusinK); // true\nTemperature twoHundredCelsius = 2 * oneHundredCelsius;\nPrint(twoHundredCelsius.Celsius); // Prints something like 846.3, not 200.0 ???\n```\nThe oneHundredCelsius instance has \"forgotten\" that it is a Celsius value, but the programmer has not. Is there a way around this? Provide an an alternative API to the * and / operators, as implemented here for instance?\n. If the lib goes with separate types for absolute and relative temperature, each is currently missing a converter, I think: ScaleTemp ToScale(); and AbsTemp ToAbsolute(); respectively.. Thanks. Seq() was the missing part I needed here. I read the version 2 release notes twice but still failed to appreciate the import of this bit:\nThe primary benefits are:\n...\n* If you construct a Seq with an IEnumerable then it maintains its laziness, but\n  also guarantees that each item in the original IEnumerable is only ever enumerated \n  once.\n...\nI guess a third reading is in order or else risk shooting myself in the other foot.\n. Thanks, @louthy . Done.. ",
    "embarrassedmilk": "Clear, thanks for detailed explanation and for your time! I'll have a closer look at Try then.. Update:\nAfter some time, I came to a slightly different setup. Would that be considered as a proper way to handle the use case or Validation is better?\n```csharp\n        public async Task Process()\n        {\n            var inputs = Enumerable.Range(0, 40);\n            var chunks = inputs.ChunkBy(10);\n            var failed = new List();\n        foreach (var chunk in chunks)\n        {\n            var eithers = await ProcessChunk(chunk);\n            var (lefts, rights) = eithers.Partition();\n            failed.AddRange(lefts);\n        }\n    }\n\n    private Task<IEnumerable<Either<int, Unit>>> ProcessChunk(IEnumerable<int> chunk)\n    {\n        Console.WriteLine($\"Processing new chunk\");\n        return chunk.Map(item => ProcessItemAdapter(item)).Sequence();\n    }\n\n    private async Task<Either<int, Unit>> ProcessItemAdapter(int id)\n    {\n        var res = await ProcessItem(id).Try();\n        return res.Match<Either<int,Unit>>(\n            Succ: _ => Right(Unit.Default),\n            Fail: _ => Left(id)\n        );\n    }\n\n```. @trbngr Thanks, that actually looks nice and clean! \ud83d\udc4d \nI'll close the issue.. ",
    "brotherbill": "\nOn Windows 10\nClone or download code.\n   Save file language-ext-master.zip\n   Extract code to language-ext-master directory\nOpen Visual Studio 2017 (with latest updates)\n   Drag language-ext.sln to Visual Studio\n   Run pack.bat\nBuild | Clean Solution\nError Messages\n\nCS0006 \n   Metadata file 'C:\\Users\\William\\Downloads\\language-ext-master\\language-ext-LanguageExt.Core\\bin\\Debug\\net451\\LanguageExt.Core.dll' could not be found\nThe current .NET SDK does not support targeting .NET Core 2.0.\n   Either target .NET Core 1.1 or lower, or use a version of the .NET SDK that supports .NET Core 2.0.\nThe current .NET SDK does not support targeting .NET Standard 2.0.\n   Either target .NET Core 1.6 or lower, or use a version of the .NET SDK that supports .NET Standard 2.0.\nThanks for tip about Semigroup.  It has been 40+ years since taking College Algebra, with rings, fields, groups, etc.  A Semigroup is a set with a binary operator and associativity.  Adding identity element gets you to a Monoid.. Reinstalled both.  No change.. ",
    "SilentLux": "As described in the test, in my mind, this would make sense that at least\nvar t = new OptionalResult<int>(1);\nvar u = Option<Result<int>>.Some(new Result<int>(1));\nt.Equals(u).Should().BeTrue();\n\nTo answer your question: \"Equal\" means \"a call the Equals method in this case returns true\", as they seem to be equivalent. They also could implement implicit conversion operators, for the same reason, I think.. Ok makes sense. In fact, my question was more like : if both types are semantically equivalent (am I right ?), is the fact that they both exist purely incidental (as we cannnot forbid Option> from being declared), and is there something that could be done about it ?\nNot so important in the end, I guess.. Yes, I read another discussion about their intermediate state in the meantime.  This solves the problem in fact. Thanks !. Hi Paul,\nThanks for the quick reply.\nI know about Either, and indeed it matches the behavior for queries, but I don't see how it matches for commands, as they're not supposed to return anything.\nFor instance:\n```\npublic void Save(Stuff stuff)\n{\n    // bla\n    SaveMethodThatCanThrow(stuff);\n}\n```\nis rewritten there as something like\npublic Result Save(Stuff stuff)\n{\n    try\n    {\n        // bla\n        SaveMethodThatCanThrow(stuff);\n        return Result.Ok();\n    }\n    catch(Exception e)\n    {\n        return Result.Fail(\"some msg\");\n    }\n}\nSo in this case, how could I use Either if I don't have anything to put on the right side ?\nI guess I could use Option, but this seems like bending its usage to something it's not designed for, and I feel that would hurt readability.. I agree with you that sticking with Either to do that doesn't smell really good.\nI didn't cover everything in the library yet, so I didn't know Try, but this looks promising for my use case. \nThanks!. Ok, I guess I have what I was looking for. This issue can be closed as far as I'm concerned.\nThanks to both of you :). Nice :) Thanks a lot!. Hi Paul, \nThanks for the answer. You're right, I should have specified that in this case I considered Either left value as an error one. In fact, I use it so much for this usage that I forgot (here only, fortunately) that it can be used another way (and the fact that the documentation states that Left cancels bindings and mappings, or is an \"early out, with a message\" comforted me in this idea).\nAnyway, I got your point (to be honest, I was even already nitpicking on \"why a Validation class?\" before I discovered the difference with Either, hence my question :) ). I can therefore definitely live without an Error class.\nClosing then.\nThanks again!\n. Thanks for your answer. I agree that we usually shouldn't have to provide the arguments, but can you expand a little bit on why it's not the same thing ?. Very nice, thanks a lot for the bunch of details.\n\nI can't imagine a situation where you'd ever have to explicitly type it, because the type-system can always infer it\n\nI thought about it in the meantime, and I agree with you, I don't think there is any use case where that would be mandatory.\nIn the end I won't push for a (useless) breaking change then :)\nThanks again!. ",
    "imranypatel": "Here is complete code:\n```\nusing System;\nusing static System.Console;\nusing static LanguageExt.Prelude;\nusing LanguageExt.Parsec;\nusing static LanguageExt.Parsec.Prim;\nusing static LanguageExt.Parsec.Char;\nnamespace FPLibsLanguageExtTests\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            LanguageExtParserTests.Test();\n            ReadKey();\n        }\n    }\npublic static class LanguageExtParserTests\n{\n    public static void Test()\n    {\n        var spaces = either(\n               eof,\n               many1(satisfy(System.Char.IsWhiteSpace)).Map(_ => unit)\n           );\n\n        Parser<A> token<A>(Parser<A> parserA) =>\n            from res in parserA\n            from spc in spaces\n            select res;\n\n        var word = from w in token(asString(many1(letter)))\n                   select new Word(w) as Term;\n\n        var number = from d in token(asString(many1(digit)))\n                     select new Number(Int32.Parse(d)) as Term;\n\n        var term = either(word, number);\n\n        var parser = from sp in spaces\n                     from ws in many1(term)\n                     select ws;\n\n        var result = parse(parser, \"   4 words are here\");\n        WriteLine(result.ToString());\n    }\n}\n\nabstract class Term { }\n\nclass Word : Term\n{\n    public readonly string Value;\n    public Word(string value) => Value = value;\n}\n\nclass Number : Term\n{\n    public readonly int Value;\n    public Number(int value) => Value = value;\n}\n\n}\n```\nTarget Framework: .Net 4.6.1\nLanguageExt.Core: v2.1.32\nLanguageExt.Parsec: v2.1.32\n. Recreated project again with target .NET Framework 4.6.1 and installed LanguageExt.Parsec with dependencices shown as:\nMicrosoft.CSharp.4.3.0 \nSystem.Reactive.Interfaces.3.1.1 \nSystem.Reactive.Core.3.1.1 \nSystem.Reactive.Linq.3.1.1 \nSystem.Reactive.Platform Services. 3.1.1 \nSystem.Reactive.Windows.Threading.3.1.1 \nSystem.Reactive.3.1.1 \nSystem.Value Tuple.4.4.0 \nLanguageExt.Core.2.1.32 \nLanguageExt.Parsec.2.1.32\nSame result. Any guess/clue/suggestion?\n. @louthy Thank you for elaborated response. \n(2.2.27-beta) has addressed the problem of misleading result of ParserResult.ToString().\nNot sure how significant it is but it was not clear how @bender2k14 attempt was a success with same versions of library and target framework as was mine.\nThank you again!\nP.S:\nI've just started using LanguageExt as one of the means to the end of reformed programmer!\nAm curious whether you've have seen my request on gitter on 6th April? Or should I post it again here?\nSome thoughts would help in increasing pace of learning.. @louthy Thank you for clearing it further.\nI'll be adding new issue on Free Monad usecase here as well to discuss it further while keeping your advice to starting with something simpler esp when developing basic intiuition.\nI admit that the level am at this stage where I find it bit challenging further transforming values from res1 in the following:\nvar res1 = parse(parser, \"   4 words are here\").ToEither(Error.New);\nI am able to tinkering like:\nvar res1a = res1.Match(Right: r => \"Success\", Left: l => \"Failed\");\nI can explore through debug/watch that:\nres1 = {Right(LanguageExt.SeqCons`1[FPLibsLanguageExtTester.Term])}\nRight = {LanguageExt.SeqCons<FPLibsLanguageExtTester.Term>}\nLanguageExt.SeqCons<FPLibsLanguageExtTester.Term> contains at:\n    [0] = {FPLibsLanguageExtTester.Number}\n[1] = {FPLibsLanguageExtTester.Word}\n[2] = {FPLibsLanguageExtTester.Word}\n[1] = {FPLibsLanguageExtTester.Word}\nBut finding bit challening getting access to values inside containers and map further based on actual types Number or Word subtypes of Term using Match. \nHopefully things get to next levels once intiuition is improved for transforming (i.e. mapping/filtering/reducing) output of library functions.\nWhile am digging through samples/docs, would appreciate more help to further transformations.\nThank you!\n. While giving it another read I've observed that some correction is needed in:\n\nValidateTerms because it is passed   with Seq<Term> whereas it is operating on Term level\nBoth ValidateWordTerm and ValidateNumberTerm because value of the parameters passed to it would be accessible through actual Value property so it has to be word.Value.Length and number.Value\n\n. @bender2k14 I find it quite reasonable to define simple domain specific language (DSL) to address recurring usecases. \nUsecase in question is one I come across often in business apps. I've handled this earlier in non-FP style.  Now trying the same in FP style.\nI want keep it to simple computations/expressions (sum/avg/count of lists, add, sub, mul, etc.) only and not to the level where complexity/structure of whole programming language needs to be addressed.\n. We don't need feature set (e.g. statements, control structures, etc.) of general purpose programming language but just simple expression parser and evaluator and json data (schema constrained) interpreter.\nI am thinking on writing in FP-style:\na. Expression Evaluator: Something similar to non-FP like evaluator of expression in string using combinators in LanguageExt-Parsec \nb. Specs Interpreter: Interpreter of Specfication of action of various Types (as specified e.g. Compute, Print, etc.) that will produce output (as described in output data) using (a.) Expression Evaluator to compute expression\nIt is recurrent usecase where user is provided with ability to declaratively specify expressions to compute more values (as descibed in output data) using values (as described in source data) already available and then use these source and computed values in reports/views/mail merge templates/etc.\nHope it makes some sense.\n. Here we go. I do appreciate your elaborated response. It really helps. \nLet me digest to take it further.\nThank you very much.. Thank you. \nresult/2/3 will remain in the context of Either so when, finally one needs to extract result value and output it to e.g. error log if it is Left (or error) or save it to e.g. db if it is Right (or success), then what alternative ways would you suggest to choose from?\n. Here I have put something concrete:\n```\nusing LanguageExt;\nusing static LanguageExt.Prelude;\nusing Newtonsoft.Json.Linq;\nusing System;\nnamespace FPLibsLanguageExtTester\n{\n    public class MessageResult\n    {\n        public JObject Value  {get; set;}\n    public MessageResult (JObject x)\n    {\n        Value = x;\n    }\n}\n\nclass LanguageExtIssue410\n{\n    static Either<string, string> GetTestMessageType(JObject msg) => Right((string)msg.SelectToken(\"Type\"));\n    static Func<JObject, MessageResult> HandleGetAuthors = (JObject x) => new MessageResult(x);\n\n    static Either<string, Func<JObject, MessageResult>> GetTestHandler(string type)\n    {\n        if (type == \"GET_AUTHORS\")\n            return Right(HandleGetAuthors);\n\n        // more types ...\n        else\n            return Left($\"Invalid Message type {type}\");\n    }\n\n    static string TestMessageResultError(string err) => $\"Error: {err}\";\n\n    static Either<string, MessageResult> HandleTestMessage(JObject msg) => match(\n        from type in GetTestMessageType(msg)\n        from handler in GetTestHandler(type)\n        select handler,\n        Left: er => Left<string, MessageResult>(TestMessageResultError(er)),\n        Right: handle => handle(msg)\n    );\n\n    static void CallsHandleTestMessage(JObject msg) => match(\n        HandleTestMessage(msg),\n        Left: Log,\n        Right: SaveToDb\n    );\n\n    static Unit Log(string error) {\n        Console.WriteLine(error);\n        return unit;\n    }\n\n    static Unit SaveToDb(MessageResult result)\n    {\n        var type = (string)result.Value.SelectToken(\"Type\");\n        Console.WriteLine($\"Success: Result of message {type} is saved to DB\");\n        return unit;\n    }\n\n    public static void Test()\n    {\n        // Valid Message Type\n        CallsHandleTestMessage(JObject.Parse(@\"{\"\"Type\"\": \"\"GET_AUTHORS\"\"}\"));\n\n        // Invalid Message Type\n        CallsHandleTestMessage(JObject.Parse(@\"{\"\"Type\"\": \"\"GET_XXXX\"\"}\"));\n\n    }\n}\n\n}\n```\nSo is this one of the ways to handle final Left(error) or Right(success) result?\n. Thank you.\nWorth mentioning that attempt to code GetTestHandler in expression oriented style as following was not success:\nstatic Either<string, Func<JObject, MessageResult>> GetTestHandlerExp(string type) =>\n            (type == \"GET_AUTHORS\")\n            ? Right(HandleGetAuthors)\n            Left($\"Invalid Message type {type}\");\nNot compiling with error: \n\nType of conditional expression cannot be determined because there is no implicit conversion...\n\nExplicit casting would be the solution but couldn't figure out one so got away with if...then...else statement instead of expression style.\n. @bender2k14  Thank you.\nJust for completeness and documentation for beginners like myself, based on your response, here is the revised version in expression style:\nstatic Either<string, Func<JObject, MessageResult>> GetTestHandler(string type) =>\n            (type == \"GET_AUTHORS\")\n            ? Right(HandleGetAuthors)\n            : Left($\"Invalid Message type {type}\").Bind<Func<JObject, MessageResult>>()\n. ",
    "flcdrg": "I'm ok to fork for now - it's probably just the net451 => net45 as @bender2k14 mentioned.\nI wondered if you'd chosen net451 for specific framework changes that aren't in net45?. ",
    "YTsalko": "I don't what to damage repo tests structure, so I'm not sure where to put this test. To EitherAsyncTests or create new file?. added test. done. Thanks.. ",
    "nojaf": "Yes, but I'd like this behavior out of the box. I'd implement it via combination indeed.. No, I still want to pass a mapping function.. Mixed feelings about going to ToEitherAsync because the .ToEither(\"Nothing was inputted\") has no need for anything Async. But it is getting nitpicking at this point. \ncsharp\n        public static EitherAsync<A, C> MapAsync<A, B, C>(this Either<A,B> either, Func<B,Task<C>> mapFn)\n        {\n            return either.ToAsync().MapAsync(mapFn);\n        }\nI rather go to Async only when the code requires it.\nFeel free to close this as it might be to opinionated.. ",
    "lucasteles": "@louthy  HKT and the dotnet/csharplang#164  Shape/Type Classes/Concepts on C# can be a game change in the world of programming languages . @louthy  Makes sense, \nBy the way, i liked the Idea off using the \u2019>\u2019 e \u2019>=\u2019 operators for simulate fsharp \u2019|>\u2019 \nDid we have something like it? . ",
    "michael-wolfenden": "Thanks for the response @louthy, I suspected as much. I will close out the issue.\nOn another note, I just wanted to say thank-you for the work you have done on this project. It has made my life \ud83d\udcaf easier.. Thanks for your response.\nTo clarify, the example was trying to demonstrate what you were alluding to, the ability to seperate out various free monads but still have the ability to combine them into a single program.\nSo instead of having a single free monad for all the IO in my domain, I could have seperate ones FreeUI and FreeAuthentication but still have the ability to compose them together into a single program (like the nested free monad you alluded to)\ncsharp\nfrom uid in UI.ask(\"What's your user ID?\")\nfrom pwd in UI.ask(\"Password, please.\")\nlet user = Authentication.Login(uid, pwd)\n. I believe the example was something like\n```csharp\nstatic Func> ShouldBeOfLength(int n) => s =>\n    s.Length == n\n        ? Success(s)\n        : Fail(Error.New(($\"{s} should be of length {n}\")));\nstatic Func> ShouldBeLowerCase => s =>\n    s == s.ToLower()\n        ? Success(s)\n        : Fail(Error.New($\"{s} should be lower case\"));\npublic class Error : NewType\n{\n    public Error(string value) : base(value) { }\n}\n```\nIf I'm undertstanding you correctly you can do the following\n```csharp\nvar test = \"USA\";\n(ShouldBeLowerCase(test) | ShouldBeOfLength(2)(test))\n    .Apply(value => value)\n    .Match(\n        Succ: ... // Action\n        Fail: ... // Action>\n    );\n```\nOr\n```csharp\nvar test = \"USA\";\nList(ShouldBeLowerCase, ShouldBeOfLength(2))\n    .Map(validator => validator(test))\n     // this returns a validation that you can match on\n    .Sequence()\n    .Match(Succ: ..., Fail: ...)\n```\nYou can also convert the resulting Validation to an Either\n```csharp\nvar test = \"USA\";\nList(ShouldBeLowerCase, ShouldBeOfLength(2))\n    .Map(validator => validator(test))\n    .Sequence()\n    .ToEither()\n    .Match(Right: ..., Left: ...)\n```\nYou can find more examples at https://github.com/louthy/language-ext/blob/master/LanguageExt.Tests/ValidationTests.cs\nHappy to know if there's a better way though. The following code appears to be working correctly\ncsharp\nvar people = Map((1, \"Rod\"), (2, \"Jane\"), (3, \"Freddy\"));\nOption<string> result = find(people, 1);`\nIf you run the following gistlyn you should see Some(Rod) printed to the console.\nHave you imported the correct namespaces?\n. The are three main ramifications\n1) Strong naming is a breaking change\n2) A strong named assembly can only reference other strong named assemblies\n3) A strong-named assembly reference must exactly match the version referenced by an assembly. So if I have a reference to myAssembly 1.2.0 and import a package that references myAssembly 1.2.3 a binding redirect will need to be configured.\nNOTE: This issue is isolated to the .NET Framework. .NET Core, Xamarin, UWP, and most other .NET implementations don't have strict assembly loading and removes the main downside of strong naming.\n\nxml\n<configuration>\n   <runtime>\n      <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n         <dependentAssembly>\n            <assemblyIdentity name=\"myAssembly\" publicKeyToken=\"32ab4ba45e0a69a1\" culture=\"neutral\" />\n            <bindingRedirect oldVersion=\"1.0.0.0\" newVersion=\"1.2.3\"/>\n         </dependentAssembly>\n      </assemblyBinding>\n   </runtime>\n</configuration>\nIn regards to LanguageExt.Core this means\n1) A new major version 4.0.0 will need to be published\n2) This library doesn't appear to reference any non  strongly named assemblies so this doesn't affect you.\n3) There are two options\n- Do nothing: The chance that a library or application are dependening on multiple versions of LanguageExt.Core are low, and if there are assembly version mismatches a binding redirect can be added (which visual studio does automatically these days). Also note this only affects .NET Framework.\n\nDo what Newtonsoft.Json and larger libraries do and pin the assembly major version. This way LanguageExt.Core 1.2.0 and LanguageExt.Core 1.2.3 both have an AssemblyVersion of 1.0.0.0 and the highest nupkg version will be used.  So LanguageExt.Core.1.2.3.nupkg would have\n\nxml\n<AssemblyVersion>1.0.0.0</AssemblyVersion>\n<FileVersion>1.2.3.0</FileVersion>\n<AssemblyInformationalVersion>1.2.3.0</AssemblyInformationalVersion>\nWhat's involved? Is there an ongoing cost?\nAll you need to do is check Sign the assembly and create a new strong name key file\n\n1) Do not give it a password\n2) Make sure it's checked into source so that anyone can compile the project\nFrom then on, your built assembly will be strongly named\nMore information can be found here. The Reader Monad is commonly used to thread configuration through application code to call sites that depend on it. It offers a form of dependency injection.\nImagine you have a UserRepository used by a number of methods. In typical c# code, you either need to pass the UserRepository to each method or use an IoC container to inject the dependency wherever it's needed.\nThe reader monad allows you to compose methods that require a UserRepository (or any dependency) without explicitly passing this dependency around.\nFor example\n```csharp\npublic class User\n{\n    public User(int id, string name)\n    {\n        Id = id;\n        Name = name;\n    }\npublic int Id { get; }\npublic string Name { get; }\n\n}\npublic class UserRepository\n{\n    public User GetById(int id) => new User(1, \"Bruce Wayne\");\n    public User GetByName(string name) => new User(2, \"Peter Parker\");\n}\npublic Reader GetUserByName(string name) =>\n    from env in ask()\n    select env.GetByName(name);\npublic Reader GetUserById(int id) =>\n    from env in ask()\n    select env.GetById(id);\npublic Reader GetUserAandBoss() =>\n    from user in GetUserByName(\"some_name\")\n    from boss in GetUserById(user.Id)\n    select $\"user:{user.Name}, boss:{boss.Name}\";\n```\nNotice that GetUserById and GetUserByName use UserRepository by ask'ing for it but without having to have it explicitly passed to them. Also note GetUserAandBoss is able to compose methods returning readers. Notice also that Reader has two generic types Env and A. Env is always fixed (in our case as UserRepository), but the type of A can change, the A in GetUserAandBoss isstring but the A in GetUserByName and GetUserById is User.\nTo actually execute, you need to call run passing in the dependency that will now be threaded throughout the composed chain and then matching on the result.\ncsharp\nGetUserAandBoss()\n    .Run(userRepository)\n    .Match(x => Console.WriteLine(x), () => Console.WriteLine(\"Fail\"));\n    // outputs => user:Peter Parker, boss:Bruce Wayne\nSo to sum up, Reader is typically used for dependency injection (as shown in https://github.com/louthy/language-ext/issues/515) or configuration. You have a Configuration object with a bunch a settings that the methods throughout your code base need to access, but you don't want to have to explicitly pass Configuration throughout your application. Instead you have a Reader<Configuration, A> and then at the entry point of you application, you load your Configuration from somewhere and call Run.\nHaving said also this, I'm new to all this myself and am happy to be corrected.. > 1. What does the ask() function actually do? I've looked at the signature and the code, but can't work it out.\nI'll try to explain it as I understand it, however forgive me as my terminology might not be 100% correct.\nLets start with this example\n```csharp\npublic class Configuration\n{\n    public string Url { get; }\n    public Configuration(string url) => Url = url;\n}\npublic Reader UppercaseUrl() =>\n    from config in ask()\n    select config.Url.ToUpper();\n```\nStarting from the top Reader<Env, A> is defined as a delegate.\ncsharp\npublic delegate(A Value, bool IsFaulted) Reader<Env, A>(Env env);\nSince Reader is a delegate, our UppercaseUrl function which returns a Reader<Configuration, string> can actually be written without using ask.\nIt just needs to return a function that takes a Env and returns a (A Value, bool IsFaulted).\nIn the case of UppercaseUrl, Env is Configuraion and A is string.\nSo\ncsharp\npublic Reader<Configuration, string> UppercaseUrl() =>\n    from config in ask<Configuration>()\n    select config.Url.ToUpper();\ncan actually be written as\ncsharp\npublic Reader<Configuraion, string> UppercaseUrlWithoutAsk()\n    => config\n    => (config.Url.ToUpper(), false);\nbut in my opinion, the ask syntax looks nicer.\nBut how is ask defined?\nWell looking at \ncsharp\npublic Reader<Configuration, string> UppercaseUrl() =>\n    from config in ask<Configuration>()\n    select config.Url.ToUpper();\nWe know two things about ask.\nFirstly, the thing that ask is returning must be a Reader<Configuration, ?> as the query syntax from reader only works if the Env is fixed and the type of monad is the same (Reader).\nSecondly, we know the A is of type Configuration because when you write from a in Reader<Env, A>, a will be of type A.\nSo ask is our case must have the type signature\ncsharp\npublic Reader<Configuration, Configuration> Ask()\nor more generically\ncsharp\npublic Reader<Env, Env> Ask()\nand for its implemenation, as above, it needs to return a function that takes a Env and returns a (Env Value, bool IsFaulted)\nSo the definition must be\ncsharp\npublic Reader<Env, Env> Ask()\n    => env\n    => (env, false);\nYou can see the formal definition https://github.com/louthy/language-ext/blob/49bc1dd7baa80ea8ad8cde7d0359f5c906dcaeb6/LanguageExt.Core/ClassInstances/Monad/MReader.cs#L43\n\n\nThe Match() function takes two parameters, the first is an Action on the result, which I understand, but the second looks like it gets called if something went wrong. What would go wrong? Obviously an exception would trigger this being called, but anything else?\nFollowing on from the previous question (and so might be answered by the answer to that), the second parameter passed to Match() doesn't contain any information about what went wrong, so seems a bit useless. It looks like you can't actually get at the exception details. Again, this question may just be be me not understanding its use.\n\n\nI'm with you, I found the Match() to be confusing as well, perhaps @louthy can shed some light\n. Sure, if your only ever calling a single method with your dependency then there is no advantage, however consider a typical application where FerretRepository is probably called from a 100 different places within your application.\nYou could choose to pass this dependency (state) around to each point in the application that its needed and infect every method signature, or use the Reader monad and pass the dependency once at the entry point of the application.. If you look at the original example, none of the methods GetUserAndBoss, GetUserById and GetUserByName require the repository. The only time a repository is involved in at the entry point of the application when run is called.\nIf you try to rewrite this as in your ferret example, each of these three methods would need the repository passed. The biggest smell being that GetUserAndBoss needs a repository passed to it that it doesn't use. It's just needs it to transparently pass to the other two methods it calls. This is the problem that the reader monad attempts to solve.. > What if I want to pass in more than one dependency? Let's say my business logic class needs two (or more) different repositories. How do I do that?\nYou could create a class World that had a UserRepository and a OrderRepository property, the call .Run(new World(userRepository, orderRepository)). ",
    "mattfurness": "Thank you for the super quick reply @louthy \ud83d\ude04 \nRegarding your comment on precluding the use of the namespace:\n- Fortunately we don't need to import LanguageExt in the file in question, so it wouldn't be an issue in this specific case.\n- If I had needed to import the LanguageExt namespace and the tests started failing in the way they did it would have been much more obvious. It was the implicitness that caught me out.\nRegarding the version of Select in the existing project, I'll try to describe it succinctly:\n- The function / method signature was similar to Task<CurProjResult<S>> Select<T, S>(this Task<CurProjResult<T>> task, Func<T, S> func). The implementation checks that the wrapped CurProjResult is Succeeded before calling func. Note CurProjResult  is a silly made up type name.\n- I was a little surprised that the existing function above wasn't the function called considering it appears to be \"more specific\" but the TaskExtensions function was chosen instead.\nAs you mentioned in your previous comment, I think moving it into the LanguageExt namespace is the right move, even though it is a breaking change, simply out of explicitness. \nThanks again!\n. No worries, thanks for responding so quickly \ud83d\ude04 . ",
    "bentefay": "I can provide a bit more detail (I work with @mattfurness).\nWe have an extension method that transforms the value of a Company.Result inside of a Task:\nC#\nnamespace Company { \n    public static class Extensions {\n        public static Task<Company.Result<S>> Select<T, S>(this Task<Company.Result<T>> task, Func<T, S> func);\n    }\n}\nWhen it comes to extension method overload resolution, if the target method is ambiguous (as it is in this case between Language Ext's Select method and ours), the method in the shallower namespace wins. Because the global namespace is shallower than our Company namespace, the Language Exts' Select method wins. If we put our extension method into the global namespace, the compiler can no longer disambiguate the methods and raises an error: The call is ambiguous between the following methods.\nLong story short, by putting public static async Task<U> Select<T, U>(this Task<T> self, Func<T, U> map) in the global namespace, it becomes impossible for consumers of Language Ext to write a Select extension method on a Task of something more specific than T. \n. ",
    "Zordid": "Sounds perfect! @trbngr, you were right - it's class Error : NewType<Error, string>.\nYour solutions look promising - but I really ask myself why there isn't a simple overload of Try.ToValidation that takes a func to transform the Exception to an arbitrary Error object...\nThanks!. Thanks for your replies - one easy answer to my question was right in front of me and I just didn't see it.\nMy code compiles fine like this:\n{\n    var errors = validators\n        .Map(validate => validate(t))\n        .Bind(v => v.Match(Fail: errs=>Some(errs.Head), Succ: _ => None))\n        .ToList();\n    return errors.Count == 0\n        ? Success<Error, T>(t)\n        : errors.ToSeq();\n};\n\nApparently, I do not need the Fail method that lifts a single Error to a Validation.Fail with a sequence of errors containing only this single error. Just supplying the sequence uses automatic conversion to a Validation.Fail!. ",
    "afifmohammed": "The monadic types you have quoted are pure computations hence don\u2019t produce side effects when composed. We are saying the same thing using different terminology.\n. When the Try delegate is wrapping a network call, the current Bind implementation will result in an interaction with the outside world. So is it correct to state in that given scenario its not Pure any more?\nSo what are the next steps here? . > My understanding of Monadic composition is that it does not produce effects as a result of the composition.\nBTW when I say that I literally mean Bind invocations should not result in interactions with the outside world.. My issue is not about how any function in C# can technically be impure hence bind is impure. \nIn the case of composing Try\u2019s, given Try is a lazy construct, does the composition warrant strict evaluation? \nMy comments around bind producing side effects (calls to the outside world) is based of my (work in progress) understanding that a Try monad exists to wrap an impure operation. . This is how I had modified it to ensure the laziness is intact.\npublic static Try<B> Bind<A, B>(this Try<A> self, Func<A, Try<B>> binder) => () =>  \n  self.Try().Match(\n    Succ: a => binder(a).Try(), \n    Fail: e => new Result<B>(e));\nAlso the SelectMany extension that enables the LINQ style composition (current implementation included below for reference) has the same issue of strict evaluation. \npublic static Try<C> SelectMany<A, B, C>(\n  this Try<A> self,\n  Func<A, Try<B>> bind,\n  Func<A, B, C> project) =>\n    MTry<A>.Inst.Bind<MTry<C>, Try<C>, C>(self, a =>\n      MTry<B>.Inst.Bind<MTry<C>, Try<C>, C>(bind(a), b =>\n        MTry<C>.Inst.Return(project(a, b))));\nI modified it to be the following to keep the laziness intact.\npublic static Try<C> SelectMany<A, B, C>(\n  this Try<A> self,\n  Func<A, Try<B>> bind,\n  Func<A, B, C> project) => () =>\n    self.Try().Match(\n      Succ: a => bind(a).Try().Match(\n        Succ: b => project(a, b), \n        Fail: ex => new Result<C>(ex)),\n     Fail: ex => new Result<C>(ex));\nBeyond that I am not aware if I have missed something around conventions in the library around how to build implementations from underlying functions.. Looking through Try Extensions there a few other functions in that class that take a Try for input and return a Try and are strict in evaluation. @louthy would you consider changing them all to preserve the laziness?. I don't understand the MTry<A>.Inst.Bind completely given it returns an MB abstraction. Haven't dug enough in the library to follow the Generic abstractions. . ",
    "simonmckenzie": "Sure!. Does this look ok to you, @bender2k14?. Done. Note that I have observed two tests which fail intermittently, but they're not related to my changes.\ncsharp\nOptionAsyncTests.Issue206()\nMemoTests.MemoTest3(). ",
    "dgreene1": "Thanks everyone for the input, especially this comment:\n\u201cIt's relatively natural to think of an Option as a collection of zero or one items.\u201d\nYes, that makes sense. I don\u2019t like that it exposes .First which is essentially .Value, but at the end of the day the responsibility for writing safe code lies in the shoulders of the developer. Someday (hopefully soon) we\u2019ll have reference types that default to non-nullable just like TypeScript, Swift, and Kotlin provide.\nUntil that day, Optional will help us get most of the way there.\nThank you everyone for your contributions! :). ",
    "slimshader": "@bender2k14 Ah I see what you mean, my understanding of wording was that it had to be explicitly field-backed. >  var list = List(enumerable);\nI tried and there seem to not be List() overload for IEnumerable, I only found toLst(). @bender2k14 \nWell, my understanding is that F# discriminated unions / sum types are derivatives of common base classes in C#, this allows for pattern matching witch if is / switch in C#7 link\nso where in F# there is:\ntype OneThroughThree = | One | Two | Three\nin my code:\n```\npublic abstract class OneThroughThree\n    {\n      public static readonly One One = new One();\n      public static readonly Two Two = new Two();\n      public static readonly Three Three = new Three();\n  public static readonly OneThroughThree[] Values = new OneThroughThree[] { One, Two, Three };\n\n  protected OneThroughThree() { }\n}\n\npublic class One : OneThroughThree { }\npublic class Two : OneThroughThree { }\npublic class Three : OneThroughThree { }\n\n```\nso later you can:\n// where row is of type OneThroughThree\nswitch (row)\n{\n  case One _:\n  case Two _:\n ...\n}\n. I am asking for a review for all of it ;) Original code is only 179 lines of F# code, my C#/LangExt version is 3 times this much but most of it is actually syntactic noise like \"{}\" and explicit class ctors. Both code gists (original and mine) are fully working console-based Tic-Tac-Toe games so it can be built and run.. I know of visitor pattern and use it in OO code but I really wanted to go FP port here, sum types, pattern matching and all. Do you have any other insights into my version of original code? Maybe you'd implement TTT game using LangExt in a very different way? Would love to get some feedback.. Not claiming it is contrary (in fact it is a sum-type link) but visitor pattern is based on virtual methods, double-dispach and generally a OO solution while FP's go-to solution for sum types is via pattern matching. Since I am doing this for learning purposes that is the way I took here.. @bender2k14 while I get that C#'s pattern matching isn't the same as say F#'s, it does come from FP land. The idea is to match the actual type of an object and operate on that data. On that note I just rewrote this part of my code:\n```\n        switch (outcome(newBoard))\n        {\n          case Winner winner:\n            Console.WriteLine($\"{winner.Letters} wins!!\");\n            Console.WriteLine(render(newBoard));\n            break;\n      case Draw _:\n        Console.WriteLine(\"It is a draw!\");\n        break;\n\n      case NoneYet _:\n        playIo(GameState(newBoard, otherPlayer(gameState.WhoseTurn)));\n        break;\n    }\n\n```\nto:\noutcome(newBoard).Match(\n          winner: letter =>\n          {\n            Console.WriteLine($\"{letter} wins!!\");\n            Console.WriteLine(render(newBoard));\n          },\n          draw: () =>\n          {\n            Console.WriteLine(\"It is a draw!\");\n          },\n          noneYet: () =>\n          {\n            playIo(GameState(newBoard, otherPlayer(gameState.WhoseTurn)));\n          });\nas described in the visitor pattern / sum type article I linked earlier. While it is not looking as FPish, it has a very nice property: it enforces exhaustive matching by requiring to pass all 3 Func<> arguments.\nWhich approach do you think is better?\nAlso, what about rest of the code?!?! ;). Ah, ternary version looks good indeed, thanks. My version with virtual Match<> method is based on Mark Seemann's article, additionally to forcing match exhaustion it also has a property of being an expression if needed as Match() may return value as well. Why do you think this approach is limited?\nIs there anything else you think could be improved in this implementation? What other tools are there in LangExt to make it better. For example, I feel like this part of the code needs improving:\npublic static Option<Position> parseMove(string str)\n      {\n        var tokens = str.Split(' ');\n        if (tokens.Length == 2)\n        {\n          return from row in parseOneThroughThree(tokens[0])\n                 from col in parseOneThroughThree(tokens[1])\n                 select Position(col, row);\n        }\n        return None;\n      }\n. @louthy thanks for awesome answers, your arguments make sense to me, more functional version of parseMove() looks great and if I understand correctly, now also handles null case for input str.\nMark Seemann isn't that bad ;)) Indeed he was against going full FP in C# but only for the reason of the code being too different from \"classic\" C# especially when working with programmers that do not know FP techniques. He is not against DI in OO code, in fact he is about to release next edition of his book on the topic, indeed he blogged tho that DI is not needed (DI rejection) in pure FP code. I do understand your general sentiment about blindly following \"gurus\".\nThing is he does blog about FP in C# and there isn't much to find on the topic. To be honest for last 5 days I am googling for ANYTHING on LangExt to learn it and it is no picnic ;)\nMore specific questions then:\nlink and link deal with input parsing and validation. I feel like Validation<> would be of use here, could you help me here?\nThis code does not use IO monad for Console <-> user interaction. Is there something in LangExt I could use to fix that?\n@bender2k14 examples from my code pretty please :)\n. @Richiban Looking for a equivalent of this. @Richiban Yup, smart enum / type safe enum idiom (+ C7 PM) is what I currently do also but it seems that solution along the lines of OneOf + some IL emitting magic (as in Record) could help with boilerplate and safety?. @louthy While the definition of delegate obviously clarifies everything and renders the concept of documentation obsolete, as a a newcomer to I'd still appreciate one ;P\nThanks a lot for pointing me to examples, will study them in detail but in my defense, I did look for StateTests and ReaderTests in the Test folder.. Confirmed when upgrading to latest version. When preparing this test code I was actually trying to reproduce minimal version of the problem in larger code-base. While I've made a bug with Record here, I realized (after your replies) that in my original code my variants didn't derive from Record<> at all.\nStill, the main reason I posted the issue was Map vs Lst comparison. I wrongly assumed it was related to polymorphic member in Record. My case is that I had a Lst of Records that was updated in similar fashion to my example (Army is now Dead), in the view layer new model was compared against old model to potentially refresh the view (a'la model-view-update). When using Lst change was detected but when I switched to Map, it no longer shows difference between old and updated model.. ",
    "slang25": "It might be worth looking at an approach like this: https://github.com/Galad/CSharpDiscriminatedUnion\nYou could have a class that's defined like above, but it would generate the code in memory to add stuff like ToString and Match. It's also generated as part of a design time build, meaning those methods would show up immediately for use (if that makes sense, a little like type providers from F#).. Read here for more info on how this works: https://github.com/AArnott/CodeGeneration.Roslyn. ",
    "colethecoder": "Normally XUnit recognises IEnumerable and runs some different logic to ensure it compares the content of the collection rather than checking reference equality (the difference between .Equals and .SequenceEqual if you were doing it manually).\nOption implements IEnumerable so it seems like it should work but XUnit first checks for IEquatable which Option also implements (https://github.com/xunit/assert.xunit/blob/db11c08977f1ecf9b868317073d4255560547c45/Sdk/AssertEqualityComparer.cs#L130) and as a result runs LanguageExt's equality logic which ultimately runs .Equals \n against the collections and the test fails.\nTo work around it you can do a match and then use Assert.Equal on the inner value like:\n```csharp\nOption> i = new List { 1, 2, 3 };\nIEnumerable j = new List { 1, 2, 3 };\ni.Match(\n    Some: x => Assert.Equal(j, x),\n    None: () => Assert.Fail(\"Should never get here\")\n)\n```\nI've started writing some XUnit helpers to simplify this here: https://github.com/colethecoder/ExtUnit this allows you to do:\n```csharp\nOption> i = new List { 1, 2, 3 };\nIEnumerable j = new List { 1, 2, 3 };\nAssert.Some(j, i);\n```\n. In C# a double divided by zero is Infinity, so you wouldn't get any exceptions, it's nothing to do with LanguageExt's Try.\nIf you go back to your original function n => 1 / n you should see the exceptions.\nYou can also avoid the ToEither bit in the example as there are extensions to support IEnumerable> so you can simply do:\ncsharp\nIEnumerable<Try<int>> result = Range(0, 10)\n                .Map(n => Try(() => 1 / n));\nIEnumerable<int> r1 = result.Succs();\nIEnumerable<Exception> r2 = result.Fails();. It looks like .Net Framework is doing the same as the LangExt code was doing:\n```csharp\n        public static IEnumerable Concat(this IEnumerable first, IEnumerable second) {\n            if (first == null) throw Error.ArgumentNull(\"first\");\n            if (second == null) throw Error.ArgumentNull(\"second\");\n            return ConcatIterator(first, second);\n        }\n    static IEnumerable<TSource> ConcatIterator<TSource>(IEnumerable<TSource> first, IEnumerable<TSource> second) {\n        foreach (TSource element in first) yield return element;\n        foreach (TSource element in second) yield return element;\n    }\n\n```\nhttps://github.com/Microsoft/referencesource/blob/60a4f8b853f60a424e36c7bf60f9b5b5f1973ed1/System.Core/System/Linq/Enumerable.cs#L800\n.Net Core has a load of optimisations:\nhttps://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Concat.cs\n. I've just tried your sample with the latest nuget package and I found this line throws an InvalidCastException:\ncs\nvar eq = a1 == a2;\nbut I believe this is because you have:\ncs\nclass Dead : Record<Idle>, ArmyState\nwhich I think should be:\ncs\nclass Dead : Record<Dead>, ArmyState\nAdjusting that I then get:\ncs\nvar mapEq = m1 == m2;               // No Exception, true\nvar eq = a1 == a2;                  // No Exception, false\nvar lstEq = \n    m1.Freeze() == m2.Freeze();     // No Exception, false\nSo map equality is a bit weird but the rest seems to be as you would expect.\nEdit: Map is only comparing keys which I assume is because the value type doesn't have to be equatable. ",
    "tassi-yuzukko": "thanks @colethecoder .\nI understood this problem depends on XUnit.\nYour solution seems great, thank you !. ",
    "TonyHernandezAtMS": "Thanks! Can you explain what you mean by \"global\" fields? I've been struggling with how to handle connections, clients, telemetry, etc.. @louthy Can you tag this as documentation? So good!. ",
    "Protiguous": "Ah! I see. Thanks.. ",
    "dknowles": "@louthy I just want to say how impressed and grateful I am that you put so much time and effort into answering questions and providing insight into a lot of this stuff. I follow everything with interest even though I'm only lurking for the most part.\nCheers. ",
    "andyigreg": "I use it to refer to any logic that encodes business rules. As opposed to logic that is used to construct a framework, or logic that is used for integrations, for example. My main use of fp is for encoding the rules of a system as imposed by business requirements. At the moment the 'superstructure' of the application is still based around DI, and integrations are achieved by following the api you are provided with and those api's are imperative and often OO.\nI don't know if that is how other people use the term.\n. Maybe I should rephrase the question to avoid any terminology issues. \nHow do we push impure functions to the extremities of an application when parts of the code in the application requires intermediate data, such that you end up with a sandwich structure such as impure-pure-impure-pure-impure? How do we avoid this structure?. > > ...any logic that encodes business rules.\n\nI don't know a good definition for \"business rule\" either.\n\nI don't know a good definition for lots of things. It doesn't stop me recognising them when I see them!! But I think the terminology is entirely beside the point.\n. I mean a situation such as a web request. The request entry point must be impure because it encodes all subsequent behaviours both pure and impure. Let's say within that entry point we take data input (impure), and then process that data in some way (pure), use the result of the process to look up some intermediate data (impure), then calculate the final values and construct a model say (pure), then write some values from that model back to the db and output them to the web page (impure). How do we push all the impure parts of that chain to the extremities?. Wow! Thankyou so much. I\u2019ll have to read that a few more times before it fully sinks in. Mid flight io doesn\u2019t bother me, I just always had a niggle that it didn\u2019t feel right. Now, I don\u2019t think I\u2019m doing it correctly, but once I\u2019ve digested your response then I think I\u2019ll be back on the right track.. @louthy  So I\u2019ve read this several times and played around with some code and I want to see if I\u2019ve got the gist of what you were explaining with your examples.\nIt seems like your primary focus with FP is composability. Pure, honest functions are the gold standard of composition and so even when our functions are not pure we should attempt to construct them in such a way so that they compose as if they were. Functors, monoids and monads are a way to do this.\nBy having some class that represents state (world in your example), and a monad to work with that state, we can build code that can pretend that it\u2019s pure even though impure operations are going on in the background.\nWhereas I took the heuristic \u201cmove all IO to the edges of a program\u201d to be interpreted as meaning IO should be like \u2018bookends\u2019, performed at the start and end of some process, it seems that you may be suggesting that another alternative is to use the \u2018margins\u2019 of the code. Push all the IO (or any other impurity) sideways to the edge of the code, hidden away in the guts of a monad.\nThis way we can focus on what the code is doing rather than the messy details and noisy obfuscation created when such concerns are explicit in the code.\nSo sacrificing some level of purity for a higher level of composition is what you are recommending?. @bender2k14  That's the one. Thanks.. ",
    "qwas368": "@bender2k14 Nice. Thank you.. ",
    "ceddlyburge": "There is a simple workaround, it's a good point.\nI don't know why you don't think it is a good idea though?. Ok, this is a also a fair point.\nI wasn't meaning to replace the existing method, but to add a new method.\nHow would you feel if I change the title to the following:\nAdd public Either<L, R> IfRightFluent(Action<R> right). ",
    "mausch": "Yep, seems we're on the same page. Throwing in that ctor you link isn't great IMHO but I think a bigger problem here are these implicit operators:\nhttps://github.com/louthy/language-ext/blob/27ea0b1e4c6eff4c5802803700e841e706c5bd7d/LanguageExt.Core/DataTypes/List/Lst.Predicate2.cs#L380\nhttps://github.com/louthy/language-ext/blob/27ea0b1e4c6eff4c5802803700e841e706c5bd7d/LanguageExt.Core/DataTypes/List/Lst.Predicate.cs#L347\nwhere you don't even have to call a ctor in your code to have that partial function kick in.\nMy suggestion would be to remove these implicit operators. I realise this is a breaking change though!. ",
    "sezaru": "Indeed that is way better, I was not aware that we could do that with Option.\nThanks!. ",
    "kalderman": "Thanks for the quick turn around.  However, this is still broken when targeting .NET framework 4.5+.\nThis may be a problem inherent in .NET framework.\nYou can see the test fail (among others) by adding the net461 target to the test project.\nWhich is already a pull request. ",
    "asgarddesigns": "In NuGet, 3.1.10 is the next version, so 3.0.3.31 is the last working version published (for my build servers at least).. Thanks guys, that gives me somewhere to start when I get back in!. So reverting to 3.0.x only got me through debug builds, release crashed on all devices. I doubt it is your libs at fault though, it looks to be hitting memory limits:\nAOT Compilation exited with code 134, command: (TaskId:229)\n  MONO_PATH=<workspace>/iOS/obj/iPhone/Release/mtouch-cache/32/3-Build /Library/Frameworks/Xamarin.iOS.framework/Versions/12.2.1.12/bin/arm-darwin-mono-sgen --debug --llvm -O=gsharedvt -O=float32  --aot=mtriple=armv7-ios,data-outfile=<workspace>/iOS/obj/iPhone/Release/mtouch-cache/armv7/LanguageExt.Core.aotdata.armv7,static,asmonly,direct-icalls,full,nodebug,dwarfdebug,msym-dir=<workspace>/iOS/obj/iPhone/Release/mtouch-cache/32/3-Build/Msym,llvm-path=/Library/Frameworks/Xamarin.iOS.framework/Versions/12.2.1.12/LLVM/bin/,outfile=<workspace>/iOS/obj/iPhone/Release/mtouch-cache/armv7/LanguageExt.Core.dll.s,llvm-outfile=<workspace>/iOS/obj/iPhone/Release/mtouch-cache/armv7/LanguageExt.Core.dll-llvm.o \"<workspace>/iOS/obj/iPhone/Release/mtouch-cache/32/3-Build/LanguageExt.Core.dll\" (TaskId:229)\n  arm-darwin-mono-sgen(35219,0xa986a1c0) malloc: *** mach_vm_map(size=8388608) failed (error code=3) (TaskId:229)\nMTOUCH : *** error : can't allocate region securely [<workspace>/iOS/ProjectName.iOS.csproj]\n  *** set a breakpoint in malloc_error_break to debug (TaskId:229)\n  Mono Ahead of Time compiler - compiling assembly <workspace>/iOS/obj/iPhone/Release/mtouch-cache/32/3-Build/LanguageExt.Core.dll (TaskId:229)\n  AOTID CCF2182F-AD55-C876-EE96-F91966C6A13D (TaskId:229)\n  Could not allocate 25960 bytes (TaskId:229)\n   (TaskId:229)\nMTOUCH : error MT3001: Could not AOT the assembly '<workspace>/iOS/obj/iPhone/Release/mtouch-cache/64/3-Build/LanguageExt.Core.dll' [<workspace>/iOS/ProjectName.iOS.csproj]\n  The command exited with code 1. (TaskId:229)\n  Output Property: _CompiledArchitectures=ARMv7, ARM64 (TaskId:229)\nTried turning off LLVM, --LinkSkip=LanguageExt.Core, linking=false. No Joy.\nThis is where my .NET/Xamarin knowledge runs out, having spent a week and a bit trying to work around this. As a result I've had to drop this lib and use another one in the short-term.\nMy suspicion is this might be due to us building for older 32bit architecture, and just with the size of the app and its deps, we are hitting a hard memory limit during build. \nIf you guys have any further advice, it'd be appreciated, but I suspect this probably isn't really your issue. Feel free to close.. @mrpantsuit Good link. Didn't come across that one... \nYeah I found that even linker behaviour didn't save me during release builds. I saw memory usage for the arm64-darwin-mono-sgen spike up to ~60gb before crashing. Now that it's removed, my debug build times have dropped from ~17 mins to ~11mins. \nI guess some of this comes with the FP territory (working around C# also doesn't help I'm sure) but it'd be good to have Core split out a bit, for the most part we are just using Option and Either. There are other libraries out there, but I'm not super fussed on them so far.\nI am sure that's easier said than done though. It sounds like we are hitting limits of Xamarin/Mono here.. ",
    "mrpantsuit": "I get this error, too. Setting the linker behaviour to \"Link All\" seems to resolve the issue (solution recommended here https://forums.xamarin.com/discussion/457/error-could-not-aot-the-assembly-servicestack-text-monotouch-dll), but I'm worried that's going to give me some runtime errors.  Perhaps, as the content in the link suggests, this lib is just too big to use on iOS w/o using the linker on it.. I solved this by turning on \"Link All\" then adding --linkskip for all my assemblies except LanguageExt and all the Xamarin assemblies.  Not an ideal solution, but a workable one.. ",
    "seerek": "I'm slowly educating myself on functional programming and for some time I'm reading what @louthy, @ploeh and others are writing about Free Monad and I'm surprised that no one noticed that we have it under our nose, built in into C# compiler.\nAs long as I understand, Free monad is just abstract syntax tree that can be parsed/interpreted depending on the context.\nThis is exactly what Expression is for, and IQueryable is best example of it.\nSee my quickly sketched example where I've implemented code mentioned in the Question you've mentioned.\n```cs\nusing System;\nusing System.Linq.Expressions;\nnamespace ConsoleApp7\n{\n    static class Program\n    {\n        static void Main()\n        {\n            var definition = Prg(null, null);\n            var program = definition.Compile();\n        program(new Consl(), new AuthImpl());\n        Console.ReadLine();\n    }\n\n    static Expression<Action<UI, Auth>> Prg(UI u, Auth a)\n    {\n        Expression<Func<UI>> x = () => u;\n        Expression<Func<Auth>> y = () => a;\n\n        return from ui in x\n               from auth in y\n                let uid = ui.Ask(\"What's your user ID?\")\n                let pwd = ui.Ask(\"Password, please.\")\n                let user = auth.Login(uid, pwd)\n                let hasPerm = auth.HasPermission(user, Permission.KnownSecret)\n                let message = hasPerm ? \"UUDDLRLRBA\" : \"Go away!\"\n               select ui.Tell(message);\n    }\n\n    static Expression<Func<A, B, C>> SelectMany<A, B, C>(this Expression<Func<A>> left, Expression<Func<A, Expression<Func<B>>>> right, Expression<Func<A, B, C>> projection)\n    {\n        return projection;\n    }\n\n    static Expression<Func<A, B, D>> Select<A, B, C, D>(this Expression<Func<A, B, C>> left, Expression<Func<C, D>> projection)\n    {\n        var a = Expression.Parameter(typeof(A), \"a\");\n        var b = Expression.Parameter(typeof(B), \"b\");\n\n        return Expression.Lambda<Func<A, B, D>>(Expression.Invoke(projection, Expression.Invoke(left, a, b)), a, b);\n        //return (a, b) => projection(left(a, b));\n    }\n\n    static Expression<Action<A, B>> Select<A, B, C>(this Expression<Func<A, B, C>> left, Expression<Action<C>> action)\n    {\n        var a = Expression.Parameter(typeof(A), \"a\");\n        var b = Expression.Parameter(typeof(B), \"b\");\n\n        return Expression.Lambda<Action<A, B>>(Expression.Invoke(action, Expression.Invoke(left, a, b)), a, b);\n        //return (a, b) => action(left(a, b));\n    }\n\n}\n\ninterface UI\n{\n    void Tell(string msg);\n    string Ask(string prompt);\n}\n\nclass Consl : UI\n{\n    public void Tell(string msg) => Console.WriteLine(msg);\n\n    public string Ask(string prompt)\n    {\n        Console.WriteLine(prompt);\n        return Console.ReadLine();\n    }\n}\n\ninterface Auth\n{\n    User Login(string id, string pwd);\n    bool HasPermission(User u, Permission p);\n}\n\nclass AuthImpl : Auth\n{\n    public User Login(string id, string pwd) => new User();\n\n    public bool HasPermission(User u, Permission p) => true;\n}\n\npublic struct Permission\n{\n    public static Permission KnownSecret = new Permission();\n}\n\n\npublic struct User\n{\n}\n\n}\n```\nAs you can see, I've not parsed the expression, just compiled it and run, but if there will be such need we can either parse it, or replace parts of it using our own implementation of ExpressionVisitor.\nOf course we are limited by C# compiler which doesn't allow Expressions to have multiple statements and to workaround it I've wrote SelectMany() and Select() methods that allowed me to compose multiple statements into one using LINQ (as I understand, composition was main problem of @louthy).\nThis, while very readable makes code hard to parse.\nWhy?\ncs\nreturn from ui in x\n                   from auth in y\n                    let uid = ui.Ask(\"What's your user ID?\")\n                    let pwd = ui.Ask(\"Password, please.\")\n                    let user = auth.Login(uid, pwd)\n                    let hasPerm = auth.HasPermission(user, Permission.KnownSecret)\n                    let message = hasPerm ? \"UUDDLRLRBA\" : \"Go away!\"\n                   select ui.Tell(message);\nis compiled into\nreturn x.SelectMany(ui => y, (ui, auth) => new {ui, auth})\n                .Select(@t => new {@t, uid = @t.ui.Ask(\"What's your user ID?\")})\n                .Select(@t => new {@t, pwd = @t.@t.ui.Ask(\"Password, please.\")})\n                .Select(@t => new {@t, user = @t.@t.@t.auth.Login(@t.@t.uid, @t.pwd)})\n                .Select(@t => new {@t, hasPerm = @t.@t.@t.@t.auth.HasPermission(@t.user, Permission.KnownSecret)})\n                .Select(@t => new {@t, message = @t.hasPerm ? \"UUDDLRLRBA\" : \"Go away!\"})\n                .Select(@t => @t.@t.@t.@t.@t.@t.ui.Tell(@t.message));\nwhich produces following expression tree:\ncs\n(a, b) => (<>h__TransparentIdentifier5 => <>h__TransparentIdentifier5.<>h__TransparentIdentifier4.<>h__TransparentIdentifier3.<>h__TransparentIdentifier2.<>h__TransparentIdentifier1.<>h__TransparentIdentifier0.ui.Tell(<>h__TransparentIdentifier5.message)).Invoke(\n    ((a, b) => (<>h__TransparentIdentifier4 => new { <>h__TransparentIdentifier4 = <>h__TransparentIdentifier4, message = <>h__TransparentIdentifier4.hasPerm ? \"UUDDLRLRBA\" : \"Go away!\" }).Invoke(\n        ((a, b) => (<>h__TransparentIdentifier3 => new { <>h__TransparentIdentifier3 = <>h__TransparentIdentifier3, hasPerm = <>h__TransparentIdentifier3.<>h__TransparentIdentifier2.<>h__TransparentIdentifier1.<>h__TransparentIdentifier0.auth.HasPermission(<>h__TransparentIdentifier3.user, Permission.KnownSecret) }).Invoke(\n            ((a, b) => (<>h__TransparentIdentifier2 => new { <>h__TransparentIdentifier2 = <>h__TransparentIdentifier2, user = <>h__TransparentIdentifier2.<>h__TransparentIdentifier1.<>h__TransparentIdentifier0.auth.Login(<>h__TransparentIdentifier2.<>h__TransparentIdentifier1.uid, <>h__TransparentIdentifier2.pwd) }).Invoke(\n                ((a, b) => (<>h__TransparentIdentifier1 => new { <>h__TransparentIdentifier1 = <>h__TransparentIdentifier1, pwd = <>h__TransparentIdentifier1.<>h__TransparentIdentifier0.ui.Ask(\"Password, please.\") }).Invoke(\n                    ((a, b) => (<>h__TransparentIdentifier0 => new { <>h__TransparentIdentifier0 = <>h__TransparentIdentifier0, uid = <>h__TransparentIdentifier0.ui.Ask(\"What's your user ID?\") }).Invoke(((ui, auth) => new { ui = ui, auth = auth }).Invoke(a, b))).Invoke(a, b))).Invoke(a, b))).Invoke(a, b))).Invoke(a, b))).Invoke(a, b))\nWho knows, maybe this is more scarier then it really is, because we may find that when we override ExpressionVisitor.VistMethodCall() to replace or parse it and filter there only types we are interested in, it may end up to be not so hard.\nThat's just my 2 cents to show potential solution.\nIn the feature I will probably need to invent something like this to have one definition of reports that can be rendered into HTML, Excel, PDF, so maybe I will find a way to make it more parsable.. > You should, for example, be able to define any domain-specific grammar as a functor, and then be able to produce a monad out of that 'for free'.\nI'm sorry @ploeh but this was too many m- and f- words without any examples for C# programmer like me.\nI'm not at that level yet (although I have Category Theory for Programmers on my TODO list) \nSo currently I'm trying to understand it from practical point of view.\nFirst of all: \nWhy do we need Free Monad pattern?\nMy understanding:\nTo separate definition/intent from execution, but not only as direction of dependencies but even physically.\nExamples:\n\nIQueryable allows me to specify my query definition in my Business Logic but be executed in my data source while making sure that dependency direction looks like this: DataSource --->Business Logic.\nThanks to this my data source can be easily replaced without touching my Business Logic + because query is executed close to data I don't have problems with performance (while for example filtering data in BL)\nImagine that you have a financial report with a lot of details for each product your company is producing and while users want to see it on web page (HTML) often they need to verify the numbers in Excel. HTML web page will show only total numbers, but in Excel users want to see formulas to quickly find why some number is wrong. I can't imagine how this can be easy achieved by simple Dependency Injection and such separation of definition from execution seems like the only way.\nHow would I do this in C#?\nBy writing all formulas as C# Expression and probably use default implementation for HTML version, and parse Expressions when I need to convert them into Excel formulas.\n\nAs an exercise, so that we can talk about something less abstract, I have implemented example from your presentation about Free Monads in C# using Expressions.\n```cs\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing LanguageExt;\nnamespace ConsoleApp8\n{\n    static class Program\n    {\n        static void Main()\n        {\n            var definition = TryAcceptDefinition.ReplaceRepository(typeof(ReservationRepository), typeof(MockRepository));\n            var program = definition.Compile();\n        int? result = program(new Reservation {Date = DateTimeOffset.Now, Quantity = 101, IsAccepted = false});\n\n        Debug.WriteLine(result.ToOption());\n    }\n\n    public static Expression<Func<Option<Reservation>, int?>> TryAcceptDefinition = res =>\n               (from reservation in res\n                where ReservationRepository.IsReservationInFuture(reservation)\n                let reservedSeats = ReservationRepository.ReadReservations(reservation.Date).Sum(r => r.Quantity)\n                where Capacity >= reservedSeats + reservation.Quantity\n                select ReservationRepository.Create(new Reservation\n                {\n                    Date = reservation.Date,\n                    Quantity = reservation.Quantity,\n                    IsAccepted = true\n                })\n               )\n               .MatchUnsafe(x => x, () => null);\n\n    public static int Capacity { get; } = 100;\n\n    private static T ReplaceRepository<T>(this T expression, Type from, Type to) where T : Expression => \n        (T) new StaticCallTypeReplacer(@from, to).Visit(expression);\n}\n\ninternal class StaticCallTypeReplacer : ExpressionVisitor\n{\n    private readonly Type @from;\n    private readonly Type to;\n\n    public StaticCallTypeReplacer(Type @from, Type to)\n    {\n        this.@from = @from;\n        this.to = to;\n    }\n\n    protected override Expression VisitMethodCall(MethodCallExpression call)\n    {\n        if (call.Method.DeclaringType == @from)\n            return base.VisitMethodCall(Expression.Call(null, to.GetMethod(call.Method.Name), call.Arguments));\n        return base.VisitMethodCall(call);\n    }\n}\n\ninternal class Reservation\n{\n    public DateTimeOffset Date { get; set; }\n    public int Quantity { get; set;  }\n    public bool IsAccepted { get; set; }\n}\n\ninternal static class ReservationRepository\n{\n    public static bool IsReservationInFuture(Reservation reservation)\n    {\n        throw new NotImplementedException();\n    }\n\n    public static IEnumerable<Reservation> ReadReservations(DateTimeOffset date)\n    {\n        throw new NotImplementedException();\n    }\n\n    public static int? Create(Reservation reservation)\n    {\n        throw new NotImplementedException();\n    }\n}\n\ninternal static class MockRepository\n{\n    public static bool IsReservationInFuture(Reservation reservation) => true;\n\n    public static IEnumerable<Reservation> ReadReservations(DateTimeOffset date) => Enumerable.Empty<Reservation>();\n\n    public static int? Create(Reservation reservation)\n    {\n        return 1;\n    }\n}\n\n}\n```\n@ploeh I think, that I've achieved the same you showed on your presentation but code doesn't look so scary as your version.\nTo simplify it, I've wrote it as one statement so that I will not need to care about composing Expressions.\nYou can see that TryAccept() function is calling directly ReservationRepository static methods which are (for this example needs) intentionally not implemented so that they will fail when called.\nIn the line \ncs\nvar definition = TryAcceptDefinition.ReplaceRepository(typeof(ReservationRepository), typeof(MockRepository));\nI'm changing the implementation to MockRepository using StaticCallTypeReplacer ExpressionVisitor.\nThis shows that such pattern allows us to not care about passing dependencies from method to method.\nWe can call default implementation and replace it when needed.\nI'm not saying it's the way to do it, because this creates dependency from our business logic to default implementation of low level details, but just wanted to show such possibility.\nOf course If I want, I can parse it and interpret in any other way.\nNow that I showed practical use of this pattern - questions to @ploeh and others smarter than me:\n\nIs it free monad?\nIf not (because of some mathematical definition) - does it matter from practical point of view?\nDoes real Free Monad gives me something I don't have here?\nCan we do something to make it real free monad?\n\n. ",
    "ploeh": "\nAs long as I understand, Free monad is just abstract syntax tree that can be parsed/interpreted depending on the context.\nThis is exactly what Expression is for, and IQueryable is best example of it.\n\nWe've had a discussion about this somewhere else (Twitter, I think), and I will, for the record, repeat what I wrote in that other context.\nI don't think it enables understanding of free monads to insist that C# expression trees and IQueryable is equivalent to free monads.\nIn related terminology, the free monoid (careful here, we're now talking about monoids, not monads) is a monoid that's available 'for free', so to speak, regardless of the data you want to aggregate. In programming, this is synonymous with a linked list, or some other synonymous pure collection type. See also this Stack Overflow answer from today.\nLikewise, a free monad is a monad that's available 'for free' for any functor. You should, for example, be able to define any domain-specific grammar as a functor, and then be able to produce a monad out of that 'for free'. As is the case with the free monoid, nothing actually happens in the monad until you apply some interpreter. The interpreter specifically walks over the expressions in the DSL.\nC# expression trees may be a specific 'instance' of that 'pattern', but I don't think that it's a free monad in itself. I think that it's a specific monad.. > this was too many m- and f- words without any examples for C# programmer like me\nThat's why I supplied links as well \ud83d\ude04 I know that there's a lot to read, so I don't expect anyone to be able to absorb it all in a couple of hours. It took me months to reach just a basic understanding of category theory. I've been at it for years now, and I only feel that I can talk sensibly about monoids, functors, monads, f-algebras, catamorphisms, and a few other things. I still don't understand the Yoneda lemma, and I only have the vaguest sense of what adjunctions are.\nI've written blog posts to pave the way for others, particularly C# programmers, because the most accessible resource for programmers, Category Theory for Programmers, uses Haskell for its code examples. I hope that by explaining some of those things using C# instead, I can make some of this material accessible to another audience.\nI still expect readers to invest significant time in this. If there's a way to explain this in depth in a few hours, I'm not aware of it.\n\nWhy do we need Free Monad pattern?\n\nIn C#, we don't. Dependency Injection is a much simpler way to address the same concerns.\nIn Haskell, on the other hand, Dependency Injection is impossible because it makes everything impure. You can attempt to use Dependency Injection (DI), but your code is simply not going to compile, because DI implies impurity. (You can, technically, get around this by making your entire Haskell code base impure, but then what's the point of the language?)\nThere's more than one way to get around that problem in Haskell. One is to use Haskell type classes in what some people call mtl style. For various reasons, I don't like that approach, although allegedly it performs better. Regardless of my bias, though, this alternative relies on a specific language feature (type classes), so doesn't readily translate to other languages.\nAnother alternative is free monads. As a universal abstraction (i.e. an abstraction based on mathematics, and thus universally existing as long as one accepts the underlying axioms) this abstraction is always available. In Haskell, this alternative is still great because the language has enough capability to make it fairly painless to use it.\nSince the abstraction is universal, you can translate it to F# or even, as I've demonstrated, to C#, but since these languages don't readily support this style of programming, it becomes increasingly irrelevant as you move from language to language.\nJust like Haskell offers more than one way to address issues with coupling, so do F# and C#. In F#, a more natural way to address the issue is with partial application, and in C#, the most natural principle is to use DI. As I've shown, partial application is equivalent to DI.\n\nI think, that I've achieved the same you showed on your presentation but code doesn't look so scary as your version.\n\nIndeed, but using DI is less scary still:\n```csharp\npublic class Ma\u00eetreD\n{\n    public Ma\u00eetreD(int capacity, IReservationsRepository reservationsRepository)\n    {\n        Capacity = capacity;\n        ReservationsRepository = reservationsRepository;\n    }\npublic int? TryAccept(Reservation reservation)\n{\n    if (!ReservationsRepository.IsReservationInFuture(reservation))\n        return null;\n\n    var reservedSeats = ReservationsRepository\n        .ReadReservations(reservation.Date)\n        .Sum(r => r.Quantity);\n    if (Capacity < reservedSeats + reservation.Quantity)\n        return null;\n\n    reservation.IsAccepted = true;\n    return ReservationsRepository.Create(reservation);\n}\n\npublic int Capacity { get; }\n\npublic IReservationsRepository ReservationsRepository { get; }\n\n}\n```\nWhile there are other ways to do this (e.g. the way that you demonstrate), I think that the trade-offs are worse. At least, while it's taken some ten years to make the OOP community understand DI (and notions are still hazy to most), at least it's starting to become fairly well-known. Most OOP languages also naturally support DI, because polymorphism is already built in.\nTo be clear, I don't consider a free monad to be a viable alternative in C#, but at least it has one thing going for it: it communicates intent. When you see a method with an IReservationsProgram<> return type, you're explicitly being told that, yes, this is an abstract syntax tree (AST), but it's an AST of a very specific and limited grammar limited to three specific instructions.\nOn the other hand, when a method returns an Expression, as a code reader, this tells you nothing about what to expect. While it's an AST, its an AST of the entire C# grammar! It's like a Haskell function that returns IO. Anything could happen inside of that function.\nSo what advantages does it offer?\n\nIs it free monad?\n\nI don't think that it is. It may be isomorphic to a free monad, just like DI and free monads are isomorphic. Probably, all three approaches are isomorphic to each other.\nA free monad is a monad that always arises from a functor. Which functor is being turned into a monad here?\n\nIf not (because of some mathematical definition) - does it matter from practical point of view?\nDoes real Free Monad gives me something I don't have here?\n\nNo, and no. In most cases, in C#, DI is the simplest way to address issues of coupling.\n\nCan we do something to make it real free monad?\n\nCurrently, I don't see how, but I haven't given it much thought, so I'm not at all sure about this.... ",
    "jwilliamson1": "@bender2k14 Thank you! That worked! I just had to tweak the tuples since I'm not using C# 7.1\n```\npublic static Func>, IEnumerable>\n            GetAndMergeDbValues = cells =>\n            {\n                var groupings = cells\n                                .Map(val => val.ToOption())\n                                .Somes()\n                                .GroupBy(c => new Tuple(c.TimePeriod, c.Periodicity))\n                                .Map(g => new QueryGrouping(\n                                    g.Key.Item1,\n                                    g.Key.Item2,\n                                    g));\n            var findings = groupings.SelectMany(FetchDbValuesAndMerge);\n\n            return findings;\n        };\n\n```\nIs there a reason there is not something similar to Somes for Validation like Successes?. @bender2k14 I might try making a PR for that then. Is there also a way to get an IEnumerable of my failed validations? . @bender2k14 I have one more related question which is how do you collect your original inputs when using the Validation applicative?  I suspect that there is away to implement a custom monoid that matches the structure of my input data and concatenate it, but I'm not sure how to do that even though I do see there is a MonoidFail overload for validation. \nUltimately what my little program does is take seven columns of a csv file, do some validation, and if valid, query against a database to see if the \"value\" column in the csv matches the \"value\" column in the database. If validation fails for some rows, I still will run the query for the good rows, and report the validation failures and query results in the same output structure.  This is why I asked my previous questions about how to get valid and invalid collections from IEnumerable\nI don't know if I'm going down the wrong path since I'm completely green to FP,  so if I'm way off in my approach let me know.\nMy input validation looks like this. I have to use Func<string> errorLoc so I can append my error messages with which sheet and range they were found since I'm losing my input state.\n```\npublic static Validation CreateCellData(\n                        string sheet,\n                        string range,\n                        string companyId,\n                        string mnemonic,\n                        string timePeriod,\n                        string periodicity,\n                        string value)\n        {\n            Func errorLoc = ()  => $\" in {sheet} in {range}\";\n        var validCompanyId = CompanyValidation.ValidateId(companyId, errorLoc);\n        var validMnemonic = MnemonicValidation.ValidateMnemonic(mnemonic, errorLoc);\n        var validTimePeriod = TimePeriodValidation.ValidateTimePeriod(timePeriod, errorLoc);\n        var validPeriodicity = PeriodicityValidation.ValidatePeriodicity(periodicity, errorLoc);\n\n\n        return (validCompanyId, validMnemonic, validTimePeriod, validPeriodicity).Apply((id, m, t, p)\n            => new CellData(sheet, range, id, m, t, p, value));\n\n```\nHere is an example of one of the validation methods above. As you can see I'm appending the sheet and range to error message, but I'd rather have something else collect all my inputs.\npublic static class CompanyValidation\n    {\n        static CompanyIDValidator validator = new CompanyIDValidator();\n        public static Validation<string, CompanyId> ValidateId(string input, Func<string> errorLoc)\n            => validator.IsValid(input) ? Success<string, CompanyId>(new CompanyId(input))\n                                    : Fail<string, CompanyId>(\"Invalid CompanyId\" + errorLoc());\n    }\nThe problem is I just end up with an IEnumerable of strings that lose all of the original data. What's a good way to maintain the input state to the function so I can report those back in their matching columns? I would like to generate the Finding class below that accumulates errors in their appropriate fields instead of a list of strings. \n```\npublic class Finding\n    {\n        public string Sheet { get; }\n        public string Range { get; }\n        public string CompanyId { get; }\n        public string Mnemonic { get; }\n        public string TimePeriod { get; }\n        public string Periodicity { get; }\n        public string CacheValue { get; }\n        public string DbValue { get; }\n        public string DbLastUpdate { get; }\n        public string Validation { get; }\n    Finding(string sheet, string range, string CompanyId, string mnemonic, string timePeriod, string periodicity, \n                   string cacheValue, string dbValue, string dbLastUpdate, string Validation)\n    {\n        this.Sheet = sheet;\n        this.Range = range;\n        this.CompanyId = CompanyId;\n        this.Mnemonic = mnemonic;\n        this.TimePeriod = timePeriod;\n        this.Periodicity = periodicity;\n        this.CacheValue = cacheValue;\n        this.DbValue = dbValue;\n        this.DbLastUpdate = dbLastUpdate;\n        this.Validation = Validation;\n    }\n\n}\n.\npublic class CompanyIDValidator : ICompanyIDValidator\n    {\n        static readonly Regex Rssd = new Regex(@\"(^\\d{1,10}$)\");\n        static readonly Regex Ticker = new Regex(@\"(^[A-Za-z]{1,5}$)\");\n        static readonly Regex KbraId = new Regex(@\"(^XYZ\\d{8}$)\", RegexOptions.IgnoreCase);\n    public bool IsValid(string input)\n    {\n        if (string.IsNullOrEmpty(input) ||\n            (!Rssd.Match(input).Success && !Ticker.Match(input).Success && !KbraId.Match(input).Success))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public void Validate(string input)\n    {\n        if(!IsValid(input))\n        {\n            throw new ArgumentException(\"CompanyID is invalid\");\n        }\n    }\n}\n\npublic class CompanyId : BaseStringSynonym\n    {\n        public CompanyId(string value) : base(value) { }\n    }\npublic class BaseStringSynonym\n    {\n        string Value { get; }\n    public BaseStringSynonym(string value) { Value = value; }\n    public static implicit operator string(BaseStringSynonym b) => b.Value;\n    public static implicit operator BaseStringSynonym(string s) => new BaseStringSynonym(s);\n\n    public override string ToString() => this.Value;\n}\n\n```\nI plan on making public static functions to create my CompanyIds and making the ctor private so that only something that passes my validation criteria can be a CompanyId.\n\nThe goal is to keep the data in stronger, more specific types as long as possible. Only \"project\" back down to weaker types like string as the last possible moment.\n\nI see your point and perhaps I need a base class for my findings and have a ValidFinding and InvalidFinding, where the ValidFinding has CompanyId, Mnemonic, TimePeriod, and Periodicity types in it and InvalidFinding has plain strings. And then those can get entered into a CSV. I think the main reason I didn't do that is because I'm just validating so my SQL query doesn't blow up, after that everything is just getting dumped into a CSV and doesn't have any type specific restrictions. \n\nFor starters, you can create and use a parameter object containing the inputs to the function. In OOP, this refactoring step goes by the name \"introduce parameter object\". (I know that I am being a bit vague here. I wanted to include a link, but every potential source that I considered was tained with additional OOP-specific information.)\n\nSomething like this?\npublic class RawData\n    {\n        public RawData(string sheet,\n                        string range,\n                        string companyId,\n                        string mnemonic,\n                        string timePeriod,\n                        string periodicity,\n                        string value,\n                        string lastUpdate)\n        {\n            this.Sheet = sheet;\n            this.Range = range;\n            this.CompanyId = companyId;\n            this.Mnemonic = mnemonic;\n            this.TimePeriod = timePeriod;\n            this.Periodicity = periodicity;\n            this.Value = value;\n            this.LastUpdate = lastUpdate;\n        }\n        public string Sheet { get; }\n        public string Range { get; }\n        public string CompanyId { get; }\n        public string Mnemonic { get; }\n        public string TimePeriod { get; }\n        public string Periodicity { get; }\n        public string Value { get; }\n        public string LastUpdate { get; }\n    }\n\nWhy?\n\nThat is just a more readable output since the user can scan the first two columns \"Sheet\" and \"Range\" to find their cell (this is a dump of an Excel cache) that has the error. Also I'm curious how easy it would be since it would be very simple to implement procedurally. \nA simpler Idea than a custom monoid, would be to have my error type for validation be Finding, so I get IEnumerable and then fold the results in the end into a merged Finding. I would just need to pass all inputs into each validation function, perhaps using an object like you suggest and then checking the respective fields of that object in each validator.. Haha, you nailed it! Enrico's book is how I found out about Language-Ext library and I think he does a great job of explaining FP concepts in a  way that is immediately useful and clear, so yeah, that's where I got that idea for the smart constructor and implicit conversion to a stronger type. I create the BaseSynonymClass because there was too much boilerplate with his original approach. \nI will take a look  at the Record type, that may simplify my code a bit.\nSo you're suggesting, instead of implicit operators, just make ConnectionString a POCO with an internal string and a ToString() method and a smart constructor?\nSo tact for validation now is pass the parameter object into my four smart constructors and return InvalidFindings in the case something is wrong. Each of the InvalidFindings will contain the same sheet, range, and value (these are values that don't need validation) that will just be folded together in the end. This has the potential to generate lists with a length of 4 in the worst case. Then when I use the errors I fold my InvalidFindings together that can be printed out into the CSV.\nA length of four isn't bad but I would think for a lot of data you would fold as you go to not allocate the memory in the collection. \nMaybe you're right a bout the base type, but the output columns need to line up with the csv headers unless I decide to separate the failures, which might make sense, but like I said, I was curious how difficult doing something easy in an OO procedural way would be in FP. \n. https://imgur.com/a/91RdsV5\nhttps://imgur.com/a/xBm8rrJ\nHere are two examples I'd like to try to output, the first being closer to the ideal, but I'm curious how I would be able to implement either of these Finding formats using the Validation applicative with smart constructors. If I were doing this using a procedural approach using strings all the way instead of strong types I would just check whether my input strings matched a given criteria and then, for the first example, if it failed add it to a list of failures associated with that row, or in the later case I'd just update the fields destructively adding \"Invalid Inputs\" in the final column.\nTo check whether I should query the database I'd either check where the list of errors was empty or in the second case if the invalid field was empty. \nI assume I could do something crazy like Validation,CellData>> where I pass in a function that takes a finding and then creates a new one updating only one field like \n(finding) => Finding.WithSheetRangeMnemonic(\"Data_1\", \"Sheet_1\", \"invalid BHCK1234\", finding)\nI'd have to kick this off by passing a new empty finding to all my failed validations and this would leak code out of the celldata constructor. So I'm almost thinking I need to go back to a more procedural approach to make either of those outputs or maybe figure out how to use a monoid other than IEnumerable in Validation's left side.. Here are the main classes in the program. I wanted to include them in case I had coded myself into a situation that restricted my options. \n```\nstatic class Program\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                var options = Options.GetOptions(args);\n            options.Match(\n                None: () => WriteLine(\"Must specify a file.\"),\n                Some: o =>\n                {\n                    var fileName = o.Source;\n\n                    var data = LoadCellData(fileName);\n\n                    IEnumerable<Seq<string>> errors = data\n                      .Map(v => v.Match(_ => None, Some))\n                      .Somes();\n\n                    var erredFindings = errors.Map(s => new Finding(string.Join(\",\", s)));\n\n                    var findings = GetAndMergeDbValues(data);\n\n                    var results = erredFindings.Append(findings);\n\n                    WriteCsv(results, o);\n\n                    WriteLine($\"File successfully created!\");\n                });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Errors: {ex.ToString()}\");\n        }\n\n        DebugPause();\n    }\n\n\n\n    static Unit WriteCsv(IEnumerable<Finding> findings, Options options)\n    {\n        using (\n\n            var output = new StreamWriter(GetOutput(options, options.Source)))\n        {\n            WriteHeader(output);\n\n            foreach (var finding in findings)\n            {\n                WriteDataPoint(finding, output);\n            }\n        }\n        return new Unit();\n    }\n\n    static void WriteHeader(StreamWriter writer)\n    {\n        writer.WriteLine(\"Sheet,Range,CompanyID,Mnemonic,Timeperiod,Periodicity,CacheValue,DbValue,Error,Validation\");\n    }\n\n    static void WriteDataPoint(this Finding f, StreamWriter writer) =>           \n        writer.WriteLine($\"{f.Sheet},{f.Range}\" +\n                     $\",{f.CompanyId},{f.Mnemonic},{f.TimePeriod},{f.Periodicity}\" +\n                     $\",{f.CacheValue},{f.DbValue},{f.Error},{f.Validation}\");\n\n\n    static Stream GetOutput(Options options, string source)\n    {\n        string filename = Path.GetFileNameWithoutExtension(source);\n\n        if (!Directory.Exists(options.OutputDir))\n            Directory.CreateDirectory(options.OutputDir);\n\n        string outputpath = Path.Combine(options.OutputDir, filename + \"-checked.csv\");\n\n        return new FileStream(outputpath, FileMode.Create, FileAccess.Write, FileShare.ReadWrite);\n    }\n\n    static IEnumerable<Validation<string, CellData>> LoadCellData(string fileName) =>\n        File.ReadLines(fileName)\n        .Skip(1)\n        .Select(ParseLine);\n\n    static Validation<string, CellData> ParseLine(string line)\n    {\n        string[] values = line.Split(',');\n        return CellData.CreateCellData(values[0], values[1], values[2], values[3], values[4], values[5], values[6]);\n    }\n\n\n    [Conditional(\"DEBUG\")]\n    static void DebugPause()\n    {\n        Console.WriteLine(\"\\nhit enter to exit.\");\n        Console.ReadLine();\n    }\n\n}\n\nVerification\npublic static class Verification\n    {\n    public static Func<IEnumerable<Validation<string, CellData>>, IEnumerable<Finding>> GetAndMergeDbValues = cells => \n    {                        \n            var groupings = cells\n            .Map(val => val.ToOption())\n            .Somes()\n            .GroupBy(c => new Tuple<DateTime, string>(c.TimePeriod, c.Periodicity))\n            .Map(g => new QueryGrouping(g.Key.Item1, g.Key.Item2, g));\n\n            var findings = groupings.SelectMany(FetchDbValuesAndMerge);\n        return findings;\n    };\n\n    static IEnumerable<Finding> FetchDbValuesAndMerge(QueryGrouping grouping)\n    {\n        ConnectionString conn = ConfigurationManager.AppSettings[\"connstr\"];\n\n        SqlTemplate template = FillTemplate(grouping);\n\n        var queryWithTemplate = conn.Query<DbResult>();\n\n        var dbResults = queryWithTemplate(template).ToList();\n\n        var findings = GenerateFinding(grouping, dbResults);\n\n        return findings;\n    }\n\n    static Func<QueryGrouping, IEnumerable<DbResult>, IEnumerable<Finding>> GenerateFinding = (aGrouping, dbVals) =>\n    {\n        return aGrouping.Cells.Select(\n            c => Finding.CreateFinding(\n                c,\n                dbVals.Where(db => c.CompanyId == db.CompanyId &&\n                               c.Mnemonic == db.DataPointKey).HeadOrNone()));\n    };\n\n    static SqlTemplate FillTemplate(QueryGrouping grouping)\n    {\n        var dataPointKeys = string.Join(\", \", grouping.Cells.Select(c => AsSqlInsertVals(c.Mnemonic)));\n\n        var companyIds = string.Join(\", \", grouping.Cells.Select(c => AsSqlInsertVals(c.CompanyId)));\n\n        var timePeriod = \"'\" + grouping.TimePeriod.ToString(\"MM-dd-yyyy\") + \"'\";\n\n        var periodicity = \"'\" + grouping.Periodicity.Replace('/', '-') + \"'\";\n\n        return $@\"DROP TABLE IF EXISTS #FundamentalsDataPointKeysTable;\n        DROP TABLE IF EXISTS #FundamentalsCompanyTable;\n        CREATE TABLE #FundamentalsDataPointKeysTable (\n            dataPointKey VARCHAR(255) NULL\n        );\n        INSERT INTO #FundamentalsDataPointKeysTable (dataPointKey)\n        VALUES {dataPointKeys};\n        CREATE TABLE #FundamentalsCompanyTable (\n            CompanyId VARCHAR(12) NULL\n        );\n        INSERT INTO #FundamentalsCompanyTable (CompanyId)\n        VALUES  {companyIds};\n        EXEC [core].[BulkStandardPeriodicityFundamentals_sps] @StartDate = {timePeriod}, @EndDate = {timePeriod}, @Periodicity = {periodicity}\";\n    }\n\n\n    static string AsSqlInsertVals(string value)\n    {\n        return \"('\" + value + \"')\";\n    }\n}\n\nDbHelpers\npublic static class DbHelpers\n    {\n        public static R Using(TDisp disposable, Func f) where TDisp : IDisposable\n        {\n            using (disposable) return f(disposable);\n        }\n    public static R Connect<R>(string connStr, Func<IDbConnection, R> f)\n        => Using(new SqlConnection(connStr), conn => { conn.Open(); return f(conn); });\n\n\n    public static Func<SqlTemplate, IEnumerable<T>> \n        Query<T>(this ConnectionString connString)\n        => (statement)\n        => Connect(connString, conn => conn.Query<T>(statement));\n\n}\n\nConnectionString\npublic class ConnectionString\n    {\n        string Value { get; }\n        public ConnectionString(string value) { Value = value; }\n    public static implicit operator string(ConnectionString c)\n       => c.Value;\n    public static implicit operator ConnectionString(string s)\n       => new ConnectionString(s);\n\n    public override string ToString() => Value;\n}\n\nSqlTemplate\npublic class SqlTemplate\n    {\n        string Value { get; }\n        public SqlTemplate(string value) { Value = value; }\n    public static implicit operator string(SqlTemplate c)\n       => c.Value;\n    public static implicit operator SqlTemplate(string s)\n       => new SqlTemplate(s);\n\n    public override string ToString() => Value;\n}. Wow this is really cool and thanks for taking the time to code this up! So you're just using Validate just to collect errors but passing any successful raw data to QueryDatabase. I had come up with something similar where I took all my validations and created a Validation<string, CellData> as an intermediate step and then converted that to an Either<string, CellData>. I then just updated the rest of the flow to use an either. Like so:\n\n```\npublic class CellData\n    {\n        public CellData(string sheet,\n                        string range,\n                        CompanyId companyId,\n                        Mnemonic mnemonic,\n                        DateTime timePeriod,\n                        Periodicity periodicity,\n                        string value)\n        {\n            this.Sheet = sheet;\n            this.Range = range;\n            this.CompanyId = companyId;\n            this.Mnemonic = mnemonic;\n            this.TimePeriod = timePeriod;\n            this.Periodicity = periodicity;\n            this.Value = value;\n        }\n        public string Sheet { get; }\n        public string Range { get; }\n        public CompanyId CompanyId { get; }\n        public Mnemonic Mnemonic { get; }\n        public DateTime TimePeriod { get; }\n        public Periodicity Periodicity { get; }\n        public string Value { get; }\n    public static Either<Finding, CellData> CreateFromRawData(RawData rawData)\n    {\n        var validCompanyId = CompanyId.Validate(rawData.CompanyId);\n        var validMnemonic = Mnemonic.Validate(rawData.Mnemonic);\n        var validTimePeriod = TimePeriodValidation.ValidateTimePeriod(rawData.TimePeriod);\n        var validPeriodicity = Periodicity.Validate(rawData.Periodicity);\n\n        var validationResult = (validCompanyId, validMnemonic, validTimePeriod, validPeriodicity)\n            .Apply((id, m, t, p)\n            => new CellData(rawData.Sheet, rawData.Range, id, m, t, p, rawData.Value));\n\n        var eitherCellData = validationResult.Match(\n            Succ: Right<Finding, CellData>,\n            Fail: f => Left<Finding, CellData>(Finding.CreateInvalid(rawData, string.Join(\", \", f)))\n        );\n\n        return eitherCellData;\n    }\n}\n\n```\nI don't love that I have an intermediate step to Validation and I wondered if there was a way to do the validation without creating the CellData first, something like you did with Validation\nThe one problem with your solution is that my query needs a \"group by\" to optimize it's use with the stored procedure and if I'm understanding the explanation you gave me earlier in this thread, that using the monadic flow over a Validation won't work because it has as it's projected select value ValidationData\nThis is the stored procedure that I'm using\n$@\"DROP TABLE IF EXISTS #FundamentalsDataPointKeysTable;\n            DROP TABLE IF EXISTS #FundamentalsCompanyTable;\n            CREATE TABLE #FundamentalsDataPointKeysTable (\n                dataPointKey VARCHAR(255) NULL\n            );\n            INSERT INTO #FundamentalsDataPointKeysTable (dataPointKey)\n            VALUES {dataPointKeys};\n            CREATE TABLE #FundamentalsCompanyTable (\n                CompanyId VARCHAR(12) NULL\n            );\n            INSERT INTO #FundamentalsCompanyTable (CompanyId)\n            VALUES  {companyIds};\n            EXEC [core].[BulkStandardPeriodicityFundamentals_sps] @StartDate = {timePeriod}, @EndDate = {timePeriod}, @Periodicity = {periodicity}\";\nThe the data gets grouped by the singular timePeriod and periodicity with multiple mnemonics and companyids.\nSo right now I'm just using this setup code even though it means multiple iterations over the collection.\n```\npublic static Func>, IEnumerable> GetAndMergeDbValues = cells => \n        {                      \n                var groupings = cells\n                .Rights()\n                .GroupBy(c => new Tuple(c.TimePeriod, c.Periodicity))\n                .Map(g => new QueryGrouping(g.Key.Item1, g.Key.Item2, g));\n            var findings = groupings.AsParallel().SelectMany(FetchDbValuesAndMerge);\n        return findings;\n    };\n\n```\nI tried to rework this to use monadic flow but ran into a bunch of errors doing the group by.. I suppose I could do the group by before validating but it feels wrong to not do the grouping right before it's being used. \nAm I right in understanding that  a group by can't work over the correct values in a Validation or Either then like a Where clause does for example?. so basically the query is something is this.\nDROP TABLE IF EXISTS #FundamentalsDataPointKeysTable;\n            DROP TABLE IF EXISTS #FundamentalsCompanyTable;\n            CREATE TABLE #FundamentalsDataPointKeysTable (\n                dataPointKey VARCHAR(255) NULL\n            );\n            INSERT INTO #FundamentalsDataPointKeysTable (dataPointKey)\n            VALUES {dataPointKeys};\n            CREATE TABLE #FundamentalsCompanyTable (\n                CompanyId VARCHAR(12) NULL\n            );\n            INSERT INTO #FundamentalsCompanyTable (CompanyId)\n            VALUES  {companyIds};\n            EXEC [core].[BulkStandardPeriodicityFundamentals_sps] @StartDate = {timePeriod}, @EndDate = {timePeriod}, @Periodicity = {periodicity}\nso if the inputs for the query are\n\"companyId1\", \"mnemonic1\", \"2/26/2019\", \"QTR\",\n\"companyId2\", \"mnemonic2\", \"2/26/2019\", \"QTR\",\n\"companyId1\", \"mnemonic1\", \"3/3/2019\", \"QTR\",\n\"companyId2\", \"mnemonic2\", \"3/3/2019\", \"QTR\",\n\"companyId3\", \"mnemonic3\", \"3/3/2019\", \"QTR\",\nthen two queries should be created from the template above that look like this:\nDROP TABLE IF EXISTS #FundamentalsDataPointKeysTable;\n            DROP TABLE IF EXISTS #FundamentalsCompanyTable;\n            CREATE TABLE #FundamentalsDataPointKeysTable (\n                dataPointKey VARCHAR(255) NULL\n            );\n            INSERT INTO #FundamentalsDataPointKeysTable (dataPointKey)\n            VALUES \"mnemonic1\",\"mnemonic2\" ;\n            CREATE TABLE #FundamentalsCompanyTable (\n                CompanyId VARCHAR(12) NULL\n            );\n            INSERT INTO #FundamentalsCompanyTable (CompanyId)\n            VALUES  \"companyId1\", \"companyId2\";\n            EXEC [core].[BulkStandardPeriodicityFundamentals_sps] @StartDate = \"2/26/2019\", @EndDate = \"2/26/2019\", @Periodicity = \"QTR\"\nand\nDROP TABLE IF EXISTS #FundamentalsDataPointKeysTable;\n            DROP TABLE IF EXISTS #FundamentalsCompanyTable;\n            CREATE TABLE #FundamentalsDataPointKeysTable (\n                dataPointKey VARCHAR(255) NULL\n            );\n            INSERT INTO #FundamentalsDataPointKeysTable (dataPointKey)\n            VALUES \"mnemonic1\",\"mnemonic2\", \"mnemonic3\" ;\n            CREATE TABLE #FundamentalsCompanyTable (\n                CompanyId VARCHAR(12) NULL\n            );\n            INSERT INTO #FundamentalsCompanyTable (CompanyId)\n            VALUES  \"companyId1\", \"companyId2\", \"companyId3\";\n            EXEC [core].[BulkStandardPeriodicityFundamentals_sps] @StartDate = \"3/3/2019\", @EndDate = \"3/3/2019\", @Periodicity = \"QTR\"\nSo you can see how the group by is used to create queries with unique TimePeriod, Periodicity sets with any matching mnemonics(called datePointKey on the Db side) and companyIds that were apart of the original expanded list. \nThe one thing I was a little confused about in your code was the use of empty strings and null in the following snippet.  I understand what it's doing but is this cheating when compared to a language like haskell without nulls? Or is this just a workaround for some functionality that we just don't have yet in C#?\n```\npublic class Finding {\n    public static Finding Empty = new Finding(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\");\npublic string Sheet { get; }\npublic string Range { get; }\npublic string CompanyId { get; }\npublic string Mnemonic { get; }\npublic string TimePeriod { get; }\npublic string Periodicity { get; }\npublic string CacheValue { get; }\npublic string CacheLastUpdateTime { get; }\npublic string DbValue { get; }\npublic string DbLastUpdate { get; }\npublic string Validation { get; }\n\npublic Finding(\n  string sheet,\n  string range,\n  string companyId,\n  string mnemonic,\n  string timePeriod,\n  string periodicity,\n  string cacheValue,\n  string cacheLastUpdateTime,\n  string dbValue,\n  string dbLastUpdate,\n  string validation\n) {\n  this.Sheet = sheet;\n  this.Range = range;\n  this.CompanyId = companyId;\n  this.Mnemonic = mnemonic;\n  this.TimePeriod = timePeriod;\n  this.Periodicity = periodicity;\n  this.CacheValue = cacheValue;\n  this.CacheLastUpdateTime = cacheLastUpdateTime;\n  this.DbValue = dbValue;\n  this.DbLastUpdate = dbLastUpdate;\n  this.Validation = validation;\n}\n\npublic Finding With(\n  string sheet = null,\n  string range = null,\n  string companyId = null,\n  string mnemonic = null,\n  string timePeriod = null,\n  string periodicity = null,\n  string cacheValue = null,\n  string cacheLastUpdateTime = null,\n  string dbValue = null,\n  string dbLastUpdate = null,\n  string validation = null\n) => new Finding(\n  sheet: sheet ?? this.Sheet,\n  range: range ?? this.Range,\n  companyId: companyId ?? this.CompanyId,\n  mnemonic: mnemonic ?? this.Mnemonic,\n  timePeriod: timePeriod ?? this.TimePeriod,\n  periodicity: periodicity ?? this.Periodicity,\n  cacheValue: cacheValue ?? this.CacheValue,\n  cacheLastUpdateTime: cacheLastUpdateTime ?? this.CacheLastUpdateTime,\n  dbValue: dbValue ?? this.DbValue,\n  dbLastUpdate: dbLastUpdate ?? this.DbLastUpdate,\n  validation: validation ?? this.Validation\n);\n\n}\n```\n. @bender2k14 It seems like the main issue I'm having is that there is a mismatch between applicative functors(AF), monads, (as far as I understand them), and operating on collections of monad and AF results as two complete sequences. Working with monads and AF seems to work well when  you want to apply single actions to the monad or AF but not great when you want to operate on the whole set returned from a collection of monads without multiple iterations. I don't really mind the multiple iteration for this particular use case since the files will only ever be in the hundreds of thousands, but I think for much larger datasets I would probably use something have a validation function that returns a tuple like (IEnumerable, IEnumerable), because I really don't want either-or, I want both.\nThanks for all your help. I'm going to close this as I'm satisfied with my current solution, which is \n```\npublic class CellData\n    {\n        public CellData(string sheet,\n                        string range,\n                        CompanyId companyId,\n                        Mnemonic mnemonic,\n                        DateTime timePeriod,\n                        Periodicity periodicity,\n                        string value)\n        {\n            this.Sheet = sheet;\n            this.Range = range;\n            this.CompanyId = companyId;\n            this.Mnemonic = mnemonic;\n            this.TimePeriod = timePeriod;\n            this.Periodicity = periodicity;\n            this.Value = value;\n        }\n        public string Sheet { get; }\n        public string Range { get; }\n        public CompanyId CompanyId { get; }\n        public Mnemonic Mnemonic { get; }\n        public DateTime TimePeriod { get; }\n        public Periodicity Periodicity { get; }\n        public string Value { get; }\n    public static Either<Finding, CellData> CreateFromRawData(RawData rawData)\n    {\n        var validCompanyId = CompanyId.Validate(rawData.CompanyId);\n        var validMnemonic = Mnemonic.Validate(rawData.Mnemonic);\n        var validTimePeriod = TimePeriodValidation.ValidateTimePeriod(rawData.TimePeriod);\n        var validPeriodicity = Periodicity.Validate(rawData.Periodicity);\n\n        var validationResult = (validCompanyId, validMnemonic, validTimePeriod, validPeriodicity)\n            .Apply((id, m, t, p)\n            => new CellData(rawData.Sheet, rawData.Range, id, m, t, p, rawData.Value));\n\n        var eitherCellData = validationResult.Match(\n            Succ: Right<Finding, CellData>,\n            Fail: f => Left<Finding, CellData>(Finding.CreateInvalid(rawData, string.Join(\", \", f)))\n        );\n\n        return eitherCellData;\n    }\n}\n\nstatic IEnumerable> LoadCellData(string fileName) =>\n            File.ReadLines(fileName)\n            .Skip(1)\n            .Select(ParseLine);\n    static Either<Finding, CellData> ParseLine(string line)\n    {\n        string[] values = line.Split(',');\n        var rawData = new RawData(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7]);\n        return CellData.\n            CreateFromRawData(rawData);\n    }\n\nstatic void Main(string[] args)\n        {\n            try\n            {\n                var options = Options.GetOptions(args);\n            options.Match(\n                None: () => WriteLine(\"Must specify a file.\"),\n                Some: o =>\n                {\n                    var fileName = o.Source;\n\n                    var data = LoadCellData(fileName);\n\n                    var erredFindings = data.Lefts();\n\n                    var findings = GetAndMergeDbValues(data);\n\n                    var results = erredFindings.Append(findings);\n\n                    WriteCsv(results, o);\n\n                    WriteLine($\"File successfully created!\");\n                });\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Errors: {ex.ToString()}\");\n        }\n\n```\n. ",
    "B-Reif": "Trying to do that gives me a type error; the signature expects a return value of a T.. I mean, I'm deliberately not interested in having any kind of return value in this case.. ",
    "zhengbli": "If anyone is also having this issue, I solved it with an extension method:\ncsharp\n        public static Task<Either<L, R>> Flip<L, R>(this Either<L, Task<R>> either)\n        {\n            return either.MatchAsync(\n                Right<L, R>,\n                Left<L, R>\n            );\n        }. ",
    "ErikFeeley": "I'm really interested in this as well. I'm hoping to work on a sample asp net core API that uses ef core and language-ext this weekend. Worst case scenario at least it might serve as a starting point.. Have not had the time to get on this yet : / High level though I want to build a simple Todo api using pretty standard asp net core stuff. Except I want to remove the model binder validation and use language-ext for that. Then also use language-ext for the actual meat of the api and working with EF Core.. ",
    "ehouarn-perret": "@ErikFeeley glad to know that I am not all alone :p. Actually, I have some plans to achieve something similar with a relatively simple kata project following DDD.\nI drafted the requirements for a full-stack application below (bigger than a todo api tho):\n\nWrite (little) program that shows how you handle the full stack from front-end to back-end.\n\nA user should be able to enter a new flight which has a departure airport and a destination airport.\nThis new flight should be persisted into the system so that it can be retrieved later on.\nBusiness logic should be able to calculate the distance between the two aiports their GPS positions and to calculate the fuel needed for this flight, given the aircraft fuel consumption per distance / flight time + takeoff effort.\nThe program should be able to list the different flights which are loaded from a persistence medium, technology for this can be chosen freely.\nIt should also be possible to edit a flight and persist these changes.\nA report page should be included that shows a summary of all entered data, including calculated data.\n\nPlease note that you are free to use the front-end framework (vanilla js, angular, vue, react or even Blazor!) that suits you the best as well as the persistence and infrastructure mediums, be it in memory DB, docker, vault for secrets and... whatnot :-)\nAlso a CQRS ES approach is preferred but not mandatory.\nPlease try to follow the holy TDD / BDD / DDD trinity when implementing.\n. \n",
    "costa100": "Thank you for taking the time to review the code and for the comments!\nRe: Dump() it is a function implemented in linqpad. I used linqpad to test the code. The using blocks are added in a separate dialog in linqpad, that's why they are missing from the code - sorry for the confusion.\nYes, I started to read the Functional Programming in C# book. Just a side comment, I wish he used your library instead of writing his own code - it makes it harder when you want to adopt the techniques and use the FP style, the concepts are similar but the code is not exactly the same.\n\nI think there is a key idea that you are missing. The purpose of validation is to guard the creation of strong types.\n\nYou make a very good point. Currently, my code is mostly imperative, however, I was looking at the validation classes to implement validation for configuration classes that receive values from the app.config file. My thought was to gradually introduce the FP style in the code. Validation is good start, I think.\n\ndo you think you can improve it based on my review of your first example?\n\nYes, your examples, NonnullString, NonemptyString etc. are very good. I can take it from here.\nThanks again. ",
    "doomchild": "How is that a BiMap at all, though?\nMaybe I'm leaning too hard on the Haskell idea of what these concepts mean, but bimap :: (a -> b) -> (c -> d) -> p a c -> p b d (from https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html) tells me that after a bimap has occurred, the left and right sides do not have to be the same type.  TryAsync.BiMap is requiring both sides to turn into the same type.  I would expect the signature to be BiMap<TResult>(Func<A, TResult> rightMorphism, Func<Exception, Exception> leftMorphisM).. Yeah, you could call it Match, and that would make sense, because all of the other Match methods coerce both sides of the disjunction into the same type. . ",
    "chyczewski-maciej": "@bender2k14, here's an even simplier version :)\n[Fact]\npublic static void IEnumerableOptionBindT_NotEnumerabled_NotEvaluated()\n{\n    new[] { unit }\n            .Select<Unit, Option<Unit>>(x => throw new Exception(\"Some proper message\"))\n            .BindT(Some);\n}\nor this \n```\n[Fact]\npublic static void IEnumerableOptionBindT_NotEnumerabled_NotEvaluated()\n{\n    ThrowOnEnumeration().BindT(Some);\nIEnumerable<Option<Unit>> ThrowOnEnumeration()\n{\n    throw new Exception(\"Some proper message\");\n    yield return unit; // Do not remove this line. This is required to generate a lazy IEnumerable sequence.\n}\n\n}\n```. ",
    "heemskerkerik": "No problem. Fixed.. "
}