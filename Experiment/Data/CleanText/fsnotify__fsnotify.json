{
    "nathany": "With internal package support in Go 1.4, it's possible that go/cmd could use fsnotify in Go 1.5 but not yet provide os/fsnotify. It just depends on whether or not fsnotify is ready to take on the Go 1 compatibility guarantee at that time.\n/cc @rsc @davecheney \n. There are some challenges to getting fsnotify into the standard library.\n- Designing a suitable (low-level) API.\n- ~~Not depending on C code.~~\nFSEvents (#11), at least in the current implementation contains C code.\n\n\"The goal of the dev.cc branch is to eliminate all C code from the Go libraries and then remove the C compiler that we have been maintaining as part of the toolchain.\" - @rsc http://golang.org/s/dev.cc\n\n~~Unless this only applies to C code like this and not cgo.~~\nThe net package uses C code, so this comment is probably specific to the libraries that are part of runtime. My bad.\n- The syscall dependency. Syscall is frozen as of Go 1.3, with any additions being made to x/sys. So far fsnotify doesn't require anything new in x/sys, but if it ever does, the necessary portions will need to become internal packages of fsnotify (to avoid having stdlib depend on x/sys).\n. Given the improvements to tools to vendor code (GO15VENDOREXPERIMENT) and support for internal/ packages, I see less value in trying to bring this into the standard library. If the go tool or godoc need to use fsnotify, it can be copied in as an internal package.\nMaybe an x/ package that uses Gerrit, the builders, and the CLA.\nOr if maintained as an independent package, perhaps the BSD license should be tweaked and the CLA requirement dropped.\n. @matthias-stone reproduced the issue:\n\nSo, looking at this in GDB the following squirrelly behaviour occurs: breaking and continuing the code \nclears the leaked file descriptors.\nExecuted with \nconsole\ngdb --args ./fsnotify.test -test.cpu=1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n-test.v -test.run=TestFsnotifyDeleteWatchedDir\nSample of leaked file descriptor - note the anon_inode:inotify\ntotal 0\nlrwx------ 1 matthias users 64 Jun 21 20:17 0 -> /dev/pts/40\nlrwx------ 1 matthias users 64 Jun 21 20:17 1 -> /dev/pts/40\nlr-x------ 1 matthias users 64 Jun 21 20:17 10 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 11 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 12 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 13 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 14 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 15 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:19 16 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:19 18 -> anon_inode:inotify\nlrwx------ 1 matthias users 64 Jun 21 20:17 2 -> /dev/pts/40\nlrwx------ 1 matthias users 64 Jun 21 20:17 3 -> socket:[289525025]\nlrwx------ 1 matthias users 64 Jun 21 20:17 4 -> socket:[289525026]\nlr-x------ 1 matthias users 64 Jun 21 20:17 5 -> pipe:[289525027]\nl-wx------ 1 matthias users 64 Jun 21 20:17 6 -> pipe:[289525027]\nlr-x------ 1 matthias users 64 Jun 21 20:17 7 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 8 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 9 -> anon_inode:inotify\n. I don't know what I'm doing :-1: \n\n```\nstrace: Can't stat './fsnotify.test': No such file or directory\nGNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1\n./fsnotify.test: No such file or directory.\n``\n. I noticed thatinotify_init1()has aIN_NONBLOCK` option in Linux 2.6.27+ (Go 1.3 requires Linux 2.6.23)\nhttp://man7.org/linux/man-pages/man2/inotify_init1.2.html\n. Also related: https://github.com/howeyc/fsnotify/issues/7\n\nDesire is to have the library send events/errors using select so that the receiving application can be monitoring the channels without the use of a separate goroutine.\n. #39 could solve this.\n. My current suggestion is to set the Op filter globally at the Watcher level instead of for each Watch added. Preferably in such a way that it cannot be changed later. Perhaps something like:\n\ngo\nwatcher, err := fsnotify.NewWatcher(fsnotify.Create|fsnotify.Write)\n- The filter can be passed to each adapter to have the OS filter out events the best it can.\n- A final user-space filter can catch any outliers without requiring the significant amount of bookkeeping of the previous implementation.\n- For the same reasons that directory watches are easier to manage, a user-space recursive watcher will be simpler to implement, whether included in fsnotify or externally.\n. @tsuna The problem with adding a new API like that is that the flags differ from platform to platform. That's partly why I'd like to split out inotify #173 so it can be used independently in special Linux-only cases.\nThis issue is tracking a more general solution, which may be a ways off yet.\n. Pull requests are welcome, and once we have more people reviewing and merging pull requests, things should start to move faster. \nI think breaking out the low-level platform specific libraries (such as #173) will also help there. It should allow experts in inotify to work on that without worrying about the cross-platform API, and others to tackle cross-platform consistency without dealing with all the low-level details.\n. leaking descriptors #59 didn't help any.\n. I've never even thought of extending it to webhook notifications like Dropbox and Google Drive provide. Interesting idea. Not sure if it belongs in this package, but having a common interface in top could be cool.\nThe sql driver model is one I've been thinking about, particularly if there are multiple options for a given OS.\n. Indeed. It also fits with another desire I have, which is to make it easier to contribute to without being knowledgable of every single platform. Separate drivers for inotify, kqueue, etc. would be one way to achieve that.\n. Yah, polling is the only option for NFS as far as I know. You can also check https://github.com/rjeczalik/notify but I don't think it has polling yet either.\n. Please do submit a pull request.\n. @omeid I don't have any plans for what a driver interface would look like yet (and to be honest, I haven't done much work on fsnotify lately).\nPersonally, I'd prefer to see the current code base cleaned up before doing a big API change. The Windows internals are particularity crufty. \nhttps://github.com/go-fsnotify/fsnotify/milestones/v2%20Internals\nMaybe we could start a new issue to figure out the details of transitioning to a driver model?\n. @cpuguy83 Do you think you would be able to add polling without changing the API? Maybe just for operating systems that fsnotify doesn't currently support?\nThere are other situations where polling would be desirable, but I'm not sure how to detect them, or if it should be done more manually (which is why a driver-style API is relevant to this discussion).\n. In terms of API, here are related issues #104 and #75. \nPolling should also help with #45 for Windows users.\n. @mdwhatcott @cpuguy83 Would you be willing to build a stand-alone fsnotify/polling package that could be incorporated into fsnotify as a secondary step?\nIf so, I'll create a repo called polling or poller or whatever you prefer.\nFor me the key considerations are:\n- providing a speedy implementation as outlined in the original post\n- a simple and idiomatic Go API specifically for polling\n- solid unit and/or integration tests (preferably without any external testing dependencies to keep it simple)\n- well documented both in the README, examples, and API docs\n. ok.\nHere is a polling watcher by @radovskyb https://github.com/radovskyb/watcher\n. @radovskyb Hey Benjamin, Would you be interested in transferring watcher into the fsnotify organization and working on it here? Still as a stand-alone repository for the time being.\nThe API already looks pretty close to fsnotify. \nOnce some of the low-level bits are extracted from fsnotify (e.g. #173) I'd like to incorporate polling into fsnotify as a fallback, while still allowing people to use the  poller directly if that's all they want.\n. Work has begun on this as an external project that can eventually be used from fsnotify.\nhttps://github.com/go-fsnotify/fsevents\nTODO:\n- [ ] Integration tests\n- [ ] Refine API\n- [ ] EventFlags.String()\n. Would it make sense to work in a monorepo for fsnotify? Bring the fsevents library into a subfolder and work on it here, even before it's integrated and used by fsnotify.\n. Some people are using fsnotify/fsevents so we'd probably leave it there and just move maintenance here. We could put a message up over there -- or not.\nI'm still undecided whether it should be internal/ here initially.\n. I'm also not sure if we should try to move fsnotify towards this new driver system (#104), or build out something entirely new. Perhaps coming back later to retrofit fsnotify on top of an intermediary API.\n. For me personally, my first step would be to get Vagrant setup with a Solaris box with Go installed. Preferably via https://github.com/nathany/vagrant-gopher.\n. @4ad Amit (@amitkris) is currently working on FEN support. Would you be willing to review his pull request when it is ready?\n. This is likely the cause of TestFsnotifySubdir fails intermittently on Mac OS X 10.9.2:\n- https://github.com/howeyc/fsnotify/issues/67\n- https://code.google.com/p/go/issues/detail?id=8147\n. no updates yet. the plan to fix this is to use FSEvents (#11) which currently exists as a stand-alone project but isn't integrated into fsnotify:\nhttps://github.com/fsnotify/fsevents\n. @kevinburke sorry to hear that. \ud83d\ude22 \nIs there something that could be added to the Spotlight mention in the README to improve finding the issue?. Each OS is likely to be a little different. Here's a little research on kqueue: https://github.com/go-fsnotify/fsnotify/issues/24#issuecomment-55539850\nEssentially: not watching the files in kqueue will result in no event at all when a file is touched/updated. (not even, hey, something changed in this directory)\nStill need to do research on inotify and Windows.\n. TextMate2 (OS X) use the exchangedata system call to perform the saves (not sure what that is). But Hugo users are having problems detecting saves: https://github.com/spf13/hugo/issues/1053#issuecomment-116778527\n. > Godoc is a relatively small program. It is built from 102 packages built from 582 source files. We certainly want to be able to build programs larger than godoc. It appears that Linux inotify will let you watch individual directories for changes within that directory, so for godoc you are looking at a little over 102 inotify watches. For OS X, fsevents will let you watch whole subtrees, so for godoc built from 1 GOROOT and 1 GOPATH entry you are looking at 2 fsevents watches.  For Microsoft Windows, FindFirstChangeNotification looks like it might be usable similar to fsevents. For Solaris, file event notifications (FEN) only apply to individual files or directories, and watching a directory inode does not appear to tell you about modifications made to files in that directory, so for godoc you are looking at almost 700 FEN watches. That might take a little while to set up, but assuming the kernel has no hard limits, it should be fine. Speaking of limits... For BSD (or OS X if you don't like fsevents), kqueue has the same \"enumerate every file or directory\" requirement as Solaris FEN, but you give them to the kernel not as file names but as file descriptors. It appears that the file descriptor must remain open while you are watching that file, so the per-process file descriptor limit imposes a limit on the number of things you can watch. Worse, the per-system file descriptor limit imposes a limit on the number of things anyone on the system can watch. The typical kernel limit on a BSD is only on the order of 10,000 file descriptors for the entire machine. - @rsc, https://groups.google.com/d/msg/golang-dev/bShm2sqbrTY/IR8eI20Su8EJ \n- The limits for FEN (Solaris) are high enough (#12) that a recursive watcher should be possible.\n- It's possible that kqueue (BSD, iOS) can't reasonably support a recursive watcher. For large trees, users may need to resort to Polling (#9) or another mechanism.\n. It should work. Most of the tricky issues are with too many resources being consumed. Also, we would ideally take advantage of native recursive watching on the operating systems that support it.\n. No update for fsnotify, but take a look at https://github.com/rjeczalik/notify as an alternative.\n. Rafal's notify library uses FSEvents on OS X instead of kqueue, so it doesn't have that problem on OS X. \n. As does fsnotify.\n. > Maybe the underlying file system event handling differs by platform.\nYes, it does.\n. Nothing yet.\n. This is closely related to #17 but specifically for Linux.\n. @rjeczalik Thanks for chiming in. I only heard of your notify project this past week. I'm really interested in taking a closer look at it.\n@edrex yah, there are too many little platform differences to trip up on. :dizzy_face: \n. I've written a rudimentary implementation of kqueue (on OS X):\nhttps://github.com/fsnotify/fslog\n. I tried a nil timeout but there is more work involved. Currently syscall.Close(w.kq) is in the same for loop that blocks. Instead it should be called directly by watcher.Close() which will cause the read to abort, after which it can clean up and return.\n. FreeBSD 10.0 behaves a bit differently:\n- Closing the kq descriptor doesn't abort the current read, in fact I still get the next event.\n- Then when setting up the next read, we of course get Kevent: bad file descriptor.\nIt's not a huge deal if we're calling Close() before shutting down the app, but if not, then the Read goroutine will sit there blocking until it gets another event to send over the channel. And if I do a proper cleanup to DELETE the events, that next event will never come.\n. When registering file descriptors to watch, this could be useful if registering multiple watches at once (such as all the files in a directory):\n\nIf an error occurs while processing an element of the changelist and there is enough room in the eventlist, then the event will be placed in the eventlist with EV_ERROR set in flags and the system error in data. Otherwise, -1 will be returned, and errno will be set to indicate the error condition. \n\nOtherwise I don't think I need to check for EV_ERROR. Fsnotify was doing this check, but eventlist was nil, so it should never be the case.\n. When watching a directory with kqueue it reports:\n- a Write when a file is created or deleted\n- a Write and Link when a subdirectory is created or deleted\n- nothing at all when a file is touched (updated)\n- but it does report a Write if modified by an editor that does an atomic save (create and rename)\nfsnotify currently adds to this:\n- watches all files in a directory to report updates to specific files. \n- watches for deletes on subdirectories to report the deleted subdirectory, not just a Write+Link\n- when a Write happens on a directory, it scans the directory for any new files/subdirectories and presents them as create events\n. In relation to #16, I was thinking of actually having an event of \"something happened in this directory, but we don't know what.\" Then the scanning and comparing of the files in a directory could be a separate utility function instead of built into readEvents(). It could be used for determining which directory was deleted as well.\nBut there is still the problem of touching files not reporting any event at all. As well as making the calling code different for kqueue.\n. Leaving this in for now as a debugging aid. it doesn't prevent anyone from writing a utility function to represent Event in another way. \n. @jaytaylor this is still something I need to research across platforms to see what can be done. Sorry for moving so slow,\n. @jmhodges Do you have any more details on \"Weird Things\" vim does? Is this when saving or is there a rename file function people are using in Vim?\n. ref: https://github.com/rjeczalik/notify/issues/78\n. not as of yet.\n. Thanks.\nHave you already signed the Go CLA? See the README. \n. Merged as fcd23cde655be3a4e721bd452abc33400136291c.\nThanks!\n. I suppose one disadvantage is that other (possibly temporary) repos such as go-fsnotify/fsevents couldn't make use of gopkg.in?\n. Good point. And I could create go-fsevents if that project took a life of its own.\n. A little maddening for autocomplete on the command line. go-* Oh well.\n. Whoops. Thanks @mewmew.\n. Thanks for the suggestion. The current API isn't final for sure, we definitely want to change how error handling works: #2.\n. There was an issue opened at https://github.com/howeyc/fsnotify/issues/7 regarding the requirement for a goroutine in the calling code.\n5 is part of looking at that, specifically on Linux.\nfor BSD I've found that having kqueue block #24 results in less CPU utilization when idle, but doing so may make it harder to avoid having a goroutine in the calling code\n. @akavel Add() isn't recursive right now. See #18, #21 and #11.\nThe documentation certainly needs some work. I will leave this issue open until that happens. Thanks.\n. That may be a limit of kqueue when there is no watch on the file/directory where the file is being moved/renamed to. I need to take a closer look.\nI'm going to close this issue in favour of a #26.\n. FSEvents (OS X) and Windows have support for recursive watching. I'm not yet sure how they behave when doing mkdir -p a/b/c. Once that is determined, it may make sense to emulate that behaviour elsewhere.\n. Thanks @zhsso. I'll test it out shortly.\nDo you happen to know the difference between filepath.Clean and path.Clean?\n. Thanks for looking into it. Sounds like we're on the right path. :stuck_out_tongue_winking_eye: \nI'm going to tackle #34 before I merge this in and do a new release later today.\n. @zhsso I forgot to mention\nContributors retain their copyright, so we need you to fill out a short form before we can accept your contribution: Google Individual Contributor License Agreement.\nHave you already signed the Go CLA?\n. Thanks very much @zhsso.\n. While renaming the tags is easy enough, it also makes it look like I've been doing breaking changes in the v1 line. I'm inclined to just remove the tags for v0.10.0 through v0.14.3 entirely. \nDoing so accomplishes the same goal of getting v0 to match howeyc/fsnotify while v1 is the new API.\n. Deleted tags:\n- 'v0.10.0' (was 56a7b52)\n- 'v0.10.1' (was 620bfd9)\n- 'v0.11.0' (was b97c307)\n- 'v0.12.0' (was efe9224)\n- 'v0.13.0' (was 4a0c411)\n- 'v0.14.0' (was 960fdf5)\n- 'v0.14.1' (was 06d7792)\n- 'v0.14.2' (was f65830e)\n- 'v0.14.3' (was 2acad09)\n. importers of go.exp/fsnotify on bitbucket:\n- https://bitbucket.org/kardianos/service/pull-request/8/use-fsnotifyv0/diff (updated to v1 with https://bitbucket.org/kardianos/service/commits/562e4b3201a3d51f2d963044ab7823d17970ab91)\n- https://bitbucket.org/ronoaldo/whenchange/pull-request/1/use-fsnotifyv0/diff (merged)\n. @kylelemons I don't know how to submit a pull request to http://kylelemons.net/browse/gitweb.cgi/go/gofr.git/tree, but please checkout fsnotify.v0 or v1.\n~~I don't know why https://github.com/laughlinez/flow is listed in importers because I see no reference to fsnotify in its code or in https://github.com/jcw/flow from which it was forked. /cc @garyburd~~\nThat takes care of everyone importing from go.exp/fsnotify, except for forks of other repositories.\n. This conversation sums up the confusion around having several places to find fsnotify: https://github.com/bmatsuo/gutterd/pull/2#issuecomment-52442275\n. @garyburd Sorry, I don't know why I didn't see that. :blush: \n. An open letter suggesting that go.exp/fsnotify be deprecated in favour of this repository.\nhttps://groups.google.com/d/msg/golang-dev/-__vD-kOF5s/v8eLY271-ucJ\n. As it turns out, there are others using go.exp/fsnotify that don't appear in the importers list.\n- https://github.com/coreos/nova-agent-watcher\n. CL to remove x/exp/fsnotify\nhttps://go-review.googlesource.com/#/c/3990/\nHere are the commits to x/exp/fsnotify:\nhttps://go.googlesource.com/exp/#\n. HI Yukang. Thanks for the submission.\nThis example doesn't actually send anything over the done channel, so I'm not 100% sure. \nI suppose having the example not exit immediately is good, even if Ctrl-C is required.\n. Alright. You win. :smile:\n. Just some C code that uses kqueue and inotify. Might be some useful tidbits, like their check_create for kqueue does a timestamp comparison before a (slower) hash lookup.\n. Thanks for working on this @chamaken. I left a few comments.\n. Feel free to add more commits here or open a new pull request.\nEpoll vs. select is up to you. Whichever works better.\nThanks @chamaken \n. @chamaken I'm not familiar with either, so I don't know. \nWe could try epoll and see how it goes. We could also request a code review from people on golang-nuts and see what we get back?\n. @chamaken Since I don't know when I'll read my Linux book and figure this stuff out, I put out a request for code review on golang-nuts.\n. Sorry for letting this sit for so long. \nEven though this isn't changing the API, I'm beginning to think that such big internal changes should also warrant a new major version and a release candidate, which is something gopkg.in is considering support for: https://github.com/niemeyer/gopkg/issues/25.\nI'm still figuring out exactly what this should look like.\n. Hi @chamaken,\nI think this is too big of a change for right now. Personally, I still haven't had a chance to learn the various Linux APIs nor have I been able to attract others to help code review and maintain the project.\nIf you're interested in helping make some smaller incremental improvements, I'd certainly be grateful. Right now I'm trying to focus on cleaning up the code (see 1f65e2ef12aa538ba66b432a0c60279f4406add1) so that lower-level concerns are more isolated.\nI'm also trying to get an fslog project going to help better understand the behaviour of each OS.\nThanks for all your work. Nathan.\n. Thanks for the report. I think #39 may address this for inotify. \nIn any case, #39 is a pretty big change, so let's get that in first. Feel free to give it a code review.\n. Right now I can only think of two possible ways to remove recursive watches for #18:\n1. keep track of all the folders we watch, this would be like asking it to remove a specific watch we added\n2. just walk the subfolders of a path and remove any watches that exist\nI'm in favour of 2, as additional watches could be created, and the API at present takes a path rather than a handle to a previous watch.\nHowever, I'd still like to see how Windows and FSEvents (OS X) handle recursive watches and removals before tackling this... which puts it a fair ways off.\n. Quite some time ago I attempted to track all the watched folders independently, but ran into an issue much like #40 in kqueue. I thought the watches were just magically removed when the folder was deleted, but I may have been wrong. (https://github.com/nathany/looper/commit/212051b2ac2b741ac055c68b4ff1434f870401e4)\nIt might be worth building a small test case to see if unwatching deleted folders is necessary. I started hacking on fslog as a place to do those sort of experiments (without all the other stuff fsnotify adds). But so far it only has kqueue.\nIt should be relatively easy to resolve #40, but I'd rather not expose w.watches as an API. It's supposed to be an internal detail.\n. So for 2, fsnotify should itself watch for remove event and do the internal cleanup of w.watches. That could be tricky later on if the user doesn't wish to subscribe to remove events (#7).\nBut for now, my focus is on cleaning up the existing code, primarily separating the lower-level stuff out. Also doing more research as with 1. Fixing #40 and doing the internal cleanup could fit into that.\n. also see #51 \n. Thanks. Is this occurring specifically on Linux?\n. @ottob Thanks for trying this out.\nI presume you did a git bisect to identify that particular commit as the source of the issue?\nDo you have the code that's using fsnotify from this branch? Somewhere at https://github.com/ottob/revel?\nBasically, I need to get a test case to figure out what's going on and prevent this from breaking in the future.\n. Sounds like a difficult issue to track down. I did introduce a bug in 5997fa2 that was fixed in 8a7f75d. I may rebase pull request so that individual commits aren't introducing bugs (for the benefit of bisect).\n. @ottob I read through Revel's watcher.go.\nI'm not sure if this will help with the problem you ran into, seems unrelated. https://github.com/revel/revel/pull/734\nWhich OS are you using? Mac or BSD?\n. @ottob Could you try to get a reproducible case with one of the sample apps and provide me the steps and OS you're using with a new issue?\n. Thanks @ottob. I haven't figured out Revel, so I'm pretty helpless trying to reproduce it.\n. @ottob Ugh. Thanks for digging into this more. Would you mind copy/pasting your last response into a new issue so it doesn't get missed? Thanks.\n. For sure. Thanks for the heads up Quinn.\n. @sqs Does the fancy linking stuff only work for code that compiles on Linux?\nI don't see any fancy stuff for this BSD file:\nhttps://sourcegraph.com/github.com/go-fsnotify/fsnotify@master/.tree/kqueue.go\n. Or maybe I just need to wait a bit... https://sourcegraph.com/github.com/go-fsnotify/fsnotify/.builds/515146\n. I'm not sure. It would certainly be nice to have a better error message. \n. I don't have SharePoint, so I'm not able to reproduce this issue.\nAccording to the Windows documentation:\n\nIf the network redirector or the target file system does not support this operation, the function fails with ERROR_INVALID_FUNCTION.\n\nSo I guess that explains it. \nMaybe I should add that to the FAQ, or we could change how this error is reported at https://github.com/go-fsnotify/fsnotify/blob/master/windows.go#L353.\n. strace and gdb with go test -c from #3.\n. Hm. Interesting. Which operating system?\n. Hi Otto. Sorry for not digging into this sooner. I've never used Revel before, but I got the booking sample running with some additional logging (on the develop branch).\nYour previous bisect had pointed to 4a0d1ae9df8c61fb8912829fc714f189358a3dc7 being the culprit. Most of those changes are to addWatch, so I added some logging there and compared against ca50e738d35a862c379baf8fffbc3bfd080b3cff. With the result you're seeing, it seems plausible that it was watching more than it was previously. \nSo far I haven't figured it out. Still digging. It might be worth confirming that bisect, since you said it wasn't 100% reproducible. If it was a commit before, that could change things quite a lot.\nIf there was a medium sized open source Revel app that we could reproduce this on, that would make it much easier. It might even be reproducible with a similar file structure to your app, even if those files don't contain the same code. /cc @robfig \n. @ottob I hope you have Spotlight disabled for your folder, which can randomly decide to create events. https://github.com/go-fsnotify/fsnotify/wiki/FAQ. \nThough if not disabled, I'd expect you'd see the same problems on v1.0.4 as well.\n. \n. I've ran into a very similar issue here. https://github.com/nathany/looper/issues/18 It is reliably reproducible. Looking into a fix now.\n. @ottob I believe this to be fixed on master. Stupid mistake on my part. Sorry for all the trouble.\n. Feel free to reopen this issue if you still see the issue.\n. It depends a lot on which OS you're using, but you probably want to watch the directory that you will be creating a file in.\n. syscall.ERROR_MORE_DATA was added in Go 1.3.\nAre you willing to upgrade? http://golang.org/dl/\n. Thanks. I put a mention of Go 1.3 in the README for next time.\n. Thanks for the detailed report. I haven't had a chance to play with the example yet.\nOS X is using kqueue, but this may be similar to #40 on Linux (inotify) where fsnotify isn't cleaning up it's internal data for watches.\n. Thanks to your example, I did manage to reproduce the issue on both v1.0.4 (before a bunch of my refactoring) and on the current master. I added some logging into addWatch in kqueue.go.\nkqueue.go is maintaining some internal state to map back and forth between filenames and descriptors. If it's a file descriptor that is already being watched, it can modifies what flags are being watched. This is something used internally.\nWhen a rename or remove event is fired, it calls the exported Remove() method to do some cleanup. For whatever reason it's sending the event on the channel and then doing the cleanup.\nThat's been this way since I adopted the code. Flipping those around makes sense to me.\n. The fix is on master. Doing a release soon.\nIf you have a chance to test it out, please let me know how it goes.\n. Thanks Matt!\nLooking forward to your next contribution. :grinning: \n. Until now I hadn't heard of USN Journals. It sounds worth looking into.\nIs this the state-of-the-art not in just Windows 2000, but also Windows 7, 8, 10?\nWe do have working code for Windows based on ReadDirectoryChangesW. It is based on winfsnotify and everyone who's contributed to it has agreed to the CLA.  \nBut it does need a lot of love (see #6 and #21), and I'm certainly not opposed to doing a fresh implementation if there are APIs that can provide better reliability and closer feature parity to other operating systems.\n. FYI, Go currently requires Windows XP or later, so there is no need to support anything older than that.\n. Is it possible to use USN Journals without Administrator privileges?\n. That's a bit unfortunate.\nDo you want me to create a Windows USN repo under go-fsnotify?\nWe could bring the code over and make sure everything still works in Go 1.3 & 1.4.\n. Nope. Nobody ever was.\n. Hi. So far this issue has just been a place to collect information about USN. Nobody has begun implementing support for it is fsnotify.\nTo support USN directly in fsnotify, I think we'll need a driver system where people can choose between ReadDirectoryChangesW or USN much like choosing a MySQL or Postgres driver. To start, my suggestion would be to build up a stand-alone USN package and then we'll figure out how to integrate it.\nThat could be as a subfolder of this repository or a separate repository (I'm happy to create a repo under the go-fsnotify organization if desired).\nThere's also plenty of clean up work to do on the current Windows support.\nhttps://github.com/go-fsnotify/fsnotify/labels/Windows%20%28ReadDirectoryChangesW%29\nThanks\n. If someone is interested in implementing USN, we would probably start by getting it working outside of fsnotify (much like the fsevents package), and then look at bringing it in afterwards.\nLet me know if you're interested.\n. Hi @jimzhan. Thanks for the report. I need a little more info.\nHow are you writing to the file? Are you using a text editor #17 or touch?\nAre you watching an individual file or he directory containing the file?\nThanks.\n. @jimzhan It's likely to do with \"atomic saves\" in VIM. See #17.\n. I'm not sure what the simple delay trick is? When I use fsnotify, I just treat Create and Write as the same.\n. Thanks for following up. \n. Yah, it would be nice. But unfortunately that's more to do with how the underlying event monitoring systems work and how editors save files than with fsnotify.\n. Hi Matt. Right now it's necessary to launch in a separate Go routine, see https://github.com/go-fsnotify/fsnotify/blob/master/example_test.go\nThis is something that we should address though.\nref also in howeyc/fsnotify https://github.com/howeyc/fsnotify/issues/7\nI'm not sure if a buffered channel will solve it, but I could give it a try.\n. I tried running this second example and it didn't deadlock here (OS X 10.10 here too).\ntouching a file in the same directory touch fsnotify_issue55.go resulted in an event at which point it breaks to Loop and sends a message over the done channel and exits.\nselect will wait for an event from one of these channels. if you don't want to wait, you could add a default: case. I don't think buffered channels would help, that's just the behaviour of select.\n. No problem. More on select:\nhttps://gobyexample.com/select\nhttp://golang.org/ref/spec#Select_statements\n(In particular bullet point 2)\n. Ops are a bit mask so it is a combination of events (4 as well as 2)\nSee the example_test.go to check for individual flags.\n. Thanks for reporting this.\n. @PieterD I'm looking this on OS X and BSD, but it also fails on Linux:\nusing import \"github.com/go-fsnotify/fsnotify\"\npanic: inotify_init: too many open files\n. Excellent.\nkqueue:\nThis is interesting, as Close just calls Remove for all watches. Another race condition? \nClose is ignoring the errors that Remove sends back, in this case: \"bad file descriptor\"\n. Thanks @PieterD. I've already merged a fix for OS X, but I have yet to tag a new release. Tomorrow once the epoll stuff is in.\n. @meatballhat Looks like everything is working. Thanks!\n. If you run into the same issue with this repo, please let me know what OS you are using and some example code if possible.\nI should really send a CL to remove x/exp/fsnotify.\n. Thanks Pieter.\nx/exp is quite a ways behind this repo, but very little has changed on Linux.\n. Thanks for the example. I'll try to take a look on the weekend.\nIf you want to try adding some logging into inotify.go and poke around, any help would be appreciated.\n. Thanks very much!\nI'll take care of exp/fsnotify.\n. merged.\n. I sent in a CL to remove exp/fsnotify. https://go-review.googlesource.com/#/c/3990/1\n. merged.\n. Thanks.\n. Have you confirmed that #3 is fixed by this change?\nI'll take a closer look and do some QA tomorrow before I merge it in. Thanks again for the help.\n. @PieterD Have you already signed Google's CLA for contributing to Go? (This code base originates from Go exp packages and may one day land in Go).\nhttps://developers.google.com/open-source/cla/individual\n. Thanks. I'm on my way to a hack day, fsnotify will be my project for today.\n. And then it gets interesting. :-)\n. Does IN_NONBLOCK help at all? See #5.\n. I admit I don't understand this stuff. I'm yet to become a Linux guru. :-)\n. A separate PR would be appreciated. Let me get this tested and merged in.\n. \u00fcbermess!\n. Hah. \"awesome\" race conditions. So awesome that -race didn't catch it.\n. For the changelog, #5 isn't actually solved yet, correct? (coming next)\n. Squashed and merged. \n5. Doesn't readEvent still block though? That little hack to wake it up on Close might work, but maybe not?\n. kqueue has a timeout right now so that it doesn't block indefinitely, but it does use a little bit of CPU to go around the loop every 100ms.\n. I'm wrong about this. It's fine.\nWe want to run filepath.Clean(name) on user-input.\n. I'm not sure how I should test this. Based on #59, the second Add should reuse the same file descriptor because Close cleaned up. But I don't want to expose file descriptors to the API.\n. guess i can add a kqueue_test.go for that. ok\n. I like how you separated the poller out into a separate file. But man, this makes it so much more complex.\n. Should there be inotify_poller_test.go?\n. Interesting. \nAnother proposal is to have something like Sys() interface{} in FileInfo to retrieve the underlying event data (OS specific bitmask). \nThat doesn't address filtering though.\n. Wow, that is odd. Your code looks good to me, so I'm going to have to do some digging.\nWhat is your import path and is fsnotify the very latest version?\n. @pbdeuchler It's this line right here:\ndefer watcher.Close()\nNothing in Run() is blocking. When it returns we close down the channels, and closed channels always receive the zero value (which is nil for interfaces like error).\nYou probably want to define a separate func (dr *DiskRecieve) Stop() error function to call Close later on in your program execution.\n. event.Op&fsnotify.Write == fsnotify.Write will never succeed when Events is returning a zero-value Event struct.\n. @PieterD I like how we both saw the issue at the exact same time. :smile: \n. A failing test on a new branch would be a good way to start. :-)\n. The FAQ should be clarified. \nIt means that the main goroutine can't be used because it will block.\n. Not Add specifically, but the run loop that NewWatcher kicks off. I think it depends on the OS, whether or not the Kernel is blocking. It would be nice to handle all this better internally, but I haven't looked into it that deeply yet. :disappointed: \n. That error would be coming from here: https://github.com/go-fsnotify/fsnotify/blob/master/windows.go#L448\nUnfortunately I don't know the Windows code very well yet. It was inherited from Chris Howey's version of fsnotify, which was inherited from winfsnotify.\nIf you manage to add enough to a code example to reproduce the issue, that would really help.\n. Sorry, I'm still not really sure. :disappointed: \nAre you using just an ordinary local directory? And you say it's when there are a lot of files? With a few files it works? Maybe I can reproduce the issue. That would be a good first step.\n. Thanks for the info. I'm not sure when I (or someone else) will have a chance to dig into the Windows code for fsnotify to figure out what's going on. But any details to help reproduce it are helpful.\n. Thanks @chamaken. I can take a look sometime over the next few days.\n. Sorry, I still haven't checked this. :-(\n. Merged. Thanks.\n. Thanks for investigating this @tsuna. Would you mind opening a new issue so this doesn't get lost?\n. Yes. I think we should take another look at this code change. Adding and removing watches from the same goroutine should not cause deadlocks.\n. @metakeule You're right. It does depend on the OS.\n23 is a little project I'd like to do to get a better sense of what each OS is doing. Importantly, that would be done at a lower-level than fsnotify, since fsnotify adds some things on top.\nThen I'd like to take that research and write about on the website: https://github.com/go-fsnotify/fsnotify.org So far I've dived into kqueue (BSD, OS X), but have yet to write anything up (other than some notes in #24). There are a few more things I need to look into as well, such as renaming #26.\n. What I like most is that fsnotify and other libraries are free to experiment with different APIs and ways of using the underlying bindings. The lowest common denominator interface vs. emulating features in user-land vs. driver-like systems. Meanwhile the bindings themselves can be really solid and reused.\n. #173 seems like a good place to start\n. Thanks for taking the time to contribute.\nBut I don't really want to add methods to the Event struct. My preference is to keep a minimal API surface with the bitfields exposed for checking, coalescing, etc. This is based on the design document mentioned in the README.\nIf you wants additional methods like this, it's easy enough to convert to a new type and provide them there.\nAn article on how to do this (and how bitfields work) would be a better approach IMO. Happy to take contributions to the fsnotify.org blog:\nhttps://github.com/go-fsnotify/fsnotify.org\n. The use of bitmasks and creation of a wrapper could be documented on the blog. Would anyone like to write it up? https://github.com/go-fsnotify/fsnotify.org\n. I'm closing this in favour of documentation or a blog post. See #107. Pull requests to the website repo are welcome.\n. Strange. I was pretty sure the the go routine would make a difference (https://github.com/go-fsnotify/fsevents/issues/11).\nl need to find some time to try out your example.\n. Apparently not. fsnotify uses inotify under the hood when running on Linux:\n\n/proc is a kernel interface. There are no real files there, hence they can't change. Reading from the handles is a request and the data in the file when you read it is a reply to that. - StackExchange\nThe data that you see when you read from the proc filesystem is generated on-the-fly when you do a read from the begining of a file. That is, doing the read causes the data to be generated by a kernel callback function that is specific to the file you are reading. \n. Hi Wang Jing,\nThis looks unusual. Was there a test.yml file there before? When a REMOVE event happens, it stops watching that file, but I haven't yet looked into this scenario where the file is overwritten.\n. The events from the underlying system are largely unmodified, resulting in differences from one platform to the next.\n\nI'm not sure what the best solution is right now. I don't know if it will always be possible to present the same result across 4-5 platforms.\n. One solution would be not support watching individual files at all. I think that might be the approach that https://godoc.org/github.com/rjeczalik/notify takes. FSEvents on OS X also seems geared towards watching directories instead of files. \nOf course, if a directory is (re)moved, you may still have to watch one level up to see what happened.\n. Maybe there should be a flag indicating if the event is a dir or file event?\n. That would be nice. The question is whether we can add that across each platform without introducing additional overhead (Lstat when not needed).\n. ref #83 \n. Merged. Thanks\n. Moving the String() method does sound like a good idea.Thanks\n. Windows is already supported. See the README.\n. There can be (and sometimes are) multiple Ops in an event. That's why it is a bitmask.\n. @techjanitor for your info, #165 has been merged, resolving the issue you set out to with this pull request.\n. If you can share some sample code to reproduce the issue, that would be helpful..\n. Revert to polling #9 or report an error like #45.\n. @omeid Not as of yet. See https://github.com/go-fsnotify/fsnotify/milestones\n. Hi David,\nThanks for the pull request. Is this meant to address #22?\nThe thing that I'm not sure about is operating systems other than Linux. With this change, there is a Closed event that doesn't mean anything outside of Linux. Hm.\n. I hope you don't mind working off a fork until we come up with a better solution.\n. Quite odd having different behaviour between different Linux versions. Different versions of the kernel, perhaps? Or maybe different versions of vim?\nCan you reproduce the issue usingtouch from the command line instead of an editor? See #17.\n. If you are watching an individual file and it moves, it may no longer be being watched. Better to watch the directory the file is in.\nIf you believe there is a bug, can you please provide more details, such as operating system you are using and a code snippet to reproduce the issue? Thanks.\n(sorry for the late reply)\n. @kkirsche sorry, I'm not sure I follow what's happening in your example.\nmoving/renaming doesn't work so well with the underlying OS notification systems #26\nbtw, which operating system are you testing on?\n. @kkirsche Glad you got it working. Do you have any suggestions for improving the example code or documentation?\n. This is on Linux? Do you think you could provide a code snippet that reproduces the issue? Thanks.\n. I'm not sure if I understand. Op is a bit field with only 5 bits. It should not overflow even an 8-bit int, and it is a 32-bit int.\n. Oh. I've never heard of it.\n. I'm not entirely sure. A git blame points back to this issue in howeyc/fsnotify https://github.com/howeyc/fsnotify/issues/36.\nI don't like the idea of ignoring events either.\n. Thanks Evan. \nIt looks like there is an unrelated problem in CircleCI and Travis. I'll look into it.\n. Merged to master. Thanks.\n. Yup. v1.2.1 released with this change.\nhttps://gopkg.in/fsnotify.v1\n. yikes. What OS did you encounter this on?\nIf possible, can you provide a small code sample that reproduces the issue?\n. If it occurs consistently, you could try changing that lock in your local copy of fsnotify to see if it solves the issue.\n. Hi Uwe. Any updates on this? I haven't ran into the issue yet myself.\n. That might do the trick, but without being able to reproduce the issue, I don't want to just change code and hope it works. Much better if @djui tries it and proves that it fixes his issue.\n. @ppknap I like your plan of using a temporary map. Would you be willing to write up a pull request along with a test case?\nUPDATE: oh, you did add a test case #102. Thanks! For some reason it's not failing on travis-ci running on OS X which does use kqueue.\n. Good idea. Thanks.\n. @djui The race detector isn't finding any races for me on OS X 10.11.2 with Go 1.5.2 or tip, but I've added --race to Travis CI (which includes OS X).\nOn the other hand, there are two races happening on Linux. Looking into those in #105. \n. Oh. It showed up now, thanks to @ppknap's TestRemoveWithClose. Not sure why it didn't show up immediately after I merged that in, but oh well. Looking into it.\n. Please review #105 and when all is good I'll do a new release.\n. Thanks.\nGo itself only requires Linux 2.6.23 or later with glib, so I should add a note to the README about 2.6.27.\n. I'm not sure what the stats are. That's a good idea to look into it. Preferably we won't need a kludge to support the older kernels, but mentioning it in the README and release notes is important.\n. No, sorry for the delay. \nI'll merge some things and do a release later today.\n. Merged. Thanks Riku.\nI'l do a new point release after looking at a few other pull requests.\n. Thanks for the PR. \nRegarding the Linux test failure, I've triggered a rebuild, so we'll see if Travis is just being flaky.\n. Merged as https://github.com/go-fsnotify/fsnotify/commit/2cdd39bd6129c6a49c74fb07fb9d77ba1271c572 and released as 1.2.5. Thanks!\n. I  should add script: go test -v --race ./... to use the race detector on Travis.\n. I'm closing this as it's included in #105, which is on the race branch. Thanks.\n. The current solution is to filter out the events you get back. Indicating which events to watch is an optimization, though not all platforms will be able to filter the same way. Please take a look at #7.\nI'm closing this is a duplicate. If you want to take a stab at it, I'd be happy to review a pull request. Feel free to discuss further at #7.\n. API changes are using Events() and Errors() instead of fields in the platform-dependent struct and returning a FileWatcher interface instead of a *Watcher struct.\nMaybe there is another way to do this that makes the drivers/bindings satisfy an interface, but keeps the existing API as is.\n. I'm not sure if I want to see this much API churn in fsnotify itself. At least in the near-term.\nRather, I'd just like to see the fsnotify split into some independent packages (#75) for each OS while keeping the current API more or less the same. Having those low-level packages in place should enable more experimentation at the higher levels in alternatives to fsnotify.\n. Personally, I'd like to keep the fsnotify API as simple as possible, without requiring the user to know which driver to use. This could be an internal implementation detail at all.\nFor those that need more control, the individual OS-specific packages could be used directly.. I've rebased in squashed commits to (somewhat) avoid test failures in the history.\n. Thanks for your review.\n. Hi @tiwaana. Just prepare a Dockerfile in a pull request that can be used to locally test Linux, with some instructions to do so. The tests (go test) should pass in the container.\n. Part of this move would be to adopt @rjeczalik's notify library as an alternative available from the same organization. Any low-level \"drivers\" for specific platforms would also exist under the new organization.\n. I'm planning to rename the organization as well, since the \"go-\" prefix is a gopkg.in thing.\n. I'm preparing to rename the organization now.\n. The move to https://github.com/fsnotify/fsnotify is done, though I have to ensure CI is still working and update the website.\nGitHub automatically redirects https://github.com/go-fsnotify/fsnotify to https://github.com/fsnotify/fsnotify.\nI tested go get gopkg.in/fsnotify.v1 and it still works, which I did not expect. If we run into any problems, or if we ever need to include github.com/fsnotify/fsnotify in an internal import path, I can put a repository up at github.com/go-fsnotify/fsnotify with a \"maintenance has moved\" message in the README.\n. All done.\n. It could be useful. Though for any API addition or change, I'd like to hear from multiple people, so I'm going to let this sit for awhile.\nOne consideration is that sometimes the underlying OS does buffering of it's own. FSEvents on Mac in particular can even persist events to disk across reboots. I'm not sure how accurate the length returned would be in such situations, but it's worth investigating.\n. Thanks for the report. That is odd. It would probably be worth digging deeper to see if inotify is the cause or if fsnotify is mangling the event somehow.\nAdding some logging in readEvents could help. https://github.com/go-fsnotify/fsnotify/blob/master/inotify.go#L171\n. Thanks @bep\n. Thanks for researching all this Anthony. So in summary:\n- EpollPwait needs to be added to x/sys by us or someone. https://github.com/golang/go/issues/10235\n- We need to switch to x/sys for fsnotify (on Linux at least) and mention it in the README and release notes.\n- We should look into ARM based continuous integration (the Go team is using some custom stuff running on https://www.scaleway.com/)\nWe can switch to InotifyInit1 at anytime, which I believe is available in the standard library sys package. It may require a slightly newer Linux kernel, but that's fine so long as the README indicates the requirements. Feel free to prepare a pull request for that if you like.\n. Ok.\n. Thanks Anthony. If you could do some testing with #135, it would be much appreciated.\n. Thanks @purpleidea. I left some comments.\n. Thanks James. As to your question, if someone does a go get github.com/go-fsnotify/fsnotify the code should compile and build without needing to go generate anything. \nThis applies even more so to a library. For example, if you go get github.com/spf13/hugo which depends on fsnotify, it would fail to build until you run go generate on the fsnotify dependency. If multiple libraries did that it would be a total nightmare for users.\nIt's also what the Go team recommends, and I trust their recommendations, because they have a lot more experience than me. https://blog.golang.org/generate\n. Is that test failure on Windows?\nfsnotify is a bit unusual in that it has a lot of platform-specific code. hopefully we can get this to work without multiple op_stringers for different platforms.\nThe Windows code is a real mess IMO #6. Sorry.\n. I'm too sleepy to be coding on this right now (bugs are inevitable), but I'll try to take a look in the next few days. Thanks for the contrib.\n. pong :)\nsorry.\n. This PR still needs a little more work before it's merged. I can do the work, but I haven't had a chance to yet.\n. see the comments i made during code review.\n. ok.\n. That would be great.\nThe only thing is, how does someone using Linux choose between them? We may need something along the lines of #104 first.\n. @purpleidea I think it would be best to build fanotify Go wrapper out as a separate repo and then look at integrating after that.. @amir73il is working on a \"super block watch\" for Linux, providing \"the ability to set a single (fanotify) watch on a root directory and get notified on all the legacy inotify events without the need to recursively add watches on all directories.\" https://lkml.org/lkml/2016/12/20/312\nThis could avoid the need for a user-space recursive watcher (#16) on modern Linux kernels.\n. Thanks Amir. \nPerhaps another option to make the patched kernel available would be to maintain a Vagrant box built with Packer. That way we could test fanotify super block using a VirtualBox VM from any operating system.. I wonder if this is similar to the issues and fixes for kqueue on BSD (#105), except for inotify.\n. Which platform are you running into this issue on?\n. Thanks. \nWere the events happening previously? Do you have any idea of what may have changed in wellington, or if it was an update to fsnotify? \n. Thanks for reporting this. I haven't noticed gopkg.in being unreliable, but it's another reason to move away from it. See #108.\n. https://github.com/fsnotify/fsnotify is the new home for fsnotify.\n. CLA hub has new maintainers if we want a CLA.\n. maybe keep the 3 clause BSD license but change the wording? e.g. https://github.com/gocql/gocql/commit/bfab7467126ac5a9e7360141737da30214f026c7\n. The CLA and license are needed if Google is to ever use this code in core or x/tools. \nWe need a better solution for enforcing the Google CLA.\nIt would make me feel less awkward if there was an active co-maintainer on the project who is employed by Google.\n. Regarding the CLA, perhaps Google has some code to integrate with GitHub Status in a similar fashion to GitHub themselves.\n\n. closing in favour of #193. Thanks!\n. Finally got my Windows VM working again. Merged. Thanks.\n. This may be related to the way editors save files. See #17 \nCan you try modifying the file at the command line? \nhttp://superuser.com/questions/10426/windows-equivalent-of-the-linux-command-touch/764716\n. Thanks for checking. \nSome people batch up or throttle events if they occur multiple times. Eg. here is the code for Hugo:\nhttps://github.com/spf13/hugo/blob/master/watcher/batcher.go\nThere was a fix for similar issues in OS X with #111, but I'm not sure if the same solution would work on Windows. \n. Thanks for investigating this @tsuna. \nHave you looked at related open issues already? Possibly #115.\n. What do you think of splitting out inotify as a dependency and adding some inotify-specific stress tests there? #173.\nAlso, there are some open pull requests in need of review/testing that may help, such as #149.\n. I'll re-run Travis to see if it's being flaky.\n. Sorry, still haven't reviewed and tested it yet.\n. I'm not that familiar with syscall.Pipe. Hoping someone will review this.\n. Thanks for your patience @fjl.\nThere is currently a data race issue with kqueue on master, which should be remedied first.\nhttps://github.com/fsnotify/fsnotify/pull/162#issuecomment-251575890\nAs to this PR, we need some familiar with epoll to do the code review.\n. sounds good. feel free to merge this.\n. @omeid I agree. We should make that clear in the CONTRIBUTING document and also look into GitHub's branch protection for master.\n. I enabled a few things:\n- The master branch is protected from force pushes. \n- Tests must pass before a branch can be merged to master.\n- Branches must be up-to-date with master before merging.\nIf the tests past on a branch and it is up-to-date with master, it should still be possible to push its contents to master directly. It may or may not work with the \"hub apply mail\" workflow I've been using.\nThough I'd prefer squash merging, merge commits are also enabled for now.\n. This whole idea could be impacted by what we end up doing for #136.\n. Thanks.\n. merged. thanks\n. Yes, this hasn't changed. kqueue does need to keep a file open for every file it watches, plus the directories themselves. On BSD the limits are higher so it's less of an issue than on OS X.\nThere is a way to increase the limit. The FAQ should probably be updated with the commands to do it. https://github.com/fsnotify/fsnotify/wiki/FAQ\nYou can also ensure that you're not watching files that don't need to be watched, such as hidden .git folders.\n. NOTE: The FAQ is now part of the README to increase visibility (#186): https://github.com/fsnotify/fsnotify#faq. Hi Mart\u00edn. Thanks for reporting the issues. Unfortunately I don't have access to Linux on these architectures to test with nor do we have CI/builders on those architectures to catch the issues. \nThe poller code that is failing was submitted by @PieterD in #66 and switched to epoll_create1 by @suihkulokki in #100 in an effort to make it work on arm64. Maybe they will have some insight into why it's failing.\n. thanks Riku\nas to the errors on PowerPC, I really have no idea :cry:\n. Thanks @laboger. Are you planning to do a CL for syscall?\nShould fsnotify switch from using standard libraries syscall to https://godoc.org/golang.org/x/sys?\n. Fixing the standard libraries syscall would be preferable. I just thought it was frozen since Go 1.3, but maybe bugfixes are still okay. Thanks.\n. Is it timing out? Many of the tests only wait so long for the notifications to occur.\n. @TheTincho Can you test arm64 with v1.3.0. It should be working now that @suihkulokki's patch is in: https://go-review.googlesource.com/#/c/21971/\n. I should've looked more closely at @laboger's work before. Apologies.\nLooking through https://github.com/golang/go/issues/15135, Lynn updated the syscall package in the standard library. That fix was made to Go 1.7.\nhttps://go-review.googlesource.com/#/c/22207/\nBut the Go team allowed the patch to be rolled back to Go 1.6.2 which is due out today: https://github.com/golang/go/issues/15288\nRiku took a different approach, revising golang.org/x/sys/unix and switching fsnotify to use it.\nAt this point it probably makes the most sense to apply @laboger's change to x/sys/unix as well. That way fsnotify won't require Go 1.6.2 for ppc.\nI don't know if @suihkulokki's change could have been made to syscall instead, but at this point it's probably too late to make the change there, and still get it in to Go 1.6.2.\n. We really need to get builders #136 setup for these environments. That way we can ensure they are continuing to work with other changes, and we could also see any test failures that occur.\n. @laboger Are you still seeing test failures sometimes? If you are running with the verbose (-v) option it can be difficult to see the failure amidst all the other logs.\n. @laboger Apologies. I merged that change before looking at the work you had done on the syscall library. Would you be willing to submit your syscall changes and any other necessary changes as a CL on golang.org/x/sys/unix? That will enable powerpc to work even on Go 1.5 rather than requiring 1.6.2.\nI'm looking into getting Go's builder machines in place for fsnotify. That way we can ensure it is tested across linux/arm64 and ppc to avoid such issues in the future.\n. Thanks Lynn.\n. @laboger syscall was supposedly frozen when x/sys was extracted. \n. @laboger Here is the relevant proposal and mailing list thread\nhttps://docs.google.com/document/d/1QXzI9I1pOfZPujQzxhyRy6EeHYTQitKKjHfpq0zpxZs/edit\nhttps://groups.google.com/forum/#!topic/golang-dev/gyOoSwxBkCA\n\nWe therefore propose to freeze the package as of Go 1.3\n. This whole thing has brought to light something I didn't realize. There are quite a lot of changes to the \"frozen\" syscall package since September 2014 (when Go 1.4 was released and syscall was \"frozen\"). Perhaps it just was the pragmatic thing to do to keep things working, but it certainly isn't frozen.\n\nThe copy to x/sys happened in August 2014 and x/sys has seen a lot of changes too. But it does make me wonder if there aren't fixes and improvements in syscall that haven't made it so x/sys.\nhttps://github.com/golang/go/commits/master/src/syscall\n. So I've posted a message to golang-dev regarding this whole confusing situation with syscall vs. x/sys: https://groups.google.com/forum/#!topic/golang-dev/cEASnHIXmLI\nI still think the switch to x/sys is a good move simply to support previous versions of Go, but I'm somewhat inclined to do a diff of the two libraries to see if we're missing any syscall patches.\n. There is an open CL for ppc from @clnperez.\nhttps://go-review.googlesource.com/#/c/22605/\nhttps://github.com/golang/go/issues/15393\nI'm not sure about s390x.\n. The change list (CL) has been submitted. Thanks Christy.\ngo get -u golang.org/x/sys/unix\nI don't think any changes are need to fsnotify itself for this update.\n@TheTincho Can you please test it out.\n. see #22. Thanks. It would've been a bit easier to use an alias for the import import syscall \"golang.org/x/sys/unix\" but this is fine.\nIt looks like the CI failure on darwin as something flaky.\nAdding a dependency could break people's builds, so we'll need to release this carefully.\n. @anthonyfok offered to do some additional testing in #112.\nI think we should release this as v1.3.0 by the end of April. I'm thinking of pre-announcing the release to golang-nuts, since it does require a new dependency.\n. Announced: https://groups.google.com/d/msg/golang-nuts/3JLKL785bTY/EacbfZVeAAAJ\nI also left a note in the #fsnotify channel on Slack.\n. merged. thanks\n. As far as local testing, I currently use https://github.com/nathany/vagrant-gopher for BSD and Linux, which I run on a Mac along with a Windows 10 VM in VMware Fusion. Solaris could probably be added, but that still only covers x86.\nI recall some plans to make it possible to utilize the builders from a local computer while debugging issues, but I don't know where that is currently at.\n. From @bradfitz:\n\nCurrently our builders can only run stuff in golang.org/x* and hosted on Gerrit.\nThat's not fundamental, but it's just how things are currently implemented.\n\nI will compose a message to golang-dev tonight after work to see where the community wants to take this.\n. There is also a matter of where the issue tracking is done in the future. In a subrepo or the Go language repo. The change from pull requests to CLs.\nI'm fairly happy with GitHub's recent improvements to pull requests and my own workflows using hub, so it's really just the builders that we need to get going on.\n. Posted to golang-dev to include other Go contributors in the discussion. https://groups.google.com/forum/#!topic/golang-dev/SVrNHQU1oEM\n. Opened an issue over in the Go repository. https://github.com/golang/go/issues/17312\n. Thanks for the report. ppc wasn't resolved in v1.3.0, see issue #130 for more.\n. Please try updating x/sys/unix.\n. From Slack, @flexd reports the same issue with v1.2.11, so this isn't a regression with the new syscall dependency in 1.3.\n. @ppknap Good call.\n@Depado does your code do a similar thing or do you have a different cause?\nMaybe we can improve the documentation or FAQ to indicate that watcher.Close() should only be called when you're done watching, not in a defer in a function call.\n. Closing this. If you have any suggestions for making this more clear in the examples or documentation, feel free to reopen it or open a new issue.\n. closed in favour of #173\n. @pattyshack provided a patch which has been merged to master. \nplease (re)open the issue if you see any further flakiness.\n. Thanks for the report. Which operating system is this on?\n. Thanks @suihkulokki. So sed exhibits the same issues as text editors #17.\n. Thanks for providing a failing test. I won't be merging it until we have a fix, nor will I be merging in with an additional testing dependency (as good as testify may be).\n. Thanks. Would you mind also taking a peek at #124?\n. @jeffwilliams You could checkout an older version of fsnotify and vendor that code. The change to EpollCreate1 was made in v1.2.5. See releases.\nI'm not sure if there is a good way to fallback to the old EpollCreate, so I'm going to go ahead and close this. \n. I've personally not test with 10k+ files. We should try to establish if the underlying inotify code handles that many files properly (for a given kernel). Assuming it does, then we will at least know it's an issue in fsnotify.\n. > \"IN_Q_OVERFLOW is emitted when the appropriate queue is full and can't take more events. If this event occurs frequently you should read events faster and eventually increase the limit for queues. This limit can be read and changed by reading/changing the appropriate procfs file (/proc/sys/fs/inotify/max_queued_events).\" - http://inotify.aiken.cz/?section=inotify&page=faq\nWould it be possible to test this by temporarily modifying /proc/sys/fs/inotify/max_queued_events to a small value? (An inotify-specific tast with the linux build tag)\nIf an integration test isn't possible (or reliable), then how should this be manually tested?\n. Ok.\nWe have a new pull request template: https://github.com/fsnotify/fsnotify/blob/master/.github/PULL_REQUEST_TEMPLATE.md\nI'd like to ensure all these questions are answered for any pull request.\nWhat does this pull request do?\n\nUpon receiving an event with IN_Q_OVERFLOW set in the mask, generate an\nerror on the Errors chan, so that the application can take appropriate\naction.\n\nWhere should the reviewer start?\nHow should this be manually tested?\n. @zeldovich Have you signed the Google CLA? We need contributors to sign the CLA so that fsnotify can be used in Go tools in the future.\nhttps://cla.developers.google.com/about\n. Thanks @bep. It seems all the current pull requests are failing in odd ways. We should really look into fixing or removing faulty tests.\n. This may be related to #142.\n\npanic: Fail in goroutine after TestInotifyStress has completed\n. Yes, we should be using filepath.Join.\n\nFor the moment, does it work to just watch \"c:\"?\n. Hi. File notifications have a tendency of not working across shares (NFS, Vagrant mounts), but it is curious that changing a file in virtualbox worked in the container. I haven't tested this particular case myself.\nAs far as the events passed, how are you changing the file? That may be related to how a text editor makes the change. See #17.\nWhat are you hoping to accomplish? If you need to detect changes to files on the Windows host, as seems to be the case, you will most likely need to watch the files in Windows and then trigger whatever action you need.\nIf instead you are looking to watch files inside the vagrant box, it's best to use a directory that isn't shared from the Windows host, as that usually won't work (as you've seen).\n. Thanks for investigating this further. Unfortunately the underlying file notification systems have some limitations and differences, which make it difficult to get the consistent behaviour we would all like to have. If we can improve something though, we'll certainly try.\n. looks good. thanks\n. Something is flaky with Mac tests, but the Windows tests on Appveyor passed.\nNotice that it's logging events with \\\\ double slashes everywhere though. Hm.\n. Yah, don't worry about the the Mac tests. That's a separate issue.\nYou can see the output in Appveyor (Windows CI) by clicking the link: https://ci.appveyor.com/project/NathanYoungman/fsnotify/build/1.0.209\nIt may just be a %q vs. %s thing. I'll double check before merging/releasing this.\n. Merged. I still have to tag a release and update the changelog, etc.\nThanks Bruno\n. Not currently. Some platforms include a flag for that but not all. Currently fsnotify is doing the lowest common denominator thing and not reporting it, as opposed to doing an os.Stat to always provide that information.\n. > IN_CLOEXEC\n\nSet the close-on-exec (FD_CLOEXEC) flag on the new file descriptor. See the description of the O_CLOEXEC flag...\nO_CLOEXEC (Since Linux 2.6.23)\nEnable the close-on-exec flag for the new file descriptor. Specifying this flag permits a program to avoid additional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag. Additionally, use of this flag is essential in some multithreaded programs since using a separate fcntl(2) F_SETFD operation to set the FD_CLOEXEC flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does a fork(2) plus execve(2).\n\nfsnotify currently uses InotifyInit (not InotifyInit1).\n\ninotify_init() first appeared in Linux 2.6.13; library support was added to glibc in version 2.4.\ninotify_init1() was added in Linux 2.6.27; library support was added to glibc in version 2.9.\n\nThis is fine (IMO).\nWhat about support on ARM and PPC64? /cc @suihkulokki @TheTincho @clnperez @laboger @tophj-ibm?\n. @TheTincho That would be very helpful. Thanks. inotify_init1 and the flags it takes. The code change is in #178.\nI wonder if we should be using IN_NONBLOCK as well? (#5) https://github.com/fsnotify/fsnotify/blob/master/inotify_poller.go#L48\n. Is there any reason why someone would want the child process to have the inotify file descriptor carried over? \nPresumably a new one would be created in the child process instead if needed.\n. Thanks. Still need to look into these flaky tests.\n. Maybe the terminology is confusing? The path on Linux should be relative to whatever you are monitoring. If the current working directory was tmp and you monitored EFlmKJ8XTYmnxQIucRkY2A/ then you should see EFlmKJ8XTYmnxQIucRkY2A/qmp.sock (relative to tmp).\nWhether the filename is included or not doesn't make the path absolute rather than relative.\nIf you want to strip off qmp.sock for some reason, you can always use filepath.Dir() from the standard library.\n. It is relative to the folder being monitored.\nIf you monitor /home/go/src then the notification paths will include /home/go/src/.... If you monitor src then the path will only include src/.... In order to do the later, your current working directory matters.\nNot saying it's the best thing. Maybe the paths returned should always be absolute. It would probably work to just call filepath.Abs on the path you want to monitor rather than every path returned for a notification -- though we'd need to verify it across each platform.\n. I opened an issue for this (#160). Thanks for bringing it up.\n. it looks like there is a data race to fix\n. Still seeing data races on Travis. Doh!\nSpecifically on macOS. The race on Linux is resolved.\n. data races in all the places\nwill come back to that one. \ud83d\udca4 \n. on macOS Sierra 10.12\n```\n\u276f go test -race -test.count=10\nPASS\nok      github.com/fsnotify/fsnotify    104.165s\nfsnotify git/master\n\u276f go16 test -race -test.count=10\n```\n... the later doesn't seem to be finishing anytime soon\n```\n\u276f go16 test -race \ntestmain\nfatal error: unexpected signal during runtime execution\n...\n```\nBut then Go 1.6 doesn't work on Sierra anyway. I wonder what version of macOS Travis is running? Might need a macOS VM just to test Go 1.6 locally. \ud83d\ude22 \n. well this is embarrassing... \ud83d\ude0a \nupdated for Go 1.8. also requested Go 1.8 for AppVeyor. https://github.com/appveyor/ci/issues/1330\nCurrently Windows tests are using Go 1.7.1. @twpayne Thanks for the note. The only problem with using .x is we need to wait for Travis CI to update their aliases, but they are in place now. I will update.\nSee: https://github.com/travis-ci/travis-build/pull/956. fsnotify doesn't currently support a file closed event -- I don't believe every platform that fsnotify supports has such a event.\n. Thanks for the report @jiangytcn.\nWe are running the tests with -race yet it hasn't caught this issue. From your description, it sounds like it rarely occurs, which is going to make it hard to track down.\nPlease let us known what go version you are using and if possible, include some sample code for how you are using fsnotify. Thanks.\n. Thanks @oozie and @jiangytcn. Related to #168.\n. @ishustava regarding ginkgo, see https://github.com/fsnotify/fsnotify/issues/167 for the discussion. thanks.\n. Hi Slawek. I would rather not introduce a testing dependency in fsnotify or other libraries I work on. I believe it's easier for contributors to use the baseline standard library tests that everyone should be familiar with. Personally I'm not a fan of BDD-style DSLs in Go. Nathan.\n. When I first started using fsnotify I had the same question and wrote all the code to remove the watchers only to find that the remove failed because the watch was already gone. I was using kqueue on macOS at the time, so I'm not 100% sure for inotify on Linux.\n. Documenting that it's unnecessary would be good -- though it would be good if it handled removing better as well.\n. Thanks @oozie. Still need to deal with flaky kqueue tests in #162 also -- not sure if that's related.\nI've not seen a pointer to a Mutex in common practice, so this is interesting. \nDo you think it would be worth restructuring the code further to make it clear what the mutex guards? I really like this idea: https://talks.golang.org/2015/tricks.slide#15\n. Renames and moves is certainly less than ideal in fsnotify -- not only with inotify, but across all operating systems. See also #26.\n. FYI, epoll was added in #66. It certainly complicates the code quite a lot.\n. related #170\n. Should this effort include fanotify on Linux as well? #114. @tiwaana Sounds awesome. Is the next DTC meetup the Feb 16 launch party for Go 1.8?. I merged #175. Want to rebase and give this another go on Travis?\n. Both locally and your remote? :cry: \nSorry, I guess I did ask you to rebase on master. Darn rebase.\nA new PR is fine by me though.\n. Thanks.\nOut of curiosity, what error occurred when the linter didn't build? I'm a bit surprised over the issue.\n. Oh, I see.\n```\ngithub.com/golang/lint\n../../golang/lint/lint.go:249: undefined: types.ImportMode\n```\nfrom https://travis-ci.org/fsnotify/fsnotify/jobs/165118920\nThere is a closed issue with a similar error https://github.com/golang/lint/issues/246\nAnd lint doesn't test itself on Go 1.5.4 \nhttps://github.com/golang/lint/commit/e39d62944f60e7296290f116b5f99ac3a4d1fce3#diff-354f30a63fb0907d4ad57269548329e3\n. Thanks. Your fix should address 1 or 2 of these issues -- https://github.com/fsnotify/fsnotify/issues?q=is%3Aopen+is%3Aissue+label%3Acritical\n. It still seems to be a bit flaky (#142) for me, though the data race (#150) is resolved.\nvagrant@vagrant-ubuntu-trusty-64:~/src/github.com/fsnotify/fsnotify$ go test ./... -race\n--- FAIL: TestInotifyStress (1.43s)\n    inotify_test.go:263: Creates and removes should not be off by more than one: 2 creates, 1000 removes\nFAIL\nFAIL    github.com/fsnotify/fsnotify    9.945s\nvagrant@vagrant-ubuntu-trusty-64:~/src/github.com/fsnotify/fsnotify$ go test ./... -race\nok      github.com/fsnotify/fsnotify    10.738s\nvagrant@vagrant-ubuntu-trusty-64:~/src/github.com/fsnotify/fsnotify$\n. Yah, looks that way. https://github.com/fsnotify/fsnotify/issues/142#issuecomment-242377927\nThanks for your work on this.\n. Thanks, it's working well for me also.\nFYI, this stress test was added in #66.\n. Thanks. P.S. I invited you to the repo, but please continue to use branches and pull requests for any code changes.\n. Waiting on feedback/testing for ARM and PPC64 before merging.\n. Can you provide steps to manually test that file descriptors are no longer leaking with this change?\n. @clnperez That's odd. I wonder if the IN_CLOEXEC flag isn't getting passed in properly or what could be causing the discrepancy on ppc.\n. I don't know why this wouldn't work. https://github.com/golang/sys/blob/master/unix/zsyscall_linux_ppc64le.go#L629\nIN_CLOEXEC is defined with the same value as other platforms.\nhttps://github.com/golang/sys/blob/master/unix/zerrors_linux_ppc64le.go#L510\nSo I wonder where the problem is.\n. Linux\n\u276f lsb_release -a\nNo LSB modules are available.\nDistributor ID: LinuxMint\nDescription:    Linux Mint 17.1 Rebecca\nRelease:        17.1\nCodename:       rebecca\nmacOS\n\u276f sw_vers\nProductName:    Mac OS X\nProductVersion:  10.12\nBuildVersion:    16A323\nWindows\n\u276f systeminfo | findstr /B /C:OS\nOS Name:                   Microsoft Windows 8.1 Enterprise Evaluation\nOS Version:                6.3.9600 N/A Build 9600\nOS Manufacturer:           Microsoft Corporation\nOS Configuration:          Standalone Workstation\nOS Build Type:             Multiprocessor Free\n. Sorry, I can't accept a pull request that isn't cross platform.\nbut see #173\n. Thanks for reporting the issue. Would you mind elaborating with specifically what you do with inotify-tools that does work for those not familiar with it?\n. I've setup GitHub teams for each platform. If you have already contributed to fsnotify and would like to be added to a platform-specific team, please let myself or another maintainer know.\n. @zchee Initially I'm thinking we build up repositories for https://github.com/fsnotify/inotify, etc. independent of the fsnotify package. Then start replacing the low-level bits of the fsnotify package with dependencies on those, while maintaining the same cross-platform API.\nEventually we can also substitute kqueue for fsevents on darwin.\nIf you'd like to help out, take a look at the https://github.com/fsnotify/fsevents project. There is an open issue with some next steps there, and I'm sure there's much more to do.\n. They are quite different. Right now I'm not thinking of changing the API of fsnotify. Just keep it stable for users.\nIf we can separate the code into low-level bits and high-level bits, I think it will be easier to maintain, as separate teams of people will be able to focus on each platform, with one team on cross-platform concerns.\nNot sure if I'm explaining it well, it might be easier to show than explain.\nI've already started with kqueue, where the code from line 463 on is the low level part. https://github.com/fsnotify/fsnotify/blob/master/kqueue.go#L463. I'm thinking of putting that in a separate repo with a test suite and documentation and making that into it's own library that fsnotify depends on. \nStill many details to work out though -- and certainly open to other ideas.\n. I could still really use some help to maintain fsnotify. Code reviews, testing and merging PRs, doing releases.. Clearly I have been doing a poor job of maintaining fsnotify. Issues without answers, pull requests left open for months... progress has stalled not due to lack of contributors, but because I am currently the bottleneck.\nWhen I got involved with Chris Howey's fsnotify, it was to help out with the API. I don't have the experience and knowledge of file systems necessary to vet a pull request like #124, which adds epoll to kqueue. Much less take on a whole new platform like #196. At first I thought I would learn these things, but doing so hasn't been a priority in what spare time I do have.\nI had hoped that having a generous policy (#126) for granting commit access combined with this call for maintainers would see a team of people volunteer to help maintain fsnotify. I had high hopes for splitting responsibility by operating system to make maintenance more palatable. But that hasn't happened... and I don't know what needs to be done for that to happen.\nAt this point, I am tired of feeling guilty for not being more involved in the project. I'm also tired of worrying that merging a pull request will break an upstream like Docker or a platform that isn't under CI (#136).\nI haven't been very involved lately, so it's time to make it official. I'm stepping away from the fsnotify project. It's up to you now.\nIf you need something from me during the transition, reach out to me here or on #fsnotify on Slack. Good luck.\n. Relevant: https://github.com/blog/2392-introducing-code-owners. thanks @vahe. \nMaybe the FAQ and other documentation would be more visible if it were moved from the GitHub Wiki to the website? What do you two think?\nhttps://github.com/fsnotify/fsnotify.org\n. Moving the FAQ to the README sounds good. Let's do it.\n. Hi @Allendar. The example we have is correct and tested by the test suite. I'm not sure what the confusion is here, but I'm closing this issue.\n. updated and merged. thanks. Sorry for the delay. I'll try to carve out some time over the Christmas holiday to work on fsnotify.. @twpayne Thanks and apologies for the delay. @ppknap Thanks also for reviewing.\nOne consideration is the performance of wide vs. narrow mutexes:\nhttps://talks.golang.org/2017/state-of-go.slide#25\nBut I think this is a good change, and we can come back to performance considerations later.\nI'll take a closer look and merge + prepare a release in the next few days. Thanks!. @twpayne It's only abandonware if nobody steps in to replace me.\nhttps://groups.google.com/forum/#!topic/golang-nuts/Ix4sg_gDLNE\nsee #183. @twpayne No worries. \nYou are right, for a Linux-only change, CI is enough and hitting merge is fine. Thanks @ppknap for reviewing and merging.\n@twpayne Did you happen to sign the Google CLA at some point? That process still needs to be automated. #193.\nThere are a few more steps to do a release which should probably be documented somewhere. Updating the AUTHORS file, CHANGELOG, and Releases after tagging a version. Creating an issue around that: #201.. Thanks for reporting the issue.\nI've not tested fsnotify with gccgo yet, nor do we have it set up in CI. That would be a good idea.. related: #22, #131 . I think this needs more discussion before opening any pull requests, as it likely involves an addition or change to the API, and fsnotify is a cross-platform API.\nThe suggestion of exposing a file-system specific mask might not be such a bad idea. See FileInfo as an example:\nSys() interface{}   // underlying data source (can return nil)\nAlso see #173 regarding the spinning out of a stand-alone package specifically for Linux.\n. @radu-munteanu I'm hoping a few people step up to build and maintain the inotify spin-off. Then there is still some amount of work to integrate that back into fsnotify with a cross-platform API.\nI'm not sure if > 32 or > 64 ops would really be necessary, but it is certainly worth considering alternative approaches to the API for the spin-off. \nHoping to keep the cross-platform fsnotify API itself fairly stable.. kqueue (BSD) also has NOTE_CLOSE_WRITE and NOTE_CLOSE.. Thanks @willnorris.\nThe licensing and CLA has felt awkward to me for a long time (#119). Let me confirm if the Go team still has any plans to use fsnotify in core. I'll post to the golang-dev mailing list and drop a link here.\nWhat would need to change for Google to be the project maintainer? If there were some Google employees maintaining fsnotify, would that be sufficient? I'm happy to pass over the reigns to make it work.. Using fsnotify in core, license and CLA \nhttps://groups.google.com/forum/#!topic/golang-dev/UwNizs08YD0. @willnorris I would really like to sort out the licensing issue. Thanks.\nhttps://groups.google.com/forum/#!topic/golang-dev/UwNizs08YD0. @bradfitz suggests doing something similar to Camlistore. From https://github.com/camlistore/go4/#details:\n\nCLA compliant contributors must agree to the Google CLA (the same as Go itself). This ensures we can move things into Go as necessary in the future. It also makes lawyers at various companies happy. The CLA is not a copyright assignment; you retain the copyright on your work. The CLA just says that your work is open source and you have permission to open source it. See https://golang.org/doc/contribute.html#tmp_6\n\nHere are the instructions from @willnorris. I suspect we will want the CLA checking for the whole organization, including fsevents or any new repos created. The fsnotify.org website doesn't really need it, but why not.\n\nHere's the instructions to enable CLA checking for fsnotify.  You can do it either at the organization level, in which case it will apply to all repos in the org, or just to the individual repos you want it activated for.  The same webhook secret will work in either case.\n\n\nGive googlebot write access to the repos.  Adding as an outside collaborator is fine, or you can add the account to the org if you don't want to setup each repo individually.  Up to you.  Write access is needed in order to set commit statuses and issue labels.\n\n\nIf you want googlebot to set issue labels, go ahead and create the labels \"cla: yes\" and \"cla: no\".  If you don't care about the labels, and will just check for the commit status, then just don't create them and googlebot won't try to add them.\n\n\nAdd a new webhook to the org or repo:\n\n\nPayload URL: https://cla.developers.google.com/api/github/webhook\nContent type: application/json\nSecret: [elided, ask]\nWhich events would you like to trigger this webhook?\nSelect \"Let me select individual events\" and then select only \"Issue comment\" and \"Pull Request\".\nActive: this should be checked\nThat should be it.\nMost of the time it should go pretty smoothly.  The one edge case that we don't handle well is when someone is submitting a PR containing commits that they did not author themselves.  In that case, the comment from googlebot should hopefully explain the situation pretty well.  It's a case where we rely on a human being (you) to do a little bit of legwork and go ahead and merge the commit, even though the official status from googlebot says that things aren't okay.  I've got a feature request outstanding to try and handle this case better.\n. @4ad @amitkris Please review.. @gfrey We don't currently have a good way to test Solaris, either with a CI service or locally from a different OS (I use Vagrant Gopher for Linux/BSD). Any suggestions?. @gfrey Thanks both for this pull request and your work on Vagrant Gopher to test it.\n\n\u276f vagrant ssh solaris -c 'go version; cd fsnotify/fsnotify; go test ./...'\ngo version go1.8 solaris/amd64\n/export/home/vagrant/src/github.com/fsnotify/fsnotify\nok      github.com/fsnotify/fsnotify    8.332s\nConnection to 127.0.0.1 closed.\n(unfortunately no race detector on Solaris)\nI'm still hoping @4ad and/or @amitkris provide a review, but I will also take a closer look in the coming days.. Sounds like a mighty good idea, though I have no insight into what has changed since the last release, or if it's \"safe\" to tag a new release.\nAs per my comment here, I haven't been following the project since March.. Thanks @thaJeztah.\nUnfortunately I haven't gotten around to #201 to describe how releases have been done in the past. Not that the process couldn't be modified to suit whoever takes up the baton. \ud83d\ude09 . Should we also suggest the use of dep for the next release? https://github.com/golang/dep\nIt may not change the actual release process beyond initial updates to the README.. With internal package support in Go 1.4, it's possible that go/cmd could use fsnotify in Go 1.5 but not yet provide os/fsnotify. It just depends on whether or not fsnotify is ready to take on the Go 1 compatibility guarantee at that time.\n/cc @rsc @davecheney \n. There are some challenges to getting fsnotify into the standard library.\n- Designing a suitable (low-level) API.\n- ~~Not depending on C code.~~\nFSEvents (#11), at least in the current implementation contains C code.\n\n\"The goal of the dev.cc branch is to eliminate all C code from the Go libraries and then remove the C compiler that we have been maintaining as part of the toolchain.\" - @rsc http://golang.org/s/dev.cc\n\n~~Unless this only applies to C code like this and not cgo.~~\nThe net package uses C code, so this comment is probably specific to the libraries that are part of runtime. My bad.\n- The syscall dependency. Syscall is frozen as of Go 1.3, with any additions being made to x/sys. So far fsnotify doesn't require anything new in x/sys, but if it ever does, the necessary portions will need to become internal packages of fsnotify (to avoid having stdlib depend on x/sys).\n. Given the improvements to tools to vendor code (GO15VENDOREXPERIMENT) and support for internal/ packages, I see less value in trying to bring this into the standard library. If the go tool or godoc need to use fsnotify, it can be copied in as an internal package.\nMaybe an x/ package that uses Gerrit, the builders, and the CLA.\nOr if maintained as an independent package, perhaps the BSD license should be tweaked and the CLA requirement dropped.\n. @matthias-stone reproduced the issue:\n\nSo, looking at this in GDB the following squirrelly behaviour occurs: breaking and continuing the code \nclears the leaked file descriptors.\nExecuted with \nconsole\ngdb --args ./fsnotify.test -test.cpu=1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n-test.v -test.run=TestFsnotifyDeleteWatchedDir\nSample of leaked file descriptor - note the anon_inode:inotify\ntotal 0\nlrwx------ 1 matthias users 64 Jun 21 20:17 0 -> /dev/pts/40\nlrwx------ 1 matthias users 64 Jun 21 20:17 1 -> /dev/pts/40\nlr-x------ 1 matthias users 64 Jun 21 20:17 10 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 11 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 12 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 13 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 14 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 15 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:19 16 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:19 18 -> anon_inode:inotify\nlrwx------ 1 matthias users 64 Jun 21 20:17 2 -> /dev/pts/40\nlrwx------ 1 matthias users 64 Jun 21 20:17 3 -> socket:[289525025]\nlrwx------ 1 matthias users 64 Jun 21 20:17 4 -> socket:[289525026]\nlr-x------ 1 matthias users 64 Jun 21 20:17 5 -> pipe:[289525027]\nl-wx------ 1 matthias users 64 Jun 21 20:17 6 -> pipe:[289525027]\nlr-x------ 1 matthias users 64 Jun 21 20:17 7 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 8 -> anon_inode:inotify\nlr-x------ 1 matthias users 64 Jun 21 20:17 9 -> anon_inode:inotify\n. I don't know what I'm doing :-1: \n\n```\nstrace: Can't stat './fsnotify.test': No such file or directory\nGNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1\n./fsnotify.test: No such file or directory.\n``\n. I noticed thatinotify_init1()has aIN_NONBLOCK` option in Linux 2.6.27+ (Go 1.3 requires Linux 2.6.23)\nhttp://man7.org/linux/man-pages/man2/inotify_init1.2.html\n. Also related: https://github.com/howeyc/fsnotify/issues/7\n\nDesire is to have the library send events/errors using select so that the receiving application can be monitoring the channels without the use of a separate goroutine.\n. #39 could solve this.\n. My current suggestion is to set the Op filter globally at the Watcher level instead of for each Watch added. Preferably in such a way that it cannot be changed later. Perhaps something like:\n\ngo\nwatcher, err := fsnotify.NewWatcher(fsnotify.Create|fsnotify.Write)\n- The filter can be passed to each adapter to have the OS filter out events the best it can.\n- A final user-space filter can catch any outliers without requiring the significant amount of bookkeeping of the previous implementation.\n- For the same reasons that directory watches are easier to manage, a user-space recursive watcher will be simpler to implement, whether included in fsnotify or externally.\n. @tsuna The problem with adding a new API like that is that the flags differ from platform to platform. That's partly why I'd like to split out inotify #173 so it can be used independently in special Linux-only cases.\nThis issue is tracking a more general solution, which may be a ways off yet.\n. Pull requests are welcome, and once we have more people reviewing and merging pull requests, things should start to move faster. \nI think breaking out the low-level platform specific libraries (such as #173) will also help there. It should allow experts in inotify to work on that without worrying about the cross-platform API, and others to tackle cross-platform consistency without dealing with all the low-level details.\n. leaking descriptors #59 didn't help any.\n. I've never even thought of extending it to webhook notifications like Dropbox and Google Drive provide. Interesting idea. Not sure if it belongs in this package, but having a common interface in top could be cool.\nThe sql driver model is one I've been thinking about, particularly if there are multiple options for a given OS.\n. Indeed. It also fits with another desire I have, which is to make it easier to contribute to without being knowledgable of every single platform. Separate drivers for inotify, kqueue, etc. would be one way to achieve that.\n. Yah, polling is the only option for NFS as far as I know. You can also check https://github.com/rjeczalik/notify but I don't think it has polling yet either.\n. Please do submit a pull request.\n. @omeid I don't have any plans for what a driver interface would look like yet (and to be honest, I haven't done much work on fsnotify lately).\nPersonally, I'd prefer to see the current code base cleaned up before doing a big API change. The Windows internals are particularity crufty. \nhttps://github.com/go-fsnotify/fsnotify/milestones/v2%20Internals\nMaybe we could start a new issue to figure out the details of transitioning to a driver model?\n. @cpuguy83 Do you think you would be able to add polling without changing the API? Maybe just for operating systems that fsnotify doesn't currently support?\nThere are other situations where polling would be desirable, but I'm not sure how to detect them, or if it should be done more manually (which is why a driver-style API is relevant to this discussion).\n. In terms of API, here are related issues #104 and #75. \nPolling should also help with #45 for Windows users.\n. @mdwhatcott @cpuguy83 Would you be willing to build a stand-alone fsnotify/polling package that could be incorporated into fsnotify as a secondary step?\nIf so, I'll create a repo called polling or poller or whatever you prefer.\nFor me the key considerations are:\n- providing a speedy implementation as outlined in the original post\n- a simple and idiomatic Go API specifically for polling\n- solid unit and/or integration tests (preferably without any external testing dependencies to keep it simple)\n- well documented both in the README, examples, and API docs\n. ok.\nHere is a polling watcher by @radovskyb https://github.com/radovskyb/watcher\n. @radovskyb Hey Benjamin, Would you be interested in transferring watcher into the fsnotify organization and working on it here? Still as a stand-alone repository for the time being.\nThe API already looks pretty close to fsnotify. \nOnce some of the low-level bits are extracted from fsnotify (e.g. #173) I'd like to incorporate polling into fsnotify as a fallback, while still allowing people to use the  poller directly if that's all they want.\n. Work has begun on this as an external project that can eventually be used from fsnotify.\nhttps://github.com/go-fsnotify/fsevents\nTODO:\n- [ ] Integration tests\n- [ ] Refine API\n- [ ] EventFlags.String()\n. Would it make sense to work in a monorepo for fsnotify? Bring the fsevents library into a subfolder and work on it here, even before it's integrated and used by fsnotify.\n. Some people are using fsnotify/fsevents so we'd probably leave it there and just move maintenance here. We could put a message up over there -- or not.\nI'm still undecided whether it should be internal/ here initially.\n. I'm also not sure if we should try to move fsnotify towards this new driver system (#104), or build out something entirely new. Perhaps coming back later to retrofit fsnotify on top of an intermediary API.\n. For me personally, my first step would be to get Vagrant setup with a Solaris box with Go installed. Preferably via https://github.com/nathany/vagrant-gopher.\n. @4ad Amit (@amitkris) is currently working on FEN support. Would you be willing to review his pull request when it is ready?\n. This is likely the cause of TestFsnotifySubdir fails intermittently on Mac OS X 10.9.2:\n- https://github.com/howeyc/fsnotify/issues/67\n- https://code.google.com/p/go/issues/detail?id=8147\n. no updates yet. the plan to fix this is to use FSEvents (#11) which currently exists as a stand-alone project but isn't integrated into fsnotify:\nhttps://github.com/fsnotify/fsevents\n. @kevinburke sorry to hear that. \ud83d\ude22 \nIs there something that could be added to the Spotlight mention in the README to improve finding the issue?. Each OS is likely to be a little different. Here's a little research on kqueue: https://github.com/go-fsnotify/fsnotify/issues/24#issuecomment-55539850\nEssentially: not watching the files in kqueue will result in no event at all when a file is touched/updated. (not even, hey, something changed in this directory)\nStill need to do research on inotify and Windows.\n. TextMate2 (OS X) use the exchangedata system call to perform the saves (not sure what that is). But Hugo users are having problems detecting saves: https://github.com/spf13/hugo/issues/1053#issuecomment-116778527\n. > Godoc is a relatively small program. It is built from 102 packages built from 582 source files. We certainly want to be able to build programs larger than godoc. It appears that Linux inotify will let you watch individual directories for changes within that directory, so for godoc you are looking at a little over 102 inotify watches. For OS X, fsevents will let you watch whole subtrees, so for godoc built from 1 GOROOT and 1 GOPATH entry you are looking at 2 fsevents watches.  For Microsoft Windows, FindFirstChangeNotification looks like it might be usable similar to fsevents. For Solaris, file event notifications (FEN) only apply to individual files or directories, and watching a directory inode does not appear to tell you about modifications made to files in that directory, so for godoc you are looking at almost 700 FEN watches. That might take a little while to set up, but assuming the kernel has no hard limits, it should be fine. Speaking of limits... For BSD (or OS X if you don't like fsevents), kqueue has the same \"enumerate every file or directory\" requirement as Solaris FEN, but you give them to the kernel not as file names but as file descriptors. It appears that the file descriptor must remain open while you are watching that file, so the per-process file descriptor limit imposes a limit on the number of things you can watch. Worse, the per-system file descriptor limit imposes a limit on the number of things anyone on the system can watch. The typical kernel limit on a BSD is only on the order of 10,000 file descriptors for the entire machine. - @rsc, https://groups.google.com/d/msg/golang-dev/bShm2sqbrTY/IR8eI20Su8EJ \n- The limits for FEN (Solaris) are high enough (#12) that a recursive watcher should be possible.\n- It's possible that kqueue (BSD, iOS) can't reasonably support a recursive watcher. For large trees, users may need to resort to Polling (#9) or another mechanism.\n. It should work. Most of the tricky issues are with too many resources being consumed. Also, we would ideally take advantage of native recursive watching on the operating systems that support it.\n. No update for fsnotify, but take a look at https://github.com/rjeczalik/notify as an alternative.\n. Rafal's notify library uses FSEvents on OS X instead of kqueue, so it doesn't have that problem on OS X. \n. As does fsnotify.\n. > Maybe the underlying file system event handling differs by platform.\nYes, it does.\n. Nothing yet.\n. This is closely related to #17 but specifically for Linux.\n. @rjeczalik Thanks for chiming in. I only heard of your notify project this past week. I'm really interested in taking a closer look at it.\n@edrex yah, there are too many little platform differences to trip up on. :dizzy_face: \n. I've written a rudimentary implementation of kqueue (on OS X):\nhttps://github.com/fsnotify/fslog\n. I tried a nil timeout but there is more work involved. Currently syscall.Close(w.kq) is in the same for loop that blocks. Instead it should be called directly by watcher.Close() which will cause the read to abort, after which it can clean up and return.\n. FreeBSD 10.0 behaves a bit differently:\n- Closing the kq descriptor doesn't abort the current read, in fact I still get the next event.\n- Then when setting up the next read, we of course get Kevent: bad file descriptor.\nIt's not a huge deal if we're calling Close() before shutting down the app, but if not, then the Read goroutine will sit there blocking until it gets another event to send over the channel. And if I do a proper cleanup to DELETE the events, that next event will never come.\n. When registering file descriptors to watch, this could be useful if registering multiple watches at once (such as all the files in a directory):\n\nIf an error occurs while processing an element of the changelist and there is enough room in the eventlist, then the event will be placed in the eventlist with EV_ERROR set in flags and the system error in data. Otherwise, -1 will be returned, and errno will be set to indicate the error condition. \n\nOtherwise I don't think I need to check for EV_ERROR. Fsnotify was doing this check, but eventlist was nil, so it should never be the case.\n. When watching a directory with kqueue it reports:\n- a Write when a file is created or deleted\n- a Write and Link when a subdirectory is created or deleted\n- nothing at all when a file is touched (updated)\n- but it does report a Write if modified by an editor that does an atomic save (create and rename)\nfsnotify currently adds to this:\n- watches all files in a directory to report updates to specific files. \n- watches for deletes on subdirectories to report the deleted subdirectory, not just a Write+Link\n- when a Write happens on a directory, it scans the directory for any new files/subdirectories and presents them as create events\n. In relation to #16, I was thinking of actually having an event of \"something happened in this directory, but we don't know what.\" Then the scanning and comparing of the files in a directory could be a separate utility function instead of built into readEvents(). It could be used for determining which directory was deleted as well.\nBut there is still the problem of touching files not reporting any event at all. As well as making the calling code different for kqueue.\n. Leaving this in for now as a debugging aid. it doesn't prevent anyone from writing a utility function to represent Event in another way. \n. @jaytaylor this is still something I need to research across platforms to see what can be done. Sorry for moving so slow,\n. @jmhodges Do you have any more details on \"Weird Things\" vim does? Is this when saving or is there a rename file function people are using in Vim?\n. ref: https://github.com/rjeczalik/notify/issues/78\n. not as of yet.\n. Thanks.\nHave you already signed the Go CLA? See the README. \n. Merged as fcd23cde655be3a4e721bd452abc33400136291c.\nThanks!\n. I suppose one disadvantage is that other (possibly temporary) repos such as go-fsnotify/fsevents couldn't make use of gopkg.in?\n. Good point. And I could create go-fsevents if that project took a life of its own.\n. A little maddening for autocomplete on the command line. go-* Oh well.\n. Whoops. Thanks @mewmew.\n. Thanks for the suggestion. The current API isn't final for sure, we definitely want to change how error handling works: #2.\n. There was an issue opened at https://github.com/howeyc/fsnotify/issues/7 regarding the requirement for a goroutine in the calling code.\n5 is part of looking at that, specifically on Linux.\nfor BSD I've found that having kqueue block #24 results in less CPU utilization when idle, but doing so may make it harder to avoid having a goroutine in the calling code\n. @akavel Add() isn't recursive right now. See #18, #21 and #11.\nThe documentation certainly needs some work. I will leave this issue open until that happens. Thanks.\n. That may be a limit of kqueue when there is no watch on the file/directory where the file is being moved/renamed to. I need to take a closer look.\nI'm going to close this issue in favour of a #26.\n. FSEvents (OS X) and Windows have support for recursive watching. I'm not yet sure how they behave when doing mkdir -p a/b/c. Once that is determined, it may make sense to emulate that behaviour elsewhere.\n. Thanks @zhsso. I'll test it out shortly.\nDo you happen to know the difference between filepath.Clean and path.Clean?\n. Thanks for looking into it. Sounds like we're on the right path. :stuck_out_tongue_winking_eye: \nI'm going to tackle #34 before I merge this in and do a new release later today.\n. @zhsso I forgot to mention\nContributors retain their copyright, so we need you to fill out a short form before we can accept your contribution: Google Individual Contributor License Agreement.\nHave you already signed the Go CLA?\n. Thanks very much @zhsso.\n. While renaming the tags is easy enough, it also makes it look like I've been doing breaking changes in the v1 line. I'm inclined to just remove the tags for v0.10.0 through v0.14.3 entirely. \nDoing so accomplishes the same goal of getting v0 to match howeyc/fsnotify while v1 is the new API.\n. Deleted tags:\n- 'v0.10.0' (was 56a7b52)\n- 'v0.10.1' (was 620bfd9)\n- 'v0.11.0' (was b97c307)\n- 'v0.12.0' (was efe9224)\n- 'v0.13.0' (was 4a0c411)\n- 'v0.14.0' (was 960fdf5)\n- 'v0.14.1' (was 06d7792)\n- 'v0.14.2' (was f65830e)\n- 'v0.14.3' (was 2acad09)\n. importers of go.exp/fsnotify on bitbucket:\n- https://bitbucket.org/kardianos/service/pull-request/8/use-fsnotifyv0/diff (updated to v1 with https://bitbucket.org/kardianos/service/commits/562e4b3201a3d51f2d963044ab7823d17970ab91)\n- https://bitbucket.org/ronoaldo/whenchange/pull-request/1/use-fsnotifyv0/diff (merged)\n. @kylelemons I don't know how to submit a pull request to http://kylelemons.net/browse/gitweb.cgi/go/gofr.git/tree, but please checkout fsnotify.v0 or v1.\n~~I don't know why https://github.com/laughlinez/flow is listed in importers because I see no reference to fsnotify in its code or in https://github.com/jcw/flow from which it was forked. /cc @garyburd~~\nThat takes care of everyone importing from go.exp/fsnotify, except for forks of other repositories.\n. This conversation sums up the confusion around having several places to find fsnotify: https://github.com/bmatsuo/gutterd/pull/2#issuecomment-52442275\n. @garyburd Sorry, I don't know why I didn't see that. :blush: \n. An open letter suggesting that go.exp/fsnotify be deprecated in favour of this repository.\nhttps://groups.google.com/d/msg/golang-dev/-__vD-kOF5s/v8eLY271-ucJ\n. As it turns out, there are others using go.exp/fsnotify that don't appear in the importers list.\n- https://github.com/coreos/nova-agent-watcher\n. CL to remove x/exp/fsnotify\nhttps://go-review.googlesource.com/#/c/3990/\nHere are the commits to x/exp/fsnotify:\nhttps://go.googlesource.com/exp/#\n. HI Yukang. Thanks for the submission.\nThis example doesn't actually send anything over the done channel, so I'm not 100% sure. \nI suppose having the example not exit immediately is good, even if Ctrl-C is required.\n. Alright. You win. :smile:\n. Just some C code that uses kqueue and inotify. Might be some useful tidbits, like their check_create for kqueue does a timestamp comparison before a (slower) hash lookup.\n. Thanks for working on this @chamaken. I left a few comments.\n. Feel free to add more commits here or open a new pull request.\nEpoll vs. select is up to you. Whichever works better.\nThanks @chamaken \n. @chamaken I'm not familiar with either, so I don't know. \nWe could try epoll and see how it goes. We could also request a code review from people on golang-nuts and see what we get back?\n. @chamaken Since I don't know when I'll read my Linux book and figure this stuff out, I put out a request for code review on golang-nuts.\n. Sorry for letting this sit for so long. \nEven though this isn't changing the API, I'm beginning to think that such big internal changes should also warrant a new major version and a release candidate, which is something gopkg.in is considering support for: https://github.com/niemeyer/gopkg/issues/25.\nI'm still figuring out exactly what this should look like.\n. Hi @chamaken,\nI think this is too big of a change for right now. Personally, I still haven't had a chance to learn the various Linux APIs nor have I been able to attract others to help code review and maintain the project.\nIf you're interested in helping make some smaller incremental improvements, I'd certainly be grateful. Right now I'm trying to focus on cleaning up the code (see 1f65e2ef12aa538ba66b432a0c60279f4406add1) so that lower-level concerns are more isolated.\nI'm also trying to get an fslog project going to help better understand the behaviour of each OS.\nThanks for all your work. Nathan.\n. Thanks for the report. I think #39 may address this for inotify. \nIn any case, #39 is a pretty big change, so let's get that in first. Feel free to give it a code review.\n. Right now I can only think of two possible ways to remove recursive watches for #18:\n1. keep track of all the folders we watch, this would be like asking it to remove a specific watch we added\n2. just walk the subfolders of a path and remove any watches that exist\nI'm in favour of 2, as additional watches could be created, and the API at present takes a path rather than a handle to a previous watch.\nHowever, I'd still like to see how Windows and FSEvents (OS X) handle recursive watches and removals before tackling this... which puts it a fair ways off.\n. Quite some time ago I attempted to track all the watched folders independently, but ran into an issue much like #40 in kqueue. I thought the watches were just magically removed when the folder was deleted, but I may have been wrong. (https://github.com/nathany/looper/commit/212051b2ac2b741ac055c68b4ff1434f870401e4)\nIt might be worth building a small test case to see if unwatching deleted folders is necessary. I started hacking on fslog as a place to do those sort of experiments (without all the other stuff fsnotify adds). But so far it only has kqueue.\nIt should be relatively easy to resolve #40, but I'd rather not expose w.watches as an API. It's supposed to be an internal detail.\n. So for 2, fsnotify should itself watch for remove event and do the internal cleanup of w.watches. That could be tricky later on if the user doesn't wish to subscribe to remove events (#7).\nBut for now, my focus is on cleaning up the existing code, primarily separating the lower-level stuff out. Also doing more research as with 1. Fixing #40 and doing the internal cleanup could fit into that.\n. also see #51 \n. Thanks. Is this occurring specifically on Linux?\n. @ottob Thanks for trying this out.\nI presume you did a git bisect to identify that particular commit as the source of the issue?\nDo you have the code that's using fsnotify from this branch? Somewhere at https://github.com/ottob/revel?\nBasically, I need to get a test case to figure out what's going on and prevent this from breaking in the future.\n. Sounds like a difficult issue to track down. I did introduce a bug in 5997fa2 that was fixed in 8a7f75d. I may rebase pull request so that individual commits aren't introducing bugs (for the benefit of bisect).\n. @ottob I read through Revel's watcher.go.\nI'm not sure if this will help with the problem you ran into, seems unrelated. https://github.com/revel/revel/pull/734\nWhich OS are you using? Mac or BSD?\n. @ottob Could you try to get a reproducible case with one of the sample apps and provide me the steps and OS you're using with a new issue?\n. Thanks @ottob. I haven't figured out Revel, so I'm pretty helpless trying to reproduce it.\n. @ottob Ugh. Thanks for digging into this more. Would you mind copy/pasting your last response into a new issue so it doesn't get missed? Thanks.\n. For sure. Thanks for the heads up Quinn.\n. @sqs Does the fancy linking stuff only work for code that compiles on Linux?\nI don't see any fancy stuff for this BSD file:\nhttps://sourcegraph.com/github.com/go-fsnotify/fsnotify@master/.tree/kqueue.go\n. Or maybe I just need to wait a bit... https://sourcegraph.com/github.com/go-fsnotify/fsnotify/.builds/515146\n. I'm not sure. It would certainly be nice to have a better error message. \n. I don't have SharePoint, so I'm not able to reproduce this issue.\nAccording to the Windows documentation:\n\nIf the network redirector or the target file system does not support this operation, the function fails with ERROR_INVALID_FUNCTION.\n\nSo I guess that explains it. \nMaybe I should add that to the FAQ, or we could change how this error is reported at https://github.com/go-fsnotify/fsnotify/blob/master/windows.go#L353.\n. strace and gdb with go test -c from #3.\n. Hm. Interesting. Which operating system?\n. Hi Otto. Sorry for not digging into this sooner. I've never used Revel before, but I got the booking sample running with some additional logging (on the develop branch).\nYour previous bisect had pointed to 4a0d1ae9df8c61fb8912829fc714f189358a3dc7 being the culprit. Most of those changes are to addWatch, so I added some logging there and compared against ca50e738d35a862c379baf8fffbc3bfd080b3cff. With the result you're seeing, it seems plausible that it was watching more than it was previously. \nSo far I haven't figured it out. Still digging. It might be worth confirming that bisect, since you said it wasn't 100% reproducible. If it was a commit before, that could change things quite a lot.\nIf there was a medium sized open source Revel app that we could reproduce this on, that would make it much easier. It might even be reproducible with a similar file structure to your app, even if those files don't contain the same code. /cc @robfig \n. @ottob I hope you have Spotlight disabled for your folder, which can randomly decide to create events. https://github.com/go-fsnotify/fsnotify/wiki/FAQ. \nThough if not disabled, I'd expect you'd see the same problems on v1.0.4 as well.\n. \n. I've ran into a very similar issue here. https://github.com/nathany/looper/issues/18 It is reliably reproducible. Looking into a fix now.\n. @ottob I believe this to be fixed on master. Stupid mistake on my part. Sorry for all the trouble.\n. Feel free to reopen this issue if you still see the issue.\n. It depends a lot on which OS you're using, but you probably want to watch the directory that you will be creating a file in.\n. syscall.ERROR_MORE_DATA was added in Go 1.3.\nAre you willing to upgrade? http://golang.org/dl/\n. Thanks. I put a mention of Go 1.3 in the README for next time.\n. Thanks for the detailed report. I haven't had a chance to play with the example yet.\nOS X is using kqueue, but this may be similar to #40 on Linux (inotify) where fsnotify isn't cleaning up it's internal data for watches.\n. Thanks to your example, I did manage to reproduce the issue on both v1.0.4 (before a bunch of my refactoring) and on the current master. I added some logging into addWatch in kqueue.go.\nkqueue.go is maintaining some internal state to map back and forth between filenames and descriptors. If it's a file descriptor that is already being watched, it can modifies what flags are being watched. This is something used internally.\nWhen a rename or remove event is fired, it calls the exported Remove() method to do some cleanup. For whatever reason it's sending the event on the channel and then doing the cleanup.\nThat's been this way since I adopted the code. Flipping those around makes sense to me.\n. The fix is on master. Doing a release soon.\nIf you have a chance to test it out, please let me know how it goes.\n. Thanks Matt!\nLooking forward to your next contribution. :grinning: \n. Until now I hadn't heard of USN Journals. It sounds worth looking into.\nIs this the state-of-the-art not in just Windows 2000, but also Windows 7, 8, 10?\nWe do have working code for Windows based on ReadDirectoryChangesW. It is based on winfsnotify and everyone who's contributed to it has agreed to the CLA.  \nBut it does need a lot of love (see #6 and #21), and I'm certainly not opposed to doing a fresh implementation if there are APIs that can provide better reliability and closer feature parity to other operating systems.\n. FYI, Go currently requires Windows XP or later, so there is no need to support anything older than that.\n. Is it possible to use USN Journals without Administrator privileges?\n. That's a bit unfortunate.\nDo you want me to create a Windows USN repo under go-fsnotify?\nWe could bring the code over and make sure everything still works in Go 1.3 & 1.4.\n. Nope. Nobody ever was.\n. Hi. So far this issue has just been a place to collect information about USN. Nobody has begun implementing support for it is fsnotify.\nTo support USN directly in fsnotify, I think we'll need a driver system where people can choose between ReadDirectoryChangesW or USN much like choosing a MySQL or Postgres driver. To start, my suggestion would be to build up a stand-alone USN package and then we'll figure out how to integrate it.\nThat could be as a subfolder of this repository or a separate repository (I'm happy to create a repo under the go-fsnotify organization if desired).\nThere's also plenty of clean up work to do on the current Windows support.\nhttps://github.com/go-fsnotify/fsnotify/labels/Windows%20%28ReadDirectoryChangesW%29\nThanks\n. If someone is interested in implementing USN, we would probably start by getting it working outside of fsnotify (much like the fsevents package), and then look at bringing it in afterwards.\nLet me know if you're interested.\n. Hi @jimzhan. Thanks for the report. I need a little more info.\nHow are you writing to the file? Are you using a text editor #17 or touch?\nAre you watching an individual file or he directory containing the file?\nThanks.\n. @jimzhan It's likely to do with \"atomic saves\" in VIM. See #17.\n. I'm not sure what the simple delay trick is? When I use fsnotify, I just treat Create and Write as the same.\n. Thanks for following up. \n. Yah, it would be nice. But unfortunately that's more to do with how the underlying event monitoring systems work and how editors save files than with fsnotify.\n. Hi Matt. Right now it's necessary to launch in a separate Go routine, see https://github.com/go-fsnotify/fsnotify/blob/master/example_test.go\nThis is something that we should address though.\nref also in howeyc/fsnotify https://github.com/howeyc/fsnotify/issues/7\nI'm not sure if a buffered channel will solve it, but I could give it a try.\n. I tried running this second example and it didn't deadlock here (OS X 10.10 here too).\ntouching a file in the same directory touch fsnotify_issue55.go resulted in an event at which point it breaks to Loop and sends a message over the done channel and exits.\nselect will wait for an event from one of these channels. if you don't want to wait, you could add a default: case. I don't think buffered channels would help, that's just the behaviour of select.\n. No problem. More on select:\nhttps://gobyexample.com/select\nhttp://golang.org/ref/spec#Select_statements\n(In particular bullet point 2)\n. Ops are a bit mask so it is a combination of events (4 as well as 2)\nSee the example_test.go to check for individual flags.\n. Thanks for reporting this.\n. @PieterD I'm looking this on OS X and BSD, but it also fails on Linux:\nusing import \"github.com/go-fsnotify/fsnotify\"\npanic: inotify_init: too many open files\n. Excellent.\nkqueue:\nThis is interesting, as Close just calls Remove for all watches. Another race condition? \nClose is ignoring the errors that Remove sends back, in this case: \"bad file descriptor\"\n. Thanks @PieterD. I've already merged a fix for OS X, but I have yet to tag a new release. Tomorrow once the epoll stuff is in.\n. @meatballhat Looks like everything is working. Thanks!\n. If you run into the same issue with this repo, please let me know what OS you are using and some example code if possible.\nI should really send a CL to remove x/exp/fsnotify.\n. Thanks Pieter.\nx/exp is quite a ways behind this repo, but very little has changed on Linux.\n. Thanks for the example. I'll try to take a look on the weekend.\nIf you want to try adding some logging into inotify.go and poke around, any help would be appreciated.\n. Thanks very much!\nI'll take care of exp/fsnotify.\n. merged.\n. I sent in a CL to remove exp/fsnotify. https://go-review.googlesource.com/#/c/3990/1\n. merged.\n. Thanks.\n. Have you confirmed that #3 is fixed by this change?\nI'll take a closer look and do some QA tomorrow before I merge it in. Thanks again for the help.\n. @PieterD Have you already signed Google's CLA for contributing to Go? (This code base originates from Go exp packages and may one day land in Go).\nhttps://developers.google.com/open-source/cla/individual\n. Thanks. I'm on my way to a hack day, fsnotify will be my project for today.\n. And then it gets interesting. :-)\n. Does IN_NONBLOCK help at all? See #5.\n. I admit I don't understand this stuff. I'm yet to become a Linux guru. :-)\n. A separate PR would be appreciated. Let me get this tested and merged in.\n. \u00fcbermess!\n. Hah. \"awesome\" race conditions. So awesome that -race didn't catch it.\n. For the changelog, #5 isn't actually solved yet, correct? (coming next)\n. Squashed and merged. \n5. Doesn't readEvent still block though? That little hack to wake it up on Close might work, but maybe not?\n. kqueue has a timeout right now so that it doesn't block indefinitely, but it does use a little bit of CPU to go around the loop every 100ms.\n. I'm wrong about this. It's fine.\nWe want to run filepath.Clean(name) on user-input.\n. I'm not sure how I should test this. Based on #59, the second Add should reuse the same file descriptor because Close cleaned up. But I don't want to expose file descriptors to the API.\n. guess i can add a kqueue_test.go for that. ok\n. I like how you separated the poller out into a separate file. But man, this makes it so much more complex.\n. Should there be inotify_poller_test.go?\n. Interesting. \nAnother proposal is to have something like Sys() interface{} in FileInfo to retrieve the underlying event data (OS specific bitmask). \nThat doesn't address filtering though.\n. Wow, that is odd. Your code looks good to me, so I'm going to have to do some digging.\nWhat is your import path and is fsnotify the very latest version?\n. @pbdeuchler It's this line right here:\ndefer watcher.Close()\nNothing in Run() is blocking. When it returns we close down the channels, and closed channels always receive the zero value (which is nil for interfaces like error).\nYou probably want to define a separate func (dr *DiskRecieve) Stop() error function to call Close later on in your program execution.\n. event.Op&fsnotify.Write == fsnotify.Write will never succeed when Events is returning a zero-value Event struct.\n. @PieterD I like how we both saw the issue at the exact same time. :smile: \n. A failing test on a new branch would be a good way to start. :-)\n. The FAQ should be clarified. \nIt means that the main goroutine can't be used because it will block.\n. Not Add specifically, but the run loop that NewWatcher kicks off. I think it depends on the OS, whether or not the Kernel is blocking. It would be nice to handle all this better internally, but I haven't looked into it that deeply yet. :disappointed: \n. That error would be coming from here: https://github.com/go-fsnotify/fsnotify/blob/master/windows.go#L448\nUnfortunately I don't know the Windows code very well yet. It was inherited from Chris Howey's version of fsnotify, which was inherited from winfsnotify.\nIf you manage to add enough to a code example to reproduce the issue, that would really help.\n. Sorry, I'm still not really sure. :disappointed: \nAre you using just an ordinary local directory? And you say it's when there are a lot of files? With a few files it works? Maybe I can reproduce the issue. That would be a good first step.\n. Thanks for the info. I'm not sure when I (or someone else) will have a chance to dig into the Windows code for fsnotify to figure out what's going on. But any details to help reproduce it are helpful.\n. Thanks @chamaken. I can take a look sometime over the next few days.\n. Sorry, I still haven't checked this. :-(\n. Merged. Thanks.\n. Thanks for investigating this @tsuna. Would you mind opening a new issue so this doesn't get lost?\n. Yes. I think we should take another look at this code change. Adding and removing watches from the same goroutine should not cause deadlocks.\n. @metakeule You're right. It does depend on the OS.\n23 is a little project I'd like to do to get a better sense of what each OS is doing. Importantly, that would be done at a lower-level than fsnotify, since fsnotify adds some things on top.\nThen I'd like to take that research and write about on the website: https://github.com/go-fsnotify/fsnotify.org So far I've dived into kqueue (BSD, OS X), but have yet to write anything up (other than some notes in #24). There are a few more things I need to look into as well, such as renaming #26.\n. What I like most is that fsnotify and other libraries are free to experiment with different APIs and ways of using the underlying bindings. The lowest common denominator interface vs. emulating features in user-land vs. driver-like systems. Meanwhile the bindings themselves can be really solid and reused.\n. #173 seems like a good place to start\n. Thanks for taking the time to contribute.\nBut I don't really want to add methods to the Event struct. My preference is to keep a minimal API surface with the bitfields exposed for checking, coalescing, etc. This is based on the design document mentioned in the README.\nIf you wants additional methods like this, it's easy enough to convert to a new type and provide them there.\nAn article on how to do this (and how bitfields work) would be a better approach IMO. Happy to take contributions to the fsnotify.org blog:\nhttps://github.com/go-fsnotify/fsnotify.org\n. The use of bitmasks and creation of a wrapper could be documented on the blog. Would anyone like to write it up? https://github.com/go-fsnotify/fsnotify.org\n. I'm closing this in favour of documentation or a blog post. See #107. Pull requests to the website repo are welcome.\n. Strange. I was pretty sure the the go routine would make a difference (https://github.com/go-fsnotify/fsevents/issues/11).\nl need to find some time to try out your example.\n. Apparently not. fsnotify uses inotify under the hood when running on Linux:\n\n/proc is a kernel interface. There are no real files there, hence they can't change. Reading from the handles is a request and the data in the file when you read it is a reply to that. - StackExchange\nThe data that you see when you read from the proc filesystem is generated on-the-fly when you do a read from the begining of a file. That is, doing the read causes the data to be generated by a kernel callback function that is specific to the file you are reading. \n. Hi Wang Jing,\nThis looks unusual. Was there a test.yml file there before? When a REMOVE event happens, it stops watching that file, but I haven't yet looked into this scenario where the file is overwritten.\n. The events from the underlying system are largely unmodified, resulting in differences from one platform to the next.\n\nI'm not sure what the best solution is right now. I don't know if it will always be possible to present the same result across 4-5 platforms.\n. One solution would be not support watching individual files at all. I think that might be the approach that https://godoc.org/github.com/rjeczalik/notify takes. FSEvents on OS X also seems geared towards watching directories instead of files. \nOf course, if a directory is (re)moved, you may still have to watch one level up to see what happened.\n. Maybe there should be a flag indicating if the event is a dir or file event?\n. That would be nice. The question is whether we can add that across each platform without introducing additional overhead (Lstat when not needed).\n. ref #83 \n. Merged. Thanks\n. Moving the String() method does sound like a good idea.Thanks\n. Windows is already supported. See the README.\n. There can be (and sometimes are) multiple Ops in an event. That's why it is a bitmask.\n. @techjanitor for your info, #165 has been merged, resolving the issue you set out to with this pull request.\n. If you can share some sample code to reproduce the issue, that would be helpful..\n. Revert to polling #9 or report an error like #45.\n. @omeid Not as of yet. See https://github.com/go-fsnotify/fsnotify/milestones\n. Hi David,\nThanks for the pull request. Is this meant to address #22?\nThe thing that I'm not sure about is operating systems other than Linux. With this change, there is a Closed event that doesn't mean anything outside of Linux. Hm.\n. I hope you don't mind working off a fork until we come up with a better solution.\n. Quite odd having different behaviour between different Linux versions. Different versions of the kernel, perhaps? Or maybe different versions of vim?\nCan you reproduce the issue usingtouch from the command line instead of an editor? See #17.\n. If you are watching an individual file and it moves, it may no longer be being watched. Better to watch the directory the file is in.\nIf you believe there is a bug, can you please provide more details, such as operating system you are using and a code snippet to reproduce the issue? Thanks.\n(sorry for the late reply)\n. @kkirsche sorry, I'm not sure I follow what's happening in your example.\nmoving/renaming doesn't work so well with the underlying OS notification systems #26\nbtw, which operating system are you testing on?\n. @kkirsche Glad you got it working. Do you have any suggestions for improving the example code or documentation?\n. This is on Linux? Do you think you could provide a code snippet that reproduces the issue? Thanks.\n. I'm not sure if I understand. Op is a bit field with only 5 bits. It should not overflow even an 8-bit int, and it is a 32-bit int.\n. Oh. I've never heard of it.\n. I'm not entirely sure. A git blame points back to this issue in howeyc/fsnotify https://github.com/howeyc/fsnotify/issues/36.\nI don't like the idea of ignoring events either.\n. Thanks Evan. \nIt looks like there is an unrelated problem in CircleCI and Travis. I'll look into it.\n. Merged to master. Thanks.\n. Yup. v1.2.1 released with this change.\nhttps://gopkg.in/fsnotify.v1\n. yikes. What OS did you encounter this on?\nIf possible, can you provide a small code sample that reproduces the issue?\n. If it occurs consistently, you could try changing that lock in your local copy of fsnotify to see if it solves the issue.\n. Hi Uwe. Any updates on this? I haven't ran into the issue yet myself.\n. That might do the trick, but without being able to reproduce the issue, I don't want to just change code and hope it works. Much better if @djui tries it and proves that it fixes his issue.\n. @ppknap I like your plan of using a temporary map. Would you be willing to write up a pull request along with a test case?\nUPDATE: oh, you did add a test case #102. Thanks! For some reason it's not failing on travis-ci running on OS X which does use kqueue.\n. Good idea. Thanks.\n. @djui The race detector isn't finding any races for me on OS X 10.11.2 with Go 1.5.2 or tip, but I've added --race to Travis CI (which includes OS X).\nOn the other hand, there are two races happening on Linux. Looking into those in #105. \n. Oh. It showed up now, thanks to @ppknap's TestRemoveWithClose. Not sure why it didn't show up immediately after I merged that in, but oh well. Looking into it.\n. Please review #105 and when all is good I'll do a new release.\n. Thanks.\nGo itself only requires Linux 2.6.23 or later with glib, so I should add a note to the README about 2.6.27.\n. I'm not sure what the stats are. That's a good idea to look into it. Preferably we won't need a kludge to support the older kernels, but mentioning it in the README and release notes is important.\n. No, sorry for the delay. \nI'll merge some things and do a release later today.\n. Merged. Thanks Riku.\nI'l do a new point release after looking at a few other pull requests.\n. Thanks for the PR. \nRegarding the Linux test failure, I've triggered a rebuild, so we'll see if Travis is just being flaky.\n. Merged as https://github.com/go-fsnotify/fsnotify/commit/2cdd39bd6129c6a49c74fb07fb9d77ba1271c572 and released as 1.2.5. Thanks!\n. I  should add script: go test -v --race ./... to use the race detector on Travis.\n. I'm closing this as it's included in #105, which is on the race branch. Thanks.\n. The current solution is to filter out the events you get back. Indicating which events to watch is an optimization, though not all platforms will be able to filter the same way. Please take a look at #7.\nI'm closing this is a duplicate. If you want to take a stab at it, I'd be happy to review a pull request. Feel free to discuss further at #7.\n. API changes are using Events() and Errors() instead of fields in the platform-dependent struct and returning a FileWatcher interface instead of a *Watcher struct.\nMaybe there is another way to do this that makes the drivers/bindings satisfy an interface, but keeps the existing API as is.\n. I'm not sure if I want to see this much API churn in fsnotify itself. At least in the near-term.\nRather, I'd just like to see the fsnotify split into some independent packages (#75) for each OS while keeping the current API more or less the same. Having those low-level packages in place should enable more experimentation at the higher levels in alternatives to fsnotify.\n. Personally, I'd like to keep the fsnotify API as simple as possible, without requiring the user to know which driver to use. This could be an internal implementation detail at all.\nFor those that need more control, the individual OS-specific packages could be used directly.. I've rebased in squashed commits to (somewhat) avoid test failures in the history.\n. Thanks for your review.\n. Hi @tiwaana. Just prepare a Dockerfile in a pull request that can be used to locally test Linux, with some instructions to do so. The tests (go test) should pass in the container.\n. Part of this move would be to adopt @rjeczalik's notify library as an alternative available from the same organization. Any low-level \"drivers\" for specific platforms would also exist under the new organization.\n. I'm planning to rename the organization as well, since the \"go-\" prefix is a gopkg.in thing.\n. I'm preparing to rename the organization now.\n. The move to https://github.com/fsnotify/fsnotify is done, though I have to ensure CI is still working and update the website.\nGitHub automatically redirects https://github.com/go-fsnotify/fsnotify to https://github.com/fsnotify/fsnotify.\nI tested go get gopkg.in/fsnotify.v1 and it still works, which I did not expect. If we run into any problems, or if we ever need to include github.com/fsnotify/fsnotify in an internal import path, I can put a repository up at github.com/go-fsnotify/fsnotify with a \"maintenance has moved\" message in the README.\n. All done.\n. It could be useful. Though for any API addition or change, I'd like to hear from multiple people, so I'm going to let this sit for awhile.\nOne consideration is that sometimes the underlying OS does buffering of it's own. FSEvents on Mac in particular can even persist events to disk across reboots. I'm not sure how accurate the length returned would be in such situations, but it's worth investigating.\n. Thanks for the report. That is odd. It would probably be worth digging deeper to see if inotify is the cause or if fsnotify is mangling the event somehow.\nAdding some logging in readEvents could help. https://github.com/go-fsnotify/fsnotify/blob/master/inotify.go#L171\n. Thanks @bep\n. Thanks for researching all this Anthony. So in summary:\n- EpollPwait needs to be added to x/sys by us or someone. https://github.com/golang/go/issues/10235\n- We need to switch to x/sys for fsnotify (on Linux at least) and mention it in the README and release notes.\n- We should look into ARM based continuous integration (the Go team is using some custom stuff running on https://www.scaleway.com/)\nWe can switch to InotifyInit1 at anytime, which I believe is available in the standard library sys package. It may require a slightly newer Linux kernel, but that's fine so long as the README indicates the requirements. Feel free to prepare a pull request for that if you like.\n. Ok.\n. Thanks Anthony. If you could do some testing with #135, it would be much appreciated.\n. Thanks @purpleidea. I left some comments.\n. Thanks James. As to your question, if someone does a go get github.com/go-fsnotify/fsnotify the code should compile and build without needing to go generate anything. \nThis applies even more so to a library. For example, if you go get github.com/spf13/hugo which depends on fsnotify, it would fail to build until you run go generate on the fsnotify dependency. If multiple libraries did that it would be a total nightmare for users.\nIt's also what the Go team recommends, and I trust their recommendations, because they have a lot more experience than me. https://blog.golang.org/generate\n. Is that test failure on Windows?\nfsnotify is a bit unusual in that it has a lot of platform-specific code. hopefully we can get this to work without multiple op_stringers for different platforms.\nThe Windows code is a real mess IMO #6. Sorry.\n. I'm too sleepy to be coding on this right now (bugs are inevitable), but I'll try to take a look in the next few days. Thanks for the contrib.\n. pong :)\nsorry.\n. This PR still needs a little more work before it's merged. I can do the work, but I haven't had a chance to yet.\n. see the comments i made during code review.\n. ok.\n. That would be great.\nThe only thing is, how does someone using Linux choose between them? We may need something along the lines of #104 first.\n. @purpleidea I think it would be best to build fanotify Go wrapper out as a separate repo and then look at integrating after that.. @amir73il is working on a \"super block watch\" for Linux, providing \"the ability to set a single (fanotify) watch on a root directory and get notified on all the legacy inotify events without the need to recursively add watches on all directories.\" https://lkml.org/lkml/2016/12/20/312\nThis could avoid the need for a user-space recursive watcher (#16) on modern Linux kernels.\n. Thanks Amir. \nPerhaps another option to make the patched kernel available would be to maintain a Vagrant box built with Packer. That way we could test fanotify super block using a VirtualBox VM from any operating system.. I wonder if this is similar to the issues and fixes for kqueue on BSD (#105), except for inotify.\n. Which platform are you running into this issue on?\n. Thanks. \nWere the events happening previously? Do you have any idea of what may have changed in wellington, or if it was an update to fsnotify? \n. Thanks for reporting this. I haven't noticed gopkg.in being unreliable, but it's another reason to move away from it. See #108.\n. https://github.com/fsnotify/fsnotify is the new home for fsnotify.\n. CLA hub has new maintainers if we want a CLA.\n. maybe keep the 3 clause BSD license but change the wording? e.g. https://github.com/gocql/gocql/commit/bfab7467126ac5a9e7360141737da30214f026c7\n. The CLA and license are needed if Google is to ever use this code in core or x/tools. \nWe need a better solution for enforcing the Google CLA.\nIt would make me feel less awkward if there was an active co-maintainer on the project who is employed by Google.\n. Regarding the CLA, perhaps Google has some code to integrate with GitHub Status in a similar fashion to GitHub themselves.\n\n. closing in favour of #193. Thanks!\n. Finally got my Windows VM working again. Merged. Thanks.\n. This may be related to the way editors save files. See #17 \nCan you try modifying the file at the command line? \nhttp://superuser.com/questions/10426/windows-equivalent-of-the-linux-command-touch/764716\n. Thanks for checking. \nSome people batch up or throttle events if they occur multiple times. Eg. here is the code for Hugo:\nhttps://github.com/spf13/hugo/blob/master/watcher/batcher.go\nThere was a fix for similar issues in OS X with #111, but I'm not sure if the same solution would work on Windows. \n. Thanks for investigating this @tsuna. \nHave you looked at related open issues already? Possibly #115.\n. What do you think of splitting out inotify as a dependency and adding some inotify-specific stress tests there? #173.\nAlso, there are some open pull requests in need of review/testing that may help, such as #149.\n. I'll re-run Travis to see if it's being flaky.\n. Sorry, still haven't reviewed and tested it yet.\n. I'm not that familiar with syscall.Pipe. Hoping someone will review this.\n. Thanks for your patience @fjl.\nThere is currently a data race issue with kqueue on master, which should be remedied first.\nhttps://github.com/fsnotify/fsnotify/pull/162#issuecomment-251575890\nAs to this PR, we need some familiar with epoll to do the code review.\n. sounds good. feel free to merge this.\n. @omeid I agree. We should make that clear in the CONTRIBUTING document and also look into GitHub's branch protection for master.\n. I enabled a few things:\n- The master branch is protected from force pushes. \n- Tests must pass before a branch can be merged to master.\n- Branches must be up-to-date with master before merging.\nIf the tests past on a branch and it is up-to-date with master, it should still be possible to push its contents to master directly. It may or may not work with the \"hub apply mail\" workflow I've been using.\nThough I'd prefer squash merging, merge commits are also enabled for now.\n. This whole idea could be impacted by what we end up doing for #136.\n. Thanks.\n. merged. thanks\n. Yes, this hasn't changed. kqueue does need to keep a file open for every file it watches, plus the directories themselves. On BSD the limits are higher so it's less of an issue than on OS X.\nThere is a way to increase the limit. The FAQ should probably be updated with the commands to do it. https://github.com/fsnotify/fsnotify/wiki/FAQ\nYou can also ensure that you're not watching files that don't need to be watched, such as hidden .git folders.\n. NOTE: The FAQ is now part of the README to increase visibility (#186): https://github.com/fsnotify/fsnotify#faq. Hi Mart\u00edn. Thanks for reporting the issues. Unfortunately I don't have access to Linux on these architectures to test with nor do we have CI/builders on those architectures to catch the issues. \nThe poller code that is failing was submitted by @PieterD in #66 and switched to epoll_create1 by @suihkulokki in #100 in an effort to make it work on arm64. Maybe they will have some insight into why it's failing.\n. thanks Riku\nas to the errors on PowerPC, I really have no idea :cry:\n. Thanks @laboger. Are you planning to do a CL for syscall?\nShould fsnotify switch from using standard libraries syscall to https://godoc.org/golang.org/x/sys?\n. Fixing the standard libraries syscall would be preferable. I just thought it was frozen since Go 1.3, but maybe bugfixes are still okay. Thanks.\n. Is it timing out? Many of the tests only wait so long for the notifications to occur.\n. @TheTincho Can you test arm64 with v1.3.0. It should be working now that @suihkulokki's patch is in: https://go-review.googlesource.com/#/c/21971/\n. I should've looked more closely at @laboger's work before. Apologies.\nLooking through https://github.com/golang/go/issues/15135, Lynn updated the syscall package in the standard library. That fix was made to Go 1.7.\nhttps://go-review.googlesource.com/#/c/22207/\nBut the Go team allowed the patch to be rolled back to Go 1.6.2 which is due out today: https://github.com/golang/go/issues/15288\nRiku took a different approach, revising golang.org/x/sys/unix and switching fsnotify to use it.\nAt this point it probably makes the most sense to apply @laboger's change to x/sys/unix as well. That way fsnotify won't require Go 1.6.2 for ppc.\nI don't know if @suihkulokki's change could have been made to syscall instead, but at this point it's probably too late to make the change there, and still get it in to Go 1.6.2.\n. We really need to get builders #136 setup for these environments. That way we can ensure they are continuing to work with other changes, and we could also see any test failures that occur.\n. @laboger Are you still seeing test failures sometimes? If you are running with the verbose (-v) option it can be difficult to see the failure amidst all the other logs.\n. @laboger Apologies. I merged that change before looking at the work you had done on the syscall library. Would you be willing to submit your syscall changes and any other necessary changes as a CL on golang.org/x/sys/unix? That will enable powerpc to work even on Go 1.5 rather than requiring 1.6.2.\nI'm looking into getting Go's builder machines in place for fsnotify. That way we can ensure it is tested across linux/arm64 and ppc to avoid such issues in the future.\n. Thanks Lynn.\n. @laboger syscall was supposedly frozen when x/sys was extracted. \n. @laboger Here is the relevant proposal and mailing list thread\nhttps://docs.google.com/document/d/1QXzI9I1pOfZPujQzxhyRy6EeHYTQitKKjHfpq0zpxZs/edit\nhttps://groups.google.com/forum/#!topic/golang-dev/gyOoSwxBkCA\n\nWe therefore propose to freeze the package as of Go 1.3\n. This whole thing has brought to light something I didn't realize. There are quite a lot of changes to the \"frozen\" syscall package since September 2014 (when Go 1.4 was released and syscall was \"frozen\"). Perhaps it just was the pragmatic thing to do to keep things working, but it certainly isn't frozen.\n\nThe copy to x/sys happened in August 2014 and x/sys has seen a lot of changes too. But it does make me wonder if there aren't fixes and improvements in syscall that haven't made it so x/sys.\nhttps://github.com/golang/go/commits/master/src/syscall\n. So I've posted a message to golang-dev regarding this whole confusing situation with syscall vs. x/sys: https://groups.google.com/forum/#!topic/golang-dev/cEASnHIXmLI\nI still think the switch to x/sys is a good move simply to support previous versions of Go, but I'm somewhat inclined to do a diff of the two libraries to see if we're missing any syscall patches.\n. There is an open CL for ppc from @clnperez.\nhttps://go-review.googlesource.com/#/c/22605/\nhttps://github.com/golang/go/issues/15393\nI'm not sure about s390x.\n. The change list (CL) has been submitted. Thanks Christy.\ngo get -u golang.org/x/sys/unix\nI don't think any changes are need to fsnotify itself for this update.\n@TheTincho Can you please test it out.\n. see #22. Thanks. It would've been a bit easier to use an alias for the import import syscall \"golang.org/x/sys/unix\" but this is fine.\nIt looks like the CI failure on darwin as something flaky.\nAdding a dependency could break people's builds, so we'll need to release this carefully.\n. @anthonyfok offered to do some additional testing in #112.\nI think we should release this as v1.3.0 by the end of April. I'm thinking of pre-announcing the release to golang-nuts, since it does require a new dependency.\n. Announced: https://groups.google.com/d/msg/golang-nuts/3JLKL785bTY/EacbfZVeAAAJ\nI also left a note in the #fsnotify channel on Slack.\n. merged. thanks\n. As far as local testing, I currently use https://github.com/nathany/vagrant-gopher for BSD and Linux, which I run on a Mac along with a Windows 10 VM in VMware Fusion. Solaris could probably be added, but that still only covers x86.\nI recall some plans to make it possible to utilize the builders from a local computer while debugging issues, but I don't know where that is currently at.\n. From @bradfitz:\n\nCurrently our builders can only run stuff in golang.org/x* and hosted on Gerrit.\nThat's not fundamental, but it's just how things are currently implemented.\n\nI will compose a message to golang-dev tonight after work to see where the community wants to take this.\n. There is also a matter of where the issue tracking is done in the future. In a subrepo or the Go language repo. The change from pull requests to CLs.\nI'm fairly happy with GitHub's recent improvements to pull requests and my own workflows using hub, so it's really just the builders that we need to get going on.\n. Posted to golang-dev to include other Go contributors in the discussion. https://groups.google.com/forum/#!topic/golang-dev/SVrNHQU1oEM\n. Opened an issue over in the Go repository. https://github.com/golang/go/issues/17312\n. Thanks for the report. ppc wasn't resolved in v1.3.0, see issue #130 for more.\n. Please try updating x/sys/unix.\n. From Slack, @flexd reports the same issue with v1.2.11, so this isn't a regression with the new syscall dependency in 1.3.\n. @ppknap Good call.\n@Depado does your code do a similar thing or do you have a different cause?\nMaybe we can improve the documentation or FAQ to indicate that watcher.Close() should only be called when you're done watching, not in a defer in a function call.\n. Closing this. If you have any suggestions for making this more clear in the examples or documentation, feel free to reopen it or open a new issue.\n. closed in favour of #173\n. @pattyshack provided a patch which has been merged to master. \nplease (re)open the issue if you see any further flakiness.\n. Thanks for the report. Which operating system is this on?\n. Thanks @suihkulokki. So sed exhibits the same issues as text editors #17.\n. Thanks for providing a failing test. I won't be merging it until we have a fix, nor will I be merging in with an additional testing dependency (as good as testify may be).\n. Thanks. Would you mind also taking a peek at #124?\n. @jeffwilliams You could checkout an older version of fsnotify and vendor that code. The change to EpollCreate1 was made in v1.2.5. See releases.\nI'm not sure if there is a good way to fallback to the old EpollCreate, so I'm going to go ahead and close this. \n. I've personally not test with 10k+ files. We should try to establish if the underlying inotify code handles that many files properly (for a given kernel). Assuming it does, then we will at least know it's an issue in fsnotify.\n. > \"IN_Q_OVERFLOW is emitted when the appropriate queue is full and can't take more events. If this event occurs frequently you should read events faster and eventually increase the limit for queues. This limit can be read and changed by reading/changing the appropriate procfs file (/proc/sys/fs/inotify/max_queued_events).\" - http://inotify.aiken.cz/?section=inotify&page=faq\nWould it be possible to test this by temporarily modifying /proc/sys/fs/inotify/max_queued_events to a small value? (An inotify-specific tast with the linux build tag)\nIf an integration test isn't possible (or reliable), then how should this be manually tested?\n. Ok.\nWe have a new pull request template: https://github.com/fsnotify/fsnotify/blob/master/.github/PULL_REQUEST_TEMPLATE.md\nI'd like to ensure all these questions are answered for any pull request.\nWhat does this pull request do?\n\nUpon receiving an event with IN_Q_OVERFLOW set in the mask, generate an\nerror on the Errors chan, so that the application can take appropriate\naction.\n\nWhere should the reviewer start?\nHow should this be manually tested?\n. @zeldovich Have you signed the Google CLA? We need contributors to sign the CLA so that fsnotify can be used in Go tools in the future.\nhttps://cla.developers.google.com/about\n. Thanks @bep. It seems all the current pull requests are failing in odd ways. We should really look into fixing or removing faulty tests.\n. This may be related to #142.\n\npanic: Fail in goroutine after TestInotifyStress has completed\n. Yes, we should be using filepath.Join.\n\nFor the moment, does it work to just watch \"c:\"?\n. Hi. File notifications have a tendency of not working across shares (NFS, Vagrant mounts), but it is curious that changing a file in virtualbox worked in the container. I haven't tested this particular case myself.\nAs far as the events passed, how are you changing the file? That may be related to how a text editor makes the change. See #17.\nWhat are you hoping to accomplish? If you need to detect changes to files on the Windows host, as seems to be the case, you will most likely need to watch the files in Windows and then trigger whatever action you need.\nIf instead you are looking to watch files inside the vagrant box, it's best to use a directory that isn't shared from the Windows host, as that usually won't work (as you've seen).\n. Thanks for investigating this further. Unfortunately the underlying file notification systems have some limitations and differences, which make it difficult to get the consistent behaviour we would all like to have. If we can improve something though, we'll certainly try.\n. looks good. thanks\n. Something is flaky with Mac tests, but the Windows tests on Appveyor passed.\nNotice that it's logging events with \\\\ double slashes everywhere though. Hm.\n. Yah, don't worry about the the Mac tests. That's a separate issue.\nYou can see the output in Appveyor (Windows CI) by clicking the link: https://ci.appveyor.com/project/NathanYoungman/fsnotify/build/1.0.209\nIt may just be a %q vs. %s thing. I'll double check before merging/releasing this.\n. Merged. I still have to tag a release and update the changelog, etc.\nThanks Bruno\n. Not currently. Some platforms include a flag for that but not all. Currently fsnotify is doing the lowest common denominator thing and not reporting it, as opposed to doing an os.Stat to always provide that information.\n. > IN_CLOEXEC\n\nSet the close-on-exec (FD_CLOEXEC) flag on the new file descriptor. See the description of the O_CLOEXEC flag...\nO_CLOEXEC (Since Linux 2.6.23)\nEnable the close-on-exec flag for the new file descriptor. Specifying this flag permits a program to avoid additional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag. Additionally, use of this flag is essential in some multithreaded programs since using a separate fcntl(2) F_SETFD operation to set the FD_CLOEXEC flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does a fork(2) plus execve(2).\n\nfsnotify currently uses InotifyInit (not InotifyInit1).\n\ninotify_init() first appeared in Linux 2.6.13; library support was added to glibc in version 2.4.\ninotify_init1() was added in Linux 2.6.27; library support was added to glibc in version 2.9.\n\nThis is fine (IMO).\nWhat about support on ARM and PPC64? /cc @suihkulokki @TheTincho @clnperez @laboger @tophj-ibm?\n. @TheTincho That would be very helpful. Thanks. inotify_init1 and the flags it takes. The code change is in #178.\nI wonder if we should be using IN_NONBLOCK as well? (#5) https://github.com/fsnotify/fsnotify/blob/master/inotify_poller.go#L48\n. Is there any reason why someone would want the child process to have the inotify file descriptor carried over? \nPresumably a new one would be created in the child process instead if needed.\n. Thanks. Still need to look into these flaky tests.\n. Maybe the terminology is confusing? The path on Linux should be relative to whatever you are monitoring. If the current working directory was tmp and you monitored EFlmKJ8XTYmnxQIucRkY2A/ then you should see EFlmKJ8XTYmnxQIucRkY2A/qmp.sock (relative to tmp).\nWhether the filename is included or not doesn't make the path absolute rather than relative.\nIf you want to strip off qmp.sock for some reason, you can always use filepath.Dir() from the standard library.\n. It is relative to the folder being monitored.\nIf you monitor /home/go/src then the notification paths will include /home/go/src/.... If you monitor src then the path will only include src/.... In order to do the later, your current working directory matters.\nNot saying it's the best thing. Maybe the paths returned should always be absolute. It would probably work to just call filepath.Abs on the path you want to monitor rather than every path returned for a notification -- though we'd need to verify it across each platform.\n. I opened an issue for this (#160). Thanks for bringing it up.\n. it looks like there is a data race to fix\n. Still seeing data races on Travis. Doh!\nSpecifically on macOS. The race on Linux is resolved.\n. data races in all the places\nwill come back to that one. \ud83d\udca4 \n. on macOS Sierra 10.12\n```\n\u276f go test -race -test.count=10\nPASS\nok      github.com/fsnotify/fsnotify    104.165s\nfsnotify git/master\n\u276f go16 test -race -test.count=10\n```\n... the later doesn't seem to be finishing anytime soon\n```\n\u276f go16 test -race \ntestmain\nfatal error: unexpected signal during runtime execution\n...\n```\nBut then Go 1.6 doesn't work on Sierra anyway. I wonder what version of macOS Travis is running? Might need a macOS VM just to test Go 1.6 locally. \ud83d\ude22 \n. well this is embarrassing... \ud83d\ude0a \nupdated for Go 1.8. also requested Go 1.8 for AppVeyor. https://github.com/appveyor/ci/issues/1330\nCurrently Windows tests are using Go 1.7.1. @twpayne Thanks for the note. The only problem with using .x is we need to wait for Travis CI to update their aliases, but they are in place now. I will update.\nSee: https://github.com/travis-ci/travis-build/pull/956. fsnotify doesn't currently support a file closed event -- I don't believe every platform that fsnotify supports has such a event.\n. Thanks for the report @jiangytcn.\nWe are running the tests with -race yet it hasn't caught this issue. From your description, it sounds like it rarely occurs, which is going to make it hard to track down.\nPlease let us known what go version you are using and if possible, include some sample code for how you are using fsnotify. Thanks.\n. Thanks @oozie and @jiangytcn. Related to #168.\n. @ishustava regarding ginkgo, see https://github.com/fsnotify/fsnotify/issues/167 for the discussion. thanks.\n. Hi Slawek. I would rather not introduce a testing dependency in fsnotify or other libraries I work on. I believe it's easier for contributors to use the baseline standard library tests that everyone should be familiar with. Personally I'm not a fan of BDD-style DSLs in Go. Nathan.\n. When I first started using fsnotify I had the same question and wrote all the code to remove the watchers only to find that the remove failed because the watch was already gone. I was using kqueue on macOS at the time, so I'm not 100% sure for inotify on Linux.\n. Documenting that it's unnecessary would be good -- though it would be good if it handled removing better as well.\n. Thanks @oozie. Still need to deal with flaky kqueue tests in #162 also -- not sure if that's related.\nI've not seen a pointer to a Mutex in common practice, so this is interesting. \nDo you think it would be worth restructuring the code further to make it clear what the mutex guards? I really like this idea: https://talks.golang.org/2015/tricks.slide#15\n. Renames and moves is certainly less than ideal in fsnotify -- not only with inotify, but across all operating systems. See also #26.\n. FYI, epoll was added in #66. It certainly complicates the code quite a lot.\n. related #170\n. Should this effort include fanotify on Linux as well? #114. @tiwaana Sounds awesome. Is the next DTC meetup the Feb 16 launch party for Go 1.8?. I merged #175. Want to rebase and give this another go on Travis?\n. Both locally and your remote? :cry: \nSorry, I guess I did ask you to rebase on master. Darn rebase.\nA new PR is fine by me though.\n. Thanks.\nOut of curiosity, what error occurred when the linter didn't build? I'm a bit surprised over the issue.\n. Oh, I see.\n```\ngithub.com/golang/lint\n../../golang/lint/lint.go:249: undefined: types.ImportMode\n```\nfrom https://travis-ci.org/fsnotify/fsnotify/jobs/165118920\nThere is a closed issue with a similar error https://github.com/golang/lint/issues/246\nAnd lint doesn't test itself on Go 1.5.4 \nhttps://github.com/golang/lint/commit/e39d62944f60e7296290f116b5f99ac3a4d1fce3#diff-354f30a63fb0907d4ad57269548329e3\n. Thanks. Your fix should address 1 or 2 of these issues -- https://github.com/fsnotify/fsnotify/issues?q=is%3Aopen+is%3Aissue+label%3Acritical\n. It still seems to be a bit flaky (#142) for me, though the data race (#150) is resolved.\nvagrant@vagrant-ubuntu-trusty-64:~/src/github.com/fsnotify/fsnotify$ go test ./... -race\n--- FAIL: TestInotifyStress (1.43s)\n    inotify_test.go:263: Creates and removes should not be off by more than one: 2 creates, 1000 removes\nFAIL\nFAIL    github.com/fsnotify/fsnotify    9.945s\nvagrant@vagrant-ubuntu-trusty-64:~/src/github.com/fsnotify/fsnotify$ go test ./... -race\nok      github.com/fsnotify/fsnotify    10.738s\nvagrant@vagrant-ubuntu-trusty-64:~/src/github.com/fsnotify/fsnotify$\n. Yah, looks that way. https://github.com/fsnotify/fsnotify/issues/142#issuecomment-242377927\nThanks for your work on this.\n. Thanks, it's working well for me also.\nFYI, this stress test was added in #66.\n. Thanks. P.S. I invited you to the repo, but please continue to use branches and pull requests for any code changes.\n. Waiting on feedback/testing for ARM and PPC64 before merging.\n. Can you provide steps to manually test that file descriptors are no longer leaking with this change?\n. @clnperez That's odd. I wonder if the IN_CLOEXEC flag isn't getting passed in properly or what could be causing the discrepancy on ppc.\n. I don't know why this wouldn't work. https://github.com/golang/sys/blob/master/unix/zsyscall_linux_ppc64le.go#L629\nIN_CLOEXEC is defined with the same value as other platforms.\nhttps://github.com/golang/sys/blob/master/unix/zerrors_linux_ppc64le.go#L510\nSo I wonder where the problem is.\n. Linux\n\u276f lsb_release -a\nNo LSB modules are available.\nDistributor ID: LinuxMint\nDescription:    Linux Mint 17.1 Rebecca\nRelease:        17.1\nCodename:       rebecca\nmacOS\n\u276f sw_vers\nProductName:    Mac OS X\nProductVersion:  10.12\nBuildVersion:    16A323\nWindows\n\u276f systeminfo | findstr /B /C:OS\nOS Name:                   Microsoft Windows 8.1 Enterprise Evaluation\nOS Version:                6.3.9600 N/A Build 9600\nOS Manufacturer:           Microsoft Corporation\nOS Configuration:          Standalone Workstation\nOS Build Type:             Multiprocessor Free\n. Sorry, I can't accept a pull request that isn't cross platform.\nbut see #173\n. Thanks for reporting the issue. Would you mind elaborating with specifically what you do with inotify-tools that does work for those not familiar with it?\n. I've setup GitHub teams for each platform. If you have already contributed to fsnotify and would like to be added to a platform-specific team, please let myself or another maintainer know.\n. @zchee Initially I'm thinking we build up repositories for https://github.com/fsnotify/inotify, etc. independent of the fsnotify package. Then start replacing the low-level bits of the fsnotify package with dependencies on those, while maintaining the same cross-platform API.\nEventually we can also substitute kqueue for fsevents on darwin.\nIf you'd like to help out, take a look at the https://github.com/fsnotify/fsevents project. There is an open issue with some next steps there, and I'm sure there's much more to do.\n. They are quite different. Right now I'm not thinking of changing the API of fsnotify. Just keep it stable for users.\nIf we can separate the code into low-level bits and high-level bits, I think it will be easier to maintain, as separate teams of people will be able to focus on each platform, with one team on cross-platform concerns.\nNot sure if I'm explaining it well, it might be easier to show than explain.\nI've already started with kqueue, where the code from line 463 on is the low level part. https://github.com/fsnotify/fsnotify/blob/master/kqueue.go#L463. I'm thinking of putting that in a separate repo with a test suite and documentation and making that into it's own library that fsnotify depends on. \nStill many details to work out though -- and certainly open to other ideas.\n. I could still really use some help to maintain fsnotify. Code reviews, testing and merging PRs, doing releases.. Clearly I have been doing a poor job of maintaining fsnotify. Issues without answers, pull requests left open for months... progress has stalled not due to lack of contributors, but because I am currently the bottleneck.\nWhen I got involved with Chris Howey's fsnotify, it was to help out with the API. I don't have the experience and knowledge of file systems necessary to vet a pull request like #124, which adds epoll to kqueue. Much less take on a whole new platform like #196. At first I thought I would learn these things, but doing so hasn't been a priority in what spare time I do have.\nI had hoped that having a generous policy (#126) for granting commit access combined with this call for maintainers would see a team of people volunteer to help maintain fsnotify. I had high hopes for splitting responsibility by operating system to make maintenance more palatable. But that hasn't happened... and I don't know what needs to be done for that to happen.\nAt this point, I am tired of feeling guilty for not being more involved in the project. I'm also tired of worrying that merging a pull request will break an upstream like Docker or a platform that isn't under CI (#136).\nI haven't been very involved lately, so it's time to make it official. I'm stepping away from the fsnotify project. It's up to you now.\nIf you need something from me during the transition, reach out to me here or on #fsnotify on Slack. Good luck.\n. Relevant: https://github.com/blog/2392-introducing-code-owners. thanks @vahe. \nMaybe the FAQ and other documentation would be more visible if it were moved from the GitHub Wiki to the website? What do you two think?\nhttps://github.com/fsnotify/fsnotify.org\n. Moving the FAQ to the README sounds good. Let's do it.\n. Hi @Allendar. The example we have is correct and tested by the test suite. I'm not sure what the confusion is here, but I'm closing this issue.\n. updated and merged. thanks. Sorry for the delay. I'll try to carve out some time over the Christmas holiday to work on fsnotify.. @twpayne Thanks and apologies for the delay. @ppknap Thanks also for reviewing.\nOne consideration is the performance of wide vs. narrow mutexes:\nhttps://talks.golang.org/2017/state-of-go.slide#25\nBut I think this is a good change, and we can come back to performance considerations later.\nI'll take a closer look and merge + prepare a release in the next few days. Thanks!. @twpayne It's only abandonware if nobody steps in to replace me.\nhttps://groups.google.com/forum/#!topic/golang-nuts/Ix4sg_gDLNE\nsee #183. @twpayne No worries. \nYou are right, for a Linux-only change, CI is enough and hitting merge is fine. Thanks @ppknap for reviewing and merging.\n@twpayne Did you happen to sign the Google CLA at some point? That process still needs to be automated. #193.\nThere are a few more steps to do a release which should probably be documented somewhere. Updating the AUTHORS file, CHANGELOG, and Releases after tagging a version. Creating an issue around that: #201.. Thanks for reporting the issue.\nI've not tested fsnotify with gccgo yet, nor do we have it set up in CI. That would be a good idea.. related: #22, #131 . I think this needs more discussion before opening any pull requests, as it likely involves an addition or change to the API, and fsnotify is a cross-platform API.\nThe suggestion of exposing a file-system specific mask might not be such a bad idea. See FileInfo as an example:\nSys() interface{}   // underlying data source (can return nil)\nAlso see #173 regarding the spinning out of a stand-alone package specifically for Linux.\n. @radu-munteanu I'm hoping a few people step up to build and maintain the inotify spin-off. Then there is still some amount of work to integrate that back into fsnotify with a cross-platform API.\nI'm not sure if > 32 or > 64 ops would really be necessary, but it is certainly worth considering alternative approaches to the API for the spin-off. \nHoping to keep the cross-platform fsnotify API itself fairly stable.. kqueue (BSD) also has NOTE_CLOSE_WRITE and NOTE_CLOSE.. Thanks @willnorris.\nThe licensing and CLA has felt awkward to me for a long time (#119). Let me confirm if the Go team still has any plans to use fsnotify in core. I'll post to the golang-dev mailing list and drop a link here.\nWhat would need to change for Google to be the project maintainer? If there were some Google employees maintaining fsnotify, would that be sufficient? I'm happy to pass over the reigns to make it work.. Using fsnotify in core, license and CLA \nhttps://groups.google.com/forum/#!topic/golang-dev/UwNizs08YD0. @willnorris I would really like to sort out the licensing issue. Thanks.\nhttps://groups.google.com/forum/#!topic/golang-dev/UwNizs08YD0. @bradfitz suggests doing something similar to Camlistore. From https://github.com/camlistore/go4/#details:\n\nCLA compliant contributors must agree to the Google CLA (the same as Go itself). This ensures we can move things into Go as necessary in the future. It also makes lawyers at various companies happy. The CLA is not a copyright assignment; you retain the copyright on your work. The CLA just says that your work is open source and you have permission to open source it. See https://golang.org/doc/contribute.html#tmp_6\n\nHere are the instructions from @willnorris. I suspect we will want the CLA checking for the whole organization, including fsevents or any new repos created. The fsnotify.org website doesn't really need it, but why not.\n\nHere's the instructions to enable CLA checking for fsnotify.  You can do it either at the organization level, in which case it will apply to all repos in the org, or just to the individual repos you want it activated for.  The same webhook secret will work in either case.\n\n\nGive googlebot write access to the repos.  Adding as an outside collaborator is fine, or you can add the account to the org if you don't want to setup each repo individually.  Up to you.  Write access is needed in order to set commit statuses and issue labels.\n\n\nIf you want googlebot to set issue labels, go ahead and create the labels \"cla: yes\" and \"cla: no\".  If you don't care about the labels, and will just check for the commit status, then just don't create them and googlebot won't try to add them.\n\n\nAdd a new webhook to the org or repo:\n\n\nPayload URL: https://cla.developers.google.com/api/github/webhook\nContent type: application/json\nSecret: [elided, ask]\nWhich events would you like to trigger this webhook?\nSelect \"Let me select individual events\" and then select only \"Issue comment\" and \"Pull Request\".\nActive: this should be checked\nThat should be it.\nMost of the time it should go pretty smoothly.  The one edge case that we don't handle well is when someone is submitting a PR containing commits that they did not author themselves.  In that case, the comment from googlebot should hopefully explain the situation pretty well.  It's a case where we rely on a human being (you) to do a little bit of legwork and go ahead and merge the commit, even though the official status from googlebot says that things aren't okay.  I've got a feature request outstanding to try and handle this case better.\n. @4ad @amitkris Please review.. @gfrey We don't currently have a good way to test Solaris, either with a CI service or locally from a different OS (I use Vagrant Gopher for Linux/BSD). Any suggestions?. @gfrey Thanks both for this pull request and your work on Vagrant Gopher to test it.\n\n\u276f vagrant ssh solaris -c 'go version; cd fsnotify/fsnotify; go test ./...'\ngo version go1.8 solaris/amd64\n/export/home/vagrant/src/github.com/fsnotify/fsnotify\nok      github.com/fsnotify/fsnotify    8.332s\nConnection to 127.0.0.1 closed.\n(unfortunately no race detector on Solaris)\nI'm still hoping @4ad and/or @amitkris provide a review, but I will also take a closer look in the coming days.. Sounds like a mighty good idea, though I have no insight into what has changed since the last release, or if it's \"safe\" to tag a new release.\nAs per my comment here, I haven't been following the project since March.. Thanks @thaJeztah.\nUnfortunately I haven't gotten around to #201 to describe how releases have been done in the past. Not that the process couldn't be modified to suit whoever takes up the baton. \ud83d\ude09 . Should we also suggest the use of dep for the next release? https://github.com/golang/dep\nIt may not change the actual release process beyond initial updates to the README.. ",
    "bradfitz": "Only designing an API is the hard part. Using C is still allowed (like the\nos/user package) and new syscalls are fine too, in a private package.\n. I've also been working to make Github pull requests auto-convert into Gerrit reviews. (https://github.com/LetsUseGerrit/)\n. Only designing an API is the hard part. Using C is still allowed (like the\nos/user package) and new syscalls are fine too, in a private package.\n. I've also been working to make Github pull requests auto-convert into Gerrit reviews. (https://github.com/LetsUseGerrit/)\n. ",
    "PieterD": "I'll put this here for now. Anyone interested, please comment.\nhttps://docs.google.com/document/d/15MQZlc6S9toF-ikUiLtuA3t8bK51ScX3zED5liAPDSY/edit?usp=sharing\n. go test -c\n. This would cause a tremendous amount of problems. With my next pull, I've got w.Close waiting until the goroutine is done. That will fix this.\n. If Close just removes all watches but the goroutine blocks on something, the goroutines will start heaping up as you keep adding more goroutines, all blocking, all keeping open files.\nThey don't even have to block; if you create the next goroutine without waiting for the last one to finish, you could create a thousand before the first goroutine has a chance to clean up.\n. Confirmed that https://github.com/go-fsnotify/fsnotify/pull/66 fixes this for inotify. For OS X, I suggest making sure Close waits until the goroutine is stopped before returning.\n. Dang, I was going to check my version, but I'm using golang.org/x/exp/fsnotify, which is not this repository. Sorry for the noise.\n. I will try to do both tonight. If I manage to reproduce it with golang.org/x/exp/fsnotify (it looks very timing-sensitive) I'll try to do the same with this one.\nMore info to follow, but it may have to wait for a bit because work. I'm on Linux/x64.\n. The problem appears in both fsnotify packages. I'm afraid it might be in syscall, specifically InotifyInit. I hope not, because that would be bad news.\nI could reproduce the problem with this:\n```\npackage main\nimport (\n  \"time\"\n  \"fmt\"\n  \"github.com/go-fsnotify/fsnotify\"\n  \"os\"\n  \"syscall\"\n)\nfunc Panic(err error) {\n  if err != nil {\n    panic(err)\n  }\n}\nfunc main() {\n  go sig()\n  go notify()\n  <-time.After(5 * time.Second)\n}\nfunc notify() *fsnotify.Watcher {\n  w, err := fsnotify.NewWatcher()\n  Panic(err)\n  defer w.Close()\n  err = w.Add(\".\")\n  Panic(err)\n  defer w.Remove(\".\")\n  for {\n    select {\n    case err := <-w.Errors:\n      Panic(fmt.Errorf(\"fsnotify error from Error channel: %#v\", err))\n    case <-w.Events:\n    }\n  }\n}\nfunc sig() {\n  p, err := os.FindProcess(os.Getpid())\n  Panic(err)\n  for {\n    p.Signal(syscall.SIGUSR1)\n  }\n}\n```\n. See also https://github.com/golang/go/issues/9782\n. Of course it could be as simple as ignoring EINTR, which might be where this is going. I just worry the call is secretly blocking.\n. I'll take a look at this tonight and keep you posted.\n. Okay, so it uses syscall.Read, and it blocks. So it will need at least a runtime.LockOSThread in the readEvents goroutine, I think.\nSecond, it can get interrupted by signals, so it needs a little help ignoring EINTR.\n. Ian cleared it up for me, no need for runtime.LockOSThread. I'll fix up the EINTR thing in the near future. Would you like me to send a CL to fix exp/fsnotify as well, or do you want to remove it? I'm thinking getting rid of it should be done by you.\n. Pull requested: https://github.com/go-fsnotify/fsnotify/pull/62\nI think you'll like the Go issue that this spawned: https://github.com/golang/go/issues/9785\nThat issue also explains why EINTR was happening.\n. Nice. I sent you an email regarding some other work on inotify.\n. Never mind, I got carried away and already made a pull request.\n. I've checked. I did the same as you (checked /proc/x/fd), disabled tests until i found the one that did it. Unsurprisingly, it was a blocking goroutine.\nIt still happened due to corner case that I hadn't covered yet; in close, when there were watches to remove but they all gave errors, the 'wakeup' wasn't done. Now it is. And thus it is fixed.\n. Did that (and A+C) years ago. It's fine.\n. There's still some uncertainty when closing which I'm fixing now.\n. Nice. I'm using epoll to get rid of the last bit of uncertainty.\n. Yeah, it's a lot of busywork for a small imperfection, but it's got to be done. You could accept the pull as is, and I'll shoot the epoll thing as a seperate pull request. That might ease the review.\n. Man, it SUCKS that syscall.Read doesn't unblock with you close the file descriptor. Even epoll doesn't respond when you do that.\n. Please. It would be nice to seperate this mess and the next mess, instead of creating one giant ubermess :P\n. HOLY CRAP I just figured it out. There's a truly awesome race condition that happens :D\nI was wondering how it could be possible that sometimes, test n was making test n+1 fail with \"bad file descriptor\" or with the wrong number of events.\nWhat happens is that when you've got a goroutine waiting for events, it's possible to close it and create a new one, before other goroutines have a chance to respond. But since the previous descriptor was closed, the new inotify file descriptor will have the same number as the previous one, which will then get closed once the previous test's goroutines wake up and close their stuff.\nSo, yeah. From now on, Close waits for the readEvents goroutine to finish.\n. So if, during the execution of Add, some other goroutine closes the watcher and something else opens a file descriptor, it'll get messed up.\nThis changes a lot. Add and Remove will have to be properly synced with readEvents. Yeah, I don't think think you'll like the next pull request.\n. I wonder if -race could be adapted to catch this.\n. I was under the impression that https://github.com/go-fsnotify/fsnotify/issues/5 was about goroutines blocking forever.\nPerhaps I'm mistaken.\n. readEvents still has a blocking read on the file descriptor, but that's fine. So does kqueue and the Windows thing.\nIt should get cleaned up pretty much always, but not ABSOLUTELY always. That's the next one. So yeah, I suppose #5 might not be fixed until I push the epoll stuff.\n. You can look at the internal field from Test.\n. That would happen when the goroutine dies. Sounds bad.\n. Thinking about it now, you're only getting stuff from Errors, so Events is still open.\nI'd take a look at the code, but I won't see a computer until tonight.\n. Oh. I got it. It's in your code. You create the watcher, defer close, and wait for stuff in a goroutine... But then you return from the function that has the defer close.\nA question might be, is the events channel being properly closed by the goroutine?\n. Hah! Sweet. I was in the train on my phone, so I had a few minutes.\nBy the wat, watcher.isClosed is racey in almost every case.\n. Ah that's how the events chan wasn't reporting. Duh. Thanks :D\n. Happens to everyone. Good luck :)\n. Er, am I blind? I shouldn't open issues from my phone. Disregard this until i get home to look again lol\n. I know I saw something when I was on my phone, but since I had to switch to the comment thing I lost it. So keep this open for a bit please, I'll look at it this weekend.\n. Yeah, it would :)\nhttps://github.com/go-fsnotify/fsnotify/issues/10\n. Sure thing, I'll take a look at this tonight or tomorrow. Thanks.\n. Don't have much time (I'm on holiday!) but I've got a few minutes.\n. Sorry, I don't have a ton of time :(\nI'm a bit confused about what the patch is meant to fix. Could you elaborate?\n. Thanks. There was some stuff in there I thought might save some time looking stuff up in the future :)\n. LGTM. I don't have a linux machine handy so I can't play around with it, but it looks good.\n. I agree. It is known. I actually think a radically different api is required. Unifying all the different systems into a single common denominator api is... Well, it's hard.\nUnfortunately, there's just the two of us at the moment, and we're pretty busy ourselves. Sorry. When I get back from holiday next week I plan to pick it back up. Until then, feel free to contribute.\n. I've put up a document on the redesign issue. Feel free to comment.\nhttps://github.com/go-fsnotify/fsnotify/issues/1\n. I also don't have those architectures, sorry.\n. I'll put this here for now. Anyone interested, please comment.\nhttps://docs.google.com/document/d/15MQZlc6S9toF-ikUiLtuA3t8bK51ScX3zED5liAPDSY/edit?usp=sharing\n. go test -c\n. This would cause a tremendous amount of problems. With my next pull, I've got w.Close waiting until the goroutine is done. That will fix this.\n. If Close just removes all watches but the goroutine blocks on something, the goroutines will start heaping up as you keep adding more goroutines, all blocking, all keeping open files.\nThey don't even have to block; if you create the next goroutine without waiting for the last one to finish, you could create a thousand before the first goroutine has a chance to clean up.\n. Confirmed that https://github.com/go-fsnotify/fsnotify/pull/66 fixes this for inotify. For OS X, I suggest making sure Close waits until the goroutine is stopped before returning.\n. Dang, I was going to check my version, but I'm using golang.org/x/exp/fsnotify, which is not this repository. Sorry for the noise.\n. I will try to do both tonight. If I manage to reproduce it with golang.org/x/exp/fsnotify (it looks very timing-sensitive) I'll try to do the same with this one.\nMore info to follow, but it may have to wait for a bit because work. I'm on Linux/x64.\n. The problem appears in both fsnotify packages. I'm afraid it might be in syscall, specifically InotifyInit. I hope not, because that would be bad news.\nI could reproduce the problem with this:\n```\npackage main\nimport (\n  \"time\"\n  \"fmt\"\n  \"github.com/go-fsnotify/fsnotify\"\n  \"os\"\n  \"syscall\"\n)\nfunc Panic(err error) {\n  if err != nil {\n    panic(err)\n  }\n}\nfunc main() {\n  go sig()\n  go notify()\n  <-time.After(5 * time.Second)\n}\nfunc notify() *fsnotify.Watcher {\n  w, err := fsnotify.NewWatcher()\n  Panic(err)\n  defer w.Close()\n  err = w.Add(\".\")\n  Panic(err)\n  defer w.Remove(\".\")\n  for {\n    select {\n    case err := <-w.Errors:\n      Panic(fmt.Errorf(\"fsnotify error from Error channel: %#v\", err))\n    case <-w.Events:\n    }\n  }\n}\nfunc sig() {\n  p, err := os.FindProcess(os.Getpid())\n  Panic(err)\n  for {\n    p.Signal(syscall.SIGUSR1)\n  }\n}\n```\n. See also https://github.com/golang/go/issues/9782\n. Of course it could be as simple as ignoring EINTR, which might be where this is going. I just worry the call is secretly blocking.\n. I'll take a look at this tonight and keep you posted.\n. Okay, so it uses syscall.Read, and it blocks. So it will need at least a runtime.LockOSThread in the readEvents goroutine, I think.\nSecond, it can get interrupted by signals, so it needs a little help ignoring EINTR.\n. Ian cleared it up for me, no need for runtime.LockOSThread. I'll fix up the EINTR thing in the near future. Would you like me to send a CL to fix exp/fsnotify as well, or do you want to remove it? I'm thinking getting rid of it should be done by you.\n. Pull requested: https://github.com/go-fsnotify/fsnotify/pull/62\nI think you'll like the Go issue that this spawned: https://github.com/golang/go/issues/9785\nThat issue also explains why EINTR was happening.\n. Nice. I sent you an email regarding some other work on inotify.\n. Never mind, I got carried away and already made a pull request.\n. I've checked. I did the same as you (checked /proc/x/fd), disabled tests until i found the one that did it. Unsurprisingly, it was a blocking goroutine.\nIt still happened due to corner case that I hadn't covered yet; in close, when there were watches to remove but they all gave errors, the 'wakeup' wasn't done. Now it is. And thus it is fixed.\n. Did that (and A+C) years ago. It's fine.\n. There's still some uncertainty when closing which I'm fixing now.\n. Nice. I'm using epoll to get rid of the last bit of uncertainty.\n. Yeah, it's a lot of busywork for a small imperfection, but it's got to be done. You could accept the pull as is, and I'll shoot the epoll thing as a seperate pull request. That might ease the review.\n. Man, it SUCKS that syscall.Read doesn't unblock with you close the file descriptor. Even epoll doesn't respond when you do that.\n. Please. It would be nice to seperate this mess and the next mess, instead of creating one giant ubermess :P\n. HOLY CRAP I just figured it out. There's a truly awesome race condition that happens :D\nI was wondering how it could be possible that sometimes, test n was making test n+1 fail with \"bad file descriptor\" or with the wrong number of events.\nWhat happens is that when you've got a goroutine waiting for events, it's possible to close it and create a new one, before other goroutines have a chance to respond. But since the previous descriptor was closed, the new inotify file descriptor will have the same number as the previous one, which will then get closed once the previous test's goroutines wake up and close their stuff.\nSo, yeah. From now on, Close waits for the readEvents goroutine to finish.\n. So if, during the execution of Add, some other goroutine closes the watcher and something else opens a file descriptor, it'll get messed up.\nThis changes a lot. Add and Remove will have to be properly synced with readEvents. Yeah, I don't think think you'll like the next pull request.\n. I wonder if -race could be adapted to catch this.\n. I was under the impression that https://github.com/go-fsnotify/fsnotify/issues/5 was about goroutines blocking forever.\nPerhaps I'm mistaken.\n. readEvents still has a blocking read on the file descriptor, but that's fine. So does kqueue and the Windows thing.\nIt should get cleaned up pretty much always, but not ABSOLUTELY always. That's the next one. So yeah, I suppose #5 might not be fixed until I push the epoll stuff.\n. You can look at the internal field from Test.\n. That would happen when the goroutine dies. Sounds bad.\n. Thinking about it now, you're only getting stuff from Errors, so Events is still open.\nI'd take a look at the code, but I won't see a computer until tonight.\n. Oh. I got it. It's in your code. You create the watcher, defer close, and wait for stuff in a goroutine... But then you return from the function that has the defer close.\nA question might be, is the events channel being properly closed by the goroutine?\n. Hah! Sweet. I was in the train on my phone, so I had a few minutes.\nBy the wat, watcher.isClosed is racey in almost every case.\n. Ah that's how the events chan wasn't reporting. Duh. Thanks :D\n. Happens to everyone. Good luck :)\n. Er, am I blind? I shouldn't open issues from my phone. Disregard this until i get home to look again lol\n. I know I saw something when I was on my phone, but since I had to switch to the comment thing I lost it. So keep this open for a bit please, I'll look at it this weekend.\n. Yeah, it would :)\nhttps://github.com/go-fsnotify/fsnotify/issues/10\n. Sure thing, I'll take a look at this tonight or tomorrow. Thanks.\n. Don't have much time (I'm on holiday!) but I've got a few minutes.\n. Sorry, I don't have a ton of time :(\nI'm a bit confused about what the patch is meant to fix. Could you elaborate?\n. Thanks. There was some stuff in there I thought might save some time looking stuff up in the future :)\n. LGTM. I don't have a linux machine handy so I can't play around with it, but it looks good.\n. I agree. It is known. I actually think a radically different api is required. Unifying all the different systems into a single common denominator api is... Well, it's hard.\nUnfortunately, there's just the two of us at the moment, and we're pretty busy ourselves. Sorry. When I get back from holiday next week I plan to pick it back up. Until then, feel free to contribute.\n. I've put up a document on the redesign issue. Feel free to comment.\nhttps://github.com/go-fsnotify/fsnotify/issues/1\n. I also don't have those architectures, sorry.\n. ",
    "nightlyone": "I like your proposal of doing the Ops filtering on creation of the watcher. \nOne usually creates such a watcher with a purpose in mind and the events being delivered are usually suitable for this purpose for the lifetime of the watcher. And after all this is just an optimization. One can always choose a broader scope in order to be sure. \nSo maybe an additional simple creation function like NewGreedyWatcher might be useful OR an additional complex creation function like NewFilteredWatcher. One of those is meant to be without arguments.\n. I like your proposal of doing the Ops filtering on creation of the watcher. \nOne usually creates such a watcher with a purpose in mind and the events being delivered are usually suitable for this purpose for the lifetime of the watcher. And after all this is just an optimization. One can always choose a broader scope in order to be sure. \nSo maybe an additional simple creation function like NewGreedyWatcher might be useful OR an additional complex creation function like NewFilteredWatcher. One of those is meant to be without arguments.\n. ",
    "tsuna": "The current code of Add() contains:\n``` go\n    const agnosticEvents = unix.IN_MOVED_TO | unix.IN_MOVED_FROM |\n        unix.IN_CREATE | unix.IN_ATTRIB | unix.IN_MODIFY |\n        unix.IN_MOVE_SELF | unix.IN_DELETE | unix.IN_DELETE_SELF\nvar flags uint32 = agnosticEvents\n\n```\nSo basically the flags are hard-coded to the ones above.  Would there be any opposition to adding another API, like:\n``` go\nfunc (w *Watcher) Add(name string) error {\n    return w.AddWithFlags(name, agnosticEvents)\n}\nfunc (w *Watcher) AddWithFlags(name string, flags uint32) error {\n    // mostly the same code as the current Add() but use flags passed in argument\n```\nI need to ignore IN_DELETE_SELF because it's misleading in my case (and causes correctness issues in my code), I only care about IN_DELETE.\n. I hear you, although I personally don't think it's a big problem that the flags differ across the platforms, since this API would just take a uint32 and what values make sense for this API could be platform specific.  So this would be a more advanced API for those needing the extra control.\nNow when I reviewed the open issues I missed #173, that's obviously a more elegant solution, and at this rate between this bug and #97 and #123, it's very hard for me to get correctness out of fsnotify, so I was considering writing my own little inotify wrapper anyway, so I'm glad to hear that this is being considered.\nFor now I think I'll just fork the project to quickly fix/hack the bugs that are impacting me.\n. This change fsnotify/fsnotify@e2532248b8b41873668e8e339833f9b4083d4a71 is making some of my unit tests fail non-deterministically.  After adding some tracing to the code, here's what I'm seeing (both on Linux 3.4.43 and 4.1.18):\nWhen Remove() is called on a Watcher, it now Wait()s on a condition variable after calling syscall.InotifyRmWatch().  The condition variable is notified from ignoreLinux(), at the point that we see an Event with the IN_IGNORED bit set.  This seems reasonable as the man page for inotify_rm_watch says:\n\nRemoving a watch causes an IN_IGNORED event to be generated for this watch descriptor.\n\nHowever I'm seeing that in two of my unit tests sometimes (more than 50% of the time) there is no IN_IGNORED event that follows the call to syscall.InotifyRmWatch().  I verified that syscall.InotifyRmWatch() doesn't return any error.  There is just no event on the watch descriptor that was passed to syscall.InotifyRmWatch().\nHas anybody seen this before?\n. OK I think I got it... With this change it's no longer safe to consume Events from the same goroutine that calls Remove().  In our case our code basically looks this:\n``` go\nfunc (shared *InotifyTracker) run() {\n    // ...\nfor {\n    select {\n    case winfo := <-shared.watch:\n        shared.error <- shared.addWatch(winfo.fname)\n\n    case fname := <-shared.remove:\n        shared.removeWatch(fname) // <-------- no longer legit\n\n    // ...\n}\n\n}\n```\nRemoving the watch leads to a deadlock: we're trying to call Remove() and Remove() is waiting to be notified that the IN_IGNORED event was received, but the IN_IGNORED event can't be sent because fsnotify is trying to write another event to the Watch.\n. @nathany I'm happy to open an issue if you deem that this new code creates an undesirable side effect that needs to be fixed.  As you can see above, I've submitted a PR to workaround this quirk in the tail library.  But I agree that the new behavior of fsnotify as a result of this change is unfortunate because it will be more easily prone to deadlocks, depending on how the client code is written.\n. I filed bug #123.  Thanks.\n. I can't find a reliable / general way to work around this bug.\n- I'm watching a directory foo and my goal is to recursively watch the tree under foo.\n- I delete and re-create a subdirectory foo/bar repeatedly in rapid succession.\n- After a few iterations, I see a REMOVE event being emitted, followed by a CREATE event immediately thereafter.\n- When my code handles the REMOVE event, I need to call Remove(\"foo/bar\"), but I can't do so from whichever goroutine is receiving the event from fsnotify due this bug.  So I defer to another goroutine to call Remove() for me.\n- My code then handles the CREATE event and attempts to re-watch this directory by calling Add(\"foo/bar\").\nNow we have two goroutines executing Add(\"foo/bar\") and Remove(\"foo/bar\") concurrently.  Let's say that Add() goes in first.  In Add() we have a first critical section:\ngo\n    w.mu.Lock()\n    watchEntry, found := w.watches[name]\n    w.mu.Unlock()\nin this scenario, found is true, because the goroutine calling Remove() hasn't gotten around to doing anything yet.  Then we issue the system call without holding the lock, followed by another critical section:\n``` go\n    wd, errno := unix.InotifyAddWatch(w.fd, name, flags)\n    if wd == -1 {\n        return errno\n    }\nw.mu.Lock()\nw.watches[name] = &watch{wd: uint32(wd), flags: flags}\nw.paths[wd] = name\nw.mu.Unlock()\n\n```\nNow while I'm in the system call, the Remove() goroutine starts to do its thing:\ngo\n    w.mu.Lock()\n    defer w.mu.Unlock()\n    watch, ok := w.watches[name]\nSo here ok is true as well and now Remove() will run to completion because it only releases the lock once it's done via the defer statement.  So it'll execute:\ngo\n    success, errno := unix.InotifyRmWatch(w.fd, watch.wd)\nAnd then it'll go in this loop that waits for the watch to be removed by the fsnotify goroutine:\ngo\n    exists := true\n    for exists {\n        w.cv.Wait()\n        _, exists = w.watches[name]\n    }\nWhen we go in Wait(), the lock is released, and Add() finishes, overwriting the entry in the maps with a different value for wd than before.\nMeanwhile fsnotify is trying to deliver the next event (which isn't, yet, the IN_IGNORED event required to unblock the Remove() call), but it's blocked trying to send on the w.Events channel because my code is trying to finish handling the previous Add(), which requires sending a message on a channel to the goroutine that is stuck in Remove().\nBasically it seems that the only safe way to call Remove() is by doing go watcher.Remove(path), but this creates other problems like not knowing exactly when I'm done removing a watch before I add another one.\nI'd like to see the code of a reliable recursive watch with fsnotify.  Currently I believe it's not possible to implement due to this bug (and due to #97, but that's another issue).\n. @nathany issue #115 and this issue are definitely the same issue.\n@purpleidea: I know how to write a recursive watch (and in fact I've run into this bug with the one I wrote), but what I meant is we need some sort of an integration test that stresses the filesystem and implements a recursive watch, to demonstrate that it's feasible to write this with fsnotify.  I assert that currently it is not possible to do this correctly with fsnotify, one will either deadlock, miss events, have watches removed when they shouldn't be, and not deal properly with the inotify queue overflowing in the kernel.\n. The build failed for a seemingly unrelated reason.  Going to close/re-open this PR to make Travis give it another go.. Oh wow I totally forgot about this change.  Thanks for taking a look at it.  It's not meant to fix anything it was really just a tiny code cleanup.. The current code of Add() contains:\n``` go\n    const agnosticEvents = unix.IN_MOVED_TO | unix.IN_MOVED_FROM |\n        unix.IN_CREATE | unix.IN_ATTRIB | unix.IN_MODIFY |\n        unix.IN_MOVE_SELF | unix.IN_DELETE | unix.IN_DELETE_SELF\nvar flags uint32 = agnosticEvents\n\n```\nSo basically the flags are hard-coded to the ones above.  Would there be any opposition to adding another API, like:\n``` go\nfunc (w *Watcher) Add(name string) error {\n    return w.AddWithFlags(name, agnosticEvents)\n}\nfunc (w *Watcher) AddWithFlags(name string, flags uint32) error {\n    // mostly the same code as the current Add() but use flags passed in argument\n```\nI need to ignore IN_DELETE_SELF because it's misleading in my case (and causes correctness issues in my code), I only care about IN_DELETE.\n. I hear you, although I personally don't think it's a big problem that the flags differ across the platforms, since this API would just take a uint32 and what values make sense for this API could be platform specific.  So this would be a more advanced API for those needing the extra control.\nNow when I reviewed the open issues I missed #173, that's obviously a more elegant solution, and at this rate between this bug and #97 and #123, it's very hard for me to get correctness out of fsnotify, so I was considering writing my own little inotify wrapper anyway, so I'm glad to hear that this is being considered.\nFor now I think I'll just fork the project to quickly fix/hack the bugs that are impacting me.\n. This change fsnotify/fsnotify@e2532248b8b41873668e8e339833f9b4083d4a71 is making some of my unit tests fail non-deterministically.  After adding some tracing to the code, here's what I'm seeing (both on Linux 3.4.43 and 4.1.18):\nWhen Remove() is called on a Watcher, it now Wait()s on a condition variable after calling syscall.InotifyRmWatch().  The condition variable is notified from ignoreLinux(), at the point that we see an Event with the IN_IGNORED bit set.  This seems reasonable as the man page for inotify_rm_watch says:\n\nRemoving a watch causes an IN_IGNORED event to be generated for this watch descriptor.\n\nHowever I'm seeing that in two of my unit tests sometimes (more than 50% of the time) there is no IN_IGNORED event that follows the call to syscall.InotifyRmWatch().  I verified that syscall.InotifyRmWatch() doesn't return any error.  There is just no event on the watch descriptor that was passed to syscall.InotifyRmWatch().\nHas anybody seen this before?\n. OK I think I got it... With this change it's no longer safe to consume Events from the same goroutine that calls Remove().  In our case our code basically looks this:\n``` go\nfunc (shared *InotifyTracker) run() {\n    // ...\nfor {\n    select {\n    case winfo := <-shared.watch:\n        shared.error <- shared.addWatch(winfo.fname)\n\n    case fname := <-shared.remove:\n        shared.removeWatch(fname) // <-------- no longer legit\n\n    // ...\n}\n\n}\n```\nRemoving the watch leads to a deadlock: we're trying to call Remove() and Remove() is waiting to be notified that the IN_IGNORED event was received, but the IN_IGNORED event can't be sent because fsnotify is trying to write another event to the Watch.\n. @nathany I'm happy to open an issue if you deem that this new code creates an undesirable side effect that needs to be fixed.  As you can see above, I've submitted a PR to workaround this quirk in the tail library.  But I agree that the new behavior of fsnotify as a result of this change is unfortunate because it will be more easily prone to deadlocks, depending on how the client code is written.\n. I filed bug #123.  Thanks.\n. I can't find a reliable / general way to work around this bug.\n- I'm watching a directory foo and my goal is to recursively watch the tree under foo.\n- I delete and re-create a subdirectory foo/bar repeatedly in rapid succession.\n- After a few iterations, I see a REMOVE event being emitted, followed by a CREATE event immediately thereafter.\n- When my code handles the REMOVE event, I need to call Remove(\"foo/bar\"), but I can't do so from whichever goroutine is receiving the event from fsnotify due this bug.  So I defer to another goroutine to call Remove() for me.\n- My code then handles the CREATE event and attempts to re-watch this directory by calling Add(\"foo/bar\").\nNow we have two goroutines executing Add(\"foo/bar\") and Remove(\"foo/bar\") concurrently.  Let's say that Add() goes in first.  In Add() we have a first critical section:\ngo\n    w.mu.Lock()\n    watchEntry, found := w.watches[name]\n    w.mu.Unlock()\nin this scenario, found is true, because the goroutine calling Remove() hasn't gotten around to doing anything yet.  Then we issue the system call without holding the lock, followed by another critical section:\n``` go\n    wd, errno := unix.InotifyAddWatch(w.fd, name, flags)\n    if wd == -1 {\n        return errno\n    }\nw.mu.Lock()\nw.watches[name] = &watch{wd: uint32(wd), flags: flags}\nw.paths[wd] = name\nw.mu.Unlock()\n\n```\nNow while I'm in the system call, the Remove() goroutine starts to do its thing:\ngo\n    w.mu.Lock()\n    defer w.mu.Unlock()\n    watch, ok := w.watches[name]\nSo here ok is true as well and now Remove() will run to completion because it only releases the lock once it's done via the defer statement.  So it'll execute:\ngo\n    success, errno := unix.InotifyRmWatch(w.fd, watch.wd)\nAnd then it'll go in this loop that waits for the watch to be removed by the fsnotify goroutine:\ngo\n    exists := true\n    for exists {\n        w.cv.Wait()\n        _, exists = w.watches[name]\n    }\nWhen we go in Wait(), the lock is released, and Add() finishes, overwriting the entry in the maps with a different value for wd than before.\nMeanwhile fsnotify is trying to deliver the next event (which isn't, yet, the IN_IGNORED event required to unblock the Remove() call), but it's blocked trying to send on the w.Events channel because my code is trying to finish handling the previous Add(), which requires sending a message on a channel to the goroutine that is stuck in Remove().\nBasically it seems that the only safe way to call Remove() is by doing go watcher.Remove(path), but this creates other problems like not knowing exactly when I'm done removing a watch before I add another one.\nI'd like to see the code of a reliable recursive watch with fsnotify.  Currently I believe it's not possible to implement due to this bug (and due to #97, but that's another issue).\n. @nathany issue #115 and this issue are definitely the same issue.\n@purpleidea: I know how to write a recursive watch (and in fact I've run into this bug with the one I wrote), but what I meant is we need some sort of an integration test that stresses the filesystem and implements a recursive watch, to demonstrate that it's feasible to write this with fsnotify.  I assert that currently it is not possible to do this correctly with fsnotify, one will either deadlock, miss events, have watches removed when they shouldn't be, and not deal properly with the inotify queue overflowing in the kernel.\n. The build failed for a seemingly unrelated reason.  Going to close/re-open this PR to make Travis give it another go.. Oh wow I totally forgot about this change.  Thanks for taking a look at it.  It's not meant to fix anything it was really just a tiny code cleanup.. ",
    "mdwhatcott": "FYI, the link (above) to the goconvey scanner is no longer valid (I've recently rewritten that package. My approach, however, is unchanged:\nhttps://github.com/smartystreets/goconvey/tree/master/web/server/watch\n. @nathany - Sounds like a fun project but I can't commit to it at this time.\n. FYI, the link (above) to the goconvey scanner is no longer valid (I've recently rewritten that package. My approach, however, is unchanged:\nhttps://github.com/smartystreets/goconvey/tree/master/web/server/watch\n. @nathany - Sounds like a fun project but I can't commit to it at this time.\n. ",
    "omeid": ":+1: for polling.\nIt is not ideal, but it is better than none and instead of everyone developing it on their own, it makes sense to have one that is made better by many people.\nIn terms of the opt-in option, fsnotify could have an option to \"register\" different \"watch providers\", in the spirit of sql package. This would also allow people to develop their own providers for other services, say Dropbox, s3, and so forth, but maybe that is jumping ahead of ourselves.\n. Yeah, it really depends how you look at it, I wouldn't consider them as general webhooks as you can think of dropbox or s3 just another type of filesystem.\nRegardless of that, having a watch-driver interface and different driver is a better design IMHO.\n. @nathany Any plans for the v2 with driver interfaces? I will be happy to help out.\n. This would be really amazing, and preferably something that is compatible with filepath.Glob, however, it does not support exclusion but it is easy to add glob exclusion. \n. Vim uses swap and backup files, involves rename and moving.\n. Oh, I couldn't find anything with glob. Thanks. :)\n. There is no reason you can't have the combination of both. -- The os and sys/GOOS (replacing the confusing syscall) packages are a good example of how to approach a complicated set of APIs that are impossible to make strictly consistent across multiple platforms.\nOr the other option is to have all the common feature set in the fsnotify as an interface. The package fsnotify then imports platform specific implementations of the aforementioned interface under the hood and allow users to cast this implementation to platform specific types if they need platform specific features.\n. @matryer \nPerhaps because what is Write can't be Remove, but what has Write may have Remove too.\nBut overall, I agree with @nathany, I don't think any more methods should be added. \nThis library should stay as minimal as possible and only solve the problem of cross-platform portability, if you want fancy helpers, you can just write a wrapper around this library and use it.\n. IMHO, the problem with adding these methods is that you either have to unexport the Event.Op (breaking change, methods are more restricted than bitmask) or have overlapping API. \nNow overlapping APIs doesn't so bad until you consider that there are 8 backends, so where you need 8 tests, with this new methods you need at least 16, where a feature could have been inconsistent or broken in 8 places, now it can be at least 16.\nThis is unnecessary complexity that can be shifted into it's own package.\n. Lstat when 'Event.Dir()' is called.\n. This has a fair bit of overlapping with Event.String(), you should simplify Event.String() if you want to add Op.String().\n. As explained by @matryer , the fmt package which is used with the log and other logging packages respects the Stringer interface. Having Event.String() string means that you can simply do log.Print(event) and you would get something nice according to the Event.String() string output.\n. The example doesn't check if watcher.Events is closed, so after calling watcher.Close() the outer select would block forever, assuming there are no errors.\n. -1 for always polling.\nThis problem can be solved in multiple ways once the driver-based based design disccuesed in #8 progresses.\n. @nathany Any plans for fsnotify dirver-based architecture change? \n. See #26.\n. How do you make changes to your target file?\n. I am not sure about Sublime but Vim depending on the configurations may use Swap files. Can you reproduce this problem using vim with swap and backup disabled?\n. Shouldn't that unlocked be defered?\n. What is the stats on kernel versions usage? If this will upset people, I think one can make it backward compatible with direct syscall.RawSyscall, First trying the old SYS_EPOLL_CREATE/1042 and then SYS_EPOLL_CREATE1/291?\n. I am for moving away from gopkg. For reproducible builds as you explained vendoring is the way to go.\nThis is a very low level library and upgrading shouldn't be a big hassle for those who want to stay up to date.\n. See #86 \n. Nothing wrong, but if you want to go this way, you need to refactor Event.String() to use op.String() as well.\n. I suggest that commits be merged by someone other than the author to allow for code review. This is specially important as a bad commit on master can break builds.\n. Sounds pretty reasonable things to do!\n. :+1: for polling.\nIt is not ideal, but it is better than none and instead of everyone developing it on their own, it makes sense to have one that is made better by many people.\nIn terms of the opt-in option, fsnotify could have an option to \"register\" different \"watch providers\", in the spirit of sql package. This would also allow people to develop their own providers for other services, say Dropbox, s3, and so forth, but maybe that is jumping ahead of ourselves.\n. Yeah, it really depends how you look at it, I wouldn't consider them as general webhooks as you can think of dropbox or s3 just another type of filesystem.\nRegardless of that, having a watch-driver interface and different driver is a better design IMHO.\n. @nathany Any plans for the v2 with driver interfaces? I will be happy to help out.\n. This would be really amazing, and preferably something that is compatible with filepath.Glob, however, it does not support exclusion but it is easy to add glob exclusion. \n. Vim uses swap and backup files, involves rename and moving.\n. Oh, I couldn't find anything with glob. Thanks. :)\n. There is no reason you can't have the combination of both. -- The os and sys/GOOS (replacing the confusing syscall) packages are a good example of how to approach a complicated set of APIs that are impossible to make strictly consistent across multiple platforms.\nOr the other option is to have all the common feature set in the fsnotify as an interface. The package fsnotify then imports platform specific implementations of the aforementioned interface under the hood and allow users to cast this implementation to platform specific types if they need platform specific features.\n. @matryer \nPerhaps because what is Write can't be Remove, but what has Write may have Remove too.\nBut overall, I agree with @nathany, I don't think any more methods should be added. \nThis library should stay as minimal as possible and only solve the problem of cross-platform portability, if you want fancy helpers, you can just write a wrapper around this library and use it.\n. IMHO, the problem with adding these methods is that you either have to unexport the Event.Op (breaking change, methods are more restricted than bitmask) or have overlapping API. \nNow overlapping APIs doesn't so bad until you consider that there are 8 backends, so where you need 8 tests, with this new methods you need at least 16, where a feature could have been inconsistent or broken in 8 places, now it can be at least 16.\nThis is unnecessary complexity that can be shifted into it's own package.\n. Lstat when 'Event.Dir()' is called.\n. This has a fair bit of overlapping with Event.String(), you should simplify Event.String() if you want to add Op.String().\n. As explained by @matryer , the fmt package which is used with the log and other logging packages respects the Stringer interface. Having Event.String() string means that you can simply do log.Print(event) and you would get something nice according to the Event.String() string output.\n. The example doesn't check if watcher.Events is closed, so after calling watcher.Close() the outer select would block forever, assuming there are no errors.\n. -1 for always polling.\nThis problem can be solved in multiple ways once the driver-based based design disccuesed in #8 progresses.\n. @nathany Any plans for fsnotify dirver-based architecture change? \n. See #26.\n. How do you make changes to your target file?\n. I am not sure about Sublime but Vim depending on the configurations may use Swap files. Can you reproduce this problem using vim with swap and backup disabled?\n. Shouldn't that unlocked be defered?\n. What is the stats on kernel versions usage? If this will upset people, I think one can make it backward compatible with direct syscall.RawSyscall, First trying the old SYS_EPOLL_CREATE/1042 and then SYS_EPOLL_CREATE1/291?\n. I am for moving away from gopkg. For reproducible builds as you explained vendoring is the way to go.\nThis is a very low level library and upgrading shouldn't be a big hassle for those who want to stay up to date.\n. See #86 \n. Nothing wrong, but if you want to go this way, you need to refactor Event.String() to use op.String() as well.\n. I suggest that commits be merged by someone other than the author to allow for code review. This is specially important as a bad commit on master can break builds.\n. Sounds pretty reasonable things to do!\n. ",
    "szechyjs": ":+1: polling would be great. I'm trying to migrate a python application from watchdog to fsnotify. Unfortunately I think this is the roadblock, as the filesystem that needs monitored is on NFS and polling is the only option.\n. :+1: polling would be great. I'm trying to migrate a python application from watchdog to fsnotify. Unfortunately I think this is the roadblock, as the filesystem that needs monitored is on NFS and polling is the only option.\n. ",
    "calavera": "You might be interested in checking how docker support fsnotify and polling at the same time. We have a compatible interface and a fallback initialization for when fsnotify is not supported:\nhttps://github.com/docker/docker/blob/master/pkg/filenotify/filenotify.go\nmaybe @cpuguy83 would be interested in moving the polling here so we can maintain only one package.\n. You might be interested in checking how docker support fsnotify and polling at the same time. We have a compatible interface and a fallback initialization for when fsnotify is not supported:\nhttps://github.com/docker/docker/blob/master/pkg/filenotify/filenotify.go\nmaybe @cpuguy83 would be interested in moving the polling here so we can maintain only one package.\n. ",
    "cpuguy83": "That would be great.\nThe reason I did not submit here is it seemed rather unknown if polling support was desired and we really needed to implement it.\n. @nathany Can you clarify what you'd like to see?\n. This change actually prevents a race condition on Close. Maybe not super important because I doubt anyone is calling Close() from multiple goroutines, but still.. This looks to be a dup of #188 but w/o fixing some of the other deadlock scenarios.. I think it's a good idea to return an error, but maybe something that the caller can inspect and see that it's specifically a not found kind of error so they can make the determination of how to handle it.. For example, see os.IsNotExist(err). That would be great.\nThe reason I did not submit here is it seemed rather unknown if polling support was desired and we really needed to implement it.\n. @nathany Can you clarify what you'd like to see?\n. This change actually prevents a race condition on Close. Maybe not super important because I doubt anyone is calling Close() from multiple goroutines, but still.. This looks to be a dup of #188 but w/o fixing some of the other deadlock scenarios.. I think it's a good idea to return an error, but maybe something that the caller can inspect and see that it's specifically a not found kind of error so they can make the determination of how to handle it.. For example, see os.IsNotExist(err). ",
    "radovskyb": "Sounds like a good idea. We can talk about it on the fsnotify Slack channel :)\n. Sounds like a good idea. We can talk about it on the fsnotify Slack channel :)\n. ",
    "samjacobson": "Yes, I agree that would make sense.\n. @nathany Thanks for all of your work! You've done a great job running this\nproject, and coaxed contributions from many people (including myself), and\nfound a way to piece them all together. You deserve thanks from all the\nmany people who have benefitted. Good luck with whatever you do next!\nSam\nOn Wed, Mar 15, 2017 at 10:36 AM, Koichi Shiraishi <notifications@github.com\n\nwrote:\n@nathany https://github.com/nathany Hi,\nJust one thing, I just wanna tell you that you did the job is not poor.\nThe community(and Member) management, raise a problem of members shortage\nis very hard works.\nSorry for my pull request was related the CI only. But I'll more learn the\nfile-systems, and I will make an effort to contribute to the linux side(if\npossible). I'll do my best.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/fsnotify/fsnotify/issues/183#issuecomment-286568565,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABMJvdHHp0Bfkeaf6u9w0A65fqnsMbS1ks5rlwhagaJpZM4KgPzl\n.\n. Yes, I agree that would make sense.\n. @nathany Thanks for all of your work! You've done a great job running this\nproject, and coaxed contributions from many people (including myself), and\nfound a way to piece them all together. You deserve thanks from all the\nmany people who have benefitted. Good luck with whatever you do next!\n\nSam\nOn Wed, Mar 15, 2017 at 10:36 AM, Koichi Shiraishi <notifications@github.com\n\nwrote:\n@nathany https://github.com/nathany Hi,\nJust one thing, I just wanna tell you that you did the job is not poor.\nThe community(and Member) management, raise a problem of members shortage\nis very hard works.\nSorry for my pull request was related the CI only. But I'll more learn the\nfile-systems, and I will make an effort to contribute to the linux side(if\npossible). I'll do my best.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/fsnotify/fsnotify/issues/183#issuecomment-286568565,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABMJvdHHp0Bfkeaf6u9w0A65fqnsMbS1ks5rlwhagaJpZM4KgPzl\n.\n. \n",
    "xen0l": "I am trying to build packer on OpenIndiana, but it fails to compile.If PR is published, I'll test it.\n. I am trying to build packer on OpenIndiana, but it fails to compile.If PR is published, I'll test it.\n. ",
    "davecheney": "I'd go further and say use a sync.Mutex \n. I'd go further and say use a sync.Mutex \n. ",
    "danield137": "any updates or plans on fixing this?. any updates or plans on fixing this?. ",
    "kevinburke": "Ugh, I just spent two hours trying to debug this :( I wasn't searching for the right terms... I was searching for kqueue sends multiple events, kqueue atime, etc.\nFor people who find this later the key to debugging this is to run sudo fs_usage | grep myfile and check for open/utimes events.. I didn't know Spotlight was responsible until the very end, I just saw multiple CHMOD events firing for the same file. I figured \"go install\" (another step in the build pipeline) was modifying the atime or something and that was triggering another rerun, or there was an error in fsnotify or justrun (the tool I use for watching for changes). (I started reading the code and adding print statements right away, then I searched Github issues for \"kqueue\", I didn't bother to check the README). Ugh, I just spent two hours trying to debug this :( I wasn't searching for the right terms... I was searching for kqueue sends multiple events, kqueue atime, etc.\nFor people who find this later the key to debugging this is to run sudo fs_usage | grep myfile and check for open/utimes events.. I didn't know Spotlight was responsible until the very end, I just saw multiple CHMOD events firing for the same file. I figured \"go install\" (another step in the build pipeline) was modifying the atime or something and that was triggering another rerun, or there was an error in fsnotify or justrun (the tool I use for watching for changes). (I started reading the code and adding print statements right away, then I searched Github issues for \"kqueue\", I didn't bother to check the README). ",
    "mstum": "It seems that there are two major use cases to use a Watcher:\n1. Watch very few individual files, e.g. config files for hot reload\n2. Watch a folder, e.g., a \"Queue\" folder in which the user copies images/logs to be processed by the app and moved to an output folder\nNumber 1 suffers from said problem. I don't know specifics of OS implementations wrt efficiency, but it seems that setting up a \"Delete\" watcher which checks if the file is recreated and automatically sets up a new OS watcher for the new file would do the trick. To my knowledge, Move Operations are atomic in all decent file systems (I know they are in NTFS, I don't know or care if they are in FAT32/exFAT), but I don't know if a move can overwrite or if it's required to delete first and then move/rename. In that case, the watcher could be setup on the directory, equipped with a timer that checks every few ms and is automatically deleted if the file isn't coming back after let's say 1s. That works for small files, but let's say the file is a gigabyte in size, I don't know if that would work (then again, I don't know how often a hot-reload-watcher would be used on a large file)\nI feel that a \"persistent write timer\" is more a high level utility construct: Allow me to specify how long the timer stays alive to re-check for file creation. In fact, I wonder if it's best to have fsnotify be a small layer of abstraction on top of the OS watcher - warts/gotchas and all - and then have a \"Utility\" for high level stuff. That way, the (what I consider) common use case of hot-reloading a tiny config file that's created within a second of a delete is trivial, but someone who wants something \"weird\" (like hot reloading gigabyte-sized files that are using copy-on-save) still has low level access.\n. It seems that there are two major use cases to use a Watcher:\n1. Watch very few individual files, e.g. config files for hot reload\n2. Watch a folder, e.g., a \"Queue\" folder in which the user copies images/logs to be processed by the app and moved to an output folder\nNumber 1 suffers from said problem. I don't know specifics of OS implementations wrt efficiency, but it seems that setting up a \"Delete\" watcher which checks if the file is recreated and automatically sets up a new OS watcher for the new file would do the trick. To my knowledge, Move Operations are atomic in all decent file systems (I know they are in NTFS, I don't know or care if they are in FAT32/exFAT), but I don't know if a move can overwrite or if it's required to delete first and then move/rename. In that case, the watcher could be setup on the directory, equipped with a timer that checks every few ms and is automatically deleted if the file isn't coming back after let's say 1s. That works for small files, but let's say the file is a gigabyte in size, I don't know if that would work (then again, I don't know how often a hot-reload-watcher would be used on a large file)\nI feel that a \"persistent write timer\" is more a high level utility construct: Allow me to specify how long the timer stays alive to re-check for file creation. In fact, I wonder if it's best to have fsnotify be a small layer of abstraction on top of the OS watcher - warts/gotchas and all - and then have a \"Utility\" for high level stuff. That way, the (what I consider) common use case of hot-reloading a tiny config file that's created within a second of a delete is trivial, but someone who wants something \"weird\" (like hot reloading gigabyte-sized files that are using copy-on-save) still has low level access.\n. ",
    "clipperhouse": "We might consider an abstraction over fsnotify proper to specify \u201cdesired\u201d behavior.\nOne case might be to compare before & after on a given file, not unlike source control. Then emit a changed event, defined as the bytes having actually changed. This is more inline with what we expect with change events in JS in a browser, eg.\nThe CREATE/DELETE cycles that editors like Sublime generate might be mitigated by a throttle/debounce. Though at that point, it\u2019s (logically) close to polling. And there is the possibility of races & inconsistency.\n. Thanks Nathan. Here's a version with the same problem, out in a goroutine.\n```\npackage main\nimport (\n    \"fmt\"\n\"github.com/go-fsnotify/fsnotify\"\n\n)\nfunc main() {\n    watcher, err := fsnotify.NewWatcher()\nif err != nil {\n    panic(err)\n}\ndefer watcher.Close()\n\ndone := make(chan bool)\n\nwatcher.Add(\"./\")\n\ngo func() {\nLoop:\n    for {\n        select {\n        case event := <-watcher.Events:\n            fmt.Println(event)\n            break Loop\n        case err := <-watcher.Errors:\n            fmt.Println(err)\n            break Loop\n        }\n    }\n    done <- true\n}()\n\n<-done\n\n}\n```\n. Hmm, mysterious. Thanks for trying to repro.\n. We might consider an abstraction over fsnotify proper to specify \u201cdesired\u201d behavior.\nOne case might be to compare before & after on a given file, not unlike source control. Then emit a changed event, defined as the bytes having actually changed. This is more inline with what we expect with change events in JS in a browser, eg.\nThe CREATE/DELETE cycles that editors like Sublime generate might be mitigated by a throttle/debounce. Though at that point, it\u2019s (logically) close to polling. And there is the possibility of races & inconsistency.\n. Thanks Nathan. Here's a version with the same problem, out in a goroutine.\n```\npackage main\nimport (\n    \"fmt\"\n\"github.com/go-fsnotify/fsnotify\"\n\n)\nfunc main() {\n    watcher, err := fsnotify.NewWatcher()\nif err != nil {\n    panic(err)\n}\ndefer watcher.Close()\n\ndone := make(chan bool)\n\nwatcher.Add(\"./\")\n\ngo func() {\nLoop:\n    for {\n        select {\n        case event := <-watcher.Events:\n            fmt.Println(event)\n            break Loop\n        case err := <-watcher.Errors:\n            fmt.Println(err)\n            break Loop\n        }\n    }\n    done <- true\n}()\n\n<-done\n\n}\n```\n. Hmm, mysterious. Thanks for trying to repro.\n. ",
    "aktau": "The question becomes then if we want to fallback to whatever is the most efficient way of doing subtree wachtes on an OS that succeeds, and if we want to tell the user that the fallback happened. Or if the user should be able to configure whether a fallback is allowed. The reason this might be handy is that a user might prefer to not have directory watching at all instead of polling, which might put too much stress on the system. Plainly telling the user that the feature is disabled or something.\nI, for one, would absolutely love subtree watches, but understand the difficulties on getting it right for cross-platform.\n. The question becomes then if we want to fallback to whatever is the most efficient way of doing subtree wachtes on an OS that succeeds, and if we want to tell the user that the fallback happened. Or if the user should be able to configure whether a fallback is allowed. The reason this might be handy is that a user might prefer to not have directory watching at all instead of polling, which might put too much stress on the system. Plainly telling the user that the feature is disabled or something.\nI, for one, would absolutely love subtree watches, but understand the difficulties on getting it right for cross-platform.\n. ",
    "purpleidea": "Is the implementation in the https://github.com/xyproto/recwatch package correct, or are there issues? I ask because it looks as if this is a more subtle, tricky problem. cc @nathany @xyproto\nCheers\n. Yes it's on Linux.\nI don't have a standalone snippet at the moment, but if you don't mind running a bit of extra code, it's 100% reproducible:\ncode:\nhttps://github.com/purpleidea/mgmt/\nrun with:\n./mgmt run --file examples/graph1.yaml\nIf you add some print statements in this else block, you'll see the obvious events from each others events:\nhttps://github.com/purpleidea/mgmt/blob/master/file.go#L137 <-- number number may change in future...\nPlease excuse the mess in this code base, it's a rough prototype and I'm a golang newbie, but getting better on both counts.\nCheers,\nJames\n. On Fri, Dec 18, 2015 at 10:12 PM, Nathan Youngman notifications@github.com\nwrote:\n\nIt could be useful. Though for any API addition or change, I'd like to\nhear from multiple people, so I'm going to let this sit for awhile.\nOne consideration is that sometimes the underlying OS does buffering of\nit's own. FSEvents on Mac in particular can even persist events to disk\nacross reboots. I'm not sure how accurate the length returned would be in\nsuch situations, but it's worth investigating.\n\nwow, I did not know that it would even buffer events to disk on OSX, but\ninteresting nonetheless!\nPer your suggestion, I agree, and I'm fine with other people weighing in.\nSince I realize I might not have given a clear enough use case, the Len()\napi would be particularly useful for situations where you have a a bunch of\nlisteners, and you'd like to know if they've temporarily quiesced, or are\nclose to quiet, of if they are still quite busy firing. IOW, if you want to\npause one, at least only run your pause when Len() is zero or less than\nsome threshold.\nThis would often be as part of a heuristic, therefore if a particular\nbackend always buffers internally and this number isn't available for\ninspection, and thus always returns 0 for the length, this isn't the end of\nthe world as long as it's documented.\nThanks again,\nJames\n. w00t! Build is now green. Enjoy!\n. @omeid Looks similar, but of course my patch is more correct. I don't see what the problem is, this is a useful thing.\n. To add some context, if you print out the Op, you just get a useless number instead of a useful string:\nhttps://github.com/purpleidea/mgmt/blob/master/file.go#L158\n. @omeid Oh, I'm sorry. I misunderstood what the other thread was saying. I'm happy to refactor it, and I will do it in a moment. Do you wish to require that the strings stay uppercase as to avoid changing that string interface, or can we switch them to the same case as in my Op. (My preference.)\n. @omeid Patch updated and passes tests on my machine. The failure seems to be some bug in the build system or an issue that I don't understand. The error is:\n./fsnotify.go:44: o.String undefined (type Op has no field or method String)\nBut I call the go generate function, and it WFM.\n. Ping?\n. Hi @nathany I \"tunnel vision\" never thought to use Errorf instead of Fatalf. Good suggestion, fixed!\nI also made the other changes.\nAs an aside, I prefer to generate the Stringer stuff instead of committing it, so I was wondering why you would like to do it this way? In any case, it's in my patch the way you preferred.\nCheers!\n. @nathany \nDoesn't work for me:\n--- FAIL: TestEventStringify (0.00s)\n    fsnotify_test.go:43: Stringify expected: `\"foo2\": Write|Chmod`; got: `\"foo2\": nil`.\n    fsnotify_test.go:47: Stringify expected: `\"foo3\": Create|Write|Remove|Rename|Chmod`; got: `\"foo3\": nil`.\nFAIL\nexit status 1\nFAIL    _/home/james/code/src/fsnotify  13.449s\n. @nathany Good point RE: go generate. In this case if there's no mechanism to run this automatically, then I consider this an issue with go get.\nAs for the test failure, it is currently passing. I don't have a Windows machine.\nAt this point if there's something else you want to modify, feel free to just add a patch on top of mine if it would make it easier for you.\nCheers\n. @nathany ping :(\n. @nathany What's missing?\n. @nathany\n\nsee the comments i made during code review.\n\nI don't know what's missing... \n\nThis PR still needs a little more work before it's merged. I can do the work, but I haven't had a chance to yet.\n\nThis was just a \"get my feet wet\" patch for this project. Feel free to do with it what you want or not. Cheers!\n. Patch is here: https://github.com/purpleidea/fsnotify/tree/feat/stringify if you want it. I'm going to close this for now.\n. Just wanted to get the approximate ACK, so that I can point people here if they're interested in fanotify benefits. Thanks!\n. @nathany Thanks for the info! Looking forward to @amir73il's patches!\nCheers. @amir73il I have pinged some kernel engineers at my company to look into your patch. In the meantime, if you have a moment, could you look into and recommend an algorithm or suggest an improvement to the recursive file watching which I've implemented for mgmt? The code is available here:\nhttps://github.com/purpleidea/mgmt/blob/master/recwatch/recwatch.go#L134\nCheers!. On Wed, Feb 1, 2017 at 3:26 AM, Amir Goldstein notifications@github.com wrote:\n\n@purpleidea thanks for the ping. If your company will show interest in the super block watch, that can be a game changer. wrt your recursive watcher, I am new to golang and have zero knowledge about fsnotify library, but it appears your code is not calling addSubFolders() recursively from Init() more than 1 level of depth, so if you never get events on the direct sub folders you will never add watchers for level 2 subdirs, but I may be missing something. Also I don't see any handling of Move events for dirs, unless it is handled in lib by generating Rename/Create event pair.\n\nI think I am having an algorithmic mind block, as IIRC I think some\ncases didn't work all the time. In any case, golang is very similar to\nC if you get bored :)\n. I really owe a huge thanks to @tsuna for finding this issue. I've spent more time than I am happy to admit realizing that this is what seems to have caused a huge regression in https://github.com/purpleidea/mgmt/. I realized it was the fsnotify code causing the problem, and eventually found this ticket.\nI haven't added a workaround to my code yet, and instead will use an older version of this lib for now, but this is a very real problem. I don't completely understand the fix, so patches and hints welcome :)\nFWIW I hit the hang here:\nhttps://github.com/fsnotify/fsnotify/blob/master/inotify.go#L158\n. @tsuna I have a (possibly broken) implementation of a recursive watcher here: https://github.com/purpleidea/mgmt/blob/master/recwatch/recwatch.go#L19 I did rollback the version of this lib to avoid this bug though. I also think I found at least one issue with my lib anyways. In any case, HTH and a permanent fix is definitely welcome.\n. This is in response to:\nerr = watcher.Add(current)\nif err == syscall.ENOENT\nOn OSX this apparently doesn't trigger for file not found and generates a different event. Maybe it's just a different error code on OSX? I don't have a mac, so IDK.\n. (that works on GNU/Linux, btw)\n. @aarondl RE:\n\nI've signed the CLA and REALLY didn't want to. I'm fairly upset that this repo requires this, and then I read this only to find out I signed it without reason: golang/go#4068 (comment)\n\nI too am strongly against this! +1\nThanks for the patch. Look forward to testing this in https://github.com/purpleidea/mgmt/ shortly.. Is the implementation in the https://github.com/xyproto/recwatch package correct, or are there issues? I ask because it looks as if this is a more subtle, tricky problem. cc @nathany @xyproto\nCheers\n. Yes it's on Linux.\nI don't have a standalone snippet at the moment, but if you don't mind running a bit of extra code, it's 100% reproducible:\ncode:\nhttps://github.com/purpleidea/mgmt/\nrun with:\n./mgmt run --file examples/graph1.yaml\nIf you add some print statements in this else block, you'll see the obvious events from each others events:\nhttps://github.com/purpleidea/mgmt/blob/master/file.go#L137 <-- number number may change in future...\nPlease excuse the mess in this code base, it's a rough prototype and I'm a golang newbie, but getting better on both counts.\nCheers,\nJames\n. On Fri, Dec 18, 2015 at 10:12 PM, Nathan Youngman notifications@github.com\nwrote:\n\nIt could be useful. Though for any API addition or change, I'd like to\nhear from multiple people, so I'm going to let this sit for awhile.\nOne consideration is that sometimes the underlying OS does buffering of\nit's own. FSEvents on Mac in particular can even persist events to disk\nacross reboots. I'm not sure how accurate the length returned would be in\nsuch situations, but it's worth investigating.\n\nwow, I did not know that it would even buffer events to disk on OSX, but\ninteresting nonetheless!\nPer your suggestion, I agree, and I'm fine with other people weighing in.\nSince I realize I might not have given a clear enough use case, the Len()\napi would be particularly useful for situations where you have a a bunch of\nlisteners, and you'd like to know if they've temporarily quiesced, or are\nclose to quiet, of if they are still quite busy firing. IOW, if you want to\npause one, at least only run your pause when Len() is zero or less than\nsome threshold.\nThis would often be as part of a heuristic, therefore if a particular\nbackend always buffers internally and this number isn't available for\ninspection, and thus always returns 0 for the length, this isn't the end of\nthe world as long as it's documented.\nThanks again,\nJames\n. w00t! Build is now green. Enjoy!\n. @omeid Looks similar, but of course my patch is more correct. I don't see what the problem is, this is a useful thing.\n. To add some context, if you print out the Op, you just get a useless number instead of a useful string:\nhttps://github.com/purpleidea/mgmt/blob/master/file.go#L158\n. @omeid Oh, I'm sorry. I misunderstood what the other thread was saying. I'm happy to refactor it, and I will do it in a moment. Do you wish to require that the strings stay uppercase as to avoid changing that string interface, or can we switch them to the same case as in my Op. (My preference.)\n. @omeid Patch updated and passes tests on my machine. The failure seems to be some bug in the build system or an issue that I don't understand. The error is:\n./fsnotify.go:44: o.String undefined (type Op has no field or method String)\nBut I call the go generate function, and it WFM.\n. Ping?\n. Hi @nathany I \"tunnel vision\" never thought to use Errorf instead of Fatalf. Good suggestion, fixed!\nI also made the other changes.\nAs an aside, I prefer to generate the Stringer stuff instead of committing it, so I was wondering why you would like to do it this way? In any case, it's in my patch the way you preferred.\nCheers!\n. @nathany \nDoesn't work for me:\n--- FAIL: TestEventStringify (0.00s)\n    fsnotify_test.go:43: Stringify expected: `\"foo2\": Write|Chmod`; got: `\"foo2\": nil`.\n    fsnotify_test.go:47: Stringify expected: `\"foo3\": Create|Write|Remove|Rename|Chmod`; got: `\"foo3\": nil`.\nFAIL\nexit status 1\nFAIL    _/home/james/code/src/fsnotify  13.449s\n. @nathany Good point RE: go generate. In this case if there's no mechanism to run this automatically, then I consider this an issue with go get.\nAs for the test failure, it is currently passing. I don't have a Windows machine.\nAt this point if there's something else you want to modify, feel free to just add a patch on top of mine if it would make it easier for you.\nCheers\n. @nathany ping :(\n. @nathany What's missing?\n. @nathany\n\nsee the comments i made during code review.\n\nI don't know what's missing... \n\nThis PR still needs a little more work before it's merged. I can do the work, but I haven't had a chance to yet.\n\nThis was just a \"get my feet wet\" patch for this project. Feel free to do with it what you want or not. Cheers!\n. Patch is here: https://github.com/purpleidea/fsnotify/tree/feat/stringify if you want it. I'm going to close this for now.\n. Just wanted to get the approximate ACK, so that I can point people here if they're interested in fanotify benefits. Thanks!\n. @nathany Thanks for the info! Looking forward to @amir73il's patches!\nCheers. @amir73il I have pinged some kernel engineers at my company to look into your patch. In the meantime, if you have a moment, could you look into and recommend an algorithm or suggest an improvement to the recursive file watching which I've implemented for mgmt? The code is available here:\nhttps://github.com/purpleidea/mgmt/blob/master/recwatch/recwatch.go#L134\nCheers!. On Wed, Feb 1, 2017 at 3:26 AM, Amir Goldstein notifications@github.com wrote:\n\n@purpleidea thanks for the ping. If your company will show interest in the super block watch, that can be a game changer. wrt your recursive watcher, I am new to golang and have zero knowledge about fsnotify library, but it appears your code is not calling addSubFolders() recursively from Init() more than 1 level of depth, so if you never get events on the direct sub folders you will never add watchers for level 2 subdirs, but I may be missing something. Also I don't see any handling of Move events for dirs, unless it is handled in lib by generating Rename/Create event pair.\n\nI think I am having an algorithmic mind block, as IIRC I think some\ncases didn't work all the time. In any case, golang is very similar to\nC if you get bored :)\n. I really owe a huge thanks to @tsuna for finding this issue. I've spent more time than I am happy to admit realizing that this is what seems to have caused a huge regression in https://github.com/purpleidea/mgmt/. I realized it was the fsnotify code causing the problem, and eventually found this ticket.\nI haven't added a workaround to my code yet, and instead will use an older version of this lib for now, but this is a very real problem. I don't completely understand the fix, so patches and hints welcome :)\nFWIW I hit the hang here:\nhttps://github.com/fsnotify/fsnotify/blob/master/inotify.go#L158\n. @tsuna I have a (possibly broken) implementation of a recursive watcher here: https://github.com/purpleidea/mgmt/blob/master/recwatch/recwatch.go#L19 I did rollback the version of this lib to avoid this bug though. I also think I found at least one issue with my lib anyways. In any case, HTH and a permanent fix is definitely welcome.\n. This is in response to:\nerr = watcher.Add(current)\nif err == syscall.ENOENT\nOn OSX this apparently doesn't trigger for file not found and generates a different event. Maybe it's just a different error code on OSX? I don't have a mac, so IDK.\n. (that works on GNU/Linux, btw)\n. @aarondl RE:\n\nI've signed the CLA and REALLY didn't want to. I'm fairly upset that this repo requires this, and then I read this only to find out I signed it without reason: golang/go#4068 (comment)\n\nI too am strongly against this! +1\nThanks for the patch. Look forward to testing this in https://github.com/purpleidea/mgmt/ shortly.. ",
    "landaire": "Any update on this? It'd be great to have.\n. @unixist not sure what system you're on but I was able to get recwatch to work on OS X with no issues besides having to update it to use this fsnotify package instead of the old one hosted under a different user/org (although I didn't try mkdir -p). You can see the code I used here.\n. Any update on this? It'd be great to have.\n. @unixist not sure what system you're on but I was able to get recwatch to work on OS X with no issues besides having to update it to use this fsnotify package instead of the old one hosted under a different user/org (although I didn't try mkdir -p). You can see the code I used here.\n. ",
    "xyproto": "I use recwatch in algernon, which works great on Linux/Windows/OS X. The only gotcha is to watch out for OS limitations in how many files can be watched. Especially on OS X the ulimit is very low by default.\n. FSEvents sounds like a good approach. The notify package has a few unresolved issues, though.\n. I use recwatch in algernon, which works great on Linux/Windows/OS X. The only gotcha is to watch out for OS limitations in how many files can be watched. Especially on OS X the ulimit is very low by default.\n. FSEvents sounds like a good approach. The notify package has a few unresolved issues, though.\n. ",
    "unixist": "Neither github.com/rjeczalik/notify nor recwatch place a watch on newly-added directories. This is fine if the directory structure is static, so for things like anomaly detection in a server environment or corporate asset.\nI have a use case (github.com/unixist/cryptostalker) that aims to detect crypto ransom malware on end-user computers. In such an environment, directories are expected to come and go all the time.\nIs there a potential for resource exhaustion that I'm unaware of, leading to this feature not being implemented more widely (and recursive at all for fsnotify)?\n. OK that might be a fluke in my testing since I created directories with mkdir -p. Still any comments welcome.\n. @landaire, I tore down my test system, but I'm thinking it was a premature post. Though I'm unsure what it was about the multiple directory creation that threw fsnotify for a loop.\nI'd be interested to know what you find doing the mkdir -p test on your code.\n. I tore down my test environment, but you can test by placing a watch on\n$dir and then doing \"mkdir -p $dir/foo/bar/baz\". I tested this on OSX.\nMaybe the underlying file system event handling differs by platform.\nOn Wed, Apr 13, 2016 at 12:07 AM, Pawel Knap notifications@github.com\nwrote:\n\nNeither github.com/rjeczalik/notify nor recwatch place a watch on\nnewly-added directories.\nCould you provide test case that reproduces this? @rjeczalik\nhttps://github.com/rjeczalik's notify package should add new\ndirectories when watching recursively. It is a bug if it doesn't.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/fsnotify/fsnotify/issues/18#issuecomment-209264403\n. Neither github.com/rjeczalik/notify nor recwatch place a watch on newly-added directories. This is fine if the directory structure is static, so for things like anomaly detection in a server environment or corporate asset.\n\nI have a use case (github.com/unixist/cryptostalker) that aims to detect crypto ransom malware on end-user computers. In such an environment, directories are expected to come and go all the time.\nIs there a potential for resource exhaustion that I'm unaware of, leading to this feature not being implemented more widely (and recursive at all for fsnotify)?\n. OK that might be a fluke in my testing since I created directories with mkdir -p. Still any comments welcome.\n. @landaire, I tore down my test system, but I'm thinking it was a premature post. Though I'm unsure what it was about the multiple directory creation that threw fsnotify for a loop.\nI'd be interested to know what you find doing the mkdir -p test on your code.\n. I tore down my test environment, but you can test by placing a watch on\n$dir and then doing \"mkdir -p $dir/foo/bar/baz\". I tested this on OSX.\nMaybe the underlying file system event handling differs by platform.\nOn Wed, Apr 13, 2016 at 12:07 AM, Pawel Knap notifications@github.com\nwrote:\n\nNeither github.com/rjeczalik/notify nor recwatch place a watch on\nnewly-added directories.\nCould you provide test case that reproduces this? @rjeczalik\nhttps://github.com/rjeczalik's notify package should add new\ndirectories when watching recursively. It is a bug if it doesn't.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/fsnotify/fsnotify/issues/18#issuecomment-209264403\n. \n",
    "ppknap": "\nNeither github.com/rjeczalik/notify nor recwatch place a watch on newly-added directories.\n\nCould you provide test case that reproduces this? @rjeczalik's notify package should add new directories when watching recursively. It is a bug if it doesn't. \n. Hi guys!\nI created a small test that reproduces this bug.\nGenerally you:\nREAD(iterate over) watches map: https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L80\nand\nDELETE items from it: https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L120\nThis Remove method is triggered by Remove or Rename events here:  https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L307\n@omeid you cannot use defer w.mu.Unlock() there because Remove method also acquires this mutex.\nThe simplest solution is to create a temporary map and copy all items from watchers map to it here: https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L76\nthen, you will just iterate over this temporary map. Close() is meant to be called once, so this extra allocation should be acceptable :)\nEDIT Test results(OSX):\n```\n{master} ~/gosrc/src/github.com/go-fsnotify/fsnotify$ go test --race\n==================\nWARNING: DATA RACE\nRead by goroutine 66:\n  runtime.mapiternext()\n      /private/var/folders/q8/bf_4b1ts2zj0l7b0p1dv36lr0000gp/T/workdir/go/src/runtime/hashmap.go:621 +0x0\n  github.com/go-fsnotify/fsnotify.(*Watcher).Close()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/kqueue.go:80 +0x233\n  github.com/go-fsnotify/fsnotify.TestRemoveWithClose.func3()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/integration_test.go:1220 +0x55\nPrevious write by goroutine 63:\n  runtime.mapdelete()\n      /private/var/folders/q8/bf_4b1ts2zj0l7b0p1dv36lr0000gp/T/workdir/go/src/runtime/hashmap.go:511 +0x0\n  github.com/go-fsnotify/fsnotify.(Watcher).Remove()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/kqueue.go:120 +0x4ed\n  github.com/go-fsnotify/fsnotify.(Watcher).readEvents()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/kqueue.go:307 +0x878\nGoroutine 66 (running) created at:\n  github.com/go-fsnotify/fsnotify.TestRemoveWithClose()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/integration_test.go:1221 +0x4e8\n  testing.tRunner()\n      /private/var/folders/q8/bf_4b1ts2zj0l7b0p1dv36lr0000gp/T/workdir/go/src/testing/testing.go:456 +0xdc\nGoroutine 63 (running) created at:\n  github.com/go-fsnotify/fsnotify.NewWatcher()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/kqueue.go:61 +0x443\n  github.com/go-fsnotify/fsnotify.newWatcher()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/integration_test.go:59 +0x3b\n  github.com/go-fsnotify/fsnotify.TestRemoveWithClose()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/integration_test.go:1196 +0x27b\n  testing.tRunner()\n      /private/var/folders/q8/bf_4b1ts2zj0l7b0p1dv36lr0000gp/T/workdir/go/src/testing/testing.go:456 +0xdc\n==================\nPASS\nFound 1 data race(s)\nexit status 66\nFAIL    github.com/go-fsnotify/fsnotify 9.650s\n```\n. Hi @nathany!\nSure, I could fix this easily but I do not have much time right now.\nTests don't fail because your .travis.yml configuration uses default settings for Go builds. Thus, your tests are run with go test -v ./... command and don't fire race checker. You may want to add script: go test -v --race ./... to your .travis.yml.\n. LGTM :+1: \n. Which OS do you use?\n. Are you sure that you have the latest version? It is quite obvious that fsnotify hangs on syscall.Read function which is currently here (line 205). Your stack trace shows that the call to syscall.Read function is in line 144 which means that  you may use an old version of the package.\nHonestly speaking, I don't believe that upgrading fsnotify will help(but it may). Implementation of readEvents function is definitely not thread safe.. \n. I cannot reproduce this bug on current master. Could you use version ^1.2.0 and confirm that this bug is still present? \n. the code provided by @flexd is not basically the code from godoc example. There are two goroutines here. The first one creates a watcher, runs second goroutine that is responsible for catching events, then adds ./post folder/file and returns immediately. This calls defer watcher.Close() function which closes both watcher.Events and watcher.Errors channels. That's the reason why you receive an endless stream of zero values. \n. Most likely we should replace watch.path+\"\\\\\"+name with filepath.Join(watch.patch, name)\nhttps://github.com/fsnotify/fsnotify/blob/master/windows.go#L309\nhttps://github.com/fsnotify/fsnotify/blob/master/windows.go#L319\nhttps://github.com/fsnotify/fsnotify/blob/master/windows.go#L456\nhttps://github.com/fsnotify/fsnotify/blob/master/windows.go#L494\n. @twpayne - I'm not a maintainer of this package but these changes LGTM.\n\nRace when Add() is called concurrently.\n\n:+1:, moreover, it fixes potential deadlock when Add(..) and Remove(..) are called concurrently with the same path...\n\nIncorrect flags stored when InotifyAddWatch fails.\n\n(Unfortunately) this is not entirely true, because the current fsnotify logic always sets all inotify events to be watched (agnosticEvents). This also implies that unix.IN_MASK_ADD is not needed at all. However, this is a different story... \nOverall, this PR is an improvement of current logic.. @twpayne @nathany I'm pretty sure this code won't break anything system dependent.. > Neither github.com/rjeczalik/notify nor recwatch place a watch on newly-added directories.\nCould you provide test case that reproduces this? @rjeczalik's notify package should add new directories when watching recursively. It is a bug if it doesn't. \n. Hi guys!\nI created a small test that reproduces this bug.\nGenerally you:\nREAD(iterate over) watches map: https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L80\nand\nDELETE items from it: https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L120\nThis Remove method is triggered by Remove or Rename events here:  https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L307\n@omeid you cannot use defer w.mu.Unlock() there because Remove method also acquires this mutex.\nThe simplest solution is to create a temporary map and copy all items from watchers map to it here: https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L76\nthen, you will just iterate over this temporary map. Close() is meant to be called once, so this extra allocation should be acceptable :)\nEDIT Test results(OSX):\n```\n{master} ~/gosrc/src/github.com/go-fsnotify/fsnotify$ go test --race\n==================\nWARNING: DATA RACE\nRead by goroutine 66:\n  runtime.mapiternext()\n      /private/var/folders/q8/bf_4b1ts2zj0l7b0p1dv36lr0000gp/T/workdir/go/src/runtime/hashmap.go:621 +0x0\n  github.com/go-fsnotify/fsnotify.(*Watcher).Close()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/kqueue.go:80 +0x233\n  github.com/go-fsnotify/fsnotify.TestRemoveWithClose.func3()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/integration_test.go:1220 +0x55\nPrevious write by goroutine 63:\n  runtime.mapdelete()\n      /private/var/folders/q8/bf_4b1ts2zj0l7b0p1dv36lr0000gp/T/workdir/go/src/runtime/hashmap.go:511 +0x0\n  github.com/go-fsnotify/fsnotify.(Watcher).Remove()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/kqueue.go:120 +0x4ed\n  github.com/go-fsnotify/fsnotify.(Watcher).readEvents()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/kqueue.go:307 +0x878\nGoroutine 66 (running) created at:\n  github.com/go-fsnotify/fsnotify.TestRemoveWithClose()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/integration_test.go:1221 +0x4e8\n  testing.tRunner()\n      /private/var/folders/q8/bf_4b1ts2zj0l7b0p1dv36lr0000gp/T/workdir/go/src/testing/testing.go:456 +0xdc\nGoroutine 63 (running) created at:\n  github.com/go-fsnotify/fsnotify.NewWatcher()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/kqueue.go:61 +0x443\n  github.com/go-fsnotify/fsnotify.newWatcher()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/integration_test.go:59 +0x3b\n  github.com/go-fsnotify/fsnotify.TestRemoveWithClose()\n      /Users/pawelk/gosrc/src/github.com/go-fsnotify/fsnotify/integration_test.go:1196 +0x27b\n  testing.tRunner()\n      /private/var/folders/q8/bf_4b1ts2zj0l7b0p1dv36lr0000gp/T/workdir/go/src/testing/testing.go:456 +0xdc\n==================\nPASS\nFound 1 data race(s)\nexit status 66\nFAIL    github.com/go-fsnotify/fsnotify 9.650s\n```\n. Hi @nathany!\nSure, I could fix this easily but I do not have much time right now.\nTests don't fail because your .travis.yml configuration uses default settings for Go builds. Thus, your tests are run with go test -v ./... command and don't fire race checker. You may want to add script: go test -v --race ./... to your .travis.yml.\n. LGTM :+1: \n. Which OS do you use?\n. Are you sure that you have the latest version? It is quite obvious that fsnotify hangs on syscall.Read function which is currently here (line 205). Your stack trace shows that the call to syscall.Read function is in line 144 which means that  you may use an old version of the package.\nHonestly speaking, I don't believe that upgrading fsnotify will help(but it may). Implementation of readEvents function is definitely not thread safe.. \n. I cannot reproduce this bug on current master. Could you use version ^1.2.0 and confirm that this bug is still present? \n. the code provided by @flexd is not basically the code from godoc example. There are two goroutines here. The first one creates a watcher, runs second goroutine that is responsible for catching events, then adds ./post folder/file and returns immediately. This calls defer watcher.Close() function which closes both watcher.Events and watcher.Errors channels. That's the reason why you receive an endless stream of zero values. \n. Most likely we should replace watch.path+\"\\\\\"+name with filepath.Join(watch.patch, name)\nhttps://github.com/fsnotify/fsnotify/blob/master/windows.go#L309\nhttps://github.com/fsnotify/fsnotify/blob/master/windows.go#L319\nhttps://github.com/fsnotify/fsnotify/blob/master/windows.go#L456\nhttps://github.com/fsnotify/fsnotify/blob/master/windows.go#L494\n. @twpayne - I'm not a maintainer of this package but these changes LGTM.\n\nRace when Add() is called concurrently.\n\n:+1:, moreover, it fixes potential deadlock when Add(..) and Remove(..) are called concurrently with the same path...\n\nIncorrect flags stored when InotifyAddWatch fails.\n\n(Unfortunately) this is not entirely true, because the current fsnotify logic always sets all inotify events to be watched (agnosticEvents). This also implies that unix.IN_MASK_ADD is not needed at all. However, this is a different story... \nOverall, this PR is an improvement of current logic.. @twpayne @nathany I'm pretty sure this code won't break anything system dependent.. ",
    "Dominik-K": "Hi. The fswatch may be a good place for fsnotify, especially for this issue. They state it has \"no known limitations\" on Solaris kernels (with FEN). I.e. also with recursive monitoring. . Hi. The fswatch may be a good place for fsnotify, especially for this issue. They state it has \"no known limitations\" on Solaris kernels (with FEN). I.e. also with recursive monitoring. . ",
    "dc0d": "I would very much like to see this!. I would very much like to see this!. ",
    "stumpyfr": "Any new on that?\n. Any new on that?\n. ",
    "edrex": "I'm guessing @extemporalgenome's original question was \"How can an fsnotify user listen for changes to a single file in a way that works with all the various text editors' save strategies?\".\nMany editors are do a little dance around saving which confounds the strategy of listening to the file for write events. For example, vim:\n2015/03/25 23:18:42 event: \"./foo.txt\": RENAME\n2015/03/25 23:18:42 event: \"./foo.txt~\": CREATE\n2015/03/25 23:18:42 event: \"./foo.txt\": CREATE\n2015/03/25 23:18:42 event: \"./foo.txt\": WRITE\n2015/03/25 23:18:42 modified file: ./foo.txt\nIt seems like the most compatible strategy is to listen to the directory and only pay attention to events matching the file name, but it's not clear which event types to listen to. Just fsevents.Write is enough for vim. For many other editors, IN_MOVE_TO is needed.\n. @nathany thanks, #17 is just what I was looking for.\nIt seems like file watching works across atomic saves on OSX (the watch stays with the path, even though the underlying file is replaced). Curious platform difference..\n@rjeczalik I'm really just a user troubleshooting an issue with a downstream package (adnanh/webhook)\n. I'm guessing @extemporalgenome's original question was \"How can an fsnotify user listen for changes to a single file in a way that works with all the various text editors' save strategies?\".\nMany editors are do a little dance around saving which confounds the strategy of listening to the file for write events. For example, vim:\n2015/03/25 23:18:42 event: \"./foo.txt\": RENAME\n2015/03/25 23:18:42 event: \"./foo.txt~\": CREATE\n2015/03/25 23:18:42 event: \"./foo.txt\": CREATE\n2015/03/25 23:18:42 event: \"./foo.txt\": WRITE\n2015/03/25 23:18:42 modified file: ./foo.txt\nIt seems like the most compatible strategy is to listen to the directory and only pay attention to events matching the file name, but it's not clear which event types to listen to. Just fsevents.Write is enough for vim. For many other editors, IN_MOVE_TO is needed.\n. @nathany thanks, #17 is just what I was looking for.\nIt seems like file watching works across atomic saves on OSX (the watch stays with the path, even though the underlying file is replaced). Curious platform difference..\n@rjeczalik I'm really just a user troubleshooting an issue with a downstream package (adnanh/webhook)\n. ",
    "rjeczalik": "Hey @edrex, @nathany! If you'd want to use IN_MOVE_{FROM,TO} events for inotify, then notify supports them out of the box - see LinuxMove example for the Watch method, in particular:\ngo\nerr := notify.Watch(\"/dir/to/watch\", channel, notify.InMovedFrom, notify.InMovedTo);\nI'm not suggesting you should pick it over fsnotify, I'm suggesting you could at least test your use-case, whether you really need platform-specific events for that.\n. Hey @edrex, @nathany! If you'd want to use IN_MOVE_{FROM,TO} events for inotify, then notify supports them out of the box - see LinuxMove example for the Watch method, in particular:\ngo\nerr := notify.Watch(\"/dir/to/watch\", channel, notify.InMovedFrom, notify.InMovedTo);\nI'm not suggesting you should pick it over fsnotify, I'm suggesting you could at least test your use-case, whether you really need platform-specific events for that.\n. ",
    "kars7e": "Big +1, I'm currently trying to handle this using timers but this approach is asking for trouble.\n. Big +1, I'm currently trying to handle this using timers but this approach is asking for trouble.\n. ",
    "jaytaylor": "+1 since this is a big problem for many use-cases.  Why doesn't the Event struct support providing this information already?\n. +1 since this is a big problem for many use-cases.  Why doesn't the Event struct support providing this information already?\n. ",
    "jmhodges": "Hey, this would be great to get. My justrun utility is failing for vim users because vim does Weird Things with rename on OS X.\n. I think watchdog (https://github.com/gorakhargosh/watchdog) has figured out a cross-platform API, by the way.\n. Hey, this would be great to get. My justrun utility is failing for vim users because vim does Weird Things with rename on OS X.\n. I think watchdog (https://github.com/gorakhargosh/watchdog) has figured out a cross-platform API, by the way.\n. ",
    "F21": "Was a solution ever found for this?\n. Do you think keeping a list of os.FileInfos in a concurrently safe map like map[string]*os.FileInfo as mentioned by @aktau is probably the best way to get this implemented?\n. Having done some experimentation on Windows, the os.Samefile() method doesn't work on Windows, because it compares by using the file path. So, if you had test.txt, the fileInfo stores the path to test.txt. After renaming it to test2.txt, using os.Lstat() on the new file stores the path as test2.txt. When you do a comparison with os.Samefile(), it sees that the file paths for the 2 FileInfos are different and returns false.\n. If I use copy /b filename.ext +,, I only get 1 write event. If I use notepad++ or notepad to edit the file and save, I get 2 write events.\n. Was a solution ever found for this?\n. Do you think keeping a list of os.FileInfos in a concurrently safe map like map[string]*os.FileInfo as mentioned by @aktau is probably the best way to get this implemented?\n. Having done some experimentation on Windows, the os.Samefile() method doesn't work on Windows, because it compares by using the file path. So, if you had test.txt, the fileInfo stores the path to test.txt. After renaming it to test2.txt, using os.Lstat() on the new file stores the path as test2.txt. When you do a comparison with os.Samefile(), it sees that the file paths for the 2 FileInfos are different and returns false.\n. If I use copy /b filename.ext +,, I only get 1 write event. If I use notepad++ or notepad to edit the file and save, I get 2 write events.\n. ",
    "hariharan-uno": "Yes..I have signed it!\n. Yes..I have signed it!\n. ",
    "tianon": "Sounds OK to me; thanks for the heads up! :heart:\n. Sounds OK to me; thanks for the heads up! :heart:\n. ",
    "cookieo9": "Wouldn't fsevents be accessible as gopkg.in/go-fsnotify/fsevents.v0 in that situation?\nThe go-/ convention is just a shortcut AFAIK. For example: http://gopkg.in/qml.v0 is also accessible as http://gopkg.in/go-qml/qml.v0 and both refer to http://github.com/go-qml/qml\n. Wouldn't fsevents be accessible as gopkg.in/go-fsnotify/fsevents.v0 in that situation?\nThe go-/ convention is just a shortcut AFAIK. For example: http://gopkg.in/qml.v0 is also accessible as http://gopkg.in/go-qml/qml.v0 and both refer to http://github.com/go-qml/qml\n. ",
    "mewmew": "Remember to update the documentation link in the repo description from http://godoc.org/github.com/fsnotify/fsnotify to http://godoc.org/github.com/go-fsnotify/fsnotify\n. Remember to update the documentation link in the repo description from http://godoc.org/github.com/fsnotify/fsnotify to http://godoc.org/github.com/go-fsnotify/fsnotify\n. ",
    "sbakke": "Thank for the response. I would also reconsider the forced goroutine/channel usage as well, in case the library is used without the need for concurrency. This way it would look more like other IO packages in the standard library. Keep in mind the nightmare that is Java's standard library as an example where different generations of packages have different API style, especially within the IO library.\n. Thank for the response. I would also reconsider the forced goroutine/channel usage as well, in case the library is used without the need for concurrency. This way it would look more like other IO packages in the standard library. Keep in mind the nightmare that is Java's standard library as an example where different generations of packages have different API style, especially within the IO library.\n. ",
    "yueqili": "I found it's because fsnotify is not recursive. Any way to make it recursive?\n. I found it's because fsnotify is not recursive. Any way to make it recursive?\n. ",
    "YuriyNasretdinov": "It seems that FSEvents actually reliably returns all subpaths as well, but there is a special flag in apple documentation that says that events might be \"dropped\" for subdirs: kFSEventStreamEventFlagMustScanSubDirs\nI think that you can safely use the same pattern \u2014 try to send events for subdirs when possible, but include similar flag into response events that would indicate that subdirs scan is required\n. It seems that FSEvents actually reliably returns all subpaths as well, but there is a special flag in apple documentation that says that events might be \"dropped\" for subdirs: kFSEventStreamEventFlagMustScanSubDirs\nI think that you can safely use the same pattern \u2014 try to send events for subdirs when possible, but include similar flag into response events that would indicate that subdirs scan is required\n. ",
    "zhsso": "No, What's the difference?\nI saw you use \"file path.Clean\" in https://github.com/go-fsnotify/fsnotify/blob/master/fsnotify_bsd.go#L371\nand when I use Watcher.Add(\"./\") and then  mv a b, it occur an error here\nhttps://github.com/go-fsnotify/fsnotify/blob/master/fsnotify_bsd.go#L373\nbecause there is w.watches[\"./\"] but not w.watches[\".\"] in it..\nI Think use filepath. Abs() must be a better way\n. I read the source of path.Clean() filepath.Clean()\nit seems they do the same thing in Linux and BSD\nbut filepath.Clean() deal with the PathSeparator in windows, and path.Clean() not\nIs this the difference?\n. I signed it  Electronically just a moment ago \ud83d\ude0a\n. No, What's the difference?\nI saw you use \"file path.Clean\" in https://github.com/go-fsnotify/fsnotify/blob/master/fsnotify_bsd.go#L371\nand when I use Watcher.Add(\"./\") and then  mv a b, it occur an error here\nhttps://github.com/go-fsnotify/fsnotify/blob/master/fsnotify_bsd.go#L373\nbecause there is w.watches[\"./\"] but not w.watches[\".\"] in it..\nI Think use filepath. Abs() must be a better way\n. I read the source of path.Clean() filepath.Clean()\nit seems they do the same thing in Linux and BSD\nbut filepath.Clean() deal with the PathSeparator in windows, and path.Clean() not\nIs this the difference?\n. I signed it  Electronically just a moment ago \ud83d\ude0a\n. ",
    "garyburd": "@nathany I don't see github.com/laughlinez/flow listed as an importer, but I do see github.com/laughlinez/flow/gadgets. This importer is correct.\n. @nathany I don't see github.com/laughlinez/flow listed as an importer, but I do see github.com/laughlinez/flow/gadgets. This importer is correct.\n. ",
    "kylelemons": "@nathany kylelemons.net/go/gofr/static updated.\n. @nathany kylelemons.net/go/gofr/static updated.\n. ",
    "chenyukang": "Hi @nathany,\n    I think this is not a complete \"hello world\" example, I am an newbie for Golang, so when I try to run this example, it's  not work as expected(should loop and print something when I have some modification over the directory).\n   The example in page: https://github.com/howeyc/fsnotify seems more meaningful.\n. Hi @nathany,\n    I think this is not a complete \"hello world\" example, I am an newbie for Golang, so when I try to run this example, it's  not work as expected(should loop and print something when I have some modification over the directory).\n   The example in page: https://github.com/howeyc/fsnotify seems more meaningful.\n. ",
    "chamaken": "I close and reopen by mistake, sorry.\nI prefer using pipe fd notification than timeout. Talking about epoll vs. select\nI think there are three issues.\n- select requires cgo, that's say built binary will be dynamically linked\n- epoll was developed for large number of file descriptors\n- (It seems) you are familiar with select more than epoll\nwould you, maintainer decide which one is suitable?\n. I agree. Thank you for your suggestion. @nathany\n. Thank you for telling me. @nathany \nI am OK with that.\n. Thank you for taking your time.\nI will restore commens. How about changing first comment:\ninotify_rm_watch will return EINVAL if the file has been deleted;\nthe inotify will already have been removed.\nwatches and pathes are deleted in ignoreLinux() implicitly and asynchronously\nby calling inotify_rm_watch() below. e.g. readEvents() goroutine receives IN_IGNORE\nso that EINVAL means that the wd is being rm_watch()ed or its file removed\nby another thread and we have not received IN_IGNORE event.\n. I close and reopen by mistake, sorry.\nI prefer using pipe fd notification than timeout. Talking about epoll vs. select\nI think there are three issues.\n- select requires cgo, that's say built binary will be dynamically linked\n- epoll was developed for large number of file descriptors\n- (It seems) you are familiar with select more than epoll\nwould you, maintainer decide which one is suitable?\n. I agree. Thank you for your suggestion. @nathany\n. Thank you for telling me. @nathany \nI am OK with that.\n. Thank you for taking your time.\nI will restore commens. How about changing first comment:\ninotify_rm_watch will return EINVAL if the file has been deleted;\nthe inotify will already have been removed.\nwatches and pathes are deleted in ignoreLinux() implicitly and asynchronously\nby calling inotify_rm_watch() below. e.g. readEvents() goroutine receives IN_IGNORE\nso that EINVAL means that the wd is being rm_watch()ed or its file removed\nby another thread and we have not received IN_IGNORE event.\n. ",
    "cespare": "Thanks; I'll try to review that change but it's basically a complete rewrite and I'm not familiar with the relevant Linux APIs.\n. I'm not quite clear about what we're discussing here.\nI'm trying to implement recursive watching myself, today, independently of #18. fsnotify does not let me do this without keeping track of all watches (i.e. duplicating w.watches) myself.\n\njust walk the subfolders of a path and remove any watches that exist\n\nYou can't do this once the directory is gone.\nSo I'm interested in a way of getting at w.watches directly, without relying on current FS state.\n. > It might be worth building a small test case to see if unwatching deleted folders is necessary.\nIt is not necessary from an inotify perspective; the watch is gone when the inode goes away.\nA satisfactory solution to this might very well be \"you don't have to delete watches for removed directories; they are removed automatically.\" But then we'd have to make sure that works:\n1. Ensure that the OS API (inotify, etc) watches are removed automatically on all platforms (may just work, like it does for inotify)\n2. Automatically delete removed paths from w.watches, which is not even possible to do manually (from a client) right now because of #40.\n. Thanks; I'll try to review that change but it's basically a complete rewrite and I'm not familiar with the relevant Linux APIs.\n. I'm not quite clear about what we're discussing here.\nI'm trying to implement recursive watching myself, today, independently of #18. fsnotify does not let me do this without keeping track of all watches (i.e. duplicating w.watches) myself.\n\njust walk the subfolders of a path and remove any watches that exist\n\nYou can't do this once the directory is gone.\nSo I'm interested in a way of getting at w.watches directly, without relying on current FS state.\n. > It might be worth building a small test case to see if unwatching deleted folders is necessary.\nIt is not necessary from an inotify perspective; the watch is gone when the inode goes away.\nA satisfactory solution to this might very well be \"you don't have to delete watches for removed directories; they are removed automatically.\" But then we'd have to make sure that works:\n1. Ensure that the OS API (inotify, etc) watches are removed automatically on all platforms (may just work, like it does for inotify)\n2. Automatically delete removed paths from w.watches, which is not even possible to do manually (from a client) right now because of #40.\n. ",
    "timshannon": "FYI, I'm seeing this same behavior in my project and can readily duplicate it.\nI'm going to look at synchthing's inotify library as they seemed to have fixed it.\n. I've been able to duplicate this in a stand alone piece of code.\nThere is a gist here (https://gist.github.com/timshannon/603f92824c5294269797) that you can run to see this issue.\n. No, it only happens on Windows.\nWorks fine on linux, i expect because linux doesn't hold onto file handles like windows.\n. FYI, I'm seeing this same behavior in my project and can readily duplicate it.\nI'm going to look at synchthing's inotify library as they seemed to have fixed it.\n. I've been able to duplicate this in a stand alone piece of code.\nThere is a gist here (https://gist.github.com/timshannon/603f92824c5294269797) that you can run to see this issue.\n. No, it only happens on Windows.\nWorks fine on linux, i expect because linux doesn't hold onto file handles like windows.\n. ",
    "ottob": "Thanks for working on this.\n4a0d1ae9df8c61fb8912829fc714f189358a3dc7 broke the revel watcher for me. Now I get an infinite refresh loop. It's seems related to this old issue https://github.com/revel/revel/issues/460\n. Yes I did a git bisect. I'm using official revel v0.10.0.\nThe problem is that I can't reproduce it with a small revel sample app but only with our internal medium sized project (but it's not reproducible 100% of the time with our project either). I will see if I can create a smaller test case next week.\n. I'm running OSX 10.9.5 and I tried today with latest fsnotify and your revel fix #734. Unfortunately I still see the same issue. I haven't hade the time to create a smaller test case, I will try next week.\n. I've spent the entire day trying to reproduce this in a consistent fashion. But I can't...\nI've tried with a tiny revel app (just revel new) - no issue. I've tried with a slightly larger (booking) - no issue. But with our code I still have the issue.\nI tried the following with our app with an instrumented revel watcher[1]:\n1. Launch the app. revel run ourapp\n2. Go to /robots.txt and wait for revel to rebuild and serve the file.\n3. Without touching any files of the project, refresh the browser (f5) and see what happens.\nWith the kqueue branch (71b4293) I got this output the first time I tried:\nhttp://paste2.org/MaDA2xsn\nand this the second time:\nhttp://paste2.org/Ih9zspp4\nSo it behaves differently in two different runs even though I'm doing the exact same thing. :cry: \nThen I switched back to the master branch (ca50e738d3) and I consistently get the following:\nhttp://paste2.org/Fmm6pvVn\nSo with the master branch there are no rebuilds triggered by changes to tmp/main.go or routes/routes.go. With master the only events are the folder changes to app/tmp and app/routes. Can this give you any clue?\n[1] Where https://github.com/revel/revel/blob/develop/watcher.go#L174-L176 was changed to this:\ncase ev := <-watcher.Events:\n    fmt.Println(\"ev\", ev.String())\n    if w.rebuildRequired(ev, listener) {\n        fmt.Println(\"rb\", ev.String())\n        refresh = true\n. Feel free to close this. I will re-open if I ever manage to write a test that triggers the issue.\n. :clap: thanks for tracking it down.\n. Thanks for working on this.\n4a0d1ae9df8c61fb8912829fc714f189358a3dc7 broke the revel watcher for me. Now I get an infinite refresh loop. It's seems related to this old issue https://github.com/revel/revel/issues/460\n. Yes I did a git bisect. I'm using official revel v0.10.0.\nThe problem is that I can't reproduce it with a small revel sample app but only with our internal medium sized project (but it's not reproducible 100% of the time with our project either). I will see if I can create a smaller test case next week.\n. I'm running OSX 10.9.5 and I tried today with latest fsnotify and your revel fix #734. Unfortunately I still see the same issue. I haven't hade the time to create a smaller test case, I will try next week.\n. I've spent the entire day trying to reproduce this in a consistent fashion. But I can't...\nI've tried with a tiny revel app (just revel new) - no issue. I've tried with a slightly larger (booking) - no issue. But with our code I still have the issue.\nI tried the following with our app with an instrumented revel watcher[1]:\n1. Launch the app. revel run ourapp\n2. Go to /robots.txt and wait for revel to rebuild and serve the file.\n3. Without touching any files of the project, refresh the browser (f5) and see what happens.\nWith the kqueue branch (71b4293) I got this output the first time I tried:\nhttp://paste2.org/MaDA2xsn\nand this the second time:\nhttp://paste2.org/Ih9zspp4\nSo it behaves differently in two different runs even though I'm doing the exact same thing. :cry: \nThen I switched back to the master branch (ca50e738d3) and I consistently get the following:\nhttp://paste2.org/Fmm6pvVn\nSo with the master branch there are no rebuilds triggered by changes to tmp/main.go or routes/routes.go. With master the only events are the folder changes to app/tmp and app/routes. Can this give you any clue?\n[1] Where https://github.com/revel/revel/blob/develop/watcher.go#L174-L176 was changed to this:\ncase ev := <-watcher.Events:\n    fmt.Println(\"ev\", ev.String())\n    if w.rebuildRequired(ev, listener) {\n        fmt.Println(\"rb\", ev.String())\n        refresh = true\n. Feel free to close this. I will re-open if I ever manage to write a test that triggers the issue.\n. :clap: thanks for tracking it down.\n. ",
    "sqs": "Currently srclib-go (which performs the Go analysis) compiles it as a Linux machine would, yes. I just posted an issue to add build tag support, though: https://github.com/sourcegraph/srclib-go/issues/16. If this would be important to you, I can expedite it. :smile: \n. Currently srclib-go (which performs the Go analysis) compiles it as a Linux machine would, yes. I just posted an issue to add build tag support, though: https://github.com/sourcegraph/srclib-go/issues/16. If this would be important to you, I can expedite it. :smile: \n. ",
    "amkgo": "How can I do to get more message for you?\n. Thanks.\n. How can I do to get more message for you?\n. Thanks.\n. ",
    "felipejfc": "OS X Yosemite\n. More info, \n1 - create a link (create event triggered)\n2 - delete the link (no event triggered)\n3 - create the same link again (no event triggered)\n4 - remove the file referenced by the first link (remove event triggered)\n. OS X Yosemite\n. More info, \n1 - create a link (create event triggered)\n2 - delete the link (no event triggered)\n3 - create the same link again (no event triggered)\n4 - remove the file referenced by the first link (remove event triggered)\n. ",
    "daemonfire300": "@nathany Hi nathany, yes I already did fix the error on my end by upgrading. I came accross it when using revel (https://github.com/revel/revel/issues/803). I should have posted my conclusion here as well.\n. @nathany Hi nathany, yes I already did fix the error on my end by upgrading. I came accross it when using revel (https://github.com/revel/revel/issues/803). I should have posted my conclusion here as well.\n. ",
    "evanj": "Yep, this sounds like it could be related. My use of fsnotify isn't critical enough at the moment for me to spend the time to debug this further at this at the moment, but I am happy to test new versions when they come up. Thanks!\n. I just verified this with go 1.4 on Mac OS X 10.9.5. I am no longer able to reproduce this bug. Thanks!\n. Yep, this sounds like it could be related. My use of fsnotify isn't critical enough at the moment for me to spend the time to debug this further at this at the moment, but I am happy to test new versions when they come up. Thanks!\n. I just verified this with go 1.4 on Mac OS X 10.9.5. I am no longer able to reproduce this bug. Thanks!\n. ",
    "pkrnjevic": "For those interested, here is a small example of using Windows Journals I wrote in Go, based on the MSJ Windows Change Journal article and sample. \nI can confirm this works with Windows 7 (32 bit) with Go 1.3.3. Must be run with Administrator privileges.\n. Not that I know of. \nMy plan was to use it in a Windows service, with a user space client interface, though there are probably better ideas.\n\nOn Nov 19, 2014, at 12:14 AM, Nathan Youngman notifications@github.com wrote:\nIs it possible to use USN Journals without Administrator privileges?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/go-fsnotify/fsnotify/issues/53#issuecomment-63593356.\n. For those interested, here is a small example of using Windows Journals I wrote in Go, based on the MSJ Windows Change Journal article and sample. \nI can confirm this works with Windows 7 (32 bit) with Go 1.3.3. Must be run with Administrator privileges.\n. Not that I know of. \nMy plan was to use it in a Windows service, with a user space client interface, though there are probably better ideas.\nOn Nov 19, 2014, at 12:14 AM, Nathan Youngman notifications@github.com wrote:\nIs it possible to use USN Journals without Administrator privileges?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/go-fsnotify/fsnotify/issues/53#issuecomment-63593356.\n. \n",
    "atimoschenkow": "Hi, \nis anyone still working on this?\n. Hi, \nis anyone still working on this?\n. ",
    "qloak": "Is anybody still working on this project? I have some interest on getting go to work with USN journal.\n. Is anybody still working on this project? I have some interest on getting go to work with USN journal.\n. ",
    "elvarb": "Would love for this to get implemented, such a powerful feature.\nFound this that could be of help.\nhttps://blogs.technet.microsoft.com/heyscriptingguy/2015/08/12/use-poshusnjournal-module-to-work-with-change-journal/\n. Would love for this to get implemented, such a powerful feature.\nFound this that could be of help.\nhttps://blogs.technet.microsoft.com/heyscriptingguy/2015/08/12/use-poshusnjournal-module-to-work-with-change-journal/\n. ",
    "jimzhan": "Hi @nathany & thanks for the quick response.\n- I was just adding some characters to an existing file\n- I was using VIM under iTerm2\n- I was watching  its directory\nClearly the events were triggered but not in the suggested way to catch.\n. @nathany By going through  these related issues along with several further test cases, I suppose the simple delay trick is the only solution for now?\n. I've tested Create & Write as well & they can't catch Delete & Update, what I'm doing now is a silly simple trick:\n``` go\n    var delay <-chan time.Time\n    for {\n        select {\n        case event := <-self.daemon.Events:\n            if self.inWatchList(event) {\n                delay = time.After(3 * time.Second)\n            }\n    case err := <-self.daemon.Errors:\n        log.Fatalf(\"Failed to watch the application sources: %v\", err)\n\n    case <-delay:\n        // restart the daemon watcher.\n        self.watch()\n\n        err = self.install()\n        if !self.installed {\n            continue\n        }\n        gorun <- true\n    }\n}\n\n```\nAny other suggestion?\n. A brief follow-up, by checking all Write, Create & Remove events, and also postpone a bits seems to be working now.\n``` go\nfunc (self *app) inWatchList(event fsnotify.Event) bool {\n    var basename = filepath.Base(event.Name)\nif event.Op&fsnotify.Write == fsnotify.Write ||\n    event.Op&fsnotify.Create == fsnotify.Create ||\n    event.Op&fsnotify.Remove == fsnotify.Remove {\n    // We only needs WatchList under write events.\n    for _, pattern := range WatchList {\n        matched, _ := filepath.Match(pattern, basename)\n        if matched {\n            return true\n        }\n    }\n}\nreturn false\n\n}\n```\n``` go\n    var delay <-chan time.Time\n    for {\n        select {\n        case event := <-self.daemon.Events:\n            if self.inWatchList(event) {\n                delay = time.After(500 * time.Millisecond)\n            }\n    case err := <-self.daemon.Errors:\n        log.Fatalf(\"Failed to watch the application sources: %v\", err)\n\n    case <-delay:\n        // restart the daemon watcher.\n        self.watch()\n\n        err = self.install()\n        if !self.installed {\n            continue\n        }\n        gorun <- true\n    }\n}\n\n```\nI hope there'll be a better solution shipped with fsnotify, but this is by far the most stable one I've tested.\n. Hi @nathany & thanks for the quick response.\n- I was just adding some characters to an existing file\n- I was using VIM under iTerm2\n- I was watching  its directory\nClearly the events were triggered but not in the suggested way to catch.\n. @nathany By going through  these related issues along with several further test cases, I suppose the simple delay trick is the only solution for now?\n. I've tested Create & Write as well & they can't catch Delete & Update, what I'm doing now is a silly simple trick:\n``` go\n    var delay <-chan time.Time\n    for {\n        select {\n        case event := <-self.daemon.Events:\n            if self.inWatchList(event) {\n                delay = time.After(3 * time.Second)\n            }\n    case err := <-self.daemon.Errors:\n        log.Fatalf(\"Failed to watch the application sources: %v\", err)\n\n    case <-delay:\n        // restart the daemon watcher.\n        self.watch()\n\n        err = self.install()\n        if !self.installed {\n            continue\n        }\n        gorun <- true\n    }\n}\n\n```\nAny other suggestion?\n. A brief follow-up, by checking all Write, Create & Remove events, and also postpone a bits seems to be working now.\n``` go\nfunc (self *app) inWatchList(event fsnotify.Event) bool {\n    var basename = filepath.Base(event.Name)\nif event.Op&fsnotify.Write == fsnotify.Write ||\n    event.Op&fsnotify.Create == fsnotify.Create ||\n    event.Op&fsnotify.Remove == fsnotify.Remove {\n    // We only needs WatchList under write events.\n    for _, pattern := range WatchList {\n        matched, _ := filepath.Match(pattern, basename)\n        if matched {\n            return true\n        }\n    }\n}\nreturn false\n\n}\n```\n``` go\n    var delay <-chan time.Time\n    for {\n        select {\n        case event := <-self.daemon.Events:\n            if self.inWatchList(event) {\n                delay = time.After(500 * time.Millisecond)\n            }\n    case err := <-self.daemon.Errors:\n        log.Fatalf(\"Failed to watch the application sources: %v\", err)\n\n    case <-delay:\n        // restart the daemon watcher.\n        self.watch()\n\n        err = self.install()\n        if !self.installed {\n            continue\n        }\n        gorun <- true\n    }\n}\n\n```\nI hope there'll be a better solution shipped with fsnotify, but this is by far the most stable one I've tested.\n. ",
    "mjibson": "@clipperhouse FYI I also can't repro this (with either versions posted here) on my mac.\n. @clipperhouse FYI I also can't repro this (with either versions posted here) on my mac.\n. ",
    "arianitu": "Ah! That makes sense.\n. Ah! That makes sense.\n. ",
    "CrazySherman": "any update on linux with this issue?. any update on linux with this issue?. ",
    "meatballhat": "sorry for delay!  try again? :smiley_cat:\n. @nathany :clap: :heart:\n. sorry for delay!  try again? :smiley_cat:\n. @nathany :clap: :heart:\n. ",
    "pbdeuchler": "go\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"gopkg.in/fsnotify.v1\"\n    \"log\"\n    \"os\"\n)\ngo-get'd just a couple hours before I made the issue\n. Oh man... Facepalming pretty hard over here. Thanks for the help guys!\n. go\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"gopkg.in/fsnotify.v1\"\n    \"log\"\n    \"os\"\n)\ngo-get'd just a couple hours before I made the issue\n. Oh man... Facepalming pretty hard over here. Thanks for the help guys!\n. ",
    "johto": "Ah, apparently I misread the FAQ.  I looked into the linked issue reports and the source of the problem isn't exactly clear.  Is the point that watcher.Add() might block indefinitely if nobody's reading from the Event/Error channels concurrently?\n. Ah, apparently I misread the FAQ.  I looked into the linked issue reports and the source of the problem isn't exactly clear.  Is the point that watcher.Add() might block indefinitely if nobody's reading from the Event/Error channels concurrently?\n. ",
    "rubenhazelaar": "I have a similar problem (Windows 8.1), running golang 1.5.2 and the latest go-fsnotify (from gopkg.in/fsnotify.v1). When I place a lot of files (200+) in my directory I get the following:\n2016/02/10 15:08:31 error: short read in readEvents()\n2016/02/10 15:08:35 error: short read in readEvents()\n2016/02/10 15:08:37 error: short read in readEvents()\n2016/02/10 15:08:40 error: short read in readEvents()\n2016/02/10 15:08:43 error: short read in readEvents()\n2016/02/10 15:08:46 error: short read in readEvents()\n2016/02/10 15:08:49 error: short read in readEvents()\n2016/02/10 15:08:51 error: short read in readEvents()\n2016/02/10 15:08:58 EOF\nWhen EOF is put out, the executable crashes. Could this be something like a buffer overflow?\n. I did some testing. The EOF was caused by a xml decoder I use, so solved that one.\nHowever the short read error remains. \nIn my setup I use ftp to upload a bunch of files. The problem also occurs when I just copy the files in the folder. When a \"WRITE\" event is fired (it fires three times btw, don't know if this is normal) I decode the content of each file and put that content in a db. So quite heavy work. Could this be interfering with fsnotify's ability to process all the new files? Or perhaps because it's a lot to process the os takes a different route which throws off fsnotify or the underlying API? Just speculating btw :)\n. Ok, had the opportunity to test on a Linux machine and had a weird difference:\nOn Windows the WRITE event is fired 3x, in Linux (ElementaryOS) 1x\nWhen a short read error occurs (on Windows) it seems to truncate the file it is reading (not necessarily always the case, seems to happen sometimes). This is also why my XML decoder errored with EOF. \nI just use a normal directory. To trigger the WRITE event I just copy the files to the watched folder. Hope it helps, if you need any other info please let me know.\nWhen I use FTP (on Windows) with a slow connection speed and I read the file on the first WRITE event, the file is not complete. This makes the XML decoder fail.\n. I have a similar problem (Windows 8.1), running golang 1.5.2 and the latest go-fsnotify (from gopkg.in/fsnotify.v1). When I place a lot of files (200+) in my directory I get the following:\n2016/02/10 15:08:31 error: short read in readEvents()\n2016/02/10 15:08:35 error: short read in readEvents()\n2016/02/10 15:08:37 error: short read in readEvents()\n2016/02/10 15:08:40 error: short read in readEvents()\n2016/02/10 15:08:43 error: short read in readEvents()\n2016/02/10 15:08:46 error: short read in readEvents()\n2016/02/10 15:08:49 error: short read in readEvents()\n2016/02/10 15:08:51 error: short read in readEvents()\n2016/02/10 15:08:58 EOF\nWhen EOF is put out, the executable crashes. Could this be something like a buffer overflow?\n. I did some testing. The EOF was caused by a xml decoder I use, so solved that one.\nHowever the short read error remains. \nIn my setup I use ftp to upload a bunch of files. The problem also occurs when I just copy the files in the folder. When a \"WRITE\" event is fired (it fires three times btw, don't know if this is normal) I decode the content of each file and put that content in a db. So quite heavy work. Could this be interfering with fsnotify's ability to process all the new files? Or perhaps because it's a lot to process the os takes a different route which throws off fsnotify or the underlying API? Just speculating btw :)\n. Ok, had the opportunity to test on a Linux machine and had a weird difference:\nOn Windows the WRITE event is fired 3x, in Linux (ElementaryOS) 1x\nWhen a short read error occurs (on Windows) it seems to truncate the file it is reading (not necessarily always the case, seems to happen sometimes). This is also why my XML decoder errored with EOF. \nI just use a normal directory. To trigger the WRITE event I just copy the files to the watched folder. Hope it helps, if you need any other info please let me know.\nWhen I use FTP (on Windows) with a slow connection speed and I read the file on the first WRITE event, the file is not complete. This makes the XML decoder fail.\n. ",
    "infogulch": "I feel like this would be much better if implemented on the Op type directly instead of on Event. I would say that it's similar to the os.FileMode type, that's just a bit field int but has methods IsDir and IsRegular to extract info from it without using bitwise arithmetic directly.\nAs a bonus, if the Event struct is changed to embed Op anonymously these new methods on Op would be promoted to Event without cluttering its' explicit type (or documentation). I don't see any downside to this. Because the current name of the struct field is the same as the type name it should be 100% backwards compatible and references to Event.Op will still work as expected. Like so:\ntype Event struct {\n    Name string // Relative path to the file or directory.\n    Op          // File operation that triggered the event.\n}\n. Perhaps add a Dir Op constant?\n. I feel like this would be much better if implemented on the Op type directly instead of on Event. I would say that it's similar to the os.FileMode type, that's just a bit field int but has methods IsDir and IsRegular to extract info from it without using bitwise arithmetic directly.\nAs a bonus, if the Event struct is changed to embed Op anonymously these new methods on Op would be promoted to Event without cluttering its' explicit type (or documentation). I don't see any downside to this. Because the current name of the struct field is the same as the type name it should be 100% backwards compatible and references to Event.Op will still work as expected. Like so:\ntype Event struct {\n    Name string // Relative path to the file or directory.\n    Op          // File operation that triggered the event.\n}\n. Perhaps add a Dir Op constant?\n. ",
    "matryer": "I like this - but why Has? Why not Is?\nIsCreate, IsWrite, etc. \nit also wouldn't stop switch code either. \n\nOn 20 Aug 2015, at 06:53, Joe notifications@github.com wrote:\nI feel like this would be much better if implemented on the Op type directly instead of on Event. I would say that it's similar to the os.FileMode type, that's just a bit field int but has methods IsDir and IsRegular to extract info from it without using bitwise arithmetic directly.\nAs a bonus, if the Event struct is changed to embed Op anonymously these new methods on Op would be promoted to Event without cluttering its' explicit type (or documentation). I don't see any downside to this. Because the current name of the struct field is the same as the type name it should be 100% backwards compatible and references to Event.Op will still work as expected. Like so:\ntype Event struct {\n    Name string // Relative path to the file or directory.\n    Op          // File operation that triggered the event.\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah. You'd almost do away with the bitmask consts in favour of the methods. \n\nBut, it's pretty nice as it is too.\n\nOn 20 Aug 2015, at 12:09, omeid notifications@github.com wrote:\n@matryer \nPerhaps because what is Write can't be Remove, but what has Write may have Remove too.\nBut overall, I agree with @nathany, I don't think any more methods should be added. \nThis library should stay as minimal as possible and only solve the problem of cross-platform portability, if you want fancy helpers, you can just write a wrapper around this library and use it.\n\u2014\nReply to this email directly or view it on GitHub.\n. It's more an academic discussion about package API design really. I agree that there's no need to change it now. \nOn 20 Aug 2015, at 12:30, omeid notifications@github.com wrote:\nIMHO, the problem with adding these methods is that you either have to unexport the Event.Op (breaking change, methods are more restricted than bitmask) or have overlapping API.\nNow overlapping APIs doesn't so bad until you consider that there are 8 backends, so where you need 8 tests, with this new methods you need at least 16, where a feature could have been inconsistent or broken in 8 places, now it can be at least 16.\nThis is unnecessary complexity that could be shifted into it's own package.\n\u2014\nReply to this email directly or view it on GitHub.\n. It's great for debugging. Shows you the op and path. \nOn 15 Aug 2015, at 21:47, techjanitor notifications@github.com wrote:\nI can, but, Event.String() doesn't make much sense to me period. Name is already a string, why not just let people format their own output .. ? I don't know what the intent of it is. It doesn't look like it's used internally.\n\u2014\nReply to this email directly or view it on GitHub.\n. I like this - but why Has? Why not Is?\n\nIsCreate, IsWrite, etc. \nit also wouldn't stop switch code either. \n\nOn 20 Aug 2015, at 06:53, Joe notifications@github.com wrote:\nI feel like this would be much better if implemented on the Op type directly instead of on Event. I would say that it's similar to the os.FileMode type, that's just a bit field int but has methods IsDir and IsRegular to extract info from it without using bitwise arithmetic directly.\nAs a bonus, if the Event struct is changed to embed Op anonymously these new methods on Op would be promoted to Event without cluttering its' explicit type (or documentation). I don't see any downside to this. Because the current name of the struct field is the same as the type name it should be 100% backwards compatible and references to Event.Op will still work as expected. Like so:\ntype Event struct {\n    Name string // Relative path to the file or directory.\n    Op          // File operation that triggered the event.\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah. You'd almost do away with the bitmask consts in favour of the methods. \n\nBut, it's pretty nice as it is too.\n\nOn 20 Aug 2015, at 12:09, omeid notifications@github.com wrote:\n@matryer \nPerhaps because what is Write can't be Remove, but what has Write may have Remove too.\nBut overall, I agree with @nathany, I don't think any more methods should be added. \nThis library should stay as minimal as possible and only solve the problem of cross-platform portability, if you want fancy helpers, you can just write a wrapper around this library and use it.\n\u2014\nReply to this email directly or view it on GitHub.\n. It's more an academic discussion about package API design really. I agree that there's no need to change it now. \nOn 20 Aug 2015, at 12:30, omeid notifications@github.com wrote:\nIMHO, the problem with adding these methods is that you either have to unexport the Event.Op (breaking change, methods are more restricted than bitmask) or have overlapping API.\nNow overlapping APIs doesn't so bad until you consider that there are 8 backends, so where you need 8 tests, with this new methods you need at least 16, where a feature could have been inconsistent or broken in 8 places, now it can be at least 16.\nThis is unnecessary complexity that could be shifted into it's own package.\n\u2014\nReply to this email directly or view it on GitHub.\n. It's great for debugging. Shows you the op and path. \nOn 15 Aug 2015, at 21:47, techjanitor notifications@github.com wrote:\nI can, but, Event.String() doesn't make much sense to me period. Name is already a string, why not just let people format their own output .. ? I don't know what the intent of it is. It doesn't look like it's used internally.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "amanankur": "Hi,\nAny update on this?\nThe same thing is happening for me too. Getting a remove signal when using rsync ,and then the file watching stops and no further events are generated\n. Hi,\nAny update on this?\nThe same thing is happening for me too. Getting a remove signal when using rsync ,and then the file watching stops and no further events are generated\n. ",
    "allencloud": "Thank @nathany  I think I have got your point.\n. Thank @nathany  I think I have got your point.\n. ",
    "wangjild": "the file I used by mv is a empty file.\nIt seems the system emit a \"Write\" event to the \"conf\" directory and then secondly send a \"remove\" event to the conf/test.yml file.\n. Sorry, I forgot to tell you.   there was a test.yml in the conf directory.\nI have readed the code,  it seems the kqueue returned a WRITE event to the \"conf\" firstly, and then a REMOVE event to the \"conf/test.yml\".\nThis is very strange. The same test code returned \"CREATE\" events in linux platform. This is just what I expected.\nWhen a file is overwrite by \"cp\" or \"mv\", CREATE events is more helpful than REMOVE, at lease I could use this event to reload the \"test.yml\". But if it returned REMOVE, I could not determine whether the \"test.yml\" is deleted by \"rm\" or overwrited by \"cp\" or \"mv\"\n. the file I used by mv is a empty file.\nIt seems the system emit a \"Write\" event to the \"conf\" directory and then secondly send a \"remove\" event to the conf/test.yml file.\n. Sorry, I forgot to tell you.   there was a test.yml in the conf directory.\nI have readed the code,  it seems the kqueue returned a WRITE event to the \"conf\" firstly, and then a REMOVE event to the \"conf/test.yml\".\nThis is very strange. The same test code returned \"CREATE\" events in linux platform. This is just what I expected.\nWhen a file is overwrite by \"cp\" or \"mv\", CREATE events is more helpful than REMOVE, at lease I could use this event to reload the \"test.yml\". But if it returned REMOVE, I could not determine whether the \"test.yml\" is deleted by \"rm\" or overwrited by \"cp\" or \"mv\"\n. ",
    "anthonyfok": "Hi @nathany,\nI think what you said earlier, i.e. \"When a REMOVE event happens, it stops watching that file\", hits the nail right on the head.\nI ran into the same problem, on Linux, while trying out Hugo v0.15's new \"dynamically reload config file\" feature.  While editors like GNU nano triggers the WRITE event, other editors like Vim and GNOME gedit first save the changes to a temporary file, then moving the tempfile to replace the original file, triggering a REMOVE event before a CREATE or WRITE event, but the CREATE or WRITE event was never detected because the watcher quits prematurely!\nPlease see spf13/viper#142 for more details.\nIf that is the case, I don't think this bug is \"OS X (kqueue)\"-specific.  Rather, if the \"When a REMOVE event happens, it stops watching that file\" behaviour is \"as-designed\", perhaps that design needs to be changed.\nMany thanks for looking into this.\n. +1  You're awesome, bep!  :-)\n. It turns out that all of the \"function not implemented\" (ENOSYS) errors from go test ./... originated from Line 85 in inotify_poller.go:\ngo\n    n, errno := syscall.EpollWait(poller.epfd, events, -1)\nIt turns out that epoll_wait is deprecated according to a slideshow by Linaro who ported Linux to ARM64, and therefore, only the newer epoll_pwait is provided on Linux/arm64.\nProblem is, Go has not yet implemented the corresponding EpollPwait, see the \"Unimplemented\" section of go/src/syscall/syscall_linux.go:948 and golang.org/x/sys/unix/syscall_linux.go:971.\nIt seems that the Go developers are aware of the issue, see golang/go#10235, though the milestone there changed from Go1.5 to Go1.6Early, and now Unplanned...  Hmm...\n. By the way, for completeness sake, syscall.InotifyInit() should probably be changed to syscall.InotifyInit1(0) too in inotify.go.  inotify_init is a \"system call without flags parameter\" according to this slide and /usr/include/asm-generic/unistd.h, so inotify_init is again not available on ARM64 though Go has a wrapper for it.  ;-)\nLast but not least, the following links were very helpful in teaching me to understand epoll_wait and epoll_pwait better:\n- Porting Applications to 64-bit ARM: http://people.linaro.org/~rikuvoipio/aarch64-talk/\n- libuv: linux: fix epoll_pwait() fallback on arm64: https://github.com/libuv/libuv/commit/1d8332f\n- Julia fails to build on arm64 due to missing __NR_epoll_wait: https://github.com/JuliaLang/julia/issues/14373\n- LWN: epoll_pwait for 2.6.18 ... (25 Sep 2006, Linux Kernel Mailing List): https://lwn.net/Articles/201084/\n. Thank you for such a wonderful plan of action that you have summarized.\nAbout adding EpollPwait to x/sys, I don't think I am currently up to the challenge due to a lack of experience in this area and a lack of time (will be very busy in the next week).  That said, if no one else has fixed it in a month or two, I would be interested to experiment with it and see if I could come up with a preliminary patch.  :-)\nYou have a good point there about InotifyInit1().  Since it would require a newer kernel (Linux 2.6.27?), and it is working fine for all architectures anyway, I think I've better leave it alone, as in \"if it ain't broke, don't fix it\".  :wink:\n. Related to #130.\nAnd looks like it has been fixed in golang.org/x/sys/unix, thanks to Riku Voipio (@suihkulokki) in commit https://github.com/golang/sys/commit/324e1375807370c3934e14f3a97e7d160832f6b4, and the upstream https://github.com/golang/go/issues/10235 has closed accordingly.\nIf it is okay with you, I would like to do some final testing, namely, to refresh relevant Go packages in Debian and make sure it is all working properly on arm64 test machine, before coming back and close this issue.  :-)\nMany thanks!\n. Fixed by Riku Voipio (golang/sys@324e137 and #135).\nfsnotify v1.3.0 works great on Linux/arm64 (aarch64).  :+1:\nThank you all!\n. Thank you for updating the patch so quickly, @suihkulokki!\nI am happy to report that your patch works wonder!  hugo server --watch quickly reports any changed files and re-render the website promptly, and no longer give \"function not implemented\" errors (spf13/hugo#1772).  Thank you for your great work, @suihkulokki!\nCc: @nathany\n. Hi @nathany,\nI think what you said earlier, i.e. \"When a REMOVE event happens, it stops watching that file\", hits the nail right on the head.\nI ran into the same problem, on Linux, while trying out Hugo v0.15's new \"dynamically reload config file\" feature.  While editors like GNU nano triggers the WRITE event, other editors like Vim and GNOME gedit first save the changes to a temporary file, then moving the tempfile to replace the original file, triggering a REMOVE event before a CREATE or WRITE event, but the CREATE or WRITE event was never detected because the watcher quits prematurely!\nPlease see spf13/viper#142 for more details.\nIf that is the case, I don't think this bug is \"OS X (kqueue)\"-specific.  Rather, if the \"When a REMOVE event happens, it stops watching that file\" behaviour is \"as-designed\", perhaps that design needs to be changed.\nMany thanks for looking into this.\n. +1  You're awesome, bep!  :-)\n. It turns out that all of the \"function not implemented\" (ENOSYS) errors from go test ./... originated from Line 85 in inotify_poller.go:\ngo\n    n, errno := syscall.EpollWait(poller.epfd, events, -1)\nIt turns out that epoll_wait is deprecated according to a slideshow by Linaro who ported Linux to ARM64, and therefore, only the newer epoll_pwait is provided on Linux/arm64.\nProblem is, Go has not yet implemented the corresponding EpollPwait, see the \"Unimplemented\" section of go/src/syscall/syscall_linux.go:948 and golang.org/x/sys/unix/syscall_linux.go:971.\nIt seems that the Go developers are aware of the issue, see golang/go#10235, though the milestone there changed from Go1.5 to Go1.6Early, and now Unplanned...  Hmm...\n. By the way, for completeness sake, syscall.InotifyInit() should probably be changed to syscall.InotifyInit1(0) too in inotify.go.  inotify_init is a \"system call without flags parameter\" according to this slide and /usr/include/asm-generic/unistd.h, so inotify_init is again not available on ARM64 though Go has a wrapper for it.  ;-)\nLast but not least, the following links were very helpful in teaching me to understand epoll_wait and epoll_pwait better:\n- Porting Applications to 64-bit ARM: http://people.linaro.org/~rikuvoipio/aarch64-talk/\n- libuv: linux: fix epoll_pwait() fallback on arm64: https://github.com/libuv/libuv/commit/1d8332f\n- Julia fails to build on arm64 due to missing __NR_epoll_wait: https://github.com/JuliaLang/julia/issues/14373\n- LWN: epoll_pwait for 2.6.18 ... (25 Sep 2006, Linux Kernel Mailing List): https://lwn.net/Articles/201084/\n. Thank you for such a wonderful plan of action that you have summarized.\nAbout adding EpollPwait to x/sys, I don't think I am currently up to the challenge due to a lack of experience in this area and a lack of time (will be very busy in the next week).  That said, if no one else has fixed it in a month or two, I would be interested to experiment with it and see if I could come up with a preliminary patch.  :-)\nYou have a good point there about InotifyInit1().  Since it would require a newer kernel (Linux 2.6.27?), and it is working fine for all architectures anyway, I think I've better leave it alone, as in \"if it ain't broke, don't fix it\".  :wink:\n. Related to #130.\nAnd looks like it has been fixed in golang.org/x/sys/unix, thanks to Riku Voipio (@suihkulokki) in commit https://github.com/golang/sys/commit/324e1375807370c3934e14f3a97e7d160832f6b4, and the upstream https://github.com/golang/go/issues/10235 has closed accordingly.\nIf it is okay with you, I would like to do some final testing, namely, to refresh relevant Go packages in Debian and make sure it is all working properly on arm64 test machine, before coming back and close this issue.  :-)\nMany thanks!\n. Fixed by Riku Voipio (golang/sys@324e137 and #135).\nfsnotify v1.3.0 works great on Linux/arm64 (aarch64).  :+1:\nThank you all!\n. Thank you for updating the patch so quickly, @suihkulokki!\nI am happy to report that your patch works wonder!  hugo server --watch quickly reports any changed files and re-render the website promptly, and no longer give \"function not implemented\" errors (spf13/hugo#1772).  Thank you for your great work, @suihkulokki!\nCc: @nathany\n. ",
    "guotie": "the dir tree is following:\nd\n--- a\n--- b\nwhere d and a is dir, I watch d, and when i rename a to aa, I got event CREATE aa\n. OSX 10.10\n. just use mv to rename the directory\n. I have create a pull request to fix it.\n. the dir tree is following:\nd\n--- a\n--- b\nwhere d and a is dir, I watch d, and when i rename a to aa, I got event CREATE aa\n. OSX 10.10\n. just use mv to rename the directory\n. I have create a pull request to fix it.\n. ",
    "techjanitor": "I can, but, Event.String() doesn't make much sense to me period. Name is already a string, why not just let people format their own output .. ? I don't know what the intent of it is. It doesn't look like it's used internally. \n. I can, but, Event.String() doesn't make much sense to me period. Name is already a string, why not just let people format their own output .. ? I don't know what the intent of it is. It doesn't look like it's used internally. \n. ",
    "pquerna": "I was having similar issues on OSX, and PR #124 fixed them for me.\n. I was also seeing Close() hangs as described in #89 -- at $job we are now carrying this patch on our vendor'ed copy of fsnotify, would love to see it merged.\n. I was having similar issues on OSX, and PR #124 fixed them for me.\n. I was also seeing Close() hangs as described in #89 -- at $job we are now carrying this patch on our vendor'ed copy of fsnotify, would love to see it merged.\n. ",
    "manatok": "Yeah this will only work on Linux. Having a Closed event that doesn't mean anything outside of Linux is probably not the best idea... I just needed it for something I was working on so added it in :)\n. Yeah this will only work on Linux. Having a Closed event that doesn't mean anything outside of Linux is probably not the best idea... I just needed it for something I was working on so added it in :)\n. ",
    "dradtke": "It should be noted that this is with Go 1.5, installed using gvm on Ubuntu, and from the Go development repo on openSUSE.\n. That's interesting, but I'm not renaming the file at any point, and it's strange that it works as expected on one flavor of Linux but not another.\nIf I get some time I may dig in to this and see if I can isolate what difference between the two distros is causing this discrepancy.\n. Looks like it's definitely an issue with whatever version of inotify Ubuntu is running. Running this program on openSUSE, then making a change to hello.txt correctly includes the IN_MODIFY event in the output. However, the same thing on Ubuntu reports:\nIN_MOVE_SELF\nIN_ATTRIB\nIN_DELETE_SELF\nBaffling.\n. :w in Vim, though I've seen the same issue using Sublime. \n. Does the same thing with swap and backup disabled.\n. I opened a bug report in Ubuntu's bug tracker, so hopefully they'll have some reason for the behavior soon. https://bugs.launchpad.net/ubuntu/+bug/1493413\n. It should be noted that this is with Go 1.5, installed using gvm on Ubuntu, and from the Go development repo on openSUSE.\n. That's interesting, but I'm not renaming the file at any point, and it's strange that it works as expected on one flavor of Linux but not another.\nIf I get some time I may dig in to this and see if I can isolate what difference between the two distros is causing this discrepancy.\n. Looks like it's definitely an issue with whatever version of inotify Ubuntu is running. Running this program on openSUSE, then making a change to hello.txt correctly includes the IN_MODIFY event in the output. However, the same thing on Ubuntu reports:\nIN_MOVE_SELF\nIN_ATTRIB\nIN_DELETE_SELF\nBaffling.\n. :w in Vim, though I've seen the same issue using Sublime. \n. Does the same thing with swap and backup disabled.\n. I opened a bug report in Ubuntu's bug tracker, so hopefully they'll have some reason for the behavior soon. https://bugs.launchpad.net/ubuntu/+bug/1493413\n. ",
    "alexeyknyshev": "Same on here!\nTrying to make background reloader for lua scripts of my server and get this one:\n\n2016/01/08 14:28:47.043753 fsnotify event: \"redis_scripts/clusterdata.lua\": CHMOD\n2016/01/08 14:28:47.043787 fsnotify event: \"redis_scripts/clusterdata.lua\": REMOVE\n. Have found a work around for with:\nJust readd event.Name to watched if received REMOVE event\n. Same on here!\nTrying to make background reloader for lua scripts of my server and get this one:\n2016/01/08 14:28:47.043753 fsnotify event: \"redis_scripts/clusterdata.lua\": CHMOD\n2016/01/08 14:28:47.043787 fsnotify event: \"redis_scripts/clusterdata.lua\": REMOVE\n. Have found a work around for with:\nJust readd event.Name to watched if received REMOVE event\n. \n",
    "wangzhuzhen": "Same on CentOS 7\uff1a\nI1013 23:15:14.649953   9265 server.go:340] Catched file: \"/etc/sysconfig/docker\": CHMOD\nI1013 23:15:14.650019    9265 server.go:340] Catched file: \"/etc/sysconfig/docker\": REMOVE\nI1013 23:15:55.602021    9265 server.go:303] Watching file: /etc/sysconfig/docker\n. Same on CentOS 7\uff1a\nI1013 23:15:14.649953   9265 server.go:340] Catched file: \"/etc/sysconfig/docker\": CHMOD\nI1013 23:15:14.650019    9265 server.go:340] Catched file: \"/etc/sysconfig/docker\": REMOVE\nI1013 23:15:55.602021    9265 server.go:303] Watching file: /etc/sysconfig/docker\n. ",
    "sourcemonk": "I'm having the same issue with Ubuntu 16.04.1 LTS\n```\nmonk at BorgCube in ~\n$ lsb_release -a\nNo LSB modules are available.\nDistributor ID: Ubuntu\nDescription:    Ubuntu 16.04.1 LTS\nRelease:        16.04\nCodename:       xenial\nmonk at BorgCube in ~\n$ uname -a\nLinux BorgCube 4.4.0-47-generic #68-Ubuntu SMP Wed Oct 26 19:39:52 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux\n```\nI don't have a problem if I write to the file using shell redirection.\nMoreover, using vim, if I set the following: \nset nobackup\nset nowritebackup\nI have no issues.\nIt would seem this issue is due to the backup scheme of the editor (at least in the case of vim), where it \n\nwrites the buffer to a new file\ndeletes the original file\nrenames the new file. I'm having the same issue with Ubuntu 16.04.1 LTS\n\n```\nmonk at BorgCube in ~\n$ lsb_release -a\nNo LSB modules are available.\nDistributor ID: Ubuntu\nDescription:    Ubuntu 16.04.1 LTS\nRelease:        16.04\nCodename:       xenial\nmonk at BorgCube in ~\n$ uname -a\nLinux BorgCube 4.4.0-47-generic #68-Ubuntu SMP Wed Oct 26 19:39:52 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux\n```\nI don't have a problem if I write to the file using shell redirection.\nMoreover, using vim, if I set the following: \nset nobackup\nset nowritebackup\nI have no issues.\nIt would seem this issue is due to the backup scheme of the editor (at least in the case of vim), where it \n\nwrites the buffer to a new file\ndeletes the original file\nrenames the new file. \n",
    "kkirsche": "I'm experiencing similar behavior to this:\nEDIT: well...removing that token...\n~/g/g/s/g/k/notify-git \u276f\u276f\u276f notify-git -v -p value\nDEBU[0000] Git repository path: /Users/user/git/test\nDEBU[0000] File to be monitored: rr1.txt\nDEBU[0000] Waiting in goroutine...\nDEBU[0005] Event received.                               event=\"/Users/user/git/test/rr1.txt\": RENAME\nDEBU[0005] Message sent to action\nI'd expect the goroutine to receive a second event:\ngo func(commitNeeded chan time.Time) {\n        for {\n            logrus.Debugln(\"Waiting in goroutine...\")\n            select {\n            case event := <-watcher.Events:\n                logrus.WithField(\"event\", event).Debugln(\"Event received.\")\n                changedTime := time.Now()\n                commitNeeded <- changedTime\n                logrus.Debugln(\"Message sent\")\n            case caseErr := <-watcher.Errors:\n                logrus.WithError(caseErr).Errorln(\"Received error from file watcher.\")\n            }\n        }\n    }(commitNeeded)\n. @nathany \nOS: OS X El Capitan\nMoving / Renaming seems to be the only type of event I can get to trigger. Vim triggers it, textedit triggers it. Is there anyway to actually hook into more \"normal\" use cases to watch the file? \n. Hm, apparently it was cause I was triggering off of any event rather than just watches. I got it fixed with the example_test.go code, but it wasn't clear.\n. For me, the biggest issue was that I'm running this as a longer running daemon, so cleanup was something that was a problem. It seemed as though I was leaving the watcher active (gocode process on OS X) which needed to have the following:\nc := make(chan os.Signal, 1)\nsignal.Notify(c, os.Interrupt)\ngo func() {\n    for _ = range c {\n        fmt.Println(\"\")\n        logrus.Infoln(\"Cleaning up...\")\n        doneWatch <- true\n        done <- true\n    }\n}()\nThis then sent the messages to close the watcher and close any open channels. Once I added that, I didn't run into any more gocode running after ctrl+c ended the application running.\nThe second thing for me which was unclear from the example was what the purpose of the done channel was since it was a bit too simplistic for me to really be able to use as a template to really base my code on. I made a more generic version to show what I was using the watch event for if it helps understand the situation.\nhttps://github.com/kkirsche/notify-git/blob/master/cmd/root.go\nLastly, I had to exit the goroutine on the above done event, or else the watcher would catch a ton (near infinite it seemed)  errors / \"\" events. For this reason I'd have the done channel also exit the background goroutine in case they do any debug messaging to avoid flooding stdout. \nI guess my takeaways were that it would be nice to include cleanup code in the example, and provide a more \"complete\" implementation that leverages the done channel.\nPotentially it'd also be helpful to have a wiki page of known programs that don't trigger write events to avoid the \"hm, why doesn't vim editing the file work?\"\nDoes that help?\n. I'm experiencing similar behavior to this:\nEDIT: well...removing that token...\n~/g/g/s/g/k/notify-git \u276f\u276f\u276f notify-git -v -p value\nDEBU[0000] Git repository path: /Users/user/git/test\nDEBU[0000] File to be monitored: rr1.txt\nDEBU[0000] Waiting in goroutine...\nDEBU[0005] Event received.                               event=\"/Users/user/git/test/rr1.txt\": RENAME\nDEBU[0005] Message sent to action\nI'd expect the goroutine to receive a second event:\ngo func(commitNeeded chan time.Time) {\n        for {\n            logrus.Debugln(\"Waiting in goroutine...\")\n            select {\n            case event := <-watcher.Events:\n                logrus.WithField(\"event\", event).Debugln(\"Event received.\")\n                changedTime := time.Now()\n                commitNeeded <- changedTime\n                logrus.Debugln(\"Message sent\")\n            case caseErr := <-watcher.Errors:\n                logrus.WithError(caseErr).Errorln(\"Received error from file watcher.\")\n            }\n        }\n    }(commitNeeded)\n. @nathany \nOS: OS X El Capitan\nMoving / Renaming seems to be the only type of event I can get to trigger. Vim triggers it, textedit triggers it. Is there anyway to actually hook into more \"normal\" use cases to watch the file? \n. Hm, apparently it was cause I was triggering off of any event rather than just watches. I got it fixed with the example_test.go code, but it wasn't clear.\n. For me, the biggest issue was that I'm running this as a longer running daemon, so cleanup was something that was a problem. It seemed as though I was leaving the watcher active (gocode process on OS X) which needed to have the following:\nc := make(chan os.Signal, 1)\nsignal.Notify(c, os.Interrupt)\ngo func() {\n    for _ = range c {\n        fmt.Println(\"\")\n        logrus.Infoln(\"Cleaning up...\")\n        doneWatch <- true\n        done <- true\n    }\n}()\nThis then sent the messages to close the watcher and close any open channels. Once I added that, I didn't run into any more gocode running after ctrl+c ended the application running.\nThe second thing for me which was unclear from the example was what the purpose of the done channel was since it was a bit too simplistic for me to really be able to use as a template to really base my code on. I made a more generic version to show what I was using the watch event for if it helps understand the situation.\nhttps://github.com/kkirsche/notify-git/blob/master/cmd/root.go\nLastly, I had to exit the goroutine on the above done event, or else the watcher would catch a ton (near infinite it seemed)  errors / \"\" events. For this reason I'd have the done channel also exit the background goroutine in case they do any debug messaging to avoid flooding stdout. \nI guess my takeaways were that it would be nice to include cleanup code in the example, and provide a more \"complete\" implementation that leverages the done channel.\nPotentially it'd also be helpful to have a wiki page of known programs that don't trigger write events to avoid the \"hm, why doesn't vim editing the file work?\"\nDoes that help?\n. ",
    "tscott0": "\nPotentially it'd also be helpful to have a wiki page of known programs that don't trigger write events to avoid the \"hm, why doesn't vim editing the file work?\"\n\n@nathany, I was also using vim to test and it wasn't working. I would instead see RENAME, CHMOD, REMOVE events. It would be great to perhaps have a list of known applications that perhaps don't interract with fsnotify as you might expect, this could become a FAQ page or similar.\nExamples of how you might trigger specific events might be useful. While these may seem obvious and would be platform-specific, it would be great to show what happens when you chmod, touch, append and delete (rm) a file from the command line.\n. > Potentially it'd also be helpful to have a wiki page of known programs that don't trigger write events to avoid the \"hm, why doesn't vim editing the file work?\"\n@nathany, I was also using vim to test and it wasn't working. I would instead see RENAME, CHMOD, REMOVE events. It would be great to perhaps have a list of known applications that perhaps don't interract with fsnotify as you might expect, this could become a FAQ page or similar.\nExamples of how you might trigger specific events might be useful. While these may seem obvious and would be platform-specific, it would be great to show what happens when you chmod, touch, append and delete (rm) a file from the command line.\n. ",
    "illicitonion": "Bleh markdown formatting\nRepro at https://gist.github.com/illicitonion/b0d0af8a720667c80f00\n. Fixed in 1.2.5\n. Fixes https://github.com/go-fsnotify/fsnotify/issues/96\n. I'm not sure why that second commit made the linux CI fail; none of the tests failed, and running the tests on a Linux machine I have they all pass and exit 0 :S\n. Bleh markdown formatting\nRepro at https://gist.github.com/illicitonion/b0d0af8a720667c80f00\n. Fixed in 1.2.5\n. Fixes https://github.com/go-fsnotify/fsnotify/issues/96\n. I'm not sure why that second commit made the linux CI fail; none of the tests failed, and running the tests on a Linux machine I have they all pass and exit 0 :S\n. ",
    "gaillard": "Seems like this is the case by looking at the code, but my simple attempts at getting it to overflow have turned up bupkis \n. I am talking about the inotify overflow event. IN_Q_OVERFLOW\n. As far as I know in order to correctly program against inotify, one must scan after receiving an overflow, which comes out of this library as just the default zero value, just needs to be documented then that any non supported events are caught in the zero value.\nIn the same line for people to develop with correctness, supporting IN_ONLYDIR in some way is the only way I know to avoid a race condition between a stat and then an add watch for a dir (since that path could become just a file inbetween).\n. I have been trying to force the overflow but still can't seem to. So inotify is documented to give out a wd of -1 on overflow. Not sure what this would do in this package.\n. Ok I found this issue in this package. At https://github.com/go-fsnotify/fsnotify/blob/master/inotify.go#L280 because the e.Name will not be filled, the Lstat() returns an error that os.IsNotExist() returns true for and the event is skipped.\nSince the overflow event is critical it needs to get into the user code. If nothing else (see below), I vote that a special check if mask&syscall.IN_Q_OVERFLOW == syscall.IN_Q_OVERFLOW { return false } is put in at the top of the method. This will end up as the default value of Event that comes across the user channel.\nActually changing the if !(e.Op&Remove == Remove || e.Op&Rename == Rename) { } to a white list instead of a negative would have avoid this issue in the first place. Overflow is not the only special event that could come through. \nI am very dubious about ignoring any of these events. That method says in a comment that it is there because it saw a write come through after a delete event, how could that happen?\n. Seems like this is the case by looking at the code, but my simple attempts at getting it to overflow have turned up bupkis \n. I am talking about the inotify overflow event. IN_Q_OVERFLOW\n. As far as I know in order to correctly program against inotify, one must scan after receiving an overflow, which comes out of this library as just the default zero value, just needs to be documented then that any non supported events are caught in the zero value.\nIn the same line for people to develop with correctness, supporting IN_ONLYDIR in some way is the only way I know to avoid a race condition between a stat and then an add watch for a dir (since that path could become just a file inbetween).\n. I have been trying to force the overflow but still can't seem to. So inotify is documented to give out a wd of -1 on overflow. Not sure what this would do in this package.\n. Ok I found this issue in this package. At https://github.com/go-fsnotify/fsnotify/blob/master/inotify.go#L280 because the e.Name will not be filled, the Lstat() returns an error that os.IsNotExist() returns true for and the event is skipped.\nSince the overflow event is critical it needs to get into the user code. If nothing else (see below), I vote that a special check if mask&syscall.IN_Q_OVERFLOW == syscall.IN_Q_OVERFLOW { return false } is put in at the top of the method. This will end up as the default value of Event that comes across the user channel.\nActually changing the if !(e.Op&Remove == Remove || e.Op&Rename == Rename) { } to a white list instead of a negative would have avoid this issue in the first place. Overflow is not the only special event that could come through. \nI am very dubious about ignoring any of these events. That method says in a comment that it is there because it saw a write come through after a delete event, how could that happen?\n. ",
    "evanphx": "@nathany Any chance this could be cherry-picked into v1?\n. Thank you!\nOn Wed, Oct 14, 2015 at 4:44 PM, Nathan Youngman notifications@github.com\nwrote:\n\nYup. v1.2.1 released with this change.\nhttps://gopkg.in/fsnotify.v1\nReply to this email directly or view it on GitHub:\nhttps://github.com/go-fsnotify/fsnotify/pull/98#issuecomment-148234310\n. I'm in favor, obviously. :grin: \n. @nathany Any chance this could be cherry-picked into v1?\n. Thank you!\n\nOn Wed, Oct 14, 2015 at 4:44 PM, Nathan Youngman notifications@github.com\nwrote:\n\nYup. v1.2.1 released with this change.\nhttps://gopkg.in/fsnotify.v1\nReply to this email directly or view it on GitHub:\nhttps://github.com/go-fsnotify/fsnotify/pull/98#issuecomment-148234310\n. I'm in favor, obviously. :grin: \n. \n",
    "djui": "OS X 10.11. Will try to shrink down the code into an example. I believe the problem is at https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L75-L80: Locking and assigning w.watches to ws does not lock w.watches while iterating over ws in the for loop.\n. Sorry, no. I lost focus on other things.\n. OS X 10.11. Will try to shrink down the code into an example. I believe the problem is at https://github.com/go-fsnotify/fsnotify/blob/master/kqueue.go#L75-L80: Locking and assigning w.watches to ws does not lock w.watches while iterating over ws in the for loop.\n. Sorry, no. I lost focus on other things.\n. ",
    "suihkulokki": "2.6.27 was released already in 2008 -  2.6.32 is generally the last relevant kernel to support (it's the kernel RHEL6 from 2010 has).\n. Hi, is there something needed from my side for this patch? \n. Indeed looks like wrapping epoll_wait to epoll_pwait is needed for arm64. just adding epoll_create1 wasn't enough. I think in go users shouldn't mess with signals, we should only ever pass sigmask of Null to epoll_pwait, which is then identical to epoll_wait. I'll study a bit and propose fix(es). \n. I've submitted a proposed fix for the arm64 side to:\nhttps://go-review.googlesource.com/#/c/21971/ \n@TheTincho how do I test the prometheus error? \n. Sorry @laboger, I didn't notice ppc was fixed in syscall instead of x/sys. I ended up patching x/sys since some earlier syscall changes I had proposed were rejected and I was told to update x/sys instead. \n. According to git log on syscall, the following changes there are missing from x/sys:\n- s390x support\n- the epollevent struct fix for ppc64x already mentioned.\n. Hi, I don't know why the darwin case failed on travis. It appears syscall and x/sys are quite identical in this front. \n. Updated patch with the comment fixes, one noticed by @anthonyfok thanks. There was another spurious syscall -> unix change + one comment line had become unaligned afterwards.\n. I seem to pass the test more reliably with:\ndiff --git a/inotify_test.go b/inotify_test.go\nindex 2527cad..227ac30 100644\n--- a/inotify_test.go\n+++ b/inotify_test.go\n@@ -217,7 +217,7 @@ func TestInotifyStress(t testing.T) {\n                                        t.Fatalf(\"Create failed: %v\", err)\n                                }\n                                handle.Close()\n-                               time.Sleep(time.Millisecond)\n-                               time.Sleep(2time.Millisecond)\n                              err = os.Remove(testFile)\n                              if err != nil {\n                                      t.Fatalf(\"Remove failed: %v\", err)\nThat works on my machine, but I still get goroutine panic on asachi.debian.org (possibly a differrent, go issue)\n. @TheTincho  Repasted:\ndiff --git a/inotify_test.go b/inotify_test.go\nindex 2527cad..227ac30 100644\n--- a/inotify_test.go\n+++ b/inotify_test.go\n@@ -217,7 +217,7 @@ func TestInotifyStress(t *testing.T) {\n                                        t.Fatalf(\"Create failed: %v\", err)\n                                }\n                                handle.Close()\n-                               time.Sleep(time.Millisecond)\n+                               time.Sleep(2*time.Millisecond)\n                                err = os.Remove(testFile)\n                                if err != nil {\n                                        t.Fatalf(\"Remove failed: %v\", err)\n. I've tested and didn't get a race so far. @TheTincho I think it should be safe to re-enable the test in debian again. Thanks @pattyshack for the fix!\n. \"sed -i foo\" is a bit misleading, it doesn't really edit the file in-place - it outputs the file to a temporary file and renames:\nopen(\"foo\", O_RDONLY)\nopen(\"./sedkYoTpL\", O_RDWR|O_CREAT)\nrename(\"./sedkYoTpL\", \"foo\")\nSo the original file inotify is watching no longer exists and the new file isn't monitored. I think you need to watch the directory if you want to catch changes like this.\n. At the moment fsnotify requirement is 2.6.27+ so Redhat 5.6 has probably something older? This PR will break arm64, unless an EpollCreate -> EpollCreate1 wrapper to x/sys is added, since arm64 doesn't have the legacy syscall.\n. 2.6.27 was released already in 2008 -  2.6.32 is generally the last relevant kernel to support (it's the kernel RHEL6 from 2010 has).\n. Hi, is there something needed from my side for this patch? \n. Indeed looks like wrapping epoll_wait to epoll_pwait is needed for arm64. just adding epoll_create1 wasn't enough. I think in go users shouldn't mess with signals, we should only ever pass sigmask of Null to epoll_pwait, which is then identical to epoll_wait. I'll study a bit and propose fix(es). \n. I've submitted a proposed fix for the arm64 side to:\nhttps://go-review.googlesource.com/#/c/21971/ \n@TheTincho how do I test the prometheus error? \n. Sorry @laboger, I didn't notice ppc was fixed in syscall instead of x/sys. I ended up patching x/sys since some earlier syscall changes I had proposed were rejected and I was told to update x/sys instead. \n. According to git log on syscall, the following changes there are missing from x/sys:\n- s390x support\n- the epollevent struct fix for ppc64x already mentioned.\n. Hi, I don't know why the darwin case failed on travis. It appears syscall and x/sys are quite identical in this front. \n. Updated patch with the comment fixes, one noticed by @anthonyfok thanks. There was another spurious syscall -> unix change + one comment line had become unaligned afterwards.\n. I seem to pass the test more reliably with:\ndiff --git a/inotify_test.go b/inotify_test.go\nindex 2527cad..227ac30 100644\n--- a/inotify_test.go\n+++ b/inotify_test.go\n@@ -217,7 +217,7 @@ func TestInotifyStress(t testing.T) {\n                                        t.Fatalf(\"Create failed: %v\", err)\n                                }\n                                handle.Close()\n-                               time.Sleep(time.Millisecond)\n-                               time.Sleep(2time.Millisecond)\n                              err = os.Remove(testFile)\n                              if err != nil {\n                                      t.Fatalf(\"Remove failed: %v\", err)\nThat works on my machine, but I still get goroutine panic on asachi.debian.org (possibly a differrent, go issue)\n. @TheTincho  Repasted:\ndiff --git a/inotify_test.go b/inotify_test.go\nindex 2527cad..227ac30 100644\n--- a/inotify_test.go\n+++ b/inotify_test.go\n@@ -217,7 +217,7 @@ func TestInotifyStress(t *testing.T) {\n                                        t.Fatalf(\"Create failed: %v\", err)\n                                }\n                                handle.Close()\n-                               time.Sleep(time.Millisecond)\n+                               time.Sleep(2*time.Millisecond)\n                                err = os.Remove(testFile)\n                                if err != nil {\n                                        t.Fatalf(\"Remove failed: %v\", err)\n. I've tested and didn't get a race so far. @TheTincho I think it should be safe to re-enable the test in debian again. Thanks @pattyshack for the fix!\n. \"sed -i foo\" is a bit misleading, it doesn't really edit the file in-place - it outputs the file to a temporary file and renames:\nopen(\"foo\", O_RDONLY)\nopen(\"./sedkYoTpL\", O_RDWR|O_CREAT)\nrename(\"./sedkYoTpL\", \"foo\")\nSo the original file inotify is watching no longer exists and the new file isn't monitored. I think you need to watch the directory if you want to catch changes like this.\n. At the moment fsnotify requirement is 2.6.27+ so Redhat 5.6 has probably something older? This PR will break arm64, unless an EpollCreate -> EpollCreate1 wrapper to x/sys is added, since arm64 doesn't have the legacy syscall.\n. ",
    "zevdg": "This would also make it easier for clients of this library to inject a mock FileWatcher into their unit tests\n. This would also make it easier for clients of this library to inject a mock FileWatcher into their unit tests\n. ",
    "tiwaana": "I recently put a docker based on ubuntu 16.04 with go and git support. If you give me some info, I will give it a try.\n. Amir, which kernel version you would like to target ? . I would love to work on this \n. Yes, I like the idea of including fanotify, but to get things going, I want to resist it. Couple of people in our Go meetup (DTC - Denver) have interest in working on it. I will be doing a presentation on inotify subsystem in our next meetup to bring people up to speed and see how far we can go as a group. . its after that, this one is more so for 1.8 release. All 3 meetups are coming together boulder, denver and DTC and doing a combined one. . I like the idea but I am not sure how closely linux and windows interfaces are ? \n. since its a library, I will prefer both event should be delivered to clients. This will keep policies out of this layer.. We in DTC golang meetup reviewed the code, not all it. But we have few questions\na) is using C required\nb) In close() things are not mutex protected. \nits only limited to Solaris, so should not break other things.\nAnand. I recently put a docker based on ubuntu 16.04 with go and git support. If you give me some info, I will give it a try.\n. Amir, which kernel version you would like to target ? . I would love to work on this \n. Yes, I like the idea of including fanotify, but to get things going, I want to resist it. Couple of people in our Go meetup (DTC - Denver) have interest in working on it. I will be doing a presentation on inotify subsystem in our next meetup to bring people up to speed and see how far we can go as a group. . its after that, this one is more so for 1.8 release. All 3 meetups are coming together boulder, denver and DTC and doing a combined one. . I like the idea but I am not sure how closely linux and windows interfaces are ? \n. since its a library, I will prefer both event should be delivered to clients. This will keep policies out of this layer.. We in DTC golang meetup reviewed the code, not all it. But we have few questions\na) is using C required\nb) In close() things are not mutex protected. \nits only limited to Solaris, so should not break other things.\nAnand. ",
    "bep": "Note: I will add a test case for this shortly.\n. I have added a test case (and tested on FreeBSD) + signed the Google Individual Contributor License Agreement.\n. There are an obvious issue with one part of this commit (checking for new files when the watched entry is a file and not a directory) -- I will check if I can fix it, or revert that part.\n. OK - now it works fine.\nI have tested this OK on both of the trouble-cases in Hugo (config reloading (file based) and content watching (dir based)).\n. On an added note:\nI have fiddled a little with this on the Linux side of it as well, today, and on Linux the only way to track changes from Vim (and similar) is to watch an entire folder, then pick the file and event type you are interested in (it will eventually be a CREATE). This is how inotify works, and I don't think fsnotify should \"write some custom code\" to get around it.\nBut with this PR, this means that BSD != Linux in the single file case, and that is maybe worth a thought. Should it? \nIf they should work the same, this patch (excluding test) will be reduced to the err == nil conditional..\n. Merged in ad13874\n. I  did some related OSX fixes some time ago, and did some tests on Linux (on Hugo) as well, and it now behaves \"better\" (at least differently) on OSX.\nThe reliable cross-platform way regarding atomic saves is to watch directories and not individual files and then just throw away the events you don't care about.\n. OK, it is established that this is a faulty test.\n. > If I watch \"c:\\\", the event name will be \"c:\\something\" instead of \"c:\\something\".\nWhat is the difference between the two?\n. >Would switching paths from relative to absolute be a breaking a change for some users?\nYes, it would be a breaking change (one example would be Hugo). I do agree, though, that absolute paths would be a cleaner solution (and I'm willing to fix Hugo and relatives if you switch), but I also suspect there are other cross-platform gotchas in here somewhere.\n. I think I blamed the wrong project. Will close this an investigate in the original bug.\n. > it looks like there is a data race to fix\nhttps://github.com/fsnotify/fsnotify/issues/150\n. What is this issue about?\n.  @4ad @amitkris @nathany This would be really good for Hugo to get in. @fazalmajid has a valid point about the this cannot break it worse than it already is and the breakage is limited to Solaris. I have quickly browsed through the code and cannot find any obvious mistakes.. Cannot what?. I think you will find that this is a limitation in the file change notification systems on the different OSs, and the events created also depends on the editor used; in Hugo we handle this by throwing away events we don't care about, including duplicate WRITE. . Note: I will add a test case for this shortly.\n. I have added a test case (and tested on FreeBSD) + signed the Google Individual Contributor License Agreement.\n. There are an obvious issue with one part of this commit (checking for new files when the watched entry is a file and not a directory) -- I will check if I can fix it, or revert that part.\n. OK - now it works fine.\nI have tested this OK on both of the trouble-cases in Hugo (config reloading (file based) and content watching (dir based)).\n. On an added note:\nI have fiddled a little with this on the Linux side of it as well, today, and on Linux the only way to track changes from Vim (and similar) is to watch an entire folder, then pick the file and event type you are interested in (it will eventually be a CREATE). This is how inotify works, and I don't think fsnotify should \"write some custom code\" to get around it.\nBut with this PR, this means that BSD != Linux in the single file case, and that is maybe worth a thought. Should it? \nIf they should work the same, this patch (excluding test) will be reduced to the err == nil conditional..\n. Merged in ad13874\n. I  did some related OSX fixes some time ago, and did some tests on Linux (on Hugo) as well, and it now behaves \"better\" (at least differently) on OSX.\nThe reliable cross-platform way regarding atomic saves is to watch directories and not individual files and then just throw away the events you don't care about.\n. OK, it is established that this is a faulty test.\n. > If I watch \"c:\\\", the event name will be \"c:\\something\" instead of \"c:\\something\".\nWhat is the difference between the two?\n. >Would switching paths from relative to absolute be a breaking a change for some users?\nYes, it would be a breaking change (one example would be Hugo). I do agree, though, that absolute paths would be a cleaner solution (and I'm willing to fix Hugo and relatives if you switch), but I also suspect there are other cross-platform gotchas in here somewhere.\n. I think I blamed the wrong project. Will close this an investigate in the original bug.\n. > it looks like there is a data race to fix\nhttps://github.com/fsnotify/fsnotify/issues/150\n. What is this issue about?\n.  @4ad @amitkris @nathany This would be really good for Hugo to get in. @fazalmajid has a valid point about the this cannot break it worse than it already is and the breakage is limited to Solaris. I have quickly browsed through the code and cannot find any obvious mistakes.. Cannot what?. I think you will find that this is a limitation in the file change notification systems on the different OSs, and the events created also depends on the editor used; in Hugo we handle this by throwing away events we don't care about, including duplicate WRITE. . ",
    "renatovargas": "Awesome, great work!!\n. Awesome, great work!!\n. ",
    "amir73il": "Well the patches are out there already in my github (applied to kernel 4.9), but for those of you hoping for this functionality to get upstream, I suggest to be patient.\nI have no doubt it is going to be some time before this feature can be\nmerged to an official kernel.\nMy bet is that I will have to maintain it out of tree for a while, and only\nafter real users show genuine interest in the feature, it will be seriously\nconsidered for upstream.\nThis is were you guys can be of help.\nSo far I had only one guy rooting for my patches on LKML\nand he has also tested them on his system.\nWhen promoting a feature for upstream it is important to bring solid use cases that require the feature and argue that the same cannot be achieved by user library code and existing kernel functionality.\nHowever, if you can't test my work on a distro kernel then it is going to be harder to claim that it is beneficial for your use cases.\nTo solve this chicken and egg problem I plan to provide install-able\nkernel modules for commonly used Linux distros, so using fanotify super block\nshould be as easy as e.g.: apt-get install fsntotify-tools.\nI cannot guaranty when I will get to providing this level of installation though, so if there are any of you out there not afraid of building a custom kernel, I will gladly assist you if you want to test my patches.\nCheers.. Yes, that could work. And I promise to assist the person who volunteers to work on this setup.. @tiwaana question is moot. I would like to target the earliest kernel version possible, but since this is not a bug fix nor a trivial improvement, some things have to happen first not all of them depend on me, not necessarily in that order:\n1. Technical review of patches (I am working on getting that)\n2. Design review of patched (ditto)\n3. Review of the proposed kernel-user API\n4. Demonstrate a cut and clear benefit to Linux users community\n5. Demonstrate no performance regressions for users not using the feature. @purpleidea thanks for the ping. If your company will show interest in the super block watch, that can be a game changer. wrt your recursive watcher, I am new to golang and have zero knowledge about fsnotify library, but it appears your code is not calling addSubFolders() recursively from Init() more than 1 level of depth, so if you never get events on the direct sub folders you will never add watchers for level 2 subdirs, but I may be missing something. Also I don't see any handling of Move events for dirs, unless it is handled in lib by generating Rename/Create event pair.. @isage focus on the part 'all the legacy inotify event', namely, create/move/delete.\nan fanotify mount watch does not provide those events.. Well the patches are out there already in my github (applied to kernel 4.9), but for those of you hoping for this functionality to get upstream, I suggest to be patient.\nI have no doubt it is going to be some time before this feature can be\nmerged to an official kernel.\nMy bet is that I will have to maintain it out of tree for a while, and only\nafter real users show genuine interest in the feature, it will be seriously\nconsidered for upstream.\nThis is were you guys can be of help.\nSo far I had only one guy rooting for my patches on LKML\nand he has also tested them on his system.\nWhen promoting a feature for upstream it is important to bring solid use cases that require the feature and argue that the same cannot be achieved by user library code and existing kernel functionality.\nHowever, if you can't test my work on a distro kernel then it is going to be harder to claim that it is beneficial for your use cases.\nTo solve this chicken and egg problem I plan to provide install-able\nkernel modules for commonly used Linux distros, so using fanotify super block\nshould be as easy as e.g.: apt-get install fsntotify-tools.\nI cannot guaranty when I will get to providing this level of installation though, so if there are any of you out there not afraid of building a custom kernel, I will gladly assist you if you want to test my patches.\nCheers.. Yes, that could work. And I promise to assist the person who volunteers to work on this setup.. @tiwaana question is moot. I would like to target the earliest kernel version possible, but since this is not a bug fix nor a trivial improvement, some things have to happen first not all of them depend on me, not necessarily in that order:\n1. Technical review of patches (I am working on getting that)\n2. Design review of patched (ditto)\n3. Review of the proposed kernel-user API\n4. Demonstrate a cut and clear benefit to Linux users community\n5. Demonstrate no performance regressions for users not using the feature. @purpleidea thanks for the ping. If your company will show interest in the super block watch, that can be a game changer. wrt your recursive watcher, I am new to golang and have zero knowledge about fsnotify library, but it appears your code is not calling addSubFolders() recursively from Init() more than 1 level of depth, so if you never get events on the direct sub folders you will never add watchers for level 2 subdirs, but I may be missing something. Also I don't see any handling of Move events for dirs, unless it is handled in lib by generating Rename/Create event pair.. @isage focus on the part 'all the legacy inotify event', namely, create/move/delete.\nan fanotify mount watch does not provide those events.. ",
    "isage": "\n@amir73il is working on a \"super block watch\" for Linux, providing \"the ability to set a single (fanotify) watch on a root directory and get notified on all the legacy inotify events without the need to recursively add watches on all directories.\" https://lkml.org/lkml/2016/12/20/312\n\nYou do know, that fanotify supports recursive watch on (any, even bind) mountpoint with FAN_MARK_MOUNT, right?. > @amir73il is working on a \"super block watch\" for Linux, providing \"the ability to set a single (fanotify) watch on a root directory and get notified on all the legacy inotify events without the need to recursively add watches on all directories.\" https://lkml.org/lkml/2016/12/20/312\nYou do know, that fanotify supports recursive watch on (any, even bind) mountpoint with FAN_MARK_MOUNT, right?. ",
    "Tasssadar": "Happened to me too, relevant stack trace:\n```\ngoroutine 60 [select, 1 minutes]:\ngopkg.in/fsnotify%2ev1.(*Watcher).readEvents(0xc82031e000)\n        src/gopkg.in/fsnotify.v1/inotify.go:265 +0xa00\ncreated by gopkg.in/fsnotify%2ev1.NewWatcher\n       gopkg.in/fsnotify.v1/inotify.go:60 +0x3e2\ngoroutine 61 [semacquire, 1 minutes]:\nsync.runtime_Syncsemacquire(0xc820300850)\n       src/runtime/sema.go:241 +0x201\nsync.(Cond).Wait(0xc820300840)\n       src/sync/cond.go:63 +0x9b\ngopkg.in/fsnotify%2ev1.(Watcher).Remove(0xc82031e000, 0xc820482230, 0x4e, 0x0, 0x0)\n        src/gopkg.in/fsnotify.v1/inotify.go:157 +0x2db\n...\n```\nThe problem is that goroutine 61 is also the one that reads from the Events channel, which means no new events can come in and free the condition in Remove(). Not sure if that's a bug per se, but definitely something that should be documented (but I honestly haven't checked if it is, so if yes, the joke's on me ^^)\n. Happened to me too, relevant stack trace:\n```\ngoroutine 60 [select, 1 minutes]:\ngopkg.in/fsnotify%2ev1.(*Watcher).readEvents(0xc82031e000)\n        src/gopkg.in/fsnotify.v1/inotify.go:265 +0xa00\ncreated by gopkg.in/fsnotify%2ev1.NewWatcher\n       gopkg.in/fsnotify.v1/inotify.go:60 +0x3e2\ngoroutine 61 [semacquire, 1 minutes]:\nsync.runtime_Syncsemacquire(0xc820300850)\n       src/runtime/sema.go:241 +0x201\nsync.(Cond).Wait(0xc820300840)\n       src/sync/cond.go:63 +0x9b\ngopkg.in/fsnotify%2ev1.(Watcher).Remove(0xc82031e000, 0xc820482230, 0x4e, 0x0, 0x0)\n        src/gopkg.in/fsnotify.v1/inotify.go:157 +0x2db\n...\n```\nThe problem is that goroutine 61 is also the one that reads from the Events channel, which means no new events can come in and free the condition in Remove(). Not sure if that's a bug per se, but definitely something that should be documented (but I honestly haven't checked if it is, so if yes, the joke's on me ^^)\n. ",
    "jiangytcn": "@nathany  and @gaplyk i had same issue, and i'm curious about whether i had to manually remove the file/directory watcher when the file/directory removed? will the fsnotify library automatically achieve this ?\n. Sorry for the late response :), for the issue i reported, after removed the watcher.Remove(event.Name) function call, the issue resolved. I don't know whether its a good resolution to it. But for now i met another issue about the scripts still hold the file descriptors, lsof +L1  shows a lot of deleted file still occupied by the program, need to manually restart the program\n. @nathany  and @gaplyk i had same issue, and i'm curious about whether i had to manually remove the file/directory watcher when the file/directory removed? will the fsnotify library automatically achieve this ?\n. Sorry for the late response :), for the issue i reported, after removed the watcher.Remove(event.Name) function call, the issue resolved. I don't know whether its a good resolution to it. But for now i met another issue about the scripts still hold the file descriptors, lsof +L1  shows a lot of deleted file still occupied by the program, need to manually restart the program\n. ",
    "gaplyk": "I just hand over in this case and use different workaround without fsnotify.\n. I just hand over in this case and use different workaround without fsnotify.\n. ",
    "thinkclay": "Mac: 10.11.4 Beta (15E27e)\n. Mac: 10.11.4 Beta (15E27e)\n. ",
    "drewwells": "I'd have to build this again on older branches, if you have a guess when this could be a regression that would help track it down. I probably never have tested this as a background process, so not sure if it's a regression or always been a problem.\n. I'd have to build this again on older branches, if you have a guess when this could be a regression that would help track it down. I probably never have tested this as a background process, so not sure if it's a regression or always been a problem.\n. ",
    "digikata": "I think this was a bug in my test code leaving the for loop running after the the watcher was closed. Closing the issue\n. I think this was a bug in my test code leaving the for loop running after the the watcher was closed. Closing the issue\n. ",
    "fjl": "I cannot reproduce the failure on Travis and it seems unrelated to the PR.\n. The tests pass on FreeBSD, too.\n. Looks like it worked this time.\n. I found a minor issue with how the pipe is set up and fixed it. Travis still passing.\n. Any ETA on getting this merged?\n. rebased\n. Is there anything I can do to get this merged?\n. I cannot reproduce the failure on Travis and it seems unrelated to the PR.\n. The tests pass on FreeBSD, too.\n. Looks like it worked this time.\n. I found a minor issue with how the pipe is set up and fixed it. Travis still passing.\n. Any ETA on getting this merged?\n. rebased\n. Is there anything I can do to get this merged?\n. ",
    "amitkris": "ping @nathany \n. ping @nathany \n. ",
    "armhold": "Almost certainly the same issue from the original project: https://github.com/howeyc/fsnotify/issues/35. \n. Almost certainly the same issue from the original project: https://github.com/howeyc/fsnotify/issues/35. \n. ",
    "TheTincho": "This also happens in normal ppc64 (bigendian)\n. In arm64, it just fails with \"function not implemented\":\n=== RUN   TestPollerWithData\n--- FAIL: TestPollerWithData (0.13s)\n    inotify_poller_test.go:82: poller failed: function not implemented\n=== RUN   TestPollerWithWakeup\n--- FAIL: TestPollerWithWakeup (0.13s)\n    inotify_poller_test.go:101: poller failed: function not implemented\n=== RUN   TestPollerWithClose\n--- FAIL: TestPollerWithClose (0.13s)\n    inotify_poller_test.go:116: poller failed: function not implemented\n=== RUN   TestPollerWithWakeupAndData\n--- FAIL: TestPollerWithWakeupAndData (0.13s)\n    inotify_poller_test.go:137: poller failed: function not implemented\n=== RUN   TestPollerConcurrent\n--- FAIL: TestPollerConcurrent (0.13s)\n    inotify_poller_test.go:180: poller failed: function not implemented\n    inotify_poller_test.go:197: expected true\n. Thanks to all for taking a look!\nI have access to porter machines in these architectures, as a Debian Developer, but it is not very easy to request access for third parties. I can test whatever you need though.\n. @laboger Care to share that patch? I could run some tests too.\n. @suihkulokki To test that, get the current prometheus source from Debian sid, remove the 07-Disable_fsnotify.patch patch from the series and just try to build the package.\nThanks for working on this!\n. Alternatively, you can just download and build prometheus from upstream, which will run al the tests (fsnotify is not yet disabled upstream, but there is a pending PR)\n. I'm on it!\n. I ran some tests, and it appears to work! I will now update fsnotify and prometheus on Debian. Thanks for working on this!\nNow, any idea about powerpc? It seemed like a different issue, no?\n. Thanks everybody! I am preparing updated packages for x/sys and fsnotify. Will update with test results as soon as I have them.\n. I have tested this in the 3 affected arches, and everything seems to work correctly now. Thanks to everybody involved!!\n. Any news on this? Do you know if it is just a flaky test or if there is some real bug in the code?\n. The patch got scrambled by github, can you paste that again in a code block?\n. Still seems to be too sensible to timing.. For now I am disabling this test in the debian package..\n. @nathany You mean support for inotify_init1? I can test building this on those arches if it is just that.\n. I have just tried PPC64 and ARMel, and it compiles and passes the tests correctly with this patch applied. Do you need me to test somewhere else too?\n. This also happens in normal ppc64 (bigendian)\n. In arm64, it just fails with \"function not implemented\":\n=== RUN   TestPollerWithData\n--- FAIL: TestPollerWithData (0.13s)\n    inotify_poller_test.go:82: poller failed: function not implemented\n=== RUN   TestPollerWithWakeup\n--- FAIL: TestPollerWithWakeup (0.13s)\n    inotify_poller_test.go:101: poller failed: function not implemented\n=== RUN   TestPollerWithClose\n--- FAIL: TestPollerWithClose (0.13s)\n    inotify_poller_test.go:116: poller failed: function not implemented\n=== RUN   TestPollerWithWakeupAndData\n--- FAIL: TestPollerWithWakeupAndData (0.13s)\n    inotify_poller_test.go:137: poller failed: function not implemented\n=== RUN   TestPollerConcurrent\n--- FAIL: TestPollerConcurrent (0.13s)\n    inotify_poller_test.go:180: poller failed: function not implemented\n    inotify_poller_test.go:197: expected true\n. Thanks to all for taking a look!\nI have access to porter machines in these architectures, as a Debian Developer, but it is not very easy to request access for third parties. I can test whatever you need though.\n. @laboger Care to share that patch? I could run some tests too.\n. @suihkulokki To test that, get the current prometheus source from Debian sid, remove the 07-Disable_fsnotify.patch patch from the series and just try to build the package.\nThanks for working on this!\n. Alternatively, you can just download and build prometheus from upstream, which will run al the tests (fsnotify is not yet disabled upstream, but there is a pending PR)\n. I'm on it!\n. I ran some tests, and it appears to work! I will now update fsnotify and prometheus on Debian. Thanks for working on this!\nNow, any idea about powerpc? It seemed like a different issue, no?\n. Thanks everybody! I am preparing updated packages for x/sys and fsnotify. Will update with test results as soon as I have them.\n. I have tested this in the 3 affected arches, and everything seems to work correctly now. Thanks to everybody involved!!\n. Any news on this? Do you know if it is just a flaky test or if there is some real bug in the code?\n. The patch got scrambled by github, can you paste that again in a code block?\n. Still seems to be too sensible to timing.. For now I am disabling this test in the debian package..\n. @nathany You mean support for inotify_init1? I can test building this on those arches if it is just that.\n. I have just tried PPC64 and ARMel, and it compiles and passes the tests correctly with this patch applied. Do you need me to test somewhere else too?\n. ",
    "laboger": "I opened this golang issue for the failures on ppc64le:  https://github.com/golang/go/issues/15135.\n. Yes I will create a CL and test it for ppc64 & ppc64le.  I'm not sure if this fixes arm64 and can't test it there.  There might be more than one issue to fix, I'll have to see once I can try it.\nI think it is best to fix the Go standard libraries syscall and use that.  I'm not familiar with what's in golang.org/x/sys or why you'd use it instead.\n. I have been testing a patch on ppc64 and ppc64le.  All the tests say PASS but when it gets to the end it says FAIL and I'm not sure why.  If I run it multiple times in a row it will sometime say PASS at the end.  Any clues?\n. @nathany I am unable to build the fsnotify test now on ppc64le with the latest golang.\nsrc/github.com/fsnotify/fsnotify/inotify.go:39: undefined: unix.InotifyInit\nsrc/github.com/fsnotify/fsnotify/inotify_poller.go:48: undefined: unix.Pipe2\nLooks like the switch was made to use golang.org/x/sys/unix but that is missing some functions for ppc64le and ppc64.  (Same errors in both)\n. I created this golang issue to make the necessary updates to golang.org/x/sys/unix.  https://github.com/golang/go/issues/15393.\n. @suihkulokki, can you clarify what you mean that previous syscall changes were rejected?  Do you mean by the golang community or fsnotify?\nBOTH golang syscall and golang.org/x/sys/unix had incorrect implementations of the structure EpollEvent for use with epoll syscalls on ppc64x and both need to be fixed if they are going to be used.  I'm not sure why you'd fix one and not the other.\n. I opened this golang issue for the failures on ppc64le:  https://github.com/golang/go/issues/15135.\n. Yes I will create a CL and test it for ppc64 & ppc64le.  I'm not sure if this fixes arm64 and can't test it there.  There might be more than one issue to fix, I'll have to see once I can try it.\nI think it is best to fix the Go standard libraries syscall and use that.  I'm not familiar with what's in golang.org/x/sys or why you'd use it instead.\n. I have been testing a patch on ppc64 and ppc64le.  All the tests say PASS but when it gets to the end it says FAIL and I'm not sure why.  If I run it multiple times in a row it will sometime say PASS at the end.  Any clues?\n. @nathany I am unable to build the fsnotify test now on ppc64le with the latest golang.\nsrc/github.com/fsnotify/fsnotify/inotify.go:39: undefined: unix.InotifyInit\nsrc/github.com/fsnotify/fsnotify/inotify_poller.go:48: undefined: unix.Pipe2\nLooks like the switch was made to use golang.org/x/sys/unix but that is missing some functions for ppc64le and ppc64.  (Same errors in both)\n. I created this golang issue to make the necessary updates to golang.org/x/sys/unix.  https://github.com/golang/go/issues/15393.\n. @suihkulokki, can you clarify what you mean that previous syscall changes were rejected?  Do you mean by the golang community or fsnotify?\nBOTH golang syscall and golang.org/x/sys/unix had incorrect implementations of the structure EpollEvent for use with epoll syscalls on ppc64x and both need to be fixed if they are going to be used.  I'm not sure why you'd fix one and not the other.\n. ",
    "clnperez": "Np @nathany. I ran the fsnotify tests on ppc64le as part of my patch validation before submitting and things seemed fine, but more testing is always a good thing.\n. I also tested this on ppc64le and it looks like both parent and child have an inotify fd:\n~> lsof -p 2338\nCOMMAND    PID    USER   FD      TYPE DEVICE SIZE/OFF    NODE NAME\nfsnotify_ 2338 christy  cwd       DIR  253,2     4096  261642 /home/christy\nfsnotify_ 2338 christy  rtd       DIR  253,2     4096       2 /\nfsnotify_ 2338 christy  txt       REG  253,2  2351144 2373750 /tmp/go-build372706786/command-line-arguments/_obj/exe/fsnotify_inotify\nfsnotify_ 2338 christy    0u      CHR  136,0      0t0       3 /dev/pts/0\nfsnotify_ 2338 christy    1u      CHR  136,0      0t0       3 /dev/pts/0\nfsnotify_ 2338 christy    2u      CHR  136,0      0t0       3 /dev/pts/0\nfsnotify_ 2338 christy    3r  a_inode   0,11        0    6637 inotify\nfsnotify_ 2338 christy    4u  a_inode   0,11        0    6637 [eventpoll]\nfsnotify_ 2338 christy    5r     FIFO   0,10      0t0  432376 pipe\nfsnotify_ 2338 christy    6w     FIFO   0,10      0t0  432376 pipe\n ~> lsof -p 2343\nCOMMAND    PID    USER   FD      TYPE DEVICE SIZE/OFF    NODE NAME\nfsnotify_ 2343 christy  cwd       DIR  253,2     4096  261642 /home/christy\nfsnotify_ 2343 christy  rtd       DIR  253,2     4096       2 /\nfsnotify_ 2343 christy  txt       REG  253,2  2351144 2373750 /tmp/go-build372706786/command-line-arguments/_obj/exe/fsnotify_inotify\nfsnotify_ 2343 christy    0r      CHR    1,3      0t0       6 /dev/null\nfsnotify_ 2343 christy    1w      CHR    1,3      0t0       6 /dev/null\nfsnotify_ 2343 christy    2w      CHR    1,3      0t0       6 /dev/null\nfsnotify_ 2343 christy    3r  a_inode   0,11        0    6637 inotify\nfsnotify_ 2343 christy    4u  a_inode   0,11        0    6637 [eventpoll]\nfsnotify_ 2343 christy    5r     FIFO   0,10      0t0  432376 pipe\nfsnotify_ 2343 christy    6w     FIFO   0,10      0t0  432376 pipe\n. Yah, I don't know either. I had to add the syscalls for Pipe2 and InotifyInit, but InotifyInit1 is already there, so, hmm. I hope it just isn't something wonky on my system. \n. Oh man. I forgot to rebuild fsnotify with this patch after I got my sys updated (since it was an older copy without the other syscalls added for ppc64le). Kiiiind of important. Sorry about the noise. It works fine on ppc64le. :)\n. Np @nathany. I ran the fsnotify tests on ppc64le as part of my patch validation before submitting and things seemed fine, but more testing is always a good thing.\n. I also tested this on ppc64le and it looks like both parent and child have an inotify fd:\n~> lsof -p 2338\nCOMMAND    PID    USER   FD      TYPE DEVICE SIZE/OFF    NODE NAME\nfsnotify_ 2338 christy  cwd       DIR  253,2     4096  261642 /home/christy\nfsnotify_ 2338 christy  rtd       DIR  253,2     4096       2 /\nfsnotify_ 2338 christy  txt       REG  253,2  2351144 2373750 /tmp/go-build372706786/command-line-arguments/_obj/exe/fsnotify_inotify\nfsnotify_ 2338 christy    0u      CHR  136,0      0t0       3 /dev/pts/0\nfsnotify_ 2338 christy    1u      CHR  136,0      0t0       3 /dev/pts/0\nfsnotify_ 2338 christy    2u      CHR  136,0      0t0       3 /dev/pts/0\nfsnotify_ 2338 christy    3r  a_inode   0,11        0    6637 inotify\nfsnotify_ 2338 christy    4u  a_inode   0,11        0    6637 [eventpoll]\nfsnotify_ 2338 christy    5r     FIFO   0,10      0t0  432376 pipe\nfsnotify_ 2338 christy    6w     FIFO   0,10      0t0  432376 pipe\n ~> lsof -p 2343\nCOMMAND    PID    USER   FD      TYPE DEVICE SIZE/OFF    NODE NAME\nfsnotify_ 2343 christy  cwd       DIR  253,2     4096  261642 /home/christy\nfsnotify_ 2343 christy  rtd       DIR  253,2     4096       2 /\nfsnotify_ 2343 christy  txt       REG  253,2  2351144 2373750 /tmp/go-build372706786/command-line-arguments/_obj/exe/fsnotify_inotify\nfsnotify_ 2343 christy    0r      CHR    1,3      0t0       6 /dev/null\nfsnotify_ 2343 christy    1w      CHR    1,3      0t0       6 /dev/null\nfsnotify_ 2343 christy    2w      CHR    1,3      0t0       6 /dev/null\nfsnotify_ 2343 christy    3r  a_inode   0,11        0    6637 inotify\nfsnotify_ 2343 christy    4u  a_inode   0,11        0    6637 [eventpoll]\nfsnotify_ 2343 christy    5r     FIFO   0,10      0t0  432376 pipe\nfsnotify_ 2343 christy    6w     FIFO   0,10      0t0  432376 pipe\n. Yah, I don't know either. I had to add the syscalls for Pipe2 and InotifyInit, but InotifyInit1 is already there, so, hmm. I hope it just isn't something wonky on my system. \n. Oh man. I forgot to rebuild fsnotify with this patch after I got my sys updated (since it was an older copy without the other syscalls added for ppc64le). Kiiiind of important. Sorry about the noise. It works fine on ppc64le. :)\n. ",
    "mprobst": "This is on Linux. Here's what another engineer wrote about this:\n\nThis looks like a bug in fsnotify to me. I don't see anything in the Watcher's Close method that would interrupt its Read. The readEvents goroutine checks the done channel before the read, so if Close happens to signal done in time then readEvents will exit cleanly and close the Events and Errors channels. If the signal comes after the check, then it'll just hang unless a new event happens to make its way through and restart the loop.\n\nThis is a stack trace where fsnotify hangs:\ngoroutine 90 [syscall]:\nsyscall.Syscall(0x0, 0x9, 0xc8204bbe40, 0x10000, 0x0, 0x0, 0x0)\n  third_party/go/gc/src/syscall/asm_linux_amd64.s:18 +0x5\nsyscall.read(0x9, 0xc8204bbe40, 0x10000, 0x10000, 0x0, 0x0, 0x0)\n  third_party/go/gc/src/syscall/zsyscall_linux_amd64.go:776 +0x5f\nsyscall.Read(0x9, 0xc8204bbe40, 0x10000, 0x10000, 0x0, 0x0, 0x0)\n  third_party/go/gc/src/syscall/syscall_unix.go:161 +0x4d\nthird_party/golang/fsnotify/fsnotify.(*Watcher).readEvents(0xc82035e680)\n  third_party/golang/fsnotify/inotify.go:144 +0x13f\ncreated by third_party/golang/fsnotify/fsnotify.NewWatcher\n  third_party/golang/fsnotify/inotify.go:47 +0x365\n. I'm pretty sure I don't have the latest, but indeed the issue seems present\nin the latest, too.\nPawel Knap notifications@github.com schrieb am Fr., 8. Apr. 2016, 19:43:\n\nAre you sure that you have the latest version? It is quite obvious that\nfsnotify hangs on syscall.Read function which is currently here\nhttps://github.com/fsnotify/fsnotify/blob/master/inotify.go#L205 (line\n205). Your stack trace shows that the call to syscall.Read function is in\nline 144 which means that you may use an old version of the package.\nHonestly speaking, I don't believe that upgrading fsnotify will help(but\nit may). Implementation of readEvents function is definitely not thread\nsafe..\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/fsnotify/fsnotify/issues/132#issuecomment-207533074\n. This is on Linux. Here's what another engineer wrote about this:\nThis looks like a bug in fsnotify to me. I don't see anything in the Watcher's Close method that would interrupt its Read. The readEvents goroutine checks the done channel before the read, so if Close happens to signal done in time then readEvents will exit cleanly and close the Events and Errors channels. If the signal comes after the check, then it'll just hang unless a new event happens to make its way through and restart the loop.\n\nThis is a stack trace where fsnotify hangs:\ngoroutine 90 [syscall]:\nsyscall.Syscall(0x0, 0x9, 0xc8204bbe40, 0x10000, 0x0, 0x0, 0x0)\n  third_party/go/gc/src/syscall/asm_linux_amd64.s:18 +0x5\nsyscall.read(0x9, 0xc8204bbe40, 0x10000, 0x10000, 0x0, 0x0, 0x0)\n  third_party/go/gc/src/syscall/zsyscall_linux_amd64.go:776 +0x5f\nsyscall.Read(0x9, 0xc8204bbe40, 0x10000, 0x10000, 0x0, 0x0, 0x0)\n  third_party/go/gc/src/syscall/syscall_unix.go:161 +0x4d\nthird_party/golang/fsnotify/fsnotify.(*Watcher).readEvents(0xc82035e680)\n  third_party/golang/fsnotify/inotify.go:144 +0x13f\ncreated by third_party/golang/fsnotify/fsnotify.NewWatcher\n  third_party/golang/fsnotify/inotify.go:47 +0x365\n. I'm pretty sure I don't have the latest, but indeed the issue seems present\nin the latest, too.\nPawel Knap notifications@github.com schrieb am Fr., 8. Apr. 2016, 19:43:\n\nAre you sure that you have the latest version? It is quite obvious that\nfsnotify hangs on syscall.Read function which is currently here\nhttps://github.com/fsnotify/fsnotify/blob/master/inotify.go#L205 (line\n205). Your stack trace shows that the call to syscall.Read function is in\nline 144 which means that you may use an old version of the package.\nHonestly speaking, I don't believe that upgrading fsnotify will help(but\nit may). Implementation of readEvents function is definitely not thread\nsafe..\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/fsnotify/fsnotify/issues/132#issuecomment-207533074\n. \n",
    "samos123": "@kataras just had the s ame issue. Thanks for posting the solution. I also forgot that I had a defer watcher.Close() in place where it shouldn't have.. @kataras just had the s ame issue. Thanks for posting the solution. I also forgot that I had a defer watcher.Close() in place where it shouldn't have.. ",
    "ghost": "@samos123 Always a step ahead ahah I'm joking, you're welcome!. @samos123 Always a step ahead ahah I'm joking, you're welcome!. ",
    "tophj-ibm": "following along in #130, thanks!\n. following along in #130, thanks!\n. ",
    "flexd": "I am on Go 1.5.3 at the moment, if that matters. I have not been good at keeping up with updates :)\n. Oops. Not sure how we missed this.. thanks for spotting that @ppknap :D\n. I am on Go 1.5.3 at the moment, if that matters. I have not been good at keeping up with updates :)\n. Oops. Not sure how we missed this.. thanks for spotting that @ppknap :D\n. ",
    "Depado": "Same here. Archlinux with 4.5.1 kernel, Go 1.6. \nExact same output, it looks like the files are not watched (tried with a directory and with a single file). \n. I think that should indeed fix the problem. I didn't try but that's a good call. I think I made the same mistake as @flexd.\n. Same here. Archlinux with 4.5.1 kernel, Go 1.6. \nExact same output, it looks like the files are not watched (tried with a directory and with a single file). \n. I think that should indeed fix the problem. I didn't try but that's a good call. I think I made the same mistake as @flexd.\n. ",
    "prateekgogia": "cat /etc/os-release\nNAME=\"Ubuntu\"\nVERSION=\"15.10 (Wily Werewolf)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 15.10\"\nVERSION_ID=\"15.10\"\nHOME_URL=\"http://www.ubuntu.com/\"\nSUPPORT_URL=\"http://help.ubuntu.com/\"\nBUG_REPORT_URL=\"http://bugs.launchpad.net/ubuntu/\"\n. cat /etc/os-release\nNAME=\"Ubuntu\"\nVERSION=\"15.10 (Wily Werewolf)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 15.10\"\nVERSION_ID=\"15.10\"\nHOME_URL=\"http://www.ubuntu.com/\"\nSUPPORT_URL=\"http://help.ubuntu.com/\"\nBUG_REPORT_URL=\"http://bugs.launchpad.net/ubuntu/\"\n. ",
    "nikunjy": "@nathany fair enough. I slacked off on making the fix. Will bounce back with the fix and do the test without testify. \n. @nathany fair enough. I slacked off on making the fix. Will bounce back with the fix and do the test without testify. \n. ",
    "prashantv": "One option is to make the blocking call also check the w.done channel in a select,\ngo\nselect {\ncase w.Events <- event:\ncase <-w.Done:\n  // quit logic here\n}\n. One option is to make the blocking call also check the w.done channel in a select,\ngo\nselect {\ncase w.Events <- event:\ncase <-w.Done:\n  // quit logic here\n}\n. ",
    "jeffwilliams": "Ah! I didn't realize this would cause an incompatibilty with arm64. It's probably more important to support that than an old kernel. Should I close the request?\n. Ah! I didn't realize this would cause an incompatibilty with arm64. It's probably more important to support that than an old kernel. Should I close the request?\n. ",
    "chmike": "This is normal because there is an upper limit for queued iNotify events. See man inotify for more information on this.\nFrom the manual :\n```\n   /proc interfaces\n       The following interfaces can be used to limit the amount of kernel mem\u2010\n       ory consumed by inotify:\n   /proc/sys/fs/inotify/max_queued_events\n          The  value  in  this file is used when an application calls ino\u2010\n          tify_init(2) to set an upper limit on the number of events  that\n          can  be queued to the corresponding inotify instance.  Events in\n          excess of this limit are dropped, but an IN_Q_OVERFLOW event  is\n          always generated.\n\n   /proc/sys/fs/inotify/max_user_instances\n          This specifies an upper limit on the number of inotify instances\n          that can be created per real user ID.\n\n   /proc/sys/fs/inotify/max_user_watches\n          This specifies an upper limit on the number of watches that  can\n          be created per real user ID.\n\n```\nand also\nNote that the event queue can overflow.  In this case, events are lost.\n       Robust applications should handle the possibility of lost events grace\u2010\n       fully.   For example, it may be necessary to rebuild part or all of the\n       application cache.  (One simple, but possibly expensive, approach is to\n       close  the  inotify file descriptor, empty the cache, create a new ino\u2010\n       tify file descriptor, and then re-create watches and cache entries  for\n       the objects to be monitored.)\nSo, considering your particular use case, I suggest you increase the value of /proc/sys/fs/inotify/max_queued_events to avoid hitting the queue limit. It is a \"limitation\" of the fsnotify library to not inform users of dropped events due to queue overflow. \n. Sorry, for the delayed update of the comment. The issue was posted by accident before I could fill the comment. I then double checked everything before posting the comment. \n. The strength of fsnotify is the simplicity of its API. Unfortunately it lacks a good reporting of renaming/moving. \nThe rename operation would require two names, the old and the new name. \nIn order to add a good support of file renaming, could it be possible to add a second string field to the Event structure ? The string would be nil if the old or new name are not known. \n. I found the answer to my own question. Closing the socket allows the kernel to reuse it. \nIf the goroutine is blocked on the read when the fd is closed, things work as expected. But if the goroutine was doing something else, there is a time gap where the kernel can reuse the fd so that when the goroutine reaches the read it will be performed on the reassigned fd. You may then read from a file or a socket. \nEven if you add a bool flag that you test just before performing the read, there will still be a time gap between the test and the read where the Close can be performed and the fd reused by the kernel.\nThis implies thus that another mechanism is used to inform the goroutine that it must stop. The use of epoll or equivalent is then required. \n. If fact point 4 is not correct. It is possible to remove the watch but by using the name used to register the directory.\nThe problem is due to a limitation of inotify. \nOne of the consequences of a rename/move of a watched dir is that the returned path is invalid. So you may be informed of modifications inside the directory, but you wouldn't be able to access the files to get the stats for instance because the path is wrong. It requires more work to properly keep track of subdirectory moves. \n. This is normal because there is an upper limit for queued iNotify events. See man inotify for more information on this.\nFrom the manual :\n```\n   /proc interfaces\n       The following interfaces can be used to limit the amount of kernel mem\u2010\n       ory consumed by inotify:\n   /proc/sys/fs/inotify/max_queued_events\n          The  value  in  this file is used when an application calls ino\u2010\n          tify_init(2) to set an upper limit on the number of events  that\n          can  be queued to the corresponding inotify instance.  Events in\n          excess of this limit are dropped, but an IN_Q_OVERFLOW event  is\n          always generated.\n\n   /proc/sys/fs/inotify/max_user_instances\n          This specifies an upper limit on the number of inotify instances\n          that can be created per real user ID.\n\n   /proc/sys/fs/inotify/max_user_watches\n          This specifies an upper limit on the number of watches that  can\n          be created per real user ID.\n\n```\nand also\nNote that the event queue can overflow.  In this case, events are lost.\n       Robust applications should handle the possibility of lost events grace\u2010\n       fully.   For example, it may be necessary to rebuild part or all of the\n       application cache.  (One simple, but possibly expensive, approach is to\n       close  the  inotify file descriptor, empty the cache, create a new ino\u2010\n       tify file descriptor, and then re-create watches and cache entries  for\n       the objects to be monitored.)\nSo, considering your particular use case, I suggest you increase the value of /proc/sys/fs/inotify/max_queued_events to avoid hitting the queue limit. It is a \"limitation\" of the fsnotify library to not inform users of dropped events due to queue overflow. \n. Sorry, for the delayed update of the comment. The issue was posted by accident before I could fill the comment. I then double checked everything before posting the comment. \n. The strength of fsnotify is the simplicity of its API. Unfortunately it lacks a good reporting of renaming/moving. \nThe rename operation would require two names, the old and the new name. \nIn order to add a good support of file renaming, could it be possible to add a second string field to the Event structure ? The string would be nil if the old or new name are not known. \n. I found the answer to my own question. Closing the socket allows the kernel to reuse it. \nIf the goroutine is blocked on the read when the fd is closed, things work as expected. But if the goroutine was doing something else, there is a time gap where the kernel can reuse the fd so that when the goroutine reaches the read it will be performed on the reassigned fd. You may then read from a file or a socket. \nEven if you add a bool flag that you test just before performing the read, there will still be a time gap between the test and the read where the Close can be performed and the fd reused by the kernel.\nThis implies thus that another mechanism is used to inform the goroutine that it must stop. The use of epoll or equivalent is then required. \n. If fact point 4 is not correct. It is possible to remove the watch but by using the name used to register the directory.\nThe problem is due to a limitation of inotify. \nOne of the consequences of a rename/move of a watched dir is that the returned path is invalid. So you may be informed of modifications inside the directory, but you wouldn't be able to access the files to get the stats for instance because the path is wrong. It requires more work to properly keep track of subdirectory moves. \n. ",
    "zeldovich": "I suspect that it's possible to test this behavior without resorting to changing /proc/sys/fs/inotify/max_queued_events; at least in my experience (which led to discovering and fixing this problem), it's quite easy to generate inotify events faster than fsnotify consumes them.\n. I've added a well-defined error, ErrEventOverflow, which is reported upon encountering inotify queue overflow, and also added a test that checks that ErrEventOverflow is properly reported.\nAs I already mentioned, Windows already has its own special handling for queue overflows, without a well-defined error code.  I did not change how Windows handles overflows as part of this pull request; it would make sense for this to be fixed at some later point (to also return ErrEventOverflow).\n. Yes, that page says I have a signed individual CLA as of Feb 05, 2013 09:47 PST.\n. I suspect that it's possible to test this behavior without resorting to changing /proc/sys/fs/inotify/max_queued_events; at least in my experience (which led to discovering and fixing this problem), it's quite easy to generate inotify events faster than fsnotify consumes them.\n. I've added a well-defined error, ErrEventOverflow, which is reported upon encountering inotify queue overflow, and also added a test that checks that ErrEventOverflow is properly reported.\nAs I already mentioned, Windows already has its own special handling for queue overflows, without a well-defined error code.  I did not change how Windows handles overflows as part of this pull request; it would make sense for this to be fixed at some later point (to also return ErrEventOverflow).\n. Yes, that page says I have a signed individual CLA as of Feb 05, 2013 09:47 PST.\n. ",
    "bbigras": "Sorry about that. I fixed the comment. The source of the comment looked fine but github removed the extra backslash.\n. > Something is flaky with Mac tests\nIsn't windows.go only used on Windows?\n\nNotice that it's logging events with \\ double slashes everywhere though. Hm.\n\nDo you see \\ double slashes with %s or %q? It should be double with %q I think but not with %s.\n. I just tested and it seems fine.\n``` go\npackage main\nimport (\n    \"log\"\n\"github.com/fsnotify/fsnotify\"\n\n)\nfunc main() {\n    watcher, err := fsnotify.NewWatcher()\n    if err != nil {\n        panic(err)\n    }\n    defer watcher.Close()\ngo func() {\n    for {\n        select {\n        case event := <-watcher.Events:\n            log.Printf(\"event: %q %s\", event.Name, event.Name)\n        case err := <-watcher.Errors:\n            log.Println(\"error:\", err)\n        }\n    }\n}()\n\nerr = watcher.Add(\"D:\\\\\")\nif err != nil {\n    panic(err)\n}\nselect {}\n\n}\n```\noutput\n2016/06/28 12:38:10 event: \"D:\\\\Nouvelle image bitmap2.bmp\" D:\\Nouvelle image bitmap2.bmp\n. Sorry about that. I fixed the comment. The source of the comment looked fine but github removed the extra backslash.\n. > Something is flaky with Mac tests\nIsn't windows.go only used on Windows?\n\nNotice that it's logging events with \\ double slashes everywhere though. Hm.\n\nDo you see \\ double slashes with %s or %q? It should be double with %q I think but not with %s.\n. I just tested and it seems fine.\n``` go\npackage main\nimport (\n    \"log\"\n\"github.com/fsnotify/fsnotify\"\n\n)\nfunc main() {\n    watcher, err := fsnotify.NewWatcher()\n    if err != nil {\n        panic(err)\n    }\n    defer watcher.Close()\ngo func() {\n    for {\n        select {\n        case event := <-watcher.Events:\n            log.Printf(\"event: %q %s\", event.Name, event.Name)\n        case err := <-watcher.Errors:\n            log.Println(\"error:\", err)\n        }\n    }\n}()\n\nerr = watcher.Add(\"D:\\\\\")\nif err != nil {\n    panic(err)\n}\nselect {}\n\n}\n```\noutput\n2016/06/28 12:38:10 event: \"D:\\\\Nouvelle image bitmap2.bmp\" D:\\Nouvelle image bitmap2.bmp\n. ",
    "HeathNaylor": "I am using vim from within the vagrant machine to edit the file and the :wq command to save and quit vim. I suppose I could have my provision script move the .env file but then it is outside of my application and I will need to experiment with symlinking for my Go application's dotenv implementation to be able to find the file, hacky at best. My expectation would be to have the same code express the same behavior on my vagrant / docker as production /docker, and this is looking to not be the case. My last true step will be to deploy the compiled application to an actual Ubuntu instance and see if I get the same behavior. Not looking too good though.\n. I am using vim from within the vagrant machine to edit the file and the :wq command to save and quit vim. I suppose I could have my provision script move the .env file but then it is outside of my application and I will need to experiment with symlinking for my Go application's dotenv implementation to be able to find the file, hacky at best. My expectation would be to have the same code express the same behavior on my vagrant / docker as production /docker, and this is looking to not be the case. My last true step will be to deploy the compiled application to an actual Ubuntu instance and see if I get the same behavior. Not looking too good though.\n. ",
    "pattyshack": "If you're share the inotify fd between between processes, the event\nnotifications may end up in either process.  In general, this behavior does\nnot seem particularly useful.\nkqueue behaves the same way (i.e., child do not inherit kqueue) for the\nsame reason.\nOn Wed, Oct 5, 2016 at 2:43 PM, Nathan Youngman notifications@github.com\nwrote:\n\nIs there any reason why someone would want the child process to have the\ninotify file descriptor carried over?\nPresumably a new one would be created in the child process instead if\nneeded.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/fsnotify/fsnotify/issues/155#issuecomment-251808379,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AGflbD7qr18W4RbK8ERw-k69CL1igOaGks5qxBnzgaJpZM4JGirW\n.\n. the data race is in the bsd build; that uses kqueue instead of inotify.  #177 will not help here\n. Looks like the project's travis config is broken (the linter doesn't build in go 1.5).  Otherwise, the change seems fine\n. (i totally messed up my branch.  will send another pull request)\n. just noticed your comment.  will split the changes\n. i guess the sleep is necessary after all.  basically the problem is if we delete a newly created file too quickly, the OS will skip the create events and only send the delete event.  (looks like integration test is flaky as well =( )\n. $ go test -test.count 10 .\nok      github.com/fsnotify/fsnotify    88.140s\n. Cool.  Will do\n. ```\n$ cat test.go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"os/exec\"\n    \"time\"\n\"github.com/fsnotify/fsnotify\"\n\n)\nfunc main() {\n    if len(os.Args) == 1 { // parent\n        watcher, err := fsnotify.NewWatcher()\n        if err != nil {\n            log.Fatal(err)\n        }\n        defer watcher.Close()\n    child := exec.Command(os.Args[0], \"child\")\n    err = child.Start()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(\"Parent\", os.Getpid(), \"child\", child.Process.Pid)\n}\n\nfmt.Println(os.Args, \"going into sleep\")\nfor {\n    time.Sleep(time.Second)\n}\n\n}\n```\n$ ./test \nParent 25174 child 25179\n[./test] going into sleep\n$ lsof -p 25174\nCOMMAND   PID    USER   FD      TYPE DEVICE SIZE/OFF     NODE NAME\ntest    25174 patrick  cwd       DIR  252,1     4096 36051491 /home/patrick/git/go/src/github.com/pattyshack/fsnotify/test\ntest    25174 patrick  rtd       DIR  252,1     4096        2 /\ntest    25174 patrick  txt       REG  252,1  2203205 12591190 /home/patrick/git/go/src/github.com/pattyshack/fsnotify/test/test\ntest    25174 patrick    0u      CHR  136,6      0t0        9 /dev/pts/6\ntest    25174 patrick    1u      CHR  136,6      0t0        9 /dev/pts/6\ntest    25174 patrick    2u      CHR  136,6      0t0        9 /dev/pts/6\ntest    25174 patrick    3r  a_inode   0,11        0     8012 inotify\ntest    25174 patrick    4u  a_inode   0,11        0     8012 [eventpoll]\ntest    25174 patrick    5r     FIFO   0,10      0t0   546148 pipe\ntest    25174 patrick    6w     FIFO   0,10      0t0   546148 pipe\n$ lsof -p 25179\nCOMMAND   PID    USER   FD      TYPE DEVICE SIZE/OFF     NODE NAME\ntest    25179 patrick  cwd       DIR  252,1     4096 36051491 /home/patrick/git/go/src/github.com/pattyshack/fsnotify/test\ntest    25179 patrick  rtd       DIR  252,1     4096        2 /\ntest    25179 patrick  txt       REG  252,1  2203205 12591190 /home/patrick/git/go/src/github.com/pattyshack/fsnotify/test/test\ntest    25179 patrick    0r      CHR    1,3      0t0        6 /dev/null\ntest    25179 patrick    1w      CHR    1,3      0t0        6 /dev/null\ntest    25179 patrick    2w      CHR    1,3      0t0        6 /dev/null\ntest    25179 patrick    4u  a_inode   0,11        0     8012 [eventpoll]\ntest    25179 patrick    5r     FIFO   0,10      0t0   546148 pipe\ntest    25179 patrick    6w     FIFO   0,10      0t0   546148 pipe\nNotice the child process does not have an inotify fd\n. ping (sounds like ppc64 is ok.  is there any other blocker?)\n. thx\n. If you're share the inotify fd between between processes, the event\nnotifications may end up in either process.  In general, this behavior does\nnot seem particularly useful.\nkqueue behaves the same way (i.e., child do not inherit kqueue) for the\nsame reason.\nOn Wed, Oct 5, 2016 at 2:43 PM, Nathan Youngman notifications@github.com\nwrote:\n\nIs there any reason why someone would want the child process to have the\ninotify file descriptor carried over?\nPresumably a new one would be created in the child process instead if\nneeded.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/fsnotify/fsnotify/issues/155#issuecomment-251808379,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AGflbD7qr18W4RbK8ERw-k69CL1igOaGks5qxBnzgaJpZM4JGirW\n.\n. the data race is in the bsd build; that uses kqueue instead of inotify.  #177 will not help here\n. Looks like the project's travis config is broken (the linter doesn't build in go 1.5).  Otherwise, the change seems fine\n. (i totally messed up my branch.  will send another pull request)\n. just noticed your comment.  will split the changes\n. i guess the sleep is necessary after all.  basically the problem is if we delete a newly created file too quickly, the OS will skip the create events and only send the delete event.  (looks like integration test is flaky as well =( )\n. $ go test -test.count 10 .\nok      github.com/fsnotify/fsnotify    88.140s\n. Cool.  Will do\n. ```\n$ cat test.go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"os/exec\"\n    \"time\"\n\"github.com/fsnotify/fsnotify\"\n\n)\nfunc main() {\n    if len(os.Args) == 1 { // parent\n        watcher, err := fsnotify.NewWatcher()\n        if err != nil {\n            log.Fatal(err)\n        }\n        defer watcher.Close()\n    child := exec.Command(os.Args[0], \"child\")\n    err = child.Start()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(\"Parent\", os.Getpid(), \"child\", child.Process.Pid)\n}\n\nfmt.Println(os.Args, \"going into sleep\")\nfor {\n    time.Sleep(time.Second)\n}\n\n}\n```\n$ ./test \nParent 25174 child 25179\n[./test] going into sleep\n$ lsof -p 25174\nCOMMAND   PID    USER   FD      TYPE DEVICE SIZE/OFF     NODE NAME\ntest    25174 patrick  cwd       DIR  252,1     4096 36051491 /home/patrick/git/go/src/github.com/pattyshack/fsnotify/test\ntest    25174 patrick  rtd       DIR  252,1     4096        2 /\ntest    25174 patrick  txt       REG  252,1  2203205 12591190 /home/patrick/git/go/src/github.com/pattyshack/fsnotify/test/test\ntest    25174 patrick    0u      CHR  136,6      0t0        9 /dev/pts/6\ntest    25174 patrick    1u      CHR  136,6      0t0        9 /dev/pts/6\ntest    25174 patrick    2u      CHR  136,6      0t0        9 /dev/pts/6\ntest    25174 patrick    3r  a_inode   0,11        0     8012 inotify\ntest    25174 patrick    4u  a_inode   0,11        0     8012 [eventpoll]\ntest    25174 patrick    5r     FIFO   0,10      0t0   546148 pipe\ntest    25174 patrick    6w     FIFO   0,10      0t0   546148 pipe\n$ lsof -p 25179\nCOMMAND   PID    USER   FD      TYPE DEVICE SIZE/OFF     NODE NAME\ntest    25179 patrick  cwd       DIR  252,1     4096 36051491 /home/patrick/git/go/src/github.com/pattyshack/fsnotify/test\ntest    25179 patrick  rtd       DIR  252,1     4096        2 /\ntest    25179 patrick  txt       REG  252,1  2203205 12591190 /home/patrick/git/go/src/github.com/pattyshack/fsnotify/test/test\ntest    25179 patrick    0r      CHR    1,3      0t0        6 /dev/null\ntest    25179 patrick    1w      CHR    1,3      0t0        6 /dev/null\ntest    25179 patrick    2w      CHR    1,3      0t0        6 /dev/null\ntest    25179 patrick    4u  a_inode   0,11        0     8012 [eventpoll]\ntest    25179 patrick    5r     FIFO   0,10      0t0   546148 pipe\ntest    25179 patrick    6w     FIFO   0,10      0t0   546148 pipe\nNotice the child process does not have an inotify fd\n. ping (sounds like ppc64 is ok.  is there any other blocker?)\n. thx\n. ",
    "VOID001": "Sorry, I mistook it, This issue is Closed due to I received events after serveral tests later\n. Sorry, I mistook it, This issue is Closed due to I received events after serveral tests later\n. ",
    "jonasfj": "\nThe path on Linux should be relative to whatever you are monitoring. \n\nOkay, we have \"current working directory\" and \"the folder being monitored\", so relative to what?\nWhy would I ever want it relative to the current working folder... that's a surprise indeed...\nI guess I could make it absolute with filepath.Abs(), but being relative to current working folder is not what people would expect, that should be made clear in the docs...\nI would expect the name to be relative to the folder currently being monitored. I realize in hindsight that this would be unfortunate if I were monitoring multiple folders :)\nSo it makes a bit sense that it's relative to current working folder, but this seems like a footgun...\nNote: I'm monitoring the folder EFlmKJ8XTYmnxQIucRkY2A waiting for qmp.sock to appear...\nSo I want to compare when events happen to see if the event was the qmp.sock file being created.\nAs for current working directory, I don't care what that is when my program is running...\nI guess the trick is to use filepath.Abs to make sure it's absolute... \n. > It is relative to the folder being monitored.\nWhat not what you said:\n\nIf the current working directory was tmp and you monitored EFlmKJ8XTYmnxQIucRkY2A/ then you should see EFlmKJ8XTYmnxQIucRkY2A/qmp.sock (relative to tmp).\nIf you monitor /home/go/src then the notification paths will include /home/go/src/.... If you monitor src then the path will only include src/.... In order to do the later, your current working directory matters.\n\nOh, I see... So it's not a relative path, it is the path given as input + the path relative to that path...\nThat's not easy to express... :)\nNote: If it was relative to the path being monitored, then in your example above it would be: test-file when test-file is created in a folder /home/go/src regardless of whether or not the input is src/... or /home/go/src... So it's not relative to the folder being monitored.\nThis is a hard one... to fix with documentation...\nEither we make it absolute, or we have to write a section of docs on the property explaining this, possibly using examples...\n. This doesn't fix the issue, see: https://github.com/fsnotify/fsnotify/pull/158#issuecomment-236972191\n. >  The path on Linux should be relative to whatever you are monitoring. \nOkay, we have \"current working directory\" and \"the folder being monitored\", so relative to what?\nWhy would I ever want it relative to the current working folder... that's a surprise indeed...\nI guess I could make it absolute with filepath.Abs(), but being relative to current working folder is not what people would expect, that should be made clear in the docs...\nI would expect the name to be relative to the folder currently being monitored. I realize in hindsight that this would be unfortunate if I were monitoring multiple folders :)\nSo it makes a bit sense that it's relative to current working folder, but this seems like a footgun...\nNote: I'm monitoring the folder EFlmKJ8XTYmnxQIucRkY2A waiting for qmp.sock to appear...\nSo I want to compare when events happen to see if the event was the qmp.sock file being created.\nAs for current working directory, I don't care what that is when my program is running...\nI guess the trick is to use filepath.Abs to make sure it's absolute... \n. > It is relative to the folder being monitored.\nWhat not what you said:\n\nIf the current working directory was tmp and you monitored EFlmKJ8XTYmnxQIucRkY2A/ then you should see EFlmKJ8XTYmnxQIucRkY2A/qmp.sock (relative to tmp).\nIf you monitor /home/go/src then the notification paths will include /home/go/src/.... If you monitor src then the path will only include src/.... In order to do the later, your current working directory matters.\n\nOh, I see... So it's not a relative path, it is the path given as input + the path relative to that path...\nThat's not easy to express... :)\nNote: If it was relative to the path being monitored, then in your example above it would be: test-file when test-file is created in a folder /home/go/src regardless of whether or not the input is src/... or /home/go/src... So it's not relative to the folder being monitored.\nThis is a hard one... to fix with documentation...\nEither we make it absolute, or we have to write a section of docs on the property explaining this, possibly using examples...\n. This doesn't fix the issue, see: https://github.com/fsnotify/fsnotify/pull/158#issuecomment-236972191\n. ",
    "esiqveland": "I would prefer this.\nThe current situation is very confusing with the path being relative to the path of the directory watched.\nSo as when I watch /home/username/src, the relative path results in /home/username/src/created.txt, yet if I am standing in /home/username and tell it to watch src/, it will be relative to this...\nIf the path was always absolute, it would be easier to know how to deal with it in all cases and much easier to create precise documentation.. I would prefer this.\nThe current situation is very confusing with the path being relative to the path of the directory watched.\nSo as when I watch /home/username/src, the relative path results in /home/username/src/created.txt, yet if I am standing in /home/username and tell it to watch src/, it will be relative to this...\nIf the path was always absolute, it would be easier to know how to deal with it in all cases and much easier to create precise documentation.. ",
    "twpayne": "FWIW you can use 1.x to get the latest stable release of Go, and (for example) 1.7.x to get the latest version of 1.7. For example:\nyaml\ngo:\n  - 1.7.x\n  - 1.x\n  - tip. If you embed a sync.Mutex value in a struct then that sync.Mutex's value will be copied when the struct is copied. This is almost certainly not what you want. The compiler doesn't catch this, but go vet does.\nSince Watcher values should not be copied, it should be OK to be embed a sync.Mutex value (not pointer) in a Watcher.\nIn this PR, the test explicitly copies Watcher objects which is why @oozie  sees multiple sync.Mutexs in the output.\n189 likely fixes the underlying problems in the library. @oozie, you should run go vet on your code to make sure that you're not copying sync.Mutex values.\n. Any chance of getting this reviewed?. Gentle ping :). Gentle ping :). Many thanks for the review!. @nathany Any chance of getting this merged?. Thanks!\nNote that in this case, the \"wide vs. narrow mutexes\" fix is about correctness, not performance. See the commit message of https://github.com/fsnotify/fsnotify/pull/189/commits/81cea74a12b0fb3e3248a242d648664fac705a70 for more details.. Four months after submission, this PR is approved, passed all checks, and ready to merge. Is this gonna happen? Is fsnotify abandonware?. Sorry, I am not able to step in to replace you. I have sufficient maintenance burden with my existing open source projects.\nIs there any reason for not merging this PR? You only have to press the merge button.. Yes, I've signed the Google CLA.. FWIW you can use 1.x to get the latest stable release of Go, and (for example) 1.7.x to get the latest version of 1.7. For example:\nyaml\ngo:\n  - 1.7.x\n  - 1.x\n  - tip. If you embed a sync.Mutex value in a struct then that sync.Mutex's value will be copied when the struct is copied. This is almost certainly not what you want. The compiler doesn't catch this, but go vet does.\nSince Watcher values should not be copied, it should be OK to be embed a sync.Mutex value (not pointer) in a Watcher.\nIn this PR, the test explicitly copies Watcher objects which is why @oozie  sees multiple sync.Mutexs in the output.\n189 likely fixes the underlying problems in the library. @oozie, you should run go vet on your code to make sure that you're not copying sync.Mutex values.\n. Any chance of getting this reviewed?. Gentle ping :). Gentle ping :). Many thanks for the review!. @nathany Any chance of getting this merged?. Thanks!\nNote that in this case, the \"wide vs. narrow mutexes\" fix is about correctness, not performance. See the commit message of https://github.com/fsnotify/fsnotify/pull/189/commits/81cea74a12b0fb3e3248a242d648664fac705a70 for more details.. Four months after submission, this PR is approved, passed all checks, and ready to merge. Is this gonna happen? Is fsnotify abandonware?. Sorry, I am not able to step in to replace you. I have sufficient maintenance burden with my existing open source projects.\nIs there any reason for not merging this PR? You only have to press the merge button.. Yes, I've signed the Google CLA.. ",
    "oozie": "@jiangytcn \nIs it possible that somewhere in your consuming code you instantiate a watcher, and assign it to a field on a struct by value, as opposed to a reference? In such case more than one mutexes are created to guard the same set of maps.\n. Let me illustrate what I mean with code. The following snippet will fail pretty reliably:\n```\npackage main\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n    \"path\"\n    \"strconv\"\n    \"time\"\n\"github.com/fsnotify/fsnotify\"\n\n)\ntype Test struct {\n    Watcher fsnotify.Watcher\n}\nfunc main() {\ntestDirPrefix := \"/tmp/test\"\n\nw, _ := fsnotify.NewWatcher()\nt := Test{Watcher: *w}\n\nfmt.Println(\"creating test dir\")\n\nconcDirs := 100\nfmt.Println(\"adding watchers...\")\nfor i := 0; i < concDirs; i++ {\n    dirName := path.Join(testDirPrefix, strconv.Itoa(i))\n    os.MkdirAll(dirName, 0700)\n    t.Watcher.Add(dirName)\n}\n\ngo func() {\n    fmt.Println(\"polling...\")\n    for {\n        select {\n        case <-t.Watcher.Events:\n        }\n    }\n}()\n\ntime.Sleep(time.Second)\n\nfor i := 0; i < concDirs; i++ {\n    dirName := path.Join(testDirPrefix, strconv.Itoa(i))\n    os.MkdirAll(dirName+\"/subdir\", 700)\n    go func() {\n        for {\n            t.Watcher.Add(dirName + \"/subdir\")\n            ioutil.WriteFile(path.Join(dirName, \"file\"), []byte(\"blah\"), 0600)\n            t.Watcher.Remove(dirName + \"/subdir\")\n        }\n    }()\n}\n\ntime.Sleep(time.Second)\n\nfmt.Println(\"cleaning up\")\ntime.Sleep(1 * time.Second)\nos.RemoveAll(testDirPrefix)\n\n}\n```\nuntil the following patch is applied\n```\ndiff --git a/example.go b/example-fix.go\nindex f9ccfc0..f555803 100644\n--- a/example.go\n+++ b/example-fix.go\n@@ -12,7 +12,7 @@ import (\n )\ntype Test struct {\n-   Watcher fsnotify.Watcher\n+   Watcher *fsnotify.Watcher\n }\nfunc main() {\n@@ -20,7 +20,7 @@ func main() {\n    testDirPrefix := \"/tmp/test\"\nw, _ := fsnotify.NewWatcher()\n\n\nt := Test{Watcher: *w}\n\nt := Test{Watcher: w}\nfmt.Println(\"creating test dir\")\n\n\n```\nPretty subtle. \n. The larger issue can probably be addressed this way (I might be missing something though):\n```\ndiff --git a/inotify.go b/inotify.go\nindex 9700df5..44f3aa6 100644\n--- a/inotify.go\n+++ b/inotify.go\n@@ -23,8 +23,8 @@ import (\n type Watcher struct {\n  Events   chan Event\n  Errors   chan error\n- mu       sync.Mutex // Map access\n- cv       sync.Cond // sync removing on rm_watch with IN_IGNORE\n+ mu       sync.Mutex // Map access\n+ cv       sync.Cond  // sync removing on rm_watch with IN_IGNORE\n  fd       int\n  poller   fdPoller\n  watches  map[string]watch // Map of inotify watches (key: path)\n@@ -55,8 +55,9 @@ func NewWatcher() (Watcher, error) {\n    Errors:   make(chan error),\n    done:     make(chan struct{}),\n    doneResp: make(chan struct{}),\n+   mu:       &sync.Mutex{},\n  }\n- w.cv = sync.NewCond(&w.mu)\n+ w.cv = sync.NewCond(w.mu)\ngo w.readEvents()\n  return w, nil\n```\nBut it would require some more extensive testing. What do you guys think about this solution?\n. @nathany Just a side note: this is not inotify-specific. The issue is reproducible on Darwin with kqueue, I just instructed the curious tester to fit print statements in inotify, but the same can be done in kqueue.go.\n. Backing this PR out for now.\n. @jiangytcn \nIs it possible that somewhere in your consuming code you instantiate a watcher, and assign it to a field on a struct by value, as opposed to a reference? In such case more than one mutexes are created to guard the same set of maps.\n. Let me illustrate what I mean with code. The following snippet will fail pretty reliably:\n```\npackage main\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n    \"path\"\n    \"strconv\"\n    \"time\"\n\"github.com/fsnotify/fsnotify\"\n\n)\ntype Test struct {\n    Watcher fsnotify.Watcher\n}\nfunc main() {\ntestDirPrefix := \"/tmp/test\"\n\nw, _ := fsnotify.NewWatcher()\nt := Test{Watcher: *w}\n\nfmt.Println(\"creating test dir\")\n\nconcDirs := 100\nfmt.Println(\"adding watchers...\")\nfor i := 0; i < concDirs; i++ {\n    dirName := path.Join(testDirPrefix, strconv.Itoa(i))\n    os.MkdirAll(dirName, 0700)\n    t.Watcher.Add(dirName)\n}\n\ngo func() {\n    fmt.Println(\"polling...\")\n    for {\n        select {\n        case <-t.Watcher.Events:\n        }\n    }\n}()\n\ntime.Sleep(time.Second)\n\nfor i := 0; i < concDirs; i++ {\n    dirName := path.Join(testDirPrefix, strconv.Itoa(i))\n    os.MkdirAll(dirName+\"/subdir\", 700)\n    go func() {\n        for {\n            t.Watcher.Add(dirName + \"/subdir\")\n            ioutil.WriteFile(path.Join(dirName, \"file\"), []byte(\"blah\"), 0600)\n            t.Watcher.Remove(dirName + \"/subdir\")\n        }\n    }()\n}\n\ntime.Sleep(time.Second)\n\nfmt.Println(\"cleaning up\")\ntime.Sleep(1 * time.Second)\nos.RemoveAll(testDirPrefix)\n\n}\n```\nuntil the following patch is applied\n```\ndiff --git a/example.go b/example-fix.go\nindex f9ccfc0..f555803 100644\n--- a/example.go\n+++ b/example-fix.go\n@@ -12,7 +12,7 @@ import (\n )\ntype Test struct {\n-   Watcher fsnotify.Watcher\n+   Watcher *fsnotify.Watcher\n }\nfunc main() {\n@@ -20,7 +20,7 @@ func main() {\n    testDirPrefix := \"/tmp/test\"\nw, _ := fsnotify.NewWatcher()\n\n\nt := Test{Watcher: *w}\n\nt := Test{Watcher: w}\nfmt.Println(\"creating test dir\")\n\n\n```\nPretty subtle. \n. The larger issue can probably be addressed this way (I might be missing something though):\n```\ndiff --git a/inotify.go b/inotify.go\nindex 9700df5..44f3aa6 100644\n--- a/inotify.go\n+++ b/inotify.go\n@@ -23,8 +23,8 @@ import (\n type Watcher struct {\n  Events   chan Event\n  Errors   chan error\n- mu       sync.Mutex // Map access\n- cv       sync.Cond // sync removing on rm_watch with IN_IGNORE\n+ mu       sync.Mutex // Map access\n+ cv       sync.Cond  // sync removing on rm_watch with IN_IGNORE\n  fd       int\n  poller   fdPoller\n  watches  map[string]watch // Map of inotify watches (key: path)\n@@ -55,8 +55,9 @@ func NewWatcher() (Watcher, error) {\n    Errors:   make(chan error),\n    done:     make(chan struct{}),\n    doneResp: make(chan struct{}),\n+   mu:       &sync.Mutex{},\n  }\n- w.cv = sync.NewCond(&w.mu)\n+ w.cv = sync.NewCond(w.mu)\ngo w.readEvents()\n  return w, nil\n```\nBut it would require some more extensive testing. What do you guys think about this solution?\n. @nathany Just a side note: this is not inotify-specific. The issue is reproducible on Darwin with kqueue, I just instructed the curious tester to fit print statements in inotify, but the same can be done in kqueue.go.\n. Backing this PR out for now.\n. ",
    "maja42": "I have a similar issue (reproducable) that might be caused by the same issue (at least the workaround of not removing the watcher worked for me too): https://github.com/fsnotify/fsnotify/issues/215. And yes, I use the version on the current master branch. The already existing issue https://github.com/fsnotify/fsnotify/issues/164 might be a duplicate?\nIf I remove the \"watcher.Remove(event.name)\" call, like it was suggested in one of the comments there, the deadlock does not happen.\nMaybe my .bat-script can help you to reproduce the issue? When I call it ~100 times, it happens nearly every time.. I have a similar issue (reproducable) that might be caused by the same issue (at least the workaround of not removing the watcher worked for me too): https://github.com/fsnotify/fsnotify/issues/215. And yes, I use the version on the current master branch. The already existing issue https://github.com/fsnotify/fsnotify/issues/164 might be a duplicate?\nIf I remove the \"watcher.Remove(event.name)\" call, like it was suggested in one of the comments there, the deadlock does not happen.\nMaybe my .bat-script can help you to reproduce the issue? When I call it ~100 times, it happens nearly every time.. ",
    "msolo": "Thanks for submitting this. Been on my list of things to push back for over a year.\n. Thanks for submitting this. Been on my list of things to push back for over a year.\n. ",
    "botherder": "Given the following snippet of code:\n```\npackage main\nimport (\n    \"log\"\n    \"github.com/botherder/fsnotify\"\n)\nfunc main() {\n    watcher, err := fsnotify.NewWatcher()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer watcher.Close()\ndone := make(chan bool)\ngo func() {\n    for {\n        select {\n        case event := <-watcher.Events:\n            if event.Op&fsnotify.Access == fsnotify.Access {\n                log.Println(\"ACCESS to /dev/video0!\")\n            }\n        case err := <-watcher.Errors:\n            log.Println(\"error:\", err)\n        }\n    }\n}()\n\nerr = watcher.Add(\"/dev/video0\")\nif err != nil {\n    log.Fatal(err)\n}\n<-done\n\n}\n```\nIt is not able to observe access events on /dev/video0. Given, this is using my fork with ACCESS events enabled, but I know that it works fine on other regular files.\nInstead using for example inotifywait /dev/video0, it does correctly trigger an event if the device is opened (e.g. by capturing the webcam using VLC):\nSetting up watches.\nWatches established.\n/dev/video0 OPEN\n. Not that I know, still not working for me.. @TheZ3ro it seems like you're doing exactly what I was setting out to do. I would be happy to collaborate on this project instead of duplicating efforts. Contact me if you want.. Given the following snippet of code:\n```\npackage main\nimport (\n    \"log\"\n    \"github.com/botherder/fsnotify\"\n)\nfunc main() {\n    watcher, err := fsnotify.NewWatcher()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer watcher.Close()\ndone := make(chan bool)\ngo func() {\n    for {\n        select {\n        case event := <-watcher.Events:\n            if event.Op&fsnotify.Access == fsnotify.Access {\n                log.Println(\"ACCESS to /dev/video0!\")\n            }\n        case err := <-watcher.Errors:\n            log.Println(\"error:\", err)\n        }\n    }\n}()\n\nerr = watcher.Add(\"/dev/video0\")\nif err != nil {\n    log.Fatal(err)\n}\n<-done\n\n}\n```\nIt is not able to observe access events on /dev/video0. Given, this is using my fork with ACCESS events enabled, but I know that it works fine on other regular files.\nInstead using for example inotifywait /dev/video0, it does correctly trigger an event if the device is opened (e.g. by capturing the webcam using VLC):\nSetting up watches.\nWatches established.\n/dev/video0 OPEN\n. Not that I know, still not working for me.. @TheZ3ro it seems like you're doing exactly what I was setting out to do. I would be happy to collaborate on this project instead of duplicating efforts. Contact me if you want.. ",
    "TheZ3ro": "Any news about this?. I'm working on detecting /dev/video* and /dev/bus/usb for a Go version of https://github.com/thez3ro/nsaway\nIt seems that the event on /dev/video* is an IN_OPEN and not IN_ACCESS.\n(you can test it with inotifywait /dev/video0 from inotify-tools1 package)\nI've made this patch https://github.com/TheZ3ro/fsnotify/commit/ed469fb0372648da575ad821e79fc0b607e33cc0 that works like a charm :wink:. Any news about this?. I'm working on detecting /dev/video* and /dev/bus/usb for a Go version of https://github.com/thez3ro/nsaway\nIt seems that the event on /dev/video* is an IN_OPEN and not IN_ACCESS.\n(you can test it with inotifywait /dev/video0 from inotify-tools1 package)\nI've made this patch https://github.com/TheZ3ro/fsnotify/commit/ed469fb0372648da575ad821e79fc0b607e33cc0 that works like a charm :wink:. ",
    "zchee": "@nathany Hi,\nI had plans to fork fsnotify and integrate the FSEvents because macOS's kqueue have some bugs.\nBTW, I would like to confirm just in case,\n\nthe best solution I can come up with is to split fsnotify into several platform-specific libraries\n\nIs It means like that?\n- fsnotify/inotify\n- fsnotify/kqueue\n- fsnotify/fsevents\nIf so and if we want to cross-platform project using fs watcher, Do we will need to import each platform packages to _darwin.go etc and will need to call a different API?\n. @nathany Ah, I see. Thanks.\nSo, split the repository by each of the platforms, and will add an API to integrate them on the fsnotify, right?\nAnyway, Apple has been announced apfs(Apple File System) and scheduled for release in 2017. Maybe filesystem interface also will change.\nI'll help you as much as possible.\n. @nathany Ah, it's for me? If so, I totally understood. Yes, API compatibility is very important. and I like your idea.\nI incorrectly wrote it. Not \"add\" an API to the fsnotify.\nI am terribly sorry to have caused confusion.\n. @nathany Hi,\nJust one thing, I just wanna tell you that you did the job is not poor.\nThe community(and Member) management, raise a problem of members shortage is very hard work. Not poor.\nSorry for my pull request was related the CI only. But I'll more learn the file-systems, and I will make an effort to contribute to the linux side(if possible). I'll do my best.. @nathany Hi,\nI had plans to fork fsnotify and integrate the FSEvents because macOS's kqueue have some bugs.\nBTW, I would like to confirm just in case,\n\nthe best solution I can come up with is to split fsnotify into several platform-specific libraries\n\nIs It means like that?\n- fsnotify/inotify\n- fsnotify/kqueue\n- fsnotify/fsevents\nIf so and if we want to cross-platform project using fs watcher, Do we will need to import each platform packages to _darwin.go etc and will need to call a different API?\n. @nathany Ah, I see. Thanks.\nSo, split the repository by each of the platforms, and will add an API to integrate them on the fsnotify, right?\nAnyway, Apple has been announced apfs(Apple File System) and scheduled for release in 2017. Maybe filesystem interface also will change.\nI'll help you as much as possible.\n. @nathany Ah, it's for me? If so, I totally understood. Yes, API compatibility is very important. and I like your idea.\nI incorrectly wrote it. Not \"add\" an API to the fsnotify.\nI am terribly sorry to have caused confusion.\n. @nathany Hi,\nJust one thing, I just wanna tell you that you did the job is not poor.\nThe community(and Member) management, raise a problem of members shortage is very hard work. Not poor.\nSorry for my pull request was related the CI only. But I'll more learn the file-systems, and I will make an effort to contribute to the linux side(if possible). I'll do my best.. ",
    "vahe": "See the first question in the FAQ, quoted below:\n\nWhen a file is moved to another directory is it still being watched?\nNo (it shouldn't be, unless you are watching where it was moved to).\n\nYou're watching the file instead of watching for the directory the file is in. Watch the parent directory, and check if the event Name matches test.txt.\n. @nathany @headwindfly I think copy/pasting FAQ contents into the README would be the most convenient since readme gets the most visibility. I had no idea that there was an fsnotify.org website, but I guess it wouldn't hurt to have it there too.\n. See the first question in the FAQ, quoted below:\n\nWhen a file is moved to another directory is it still being watched?\nNo (it shouldn't be, unless you are watching where it was moved to).\n\nYou're watching the file instead of watching for the directory the file is in. Watch the parent directory, and check if the event Name matches test.txt.\n. @nathany @headwindfly I think copy/pasting FAQ contents into the README would be the most convenient since readme gets the most visibility. I had no idea that there was an fsnotify.org website, but I guess it wouldn't hurt to have it there too.\n. ",
    "razonyang": "thanks\n. Sorry, this is my mistake, I did not notice the FAQ.\n@nathany I prefer to add FAQ in README (in my opinion, that will be more convenient and conspicuous):\n```\nFAQ\n\nquestion1\nquestion2\n....\n```\n. thanks\n. Sorry, this is my mistake, I did not notice the FAQ.\n\n@nathany I prefer to add FAQ in README (in my opinion, that will be more convenient and conspicuous):\n```\nFAQ\n\nquestion1\nquestion2\n....\n```\n. \n",
    "hekaldama": "I am not seeing that API. Maybe you are confused with: https://godoc.org/github.com/howeyc/fsnotify ?\n. I am not seeing that API. Maybe you are confused with: https://godoc.org/github.com/howeyc/fsnotify ?\n. ",
    "Allendar": "It doesn't seem to be that. When expanding the example this is the example code (as directly linked on the README of this project's Github page):\n```\nwatcher, err := fsnotify.NewWatcher()\nif err != nil {\n    log.Fatal(err)\n}\ndefer watcher.Close()\ndone := make(chan bool)\ngo func() {\n    for {\n        select {\n        case event := <-watcher.Events:\n            log.Println(\"event:\", event)\n            if event.Op&fsnotify.Write == fsnotify.Write {\n                log.Println(\"modified file:\", event.Name)\n            }\n        case err := <-watcher.Errors:\n            log.Println(\"error:\", err)\n        }\n    }\n}()\nerr = watcher.Add(\"/tmp/foo\")\nif err != nil {\n    log.Fatal(err)\n}\n<-done\n```\n. It doesn't seem to be that. When expanding the example this is the example code (as directly linked on the README of this project's Github page):\n```\nwatcher, err := fsnotify.NewWatcher()\nif err != nil {\n    log.Fatal(err)\n}\ndefer watcher.Close()\ndone := make(chan bool)\ngo func() {\n    for {\n        select {\n        case event := <-watcher.Events:\n            log.Println(\"event:\", event)\n            if event.Op&fsnotify.Write == fsnotify.Write {\n                log.Println(\"modified file:\", event.Name)\n            }\n        case err := <-watcher.Errors:\n            log.Println(\"error:\", err)\n        }\n    }\n}()\nerr = watcher.Add(\"/tmp/foo\")\nif err != nil {\n    log.Fatal(err)\n}\n<-done\n```\n. ",
    "glycerine": "probably addresses #145 as well.\n. confirmed. this patch makes test in #145 pass.\n. Ping.\nPlease merge this.. probably addresses #145 as well.\n. confirmed. this patch makes test in #145 pass.\n. Ping.\nPlease merge this.. ",
    "radu-munteanu": "I've created a new Op called \"Update\" on my fork, and used it on inotify to represent  unix.IN_CLOSE_WRITE  and unix.IN_MOVED_TO.\nhttps://github.com/radu-munteanu/fsnotify/commit/6638bfdb7939ba8a4687a44cdff21906d9b547c9\nWarning: I didn't write any tests for this Op.. @hallyn (1) As @nathany said, the fsnotify is more about being cross-platform than anything. The pull would only make this operation be useful on unix. (2) That I can do, if people need it. It's pretty easy to expand up to 32 Ops.\n@nathany The ugly part about exposing the mask is that, how it's written now, the watcher is filtering the notifications by those agnosticEvents, and we would need either to remove this part, or have a flags parameter. The first option will generate a lot of unwanted messages, the second option would make the fsnotify less cross-platform code friendly.\nI read that part about the spin-off. It's a great idea, but I saw that the project is empty. If someone who knows what they're doing (not me) would put the basic code there, I'd try to expand it with any functionality I need.\nOne thing that I think should change in the spin-off is how the Op is defined. It's pretty nice to do bit operations, but it constrains the numbers of Ops we can have.. @hallyn I've enabled the issues option on my fork. If you need that Op, write a new issue there. Thanks.. You won't get that merge approved, as it only works with one OS. Check this thread: https://github.com/fsnotify/fsnotify/issues/191 . Hi @runner365,\nYou're missing the part where you identify  unix.IN_CLOSE_WRITE with an operation.\nLook for the lines similar to this, and add your unix.IN_CLOSE_WRITE and unix.IN_CLOSE:\nif mask&unix.IN_ATTRIB == unix.IN_ATTRIB {\n        e.Op |= Chmod\n}\nYou can check my fork commit, where I add a totally new operation: https://github.com/radu-munteanu/fsnotify/commit/f8f617d6740c0f6861cebcf926c4c133aa3ba129. I've created a new Op called \"Update\" on my fork, and used it on inotify to represent  unix.IN_CLOSE_WRITE  and unix.IN_MOVED_TO.\nhttps://github.com/radu-munteanu/fsnotify/commit/6638bfdb7939ba8a4687a44cdff21906d9b547c9\nWarning: I didn't write any tests for this Op.. @hallyn (1) As @nathany said, the fsnotify is more about being cross-platform than anything. The pull would only make this operation be useful on unix. (2) That I can do, if people need it. It's pretty easy to expand up to 32 Ops.\n@nathany The ugly part about exposing the mask is that, how it's written now, the watcher is filtering the notifications by those agnosticEvents, and we would need either to remove this part, or have a flags parameter. The first option will generate a lot of unwanted messages, the second option would make the fsnotify less cross-platform code friendly.\nI read that part about the spin-off. It's a great idea, but I saw that the project is empty. If someone who knows what they're doing (not me) would put the basic code there, I'd try to expand it with any functionality I need.\nOne thing that I think should change in the spin-off is how the Op is defined. It's pretty nice to do bit operations, but it constrains the numbers of Ops we can have.. @hallyn I've enabled the issues option on my fork. If you need that Op, write a new issue there. Thanks.. You won't get that merge approved, as it only works with one OS. Check this thread: https://github.com/fsnotify/fsnotify/issues/191 . Hi @runner365,\nYou're missing the part where you identify  unix.IN_CLOSE_WRITE with an operation.\nLook for the lines similar to this, and add your unix.IN_CLOSE_WRITE and unix.IN_CLOSE:\nif mask&unix.IN_ATTRIB == unix.IN_ATTRIB {\n        e.Op |= Chmod\n}\nYou can check my fork commit, where I add a totally new operation: https://github.com/radu-munteanu/fsnotify/commit/f8f617d6740c0f6861cebcf926c4c133aa3ba129. ",
    "hallyn": "Hi, (1) are you planning on doing a pull request from your fork, and (2) would you by any chance consider adding a purer CLOSE (IN_CLOSE_WRITE|IN_CLOSE_NOWRITE) op?. Hi, (1) are you planning on doing a pull request from your fork, and (2) would you by any chance consider adding a purer CLOSE (IN_CLOSE_WRITE|IN_CLOSE_NOWRITE) op?. ",
    "willnorris": "The CLA is an agreement between the contributor and the project maintainer.  Since Google is neither of those, we wouldn't actually be party to the agreement, so I'm not sure that using the Google CLA makes sense.\nThe discussion in golang/go#17244 is interesting, and I'll have to talk with some folks next week to better understand the situation and what we can do in cases like this.  Feel free to ping me if you don't hear back in a while.\n. The CLA is an agreement between the contributor and the project maintainer.  Since Google is neither of those, we wouldn't actually be party to the agreement, so I'm not sure that using the Google CLA makes sense.\nThe discussion in golang/go#17244 is interesting, and I'll have to talk with some folks next week to better understand the situation and what we can do in cases like this.  Feel free to ping me if you don't hear back in a while.\n. ",
    "vladlosev": "What is happening here is that Linux's inotify actually delivers two notifications when a file is deleted. It first sends IN_ATTRIB to indicate that the number of file links have been decremented, and follows up by IN_DELETE_SELF to indicate that the file is deleted from disk. When some process is has open handles to the file, the file is not actually deleted from disk until all open handles are closed, and thus the second notification is also delayed. But fsnotify propagates only the second notification and drops the first one after statting the file name and seeing it gone.\nHere is a go test for this.\n```go\nfunc TestInotifyDeleteOpenFile(t *testing.T) {\n    testDir := tempMkdir(t)\n    defer os.RemoveAll(testDir)\ntestFile := filepath.Join(testDir, \"testfile\")\n\nhandle, err := os.Create(testFile)\nif err != nil {\n    t.Fatalf(\"Create failed: %v\", err)\n}\n\nw, err := NewWatcher()\nif err != nil {\n    t.Fatalf(\"Failed to create watcher: %v\", err)\n}\ndefer w.Close()\n\nerr = w.Add(testFile)\nif err != nil {\n    t.Fatalf(\"Failed to add watch for %s: %v\", testFile, err)\n}\n\nerr = os.Remove(testFile)\nif err != nil {\n    t.Fatalf(\"Failed to remove %s: %v\", testFile, err)\n}\n\nvar event Event\n\nfunc() {\n    defer handle.Close()\n\n    select {\n    case event = <-w.Events:\n    case <-time.After(100 * time.Millisecond):\n        t.Fatalf(\"Expected event not delivered\")\n    }\n}()\n\nif event.Op != Remove {\n    t.Fatalf(\"Expected event type %s, got: %v\", Remove, event.Op)\n}\n\nw.Close()\n\n// Wait for the close to complete.\ntime.Sleep(50 * time.Millisecond)\nisWatcherReallyClosed(t, w)\n\n}\n```\nI can see a few options for dealing with this, none of them perfect:\n 1. Convert the IN_ATTRIB notification into Remove for files which do not show up on disk. This will cause fsnotify to always deliver two Remove notifications. That may break some existing clients.\n 2. Deliver the Chmod notification even for files that do not appear on disk anymore. This will allow clients at least some notification about what's happening with the file. This will probably also affect some clients but I believe fewer are checking Chmod events than Delete ones.\n 3. Introduce a special watching mode that will treat open files correctly. This will require addition to the API.. What is happening here is that Linux's inotify actually delivers two notifications when a file is deleted. It first sends IN_ATTRIB to indicate that the number of file links have been decremented, and follows up by IN_DELETE_SELF to indicate that the file is deleted from disk. When some process is has open handles to the file, the file is not actually deleted from disk until all open handles are closed, and thus the second notification is also delayed. But fsnotify propagates only the second notification and drops the first one after statting the file name and seeing it gone.\nHere is a go test for this.\n```go\nfunc TestInotifyDeleteOpenFile(t *testing.T) {\n    testDir := tempMkdir(t)\n    defer os.RemoveAll(testDir)\ntestFile := filepath.Join(testDir, \"testfile\")\n\nhandle, err := os.Create(testFile)\nif err != nil {\n    t.Fatalf(\"Create failed: %v\", err)\n}\n\nw, err := NewWatcher()\nif err != nil {\n    t.Fatalf(\"Failed to create watcher: %v\", err)\n}\ndefer w.Close()\n\nerr = w.Add(testFile)\nif err != nil {\n    t.Fatalf(\"Failed to add watch for %s: %v\", testFile, err)\n}\n\nerr = os.Remove(testFile)\nif err != nil {\n    t.Fatalf(\"Failed to remove %s: %v\", testFile, err)\n}\n\nvar event Event\n\nfunc() {\n    defer handle.Close()\n\n    select {\n    case event = <-w.Events:\n    case <-time.After(100 * time.Millisecond):\n        t.Fatalf(\"Expected event not delivered\")\n    }\n}()\n\nif event.Op != Remove {\n    t.Fatalf(\"Expected event type %s, got: %v\", Remove, event.Op)\n}\n\nw.Close()\n\n// Wait for the close to complete.\ntime.Sleep(50 * time.Millisecond)\nisWatcherReallyClosed(t, w)\n\n}\n```\nI can see a few options for dealing with this, none of them perfect:\n 1. Convert the IN_ATTRIB notification into Remove for files which do not show up on disk. This will cause fsnotify to always deliver two Remove notifications. That may break some existing clients.\n 2. Deliver the Chmod notification even for files that do not appear on disk anymore. This will allow clients at least some notification about what's happening with the file. This will probably also affect some clients but I believe fewer are checking Chmod events than Delete ones.\n 3. Introduce a special watching mode that will treat open files correctly. This will require addition to the API.. ",
    "rvadim": "Im creating log forwarder and try to using fsnotify. Workaround this by getting stat every iteration =(. Im creating log forwarder and try to using fsnotify. Workaround this by getting stat every iteration =(. ",
    "aarondl": "Have the same issue here. Adding a goroutine really isn't a feasible alternative here since you need to check for errors and the goroutine that owns the watcher/list of watched directories (because we have no recursive API) needs to know when this goroutine succeeds or fails in order to go ahead with deletion from the watched dirs. This really complicates implementing the recursive watcher :(. Have the same issue here. Adding a goroutine really isn't a feasible alternative here since you need to check for errors and the goroutine that owns the watcher/list of watched directories (because we have no recursive API) needs to know when this goroutine succeeds or fails in order to go ahead with deletion from the watched dirs. This really complicates implementing the recursive watcher :(. ",
    "nullbio": "Having this problem as well, please see above reference. What can we do about this?. Same issues: #123 and #115 . An example of a library with problems that this patch fixes: https://github.com/markbates/refresh/issues/6. Having this problem as well, please see above reference. What can we do about this?. Same issues: #123 and #115 . An example of a library with problems that this patch fixes: https://github.com/markbates/refresh/issues/6. ",
    "gfrey": "@nathany I used VirtualBox with an OpenIndiana hipster install. I'll try and add support for solaris to your Vagrant Gopher, just give me a few days.. @nathany I used VirtualBox with an OpenIndiana hipster install. I'll try and add support for solaris to your Vagrant Gopher, just give me a few days.. ",
    "fazalmajid": "What can we do to get this PR accepted and merged into the master branch?\nThis is blocking getting https://github.com/spf13/hugo and https://github.com/prometheus/alertmanager (via https://github.com/stuartnelson3/guac) running on Solaris.\nI confirmed that this branch merged into master works on SmartOS inside Hugo (running hugo --watch) whereas without it it just exits with the message FEN based watcher not yet supported for fsnotify. Even if gfrey's code has bugs, it can't be any more broken on Solaris than the stub in the master branch. Furthermore, fen.go is marked as +build solaris so there is zero risk of regression on other platforms.. What can we do to get this PR accepted and merged into the master branch?\nThis is blocking getting https://github.com/spf13/hugo and https://github.com/prometheus/alertmanager (via https://github.com/stuartnelson3/guac) running on Solaris.\nI confirmed that this branch merged into master works on SmartOS inside Hugo (running hugo --watch) whereas without it it just exits with the message FEN based watcher not yet supported for fsnotify. Even if gfrey's code has bugs, it can't be any more broken on Solaris than the stub in the master branch. Furthermore, fen.go is marked as +build solaris so there is zero risk of regression on other platforms.. ",
    "binarycrusader": "I'm not the author, but Solaris requires use of cgo, in general, since libc is the provider of system interfaces.  The only other comment I would add is that this should be using golang.org/x/sys/unix instead of syscall.  Per the official Go documentation, use of syscall outside of the Go standard runtime has been deprecated since 1.4:\n\nNOTE: This package is locked down. Code outside the standard Go repository should be migrated to use the corresponding package in the golang.org/x/sys repository. That is also where updates required by new systems or versions should be applied. See https://golang.org/s/go1.4-syscall for more information. \nhttps://golang.org/pkg/syscall/\n\nAs far as I can tell, this should work on commercial releases of Solaris, although I haven't tried it myself.  It appears to be using functionality shared between Solaris and OpenSolaris-based derivatives such as Illumos/SmartOS.. I'm not the author, but Solaris requires use of cgo, in general, since libc is the provider of system interfaces.  The only other comment I would add is that this should be using golang.org/x/sys/unix instead of syscall.  Per the official Go documentation, use of syscall outside of the Go standard runtime has been deprecated since 1.4:\n\nNOTE: This package is locked down. Code outside the standard Go repository should be migrated to use the corresponding package in the golang.org/x/sys repository. That is also where updates required by new systems or versions should be applied. See https://golang.org/s/go1.4-syscall for more information. \nhttps://golang.org/pkg/syscall/\n\nAs far as I can tell, this should work on commercial releases of Solaris, although I haven't tried it myself.  It appears to be using functionality shared between Solaris and OpenSolaris-based derivatives such as Illumos/SmartOS.. ",
    "4ad": "I don't care about fsnotify, so you'll have to find someone else to review this, but I will point out that using cgo here is an unnecessary mistake. This should all be done using golang.org/x/sys/unix (probably after you update it).. I don't care about fsnotify, so you'll have to find someone else to review this, but I will point out that using cgo here is an unnecessary mistake. This should all be done using golang.org/x/sys/unix (probably after you update it).. ",
    "quenelle": "Forgive any mistakes here, I'm very new to Go.  For this kind of code there seems to be a good justification for using the C pass through interfaces.  Probably lots of things don't have native Go interfaces yet.  Using \"syscall\" is another matter.  It's explicitly deprecated.  I see two places where syscall is used explicitly in the code.  1) It's used to access the enumeration of errno values.  When I visit x/sys/unix, it says that the official place to get errno values from is syscall.Errno.  (Check the top of https://godoc.org/golang.org/x/sys/unix) So that seems legitimate.  2) The other place it's used is to access the C structure for stat_t.  The code starts by using os.FileInfo, then goes through Sys() to get the stat_t.  It does this because the FileInfo doesn't include atime or ctime members. (access time / create time).  Only mtime (modification time) is available through FileInfo according to the docs.  So I don't see any way the code could be changed to avoid the existing uses of syscall.\nIn theory you could argue that atime and ctime should be added FileInfo, but that seems like a change that should take into account the availability of those interfaces on other platforms.  I'm not sure how widely they're supported on all the Go platforms.  It doesn't seem appropriate to ask the submitter to take that on at this point.\nSo with that in mind, I don't see any issues with the use of cgo or syscall.\nI also ran the fsnotify package test on x86 Oracle Solaris (latest internal build) with the bundled Go 1.5, and it passed.  I also ran it on the same Solaris build on SPARC with the latest sparc compiler from https://github.com/4ad/go/tree/sparc64.go1.8 and it passed.\nI'm not that familiar with file events in Solaris, but if additional code review is what's holding this up, I can find an Oracle Solaris engineer who is familiar with file events to check over the logic.  They won't be familiar with Go, but they could vouch for the usage of Solaris interfaces.\n. Forgive any mistakes here, I'm very new to Go.  For this kind of code there seems to be a good justification for using the C pass through interfaces.  Probably lots of things don't have native Go interfaces yet.  Using \"syscall\" is another matter.  It's explicitly deprecated.  I see two places where syscall is used explicitly in the code.  1) It's used to access the enumeration of errno values.  When I visit x/sys/unix, it says that the official place to get errno values from is syscall.Errno.  (Check the top of https://godoc.org/golang.org/x/sys/unix) So that seems legitimate.  2) The other place it's used is to access the C structure for stat_t.  The code starts by using os.FileInfo, then goes through Sys() to get the stat_t.  It does this because the FileInfo doesn't include atime or ctime members. (access time / create time).  Only mtime (modification time) is available through FileInfo according to the docs.  So I don't see any way the code could be changed to avoid the existing uses of syscall.\nIn theory you could argue that atime and ctime should be added FileInfo, but that seems like a change that should take into account the availability of those interfaces on other platforms.  I'm not sure how widely they're supported on all the Go platforms.  It doesn't seem appropriate to ask the submitter to take that on at this point.\nSo with that in mind, I don't see any issues with the use of cgo or syscall.\nI also ran the fsnotify package test on x86 Oracle Solaris (latest internal build) with the bundled Go 1.5, and it passed.  I also ran it on the same Solaris build on SPARC with the latest sparc compiler from https://github.com/4ad/go/tree/sparc64.go1.8 and it passed.\nI'm not that familiar with file events in Solaris, but if additional code review is what's holding this up, I can find an Oracle Solaris engineer who is familiar with file events to check over the logic.  They won't be familiar with Go, but they could vouch for the usage of Solaris interfaces.\n. ",
    "maxmeyer": "@dago Are you still into OpenCSW? Can their build farm help to solve the CI \"problem\" in this issue?\n. @dago Are you still into OpenCSW? Can their build farm help to solve the CI \"problem\" in this issue?\n. ",
    "756445638": "one for open,one for write?? . my bad,io.WritFile will  open with parameter os.O_TRUNC,so I can see two modify event!!. one for open,one for write?? . my bad,io.WritFile will  open with parameter os.O_TRUNC,so I can see two modify event!!. ",
    "betim": "@radu-munteanu, you mean it does not work in one OS?\nI totally understand that fsnotify tends to be as cross-platform as possible. But not implementing something rather essential I cannot. Besides windows has file locking so combination of file locking and Op.Write event should give windows programmer freedom to implement the same functionality as getting Op.Close on linux.. @bevand10 - I'm using my own fork for this, it works very well.. @radu-munteanu, you mean it does not work in one OS?\nI totally understand that fsnotify tends to be as cross-platform as possible. But not implementing something rather essential I cannot. Besides windows has file locking so combination of file locking and Op.Write event should give windows programmer freedom to implement the same functionality as getting Op.Close on linux.. @bevand10 - I'm using my own fork for this, it works very well.. ",
    "bevand10": "@betim - I'd recommend switching to this fork as it'll better suit your needs by supporting IN_CLOSE_WRITE https://github.com/ericbrisrubio/fsnotify. @betim - I'd recommend switching to this fork as it'll better suit your needs by supporting IN_CLOSE_WRITE https://github.com/ericbrisrubio/fsnotify. ",
    "Dmitry-N-Medvedev": "@bevand10, Dave, if there is no IN_CLOSE_WRITE or similar operation how would one implement processing of newly created or changed files? I personally, being a nub tho, don't know how that could be implemented.\nWithout CLOSE operation the fsnotify seems to have next to now real-world application at all.. @bevand10, Dave, if there is no IN_CLOSE_WRITE or similar operation how would one implement processing of newly created or changed files? I personally, being a nub tho, don't know how that could be implemented.\nWithout CLOSE operation the fsnotify seems to have next to now real-world application at all.. ",
    "dmonay": "Apologies - sent the issue before typing it out.. Closing the issue as this is not a problem with fsnotify. Turns out this was caused by OpenDNS - I set two of their servers as my default DNS resolution servers and this led to system-wide issues with https. go get failed for a number of go packages that are hosted over https, including golang.org/x/sys.. Apologies - sent the issue before typing it out.. Closing the issue as this is not a problem with fsnotify. Turns out this was caused by OpenDNS - I set two of their servers as my default DNS resolution servers and this led to system-wide issues with https. go get failed for a number of go packages that are hosted over https, including golang.org/x/sys.. ",
    "jokerbo1": "@dmonay  Hi, now i meet the problem , Can you tell me solution method?. @dmonay  Hi, now i meet the problem , Can you tell me solution method?. ",
    "jlory": "Any updates on that? I'm having errors using trigger on large file being written because IN_CLOSE_WRITE  is not yet implemented.. Any updates on that? I'm having errors using trigger on large file being written because IN_CLOSE_WRITE  is not yet implemented.. ",
    "vyarmak": "Same issue with GoLand and https://www.jetbrains.com/go/. Same issue with GoLand and https://www.jetbrains.com/go/. ",
    "stonyz": "I encounter the same issue when debug mattermost which is using fsnotify. . I encounter the same issue when debug mattermost which is using fsnotify. . ",
    "enashed": "+1 I have the same issue. +1 I have the same issue. ",
    "DenKoren": "+1 The same one. \n\n>go version\ngo version go1.9 darwin/amd64\n[[constraint]]\n  name = \"github.com/fsnotify/fsnotify\"\n  version = \"1.4.2\"\n\nMacOSX 10.12.6 (16G29). +1 The same one. \n\n>go version\ngo version go1.9 darwin/amd64\n[[constraint]]\n  name = \"github.com/fsnotify/fsnotify\"\n  version = \"1.4.2\"\n\nMacOSX 10.12.6 (16G29). ",
    "stevekuznetsov": "Looks like ( on Linux, anyway ) the errors will be those from epoll_wait, so the following could be possible:\n```\n       EBADF  epfd is not a valid file descriptor.\n   EFAULT The memory area pointed to by events is not accessible with\n          write permissions.\n\n   EINTR  The call was interrupted by a signal handler before either (1)\n          any of the requested events occurred or (2) the timeout\n          expired; see signal(7).\n\n   EINVAL epfd is not an epoll file descriptor, or maxevents is less\n          than or equal to zero.\n\n```\nI would expect EBADF to be exposed in the fsnotify.Watcher#Add() call, the runtime should ensure EFAULT doesn't occur, EINTR will kill the whole process (??) and EINVAL would invalidate the watch?. Looks like ( on Linux, anyway ) the errors will be those from epoll_wait, so the following could be possible:\n```\n       EBADF  epfd is not a valid file descriptor.\n   EFAULT The memory area pointed to by events is not accessible with\n          write permissions.\n\n   EINTR  The call was interrupted by a signal handler before either (1)\n          any of the requested events occurred or (2) the timeout\n          expired; see signal(7).\n\n   EINVAL epfd is not an epoll file descriptor, or maxevents is less\n          than or equal to zero.\n\n```\nI would expect EBADF to be exposed in the fsnotify.Watcher#Add() call, the runtime should ensure EFAULT doesn't occur, EINTR will kill the whole process (??) and EINVAL would invalidate the watch?. ",
    "bo0rsh201": "Thank you for answer. As for now I see that this remove is 99% useless in my case, because you force remove on DELETE event for directory, so I don't need to call it (maybe in case when we don't watch parent dir, but a couple of separate dirs with different unwatched parents). Thank you for answer. As for now I see that this remove is 99% useless in my case, because you force remove on DELETE event for directory, so I don't need to call it (maybe in case when we don't watch parent dir, but a couple of separate dirs with different unwatched parents). ",
    "pwaller": "I can confirm that this fixes a problem I see, too. Bit surprised this wasn't fixed in #178.. I can confirm that this fixes a problem I see, too. Bit surprised this wasn't fixed in #178.. ",
    "Asoseil": "there was a problem of my sftp client . there was a problem of my sftp client . ",
    "thaJeztah": "ping @markbates @nathany ptal \ud83e\udd17 . Thanks! I'll await @nathany's input \ud83d\udc4d . Ah, I see (apologies; haven't really followed this project myself, only arrived here because of the linked issue); number of changes since March isn't huge; https://github.com/fsnotify/fsnotify/compare/v1.4.2...master\nLet me look around as well if there's maintainers, or contributors in the Moby project that would be able to help out on this project. ping @markbates @nathany ptal \ud83e\udd17 . Thanks! I'll await @nathany's input \ud83d\udc4d . Ah, I see (apologies; haven't really followed this project myself, only arrived here because of the linked issue); number of changes since March isn't huge; https://github.com/fsnotify/fsnotify/compare/v1.4.2...master\nLet me look around as well if there's maintainers, or contributors in the Moby project that would be able to help out on this project. ",
    "markbates": "I agree a new version is probably warranted. I don't have the insight into the package to determine if that's ok or not. @nathany is probably in the best position to make that call.. I agree a new version is probably warranted. I don't have the insight into the package to determine if that's ok or not. @nathany is probably in the best position to make that call.. "
}